ObjectId),
                                       0) == sizeof(SourceObjectId.BirthObjectId)) {
                        status = STATUS_SUCCESS;
                        leave;
                    }

                    //
                    // Query the volume ID of the target.
                    //

                    status = IopGetSetObjectId( dstFileObject,
                                                &TargetVolumeId,
                                                sizeof( FILE_VOLUMEID_WITH_TYPE ),
                                                FSCTL_LMR_GET_LINK_TRACKING_INFORMATION );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Query the object ID of the target.
                    //

                    status = IopGetSetObjectId( dstFileObject,
                                                &TargetObjectId,
                                                sizeof( TargetObjectId ),
                                                FSCTL_CREATE_OR_GET_OBJECT_ID );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Notify the tracking system of the move.
                    //

                    IopMarshalIds( &trackingBuffer, &TargetVolumeId, &TargetObjectId, trackingInfo );
                    status = IopTrackLink( FileObject,
                                           IoStatusBlock,
                                           &trackingBuffer.TrackingInformation,
                                           FIELD_OFFSET( FILE_TRACKING_INFORMATION,
                                                ObjectInformation ) +
                                                    trackingBuffer.TrackingInformation.ObjectInformationLength,
                                           Event,
                                           KernelMode );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Delete the ID from the source
                    //

                    status = IopGetSetObjectId( FileObject,
                                                NULL,
                                                0,
                                                FSCTL_DELETE_OBJECT_ID );
                    if( !NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Set the Birth ID on the target, turning on the bit
                    // that indicates that this file has been involved in a cross-
                    // volume move.
                    //

                    CrossVolumeObjectId = SourceObjectId;
                    CrossVolumeObjectId.BirthVolumeId[0] |= 1;

                    status = IopGetSetObjectId( dstFileObject,
                                                &CrossVolumeObjectId.ExtendedInfo[0],
                                                sizeof( CrossVolumeObjectId.ExtendedInfo ),
                                                FSCTL_SET_OBJECT_ID_EXTENDED );
                    if (!NT_SUCCESS( status )) {

                        // Try to restore the source
                        IopGetSetObjectId( FileObject,
                                           &SourceObjectId,
                                           sizeof(SourceObjectId),
                                           FSCTL_SET_OBJECT_ID );
                        leave;
                    }


                }   // if (IsFileLocal( dstFileObject ))

            } else {    // if (trackingInfo->DestinationFile)

                //
                // A destination file handle was not specified.  Simply query
                // the source file's object ID and call the link tracking code.
                // Note that the function input buffer contains the volume ID
                // and file object ID of the target.  Note also that it is
                // assumed that the source file has an object ID.
                //

                status = IopGetVolumeId( FileObject,
                                         &SourceVolumeId,
                                         sizeof( SourceVolumeId ) );
                if (!NT_SUCCESS( status )) {
                    leave;
                }

                status = IopGetSetObjectId( FileObject,
                                            &SourceObjectId,
                                            sizeof( SourceObjectId ),
                                            FSCTL_GET_OBJECT_ID );
                if (!NT_SUCCESS( status )) {
                    leave;
                }

                //
                // If the extended info field is zero then this file
                // has no interesting tracking information.
                //
                if (RtlCompareMemoryUlong(SourceObjectId.BirthObjectId,
                                       sizeof(SourceObjectId.BirthObjectId),
                                       0) == sizeof(SourceObjectId.BirthObjectId)) {
                    status = STATUS_SUCCESS;
                    leave;
                }
                //
                // Inform the user-mode link tracking service that the file
                // has been moved.
                //

                NormalizedObjectId = SourceObjectId;
                NormalizedObjectId.BirthVolumeId[0] &= 0xfe;

                status = IopSendMessageToTrackService( &SourceVolumeId,
                                                       &NormalizedObjectId,
                                                       FileInformation );
                if (!NT_SUCCESS( status )) {
                    leave;
                }

            }   // if (trackingInfo->DestinationFile) ... else

        } else {    // if (IsFileLocal( FileObject ))

            //
            // The source file is remote.  For this case, remote the operation
            // to the system on which the source file is located.  Begin by
            // ensuring that the source file actually has an object ID.  If
            // not, then get out now since there is nothing to be done.
            //

            status = IopGetSetObjectId( FileObject,
                                        &SourceObjectId,
                                        sizeof( SourceObjectId ),
                                        FSCTL_GET_OBJECT_ID );

            if (status == STATUS_OBJECT_NAME_NOT_FOUND)
            {
                status = STATUS_SUCCESS;
                leave;
            }

            if (!NT_SUCCESS( status )) {
                leave;
            }

            //
            // If the extended info field is zero then this file
            // has no interesting tracking information.
            //
            if (RtlCompareMemoryUlong(SourceObjectId.BirthObjectId,
                                      sizeof(SourceObjectId.BirthObjectId),
                                      0) == sizeof(SourceObjectId.BirthObjectId)) {
                status = STATUS_SUCCESS;
                leave;
            }
            if (trackingInfo->DestinationFile) {

                //
                // A handle was specified for the destination file.  Determine
                // whether it is local or remote.  If remote and both handles
                // refer to the same machine, then ship the entire API to that
                // machine and have it perform the operation.
                //
                // Otherwise, query the target file's object ID, and then redo
                // the operation.  This will cause the API to be remoted to the
                // machine where the source file resides.
                //

                if (IsFileLocal( dstFileObject )) {

                    //
                    // The source is remote and the destination is local, so
                    // query the object ID of the target and recursively track
                    // the link from the source file's remote node.
                    //

                    status = IopGetVolumeId( dstFileObject,
                                             &TargetVolumeId,
                                             sizeof( TargetVolumeId ) );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    status = IopGetSetObjectId( dstFileObject,
                                                &TargetObjectId,
                                                sizeof( TargetObjectId ),
                                                FSCTL_CREATE_OR_GET_OBJECT_ID );
                    if (!NT_SUCCESS( status )) {
                        leave;
                    }


                    //
                    // Notify the tracking system of the move.
                    //

                    IopMarshalIds( &trackingBuffer, &TargetVolumeId, &TargetObjectId, trackingInfo );

                    status = IopTrackLink( FileObject,
                                           IoStatusBlock,
                                           &trackingBuffer.TrackingInformation,
                                           FIELD_OFFSET( FILE_TRACKING_INFORMATION,
                                                ObjectInformation ) +
                                                    trackingBuffer.TrackingInformation.ObjectInformationLength,
                                           Event,
                                           KernelMode );
                    if( !NT_SUCCESS(status) ) {
                        leave;
                    }

                    //
                    //  Delete the ID from the source
                    //

                    status = IopGetSetObjectId( FileObject,
                                                NULL,
                                                0,
                                                FSCTL_DELETE_OBJECT_ID );
                    if( !NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Set the birth ID on the target, also turning on the bit
                    // that indicates that this file has moved across volumes.
                    //

                    CrossVolumeObjectId = SourceObjectId;
                    CrossVolumeObjectId.BirthVolumeId[0] |= 1;

                    status = IopGetSetObjectId( dstFileObject,
                                                &CrossVolumeObjectId.ExtendedInfo[0],
                                                sizeof( CrossVolumeObjectId.ExtendedInfo ),
                                                FSCTL_SET_OBJECT_ID_EXTENDED );

                    if( !NT_SUCCESS( status )) {

                        IopGetSetObjectId( FileObject,
                                           &SourceObjectId,
                                           sizeof(SourceObjectId),
                                           FSCTL_SET_OBJECT_ID );
                        leave;
                    }

                }   // if (IsFileLocal( dstFileObject ))

                else if (!IopIsSameMachine( FileObject, trackingInfo->DestinationFile)) {

                    //
                    // The source and the target are remote from each other and from
                    // this machine.  Query the object ID of the target and recursively
                    // track the link from the source file's remote node.
                    //

                    //
                    // Query the volume ID of the target.
                    //

                    status = IopGetSetObjectId( dstFileObject,
                                                &TargetVolumeId,
                                                sizeof( FILE_VOLUMEID_WITH_TYPE ),
                                                FSCTL_LMR_GET_LINK_TRACKING_INFORMATION );

                    if (!NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Query the object ID of the target.
                    //

                    status = IopGetSetObjectId( dstFileObject,
                                                &TargetObjectId,
                                                sizeof( TargetObjectId ),
                                                FSCTL_CREATE_OR_GET_OBJECT_ID );
                    if( !NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Notify the tracking system of the move.
                    //

                    IopMarshalIds( &trackingBuffer, &TargetVolumeId, &TargetObjectId, trackingInfo );

                    status = IopTrackLink( FileObject,
                                           IoStatusBlock,
                                           &trackingBuffer.TrackingInformation,
                                           FIELD_OFFSET( FILE_TRACKING_INFORMATION,
                                                ObjectInformation ) +
                                                    trackingBuffer.TrackingInformation.ObjectInformationLength,
                                           Event,
                                           KernelMode );
                    if( !NT_SUCCESS( status )) {
                        leave;
                    }

                    //
                    // Set the birth ID on the target, turning on the bit that indicates
                    // that this file has moved across volumes.
                    //

                    CrossVolumeObjectId = SourceObjectId;
                    CrossVolumeObjectId.BirthVolumeId[0] |= 1;

                    status = IopGetSetObjectId( dstFileObject,
                                                &CrossVolumeObjectId.ExtendedInfo[0],
                                                sizeof( CrossVolumeObjectId.ExtendedInfo ),
                                                FSCTL_SET_OBJECT_ID_EXTENDED );

                    if( !NT_SUCCESS( status )) {
                        IopGetSetObjectId( FileObject,
                                           &SourceObjectId,
                                           sizeof(SourceObjectId),
                                           FSCTL_SET_OBJECT_ID );
                        leave;
                    }

                } else {    // else if (!IopIsSameMachine( FileObject, trackingInfo->DestinationFile))

                    //
                    // Both the source and the target are remote and they're
                    // both on the same remote machine.  For this case, remote
                    // the entire API using the file object pointers.
                    //

                    status = IopSetRemoteLink( FileObject, dstFileObject, trackingInfo );

                }   // else if (!IopIsSameMachine( FileObject, trackingInfo->DestinationFile)) ... else

            } else {    // if (trackingInfo->DestinationFile)

                //
                // The source file is remote and the object ID of the target is
                // contained w/in the tracking buffer.  Simply remote the API
                // to the remote machine using the source file object pointer
                // and the object ID of the target in the buffer.
                //

                status = IopSetRemoteLink( FileObject, NULL, FileInformation );

            }   // if (trackingInfo->DestinationFile) ... else
        }   // if (IsFileLocal( FileObject )) ... else

    } finally {

        //
        // Ensure that everything has been cleaned up.
        //

        if (RequestorMode != KernelMode && trackingInfo) {
            ExFreePool( trackingInfo );
        }

        if (dstFileObject ) {
            ObDereferenceObject( dstFileObject );
        }

        KeSetEvent( Event, 0, FALSE );
    }

    return status;
}

VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine is invoked in the final processing of an IRP.  Everything has
    been completed except that the caller's APC routine must be invoked.  The
    system will do this as soon as this routine exits.  The only processing
    remaining to be completed by the I/O system is to free the I/O Request
    Packet itself.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

Note:

    If no other processing is ever needed, and the APC can be placed at the
    beginning of the IRP, then this routine could be replaced by simply
    specifying the address of the pool deallocation routine in the APC instead
    of the address of this routine.

Caution:

    This routine is also invoked as a general purpose rundown routine for APCs.
    Should this code ever need to directly access any of the other parameters
    other than Apc, this routine will need to be split into two separate
    routines.  The rundown routine should perform exactly the following code's
    functionality.

--*/

{
    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    PAGED_CODE();

    //
    // Free the packet.
    //

    IoFreeIrp( CONTAINING_RECORD( Apc, IRP, Tail.Apc ) );
}



VOID
IopUserRundown(
    IN PKAPC Apc
    )

/*++

Routine Description:

    This routine is invoked during thread termination as the rundown routine
    for it simply calls IopUserCompletion.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

Return Value:

    None.


--*/

{
    PAGED_CODE();

    //
    // Free the packet.
    //

    IoFreeIrp( CONTAINING_RECORD( Apc, IRP, Tail.Apc ) );
}

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the driver associated with the file handle.
    handle.  It is up to the driver to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        driver.  Whether or not the buffer is actually optional is dependent
        on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

    DeviceIoControl - Determines whether this is a Device or File System
        Control function.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT eventObject = (PKEVENT) NULL;
    PIO_STACK_LOCATION irpSp;
    ULONG method;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    IO_STATUS_BLOCK localIoStatus;
    PFAST_IO_DISPATCH fastIoDispatch;
    POOL_TYPE poolType;
    PULONG majorFunction;
    KPROCESSOR_MODE requestorMode;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the method that the buffers are being passed by.
    //

    method = IoControlCode & 3;

    //
    // Check the caller's parameters based on the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The output buffer can be used in any one of the following three ways,
            // if it is specified:
            //
            //     0) It can be a normal, buffered output buffer.
            //
            //     1) It can be a DMA input buffer.
            //
            //     2) It can be a DMA output buffer.
            //
            // Which way the buffer is to be used it based on the low-order two bits
            // of the IoControlCode.
            //
            // If the method is 0 we probe the output buffer for write access.
            // If the method is not 3 we probe the input buffer for read access.
            //

            if (method == METHOD_BUFFERED) {
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    ProbeForWrite( OutputBuffer,
                                   OutputBufferLength,
                                   sizeof( UCHAR ) );
                } else {
                    OutputBufferLength = 0;
                }
            }

            if (method != METHOD_NEITHER) {
                if (ARGUMENT_PRESENT( InputBuffer )) {
                    ProbeForRead( InputBuffer,
                                  InputBufferLength,
                                  sizeof( UCHAR ) );
                } else {
                    InputBufferLength = 0;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to probe or write
            // one of the caller's parameters.  Simply return an appropriate
            // error status code.
            //

            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now check the access type for this control code to ensure that the
    // caller has the appropriate access to this file object to perform the
    // operation.
    //

    if (requestorMode != KernelMode) {

        ULONG accessMode = (IoControlCode >> 14) & 3;

        if (accessMode != FILE_ANY_ACCESS) {

            //
            // This I/O control requires that the caller have read, write,
            // or read/write access to the object.  If this is not the case,
            // then cleanup and return an appropriate error status code.
            //

            if (SeComputeGrantedAccesses( handleInformation.GrantedAccess, accessMode ) != accessMode ) {
                ObDereferenceObject( fileObject );
                return STATUS_ACCESS_DENIED;
            }
        }
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }

    if (DeviceIoControl) {

        //
        // Also get the address of the Fast I/O dispatch structure.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        //
        // Turbo device control support.  If the device has a fast I/O entry
        // point for DeviceIoControlFile, call the entry point and give it a
        // chance to try to complete the request.  Note if FastIoDeviceControl
        // returns FALSE or we get an I/O error, we simply fall through and
        // go the "long way" and create an Irp.
        //

        if (fastIoDispatch && fastIoDispatch->FastIoDeviceControl) {

            //
            // Before we actually call the fast I/O routine in the driver,
            // we must probe OutputBuffer if the method is METHOD_IN_DIRECT or METHOD_OUT_DIRECT.
            //

            if (requestorMode != KernelMode && ARGUMENT_PRESENT(OutputBuffer)) {

                try {

                    if (method == METHOD_IN_DIRECT) {
                        ProbeForRead( OutputBuffer,
                                      OutputBufferLength,
                                      sizeof( UCHAR ) );
                    } else if (method == METHOD_OUT_DIRECT) {
                        ProbeForWrite( OutputBuffer,
                                       OutputBufferLength,
                                       sizeof( UCHAR ) );
                    }

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    //
                    // An exception was incurred while attempting to probe
                    // the output buffer.  Clean up and return an
                    // appropriate error status code.
                    //

                    if (synchronousIo) {
                        IopReleaseFileObjectLock( fileObject );
                    }

                    if (eventObject) {
                        ObDereferenceObject( eventObject );
                    }

                    ObDereferenceObject( fileObject );

                    return GetExceptionCode();
                }
            }

            //
            // If we are dismounting a volume, increment the shared count.  This
            // allows user-space applications to efficiently test for validity
            // of current directory handles.
            //

            if (IoControlCode == FSCTL_DISMOUNT_VOLUME) {
                InterlockedIncrement( (PLONG) &SharedUserData->DismountCount );
            }


            //
            // Call the driver's fast I/O routine.
            //

            if (fastIoDispatch->FastIoDeviceControl( fileObject,
                                                     TRUE,
                                                     InputBuffer,
                                                     InputBufferLength,
                                                     OutputBuffer,
                                                     OutputBufferLength,
                                                     IoControlCode,
                                                     &localIoStatus,
                                                     deviceObject )) {

                PVOID port;
                PVOID key;

                //
                // The driver successfully performed the I/O in it's
                // fast device control routine.  Carefully return the
                // I/O status.
                //

                try {
#if defined(_WIN64)
                    //
                    // If this is a32-bit thread, and the IO request is
                    // asynchronous, then the IOSB is 32-bit. Wow64 always sends
                    // the 32-bit IOSB when the I/O is asynchronous.
                    //
                    if (IopIsIosb32(ApcRoutine)) {
                        PIO_STATUS_BLOCK32 UserIosb32 = (PIO_STATUS_BLOCK32)IoStatusBlock;

                        UserIosb32->Information = (ULONG)localIoStatus.Information;
                        UserIosb32->Status = (NTSTATUS)localIoStatus.Status;
                    } else {
                        *IoStatusBlock = localIoStatus;
                    }
#else
                    *IoStatusBlock = localIoStatus;
#endif
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }


                //
                // If there is an I/O completion port object associated w/this request,
                // save it here. We cannot look at the fileobject after signaling the
                // event as that might result in the attachment of a completion port.
                // This makes the behaviour consistent with the one in IopCompleteRequest.
                //

                if (fileObject->CompletionContext) {
                    port = fileObject->CompletionContext->Port;
                    key = fileObject->CompletionContext->Key;
                } else {
                    port = NULL;
                    key = NULL;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.  Release the
                // file object lock, if necessary.
                //

                if (synchronousIo) {
                    IopReleaseFileObjectLock( fileObject );
                }

                //
                // If this file object has a completion port associated with it
                // and this request has a non-NULL APC context then a completion
                // message needs to be queued.
                //

                if (port && ARGUMENT_PRESENT( ApcContext )) {
                    if (!NT_SUCCESS(IoSetIoCompletion( port,
                                                       key,
                                                       ApcContext,
                                                       localIoStatus.Status,
                                                       localIoStatus.Information,
                                                       TRUE ))) {
                        localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                //
                // Cleanup and return.
                //

                ObDereferenceObject( fileObject );
                return localIoStatus.Status;
            }
        }

    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );

    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = DeviceIoControl ? IRP_MJ_DEVICE_CONTROL : IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Set the pool type based on the type of function being performed.
    //

    poolType = DeviceIoControl ? NonPagedPoolCacheAligned : NonPagedPool;

    //
    // Based on the method that the buffer are being passed, either allocate
    // buffers or build MDLs.  Note that in some cases no probing has taken
    // place so the exception handler must catch access violations.
    //

    irp->MdlAddress = (PMDL) NULL;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;

    switch ( method ) {

    case METHOD_BUFFERED:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //

        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID) NULL;

        try {

            if (InputBufferLength || OutputBufferLength) {
                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( poolType,
                                             (InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength );

                if (ARGUMENT_PRESENT( InputBuffer )) {
                    RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                                   InputBuffer,
                                   InputBufferLength );
                }
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
                irp->UserBuffer = OutputBuffer;
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    irp->Flags |= IRP_INPUT_OPERATION;
                }
            } else {
                irp->Flags = 0;
                irp->UserBuffer = (PVOID) NULL;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either allocating the
            // the system buffer or moving the caller's data.  Determine
            // what actually happened, cleanup accordingly, and return
            // an appropriate error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            return GetExceptionCode();
        }

        break;

    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that the buffer length parameters have been jammed to zero for
        // users if the buffer parameter was not passed.  (Kernel callers
        // should be calling the service correctly in the first place.)
        //
        // Note also that it doesn't make a whole lot of sense to specify
        // either method #1 or #2 if the IOCTL does not require the caller
        // to specify an output buffer.
        //

        irp->Flags = 0;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID) NULL;

        try {

            if (InputBufferLength && ARGUMENT_PRESENT( InputBuffer )) {
                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( poolType,
                                             InputBufferLength );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            }

            if (OutputBufferLength != 0) {
                irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                                 OutputBufferLength,
                                                 FALSE,
                                                 TRUE,
                                                 irp  );
                if (irp->MdlAddress == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                IopProbeAndLockPages( irp->MdlAddress,
                                     requestorMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess),
                                       deviceObject,
                                      *majorFunction);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either allocating the
            // system buffer, copying the caller's data, allocating the
            // MDL, or probing and locking the caller's buffer. Determine
            // what actually happened, cleanup accordingly, and return
            // an appropriate error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            return GetExceptionCode();
        }

        break;

    case METHOD_NEITHER:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->Flags = 0;
        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

    //
    // Pass the read/write access granted bits down to the driver. This allows drivers to check
    // access for ioctls that were mistakenly defined as FILE_ANY_ACCESS and cannot be redefined for
    // compatibility reasons.
    //

    irpSp->Flags |= SeComputeGrantedAccesses( handleInformation.GrantedAccess, FILE_READ_DATA ) ? SL_READ_ACCESS_GRANTED : 0;
    irpSp->Flags |= SeComputeGrantedAccesses( handleInformation.GrantedAccess, FILE_WRITE_DATA ) ? SL_WRITE_ACCESS_GRANTED : 0;

    //
    // Defer I/O completion for FSCTL requests, but not for IOCTL requests,
    // since file systems set pending properly but device driver do not.
    //

    if (!DeviceIoControl) {
        irp->Flags |= IRP_DEFER_IO_COMPLETION;
    }

    //
    // If we are dismounting a volume, increment the shared count.  This
    // allows user-space applications to efficiently test for validity
    // of current directory handles.
    //

    if (IoControlCode == FSCTL_DISMOUNT_VOLUME) {
        InterlockedIncrement( (PLONG) &SharedUserData->DismountCount );
    }


    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      (BOOLEAN)!DeviceIoControl,
                                      requestorMode,
                                      synchronousIo,
                                      OtherTransfer );
}

NTSTATUS
IopLookupBusStringFromID (
    IN  HANDLE KeyHandle,
    IN  INTERFACE_TYPE InterfaceType,
    OUT PWCHAR Buffer,
    IN  ULONG Length,
    OUT PULONG BusFlags OPTIONAL
    )
/*++

Routine Description:

    Translates INTERFACE_TYPE to its corresponding WCHAR[] string.

Arguments:

    KeyHandle - Supplies a handle to the opened registry key,
        HKLM\System\CurrentControlSet\Control\SystemResources\BusValues.

    InterfaceType - Supplies the interface type for which a descriptive
        name is to be retrieved.

    Buffer - Supplies a pointer to a unicode character buffer that will
        receive the bus name.  Since this buffer is used in an
        intermediate step to retrieve a KEY_VALUE_FULL_INFORMATION structure,
        it must be large enough to contain this structure (including the
        longest value name & data length under KeyHandle).

    Length - Supplies the length, in bytes, of the Buffer.

    BusFlags - Optionally receives the flags specified in the second
        DWORD of the matching REG_BINARY value.

Return Value:

    The function value is the final status of the operation.

--*/
{
    NTSTATUS                        status;
    ULONG                           Index, junk, i, j;
    PULONG                          pl;
    PKEY_VALUE_FULL_INFORMATION     KeyInformation;
    WCHAR                           c;

    PAGED_CODE();

    Index = 0;
    KeyInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    for (; ;) {
        status = ZwEnumerateValueKey (
                        KeyHandle,
                        Index++,
                        KeyValueFullInformation,
                        Buffer,
                        Length,
                        &junk
                        );

        if (!NT_SUCCESS (status)) {
            return status;
        }

        if (KeyInformation->Type != REG_BINARY) {
            continue;
        }

        pl = (PULONG) ((PUCHAR) KeyInformation + KeyInformation->DataOffset);
        if ((ULONG) InterfaceType != pl[0]) {
            continue;
        }

        //
        // Found a match - move the name to the start of the buffer
        //

        if(ARGUMENT_PRESENT(BusFlags)) {
            *BusFlags = pl[1];
        }

        j = KeyInformation->NameLength / sizeof (WCHAR);
        for (i=0; i < j; i++) {
            c = KeyInformation->Name[i];
            Buffer[i] = c;
        }

        Buffer[i] = 0;
        return STATUS_SUCCESS;
    }
}


BOOLEAN
IopSafebootDriverLoad(
    PUNICODE_STRING DriverId
    )
/*++

Routine Description:

    Checks to see if a driver or service is included
    in the current safeboot registry section.

Arguments:

    DriverId - Specifies which driver is to be validated.
        The string should contain a driver executable name
        like foo.sys or a GUID for a pnp driver class.

Return Value:

    TRUE    - driver/service is in the registry
    FALSE   - driver/service is NOT in the registry

--*/
{
    NTSTATUS status;
    HANDLE hSafeBoot,hGuid;
    UNICODE_STRING safeBootKey;
    UNICODE_STRING SafeBootTypeString;



    //
    // set the first part of the registry key name
    //

    switch (InitSafeBootMode) {
        case SAFEBOOT_MINIMAL:
            RtlInitUnicodeString(&SafeBootTypeString,SAFEBOOT_MINIMAL_STR_W);
            break;

        case SAFEBOOT_NETWORK:
            RtlInitUnicodeString(&SafeBootTypeString,SAFEBOOT_NETWORK_STR_W);
            break;

        case SAFEBOOT_DSREPAIR:
            return TRUE;

        default:
            KdPrint(("SAFEBOOT: invalid safeboot option = %d\n",InitSafeBootMode));
            return FALSE;
    }

    safeBootKey.Length = 0;
    safeBootKey.MaximumLength = DriverId->Length + SafeBootTypeString.Length + (4*sizeof(WCHAR));
    safeBootKey.Buffer = (PWCHAR)ExAllocatePool(PagedPool,safeBootKey.MaximumLength);
    if (!safeBootKey.Buffer) {
        KdPrint(("SAFEBOOT: could not allocate pool\n"));
        return FALSE;
    }

    RtlCopyUnicodeString(&safeBootKey,&SafeBootTypeString);
    status = RtlAppendUnicodeToString(&safeBootKey,L"\\");
    if (!NT_SUCCESS(status)) {
        ExFreePool (safeBootKey.Buffer);
        KdPrint(("SAFEBOOT: could not create registry key string = %x\n",status));
        return FALSE;
    }
    status = RtlAppendUnicodeStringToString(&safeBootKey,DriverId);
    if (!NT_SUCCESS(status)) {
        ExFreePool (safeBootKey.Buffer);
        KdPrint(("SAFEBOOT: could not create registry key string = %x\n",status));
        return FALSE;
    }

    status = IopOpenRegistryKey (
        &hSafeBoot,
        NULL,
        &CmRegistryMachineSystemCurrentControlSetControlSafeBoot,
        KEY_ALL_ACCESS,
        FALSE
        );
    if (NT_SUCCESS(status)) {
        status = IopOpenRegistryKey (
            &hGuid,
            hSafeBoot,
            &safeBootKey,
            KEY_ALL_ACCESS,
            FALSE
            );
        ObCloseHandle(hSafeBoot, KernelMode);
        if (NT_SUCCESS(status)) {
            ObCloseHandle(hGuid, KernelMode);
            ExFreePool(safeBootKey.Buffer);
            return TRUE;
        }
    }

    ExFreePool(safeBootKey.Buffer);

    return FALSE;
}



#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif
static PBOOT_LOG_RECORD BootLogRecord;
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

VOID
IopInitializeBootLogging(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PCHAR HeaderString
    )
/*++

Routine Description:

    Initializes strings for boot logging.

Arguments:

    LoaderBlock - the loader parameter block

Return Value:

    VOID

--*/
{
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    PLIST_ENTRY nextEntry;
    PKLDR_DATA_TABLE_ENTRY driverEntry;


    PAGED_CODE();

    if (BootLogRecord != NULL) {
        return;
    }

    BootLogRecord = (PBOOT_LOG_RECORD) ExAllocatePool(NonPagedPool, sizeof(BOOT_LOG_RECORD));

    if (BootLogRecord == NULL) {
        return;
    }

    RtlZeroMemory(BootLogRecord, sizeof(BOOT_LOG_RECORD));

    ExInitializeResourceLite(&BootLogRecord->Resource);

    //
    // No need to do KeEnterCriticalRegion as this is called
    // from system process only.
    //
    ExAcquireResourceExclusiveLite(&BootLogRecord->Resource, TRUE);

    DataTableEntry = CONTAINING_RECORD(LoaderBlock->LoadOrderListHead.Flink,
                                        KLDR_DATA_TABLE_ENTRY,
                                        InLoadOrderLinks);

    Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0, BOOTLOG_LOADED, &MessageEntry);

    if (NT_SUCCESS( Status )) {
        AnsiString.Buffer = (PCHAR) MessageEntry->Text;
        AnsiString.Length = (USHORT)strlen((const char *)MessageEntry->Text);
        AnsiString.MaximumLength = AnsiString.Length + 1;

        RtlAnsiStringToUnicodeString(&BootLogRecord->LoadedString, &AnsiString, TRUE);

        // whack the crlf at the end of the string

        if (BootLogRecord->LoadedString.Length > 2 * sizeof(WCHAR)) {
            BootLogRecord->LoadedString.Length -= 2 * sizeof(WCHAR);
            BootLogRecord->LoadedString.Buffer[BootLogRecord->LoadedString.Length / sizeof(WCHAR)] = UNICODE_NULL;
        }
    }

    Status = RtlFindMessage (DataTableEntry->DllBase, 11, 0, BOOTLOG_NOT_LOADED, &MessageEntry);

    if (NT_SUCCESS( Status )) {
        AnsiString.Buffer = (PCHAR) MessageEntry->Text;
        AnsiString.Length = (USHORT)strlen((const char *)MessageEntry->Text);
        AnsiString.MaximumLength = AnsiString.Length + 1;

        RtlAnsiStringToUnicodeString(&BootLogRecord->NotLoadedString, &AnsiString, TRUE);

        // whack the crlf at the end of the string

        if (BootLogRecord->NotLoadedString.Length > 2 * sizeof(WCHAR)) {
            BootLogRecord->NotLoadedString.Length -= 2 * sizeof(WCHAR);
            BootLogRecord->NotLoadedString.Buffer[BootLogRecord->NotLoadedString.Length / sizeof(WCHAR)] = UNICODE_NULL;
        }
    }

    // The header string (copied from DebugString in Phase1Initialization) appears to have a leading null byte

    HeaderString++;

    RtlCreateUnicodeStringFromAsciiz(&BootLogRecord->HeaderString, HeaderString);

    // Log the drivers loaded by the boot loader

    ExAcquireResourceSharedLite( &PsLoadedModuleResource, TRUE );
    nextEntry = PsLoadedModuleList.Flink;
    while (nextEntry != &PsLoadedModuleList) {

        //
        // Look at the next boot driver in the list.
        //

        driverEntry = CONTAINING_RECORD( nextEntry,
                                         KLDR_DATA_TABLE_ENTRY,
                                         InLoadOrderLinks );

        IopBootLog(&driverEntry->FullDllName, TRUE);

        nextEntry = nextEntry->Flink;
    }

    ExReleaseResourceLite( &PsLoadedModuleResource );

    ExReleaseResourceLite(&BootLogRecord->Resource);
}

VOID
IopBootLog(
    PUNICODE_STRING LogEntry,
    BOOLEAN Loaded
    )
/*++

Routine Description:

    Create and write out a log entry.  Before NtInitializeRegistry is called, log entries are spooled
    into the registry.  When NtInitalizeRegistry is called by the session manager, the
    log file is created if necessary and truncated.  Log entries in the registry are
    then copied into the log file and the registry entries are deleted.

Arguments:

    LogEntry - the text to log.
    Loaded - indicates whether to prepend the "Loaded" string or the "Not Loaded" string.

Return Value:

    VOID


--*/
{
    WCHAR NameBuffer[BOOTLOG_STRSIZE];
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING CrLf;
    UNICODE_STRING Space;
    NTSTATUS Status;

    WCHAR MessageBuffer[BOOTLOG_STRSIZE];
    UNICODE_STRING MessageString = {
        0,
        BOOTLOG_STRSIZE,
        &MessageBuffer[0]
    };

    PAGED_CODE();

    if (BootLogRecord == NULL) {
        return;
    }

    //
    // No need to do KeEnterCriticalRegion as this is called
    // from system process only.
    //
    ExAcquireResourceExclusiveLite(&BootLogRecord->Resource, TRUE);

    if (Loaded) {
        RtlCopyUnicodeString(&MessageString, &BootLogRecord->LoadedString);
    } else {
        RtlCopyUnicodeString(&MessageString, &BootLogRecord->NotLoadedString);
    }

    // add a space after the message prefix

    RtlInitUnicodeString(&Space, L" ");

    RtlAppendUnicodeStringToString(&MessageString, &Space);

    RtlAppendUnicodeStringToString(&MessageString, LogEntry);

    // add a CR LF

    RtlInitUnicodeString(&CrLf, L"\r\n");
    RtlAppendUnicodeStringToString(&MessageString, &CrLf);

    swprintf(NameBuffer, L"%d", BootLogRecord->NextKey++);

    RtlCreateUnicodeString(&KeyName, NameBuffer);
    RtlInitUnicodeString(&ValueName, L"");

    if (!BootLogRecord->FileLogging) {
        HANDLE hLogKey, hBootKey;

        Status = IopOpenRegistryKey (
            &hBootKey,
            NULL,
            &CmRegistryMachineSystemCurrentControlSetControlBootLog,
            KEY_ALL_ACCESS,
            TRUE
            );

        if (NT_SUCCESS(Status)) {
            Status = IopOpenRegistryKey (
                &hLogKey,
                hBootKey,
                &KeyName,
                KEY_ALL_ACCESS,
                TRUE
                );
            if (NT_SUCCESS(Status)) {
                Status = IopSetRegistryStringValue(
                    hLogKey,
                    &ValueName,
                    &MessageString
                    );
                ZwClose(hLogKey);
            }
            ZwClose(hBootKey);
        }

    } else {
        IopBootLogToFile( &MessageString );
    }

    RtlFreeUnicodeString(&KeyName);

    ExReleaseResourceLite(&BootLogRecord->Resource);
}

VOID
IopCopyBootLogRegistryToFile(
    VOID
    )
/*++

Routine Description:

    Copy the text in the registry entries into the log file and delete the registry entries.  Set the
    flag that indicates direct logging to the log file.

Arguments:

    NONE

Return Value:

    VOID


--*/
{
    UNICODE_STRING KeyName;
    WCHAR NameBuffer[BOOTLOG_STRSIZE];
    NTSTATUS Status;
    HANDLE hLogKey, hBootKey;
    ULONG Index;
    PKEY_VALUE_FULL_INFORMATION Information;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    CHAR AnsiTimeBuffer[256];
    ANSI_STRING AnsiTimeString;
    UNICODE_STRING UnicodeTimeString;
    UNICODE_STRING LogString;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    if (BootLogRecord == NULL) {
        return;
    }

    CurrentThread = KeGetCurrentThread ();
    KeEnterCriticalRegionThread(CurrentThread);
    ExAcquireResourceExclusiveLite(&BootLogRecord->Resource, TRUE);

    IopBootLogToFile(&BootLogRecord->HeaderString);

    ExSystemTimeToLocalTime(&KeBootTime, &LocalTime);

    RtlTimeToTimeFields(&LocalTime, &TimeFields);

    sprintf(
        AnsiTimeBuffer,
        "%2d %2d %4d %02d:%02d:%02d.%03d\r\n",
        TimeFields.Month,
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second,
        TimeFields.Milliseconds
    );

    RtlInitAnsiString(&AnsiTimeString, AnsiTimeBuffer);

    RtlAnsiStringToUnicodeString(&UnicodeTimeString, &AnsiTimeString, TRUE);

    IopBootLogToFile(&UnicodeTimeString);

    RtlFreeUnicodeString(&UnicodeTimeString);

    //
    // Read all of the strings in the registry and write them to the log file.
    // Delete the registry keys when done.
    //

    Status = IopOpenRegistryKey (
        &hBootKey,
        NULL,
        &CmRegistryMachineSystemCurrentControlSetControlBootLog,
        KEY_ALL_ACCESS,
        FALSE
        );

    if (NT_SUCCESS(Status)) {
        for (Index = 0; Index < BootLogRecord->NextKey; Index++) {
            swprintf(NameBuffer, L"%d", Index);

            RtlCreateUnicodeString(&KeyName, NameBuffer);

            Status = IopOpenRegistryKey (
                &hLogKey,
                hBootKey,
                &KeyName,
                KEY_ALL_ACCESS,
                FALSE
                );

            if (NT_SUCCESS(Status)) {
                Status = IopGetRegistryValue(
                    hLogKey,
                    L"",
                    &Information
                    );

                if (NT_SUCCESS(Status)){
                    RtlInitUnicodeString(&LogString, (PWSTR) ((PUCHAR)Information + Information->DataOffset));
                    IopBootLogToFile(&LogString);
                }
                ExFreePool(Information);
                ZwDeleteKey(hLogKey);
                ZwClose(hLogKey);
            }
        }
        ZwDeleteKey(hBootKey);
        ZwClose(hBootKey);

        //
        // Write directly to the file from now on.
        //

        BootLogRecord->FileLogging = TRUE;
    }

    ExReleaseResourceLite(&BootLogRecord->Resource);
    KeLeaveCriticalRegionThread(CurrentThread);
}


NTSTATUS
IopBootLogToFile(
    PUNICODE_STRING String
    )
/*++

Routine Description:

    Write the buffer into the log file.

Arguments:

    Buffer - pointer to the string to write out.
    Length - number of bytes to write

Return Value:

    The function status is the final status of the operation.


--*/
{
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    WCHAR UnicodeHeader = 0xfeff;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    if (BootLogRecord == NULL) {
        return STATUS_SUCCESS;
    }

    CurrentThread = KeGetCurrentThread ();
    KeEnterCriticalRegionThread(CurrentThread);
    ExAcquireResourceExclusiveLite(&BootLogRecord->Resource, TRUE);

    if (BootLogRecord->LogFileName.Buffer == NULL) {
        RtlInitUnicodeString(&BootLogRecord->LogFileName, L"\\SystemRoot\\ntbtlog.txt");
    }

    InitializeObjectAttributes(&ObjA, &BootLogRecord->LogFileName, OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE, NULL, NULL);

    Status = ZwCreateFile(&FileHandle,
                            GENERIC_WRITE,
                            &ObjA,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ,
                            FILE_OPEN_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
                            NULL,
                            0
                            );

    if (NT_SUCCESS(Status)) {

        //
        // If the file is created for the first time, write the header.
        //

        if (IoStatusBlock.Information == FILE_CREATED) {

            Status = ZwWriteFile(
                        FileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        (PVOID) &UnicodeHeader,
                        sizeof(WCHAR),
                        NULL,
                        NULL
                        );
        }

        if (NT_SUCCESS(Status)) {

            LARGE_INTEGER EndOfFile;

            EndOfFile.HighPart = 0xffffffff;
            EndOfFile.LowPart = FILE_WRITE_TO_END_OF_FILE;

            Status = ZwWriteFile(
                        FileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        (PVOID) String->Buffer,
                        String->Length,
                        &EndOfFile,
                        NULL
                        );

        }

        ZwClose(FileHandle);
    }

    ExReleaseResourceLite(&BootLogRecord->Resource);
    KeLeaveCriticalRegionThread(CurrentThread);

    return Status;
}

PLIST_ENTRY
FASTCALL
IopInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This function inserts an entry at the head of a list using the I/O
    database lock for synchronization.

Arguments:

    Listhead - Supplies a pointer to the list head.

    ListEntry - Supplies a pointer to the list entry.

Return Value:

    If the list was previously empty, then NULL is returned as the function
    value. Otherwise, a pointer to the previous first entry in the list is
    returned as the function value.

--*/

{

    PLIST_ENTRY entry;
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    entry = ListHead->Flink;
    if ( entry == ListHead ) {
        entry = NULL;
    }

    InsertHeadList( ListHead, ListEntry );
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return entry;
}

PLIST_ENTRY
FASTCALL
IopInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This function inserts an entry at the tail of a list using the I/O
    database lock for synchronization.

Arguments:

    Listhead - Supplies a pointer to the list head.

    ListEntry - Supplies a pointer to the list entry.

Return Value:

    If the list was previously empty, then NULL is returned as the function
    value. Otherwise, a pointer to the previous last entry in the list is
    returned as the function value.

--*/

{

    PLIST_ENTRY entry;
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    entry = ListHead->Blink;
    if ( entry == ListHead) {
        entry = NULL;
    }

    InsertTailList( ListHead, ListEntry );
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return entry;
}

PLIST_ENTRY
FASTCALL
IopInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    This function removes the first entry form a list using the I/O database
    lock for synchronization.

Arguments:

    Listhead - Supplies a pointer to the list head.

Return Value:

    If the list is empty, then NULL is returned as the function value.
    Otherwise, a pointer to the first entry in the list is returned as
    the function value.

--*/

{

    PLIST_ENTRY entry;
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    entry = ListHead->Flink;
    if ( entry != ListHead ) {
        RemoveEntryList( entry );

    } else {
        entry = NULL;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return entry;
}

ULONG
FASTCALL
IopInterlockedDecrementUlong (
   IN KSPIN_LOCK_QUEUE_NUMBER Number,
   IN OUT PLONG Addend
   )

/*++

Routine Description:

    This function decrements the specified value using a queued spin lock
    for synchronization.

Arguments:

    Number - Supplies the number of the queued spin lock.

    Addend - Supplies a pointer to the variable to be decremented.

Return Value:

    The value of the variable before the decrement is applied.

--*/

{

    KIRQL irql;
    ULONG value;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (Number);
#endif

    irql = KeAcquireQueuedSpinLock( Number );
    value = * (PULONG) Addend;
    *Addend -= 1;
    KeReleaseQueuedSpinLock( Number, irql );
    return value;
}

ULONG
FASTCALL
IopInterlockedIncrementUlong (
   IN KSPIN_LOCK_QUEUE_NUMBER Number,
   IN OUT PLONG Addend
   )

/*++

Routine Description:

    This function increments the specified value using a queued spin lock
    for synchronization.

Arguments:

    Number - Supplies the number of the queued spin lock.

    Addend - Supplies a pointer to the variable to be incremented.

Return Value:

    The value of the variable before the increment is applied.

--*/

{

    KIRQL irql;
    ULONG value;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (Number);
#endif

    irql = KeAcquireQueuedSpinLock( Number );
    value = * (PULONG) Addend;
    *Addend += 1;
    KeReleaseQueuedSpinLock( Number, irql );
    return value;
}

BOOLEAN
IopCallBootDriverReinitializationRoutines(
    VOID
    )

/*++

Routine Description:

    This routine processes the boot driver reinitialization list.  It calls each
    entry and then removes it from the list.

Arguments:

    NONE

Returns:

    TRUE if any entries were processed.

--*/

{
    PLIST_ENTRY entry;
    PREINIT_PACKET reinitEntry;
    BOOLEAN routinesFound = FALSE;

    //
    // Walk the list reinitialization list in case this driver, or
    // some other driver, has requested to be invoked at a re-
    // initialization entry point.
    //

    while (entry = IopInterlockedRemoveHeadList( &IopBootDriverReinitializeQueueHead )) {
        routinesFound = TRUE;
        reinitEntry = CONTAINING_RECORD( entry, REINIT_PACKET, ListEntry );
        reinitEntry->DriverObject->DriverExtension->Count++;
        reinitEntry->DriverObject->Flags &= ~DRVO_BOOTREINIT_REGISTERED;
        reinitEntry->DriverReinitializationRoutine( reinitEntry->DriverObject,
                                                    reinitEntry->Context,
                                                    reinitEntry->DriverObject->DriverExtension->Count );
        ExFreePool( reinitEntry );
    }

    return routinesFound;
}

BOOLEAN
IopCallDriverReinitializationRoutines(
    VOID
    )

/*++

Routine Description:

    This routine processes the driver reinitialization list.  It calls each
    entry and then removes it from the list.

Arguments:

    NONE

Returns:

    TRUE if any entries were processed.

--*/

{
    PLIST_ENTRY entry;
    PREINIT_PACKET reinitEntry;
    BOOLEAN routinesFound = FALSE;

    PAGED_CODE();

    //
    // Walk the list reinitialization list in case this driver, or
    // some other driver, has requested to be invoked at a re-
    // initialization entry point.
    //

    while (entry = IopInterlockedRemoveHeadList( &IopDriverReinitializeQueueHead )) {
        routinesFound = TRUE;
        reinitEntry = CONTAINING_RECORD( entry, REINIT_PACKET, ListEntry );
        reinitEntry->DriverObject->DriverExtension->Count++;
        reinitEntry->DriverObject->Flags &= ~DRVO_REINIT_REGISTERED;
        reinitEntry->DriverReinitializationRoutine( reinitEntry->DriverObject,
                                                    reinitEntry->Context,
                                                    reinitEntry->DriverObject->DriverExtension->Count );
        ExFreePool( reinitEntry );
    }

    return routinesFound;
}

PDRIVER_OBJECT
IopReferenceDriverObjectByName (
    IN PUNICODE_STRING DriverName
    )

/*++

Routine Description:

    This routine references a driver object by a given driver name.

Arguments:

    DriverName - supplies a pointer to the name of the driver whose driver object is
        to be referenced.

Returns:

    A pointer to a DRIVER_OBJECT if succeeds.  Otherwise, a NULL value.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE driverHandle;
    NTSTATUS status;
    PDRIVER_OBJECT driverObject;

    //
    // Make sure the driver name is valid.
    //

    if (DriverName->Length == 0) {
        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               DriverName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                               );
    status = ObOpenObjectByName(&objectAttributes,
                                IoDriverObjectType,
                                KernelMode,
                                NULL,
                                FILE_READ_ATTRIBUTES,
                                NULL,
                                &driverHandle
                                );
    if (NT_SUCCESS(status)) {

        //
        // Now reference the driver object.
        //

        status = ObReferenceObjectByHandle(driverHandle,
                                           0,
                                           IoDriverObjectType,
                                           KernelMode,
                                           &driverObject,
                                           NULL
                                           );
        NtClose(driverHandle);
        if (NT_SUCCESS(status)) {
            return driverObject;
        }
    }

    return NULL;
}


PIRP
IopAllocateReserveIrp(
    IN CCHAR StackSize
    )
/*++

Routine Description:

    This routine allocates a reserve IRP for paging reads.

Arguments:

    StackSize - IRP stack size.

Return Value:

    The function value is an IRP.

--*/
{
    PIOP_RESERVE_IRP_ALLOCATOR  allocator = &IopReserveIrpAllocator;

    if (StackSize > allocator->ReserveIrpStackSize) {
        return NULL;
    }


    while (InterlockedExchange(&allocator->IrpAllocated, 1) == 1) {

        (VOID)KeWaitForSingleObject(&allocator->Event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER)0);
    }

    IoInitializeIrp(allocator->ReserveIrp, IoSizeOfIrp(StackSize), StackSize);
    return (allocator->ReserveIrp);
}

VOID
IopFreeReserveIrp(
    IN  CCHAR   PriorityBoost
    )
/*++

Routine Description:

    This routine frees a reserve IRP

Arguments:

    PriorityBoost - Boost to be supplied to waiting threads.

Return Value:

    None

--*/
{
    InterlockedExchange(&IopReserveIrpAllocator.IrpAllocated, 0);
    KeSetEvent(&IopReserveIrpAllocator.Event, PriorityBoost, FALSE);
}


NTSTATUS
IopGetBasicInformationFile(
    IN  PFILE_OBJECT            FileObject,
    IN  PFILE_BASIC_INFORMATION BasicInformationBuffer
    )
/*++

Routine Description:

    This routine gets the basic information of a fileobject.

Arguments:

    FileObject  - Fileobject for which the information is needed.
    BasicInformationBuffer - Buffer of type FILE_BASIC_INFORMATION

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    IO_STATUS_BLOCK localIoStatus;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG   lengthNeeded;
    BOOLEAN queryResult;

    PAGED_CODE();

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    if (fastIoDispatch && fastIoDispatch->FastIoQueryBasicInfo) {

        queryResult = fastIoDispatch->FastIoQueryBasicInfo( FileObject,
                                                            (FileObject->Flags & FO_SYNCHRONOUS_IO) ? TRUE : FALSE,
                                                            BasicInformationBuffer,
                                                            &localIoStatus,
                                                            deviceObject );
        if (queryResult) {
            return (localIoStatus.Status);
        }
    }

    //
    // Use the special API because the fileobject may be synchronous.
    //

    status = IopGetFileInformation(FileObject,
                                   sizeof(FILE_BASIC_INFORMATION),
                                   FileBasicInformation,
                                   BasicInformationBuffer,
                                   &lengthNeeded);
    return status;
}

PVPB
IopMountInitializeVpb(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PDEVICE_OBJECT  AttachedDevice,
    IN  ULONG           RawMountOnly
    )
/*++

Routine Description:

    This routine initializes the mounted volume VPB holding the VPB lock.

Arguments:

    DeviceObject  - Disk device object
    AttachedDevice - Top of FS stack.
    RawMountOnly   - Only allow raw mounts

Return Value:

    none.

--*/
{
    KIRQL   irql;
    PVPB    vpb;

    IoAcquireVpbSpinLock(&irql);

    vpb = DeviceObject->Vpb;

    vpb->Flags = VPB_MOUNTED;


    //
    // We explicitly propagate VPB_RAW_MOUNT as the previous
    // statement that has been there for a long time in NT
    // could be clearing other flags which should be cleared.
    //

    if (RawMountOnly) {
        vpb->Flags |= VPB_RAW_MOUNT;
    }

    vpb->DeviceObject->StackSize = (UCHAR) (AttachedDevice->StackSize + 1);

    //
    // Set the reverse Vpb pointer in the filesystem device object's VPB.
    //

    vpb->DeviceObject->DeviceObjectExtension->Vpb = vpb;

    vpb->ReferenceCount += 1;

    IoReleaseVpbSpinLock(irql);

    return vpb;
}

BOOLEAN
IopVerifyDeviceObjectOnStack(
    IN  PDEVICE_OBJECT  BaseDeviceObject,
    IN  PDEVICE_OBJECT  TopDeviceObject
    )
/*++

Routine Description:

    This routine checks if a device object is on a device stack.

Arguments:

    BaseDeviceObject  - Lowest device object on the stack.
    TopDeviceObject - Device which is to be tested.

Return Value:

    Returns TRUE if TopDeviceObject is on stack.

--*/
{
    KIRQL           irql;
    PDEVICE_OBJECT  currentDeviceObject;

    //
    // Loop through all of the device object's attached to the specified
    // device.  When the last device object is found that is not attached
    // to, return it.
    //

    ASSERT( BaseDeviceObject != NULL);

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    currentDeviceObject = BaseDeviceObject;

    do {
        if (currentDeviceObject == TopDeviceObject) {
            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
            return TRUE;
        }
        currentDeviceObject = currentDeviceObject->AttachedDevice;
    } while (currentDeviceObject);

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return FALSE;
}

BOOLEAN
IopVerifyDiskSignature(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout,
    IN PARC_DISK_SIGNATURE          LoaderDiskBlock,
    OUT PULONG                      DiskSignature
    )
/*++

Routine Description:

    This routine verifies disk signature that is present in the loader block
    and that retrieved by the storage drivers.

Arguments:

    DriveLayout - Informtion obtained from the storage stack.
    LoaderDiskBlock - Signature info from loader
    SectorBuffer - Buffer containing sector 0 on the disk.
    DiskSignature - If successful contains disk signature.

Return Value:

    Returns TRUE if signature matches.

--*/
{
    ULONG   diskSignature;

    if (!LoaderDiskBlock->ValidPartitionTable) {
        return FALSE;
    }

    //
    // Save off the signature in local variable if
    // its a MBR disk
    //

    if (DriveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
        diskSignature = DriveLayout->Mbr.Signature;
        if (LoaderDiskBlock->Signature == diskSignature) {
            if (DiskSignature) {
                *DiskSignature = diskSignature;
            }
            return TRUE;
        }
    }

    //
    // Get hold of the signature from MBR if its GPT disk
    //

    if (DriveLayout->PartitionStyle == PARTITION_STYLE_GPT) {

        if (!LoaderDiskBlock->IsGpt) {
            return FALSE;
        }

        if (!RtlEqualMemory(LoaderDiskBlock->GptSignature, &DriveLayout->Gpt.DiskId, sizeof(GUID))) {
            return FALSE;
        }

        if (DiskSignature) {
            *DiskSignature = 0;
        }
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
IopGetDriverPathInformation(
    IN  PFILE_OBJECT                        FileObject,
    IN  PFILE_FS_DRIVER_PATH_INFORMATION    FsDpInfo,
    IN  ULONG                               Length
    )
/*++

Routine Description:

    This routine returns true if a driver specified by name is present in the IO path
    for the fileobject.

Arguments:

    FileObject - FileObject to which IO is issued.
    FsDpInfo - Info that contains driver name.

Return Value:

    NTSTATUS

--*/
{
    UNICODE_STRING  driverString;
    PDRIVER_OBJECT  driverObject;
    NTSTATUS        status;
    KIRQL           irql;

    if ((ULONG) (Length - FIELD_OFFSET( FILE_FS_DRIVER_PATH_INFORMATION, DriverName[0] )) < FsDpInfo->DriverNameLength) {
        return STATUS_INVALID_PARAMETER;
    }

    driverString.Buffer = FsDpInfo->DriverName;
    driverString.Length = (USHORT)FsDpInfo->DriverNameLength;
    driverString.MaximumLength = (USHORT)FsDpInfo->DriverNameLength;

    status = ObReferenceObjectByName(&driverString,
                                     OBJ_CASE_INSENSITIVE,
                                     NULL,                 // access state
                                     0,                    // access mask
                                     IoDriverObjectType,
                                     KernelMode,
                                     NULL,                 // parse context
                                     &driverObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );


    if (FileObject->Vpb != NULL && FileObject->Vpb->DeviceObject != NULL) {

        //
        // Check the disk filesystem stack.
        //

        if (IopVerifyDriverObjectOnStack(FileObject->Vpb->DeviceObject, driverObject)) {

            FsDpInfo->DriverInPath = TRUE;
            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
            ObDereferenceObject(driverObject);
            return STATUS_SUCCESS;
        }
    }

    //
    // Check the storage stack or non disk filesystem stack.
    //

    FsDpInfo->DriverInPath = IopVerifyDriverObjectOnStack(FileObject->DeviceObject, driverObject);
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    ObDereferenceObject(driverObject);
    return STATUS_SUCCESS;
}

BOOLEAN
IopVerifyDriverObjectOnStack(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine returns true if a driver specified by driverObject is present in the IO path
    for the deviceobject.

Arguments:

    DeviceObject - DeviceObject to which IO is issued.
    Driverobject - DriverObject to be checked.

Return Value:

    TRUE if the driverObject is in the IO path

--*/
{
    PDEVICE_OBJECT  currentDeviceObject;

    currentDeviceObject = IopGetDeviceAttachmentBase(DeviceObject);

    while (currentDeviceObject) {
        if (currentDeviceObject->DriverObject == DriverObject) {
            return TRUE;
        }
        currentDeviceObject = currentDeviceObject->AttachedDevice;
    }
    return FALSE;
}

VOID
IopIncrementDeviceObjectHandleCount(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
  IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                &DeviceObject->ReferenceCount );
}

VOID
IopDecrementDeviceObjectHandleCount(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    IopDecrementDeviceObjectRef(DeviceObject, FALSE, FALSE);
}

NTSTATUS
IopInitializeIrpStackProfiler(
    VOID
    )
/*++

Routine Description:

    This routine initializes the Irp stack profiler.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    LARGE_INTEGER   dueTime;

    RtlZeroMemory(IopIrpStackProfiler.Profile, MAX_LOOKASIDE_IRP_STACK_COUNT * sizeof(ULONG));

    KeInitializeTimer(&IopIrpStackProfiler.Timer);
    KeInitializeDpc(&IopIrpStackProfiler.Dpc, IopIrpStackProfilerTimer, &IopIrpStackProfiler);

    dueTime.QuadPart = - IOP_PROFILE_TIME_PERIOD * 10 * 1000 * 1000;  // 1 Minute with a recurring period of a minute
    IopIrpStackProfiler.TriggerCount = 0;

    KeSetTimerEx(&IopIrpStackProfiler.Timer, dueTime, IOP_PROFILE_TIME_PERIOD * 1000, &IopIrpStackProfiler.Dpc);

    return STATUS_SUCCESS;
}

VOID
IopIrpStackProfilerTimer(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is the timer DPC routine.

Arguments:

    DeferredContext - Pointer to the profiler structure.

Return Value:

    None

--*/
{
    PIOP_IRP_STACK_PROFILER profiler = DeferredContext;
    LONG                    i;
    ULONG                   totalIrpsCounted;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // If profile stack count is now enabled, we wait for ProfileDuration * 60 secs to stop
    // it. Once stopped, IopProcessIrpStackProfiler will tally the counts and find the top two
    // stack counts.
    //

    if (profiler->Flags & IOP_PROFILE_STACK_COUNT) {
        totalIrpsCounted = 0;
        for (i = 0; i < MAX_LOOKASIDE_IRP_STACK_COUNT; i++) {
            totalIrpsCounted += profiler->Profile[i];
        }
        if (totalIrpsCounted > NUM_SAMPLE_IRPS) {
            profiler->Flags &= ~IOP_PROFILE_STACK_COUNT; // Stop the profiling.
            IopProcessIrpStackProfiler();
        }
        return;
    }

    //
    // Every IOP_PROFILE_TRIGGER_INTERVAL * 60 seconds we turn on the profiling
    //

    profiler->TriggerCount++;
    if ((profiler->TriggerCount % IOP_PROFILE_TRIGGER_INTERVAL) == 0) {
        profiler->Flags |= IOP_PROFILE_STACK_COUNT;  // Enable profiling
    }
}

VOID
IopProcessIrpStackProfiler(
    VOID
    )
/*++

Routine Description:

    This routine profiles and resets the per-processor counters. It sets the variables
    IopLargeIrpStackLocations and IopSmallIrpStackLocations with the values learned from
    counters.

Arguments:

    None

Return Value:

    None

--*/
{
    PIOP_IRP_STACK_PROFILER profiler = &IopIrpStackProfiler;
    ULONG                   i;
    LONG                    bucket = 0;
    ULONG                   stackCount = 0;
    LONG                    numRequests;

    numRequests = 0;
    for (i = BASE_STACK_COUNT; i < MAX_LOOKASIDE_IRP_STACK_COUNT; i++) {
        numRequests += profiler->Profile[i];
        profiler->Profile[i] = 0;
        if (numRequests > bucket) {
            stackCount = i;
            bucket = numRequests;
        }
        numRequests = 0;
    }


    //
    // If the top allocation is less than the minimum threshold do nothing.
    //

    if (bucket < MIN_IRP_THRESHOLD) {
        return;
    }

    //
    // Update the global variables. This should cause IoAllocateIrp to start using the new IRPs
    // right away.
    //

    if (IopLargeIrpStackLocations != stackCount) {
        IopLargeIrpStackLocations = stackCount;
    }
}

BOOLEAN
IopReferenceVerifyVpb(
    IN  PDEVICE_OBJECT  DeviceObject, 
    OUT PVPB            *Vpb, 
    OUT PDEVICE_OBJECT  *FsDeviceObject
    )
/*++

Routine Description:

    This routine tests if a device object is mounted and if so retrieves
    the fs device object and returns it along with the VPB. Its called
    from IoVerifyVolume. It takes a reference so that the VPB and the fsDeviceObject
    don't vanish.

Arguments:

    DeviceObject    - DeviceObject of the drive we have to verify.
    Vpb             - The vpb is returned here.
    FsDeviceObject  - The fs deviceobject is returned here.

Return Value:

    TRUE if mounted, FALSE otherwise.

--*/
{
    KIRQL   irql;
    BOOLEAN isMounted = FALSE;
    PVPB    vpb;

    IoAcquireVpbSpinLock(&irql);

    *Vpb = NULL;
    *FsDeviceObject = NULL;

    vpb = DeviceObject->Vpb;

    if (vpb && vpb->Flags & VPB_MOUNTED) {
        *FsDeviceObject = vpb->DeviceObject;
        isMounted = TRUE;
        *Vpb = vpb;
        vpb->ReferenceCount++;
    }

    IoReleaseVpbSpinLock(irql); 

    return isMounted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\ioinit.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ioinit.c

Abstract:

    This module contains the code to initialize the I/O system.

Author:

    Darryl E. Havens (darrylh) April 27, 1989

Environment:

    Kernel mode, system initialization code

Revision History:


--*/

#include "iomgr.h"
#include <setupblk.h>
#include <inbv.h>
#include <ntddstor.h>
#include <hdlsblk.h>
#include <hdlsterm.h>


//
// Define the default number of IRP that can be in progress and allocated
// from a lookaside list.
//

#define DEFAULT_LOOKASIDE_IRP_LIMIT 512

//
// I/O Error logging support
//
PVOID IopErrorLogObject = NULL;

//
// Define a macro for initializing drivers.
//

#define InitializeDriverObject( Object ) {                                 \
    ULONG i;                                                               \
    RtlZeroMemory( Object,                                                 \
                   sizeof( DRIVER_OBJECT ) + sizeof ( DRIVER_EXTENSION )); \
    Object->DriverExtension = (PDRIVER_EXTENSION) (Object + 1);            \
    Object->DriverExtension->DriverObject = Object;                        \
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)                         \
        Object->MajorFunction[i] = IopInvalidDeviceRequest;                \
    Object->Type = IO_TYPE_DRIVER;                                         \
    Object->Size = sizeof( DRIVER_OBJECT );                                \
    }

ULONG   IopInitFailCode;    // Debugging aid for IoInitSystem

//
// Define external procedures not in common header files
//

VOID
IopInitializeData(
    VOID
    );

//
// Define the local procedures
//

BOOLEAN
IopCreateObjectTypes(
    VOID
    );

BOOLEAN
IopCreateRootDirectories(
    VOID
    );

NTSTATUS
IopInitializeAttributesAndCreateObject(
    IN PUNICODE_STRING ObjectName,
    IN OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PDRIVER_OBJECT *DriverObject
    );

BOOLEAN
IopReassignSystemRoot(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    OUT PSTRING NtDeviceName
    );

VOID
IopSetIoRoutines(
    IN VOID
    );

VOID
IopStoreSystemPartitionInformation(
    IN     PUNICODE_STRING NtSystemPartitionDeviceName,
    IN OUT PUNICODE_STRING OsLoaderPathName
    );

//
// The following allows the I/O system's initialization routines to be
// paged out of memory.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,IoInitSystem)
#pragma alloc_text(INIT,IopCreateArcNames)
#pragma alloc_text(INIT,IopCreateObjectTypes)
#pragma alloc_text(INIT,IopCreateRootDirectories)
#pragma alloc_text(INIT,IopInitializeAttributesAndCreateObject)
#pragma alloc_text(INIT,IopInitializeBuiltinDriver)
#pragma alloc_text(INIT,IopMarkBootPartition)
#pragma alloc_text(INIT,IopReassignSystemRoot)
#pragma alloc_text(INIT,IopSetIoRoutines)
#pragma alloc_text(INIT,IopStoreSystemPartitionInformation)
#pragma alloc_text(INIT,IopInitializeReserveIrp)
#endif


BOOLEAN
IoInitSystem(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine initializes the I/O system.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block that was
        created by the OS Loader.

Return Value:

    The function value is a BOOLEAN indicating whether or not the I/O system
    was successfully initialized.

--*/

{
    PDRIVER_OBJECT driverObject;
    PDRIVER_OBJECT *nextDriverObject;
    STRING ntDeviceName;
    CHAR deviceNameBuffer[256];
    ULONG largePacketSize;
    ULONG smallPacketSize;
    ULONG mdlPacketSize;
    LARGE_INTEGER deltaTime;
    MM_SYSTEMSIZE systemSize;
    USHORT completionZoneSize;
    USHORT largeIrpZoneSize;
    USHORT smallIrpZoneSize;
    USHORT mdlZoneSize;
    ULONG oldNtGlobalFlag;
    NTSTATUS status;
    ANSI_STRING ansiString;
    UNICODE_STRING eventName;
    UNICODE_STRING startTypeName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;
    PGENERAL_LOOKASIDE lookaside;
    ULONG lookasideIrpLimit;
    ULONG lookasideSize;
    ULONG Index;
    PKPRCB prcb;
    ULONG len;
    PKEY_VALUE_PARTIAL_INFORMATION value;
    UCHAR   valueBuffer[32];

    ASSERT( IopQueryOperationLength[FileMaximumInformation] == 0xff );
    ASSERT( IopSetOperationLength[FileMaximumInformation] == 0xff );
    ASSERT( IopQueryOperationAccess[FileMaximumInformation] == 0xffffffff );
    ASSERT( IopSetOperationAccess[FileMaximumInformation] == 0xffffffff );

    ASSERT( IopQueryFsOperationLength[FileFsMaximumInformation] == 0xff );
    ASSERT( IopSetFsOperationLength[FileFsMaximumInformation] == 0xff );
    ASSERT( IopQueryFsOperationAccess[FileFsMaximumInformation] == 0xffffffff );
    ASSERT( IopSetFsOperationAccess[FileFsMaximumInformation] == 0xffffffff );

    //
    // Initialize the I/O database resource, lock, and the file system and
    // network file system queue headers.  Also allocate the cancel spin
    // lock.
    //

    ntDeviceName.Buffer = deviceNameBuffer;
    ntDeviceName.MaximumLength = sizeof(deviceNameBuffer);
    ntDeviceName.Length = 0;

    ExInitializeResourceLite( &IopDatabaseResource );
    ExInitializeResourceLite( &IopSecurityResource );
    ExInitializeResourceLite( &IopCrashDumpLock );
    InitializeListHead( &IopDiskFileSystemQueueHead );
    InitializeListHead( &IopCdRomFileSystemQueueHead );
    InitializeListHead( &IopTapeFileSystemQueueHead );
    InitializeListHead( &IopNetworkFileSystemQueueHead );
    InitializeListHead( &IopBootDriverReinitializeQueueHead );
    InitializeListHead( &IopDriverReinitializeQueueHead );
    InitializeListHead( &IopNotifyShutdownQueueHead );
    InitializeListHead( &IopNotifyLastChanceShutdownQueueHead );
    InitializeListHead( &IopFsNotifyChangeQueueHead );
    KeInitializeSpinLock( &IoStatisticsLock );

    IopSetIoRoutines();
    //
    // Initialize the unique device object number counter used by IoCreateDevice
    // when automatically generating a device object name.
    //
    IopUniqueDeviceObjectNumber = 0;

    //
    // Initialize the large I/O Request Packet (IRP) lookaside list head and the
    // mutex which guards the list.
    //


    if (!IopLargeIrpStackLocations) {
        IopLargeIrpStackLocations = DEFAULT_LARGE_IRP_LOCATIONS;
        IopIrpStackProfiler.Flags |= IOP_ENABLE_AUTO_SIZING;
    }

    systemSize = MmQuerySystemSize();

    switch ( systemSize ) {

    case MmSmallSystem :
        completionZoneSize = 6;
        smallIrpZoneSize = 6;
        largeIrpZoneSize = 8;
        mdlZoneSize = 16;
        lookasideIrpLimit = DEFAULT_LOOKASIDE_IRP_LIMIT;
        break;

    case MmMediumSystem :
        completionZoneSize = 24;
        smallIrpZoneSize = 24;
        largeIrpZoneSize = 32;
        mdlZoneSize = 90;
        lookasideIrpLimit = DEFAULT_LOOKASIDE_IRP_LIMIT * 2;
        break;

    case MmLargeSystem :
    default :
        if (MmIsThisAnNtAsSystem()) {
            completionZoneSize = 96;
            smallIrpZoneSize = 96;
            largeIrpZoneSize = 128;
            mdlZoneSize = 256;
            lookasideIrpLimit = DEFAULT_LOOKASIDE_IRP_LIMIT * 128; // 64k

        } else {
            completionZoneSize = 32;
            smallIrpZoneSize = 32;
            largeIrpZoneSize = 64;
            mdlZoneSize = 128;
            lookasideIrpLimit = DEFAULT_LOOKASIDE_IRP_LIMIT * 3;
        }

        break;
    }

    //
    // Initialize the system I/O completion lookaside list.
    //

    ExInitializeSystemLookasideList( &IopCompletionLookasideList,
                                     NonPagedPool,
                                     sizeof(IOP_MINI_COMPLETION_PACKET),
                                     ' pcI',
                                     completionZoneSize,
                                     &ExSystemLookasideListHead );


    //
    // Initialize the system large IRP lookaside list.
    //

    largePacketSize = (ULONG) (sizeof( IRP ) + (IopLargeIrpStackLocations * sizeof( IO_STACK_LOCATION )));
    ExInitializeSystemLookasideList( &IopLargeIrpLookasideList,
                                     NonPagedPool,
                                     largePacketSize,
                                     'lprI',
                                     largeIrpZoneSize,
                                     &ExSystemLookasideListHead );

    //
    // Initialize the system small IRP lookaside list.
    //


    smallPacketSize = (ULONG) (sizeof( IRP ) + sizeof( IO_STACK_LOCATION ));
    ExInitializeSystemLookasideList( &IopSmallIrpLookasideList,
                                     NonPagedPool,
                                     smallPacketSize,
                                     'sprI',
                                     smallIrpZoneSize,
                                     &ExSystemLookasideListHead );

    //
    // Initialize the system MDL lookaside list.
    //

    mdlPacketSize = (ULONG) (sizeof( MDL ) + (IOP_FIXED_SIZE_MDL_PFNS * sizeof( PFN_NUMBER )));
    ExInitializeSystemLookasideList( &IopMdlLookasideList,
                                     NonPagedPool,
                                     mdlPacketSize,
                                     ' ldM',
                                     mdlZoneSize,
                                     &ExSystemLookasideListHead );

    //
    // Compute the lookaside IRP float credits per processor.
    //

    lookasideIrpLimit /= KeNumberProcessors;

    //
    // Initialize the per processor nonpaged lookaside lists and descriptors.
    //
    // N.B. All the I/O related lookaside list structures are allocated at
    //      one time to make sure they are aligned, if possible, and to avoid
    //      pool overhead.
    //

    lookasideSize = 4 * KeNumberProcessors * sizeof(GENERAL_LOOKASIDE);
    lookaside = ExAllocatePoolWithTag( NonPagedPool, lookasideSize, 'oI');
    for (Index = 0; Index < (ULONG)KeNumberProcessors; Index += 1) {
        prcb = KiProcessorBlock[Index];

        //
        // Set the per processor IRP float credits.
        //

        prcb->LookasideIrpFloat = lookasideIrpLimit;

        //
        // Initialize the I/O completion per processor lookaside pointers
        //

        prcb->PPLookasideList[LookasideCompletionList].L = &IopCompletionLookasideList;
        if (lookaside != NULL) {
            ExInitializeSystemLookasideList( lookaside,
                                             NonPagedPool,
                                             sizeof(IOP_MINI_COMPLETION_PACKET),
                                             'PpcI',
                                             completionZoneSize,
                                             &ExSystemLookasideListHead );

            prcb->PPLookasideList[LookasideCompletionList].P = lookaside;
            lookaside += 1;

        } else {
            prcb->PPLookasideList[LookasideCompletionList].P = &IopCompletionLookasideList;
        }

        //
        // Initialize the large IRP per processor lookaside pointers.
        //

        prcb->PPLookasideList[LookasideLargeIrpList].L = &IopLargeIrpLookasideList;
        if (lookaside != NULL) {
            ExInitializeSystemLookasideList( lookaside,
                                             NonPagedPool,
                                             largePacketSize,
                                             'LprI',
                                             largeIrpZoneSize,
                                             &ExSystemLookasideListHead );

            prcb->PPLookasideList[LookasideLargeIrpList].P = lookaside;
            lookaside += 1;

        } else {
            prcb->PPLookasideList[LookasideLargeIrpList].P = &IopLargeIrpLookasideList;
        }

        //
        // Initialize the small IRP per processor lookaside pointers.
        //

        prcb->PPLookasideList[LookasideSmallIrpList].L = &IopSmallIrpLookasideList;
        if (lookaside != NULL) {
            ExInitializeSystemLookasideList( lookaside,
                                             NonPagedPool,
                                             smallPacketSize,
                                             'SprI',
                                             smallIrpZoneSize,
                                             &ExSystemLookasideListHead );

            prcb->PPLookasideList[LookasideSmallIrpList].P = lookaside;
            lookaside += 1;

        } else {
            prcb->PPLookasideList[LookasideSmallIrpList].P = &IopSmallIrpLookasideList;
        }

        //
        // Initialize the MDL per processor lookaside list pointers.
        //

        prcb->PPLookasideList[LookasideMdlList].L = &IopMdlLookasideList;
        if (lookaside != NULL) {
            ExInitializeSystemLookasideList( lookaside,
                                             NonPagedPool,
                                             mdlPacketSize,
                                             'PldM',
                                             mdlZoneSize,
                                             &ExSystemLookasideListHead );

            prcb->PPLookasideList[LookasideMdlList].P = lookaside;
            lookaside += 1;

        } else {
            prcb->PPLookasideList[LookasideMdlList].P = &IopMdlLookasideList;
        }
    }

    //
    // Initalize the error log spin locks and log list.
    //

    KeInitializeSpinLock( &IopErrorLogLock );
    InitializeListHead( &IopErrorLogListHead );

    if (IopInitializeReserveIrp(&IopReserveIrpAllocator) == FALSE) {
        IopInitFailCode = 1;
        return FALSE;
    }

    if (IopIrpAutoSizingEnabled() && !NT_SUCCESS(IopInitializeIrpStackProfiler())) {
        IopInitFailCode = 13;
        return FALSE;
    }

    //
    // Determine if the Error Log service will ever run this boot.
    //
    InitializeObjectAttributes (&objectAttributes,
                                &CmRegistryMachineSystemCurrentControlSetServicesEventLog,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenKey(&handle,
                       KEY_READ,
                       &objectAttributes
                       );

    if (NT_SUCCESS (status)) {
        RtlInitUnicodeString (&startTypeName, L"Start");
        value = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;
        status = NtQueryValueKey (handle,
                                  &startTypeName,
                                  KeyValuePartialInformation,
                                  valueBuffer,
                                  sizeof (valueBuffer),
                                  &len);

        if (NT_SUCCESS (status) && (value->Type == REG_DWORD)) {
            if (SERVICE_DISABLED == (*(PULONG) (value->Data))) {
                //
                // We are disabled for this boot.
                //
                IopErrorLogDisabledThisBoot = TRUE;
            } else {
                IopErrorLogDisabledThisBoot = FALSE;
            }
        } else {
            //
            // Didn't find the value so we are not enabled.
            //
            IopErrorLogDisabledThisBoot = TRUE;
        }
        ObCloseHandle(handle, KernelMode);
    } else {
        //
        // Didn't find the key so we are not enabled
        //
        IopErrorLogDisabledThisBoot = TRUE;
    }

    //
    // Initialize the timer database and start the timer DPC routine firing
    // so that drivers can use it during initialization.
    //

    deltaTime.QuadPart = - 10 * 1000 * 1000;

    KeInitializeSpinLock( &IopTimerLock );
    InitializeListHead( &IopTimerQueueHead );
    KeInitializeDpc( &IopTimerDpc, IopTimerDispatch, NULL );
    KeInitializeTimerEx( &IopTimer, SynchronizationTimer );
    (VOID) KeSetTimerEx( &IopTimer, deltaTime, 1000, &IopTimerDpc );

    //
    // Initialize the IopHardError structure used for informational pop-ups.
    //

    ExInitializeWorkItem( &IopHardError.ExWorkItem,
                          IopHardErrorThread,
                          NULL );

    InitializeListHead( &IopHardError.WorkQueue );

    KeInitializeSpinLock( &IopHardError.WorkQueueSpinLock );

    KeInitializeSemaphore( &IopHardError.WorkQueueSemaphore,
                           0,
                           MAXLONG );

    IopHardError.ThreadStarted = FALSE;

    IopCurrentHardError = NULL;

    //
    // Create the link tracking named event.
    //

    RtlInitUnicodeString( &eventName, L"\\Security\\TRKWKS_EVENT" );
    InitializeObjectAttributes( &objectAttributes,
                                &eventName,
                                OBJ_PERMANENT|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );
    status = NtCreateEvent( &handle,
                            EVENT_ALL_ACCESS,
                            &objectAttributes,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrint( "IOINIT: NtCreateEvent failed\n" );
#endif
        HeadlessKernelAddLogEntry(HEADLESS_LOG_EVENT_CREATE_FAILED, NULL);
        return FALSE;
    }

    (VOID) ObReferenceObjectByHandle( handle,
                                      0,
                                      ExEventObjectType,
                                      KernelMode,
                                      (PVOID *) &IopLinkTrackingServiceEvent,
                                      NULL );

    KeInitializeEvent( &IopLinkTrackingPacket.Event, NotificationEvent, FALSE );
    KeInitializeEvent(&IopLinkTrackingPortObject, SynchronizationEvent, TRUE );
    ObCloseHandle(handle, KernelMode);

    //
    // Create all of the objects for the I/O system.
    //

    if (!IopCreateObjectTypes()) {

#if DBG
        DbgPrint( "IOINIT: IopCreateObjectTypes failed\n" );
#endif

        HeadlessKernelAddLogEntry(HEADLESS_LOG_OBJECT_TYPE_CREATE_FAILED, NULL);
        IopInitFailCode = 2;
        return FALSE;
    }

    //
    // Create the root directories for the I/O system.
    //

    if (!IopCreateRootDirectories()) {

#if DBG
        DbgPrint( "IOINIT: IopCreateRootDirectories failed\n" );
#endif

        HeadlessKernelAddLogEntry(HEADLESS_LOG_ROOT_DIR_CREATE_FAILED, NULL);
        IopInitFailCode = 3;
        return FALSE;
    }

    //
    // Initialize PlugPlay services phase 0
    //

    status = IopInitializePlugPlayServices(LoaderBlock, 0);
    if (!NT_SUCCESS(status)) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_PNP_PHASE0_INIT_FAILED, NULL);
        IopInitFailCode = 4;
        return FALSE;
    }

    //
    // Call Power manager to initialize for drivers
    //

    PoInitDriverServices(0);

    //
    // Call HAL to initialize PnP bus driver
    //

    HalInitPnpDriver();

    IopMarkHalDeviceNode();

    //
    // Call WMI to initialize it and allow it to create its driver object
    // Note that no calls to WMI can occur until it is initialized here.
    //

    WMIInitialize(0, (PVOID)LoaderBlock);

    //
    // Save this for use during PnP enumeration -- we NULL it out later
    // before LoaderBlock is reused.
    //

    IopLoaderBlock = (PVOID)LoaderBlock;

    //
    // If this is a remote boot, we need to add a few values to the registry.
    //

    if (IoRemoteBootClient) {
        status = IopAddRemoteBootValuesToRegistry(LoaderBlock);
        if (!NT_SUCCESS(status)) {
            KeBugCheckEx( NETWORK_BOOT_INITIALIZATION_FAILED,
                          1,
                          status,
                          0,
                          0 );
        }
    }

    //
    // Initialize PlugPlay services phase 1 to execute firmware mapper
    //

    status = IopInitializePlugPlayServices(LoaderBlock, 1);
    if (!NT_SUCCESS(status)) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_PNP_PHASE1_INIT_FAILED, NULL);
        IopInitFailCode = 5;
        return FALSE;
    }

    //
    // Initialize the drivers loaded by the boot loader (OSLOADER)
    //

    nextDriverObject = &driverObject;
    if (!IopInitializeBootDrivers( LoaderBlock,
                                   nextDriverObject )) {

#if DBG
        DbgPrint( "IOINIT: Initializing boot drivers failed\n" );
#endif // DBG

        HeadlessKernelAddLogEntry(HEADLESS_LOG_BOOT_DRIVERS_INIT_FAILED, NULL);
        IopInitFailCode = 6;
        return FALSE;
    }

    //
    // Once we have initialized the boot drivers, we don't need the
    // copy of the pointer to the loader block any more.
    //

    IopLoaderBlock = NULL;

    //
    // If this is a remote boot, start the network and assign
    // C: to \Device\LanmanRedirector.
    //

    if (IoRemoteBootClient) {
        status = IopStartNetworkForRemoteBoot(LoaderBlock);
        if (!NT_SUCCESS( status )) {
            KeBugCheckEx( NETWORK_BOOT_INITIALIZATION_FAILED,
                          2,
                          status,
                          0,
                          0 );
        }
    }

    //
    // Do last known good boot processing. If this is a last known good boot,
    // we will copy over the last known good drivers and files. Otherwise we
    // will ensure this boot doesn't taint our last good info (in case we crash
    // before the boot is marked good). Note that loading of the correct boot
    // drivers was handled by the boot loader, who chose an LKG boot in the
    // first place.
    //
    PpLastGoodDoBootProcessing();

    //
    // Save the current value of the NT Global Flags and enable kernel debugger
    // symbol loading while drivers are being loaded so that systems can be
    // debugged regardless of whether they are free or checked builds.
    //

    oldNtGlobalFlag = NtGlobalFlag;

    if (!(NtGlobalFlag & FLG_ENABLE_KDEBUG_SYMBOL_LOAD)) {
        NtGlobalFlag |= FLG_ENABLE_KDEBUG_SYMBOL_LOAD;
    }

    status = PsLocateSystemDll(FALSE);
    if (!NT_SUCCESS( status )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOCATE_SYSTEM_DLL_FAILED, NULL);
        IopInitFailCode = 7;
        return FALSE;
    }

    //
    // Notify the boot prefetcher of boot progress.
    //

    CcPfBeginBootPhase(PfSystemDriverInitPhase);

    //
    // Initialize the device drivers for the system.
    //

    if (!IopInitializeSystemDrivers()) {
#if DBG
        DbgPrint( "IOINIT: Initializing system drivers failed\n" );
#endif // DBG

        HeadlessKernelAddLogEntry(HEADLESS_LOG_SYSTEM_DRIVERS_INIT_FAILED, NULL);
        IopInitFailCode = 8;
        return FALSE;
    }

    IopCallDriverReinitializationRoutines();

    //
    // Reassign \SystemRoot to NT device name path.
    //

    if (!IopReassignSystemRoot( LoaderBlock, &ntDeviceName )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_ASSIGN_SYSTEM_ROOT_FAILED, NULL);
        IopInitFailCode = 9;
        return FALSE;
    }

    //
    // Protect the system partition of an ARC system if necessary
    //

    if (!IopProtectSystemPartition( LoaderBlock )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_PROTECT_SYSTEM_ROOT_FAILED, NULL);
        IopInitFailCode = 10;
        return FALSE;
    }

    //
    // Assign DOS drive letters to disks and cdroms and define \SystemRoot.
    //

    ansiString.MaximumLength = NtSystemRoot.MaximumLength / sizeof( WCHAR );
    ansiString.Length = 0;
    ansiString.Buffer = (RtlAllocateStringRoutine)( ansiString.MaximumLength );
    status = RtlUnicodeStringToAnsiString( &ansiString,
                                           &NtSystemRoot,
                                           FALSE
                                         );
    if (!NT_SUCCESS( status )) {

        DbgPrint( "IOINIT: UnicodeToAnsi( %wZ ) failed - %x\n", &NtSystemRoot, status );

        HeadlessKernelAddLogEntry(HEADLESS_LOG_UNICODE_TO_ANSI_FAILED, NULL);
        IopInitFailCode = 11;
        return FALSE;
    }

    IoAssignDriveLetters( LoaderBlock,
                          &ntDeviceName,
                          (PUCHAR) ansiString.Buffer,
                          &ansiString );

    status = RtlAnsiStringToUnicodeString( &NtSystemRoot,
                                           &ansiString,
                                           FALSE
                                         );
    if (!NT_SUCCESS( status )) {

        DbgPrint( "IOINIT: AnsiToUnicode( %Z ) failed - %x\n", &ansiString, status );

        HeadlessKernelAddLogEntry(HEADLESS_LOG_ANSI_TO_UNICODE_FAILED, NULL);
        IopInitFailCode = 12;
        return FALSE;
    }

    //
    // Also restore the NT Global Flags to their original state.
    //

    NtGlobalFlag = oldNtGlobalFlag;

    //
    // Let WMI have a second chance to initialize, now that all drivers
    // are started and should be ready to get WMI irps
    //
    WMIInitialize(1, NULL);

    //
    // Call Power manager to initialize for post-boot drivers
    //
    PoInitDriverServices(1);

    //
    // Indicate that the I/O system successfully initialized itself.
    //

    return TRUE;

}

VOID
IopSetIoRoutines()
{
    if (pIofCompleteRequest == NULL) {

        pIofCompleteRequest = IopfCompleteRequest;
    }

    if (pIoAllocateIrp == NULL) {

        pIoAllocateIrp = IopAllocateIrpPrivate;
    }

    if (pIoFreeIrp == NULL) {

        pIoFreeIrp = IopFreeIrp;
    }
}


VOID
IopCreateArcNames(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    The loader block contains a table of disk signatures and corresponding
    ARC names. Each device that the loader can access will appear in the
    table. This routine opens each disk device in the system, reads the
    signature and compares it to the table. For each match, it creates a
    symbolic link between the nt device name and the ARC name.

    The checksum value provided by the loader is the ULONG sum of all
    elements in the checksum, inverted, plus 1:
    checksum = ~sum + 1;
    This way the sum of all of the elements can be calculated here and
    added to the checksum in the loader block.  If the result is zero, then
    there is a match.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block that was
        created by the OS Loader.

Return Value:

    None.

--*/

{
    STRING arcBootDeviceString;
    CHAR deviceNameBuffer[128];
    STRING deviceNameString;
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    CHAR arcNameBuffer[128];
    STRING arcNameString;
    UNICODE_STRING arcNameUnicodeString;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    DISK_GEOMETRY diskGeometry;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayout;
    PLIST_ENTRY listEntry;
    PARC_DISK_SIGNATURE diskBlock;
    ULONG diskNumber;
    ULONG partitionNumber;
    PCHAR arcName;
    PULONG buffer;
    PIRP irp;
    KEVENT event;
    LARGE_INTEGER offset;
    ULONG checkSum;
    SIZE_T i;
    PVOID tmpPtr;
    BOOLEAN useLegacyEnumeration = FALSE;
    BOOLEAN singleBiosDiskFound;
    BOOLEAN bootDiskFound = FALSE;
    PARC_DISK_INFORMATION arcInformation = LoaderBlock->ArcDiskInformation;
    ULONG totalDriverDisksFound = IoGetConfigurationInformation()->DiskCount;
    ULONG totalPnpDisksFound = 0;
    STRING arcSystemDeviceString;
    STRING osLoaderPathString;
    UNICODE_STRING osLoaderPathUnicodeString;
    PWSTR diskList = NULL;
    wchar_t *pDiskNameList;
    STORAGE_DEVICE_NUMBER   pnpDiskDeviceNumber;
    ULONG  diskSignature;


    //
    // ask PNP to give us a list with all the currently active disks
    //

    pDiskNameList = diskList;
    pnpDiskDeviceNumber.DeviceNumber = 0xFFFFFFFF;
    status = IoGetDeviceInterfaces(&DiskClassGuid, NULL, 0, &diskList);

    if (!NT_SUCCESS(status)) {

        useLegacyEnumeration = TRUE;
        if (pDiskNameList) {
            *pDiskNameList = L'\0';
        }

    } else {

        //
        // count the number of disks returned
        //

        pDiskNameList = diskList;
        while (*pDiskNameList != L'\0') {

            totalPnpDisksFound++;
            pDiskNameList = pDiskNameList + (wcslen(pDiskNameList) + 1);

        }

        pDiskNameList = diskList;

        //
        // if the disk returned by PNP are not all the disks in the system
        // it means that some legacy driver has generated a disk device object/link.
        // In that case we need to enumerate all pnp disks and then using the legacy
        // for-loop also enumerate the non-pnp disks
        //

        if (totalPnpDisksFound < totalDriverDisksFound) {
            useLegacyEnumeration = TRUE;
        }

    }

    //
    // If a single bios disk was found if there is only a
    // single entry on the disk signature list.
    //

    singleBiosDiskFound = (arcInformation->DiskSignatures.Flink->Flink ==
                           &arcInformation->DiskSignatures) ? (TRUE) : (FALSE);


    //
    // Create hal/loader partition name
    //

    sprintf( arcNameBuffer, "\\ArcName\\%s", LoaderBlock->ArcHalDeviceName );
    RtlInitAnsiString( &arcNameString, arcNameBuffer );
    RtlAnsiStringToUnicodeString (&IoArcHalDeviceName, &arcNameString, TRUE);

    //
    // Create boot partition name
    //

    sprintf( arcNameBuffer, "\\ArcName\\%s", LoaderBlock->ArcBootDeviceName );
    RtlInitAnsiString( &arcNameString, arcNameBuffer );
    RtlAnsiStringToUnicodeString (&IoArcBootDeviceName, &arcNameString, TRUE);
    i = strlen (LoaderBlock->ArcBootDeviceName) + 1;
    IoLoaderArcBootDeviceName = ExAllocatePool (PagedPool, i);
    if (IoLoaderArcBootDeviceName) {
        memcpy (IoLoaderArcBootDeviceName, LoaderBlock->ArcBootDeviceName, i);
    }

    if (singleBiosDiskFound && strstr(LoaderBlock->ArcBootDeviceName, "cdrom")) {
        singleBiosDiskFound = FALSE;
    }

    //
    // Get ARC boot device name from loader block.
    //

    RtlInitAnsiString( &arcBootDeviceString,
                       LoaderBlock->ArcBootDeviceName );

    //
    // Get ARC system device name from loader block.
    //

    RtlInitAnsiString( &arcSystemDeviceString,
                       LoaderBlock->ArcHalDeviceName );

    //
    // If this is a remote boot, create an ArcName for the redirector path.
    //

    if (IoRemoteBootClient) {

        bootDiskFound = TRUE;

        RtlInitAnsiString( &deviceNameString, "\\Device\\LanmanRedirector" );
        status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                               &deviceNameString,
                                               TRUE );

        if (NT_SUCCESS( status )) {

            sprintf( arcNameBuffer,
                     "\\ArcName\\%s",
                     LoaderBlock->ArcBootDeviceName );
            RtlInitAnsiString( &arcNameString, arcNameBuffer );
            status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                                   &arcNameString,
                                                   TRUE );
            if (NT_SUCCESS( status )) {

                //
                // Create symbolic link between NT device name and ARC name.
                //

                IoCreateSymbolicLink( &arcNameUnicodeString,
                                      &deviceNameUnicodeString );
                RtlFreeUnicodeString( &arcNameUnicodeString );

                //
                // We've found the system partition--store it away in the registry
                // to later be transferred to a application-friendly location.
                //
                RtlInitAnsiString( &osLoaderPathString, LoaderBlock->NtHalPathName );
                status = RtlAnsiStringToUnicodeString( &osLoaderPathUnicodeString,
                                                       &osLoaderPathString,
                                                       TRUE );

#if DBG
                if (!NT_SUCCESS( status )) {
                    DbgPrint("IopCreateArcNames: couldn't allocate unicode string for OsLoader path - %x\n", status);
                }
#endif // DBG
                if (NT_SUCCESS( status )) {

                    IopStoreSystemPartitionInformation( &deviceNameUnicodeString,
                                                        &osLoaderPathUnicodeString );

                    RtlFreeUnicodeString( &osLoaderPathUnicodeString );
                }
            }

            RtlFreeUnicodeString( &deviceNameUnicodeString );
        }
    }

    //
    // For each disk in the system do the following:
    // 1. open the device
    // 2. get its geometry
    // 3. read the MBR
    // 4. determine ARC name via disk signature and checksum
    // 5. construct ARC name.
    // In order to deal with the case of disk dissappearing before we get to this point
    // (due to a failed start on one of many disks present in the system) we ask PNP for a list
    // of all the currenttly active disks in the system. If the number of disks returned is
    // less than the IoGetConfigurationInformation()->DiskCount, then we have legacy disks
    // that we need to enumerate in the for loop.
    // In the legacy case, the ending condition for the loop is NOT the total disk on the
    // system but an arbitrary number of the max total legacy disks expected in the system..
    // Additional note: Legacy disks get assigned symbolic links AFTER all pnp enumeration is complete
    //

    totalDriverDisksFound = max(totalPnpDisksFound,totalDriverDisksFound);

    if (useLegacyEnumeration && (totalPnpDisksFound == 0)) {

        //
        // search up to a maximum arbitrary number of legacy disks
        //

        totalDriverDisksFound +=20;
    }

    for (diskNumber = 0;
         diskNumber < totalDriverDisksFound;
         diskNumber++) {

        //
        // Construct the NT name for a disk and obtain a reference.
        //

        if (pDiskNameList && (*pDiskNameList != L'\0')) {

            //
            // retrieve the first symbolic linkname from the PNP disk list
            //

            RtlInitUnicodeString(&deviceNameUnicodeString, pDiskNameList);
            pDiskNameList = pDiskNameList + (wcslen(pDiskNameList) + 1);

            status = IoGetDeviceObjectPointer( &deviceNameUnicodeString,
                                               FILE_READ_ATTRIBUTES,
                                               &fileObject,
                                               &deviceObject );

            if (NT_SUCCESS(status)) {

                //
                // since PNP gave s just asym link we have to retrieve the actual
                // disk number through an IOCTL call to the disk stack.
                // Create IRP for get device number device control.
                //

                irp = IoBuildDeviceIoControlRequest( IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                                     deviceObject,
                                                     NULL,
                                                     0,
                                                     &pnpDiskDeviceNumber,
                                                     sizeof(STORAGE_DEVICE_NUMBER),
                                                     FALSE,
                                                     &event,
                                                     &ioStatusBlock );
                if (!irp) {
                    ObDereferenceObject( fileObject );
                    continue;
                }

                KeInitializeEvent( &event,
                                   NotificationEvent,
                                   FALSE );
                status = IoCallDriver( deviceObject,
                                       irp );

                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject( &event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL );
                    status = ioStatusBlock.Status;
                }

                if (!NT_SUCCESS( status )) {
                    ObDereferenceObject( fileObject );
                    continue;
                }

            }

            if (useLegacyEnumeration && (*pDiskNameList == L'\0') ) {

                //
                // end of pnp disks
                // if there are any legacy disks following we need to update
                // the total disk found number to cover the maximum disk number
                // a legacy disk could be at. (in a sparse name space)
                //

                if (pnpDiskDeviceNumber.DeviceNumber == 0xFFFFFFFF) {
                    pnpDiskDeviceNumber.DeviceNumber = 0;
                }

                diskNumber = max(diskNumber,pnpDiskDeviceNumber.DeviceNumber);
                totalDriverDisksFound = diskNumber + 20;

            }

        } else {

            sprintf( deviceNameBuffer,
                     "\\Device\\Harddisk%d\\Partition0",
                     diskNumber );
            RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
            status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                                   &deviceNameString,
                                                   TRUE );
            if (!NT_SUCCESS( status )) {
                continue;
            }

            status = IoGetDeviceObjectPointer( &deviceNameUnicodeString,
                                               FILE_READ_ATTRIBUTES,
                                               &fileObject,
                                               &deviceObject );

            RtlFreeUnicodeString( &deviceNameUnicodeString );

            //
            // set the pnpDiskNumber value so its not used.
            //

            pnpDiskDeviceNumber.DeviceNumber = 0xFFFFFFFF;

        }


        if (!NT_SUCCESS( status )) {

            continue;
        }

        //
        // Create IRP for get drive geometry device control.
        //

        irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &diskGeometry,
                                             sizeof(DISK_GEOMETRY),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
        if (!irp) {
            ObDereferenceObject( fileObject );
            continue;
        }

        KeInitializeEvent( &event,
                           NotificationEvent,
                           FALSE );
        status = IoCallDriver( deviceObject,
                               irp );

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            status = ioStatusBlock.Status;
        }

        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Get partition information for this disk.
        //


        status = IoReadPartitionTableEx(deviceObject,
                                       &driveLayout );


        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }


        //
        // Make sure sector size is at least 512 bytes.
        //

        if (diskGeometry.BytesPerSector < 512) {
            diskGeometry.BytesPerSector = 512;
        }

        //
        // Check to see if EZ Drive is out there on this disk.  If
        // it is then zero out the signature in the drive layout since
        // this will never be written by anyone AND change to offset to
        // actually read sector 1 rather than 0 cause that's what the
        // loader actually did.
        //

        offset.QuadPart = 0;
        HalExamineMBR( deviceObject,
                       diskGeometry.BytesPerSector,
                       (ULONG)0x55,
                       &tmpPtr );

        if (tmpPtr) {

            offset.QuadPart = diskGeometry.BytesPerSector;
            ExFreePool(tmpPtr);
        }

        //
        // Allocate buffer for sector read and construct the read request.
        //

        buffer = ExAllocatePool( NonPagedPoolCacheAligned,
                                 diskGeometry.BytesPerSector );

        if (buffer) {
            irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                                deviceObject,
                                                buffer,
                                                diskGeometry.BytesPerSector,
                                                &offset,
                                                &event,
                                                &ioStatusBlock );

            if (!irp) {
                ExFreePool(driveLayout);
                ExFreePool(buffer);
                ObDereferenceObject( fileObject );
                continue;
            }
        } else {
            ExFreePool(driveLayout);
            ObDereferenceObject( fileObject );
            continue;
        }
        KeInitializeEvent( &event,
                           NotificationEvent,
                           FALSE );
        status = IoCallDriver( deviceObject,
                               irp );
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            status = ioStatusBlock.Status;
        }

        if (!NT_SUCCESS( status )) {
            ExFreePool(driveLayout);
            ExFreePool(buffer);
            ObDereferenceObject( fileObject );
            continue;
        }

        ObDereferenceObject( fileObject );

        //
        // Calculate MBR sector checksum.  Only 512 bytes are used.
        //

        checkSum = 0;
        for (i = 0; i < 128; i++) {
            checkSum += buffer[i];
        }

        //
        // For each ARC disk information record in the loader block
        // match the disk signature and checksum to determine its ARC
        // name and construct the NT ARC names symbolic links.
        //

        for (listEntry = arcInformation->DiskSignatures.Flink;
             listEntry != &arcInformation->DiskSignatures;
             listEntry = listEntry->Flink) {

            //
            // Get next record and compare disk signatures.
            //

            diskBlock = CONTAINING_RECORD( listEntry,
                                           ARC_DISK_SIGNATURE,
                                           ListEntry );

            //
            // Compare disk signatures.
            //
            // Or if there is only a single disk drive from
            // both the bios and driver viewpoints then
            // assign an arc name to that drive.
            //



            if ((singleBiosDiskFound &&
                 (totalDriverDisksFound == 1) &&
                 (driveLayout->PartitionStyle == PARTITION_STYLE_MBR)) ||

                (IopVerifyDiskSignature(driveLayout, diskBlock, &diskSignature) &&
                 !(diskBlock->CheckSum + checkSum))) {

                //
                // Create unicode device name for physical disk.
                //

                if (pnpDiskDeviceNumber.DeviceNumber == 0xFFFFFFFF) {

                    sprintf( deviceNameBuffer,
                             "\\Device\\Harddisk%d\\Partition0",
                             diskNumber );

                } else {

                    sprintf( deviceNameBuffer,
                             "\\Device\\Harddisk%d\\Partition0",
                             pnpDiskDeviceNumber.DeviceNumber );

                }

                RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
                status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                                       &deviceNameString,
                                                       TRUE );
                if (!NT_SUCCESS( status )) {
                    continue;
                }

                //
                // Create unicode ARC name for this partition.
                //

                arcName = diskBlock->ArcName;
                sprintf( arcNameBuffer,
                         "\\ArcName\\%s",
                         arcName );
                RtlInitAnsiString( &arcNameString, arcNameBuffer );
                status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                                       &arcNameString,
                                                       TRUE );
                if (!NT_SUCCESS( status )) {
                    continue;
                }

                //
                // Create symbolic link between NT device name and ARC name.
                //

                IoCreateSymbolicLink( &arcNameUnicodeString,
                                      &deviceNameUnicodeString );
                RtlFreeUnicodeString( &arcNameUnicodeString );
                RtlFreeUnicodeString( &deviceNameUnicodeString );

                //
                // Create an ARC name for every partition on this disk.
                //

                for (partitionNumber = 0;
                     partitionNumber < driveLayout->PartitionCount;
                     partitionNumber++) {

                    //
                    // Create unicode NT device name.
                    //

                    if (pnpDiskDeviceNumber.DeviceNumber == 0xFFFFFFFF) {

                        sprintf( deviceNameBuffer,
                                 "\\Device\\Harddisk%d\\Partition%d",
                                 diskNumber,
                                 partitionNumber+1 );


                    } else {

                        sprintf( deviceNameBuffer,
                                 "\\Device\\Harddisk%d\\Partition%d",
                                 pnpDiskDeviceNumber.DeviceNumber,
                                 partitionNumber+1 );

                    }

                    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
                    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                                           &deviceNameString,
                                                           TRUE );
                    if (!NT_SUCCESS( status )) {
                        continue;
                    }

                    //
                    // Create unicode ARC name for this partition and
                    // check to see if this is the boot disk.
                    //

                    sprintf( arcNameBuffer,
                             "%spartition(%d)",
                             arcName,
                             partitionNumber+1 );
                    RtlInitAnsiString( &arcNameString, arcNameBuffer );
                    if (RtlEqualString( &arcNameString,
                                        &arcBootDeviceString,
                                        TRUE )) {
                        bootDiskFound = TRUE;
                    }

                    //
                    // See if this is the system partition.
                    //
                    if (RtlEqualString( &arcNameString,
                                        &arcSystemDeviceString,
                                        TRUE )) {
                        //
                        // We've found the system partition--store it away in the registry
                        // to later be transferred to a application-friendly location.
                        //
                        RtlInitAnsiString( &osLoaderPathString, LoaderBlock->NtHalPathName );
                        status = RtlAnsiStringToUnicodeString( &osLoaderPathUnicodeString,
                                                               &osLoaderPathString,
                                                               TRUE );

#if DBG
                        if (!NT_SUCCESS( status )) {
                            DbgPrint("IopCreateArcNames: couldn't allocate unicode string for OsLoader path - %x\n", status);
                        }
#endif // DBG
                        if (NT_SUCCESS( status )) {

                            IopStoreSystemPartitionInformation( &deviceNameUnicodeString,
                                                                &osLoaderPathUnicodeString );

                            RtlFreeUnicodeString( &osLoaderPathUnicodeString );
                        }
                    }

                    //
                    // Add the NT ARC namespace prefix to the ARC name constructed.
                    //

                    sprintf( arcNameBuffer,
                             "\\ArcName\\%spartition(%d)",
                             arcName,
                             partitionNumber+1 );
                    RtlInitAnsiString( &arcNameString, arcNameBuffer );
                    status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                                           &arcNameString,
                                                           TRUE );
                    if (!NT_SUCCESS( status )) {
                        continue;
                    }

                    //
                    // Create symbolic link between NT device name and ARC name.
                    //

                    IoCreateSymbolicLink( &arcNameUnicodeString,
                                          &deviceNameUnicodeString );
                    RtlFreeUnicodeString( &arcNameUnicodeString );
                    RtlFreeUnicodeString( &deviceNameUnicodeString );
                }

            } else {

#if DBG
                //
                // Check key indicators to see if this condition may be
                // caused by a viral infection.
                //

                if (diskBlock->Signature == diskSignature &&
                    (diskBlock->CheckSum + checkSum) != 0 &&
                    diskBlock->ValidPartitionTable) {
                    DbgPrint("IopCreateArcNames: Virus or duplicate disk signatures\n");
                }
#endif
            }
        }

        ExFreePool( driveLayout );
        ExFreePool( buffer );
    }

    if (!bootDiskFound) {

        //
        // Locate the disk block that represents the boot device.
        //

        diskBlock = NULL;
        for (listEntry = arcInformation->DiskSignatures.Flink;
             listEntry != &arcInformation->DiskSignatures;
             listEntry = listEntry->Flink) {

            diskBlock = CONTAINING_RECORD( listEntry,
                                           ARC_DISK_SIGNATURE,
                                           ListEntry );
            if (strcmp( diskBlock->ArcName, LoaderBlock->ArcBootDeviceName ) == 0) {
                break;
            }
            diskBlock = NULL;
        }

        if (diskBlock) {

            //
            // This could be a CdRom boot.  Search all of the NT CdRoms
            // to locate a checksum match on the diskBlock found.  If
            // there is a match, assign the ARC name to the CdRom.
            //

            irp = NULL;
            buffer = ExAllocatePool( NonPagedPoolCacheAligned,
                                     2048 );
            if (buffer) {

                //
                // Construct the NT names for CdRoms and search each one
                // for a checksum match.  If found, create the ARC Name
                // symbolic link.
                //

                for (diskNumber = 0; TRUE; diskNumber++) {

                    sprintf( deviceNameBuffer,
                             "\\Device\\CdRom%d",
                             diskNumber );

                    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
                    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                                           &deviceNameString,
                                                           TRUE );
                    if (NT_SUCCESS( status )) {

                        status = IoGetDeviceObjectPointer( &deviceNameUnicodeString,
                                                           FILE_READ_ATTRIBUTES,
                                                           &fileObject,
                                                           &deviceObject );
                        if (!NT_SUCCESS( status )) {

                            //
                            // All CdRoms have been processed.
                            //

                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            break;
                        }

                        //
                        // Read the block for the checksum calculation.
                        //

                        offset.QuadPart = 0x8000;
                        irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                                            deviceObject,
                                                            buffer,
                                                            2048,
                                                            &offset,
                                                            &event,
                                                            &ioStatusBlock );
                        checkSum = 0;
                        if (irp) {
                            KeInitializeEvent( &event,
                                               NotificationEvent,
                                               FALSE );
                            status = IoCallDriver( deviceObject,
                                                   irp );
                            if (status == STATUS_PENDING) {
                                KeWaitForSingleObject( &event,
                                                       Executive,
                                                       KernelMode,
                                                       FALSE,
                                                       NULL );
                                status = ioStatusBlock.Status;
                            }

                            if (NT_SUCCESS( status )) {

                                //
                                // Calculate MBR sector checksum.
                                // 2048 bytes are used.
                                //

                                for (i = 0; i < 2048 / sizeof(ULONG) ; i++) {
                                    checkSum += buffer[i];
                                }
                            }
                        }
                        ObDereferenceObject( fileObject );

                        if (!(diskBlock->CheckSum + checkSum)) {

                            //
                            // This is the boot CdRom.  Create the symlink for
                            // the ARC name from the loader block.
                            //

                            sprintf( arcNameBuffer,
                                     "\\ArcName\\%s",
                                     LoaderBlock->ArcBootDeviceName );
                            RtlInitAnsiString( &arcNameString, arcNameBuffer );
                            status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                                                   &arcNameString,
                                                                   TRUE );
                            if (NT_SUCCESS( status )) {

                                IoCreateSymbolicLink( &arcNameUnicodeString,
                                                      &deviceNameUnicodeString );
                                RtlFreeUnicodeString( &arcNameUnicodeString );
                            }
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            break;
                        }
                        RtlFreeUnicodeString( &deviceNameUnicodeString );
                    }
                }
                ExFreePool(buffer);
            }
        }
    }

    if (diskList) {
        ExFreePool(diskList);
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
const GENERIC_MAPPING IopFileMapping = {
    STANDARD_RIGHTS_READ |
        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_EXECUTE,
    FILE_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif // ALLOC_DATA_PRAGMA
const GENERIC_MAPPING IopCompletionMapping = {
    STANDARD_RIGHTS_READ |
        IO_COMPLETION_QUERY_STATE,
    STANDARD_RIGHTS_WRITE |
        IO_COMPLETION_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    IO_COMPLETION_ALL_ACCESS
};

BOOLEAN
IopCreateObjectTypes(
    VOID
    )

/*++

Routine Description:

    This routine creates the object types used by the I/O system and its
    components.  The object types created are:

        Adapter
        Controller
        Device
        Driver
        File
        I/O Completion

Arguments:

    None.

Return Value:

    The function value is a BOOLEAN indicating whether or not the object
    types were successfully created.


--*/

{
    OBJECT_TYPE_INITIALIZER objectTypeInitializer;
    UNICODE_STRING nameString;

    //
    // Initialize the common fields of the Object Type Initializer record
    //

    RtlZeroMemory( &objectTypeInitializer, sizeof( objectTypeInitializer ) );
    objectTypeInitializer.Length = sizeof( objectTypeInitializer );
    objectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    objectTypeInitializer.GenericMapping = IopFileMapping;
    objectTypeInitializer.PoolType = NonPagedPool;
    objectTypeInitializer.ValidAccessMask = FILE_ALL_ACCESS;
    objectTypeInitializer.UseDefaultObject = TRUE;


    //
    // Create the object type for adapter objects.
    //

    RtlInitUnicodeString( &nameString, L"Adapter" );
    // objectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( struct _ADAPTER_OBJECT );
    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoAdapterObjectType ))) {
        return FALSE;
    }

#ifdef _PNP_POWER_

    //
    // Create the object type for device helper objects.
    //

    RtlInitUnicodeString( &nameString, L"DeviceHandler" );
    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoDeviceHandlerObjectType ))) {
        return FALSE;
    }
    IoDeviceHandlerObjectSize = sizeof(DEVICE_HANDLER_OBJECT);

#endif

    //
    // Create the object type for controller objects.
    //

    RtlInitUnicodeString( &nameString, L"Controller" );
    objectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( CONTROLLER_OBJECT );
    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoControllerObjectType ))) {
        return FALSE;
    }

    //
    // Create the object type for device objects.
    //

    RtlInitUnicodeString( &nameString, L"Device" );
    objectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( DEVICE_OBJECT );
    objectTypeInitializer.ParseProcedure = IopParseDevice;
    objectTypeInitializer.CaseInsensitive = TRUE;
    objectTypeInitializer.DeleteProcedure = IopDeleteDevice;
    objectTypeInitializer.SecurityProcedure = IopGetSetSecurityObject;
    objectTypeInitializer.QueryNameProcedure = (OB_QUERYNAME_METHOD)NULL;
    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoDeviceObjectType ))) {
        return FALSE;
    }

    //
    // Create the object type for driver objects.
    //

    RtlInitUnicodeString( &nameString, L"Driver" );
    objectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( DRIVER_OBJECT );
    objectTypeInitializer.ParseProcedure = (OB_PARSE_METHOD) NULL;
    objectTypeInitializer.DeleteProcedure = IopDeleteDriver;
    objectTypeInitializer.SecurityProcedure = (OB_SECURITY_METHOD) NULL;
    objectTypeInitializer.QueryNameProcedure = (OB_QUERYNAME_METHOD)NULL;


    //
    // This allows us to get a list of Driver objects.
    //
    if (IopVerifierOn) {
        objectTypeInitializer.MaintainTypeList = TRUE;
    }

    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoDriverObjectType ))) {
        return FALSE;
    }

    //
    // Create the object type for I/O completion objects.
    //

    RtlInitUnicodeString( &nameString, L"IoCompletion" );
    objectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( KQUEUE );
    objectTypeInitializer.InvalidAttributes = OBJ_PERMANENT | OBJ_OPENLINK;
    objectTypeInitializer.GenericMapping = IopCompletionMapping;
    objectTypeInitializer.ValidAccessMask = IO_COMPLETION_ALL_ACCESS;
    objectTypeInitializer.DeleteProcedure = IopDeleteIoCompletion;
    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoCompletionObjectType ))) {
        return FALSE;
    }

    //
    // Create the object type for file objects.
    //

    RtlInitUnicodeString( &nameString, L"File" );
    objectTypeInitializer.DefaultPagedPoolCharge = IO_FILE_OBJECT_PAGED_POOL_CHARGE;
    objectTypeInitializer.DefaultNonPagedPoolCharge = IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE +
                                                      sizeof( FILE_OBJECT );
    objectTypeInitializer.InvalidAttributes = OBJ_PERMANENT | OBJ_EXCLUSIVE | OBJ_OPENLINK;
    objectTypeInitializer.GenericMapping = IopFileMapping;
    objectTypeInitializer.ValidAccessMask = FILE_ALL_ACCESS;
    objectTypeInitializer.MaintainHandleCount = TRUE;
    objectTypeInitializer.CloseProcedure = IopCloseFile;
    objectTypeInitializer.DeleteProcedure = IopDeleteFile;
    objectTypeInitializer.ParseProcedure = IopParseFile;
    objectTypeInitializer.SecurityProcedure = IopGetSetSecurityObject;
    objectTypeInitializer.QueryNameProcedure = IopQueryName;
    objectTypeInitializer.UseDefaultObject = FALSE;

    PERFINFO_MUNG_FILE_OBJECT_TYPE_INITIALIZER(objectTypeInitializer);

    if (!NT_SUCCESS( ObCreateObjectType( &nameString,
                                      &objectTypeInitializer,
                                      (PSECURITY_DESCRIPTOR) NULL,
                                      &IoFileObjectType ))) {
        return FALSE;
    }

    PERFINFO_UNMUNG_FILE_OBJECT_TYPE_INITIALIZER(objectTypeInitializer);

    return TRUE;
}

BOOLEAN
IopCreateRootDirectories(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to create the object manager directory objects
    to contain the various device and file system driver objects.

Arguments:

    None.

Return Value:

    The function value is a BOOLEAN indicating whether or not the directory
    objects were successfully created.


--*/

{
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING nameString;
    NTSTATUS status;

    //
    // Create the root directory object for the \Driver directory.
    //

    RtlInitUnicodeString( &nameString, L"\\Driver" );
    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_PERMANENT|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = NtCreateDirectoryObject( &handle,
                                      DIRECTORY_ALL_ACCESS,
                                      &objectAttributes );
    if (!NT_SUCCESS( status )) {
        return FALSE;
    } else {
        (VOID) ObCloseHandle( handle , KernelMode);
    }

    //
    // Create the root directory object for the \FileSystem directory.
    //

    RtlInitUnicodeString( &nameString, L"\\FileSystem" );

    status = NtCreateDirectoryObject( &handle,
                                      DIRECTORY_ALL_ACCESS,
                                      &objectAttributes );
    if (!NT_SUCCESS( status )) {
        return FALSE;
    } else {
        (VOID) ObCloseHandle( handle , KernelMode);
    }

    //
    // Create the root directory object for the \FileSystem\Filters directory.
    //

    RtlInitUnicodeString( &nameString, L"\\FileSystem\\Filters" );

    status = NtCreateDirectoryObject( &handle,
                                      DIRECTORY_ALL_ACCESS,
                                      &objectAttributes );
    if (!NT_SUCCESS( status )) {
        return FALSE;
    } else {
        (VOID) ObCloseHandle( handle , KernelMode);
    }

    return TRUE;
}

NTSTATUS
IopInitializeAttributesAndCreateObject(
    IN PUNICODE_STRING ObjectName,
    IN OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PDRIVER_OBJECT *DriverObject
    )

/*++

Routine Description:

    This routine is invoked to initialize a set of object attributes and
    to create a driver object.

Arguments:

    ObjectName - Supplies the name of the driver object.

    ObjectAttributes - Supplies a pointer to the object attributes structure
        to be initialized.

    DriverObject - Supplies a variable to receive a pointer to the resultant
        created driver object.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;

    //
    // Simply initialize the object attributes and create the driver object.
    //

    InitializeObjectAttributes( ObjectAttributes,
                                ObjectName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ObCreateObject( KeGetPreviousMode(),
                             IoDriverObjectType,
                             ObjectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) (sizeof( DRIVER_OBJECT ) + sizeof ( DRIVER_EXTENSION )),
                             0,
                             0,
                             (PVOID *)DriverObject );
    return status;
}

NTSTATUS
IopInitializeBuiltinDriver(
    IN PUNICODE_STRING DriverName,
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_INITIALIZE DriverInitializeRoutine,
    IN PKLDR_DATA_TABLE_ENTRY DriverEntry,
    IN BOOLEAN IsFilter,
    IN PDRIVER_OBJECT *Result
    )

/*++

Routine Description:

    This routine is invoked to initialize a built-in driver.

Arguments:

    DriverName - Specifies the name to be used in creating the driver object.

    RegistryPath - Specifies the path to be used by the driver to get to
        the registry.

    DriverInitializeRoutine - Specifies the initialization entry point of
        the built-in driver.

    DriverEntry - Specifies the driver data table entry to determine if the
        driver is a wdm driver.

Return Value:

    The function returns a pointer to a DRIVER_OBJECT if the built-in
    driver successfully initialized.  Otherwise, a value of NULL is returned.

--*/

{
    HANDLE handle;
    PDRIVER_OBJECT driverObject;
    PDRIVER_OBJECT tmpDriverObject;
    OBJECT_ATTRIBUTES objectAttributes;
    PWSTR buffer;
    NTSTATUS status;
    HANDLE serviceHandle;
    PWSTR pserviceName;
    USHORT serviceNameLength;
    PDRIVER_EXTENSION driverExtension;
    PIMAGE_NT_HEADERS ntHeaders;
    PVOID imageBase;
#if DBG
    LARGE_INTEGER stime, etime;
    ULONG dtime;
#endif
    PLIST_ENTRY entry;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;

    *Result = NULL;
    //
    // Log the file name
    //
    HeadlessKernelAddLogEntry(HEADLESS_LOG_LOADING_FILENAME, DriverName);

    //
    // Begin by creating the driver object.
    //

    status = IopInitializeAttributesAndCreateObject( DriverName,
                                                     &objectAttributes,
                                                     &driverObject );
    if (!NT_SUCCESS( status )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
        return status;
    }

    //
    // Initialize the driver object.
    //

    InitializeDriverObject( driverObject );
    driverObject->DriverInit = DriverInitializeRoutine;

    //
    // Insert the driver object into the object table.
    //

    status = ObInsertObject( driverObject,
                             NULL,
                             FILE_READ_DATA,
                             0,
                             (PVOID *) NULL,
                             &handle );

    if (!NT_SUCCESS( status )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
        return status;
    }

    //
    // Reference the handle and obtain a pointer to the driver object so that
    // the handle can be deleted without the object going away.
    //

    status = ObReferenceObjectByHandle( handle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &tmpDriverObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    ASSERT(status == STATUS_SUCCESS);
    //
    // Fill in the DriverSection so the image will be automatically unloaded on
    // failures. We should use the entry from the PsModuleList.
    //

    entry = PsLoadedModuleList.Flink;
    while (entry != &PsLoadedModuleList && DriverEntry) {
        DataTableEntry = CONTAINING_RECORD(entry,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);
        if (RtlEqualString((PSTRING)&DriverEntry->BaseDllName,
                    (PSTRING)&DataTableEntry->BaseDllName,
                    TRUE
                    )) {
            driverObject->DriverSection = DataTableEntry;
            break;
        }
        entry = entry->Flink;
    }

    //
    // The boot process takes a while loading drivers.   Indicate that
    // progress is being made.
    //

    InbvIndicateProgress();

    //
    // Get start and sice for the DriverObject.
    //

    if (DriverEntry) {
        imageBase = DriverEntry->DllBase;
        ntHeaders = RtlImageNtHeader(imageBase);
        driverObject->DriverStart = imageBase;
        driverObject->DriverSize = ntHeaders->OptionalHeader.SizeOfImage;
        if (!(ntHeaders->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_WDM_DRIVER)) {
            driverObject->Flags |= DRVO_LEGACY_DRIVER;
        }
    } else {
        ntHeaders = NULL;
        imageBase = NULL;
        driverObject->Flags |= DRVO_LEGACY_DRIVER;
    }

    //
    // Save the name of the driver so that it can be easily located by functions
    // such as error logging.
    //

    buffer = ExAllocatePool( PagedPool, DriverName->MaximumLength + 2 );

    if (buffer) {
        driverObject->DriverName.Buffer = buffer;
        driverObject->DriverName.MaximumLength = DriverName->MaximumLength;
        driverObject->DriverName.Length = DriverName->Length;

        RtlCopyMemory( driverObject->DriverName.Buffer,
                       DriverName->Buffer,
                       DriverName->MaximumLength );
        buffer[DriverName->Length >> 1] = (WCHAR) '\0';
    }

    //
    // Save the name of the service key so that it can be easily located by PnP
    // mamager.
    //

    driverExtension = driverObject->DriverExtension;
    if (RegistryPath && RegistryPath->Length != 0) {
        pserviceName = RegistryPath->Buffer + RegistryPath->Length / sizeof (WCHAR) - 1;
        if (*pserviceName == OBJ_NAME_PATH_SEPARATOR) {
            pserviceName--;
        }
        serviceNameLength = 0;
        while (pserviceName != RegistryPath->Buffer) {
            if (*pserviceName == OBJ_NAME_PATH_SEPARATOR) {
                pserviceName++;
                break;
            } else {
                serviceNameLength += sizeof(WCHAR);
                pserviceName--;
            }
        }
        if (pserviceName == RegistryPath->Buffer) {
            serviceNameLength += sizeof(WCHAR);
        }
        buffer = ExAllocatePool( NonPagedPool, serviceNameLength + sizeof(UNICODE_NULL) );

        if (buffer) {
            driverExtension->ServiceKeyName.Buffer = buffer;
            driverExtension->ServiceKeyName.MaximumLength = serviceNameLength + sizeof(UNICODE_NULL);
            driverExtension->ServiceKeyName.Length = serviceNameLength;

            RtlCopyMemory( driverExtension->ServiceKeyName.Buffer,
                           pserviceName,
                           serviceNameLength );
            buffer[driverExtension->ServiceKeyName.Length >> 1] = UNICODE_NULL;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            driverExtension->ServiceKeyName.Buffer = NULL;
            driverExtension->ServiceKeyName.Length = 0;
            goto exit;
        }

        //
        // Prepare driver initialization
        //

        status = IopOpenRegistryKeyEx( &serviceHandle,
                                       NULL,
                                       RegistryPath,
                                       KEY_ALL_ACCESS
                                       );
        if (NT_SUCCESS(status)) {
            status = IopPrepareDriverLoading(&driverExtension->ServiceKeyName,
                                             serviceHandle,
                                             imageBase,
                                             IsFilter);
            NtClose(serviceHandle);
            if (!NT_SUCCESS(status)) {
                goto exit;
            }
        } else {
            goto exit;
        }
    } else {
        driverExtension->ServiceKeyName.Buffer = NULL;
        driverExtension->ServiceKeyName.MaximumLength = 0;
        driverExtension->ServiceKeyName.Length = 0;
    }

    //
    // Load the Registry information in the appropriate fields of the device
    // object.
    //

    driverObject->HardwareDatabase = &CmRegistryMachineHardwareDescriptionSystemName;

#if DBG
    KeQuerySystemTime (&stime);
#endif

    //
    // Now invoke the driver's initialization routine to initialize itself.
    //


    status = driverObject->DriverInit( driverObject, RegistryPath );


#if DBG

    //
    // If DriverInit took longer than 5 seconds or the driver did not load,
    // print a message.
    //

    KeQuerySystemTime (&etime);
    dtime  = (ULONG) ((etime.QuadPart - stime.QuadPart) / 1000000);

    if (dtime > 50  ||  !NT_SUCCESS( status )) {
        if (dtime < 10) {
            DbgPrint( "IOINIT: Built-in driver %wZ failed to initialize - %lX\n",
                DriverName, status );

        } else {
            DbgPrint( "IOINIT: Built-in driver %wZ took %d.%ds to ",
                DriverName, dtime/10, dtime%10 );

            if (NT_SUCCESS( status )) {
                DbgPrint ("initialize\n");
            } else {
                DbgPrint ("fail initialization - %lX\n", status);
            }
        }
    }
#endif
exit:

    NtClose( handle );

    if (NT_SUCCESS( status )) {
        IopReadyDeviceObjects( driverObject );
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_SUCCESSFUL, NULL);
        *Result = driverObject;
        return status;
    } else {
        if (status != STATUS_PLUGPLAY_NO_DEVICE) {

            //
            // if STATUS_PLUGPLAY_NO_DEVICE, the driver was disable by hardware profile.
            //

            IopDriverLoadingFailed(NULL, &driverObject->DriverExtension->ServiceKeyName);
        }
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
        ObMakeTemporaryObject(driverObject);
        ObDereferenceObject (driverObject);
        return status;
    }
}

BOOLEAN
IopMarkBootPartition(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine is invoked to locate and mark the boot partition device object
    as a boot device so that subsequent operations can fail more cleanly and
    with a better explanation of why the system failed to boot and run properly.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block created
        by the OS Loader during the boot process.  This structure contains
        the various system partition and boot device names and paths.

Return Value:

    The function value is TRUE if everything worked, otherwise FALSE.

Notes:

    If the boot partition device object cannot be found, then the system will
    bugcheck.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    STRING deviceNameString;
    CHAR deviceNameBuffer[256];
    UNICODE_STRING deviceNameUnicodeString;
    NTSTATUS status;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    PFILE_OBJECT fileObject;
    CHAR ArcNameFmt[12];

    ArcNameFmt[0] = '\\';
    ArcNameFmt[1] = 'A';
    ArcNameFmt[2] = 'r';
    ArcNameFmt[3] = 'c';
    ArcNameFmt[4] = 'N';
    ArcNameFmt[5] = 'a';
    ArcNameFmt[6] = 'm';
    ArcNameFmt[7] = 'e';
    ArcNameFmt[8] = '\\';
    ArcNameFmt[9] = '%';
    ArcNameFmt[10] = 's';
    ArcNameFmt[11] = '\0';
    //
    // Open the ARC boot device object. The boot device driver should have
    // created the object.
    //

    sprintf( deviceNameBuffer,
             ArcNameFmt,
             LoaderBlock->ArcBootDeviceName );

    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                           &deviceNameString,
                                           TRUE );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &deviceNameUnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwOpenFile( &fileHandle,
                         FILE_READ_ATTRIBUTES,
                         &objectAttributes,
                         &ioStatus,
                         0,
                         FILE_NON_DIRECTORY_FILE );
    if (!NT_SUCCESS( status )) {
        KeBugCheckEx( INACCESSIBLE_BOOT_DEVICE,
                      (ULONG_PTR) &deviceNameUnicodeString,
                      status,
                      0,
                      0 );
    }

    //
    // Convert the file handle into a pointer to the device object itself.
    //

    status = ObReferenceObjectByHandle( fileHandle,
                                        0,
                                        IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        RtlFreeUnicodeString( &deviceNameUnicodeString );
        return FALSE;
    }

    //
    // Mark the device object represented by the file object.
    //

    fileObject->DeviceObject->Flags |= DO_SYSTEM_BOOT_PARTITION;

    //
    // Save away the characteristics of boot device object for later
    // use in WinPE mode
    //
    if (InitIsWinPEMode) {
        if (fileObject->DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA) {
            InitWinPEModeType |= INIT_WINPEMODE_REMOVABLE_MEDIA;
        }

        if (fileObject->DeviceObject->Characteristics & FILE_READ_ONLY_DEVICE) {
            InitWinPEModeType |= INIT_WINPEMODE_READONLY_MEDIA;
        }
    }

    //
    // Reference the device object and store the reference.
    //
    ObReferenceObject(fileObject->DeviceObject);

    IopErrorLogObject =  fileObject->DeviceObject;

    RtlFreeUnicodeString( &deviceNameUnicodeString );

    //
    // Finally, close the handle and dereference the file object.
    //

    ObCloseHandle( fileHandle, KernelMode);
    ObDereferenceObject( fileObject );

    return TRUE;
}

BOOLEAN
IopReassignSystemRoot(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    OUT PSTRING NtDeviceName
    )

/*++

Routine Description:

    This routine is invoked to reassign \SystemRoot from being an ARC path
    name to its NT path name equivalent.  This is done by looking up the
    ARC device name as a symbolic link and determining which NT device object
    is referred to by it.  The link is then replaced with the new name.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block created
        by the OS Loader during the boot process.  This structure contains
        the various system partition and boot device names and paths.

    NtDeviceName - Specifies a pointer to a STRING to receive the NT name of
        the device from which the system was booted.

Return Value:

    The function value is a BOOLEAN indicating whether or not the ARC name
    was resolved to an NT name.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    CHAR deviceNameBuffer[256];
    WCHAR arcNameUnicodeBuffer[64];
    CHAR arcNameStringBuffer[256];
    STRING deviceNameString;
    STRING arcNameString;
    STRING linkString;
    UNICODE_STRING linkUnicodeString;
    UNICODE_STRING deviceNameUnicodeString;
    UNICODE_STRING arcNameUnicodeString;
    HANDLE linkHandle;

#if DBG

    CHAR debugBuffer[256];
    STRING debugString;
    UNICODE_STRING debugUnicodeString;

#endif
    CHAR ArcNameFmt[12];

    ArcNameFmt[0] = '\\';
    ArcNameFmt[1] = 'A';
    ArcNameFmt[2] = 'r';
    ArcNameFmt[3] = 'c';
    ArcNameFmt[4] = 'N';
    ArcNameFmt[5] = 'a';
    ArcNameFmt[6] = 'm';
    ArcNameFmt[7] = 'e';
    ArcNameFmt[8] = '\\';
    ArcNameFmt[9] = '%';
    ArcNameFmt[10] = 's';
    ArcNameFmt[11] = '\0';

    //
    // Open the ARC boot device symbolic link object. The boot device
    // driver should have created the object.
    //

    sprintf( deviceNameBuffer,
             ArcNameFmt,
             LoaderBlock->ArcBootDeviceName );

    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                           &deviceNameString,
                                           TRUE );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &deviceNameUnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = NtOpenSymbolicLinkObject( &linkHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &objectAttributes );

    if (!NT_SUCCESS( status )) {

#if DBG

        sprintf( debugBuffer, "IOINIT: unable to resolve %s, Status == %X\n",
                 deviceNameBuffer,
                 status );

        RtlInitAnsiString( &debugString, debugBuffer );

        status = RtlAnsiStringToUnicodeString( &debugUnicodeString,
                                               &debugString,
                                               TRUE );

        if (NT_SUCCESS( status )) {
            ZwDisplayString( &debugUnicodeString );
            RtlFreeUnicodeString( &debugUnicodeString );
        }

#endif // DBG

        RtlFreeUnicodeString( &deviceNameUnicodeString );
        return FALSE;
    }

    //
    // Get handle to \SystemRoot symbolic link.
    //

    arcNameUnicodeString.Buffer = arcNameUnicodeBuffer;
    arcNameUnicodeString.Length = 0;
    arcNameUnicodeString.MaximumLength = sizeof( arcNameUnicodeBuffer );

    status = NtQuerySymbolicLinkObject( linkHandle,
                                        &arcNameUnicodeString,
                                        NULL );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    arcNameString.Buffer = arcNameStringBuffer;
    arcNameString.Length = 0;
    arcNameString.MaximumLength = sizeof( arcNameStringBuffer );

    status = RtlUnicodeStringToAnsiString( &arcNameString,
                                           &arcNameUnicodeString,
                                           FALSE );

    arcNameStringBuffer[arcNameString.Length] = '\0';

    ObCloseHandle( linkHandle, KernelMode );
    RtlFreeUnicodeString( &deviceNameUnicodeString );

    RtlInitAnsiString( &linkString, INIT_SYSTEMROOT_LINKNAME );

    status = RtlAnsiStringToUnicodeString( &linkUnicodeString,
                                           &linkString,
                                           TRUE);

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &linkUnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = NtOpenSymbolicLinkObject( &linkHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &objectAttributes );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    NtMakeTemporaryObject( linkHandle );
    ObCloseHandle( linkHandle, KernelMode );

    sprintf( deviceNameBuffer,
             "%Z%s",
             &arcNameString,
             LoaderBlock->NtBootPathName );

    //
    // Get NT device name for \SystemRoot assignment.
    //

    RtlCopyString( NtDeviceName, &arcNameString );

    deviceNameBuffer[strlen(deviceNameBuffer)-1] = '\0';

    RtlInitAnsiString(&deviceNameString, deviceNameBuffer);

    InitializeObjectAttributes( &objectAttributes,
                                &linkUnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                           &deviceNameString,
                                           TRUE);

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    status = NtCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         &arcNameUnicodeString );

    RtlFreeUnicodeString( &arcNameUnicodeString );
    RtlFreeUnicodeString( &linkUnicodeString );
    ObCloseHandle( linkHandle, KernelMode );

#if DBG

    if (NT_SUCCESS( status )) {

        sprintf( debugBuffer,
                 "INIT: Reassigned %s => %s\n",
                 INIT_SYSTEMROOT_LINKNAME,
                 deviceNameBuffer );

    } else {

        sprintf( debugBuffer,
                 "INIT: unable to create %s => %s, Status == %X\n",
                 INIT_SYSTEMROOT_LINKNAME,
                 deviceNameBuffer,
                 status );
    }

    RtlInitAnsiString( &debugString, debugBuffer );

    status = RtlAnsiStringToUnicodeString( &debugUnicodeString,
                                           &debugString,
                                           TRUE );

    if (NT_SUCCESS( status )) {

        ZwDisplayString( &debugUnicodeString );
        RtlFreeUnicodeString( &debugUnicodeString );
    }

#endif // DBG

    return TRUE;
}

VOID
IopStoreSystemPartitionInformation(
    IN     PUNICODE_STRING NtSystemPartitionDeviceName,
    IN OUT PUNICODE_STRING OsLoaderPathName
    )

/*++

Routine Description:

    This routine writes two values to the registry (under HKLM\SYSTEM\Setup)--one
    containing the NT device name of the system partition and the other containing
    the path to the OS loader.  These values will later be migrated into a
    Win95-compatible registry location (NT path converted to DOS path), so that
    installation programs (including our own setup) have a rock-solid way of knowing
    what the system partition is, on both ARC and x86.

    ERRORS ENCOUNTERED IN THIS ROUTINE ARE NOT CONSIDERED FATAL.

Arguments:

    NtSystemPartitionDeviceName - supplies the NT device name of the system partition.
        This is the \Device\Harddisk<n>\Partition<m> name, which used to be the actual
        device name, but now is a symbolic link to a name of the form \Device\Volume<x>.
        We open up this symbolic link, and retrieve the name that it points to.  The
        target name is the one we store away in the registry.

    OsLoaderPathName - supplies the path (on the partition specified in the 1st parameter)
        where the OS loader is located.  Upon return, this path will have had its trailing
        backslash removed (if present, and path isn't root).

Return Value:

    None.

--*/

{
    NTSTATUS status;
    HANDLE linkHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE systemHandle, setupHandle;
    UNICODE_STRING nameString, volumeNameString;
    WCHAR voumeNameStringBuffer[256];
    //
    // Declare a unicode buffer big enough to contain the longest string we'll be using.
    // (ANSI string in 'sizeof()' below on purpose--we want the number of chars here.)
    //
    WCHAR nameBuffer[sizeof("SystemPartition")];

    //
    // Both UNICODE_STRING buffers should be NULL-terminated.
    //

    ASSERT( NtSystemPartitionDeviceName->MaximumLength >= NtSystemPartitionDeviceName->Length + sizeof(WCHAR) );
    ASSERT( NtSystemPartitionDeviceName->Buffer[NtSystemPartitionDeviceName->Length / sizeof(WCHAR)] == L'\0' );

    ASSERT( OsLoaderPathName->MaximumLength >= OsLoaderPathName->Length + sizeof(WCHAR) );
    ASSERT( OsLoaderPathName->Buffer[OsLoaderPathName->Length / sizeof(WCHAR)] == L'\0' );

    //
    // Open the NtSystemPartitionDeviceName symbolic link, and find out the volume device
    // it points to.
    //

    InitializeObjectAttributes(&objectAttributes,
                               NtSystemPartitionDeviceName,
                               OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                              );

    status = NtOpenSymbolicLinkObject(&linkHandle,
                                      SYMBOLIC_LINK_QUERY,
                                      &objectAttributes
                                     );

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't open symbolic link %wZ - %x\n",
                 NtSystemPartitionDeviceName,
                 status
                );
#endif // DBG
        return;
    }

    volumeNameString.Buffer = voumeNameStringBuffer;
    volumeNameString.Length = 0;
    //
    // Leave room at the end of the buffer for a terminating null, in case we need to add one.
    //
    volumeNameString.MaximumLength = sizeof(voumeNameStringBuffer) - sizeof(WCHAR);

    status = NtQuerySymbolicLinkObject(linkHandle,
                                       &volumeNameString,
                                       NULL
                                      );

    //
    // We don't need the handle to the symbolic link any longer.
    //

    ObCloseHandle(linkHandle, KernelMode);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't query symbolic link %wZ - %x\n",
                 NtSystemPartitionDeviceName,
                 status
                );
#endif // DBG
        return;
    }

    //
    // Make sure the volume name string is null-terminated.
    //

    volumeNameString.Buffer[volumeNameString.Length / sizeof(WCHAR)] = L'\0';

    //
    // Open HKLM\SYSTEM key.
    //

    status = IopOpenRegistryKeyEx( &systemHandle,
                                   NULL,
                                   &CmRegistryMachineSystemName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't open \\REGISTRY\\MACHINE\\SYSTEM - %x\n", status);
#endif // DBG
        return;
    }

    //
    // Now open/create the setup subkey.
    //

    ASSERT( sizeof(L"Setup") <= sizeof(nameBuffer) );

    nameBuffer[0] = L'S';
    nameBuffer[1] = L'e';
    nameBuffer[2] = L't';
    nameBuffer[3] = L'u';
    nameBuffer[4] = L'p';
    nameBuffer[5] = L'\0';

    nameString.MaximumLength = sizeof(L"Setup");
    nameString.Length        = sizeof(L"Setup") - sizeof(WCHAR);
    nameString.Buffer        = nameBuffer;

    status = IopCreateRegistryKeyEx( &setupHandle,
                                     systemHandle,
                                     &nameString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    ObCloseHandle(systemHandle, KernelMode);  // Don't need the handle to the HKLM\System key anymore.

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't open Setup subkey - %x\n", status);
#endif // DBG
        return;
    }

    ASSERT( sizeof(L"SystemPartition") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'S';
    nameBuffer[1]  = L'y';
    nameBuffer[2]  = L's';
    nameBuffer[3]  = L't';
    nameBuffer[4]  = L'e';
    nameBuffer[5]  = L'm';
    nameBuffer[6]  = L'P';
    nameBuffer[7]  = L'a';
    nameBuffer[8]  = L'r';
    nameBuffer[9]  = L't';
    nameBuffer[10] = L'i';
    nameBuffer[11] = L't';
    nameBuffer[12] = L'i';
    nameBuffer[13] = L'o';
    nameBuffer[14] = L'n';
    nameBuffer[15] = L'\0';

    nameString.MaximumLength = sizeof(L"SystemPartition");
    nameString.Length        = sizeof(L"SystemPartition") - sizeof(WCHAR);



    status = NtSetValueKey(setupHandle,
                            &nameString,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            volumeNameString.Buffer,
                            volumeNameString.Length + sizeof(WCHAR)
                           );


#if DBG
    if (!NT_SUCCESS(status)) {
        DbgPrint("IopStoreSystemPartitionInformation: couldn't write SystemPartition value - %x\n", status);
    }
#endif // DBG

    ASSERT( sizeof(L"OsLoaderPath") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'O';
    nameBuffer[1]  = L's';
    nameBuffer[2]  = L'L';
    nameBuffer[3]  = L'o';
    nameBuffer[4]  = L'a';
    nameBuffer[5]  = L'd';
    nameBuffer[6]  = L'e';
    nameBuffer[7]  = L'r';
    nameBuffer[8]  = L'P';
    nameBuffer[9]  = L'a';
    nameBuffer[10] = L't';
    nameBuffer[11] = L'h';
    nameBuffer[12] = L'\0';

    nameString.MaximumLength = sizeof(L"OsLoaderPath");
    nameString.Length        = sizeof(L"OsLoaderPath") - sizeof(WCHAR);

    //
    // Strip off the trailing backslash from the path (unless, of course, the path is a
    // single backslash).
    //

    if ((OsLoaderPathName->Length > sizeof(WCHAR)) &&
        (*(PWCHAR)((PCHAR)OsLoaderPathName->Buffer + OsLoaderPathName->Length - sizeof(WCHAR)) == L'\\')) {

        OsLoaderPathName->Length -= sizeof(WCHAR);
        *(PWCHAR)((PCHAR)OsLoaderPathName->Buffer + OsLoaderPathName->Length) = L'\0';
    }

    status = NtSetValueKey(setupHandle,
                           &nameString,
                           TITLE_INDEX_VALUE,
                           REG_SZ,
                           OsLoaderPathName->Buffer,
                           OsLoaderPathName->Length + sizeof(WCHAR)
                           );
#if DBG
    if (!NT_SUCCESS(status)) {
        DbgPrint("IopStoreSystemPartitionInformation: couldn't write OsLoaderPath value - %x\n", status);
    }
#endif // DBG

    ObCloseHandle(setupHandle, KernelMode);
}

NTSTATUS
IopLogErrorEvent(
    IN ULONG            SequenceNumber,
    IN ULONG            UniqueErrorValue,
    IN NTSTATUS         FinalStatus,
    IN NTSTATUS         SpecificIOStatus,
    IN ULONG            LengthOfInsert1,
    IN PWCHAR           Insert1,
    IN ULONG            LengthOfInsert2,
    IN PWCHAR           Insert2
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:
    SequenceNumber - A value that is unique to an IRP over the life of the irp in
    this driver. - 0 generally means an error not associated with an IRP

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    STATUS_SUCCESS - Success
    STATUS_INVALID_HANDLE - Uninitialized error log device object
    STATUS_NO_DATA_DETECTED - NULL Error log entry

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PUCHAR ptrToFirstInsert;
    PUCHAR ptrToSecondInsert;

    if (!IopErrorLogObject) {
        return(STATUS_INVALID_HANDLE);
    }


    errorLogEntry = IoAllocateErrorLogEntry(
                        IopErrorLogObject,
                        (UCHAR)( sizeof(IO_ERROR_LOG_PACKET) +
                                LengthOfInsert1 +
                                LengthOfInsert2) );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = 0;
      errorLogEntry->RetryCount = 0;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = 0;

      ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         } //LenghtOfInsert2

      } // LenghtOfInsert1

      IoWriteErrorLogEntry(errorLogEntry);
      return(STATUS_SUCCESS);

   }  // errorLogEntry != NULL

    return(STATUS_NO_DATA_DETECTED);

} //IopLogErrorEvent

BOOLEAN
IopInitializeReserveIrp(
    PIOP_RESERVE_IRP_ALLOCATOR  Allocator
    )
/*++

Routine Description:

    This routine initializes the reserve IRP allocator for paging reads.

Arguments:

    Allocator - Pointer to the reserve IRP allocator structure.
        created by the OS Loader.

Return Value:

    The function value is a BOOLEAN indicating whether or not the reserver allocator
    was successfully initialized.

--*/
{
    Allocator->ReserveIrpStackSize = MAX_RESERVE_IRP_STACK_SIZE;
    Allocator->ReserveIrp = IoAllocateIrp(MAX_RESERVE_IRP_STACK_SIZE, FALSE);
    if (Allocator->ReserveIrp == NULL) {
        return FALSE;
    }

    Allocator->IrpAllocated = FALSE;
    KeInitializeEvent(&Allocator->Event, SynchronizationEvent, FALSE);

    return TRUE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\ioperf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   ioPerf.c

Abstract:

    This module contains the routines to collect performance info for driver calls...

Author:

    Mike Fortin (mrfortin) May 8, 2000

Revision History:

--*/

#include "iomgr.h"

#if (( defined(_X86_) ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

NTSTATUS
IoPerfInit(
    );

NTSTATUS
IoPerfReset(
    );

NTSTATUS
FASTCALL
IoPerfCallDriver(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress
    );

VOID
FASTCALL
IoPerfCompleteRequest (
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#ifndef NTPERF
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWMI, IoPerfCallDriver)
#pragma alloc_text(PAGEWMI, IoPerfInit)
#pragma alloc_text(PAGEWMI, IoPerfReset)
#pragma alloc_text(PAGEWMI, IopPerfLogFileCreate)
#endif
#endif // NTPERF


NTSTATUS
IoPerfInit(
    )
{
    if ( IopVerifierOn ){
        // We will not log driver hooks if the verifier has
        // also been turned on
        // Probably want to log some event or make a testenv note about
        // the perf implications of having the verifier turned on
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Enable and hook in the Perf Routines
    //
    InterlockedExchangePointer((PVOID *)&pIofCallDriver, (PVOID) IoPerfCallDriver);
    InterlockedExchangePointer((PVOID *)&pIofCompleteRequest, (PVOID) IoPerfCompleteRequest);

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    return STATUS_SUCCESS;
}

NTSTATUS
IoPerfReset(
    )
{
    if ( IopVerifierOn ){
        // We did not replace the function ptrs if the verifier
        // also was turned on, so just return
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Reset to init values, see IopSetIoRoutines
    //
    InterlockedExchangePointer((PVOID *)&pIofCallDriver, NULL);
    InterlockedExchangePointer((PVOID *)&pIofCompleteRequest, (PVOID) IopfCompleteRequest);

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    return STATUS_SUCCESS;
}


LONG IopPerfDriverUniqueMatchId;

NTSTATUS
FASTCALL
IoPerfCallDriver(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress
    )

/*++

Routine Description:

    This routine is invoked to pass an I/O Request Packet (IRP) to another
    driver at its dispatch routine, logging perf data along the way.

Arguments:

    DeviceObject - Pointer to device object to which the IRP should be passed.

    Irp - Pointer to IRP for request.

Return Value:

    Return status from driver's dispatch routine.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVER_OBJECT driverObject;
    NTSTATUS status;
    PVOID PerfInfoRoutineAddr;
    ULONG MatchId;
#ifdef NTPERF
    ULONGLONG  PerfInfoTimeOfCall = PerfGetCycleCount();
#endif // NTPERF

    //
    // Ensure that this is really an I/O Request Packet.
    //
    UNREFERENCED_PARAMETER(ReturnAddress);

    ASSERT( Irp->Type == IO_TYPE_IRP );

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Invoke the driver at its dispatch routine entry point.
    //

    driverObject = DeviceObject->DriverObject;

    //
    // Prevent the driver from unloading.
    //

    ObReferenceObject(DeviceObject);

    MatchId = InterlockedIncrement( &IopPerfDriverUniqueMatchId );

    PerfInfoRoutineAddr = (PVOID) (ULONG_PTR) driverObject->MajorFunction[irpSp->MajorFunction];

    //
    // Log the Call Event
    //
    if (PERFINFO_IS_GROUP_ON(PERF_DRIVERS)) {
        PERFINFO_DRIVER_MAJORFUNCTION MFInfo;
        MFInfo.MajorFunction = irpSp->MajorFunction;
        MFInfo.MinorFunction = irpSp->MinorFunction;
        MFInfo.RoutineAddr = (PVOID) (ULONG_PTR) driverObject->MajorFunction[irpSp->MajorFunction];
        MFInfo.Irp = Irp;
        MFInfo.UniqMatchId = MatchId;
        if (Irp->Flags & IRP_ASSOCIATED_IRP) {
            ASSERT (Irp->AssociatedIrp.MasterIrp != NULL);
            if (Irp->AssociatedIrp.MasterIrp != NULL) {
                //
                // The check for MasterIrp is defensive code.
                // We have hit a bugcechk when a filter driver set the
                // IRP_ASSOCIATED_IRP bit while MasterIrp pointing to NULL.
                //
                // The ASSERT above was to catch similar problems before we release.
                //
                MFInfo.FileNamePointer = Irp->AssociatedIrp.MasterIrp->Tail.Overlay.OriginalFileObject;
            } else {
                MFInfo.FileNamePointer = NULL;
            }
        } else {
            MFInfo.FileNamePointer = Irp->Tail.Overlay.OriginalFileObject;
        }
        PerfInfoLogBytes(
            PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_CALL,
            &MFInfo,
            sizeof(MFInfo)
            );
    }

    //
    // Do the normal IopfCallDriver work
    //
    status = IopfCallDriver(DeviceObject, Irp );

    //
    // Log the Return
    //
    if (PERFINFO_IS_GROUP_ON(PERF_DRIVERS)) {
        PERFINFO_DRIVER_MAJORFUNCTION_RET MFInfo;
        MFInfo.Irp = Irp;
        MFInfo.UniqMatchId = MatchId;

        PERFINFO_DRIVER_INTENTIONAL_DELAY();

        PerfInfoLogBytes(
            PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_RETURN,
            &MFInfo,
            sizeof(MFInfo)
            );

        PERFINFO_DRIVER_STACKTRACE();
    }

    ObDereferenceObject(DeviceObject);

    return status;
}

VOID
FASTCALL
IoPerfCompleteRequest (
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is invoked when a driver completes an IRP, logging perf data
    along the way.

Arguments:

    Irp - Pointer to IRP for completed request.

    PriorityBoost - Priority boost specified by the driver completing the IRP.

Return Value:

    None.

--*/

{
    PERFINFO_DRIVER_COMPLETE_REQUEST CompleteRequest;
    PERFINFO_DRIVER_COMPLETE_REQUEST_RET CompleteRequestRet;
    PIO_STACK_LOCATION irpSp;
    PVOID DriverRoutineAddr;
    ULONG MatchId;

    //
    // Initialize locals.
    //

    DriverRoutineAddr = NULL;

    //
    // If the packet looks weird/improper pass it on to the real IO completion routine
    // directly.
    //

    if (Irp->Type != IO_TYPE_IRP || Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1)) {
        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    //
    // Get current stack location and save the driver routine address to
    // identify the driver that was processing the IRP when it got completed. If
    // device object is NULL, try to get the completion routine addr.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if (irpSp->DeviceObject) {

        //
        // We don't want to cause a bugcheck in this code even when something else is
        // corrupt.
        //

        ASSERT(irpSp->DeviceObject->DriverObject);

        if (irpSp->DeviceObject->DriverObject) {

            ASSERT(irpSp->MajorFunction <= IRP_MJ_MAXIMUM_FUNCTION);

            if (irpSp->MajorFunction <= IRP_MJ_MAXIMUM_FUNCTION) {

                DriverRoutineAddr = (PVOID) (ULONG_PTR) irpSp->DeviceObject->DriverObject->MajorFunction[irpSp->MajorFunction];
            }
        }

    } else {

        DriverRoutineAddr = (PVOID) (ULONG_PTR) irpSp->CompletionRoutine;
    }

    //
    // Bump the ID that gets used to match COMPLETE_REQUEST and COMPLETE_REQUEST_RET
    // entries logged for an IRP completion.
    //

    MatchId = InterlockedIncrement( &IopPerfDriverUniqueMatchId );

    //
    // Log the start of the completion.
    //

    if (PERFINFO_IS_GROUP_ON(PERF_DRIVERS)) {

        CompleteRequest.Irp = Irp;
        CompleteRequest.UniqMatchId = MatchId;
        CompleteRequest.RoutineAddr = DriverRoutineAddr;

        PerfInfoLogBytes(
            PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST,
            &CompleteRequest,
            sizeof(CompleteRequest)
            );
    }

    //
    // Do the normal IopfCompleteIrp work.
    //

    IopfCompleteRequest(Irp, PriorityBoost);

    //
    // After this point no fields of Irp should be accessed. E.g. the Irp may
    // have been freed / reallocated etc. by a completion routine.
    //

    //
    // Log the return.
    //

    if (PERFINFO_IS_GROUP_ON(PERF_DRIVERS)) {

        CompleteRequestRet.Irp = Irp;
        CompleteRequestRet.UniqMatchId = MatchId;

        PerfInfoLogBytes(
            PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST_RETURN,
            &CompleteRequestRet,
            sizeof(CompleteRequestRet)
            );
    }

    return;
}


VOID
IopPerfLogFileCreate(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING CompleteName
    )
{
    PERFINFO_LOG_FILE_CREATE(FileObject, CompleteName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\iomgr.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    iomgr.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

Author:

    Nar Ganapathy (narg) 1-Jan-1999


Revision History:

--*/

#ifndef _IOMGR_
#define _IOMGR_
//
// Define Information fields values for the return value from popups when a
// volume mount is in progress but failed.
//

#define IOP_ABORT                       1

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional expression

#include "ntos.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "mountmgr.h"
#include "ntiolog.h"
#include "ntiologc.h"
#include "ntseapi.h"
#include "fsrtl.h"
#include "zwapi.h"

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "safeboot.h"
#include "ioverifier.h"

#include "iopcmn.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  oI')
#undef ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  oI')
#endif

typedef struct _DUMP_CONTROL_BLOCK DUMP_CONTROL_BLOCK, *PDUMP_CONTROL_BLOCK;

//
// Define the type for entries placed on the driver reinitialization queue.
// These entries are entered onto the tail when the driver requests that
// it be reinitialized, and removed from the head by the code that actually
// performs the reinitialization.
//

typedef struct _REINIT_PACKET {
    LIST_ENTRY ListEntry;
    PDRIVER_OBJECT DriverObject;
    PDRIVER_REINITIALIZE DriverReinitializationRoutine;
    PVOID Context;
} REINIT_PACKET, *PREINIT_PACKET;


//
// Define transfer types for process counters.
//

typedef enum _TRANSFER_TYPE {
    ReadTransfer,
    WriteTransfer,
    OtherTransfer
} TRANSFER_TYPE, *PTRANSFER_TYPE;

//
// Define the maximum amount of memory that can be allocated for all
// outstanding error log packets.
//

#define IOP_MAXIMUM_LOG_ALLOCATION (100*PAGE_SIZE)

//
// Define an error log entry.
//

typedef struct _ERROR_LOG_ENTRY {
    USHORT Type;
    USHORT Size;
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
    PDRIVER_OBJECT DriverObject;
    LARGE_INTEGER TimeStamp;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
//  Define both the global IOP_HARD_ERROR_QUEUE and IOP_HARD_ERROR_PACKET
//  structures.   Also set the maximum number of outstanding hard error
//  packets allowed.
//

typedef struct _IOP_HARD_ERROR_QUEUE {
    WORK_QUEUE_ITEM ExWorkItem;
    LIST_ENTRY WorkQueue;
    KSPIN_LOCK WorkQueueSpinLock;
    KSEMAPHORE WorkQueueSemaphore;
    BOOLEAN ThreadStarted;
    LONG   NumPendingApcPopups;
} IOP_HARD_ERROR_QUEUE, *PIOP_HARD_ERROR_QUEUE;

typedef struct _IOP_HARD_ERROR_PACKET {
    LIST_ENTRY WorkQueueLinks;
    NTSTATUS ErrorStatus;
    UNICODE_STRING String;
} IOP_HARD_ERROR_PACKET, *PIOP_HARD_ERROR_PACKET;

typedef struct _IOP_APC_HARD_ERROR_PACKET {
    WORK_QUEUE_ITEM Item;
    PIRP Irp;
    PVPB Vpb;
    PDEVICE_OBJECT RealDeviceObject;
} IOP_APC_HARD_ERROR_PACKET, *PIOP_APC_HARD_ERROR_PACKET;

typedef
NTSTATUS
(FASTCALL *PIO_CALL_DRIVER) (
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress
    );

typedef
VOID
(FASTCALL *PIO_COMPLETE_REQUEST) (
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

typedef
VOID
(*PIO_FREE_IRP) (
    IN struct _IRP *Irp
    );

typedef
PIRP
(*PIO_ALLOCATE_IRP) (
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota
    );

extern IOP_HARD_ERROR_QUEUE IopHardError;
extern PIOP_HARD_ERROR_PACKET IopCurrentHardError;

#define IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS 25

typedef struct _IO_WORKITEM {
    WORK_QUEUE_ITEM WorkItem;
    PIO_WORKITEM_ROUTINE Routine;
    PDEVICE_OBJECT DeviceObject;
    PVOID Context;
#if DBG
    ULONG Size;
#endif
} IO_WORKITEM;

//
// Define the global data for the error logger and I/O system.
//

extern WORK_QUEUE_ITEM IopErrorLogWorkItem;
extern BOOLEAN IopErrorLogPortPending;
extern BOOLEAN IopErrorLogDisabledThisBoot;
extern KSPIN_LOCK IopErrorLogLock;
extern LIST_ENTRY IopErrorLogListHead;
extern LONG IopErrorLogAllocation;
extern KSPIN_LOCK IopErrorLogAllocationLock;
extern const GENERIC_MAPPING IopFileMapping;

//
// Define a dummy file object for use on stack for fast open operations.
//

typedef struct _DUMMY_FILE_OBJECT {
    OBJECT_HEADER ObjectHeader;
    CHAR FileObjectBody[ sizeof( FILE_OBJECT ) ];
} DUMMY_FILE_OBJECT, *PDUMMY_FILE_OBJECT;

//
// Define the structures private to the I/O system.
//

#define OPEN_PACKET_PATTERN  0xbeaa0251

//
// Define an Open Packet (OP).  An OP is used to communicate information
// between the NtCreateFile service executing in the context of the caller
// and the device object parse routine.  It is the parse routine who actually
// creates the file object for the file.
//

typedef struct _OPEN_PACKET {
    CSHORT Type;
    CSHORT Size;
    PFILE_OBJECT FileObject;
    NTSTATUS FinalStatus;
    ULONG_PTR Information;
    ULONG ParseCheck;
    PFILE_OBJECT RelatedFileObject;

    //
    // The following are the open-specific parameters.  Notice that the desired
    // access field is passed through to the parse routine via the object
    // management architecture, so it does not need to be repeated here.  Also
    // note that the same is true for the file name.
    //

    LARGE_INTEGER AllocationSize;
    ULONG CreateOptions;
    USHORT FileAttributes;
    USHORT ShareAccess;
    PVOID EaBuffer;
    ULONG EaLength;
    ULONG Options;
    ULONG Disposition;

    //
    // The following is used when performing a fast query during open to get
    // back the file attributes for a file.
    //

    PFILE_BASIC_INFORMATION BasicInformation;

    //
    // The following is used when performing a fast network query during open
    // to get back the network file attributes for a file.
    //

    PFILE_NETWORK_OPEN_INFORMATION NetworkInformation;

    //
    // The type of file to create.
    //

    CREATE_FILE_TYPE CreateFileType;

    //
    // The following pointer provides a way of passing the parameters
    // specific to the file type of the file being created to the parse
    // routine.
    //

    PVOID ExtraCreateParameters;

    //
    // The following is used to indicate that an open of a device has been
    // performed and the access check for the device has already been done,
    // but because of a reparse, the I/O system has been called again for
    // the same device.  Since the access check has already been made, the
    // state cannot handle being called again (access was already granted)
    // and it need not anyway since the check has already been made.
    //

    BOOLEAN Override;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of querying its attributes.  This causes a considerable
    // number of shortcuts to be taken in the parse, query, and close paths.
    //

    BOOLEAN QueryOnly;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of deleting it.  This causes a considerable number of
    // shortcurs to be taken in the parse and close paths.
    //

    BOOLEAN DeleteOnly;

    //
    // The following is used to indicate that a file being opened for a query
    // only is being opened to query its network attributes rather than just
    // its FAT file attributes.
    //

    BOOLEAN FullAttributes;

    //
    // The following pointer is used when a fast open operation for a fast
    // delete or fast query attributes call is being made rather than a
    // general file open.  The dummy file object is actually stored on the
    // the caller's stack rather than allocated pool to speed things up.
    //

    PDUMMY_FILE_OBJECT LocalFileObject;

    //
    // The following is used to indicate we passed through a mount point while
    // parsing the filename. We use this to do an extra check on the device type
    // for the final file
    //

    BOOLEAN TraversedMountPoint;

    //
    // Device object where the create should start if present on the stack
    // Applicable for kernel opens only.
    //

    ULONG           InternalFlags;      // Passed from IopCreateFile
    PDEVICE_OBJECT  TopDeviceObjectHint;

} OPEN_PACKET, *POPEN_PACKET;

//
// Define a Load Packet (LDP).  An LDP is used to communicate load and unload
// driver information between the appropriate system services and the routine
// that actually performs the work.  This is implemented using a packet
// because various drivers need to be initialized in the context of THE
// system process because they create threads within its context which open
// handles to objects that henceforth are only valid in the context of that
// process.
//

typedef struct _LOAD_PACKET {
    WORK_QUEUE_ITEM WorkQueueItem;
    KEVENT Event;
    PDRIVER_OBJECT DriverObject;
    PUNICODE_STRING DriverServiceName;
    NTSTATUS FinalStatus;
} LOAD_PACKET, *PLOAD_PACKET;

//
// Define a Link Tracking Packet.  A link tracking packet is used to open the
// user-mode link tracking service's LPC port so that information about objects
// which have been moved can be tracked.
//

typedef struct _LINK_TRACKING_PACKET {
    WORK_QUEUE_ITEM WorkQueueItem;
    KEVENT Event;
    NTSTATUS FinalStatus;
} LINK_TRACKING_PACKET, *PLINK_TRACKING_PACKET;


//
// Define the type for entries placed on the driver shutdown notification queue.
// These entries represent those drivers that would like to be notified that the
// system is begin shutdown before it actually goes down.
//

typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

//
// Define the type for entries placed on the file system registration change
// notification queue.
//

typedef struct _NOTIFICATION_PACKET {
    LIST_ENTRY ListEntry;
    PDRIVER_OBJECT DriverObject;
    PDRIVER_FS_NOTIFICATION NotificationRoutine;
} NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

//
// Define I/O completion packet types.
//

typedef enum _COMPLETION_PACKET_TYPE {
    IopCompletionPacketIrp,
    IopCompletionPacketMini,
    IopCompletionPacketQuota
} COMPLETION_PACKET_TYPE, *PCOMPLETION_PACKET_TYPE;

//
// Define the type for completion packets inserted onto completion ports when
// there is no full I/O request packet that was used to perform the I/O
// operation.  This occurs when the fast I/O path is used, and when the user
// directly inserts a completion message.
//
typedef struct _IOP_MINI_COMPLETION_PACKET {

    //
    // The following unnamed structure must be exactly identical
    // to the unnamed structure used in the IRP overlay section used
    // for completion queue entries.
    //

    struct {

        //
        // List entry - used to queue the packet to completion queue, among
        // others.
        //

        LIST_ENTRY ListEntry;

        union {

            //
            // Current stack location - contains a pointer to the current
            // IO_STACK_LOCATION structure in the IRP stack.  This field
            // should never be directly accessed by drivers.  They should
            // use the standard functions.
            //

            struct _IO_STACK_LOCATION *CurrentStackLocation;

            //
            // Minipacket type.
            //

            ULONG PacketType;
        };
    };

    PVOID KeyContext;
    PVOID ApcContext;
    NTSTATUS IoStatus;
    ULONG_PTR IoStatusInformation;
} IOP_MINI_COMPLETION_PACKET, *PIOP_MINI_COMPLETION_PACKET;

typedef struct _IO_UNLOAD_SAFE_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PVOID Context;
    PIO_COMPLETION_ROUTINE CompletionRoutine;
} IO_UNLOAD_SAFE_COMPLETION_CONTEXT, *PIO_UNLOAD_SAFE_COMPLETION_CONTEXT;

typedef struct  _IOP_RESERVE_IRP_ALLOCATOR {
    PIRP    ReserveIrp;
    LONG    IrpAllocated;
    KEVENT  Event;
    CCHAR   ReserveIrpStackSize;
} IOP_RESERVE_IRP_ALLOCATOR, *PIOP_RESERVE_IRP_ALLOCATOR;

//
// This structure is the extension to a fileobject if the flag
// FO_FILE_OBJECT_HAS_EXTENSION is set in the fileobject.
//

typedef struct _IOP_FILE_OBJECT_EXTENSION {
    ULONG           FileObjectExtensionFlags;
    PDEVICE_OBJECT  TopDeviceObjectHint;
    PVOID           FilterContext;          // Pointer where filter keeps its context
} IOP_FILE_OBJECT_EXTENSION, *PIOP_FILE_OBJECT_EXTENSION;

//
// Structure to bookkeep stack profiler.
//

#define MAX_LOOKASIDE_IRP_STACK_COUNT  20   // Highest value for a lookaside stack count

typedef struct  _IOP_IRP_STACK_PROFILER {
    ULONG   Profile[MAX_LOOKASIDE_IRP_STACK_COUNT];
    KTIMER  Timer;
    KDPC    Dpc;
    ULONG   Flags;
    ULONG   TriggerCount;
    ULONG   ProfileDuration;
} IOP_IRP_STACK_PROFILER, *PIOP_IRP_STACK_PROFILER;


#define IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT   0x1 // Define for internal flags to IopCreateFile
#define IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK    0x2

// Extension Flag definitions.

#define FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK  0x1 // Ignore share access check.

//
// Define the global data for the I/O system.
//

#define IOP_FIXED_SIZE_MDL_PFNS        0x17

#define MAX_RESERVE_IRP_STACK_SIZE     20   // Define 20 as the number of stacks needed for the reserve IRP
#define IOP_PROFILE_TIME_PERIOD        60   // 60 seconds
#define NUM_SAMPLE_IRPS                2000
#define MIN_IRP_THRESHOLD              400  // At least 20 % should be allocated from a given stack location

//
// Define the default number of I/O stack locations a large IRP should
// have if not specified by the registry.
//

#define DEFAULT_LARGE_IRP_LOCATIONS     8
#define BASE_STACK_COUNT                DEFAULT_LARGE_IRP_LOCATIONS

//
// Defines for IopIrpAllocatorFlags.
//

#define IOP_ENABLE_AUTO_SIZING              0x1
#define IOP_PROFILE_STACK_COUNT             0x2
#define IOP_PROFILE_DURATION                1   // 1*60 seconds
#define IOP_PROFILE_TRIGGER_INTERVAL        10  // 10*60 seconds

extern ERESOURCE IopDatabaseResource;
extern ERESOURCE IopSecurityResource;
extern ERESOURCE IopCrashDumpLock;
extern LIST_ENTRY IopDiskFileSystemQueueHead;
extern LIST_ENTRY IopCdRomFileSystemQueueHead;
extern LIST_ENTRY IopNetworkFileSystemQueueHead;
extern LIST_ENTRY IopTapeFileSystemQueueHead;
extern LIST_ENTRY IopBootDriverReinitializeQueueHead;
extern LIST_ENTRY IopNotifyShutdownQueueHead;
extern LIST_ENTRY IopNotifyLastChanceShutdownQueueHead;
extern LIST_ENTRY IopFsNotifyChangeQueueHead;
extern KSPIN_LOCK IoStatisticsLock;
extern KSPIN_LOCK IopTimerLock;
extern LIST_ENTRY IopTimerQueueHead;
extern KDPC IopTimerDpc;
extern KTIMER IopTimer;
extern ULONG IopTimerCount;
extern ULONG IopLargeIrpStackLocations;
extern ULONG IopFailZeroAccessCreate;
extern ULONG    IopFsRegistrationOps;

extern POBJECT_TYPE IoAdapterObjectType;
extern POBJECT_TYPE IoCompletionObjectType;
extern POBJECT_TYPE IoControllerObjectType;
extern POBJECT_TYPE IoDeviceHandlerObjectType;

extern GENERAL_LOOKASIDE IopLargeIrpLookasideList;
extern GENERAL_LOOKASIDE IopSmallIrpLookasideList;
extern GENERAL_LOOKASIDE IopMdlLookasideList;
extern GENERAL_LOOKASIDE IopCompletionLookasideList;

extern const UCHAR IopQueryOperationLength[];
extern const UCHAR IopSetOperationLength[];
extern const ULONG IopQueryOperationAccess[];
extern const ULONG IopSetOperationAccess[];
extern const UCHAR IopQuerySetAlignmentRequirement[];
extern const UCHAR IopQueryFsOperationLength[];
extern const UCHAR IopSetFsOperationLength[];
extern const ULONG IopQueryFsOperationAccess[];
extern const ULONG IopSetFsOperationAccess[];
extern const UCHAR IopQuerySetFsAlignmentRequirement[];

extern UNICODE_STRING IoArcHalDeviceName;
extern PUCHAR IoLoaderArcBootDeviceName;


extern LONG IopUniqueDeviceObjectNumber;

extern PVOID IopLinkTrackingServiceObject;
extern PKEVENT IopLinkTrackingServiceEvent;
extern HANDLE IopLinkTrackingServiceEventHandle;
extern KEVENT IopLinkTrackingPortObject;
extern LINK_TRACKING_PACKET IopLinkTrackingPacket;

extern UNICODE_STRING IoArcBootDeviceName;
extern PDUMP_CONTROL_BLOCK IopDumpControlBlock;
extern ULONG IopDumpControlBlockChecksum;

extern LIST_ENTRY IopDriverReinitializeQueueHead;

extern BOOLEAN  IopVerifierOn;

extern PIO_CALL_DRIVER        pIofCallDriver;
extern PIO_COMPLETE_REQUEST   pIofCompleteRequest;
extern PIO_FREE_IRP           pIoFreeIrp;
extern PIO_ALLOCATE_IRP       pIoAllocateIrp;
extern IOP_RESERVE_IRP_ALLOCATOR IopReserveIrpAllocator;
extern IOP_IRP_STACK_PROFILER  IopIrpStackProfiler;
//
// The following declaration cannot go in EX.H since POBJECT_TYPE is not defined
// until OB.H, which depends on EX.H.  Hence, it is not exported by the EX
// component at all.
//

extern POBJECT_TYPE ExEventObjectType;


//
// Define routines private to the I/O system.
//

VOID
IopAbortRequest(
    IN PKAPC Apc
    );

//+
//
// BOOLEAN
// IopAcquireFastLock(
//     IN PFILE_OBJECT FileObject
// )
//
// Routine Description:
//
//     This routine is invoked to acquire the fast lock for a file object.
//     This lock protects the busy indicator in the file object resource.
//
// Arguments:
//
//     FileObject - Pointer to the file object to be locked.
//
// Return Values:
//
//      FALSE - the fileobject was not locked (it was busy)
//      TRUE  - the fileobject was locked & the busy flag has been set to TRUE
//
//-

static  FORCEINLINE BOOLEAN
IopAcquireFastLock(
    IN  PFILE_OBJECT    FileObject
    )
{
    UNREFERENCED_PARAMETER(FileObject);

    if ( InterlockedExchange( (PLONG) &FileObject->Busy, (ULONG) TRUE ) == FALSE ) {
         ObReferenceObject(FileObject);
        return TRUE;
    }

    return FALSE;
}

#define IopAcquireCancelSpinLockAtDpcLevel()    \
    KiAcquireQueuedSpinLock ( &KeGetCurrentPrcb()->LockQueue[LockQueueIoCancelLock] )

#define IopReleaseCancelSpinLockFromDpcLevel()  \
    KiReleaseQueuedSpinLock ( &KeGetCurrentPrcb()->LockQueue[LockQueueIoCancelLock] )

#define IopAllocateIrp(StackSize, ChargeQuota) \
        IoAllocateIrp((StackSize), (ChargeQuota))

#define IsIoVerifierOn()    IopVerifierOn


static __inline  VOID
IopProbeAndLockPages(
     IN OUT PMDL MemoryDescriptorList,
     IN KPROCESSOR_MODE AccessMode,
     IN LOCK_OPERATION Operation,
     IN PDEVICE_OBJECT DeviceObject,
     IN ULONG          MajorFunction
     )
{
    extern LOGICAL  MmTrackLockedPages;

    MmProbeAndLockPages(MemoryDescriptorList, AccessMode, Operation);
    if (MmTrackLockedPages) {
        PVOID   DriverRoutine;

        DriverRoutine = (PVOID)(ULONG_PTR)DeviceObject->DriverObject->MajorFunction[MajorFunction];
        MmUpdateMdlTracker(MemoryDescriptorList, DriverRoutine, DeviceObject);
    }
}

#define IopIsReserveIrp(Irp)    ((Irp) == (IopReserveIrpAllocator.ReserveIrp))

//
// Bump the stack profile.
//

#define IopProfileIrpStackCount(StackSize)  \
            ((StackSize < MAX_LOOKASIDE_IRP_STACK_COUNT) ? \
                IopIrpStackProfiler.Profile[StackSize]++ : 0)

//
// True if auto sizing is enabled.
//
#define IopIrpAutoSizingEnabled()   ((IopIrpStackProfiler.Flags & IOP_ENABLE_AUTO_SIZING))

//
// True if stack profiling is enabled.
//

#define IopIrpProfileStackCountEnabled() \
    ((IopIrpStackProfiler.Flags & (IOP_PROFILE_STACK_COUNT|IOP_ENABLE_AUTO_SIZING)) \
            == (IOP_PROFILE_STACK_COUNT|IOP_ENABLE_AUTO_SIZING))

//
// Definitions for SecurityDescriptorFlavor.
//

#define IO_SD_LEGACY                             0  // Sets per WIN2K settings.
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_E            1  // WORLD:E, Admins:ALL, System:ALL
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_E_RES_E      2  // WORLD:E, Admins:ALL, System:ALL, Restricted:E
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE          3  // WORLD:RWE, Admins:ALL, System:ALL
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE   4  // WORLD:RWE, Admins:ALL, System:ALL, Restricted:RE
#define IO_SD_SYS_ALL_ADM_RE                     5  // System:ALL, Admins:RE


NTSTATUS
IopAcquireFileObjectLock(
    IN PFILE_OBJECT FileObject,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN Alertable,
    OUT PBOOLEAN Interrupted
    );


VOID
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    );

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    );

VOID
IopApcHardError(
    IN PVOID StartContext
    );

VOID
IopCancelAlertedRequest(
    IN PKEVENT Event,
    IN PIRP Irp
    );

VOID
IopCheckBackupRestorePrivilege(
    IN PACCESS_STATE AccessState,
    IN OUT PULONG CreateOptions,
    IN KPROCESSOR_MODE PreviousMode,
    IN ULONG Disposition
    );

NTSTATUS
IopCheckGetQuotaBufferValidity(
    IN PFILE_GET_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG_PTR ErrorOffset
    );

VOID
IopCloseFile(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ULONG GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN OnCleanStack,
    IN KIRQL Irql
    );

VOID
IopCompletePageWrite(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

BOOLEAN
IopConfigureCrashDump(
    IN HANDLE HandlePagingFile
    );

VOID
IopConnectLinkTrackingPort(
    IN PVOID Parameter
    );

NTSTATUS
IopCreateVpb (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopDeallocateApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AlwaysUnload,
    IN BOOLEAN OnCleanStack
    );

VOID
IopDeleteDriver(
    IN PVOID    Object
    );

VOID
IopDeleteDevice(
    IN PVOID    Object
    );

VOID
IopDeleteFile(
    IN PVOID    Object
    );

VOID
IopDeleteIoCompletion(
    IN PVOID    Object
    );

//+
//
// VOID
// IopDequeueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine dequeues the specified I/O Request Packet (IRP) from the
//     thread IRP queue which it is currently queued.
//
//     In checked we set Flink == Blink so we can assert free's of queue'd IRPs
//
// Arguments:
//
//     Irp - Specifies the IRP that is dequeued.
//
// Return Value:
//
//     None.
//
//-

#define IopDequeueThreadIrp( Irp ) \
   { \
   RemoveEntryList( &Irp->ThreadListEntry ); \
   InitializeListHead( &Irp->ThreadListEntry ) ; \
   }


#ifdef  _WIN64
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT((ULONG_PTR)(ApcRoutine) & ~1)
#define IopIsIosb32(ApcRoutine)                ((ULONG_PTR)(ApcRoutine) & 1)
#else
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT(ApcRoutine)
#endif

VOID
IopDisassociateThreadIrp(
    VOID
    );

BOOLEAN
IopDmaDispatch(
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    );

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

LONG
IopExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers,
    OUT PNTSTATUS ExceptionCode
    );

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL,
    IN PKEVENT KernelEvent OPTIONAL
    );

VOID
IopErrorLogThread(
    IN PVOID StartContext
    );

VOID
IopFreeIrpAndMdls(
    IN PIRP Irp
    );

PDEVICE_OBJECT
IopGetDeviceAttachmentBase(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopGetFileInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

BOOLEAN
IopGetMountFlag(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopGetRegistryValues(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_FULL_INFORMATION *ValueList
    );

NTSTATUS
IopGetSetObjectId(
    IN PFILE_OBJECT FileObject,
    IN OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG OperationFlags
    );

NTSTATUS
IopGetSetSecurityObject(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
IopGetVolumeId(
    IN PFILE_OBJECT FileObject,
    IN OUT PLINK_TRACKING_INFORMATION ObjectId,
    IN ULONG Length
    );

VOID
IopHardErrorThread(
    PVOID StartContext
    );

VOID
IopInsertRemoveDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Insert
    );

//
// Interlocked list manipulation funtions using queued spin locks.
//

PLIST_ENTRY
FASTCALL
IopInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

PLIST_ENTRY
FASTCALL
IopInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

PLIST_ENTRY
FASTCALL
IopInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    );

LOGICAL
IopIsSameMachine(
    IN PFILE_OBJECT SourceFile,
    IN HANDLE TargetFile
    );

VOID
IopLoadFileSystemDriver(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopLoadUnloadDriver(
    IN PVOID Parameter
    );

NTSTATUS
IopLogErrorEvent(
    IN ULONG            SequenceNumber,
    IN ULONG            UniqueErrorValue,
    IN NTSTATUS         FinalStatus,
    IN NTSTATUS         SpecificIOStatus,
    IN ULONG            LengthOfInsert1,
    IN PWCHAR           Insert1,
    IN ULONG            LengthOfInsert2,
    IN PWCHAR           Insert2
    );

NTSTATUS
IopLookupBusStringFromID (
    IN  HANDLE KeyHandle,
    IN  INTERFACE_TYPE InterfaceType,
    OUT PWCHAR Buffer,
    IN  ULONG Length,
    OUT PULONG BusFlags OPTIONAL
    );

NTSTATUS
IopMountVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount,
    IN BOOLEAN DeviceLockAlreadyHeld,
    IN BOOLEAN Alertable,
    OUT PVPB    *Vpb
    );


NTSTATUS
IopOpenLinkOrRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PVOID RenameBuffer,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
IopParseDevice(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

BOOLEAN
IopProtectSystemPartition(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    );

NTSTATUS
IopQueryNameInternal(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    IN BOOLEAN UseDosDeviceName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE  Mode
    );

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    IN KPROCESSOR_MODE Mode,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    );

VOID
IopQueueWorkRequest(
    IN PIRP Irp
    );

VOID
IopRaiseHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IopRaiseInformationalHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IopReadyDeviceObjects(
    IN PDRIVER_OBJECT DriverObject
    );

//+
//
// VOID
// IopReleaseFileObjectLock(
//     IN PFILE_OBJECT FileObject
// )
//
// Routine Description:
//
//     This routine is invoked to release ownership of the file object lock.
//     Dereference the fileobject acquired during the lock.
//
// Arguments:
//
//     FileObject - Pointer to the file object whose ownership is to be
//         released.
//
// Return Value:
//
//     None.
//
//-

#define IopReleaseFileObjectLock( FileObject ) {    \
    ULONG Result;                                   \
    Result = InterlockedExchange( (PLONG) &FileObject->Busy, FALSE ); \
    ASSERT(Result != FALSE);                        \
    if (FileObject->Waiters != 0) {                 \
        KeSetEvent( &FileObject->Lock, 0, FALSE );  \
    }                                               \
    ObDereferenceObject(FileObject);                \
}

#if _WIN32_WINNT >= 0x0500
NTSTATUS
IopSendMessageToTrackService(
    IN PLINK_TRACKING_INFORMATION SourceVolumeId,
    IN PFILE_OBJECTID_BUFFER SourceObjectId,
    IN PFILE_TRACKING_INFORMATION TargetObjectInformation
    );
#endif

NTSTATUS
IopSetEaOrQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN SetEa
    );

NTSTATUS
IopSetRemoteLink(
    IN PFILE_OBJECT FileObject,
    IN PFILE_OBJECT DestinationFileObject OPTIONAL,
    IN PFILE_TRACKING_INFORMATION FileInformation OPTIONAL
    );

VOID
IopStartApcHardError(
    IN PVOID StartContext
    );

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN KPROCESSOR_MODE RequestorMode,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN SynchronousIo,
    IN TRANSFER_TYPE TransferType
    );

VOID
IopTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
IopTrackLink(
    IN PFILE_OBJECT FileObject,
    IN OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_TRACKING_INFORMATION FileInformation,
    IN ULONG Length,
    IN PKEVENT Event,
    IN KPROCESSOR_MODE RequestorMode
    );


VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    );

NTSTATUS
IopReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );


VOID
IopDoNameTransmogrify(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    );

VOID
IopUpdateOtherOperationCount(
    VOID
    );

VOID
IopUpdateReadOperationCount(
    VOID
    );

VOID
IopUpdateWriteOperationCount(
    VOID
    );

VOID
IopUpdateOtherTransferCount(
    IN ULONG TransferCount
    );

VOID
IopUpdateReadTransferCount(
    IN ULONG TransferCount
    );

VOID
IopUpdateWriteTransferCount(
    IN ULONG TransferCount
    );

NTSTATUS
FORCEINLINE
IopfCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to pass an I/O Request Packet (IRP) to another
    driver at its dispatch routine.

Arguments:

    DeviceObject - Pointer to device object to which the IRP should be passed.

    Irp - Pointer to IRP for request.

Return Value:

    Return status from driver's dispatch routine.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVER_OBJECT driverObject;
    NTSTATUS status;

    //
    // Ensure that this is really an I/O Request Packet.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Update the IRP stack to point to the next location.
    //
    Irp->CurrentLocation--;

    if (Irp->CurrentLocation <= 0) {
        KeBugCheckEx( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, 0, 0, 0 );
    }

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    //
    // Save a pointer to the device object for this request so that it can
    // be used later in completion.
    //

    irpSp->DeviceObject = DeviceObject;


    //
    // Invoke the driver at its dispatch routine entry point.
    //

    driverObject = DeviceObject->DriverObject;

    //
    // Prevent the driver from unloading.
    //


    status = driverObject->MajorFunction[irpSp->MajorFunction]( DeviceObject,
                                                              Irp );

    return status;
}


VOID
FASTCALL
IopfCompleteRequest(
    IN  PIRP    Irp,
    IN  CCHAR   PriorityBost
    );


PIRP
IopAllocateIrpPrivate(
    IN  CCHAR   StackSize,
    IN  BOOLEAN ChargeQuota
    );

VOID
IopFreeIrp(
    IN  PIRP    Irp
    );

PVOID
IopAllocateErrorLogEntry(
    IN PDEVICE_OBJECT deviceObject,
    IN PDRIVER_OBJECT driverObject,
    IN UCHAR EntrySize
    );

VOID
IopNotifyAlreadyRegisteredFileSystems(
    IN PLIST_ENTRY  ListHead,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine,
    IN BOOLEAN                 SkipRaw
    );

NTSTATUS
IopCheckUnloadDriver(
    IN PDRIVER_OBJECT driverObject,
    OUT PBOOLEAN unloadDriver
    );
//
// Interlocked increment/decrement functions using queued spin locks.
//

ULONG
FASTCALL
IopInterlockedDecrementUlong (
   IN KSPIN_LOCK_QUEUE_NUMBER Number,
   IN OUT PLONG Addend
   );

ULONG
FASTCALL
IopInterlockedIncrementUlong (
   IN KSPIN_LOCK_QUEUE_NUMBER Number,
   IN OUT PLONG Addend
   );


VOID
IopShutdownBaseFileSystems(
    IN PLIST_ENTRY  ListHead
    );

VOID
IopPerfLogFileCreate(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING CompleteName
    );

BOOLEAN
IopInitializeReserveIrp(
    PIOP_RESERVE_IRP_ALLOCATOR  Allocator
    );

PIRP
IopAllocateReserveIrp(
    IN CCHAR StackSize
    );

VOID
IopFreeReserveIrp(
    IN  CCHAR   PriorityBoost
    );

NTSTATUS
IopGetBasicInformationFile(
    IN  PFILE_OBJECT            FileObject,
    IN  PFILE_BASIC_INFORMATION BasicInformationBuffer
    );

NTSTATUS
IopCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN ULONG InternalFlags,
    IN PVOID DeviceObject
    );

BOOLEAN
IopVerifyDeviceObjectOnStack(
    IN  PDEVICE_OBJECT  BaseDeviceObject,
    IN  PDEVICE_OBJECT  TopDeviceObject
    );

BOOLEAN
IopVerifyDiskSignature(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout,
    IN PARC_DISK_SIGNATURE          LoaderDiskBlock,
    OUT PULONG                      DiskSignature
    );

NTSTATUS
IopGetDriverPathInformation(
    IN  PFILE_OBJECT                        FileObject,
    IN  PFILE_FS_DRIVER_PATH_INFORMATION    FsDpInfo,
    IN  ULONG                               Length
    );

BOOLEAN
IopVerifyDriverObjectOnStack(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IopInitializeIrpStackProfiler(
    VOID
    );

VOID
IopIrpStackProfilerTimer(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IopProcessIrpStackProfiler(
    VOID
    );

PDEVICE_OBJECT
IopAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject OPTIONAL
    );


NTSTATUS
IopCreateSecurityDescriptorPerType(
    IN  PSECURITY_DESCRIPTOR  Descriptor,
    IN  ULONG                 SecurityDescriptorFlavor,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    );

BOOLEAN
IopReferenceVerifyVpb(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PVPB            *Vpb,
    OUT PDEVICE_OBJECT  *FsDeviceObject
    );

VOID
IopDereferenceVpbAndFree(
    IN PVPB Vpb
    );
#endif // _IOMGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\ioverifier.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   ioverifier.c

Abstract:

    This module contains the routines to verify suspect drivers.

Author:

    Narayanan Ganapathy (narg) 8-Jan-1999

Revision History:

    Adrian J. Oney (AdriaO) 28-Feb-1999
        - merge in special irp code.

--*/

#include "iomgr.h"
#include "malloc.h"
#include "..\verifier\vfdeadlock.h"

#if (( defined(_X86_) ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif


#define IO_FREE_IRP_TYPE_INVALID                1
#define IO_FREE_IRP_NOT_ASSOCIATED_WITH_THREAD  2
#define IO_CALL_DRIVER_IRP_TYPE_INVALID         3
#define IO_CALL_DRIVER_INVALID_DEVICE_OBJECT    4
#define IO_CALL_DRIVER_IRQL_NOT_EQUAL           5
#define IO_COMPLETE_REQUEST_INVALID_STATUS      6
#define IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET  7
#define IO_BUILD_FSD_REQUEST_EXCEPTION          8
#define IO_BUILD_IOCTL_REQUEST_EXCEPTION        9
#define IO_REINITIALIZING_TIMER_OBJECT          10
#define IO_INVALID_HANDLE                       11
#define IO_INVALID_STACK_IOSB                   12
#define IO_INVALID_STACK_EVENT                  13
#define IO_COMPLETE_REQUEST_INVALID_IRQL        14
#define IO_CALL_DRIVER_ISSUING_INVALID_CREATE_REQUEST   15

//
// 0x200 and up are defined in ioassert.c
//


#ifdef  IOV_KD_PRINT
#define IovpKdPrint(x)  KdPrint(x)
#else
#define IovpKdPrint(x)
#endif

BOOLEAN
IovpValidateDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );
VOID
IovFreeIrpPrivate(
    IN  PIRP    Irp
    );

NTSTATUS
IovpUnloadDriver(
    PDRIVER_OBJECT  DriverObject
    );

BOOLEAN
IovpBuildDriverObjectList(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG_PTR HandleCount,
    IN ULONG_PTR PointerCount,
    IN PVOID Parameter
    );

NTSTATUS
IovpLocalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


typedef struct _IOV_COMPLETION_CONTEXT {
    PIO_STACK_LOCATION StackPointer;
    PVOID               IrpContext;
    PVOID               GlobalContext;
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    IO_STACK_LOCATION  OldStackContents;
} IOV_COMPLETION_CONTEXT, *PIOV_COMPLETION_CONTEXT;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IoVerifierInit)
#pragma alloc_text(PAGEVRFY,IovAllocateIrp)
#pragma alloc_text(PAGEVRFY,IovFreeIrp)
#pragma alloc_text(PAGEVRFY,IovCallDriver)
#pragma alloc_text(PAGEVRFY,IovCompleteRequest)
#pragma alloc_text(PAGEVRFY,IovpValidateDeviceObject)
#pragma alloc_text(PAGEVRFY,IovFreeIrpPrivate)
#pragma alloc_text(PAGEVRFY,IovUnloadDrivers)
#pragma alloc_text(PAGEVRFY,IovpUnloadDriver)
#pragma alloc_text(PAGEVRFY,IovBuildDeviceIoControlRequest)
#pragma alloc_text(PAGEVRFY,IovBuildAsynchronousFsdRequest)
#pragma alloc_text(PAGEVRFY,IovpCompleteRequest)
#pragma alloc_text(PAGEVRFY,IovpBuildDriverObjectList)
#pragma alloc_text(PAGEVRFY,IovInitializeIrp)
#pragma alloc_text(PAGEVRFY,IovCancelIrp)
#pragma alloc_text(PAGEVRFY,IovAttachDeviceToDeviceStack)
#pragma alloc_text(PAGEVRFY,IovInitializeTimer)
#pragma alloc_text(PAGEVRFY,IovDetachDevice)
#pragma alloc_text(PAGEVRFY,IovDeleteDevice)
#pragma alloc_text(PAGEVRFY,IovpLocalCompletionRoutine)
#endif

BOOLEAN         IopVerifierOn = FALSE;
ULONG           IovpVerifierLevel = (ULONG)0;
LONG            IovpInitCalled = 0;
ULONG           IovpVerifierFlags = 0;               // Stashes the verifier flags passed at init.

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif
BOOLEAN         IoVerifierOnByDefault = TRUE;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

VOID
IoVerifierInit(
    IN ULONG VerifierFlags
    )
{
    IovpVerifierLevel = 2;

    if (IoVerifierOnByDefault) {
        VerifierFlags |= DRIVER_VERIFIER_IO_CHECKING;
    }

    VfInitVerifier(VerifierFlags);

    if (!VerifierFlags) {
        return;
    }

    pIoAllocateIrp = IovAllocateIrp;

    if (!(VerifierFlags & DRIVER_VERIFIER_IO_CHECKING)) {

        if (!(VerifierFlags & DRIVER_VERIFIER_DEADLOCK_DETECTION) &&
            !(VerifierFlags & DRIVER_VERIFIER_DMA_VERIFIER)) {

            return;

        } else {

            //
            // If deadlock or DMA verifier are on we need to let the function
            // continue to install the hooks but we will set the
            // I/O verifier level to minimal checks.
            //
            IovpVerifierLevel = 0;
        }
    }

    //
    // Enable and hook in the verifier.
    //
    IopVerifierOn = TRUE;
    IovpInitCalled = 1;
    IovpVerifierFlags = VerifierFlags;

    //
    // Initialize the special IRP code as appropriate.
    //
    InterlockedExchangePointer((PVOID *)&pIofCallDriver, (PVOID) IovCallDriver);
    InterlockedExchangePointer((PVOID *)&pIofCompleteRequest, (PVOID) IovCompleteRequest);
    InterlockedExchangePointer((PVOID *)&pIoFreeIrp, (PVOID) IovFreeIrpPrivate);

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);
}


BOOLEAN
IovpValidateDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    if ((DeviceObject->Type != IO_TYPE_DEVICE) ||
        (DeviceObject->DriverObject == NULL) ||
        (DeviceObject->ReferenceCount < 0 )) {
        return FALSE;
    } else {
        return TRUE;
    }
}

VOID
IovFreeIrp(
    IN  PIRP    Irp
    )
{
    IovFreeIrpPrivate(Irp);
}

VOID
IovFreeIrpPrivate(
    IN  PIRP    Irp
    )
{
    BOOLEAN freeHandled ;

    if (IopVerifierOn) {
        if (Irp->Type != IO_TYPE_IRP) {
            KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                         IO_FREE_IRP_TYPE_INVALID,
                         (ULONG_PTR)Irp,
                         0,
                         0);
        }
        if (!IsListEmpty(&(Irp)->ThreadListEntry)) {
            KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                         IO_FREE_IRP_NOT_ASSOCIATED_WITH_THREAD,
                         (ULONG_PTR)Irp,
                         0,
                         0);
        }
    }

    VerifierIoFreeIrp(Irp, &freeHandled);

    if (freeHandled) {

       return;
    }

    IopFreeIrp(Irp);
}

NTSTATUS
FASTCALL
IovCallDriver(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress
    )
{
    KIRQL    saveIrql;
    NTSTATUS status;
    PIOFCALLDRIVER_STACKDATA iofCallDriverStackData;
    BOOLEAN pagingIrp;
    PIO_STACK_LOCATION  irpSp;

    if (!IopVerifierOn) {

        return IopfCallDriver(DeviceObject, Irp);
    }

    if (Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_IRP_TYPE_INVALID,
                     (ULONG_PTR)Irp,
                     0,
                     0);
    }
    if (!IovpValidateDeviceObject(DeviceObject)) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_INVALID_DEVICE_OBJECT,
                     (ULONG_PTR)DeviceObject,
                     0,
                     0);
    }

    irpSp = IoGetNextIrpStackLocation(Irp);
    if (irpSp->MajorFunction == IRP_MJ_CREATE &&
        (irpSp->FileObject) &&
        ((irpSp->FileObject->Flags &
          (FO_CLEANUP_COMPLETE|FO_FILE_OPEN_CANCELLED)) == (FO_CLEANUP_COMPLETE|FO_FILE_OPEN_CANCELLED))) {

        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_ISSUING_INVALID_CREATE_REQUEST,
                     (ULONG_PTR)DeviceObject,
                     (ULONG_PTR)Irp,
                     (ULONG_PTR)irpSp->FileObject);

    }
    saveIrql = KeGetCurrentIrql();

    //
    // Deadlock verifier functions are called before and after the
    // real IoCallDriver() call. If deadlock verifier is not enabled
    // this functions will return immediately.
    //
    pagingIrp = VfDeadlockBeforeCallDriver(DeviceObject, Irp);

    //
    // VfIrpCallDriverPreprocess is a macro function that may do an alloca as
    // part of it's operation. As such callers must be careful not to use
    // variable lengthed arrays in a scope that encompasses
    // VfIrpCallDriverPreProcess but not VfIrpCallDriverPostProcess.
    //
    VfIrpCallDriverPreProcess(DeviceObject, &Irp, &iofCallDriverStackData, ReturnAddress);

    VfStackSeedStack(0xFFFFFFFF);

    status = IopfCallDriver(DeviceObject, Irp);

    VfIrpCallDriverPostProcess(DeviceObject, &status, iofCallDriverStackData);

    VfDeadlockAfterCallDriver(DeviceObject, Irp, pagingIrp);

    if (saveIrql != KeGetCurrentIrql()) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_CALL_DRIVER_IRQL_NOT_EQUAL,
                     (ULONG_PTR)DeviceObject,
                     saveIrql,
                     KeGetCurrentIrql());

    }

    return status;
}




//
// Wrapper for IovAllocateIrp. Use special pool to allocate the IRP.
// This is directly called from IoAllocateIrp.
//
PIRP
IovAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    )
{
    USHORT allocateSize;
    UCHAR fixedSize;
    PIRP irp;
    USHORT packetSize;

    //
    // Should we override normal lookaside caching so that we may catch
    // more bugs?
    //
    VerifierIoAllocateIrp1(StackSize, ChargeQuota, &irp);

    if (irp) {

       return irp;
    }

    //
    // If special pool is not turned on lets just call the standard
    // irp allocator.
    //

    if (!(IovpVerifierFlags & DRIVER_VERIFIER_SPECIAL_POOLING )) {
        irp = IopAllocateIrpPrivate(StackSize, ChargeQuota);
        return irp;
    }


    irp = NULL;
    fixedSize = 0;
    packetSize = IoSizeOfIrp(StackSize);
    allocateSize = packetSize;

    //
    // There are no free packets on the lookaside list, or the packet is
    // too large to be allocated from one of the lists, so it must be
    // allocated from nonpaged pool. If quota is to be charged, charge it
    // against the current process. Otherwise, allocate the pool normally.
    //

    if (ChargeQuota) {
        try {
            irp = ExAllocatePoolWithTagPriority(
                    NonPagedPool,
                    allocateSize,
                    ' prI',
                    HighPoolPrioritySpecialPoolOverrun);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

    } else {

        //
        // Attempt to allocate the pool from non-paged pool.  If this
        // fails, and the caller's previous mode was kernel then allocate
        // the pool as must succeed.
        //

        irp = ExAllocatePoolWithTagPriority(
                NonPagedPool,
                allocateSize,
                ' prI',
                HighPoolPrioritySpecialPoolOverrun);
    }

    if (!irp) {
        return NULL;
    }

    //
    // Initialize the packet.
    //

    IopInitializeIrp(irp, packetSize, StackSize);
    if (ChargeQuota) {
        irp->AllocationFlags |= IRP_QUOTA_CHARGED;
    }

    VerifierIoAllocateIrp2(irp);
    return irp;
}

PIRP
IovBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )
{
    PIRP    Irp;

    try {
        Irp = IoBuildAsynchronousFsdRequest(
            MajorFunction,
            DeviceObject,
            Buffer,
            Length,
            StartingOffset,
            IoStatusBlock
            );
    } except(EXCEPTION_EXECUTE_HANDLER) {
         KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                      IO_BUILD_FSD_REQUEST_EXCEPTION,
                      (ULONG_PTR)DeviceObject,
                      (ULONG_PTR)MajorFunction,
                      GetExceptionCode());
    }
    return (Irp);
}

PIRP
IovBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
{
    PIRP    Irp;

    try {
        Irp = IoBuildDeviceIoControlRequest(
            IoControlCode,
            DeviceObject,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength,
            InternalDeviceIoControl,
            Event,
            IoStatusBlock
            );
    } except(EXCEPTION_EXECUTE_HANDLER) {
         KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                      IO_BUILD_IOCTL_REQUEST_EXCEPTION,
                      (ULONG_PTR)DeviceObject,
                      (ULONG_PTR)IoControlCode,
                      GetExceptionCode());
    }

    return (Irp);
}

NTSTATUS
IovInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    )
{
   if (DeviceObject->Timer) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_REINITIALIZING_TIMER_OBJECT,
                     (ULONG_PTR)DeviceObject,
                     0,
                     0);
   }
   return (IoInitializeTimer(DeviceObject, TimerRoutine, Context));
}


VOID
IovpCompleteRequest(
    IN PKAPC Apc,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
{
    PIRP    irp;
#if defined(_X86_)
    PUCHAR  addr;
    ULONG   BestStackOffset;
#endif

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );

    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

#if defined(_X86_)


    addr = (PUCHAR)irp->UserIosb;
    if ((addr > (PUCHAR)KeGetCurrentThread()->StackLimit) &&
        (addr <= (PUCHAR)&BestStackOffset)) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_INVALID_STACK_IOSB,
                     (ULONG_PTR)addr,
                     0,
                     0);

    }

    addr = (PUCHAR)irp->UserEvent;
    if ((addr > (PUCHAR)KeGetCurrentThread()->StackLimit) &&
        (addr <= (PUCHAR)&BestStackOffset)) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_INVALID_STACK_EVENT,
                     (ULONG_PTR)addr,
                     0,
                     0);

    }
#endif
}


/*-------------------------- SPECIALIRP HOOKS -------------------------------*/

VOID
FASTCALL
IovCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    IOV_COMPLETION_CONTEXT  StackContext;
    PIOV_COMPLETION_CONTEXT  pStackContext;
    IOFCOMPLETEREQUEST_STACKDATA completionPacket;
    LONG   currentLocation;
    PIO_STACK_LOCATION  stackPointer;


    if (!IopVerifierOn) {
        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1) ||
        Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS,
                      (ULONG_PTR) Irp,
                      __LINE__,
                      0,
                      0);
    }

    if (Irp->CancelRoutine) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET,
                     (ULONG_PTR)Irp->CancelRoutine,
                     (ULONG_PTR)Irp,
                     0);
    }

    if (Irp->IoStatus.Status == STATUS_PENDING || Irp->IoStatus.Status == 0xffffffff) {
         KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                      IO_COMPLETE_REQUEST_INVALID_STATUS,
                      Irp->IoStatus.Status,
                      (ULONG_PTR)Irp,
                      0);
    }

    if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
        KeBugCheckEx(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
                     IO_COMPLETE_REQUEST_INVALID_IRQL,
                     KeGetCurrentIrql(),
                     (ULONG_PTR)Irp,
                     0);

    }

    if (IovpVerifierLevel <= 1) {

        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    SPECIALIRP_IOF_COMPLETE_1(Irp, PriorityBoost, &completionPacket);

    if ((Irp->CurrentLocation) > (CCHAR) (Irp->StackCount)) {
        IopfCompleteRequest(Irp, PriorityBoost);
        return;
    }

    currentLocation = Irp->CurrentLocation;
    pStackContext = &StackContext;
    stackPointer = IoGetCurrentIrpStackLocation(Irp);

    //
    // Replace the completion routines with verifier completion routines so that
    // verifier gets control.
    //

    IovpKdPrint(("Hook:Irp 0x%x StackCount %d currentlocation %d stackpointer 0%x\n",
             Irp,
             Irp->StackCount,
             currentLocation,
             IoGetCurrentIrpStackLocation(Irp)));


    pStackContext->CompletionRoutine = NULL;
    pStackContext->GlobalContext = &completionPacket;
    pStackContext->IrpContext = stackPointer->Context;
    pStackContext->StackPointer = stackPointer;
    pStackContext->OldStackContents = *(stackPointer); // Save the stack contents

    IovpKdPrint(("Seeding completion Rtn 0x%x currentLocation %d stackpointer 0x%x pStackContext 0x%x \n",
             stackPointer->CompletionRoutine,
             currentLocation,
             stackPointer,
             pStackContext
             ));

    if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
         stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
         (!NT_SUCCESS( Irp->IoStatus.Status ) &&
         stackPointer->Control & SL_INVOKE_ON_ERROR) ||
         (Irp->Cancel &&
         stackPointer->Control & SL_INVOKE_ON_CANCEL)
       ) {

        pStackContext->CompletionRoutine = stackPointer->CompletionRoutine;
        pStackContext->IrpContext = stackPointer->Context;
    } else {

        //
        // Force the completion routine to be called.
        // Store the old control flag value.
        //

        stackPointer->Control |= SL_INVOKE_ON_SUCCESS|SL_INVOKE_ON_ERROR;

    }

    stackPointer->CompletionRoutine = IovpLocalCompletionRoutine;
    stackPointer->Context = pStackContext;


    IopfCompleteRequest(Irp, PriorityBoost);

}

#define ZeroAndDopeIrpStackLocation( IrpSp ) {  \
    (IrpSp)->MinorFunction = 0;                 \
    (IrpSp)->Flags = 0;                         \
    (IrpSp)->Control = SL_NOTCOPIED;            \
    (IrpSp)->Parameters.Others.Argument1 = 0;   \
    (IrpSp)->Parameters.Others.Argument2 = 0;   \
    (IrpSp)->Parameters.Others.Argument3 = 0;   \
    (IrpSp)->Parameters.Others.Argument4 = 0;   \
    (IrpSp)->FileObject = (PFILE_OBJECT) NULL; }


NTSTATUS
IovpLocalCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIOV_COMPLETION_CONTEXT  pStackContext = Context;
    NTSTATUS status;
    PIO_STACK_LOCATION stackPointer = pStackContext->StackPointer;
    BOOLEAN lastStackLocation = FALSE;

    //
    // Copy back all parameters that were zeroed out.
    //
    //
    stackPointer->MinorFunction = pStackContext->OldStackContents.MinorFunction;
    stackPointer->Flags = pStackContext->OldStackContents.Flags;
    stackPointer->Control = pStackContext->OldStackContents.Control;
    stackPointer->Parameters.Others.Argument1 = pStackContext->OldStackContents.Parameters.Others.Argument1;
    stackPointer->Parameters.Others.Argument2 = pStackContext->OldStackContents.Parameters.Others.Argument2;
    stackPointer->Parameters.Others.Argument3 = pStackContext->OldStackContents.Parameters.Others.Argument3;
    stackPointer->Parameters.Others.Argument4 = pStackContext->OldStackContents.Parameters.Others.Argument4;
    stackPointer->FileObject = pStackContext->OldStackContents.FileObject;

    //
    // Put these back too.
    //
    stackPointer->CompletionRoutine = pStackContext->CompletionRoutine;
    stackPointer->Context = pStackContext->IrpContext;

    //
    // Get this before the IRP is freed.
    //
    lastStackLocation = (Irp->CurrentLocation == (CCHAR) (Irp->StackCount + 1));

    //
    // Simulated completion routine.
    //
    SPECIALIRP_IOF_COMPLETE_2(Irp, pStackContext->GlobalContext);
    ZeroAndDopeIrpStackLocation( stackPointer );

    if (!stackPointer->CompletionRoutine) {

        IovpKdPrint(("Local completion routine null stackpointer 0x%x \n", stackPointer));

        //
        // Handle things as if no completion routine existed.
        //
        if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
            IoMarkIrpPending( Irp );
        }

        status = STATUS_SUCCESS;

    } else {

        IovpKdPrint(("Local completion routine 0x%x stackpointer 0x%x \n", routine, stackPointer));

        //
        // A completion routine exists, call it now.
        //
        SPECIALIRP_IOF_COMPLETE_3(Irp, (PVOID) (ULONG_PTR) stackPointer->CompletionRoutine, (PIOFCOMPLETEREQUEST_STACKDATA)pStackContext->GlobalContext);
        status = stackPointer->CompletionRoutine(DeviceObject, Irp, stackPointer->Context);
        SPECIALIRP_IOF_COMPLETE_4(Irp, status, pStackContext->GlobalContext);
    }

    SPECIALIRP_IOF_COMPLETE_5(Irp, pStackContext->GlobalContext);

    if (status != STATUS_MORE_PROCESSING_REQUIRED && !lastStackLocation) {

        //
        // Seed the next location. We can touch the stack as the IRP is still valid
        //

        stackPointer++;

        pStackContext->StackPointer = stackPointer;
        pStackContext->CompletionRoutine = NULL;
        pStackContext->IrpContext = stackPointer->Context;
        pStackContext->StackPointer = stackPointer;
        pStackContext->OldStackContents = *(stackPointer); // Save the stack contents

        if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
             (!NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_ERROR) ||
             (Irp->Cancel &&
             stackPointer->Control & SL_INVOKE_ON_CANCEL)
           ) {

            pStackContext->CompletionRoutine = stackPointer->CompletionRoutine;
            pStackContext->IrpContext = stackPointer->Context;

        } else {

            //
            // Force the completion routine to be called.
            // Store the old control flag value.
            //

            stackPointer->Control |= SL_INVOKE_ON_SUCCESS|SL_INVOKE_ON_ERROR;

        }

        stackPointer->CompletionRoutine = IovpLocalCompletionRoutine;
        stackPointer->Context = pStackContext;

        IovpKdPrint(("Seeding completion Rtn 0x%x currentLocation %d stackpointer 0x%x pStackContext 0x%x \n",
                 stackPointer->CompletionRoutine,
                 Irp->CurrentLocation,
                 stackPointer,
                 pStackContext
                 ));
    }

    return status;
}


VOID
IovInitializeIrp(
    PIRP    Irp,
    USHORT  PacketSize,
    CCHAR   StackSize
    )
{
    BOOLEAN initializeHandled ;

    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoInitializeIrp(Irp, PacketSize, StackSize, &initializeHandled);
}

VOID
IovAttachDeviceToDeviceStack(
    PDEVICE_OBJECT  SourceDevice,
    PDEVICE_OBJECT  TargetDevice
    )
{
    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoAttachDeviceToDeviceStack(SourceDevice, TargetDevice);
}

VOID
IovDeleteDevice(
    PDEVICE_OBJECT  DeleteDevice
    )
{
    if (IovpVerifierFlags & DRIVER_VERIFIER_DMA_VERIFIER) {
       VfHalDeleteDevice(DeleteDevice);
    }

    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoDeleteDevice(DeleteDevice);
}

VOID
IovDetachDevice(
    PDEVICE_OBJECT  TargetDevice
    )
{
    if (IovpVerifierLevel < 2) {
        return;
    }

    VerifierIoDetachDevice(TargetDevice);
}

BOOLEAN
IovCancelIrp(
    PIRP    Irp,
    BOOLEAN *returnValue
    )
{
    BOOLEAN cancelHandled;

    SPECIALIRP_IO_CANCEL_IRP(Irp, &cancelHandled, returnValue) ;

    return cancelHandled;
}

typedef struct  _IOV_DRIVER_LIST_ENTRY {
    SINGLE_LIST_ENTRY   listEntry;
    PDRIVER_OBJECT      DriverObject;
} IOV_DRIVER_LIST_ENTRY, *PIOV_DRIVER_LIST_ENTRY;

SINGLE_LIST_ENTRY   IovDriverListHead;



BOOLEAN
IovpBuildDriverObjectList(
    IN PVOID Object,
    IN PUNICODE_STRING ObjectName,
    IN ULONG_PTR HandleCount,
    IN ULONG_PTR PointerCount,
    IN PVOID Parameter
    )
{
    PIOV_DRIVER_LIST_ENTRY driverListEntry;
    PDRIVER_OBJECT         driverObject;

    UNREFERENCED_PARAMETER (ObjectName);
    UNREFERENCED_PARAMETER (HandleCount);
    UNREFERENCED_PARAMETER (PointerCount);
    UNREFERENCED_PARAMETER (Parameter);

    driverObject = (PDRIVER_OBJECT)Object;

    if (IopIsLegacyDriver(driverObject)) {
        driverListEntry = ExAllocatePoolWithTag(
                                    NonPagedPool,
                                    sizeof(IOV_DRIVER_LIST_ENTRY),
                                    'ovI'
                                    );
        if (!driverListEntry) {
            return FALSE;
        }

        if (ObReferenceObjectSafe(driverObject)) {
           driverListEntry->DriverObject = driverObject;
           PushEntryList(&IovDriverListHead, &driverListEntry->listEntry);
        } else {
           ExFreePool (driverListEntry);
        }
    } else {
        IovpKdPrint (("Rejected non-legacy driver %wZ (%p)\n", &driverObject->DriverName, driverObject));
    }

    return TRUE;
}

NTSTATUS
IovpUnloadDriver(
    PDRIVER_OBJECT  DriverObject
    )
{
    NTSTATUS status;
    BOOLEAN unloadDriver;

    //
    // Check to see whether or not this driver implements unload.
    //

    if (DriverObject->DriverUnload == (PDRIVER_UNLOAD) NULL) {
        IovpKdPrint (("No unload routine for driver %wZ (%p)\n", &DriverObject->DriverName, DriverObject));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Check to see whether the driver has already been marked for an unload
    // operation by anyone in the past.
    //

    ObReferenceObject (DriverObject);

    status = IopCheckUnloadDriver(DriverObject,&unloadDriver);

    if ( NT_SUCCESS(status) ) {
        return STATUS_PENDING;
    }

    ObDereferenceObject (DriverObject);


    if (unloadDriver) {


        //
        // If the current thread is not executing in the context of the system
        // process, which is required in order to invoke the driver's unload
        // routine.  Queue a worker item to one of the worker threads to
        // get into the appropriate process context and then invoke the
        // routine.
        //
        if (PsGetCurrentProcess() == PsInitialSystemProcess) {
            //
            // The current thread is alrady executing in the context of the
            // system process, so simply invoke the driver's unload routine.
            //
            IovpKdPrint (("Calling unload for driver %wZ (%p)\n",
                     &DriverObject->DriverName, DriverObject));
            DriverObject->DriverUnload( DriverObject );
            IovpKdPrint (("Unload returned for driver %wZ (%p)\n",
                     &DriverObject->DriverName, DriverObject));

        } else {
            LOAD_PACKET loadPacket;

            KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
            loadPacket.DriverObject = DriverObject;
            ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                                  IopLoadUnloadDriver,
                                  &loadPacket );
            ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );
            (VOID) KeWaitForSingleObject( &loadPacket.Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }
        ObMakeTemporaryObject( DriverObject );
        ObDereferenceObject( DriverObject );
        return STATUS_SUCCESS;
    } else {
        return STATUS_PENDING;
    }

}

NTSTATUS
IovUnloadDrivers(
    VOID
    )
{
    NTSTATUS status;
    PSINGLE_LIST_ENTRY listEntry;
    PIOV_DRIVER_LIST_ENTRY driverListEntry;
    SINGLE_LIST_ENTRY NonUnloadedDrivers, NonUnloadedDriversTmp;
    BOOLEAN DoneSomething, NeedWait, Break;

    if (!PoCleanShutdownEnabled ())
        return STATUS_UNSUCCESSFUL;

    IovDriverListHead.Next = NULL;
    NonUnloadedDrivers.Next = NULL;

    //
    // Prepare a list of all driver objects.
    //

    status = ObEnumerateObjectsByType(
                IoDriverObjectType,
                IovpBuildDriverObjectList,
                NULL
                );

    //
    // Walk through the list and unload each driver.
    //
    while (TRUE) {
        listEntry = PopEntryList(&IovDriverListHead);
        if (listEntry == NULL) {
            break;
        }
        driverListEntry = CONTAINING_RECORD(listEntry, IOV_DRIVER_LIST_ENTRY, listEntry);
        IovpKdPrint (("Trying to unload %wZ (%p)\n",
                  &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));
        if (IovpUnloadDriver(driverListEntry->DriverObject) != STATUS_PENDING) {
            ObDereferenceObject(driverListEntry->DriverObject);
            ExFreePool(driverListEntry);
        } else {
            IovpKdPrint (("Unload of driver %wZ (%p) pended\n",
                      &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));
            PushEntryList(&NonUnloadedDrivers, &driverListEntry->listEntry);
        }
    }

    //
    // Walk the drivers that didn't unload straight away and see if any have had their unloads called yet
    //
    do {
        NeedWait = DoneSomething = FALSE;
        NonUnloadedDriversTmp.Next = NULL;

        while (TRUE) {

            listEntry = PopEntryList(&NonUnloadedDrivers);

            if (listEntry == NULL) {
                break;
            }

            driverListEntry = CONTAINING_RECORD(listEntry, IOV_DRIVER_LIST_ENTRY, listEntry);

            //
            // If driver unload is queued to be invoked then
            //

            if (driverListEntry->DriverObject->Flags & DRVO_UNLOAD_INVOKED) {

                IovpKdPrint (("Pending unload of driver %wZ (%p) is being invoked\n",
                         &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));
                ObDereferenceObject(driverListEntry->DriverObject);
                ExFreePool(driverListEntry);
                NeedWait = TRUE;

            } else {

                PushEntryList(&NonUnloadedDriversTmp, &driverListEntry->listEntry);
            }
        }

        if (NeedWait) {
            LARGE_INTEGER tmo = {(ULONG)(-10 * 1000 * 1000 * 10), -1};
            ZwDelayExecution (FALSE, &tmo);
            DoneSomething = TRUE;
        }

        NonUnloadedDrivers = NonUnloadedDriversTmp;

    } while (DoneSomething == TRUE && NonUnloadedDrivers.Next != NULL);

    //
    // All the drivers left didn't have unload called becuase they had files open etc
    //

    Break = FALSE;

    while (TRUE) {

        listEntry = PopEntryList(&NonUnloadedDrivers);

        if (listEntry == NULL) {
            break;
        }

        driverListEntry = CONTAINING_RECORD(listEntry, IOV_DRIVER_LIST_ENTRY, listEntry);

        IovpKdPrint (("Unload never got called for driver %wZ (%p)\n",
                 &driverListEntry->DriverObject->DriverName, driverListEntry->DriverObject));

        ObDereferenceObject(driverListEntry->DriverObject);
        ExFreePool(driverListEntry);

        Break = TRUE;
    }
    if (Break == TRUE) {
//      DbgBreakPoint ();
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\lock.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This module contains the code to implement the NtLockFile and the
    NtUnlockFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 29-Nov-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtLockFile)
#pragma alloc_text(PAGE, NtUnlockFile)
#endif

NTSTATUS
NtLockFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    )

/*++

Routine Description:

    This service locks a specified range of bytes on the file specified by
    the FileHandle parameter.  The lock may either be an exclusive lock or
    a shared lock.  Furthermore, the caller has the option of specifying
    whether or not the service should return immediately if the lock cannot
    be acquired without waiting.

Arguments:

    FileHandle - Supplies a handle to an open file.

    Event - Supplies an optional event to be set to the Signaled state when
        the operation is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    ByteOffset - Specifies the starting byte offset of the range to lock.

    Length - Specifies the length of the byte range to be locked.

    Key - Specifies the key to be associated with the lock.

    FailImmediately - Specifies that if the lock cannot immediately be
        acquired that the service should return to the caller.

    ExclusiveLock - Specifies, if TRUE, that the lock should be an exclusive
        lock;  otherwise the lock is a shared lock.

Return Value:

    The status returned is success if the operation was properly queued to
    the I/O system.  Once the operation completes, the status can be
    determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT eventObject = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER fileOffset;
    LARGE_INTEGER length;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers
    // in user mode.  Note that if the handle does not refer to a file
    // object, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either READ or WRITE access to
        // the file.  If not, cleanup and return an error.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The ByteOffset parameter must be readable by the caller.  Probe
            // and capture it.
            //

            ProbeForReadSmallStructure( ByteOffset,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            fileOffset = *ByteOffset;

            //
            // Likewise, the Length parameter must also be readable by the
            // caller.  Probe and capture it as well.
            //

            ProbeForReadSmallStructure( Length,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            length = *Length;

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller's
            // parameters.  Dereference the file object and return an
            // appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return GetExceptionCode();
        }

    } else {

        //
        // The caller's mode was kernel.  Get the ByteOffset and Length
        // parameter 's to the expected locations.
        //

        fileOffset = *ByteOffset;
        length = *Length;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.  Since certain legacy
    // applications rely on an old bug in Win32's LockFileEx, we must
    // tolerate bad event handles.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ASSERT( !eventObject );
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the target device object and the fast Io dispatch
    // structure.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Turbo lock support.  If the fast Io Dispatch specifies a fast lock
    // routine then we'll first try and calling it with the specified lock
    // parameters.
    //

    if (fastIoDispatch && fastIoDispatch->FastIoLock) {

        IO_STATUS_BLOCK localIoStatus;

        if (fastIoDispatch->FastIoLock( fileObject,
                                        &fileOffset,
                                        &length,
                                        PsGetCurrentProcessByThread(CurrentThread),
                                        Key,
                                        FailImmediately,
                                        ExclusiveLock,
                                        &localIoStatus,
                                        deviceObject )) {

            //
            // Carefully return the I/O status.
            //

            try {
#if defined(_WIN64)
                //
                // If this is a32-bit thread, and the IO request is 
                // asynchronous, then the IOSB is 32-bit. Wow64 always sends
                // the 32-bit IOSB when the I/O is asynchronous.
                //
                if (IopIsIosb32(ApcRoutine)) {
                    PIO_STATUS_BLOCK32 UserIosb32 = (PIO_STATUS_BLOCK32)IoStatusBlock;
                    
                    UserIosb32->Information = (ULONG)localIoStatus.Information;
                    UserIosb32->Status = (NTSTATUS)localIoStatus.Status;
                } else {
                    *IoStatusBlock = localIoStatus;
                }
#else
                *IoStatusBlock = localIoStatus;
#endif
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                localIoStatus.Status = GetExceptionCode();
                localIoStatus.Information = 0;
            }

            //
            // If a valid event was specified, set it.
            //

            if (eventObject) {
                KeSetEvent( eventObject, 0, FALSE );
                ObDereferenceObject( eventObject );
            }

            //
            // Note that the file object event need not be set to the
            // Signaled state, as it is already set.
            //

            //
            // If this file object has a completion port associated with it
            // and this request has a non-NULL APC context then a completion
            // message needs to be queued.
            //

            if (fileObject->CompletionContext && ARGUMENT_PRESENT( ApcContext )) {
                if (!NT_SUCCESS(IoSetIoCompletion( fileObject->CompletionContext->Port,
                                                   fileObject->CompletionContext->Key,
                                                   ApcContext,
                                                   localIoStatus.Status,
                                                   localIoStatus.Information,
                                                   TRUE ))) {
                    localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            //
            // Cleanup and return.
            //

            fileObject->LockOperation = TRUE;
            ObDereferenceObject( fileObject );
            return localIoStatus.Status;
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state and mark it as having had
    // a lock operation performed on it.
    //

    KeClearEvent( &fileObject->Event );
    fileObject->LockOperation = TRUE;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_LOCK;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Flags = 0;
    if (FailImmediately) {
        irpSp->Flags = SL_FAIL_IMMEDIATELY;
    }
    if (ExclusiveLock) {
        irpSp->Flags |= SL_EXCLUSIVE_LOCK;
    }
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = fileOffset;

    try {
        PLARGE_INTEGER lengthBuffer;

        //
        // Attempt to allocate an intermediary buffer to hold the length of
        // this lock operation.  If it fails, either because there is no
        // more quota, or because there are no more resources, then the
        // exception handler will be invoked to cleanup and exit.
        //

        lengthBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                sizeof( LARGE_INTEGER ) );

        *lengthBuffer = length;
        irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
        irpSp->Parameters.LockControl.Length = lengthBuffer;
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred.  Simply clean everything up and
        // return an appropriate error status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             eventObject,
                             (PKEVENT) NULL );

        return GetExceptionCode();
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      FALSE,
                                      requestorMode,
                                      synchronousIo,
                                      OtherTransfer );
}

NTSTATUS
NtUnlockFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG Key
    )

/*++

Routine Description:

    This service releases the lock associated with the specified byte range
    for the file specified by the FileHandle parameter.

Arguments:

    FileHandle - Supplies a handle to an open file.

    IoStatusBlock - Address of the caller's I/O status block.

    ByteOffset - Specifies the byte offset of the range to unlock.

    Length - Specifies the length of the byte range to unlock.

    Key - Specifies the key associated with the locked range.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT event;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    LARGE_INTEGER fileOffset;
    LARGE_INTEGER length;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers
    // in user mode.  Note that if the handle does not refer to a file
    // object, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either READ or WRITE access
        // to the file.  If not, cleanup and return an error.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The ByteOffset parameter must be readable by the caller.  Probe
            // and capture it.
            //

            ProbeForReadSmallStructure( ByteOffset,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            fileOffset = *ByteOffset;

            //
            // Likewise, the Length parameter must also be readable by the
            // caller.  Probe and capture it as well.
            //

            ProbeForReadSmallStructure( Length,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            length = *Length;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was kernel.  Get the ByteOffset and Length
        // parameter 's to the expected locations.
        //

        fileOffset = *ByteOffset;
        length = *Length;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.  Also get the fast I/O dispatch address.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Turbo lock support.  If the fast Io Dispatch specifies a fast lock
    // routine then we'll first try and calling it with the specified lock
    // parameters.
    //

    if (fastIoDispatch && fastIoDispatch->FastIoUnlockSingle) {

        IO_STATUS_BLOCK localIoStatus;

        if (fastIoDispatch->FastIoUnlockSingle( fileObject,
                                                &fileOffset,
                                                &length,
                                                PsGetCurrentProcessByThread(CurrentThread),
                                                Key,
                                                &localIoStatus,
                                                deviceObject )) {

            //
            // Carefully return the I/O status.
            //

            try {
                *IoStatusBlock = localIoStatus;
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                localIoStatus.Status = GetExceptionCode();
                localIoStatus.Information = 0;
            }

            //
            // Cleanup and return.
            //

            ObDereferenceObject( fileObject );
            return localIoStatus.Status;
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
        event = NULL;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (event) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_UNLOCK_SINGLE;
    irpSp->FileObject = fileObject;

    try {
        PLARGE_INTEGER lengthBuffer;

        //
        // Attempt to allocate an intermediary buffer to hold the length of
        // this lock operation.  If it fails, either because there is no
        // more quota, or because there are no more resources, then the
        // exception handler will be invoked to cleanup and exit.
        //

        lengthBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                sizeof( LARGE_INTEGER ) );

        *lengthBuffer = length;
        irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
        irpSp->Parameters.LockControl.Length = lengthBuffer;
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred.  Simply clean everything up and
        // return an appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }
  
        IopExceptionCleanup( fileObject,
                             irp,
                             NULL,
                             (PKEVENT) NULL );

        return GetExceptionCode();
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the code to implement the NtFlushBuffersFile,
    NtSetNewSizeFile, IoQueueWorkItem, and NtCancelIoFile system services
    for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 22-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

//
// Local function prototypes follow
//

VOID
IopProcessWorkItem(
    IN PVOID Parameter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtCancelIoFile)
#pragma alloc_text(PAGE, NtDeleteFile)
#pragma alloc_text(PAGE, NtFlushBuffersFile)
#pragma alloc_text(PAGE, NtQueryAttributesFile)
#pragma alloc_text(PAGE, NtQueryFullAttributesFile)
#pragma alloc_text(PAGE, IopProcessWorkItem)
#endif


NTSTATUS
NtCancelIoFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This service causes all pending I/O operations for the specified file to be
    marked as canceled.  Most types of operations can be canceled immediately,
    while others may continue toward completion before they are actually
    canceled and the caller is notified.

    Only those pending operations that were issued by the current thread using
    the specified handle are canceled.  Any operations issued for the file by
    any other thread or any other process continues normally.

Arguments:

    FileHandle - Supplies a handle to the file whose operations are to be
        canceled.

    IoStatusBlock - Address of the caller's I/O status block.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KPROCESSOR_MODE requestorMode;
    PETHREAD thread;
    BOOLEAN found = FALSE;
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;

    PAGED_CODE();


    //
    // Get the address of the current thread.  The thread contains a list of
    // the pending operations for this file.
    //

    thread = PsGetCurrentThread();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousModeByThread(&thread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller'
            // I/O status block.  Simply return an appropriate error status
            // code.
            //

            return GetExceptionCode();
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return(status);
    }

    //
    // Note that here the I/O system would normally make a check to determine
    // whether or not the file was opened for synchronous I/O.  If it was, then
    // it would attempt to exclusively acquire the file object lock.  However,
    // since this service is attempting to cancel all of the I/O for the file,
    // it does not make much sense to wait until it has all completed before
    // attempting to cancel it.
    //


    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();

    //
    // Walk the list of IRPs on the thread's pending I/O queue looking for IRPs
    // which specify the same file as the FileHandle refers to.  For each IRP
    // found, set its cancel flag.  If no IRPs are found, simply complete the
    // I/O here.  The only synchronization needed here is to block out all APCs
    // for this thread so that no I/O can complete and remove packets from the
    // queue.  No considerations need be made for multi-processing since this
    // thread can only be running on one processor at a time and this routine
    // has control of the thread for now.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    header = &thread->IrpList;
    entry = thread->IrpList.Flink;

    while (header != entry) {

        //
        // An IRP has been found for this thread.  If the IRP refers to the
        // appropriate file object, set its cancel flag and remember that it
        // was found;  otherwise, simply continue the loop.
        //

        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        if (irp->Tail.Overlay.OriginalFileObject == fileObject) {
            found = TRUE;
            IoCancelIrp( irp );
        }

        entry = entry->Flink;
    }

    //
    // Lower the IRQL back down to what it was on entry to this procedure.
    //

    KeLowerIrql( irql );

    if (found) {

        LARGE_INTEGER interval;

        //
        // Delay execution for a time and let the request
        // finish.  The delay time is 10ms.
        //

        interval.QuadPart = -10 * 1000 * 10;

        //
        // Wait for a while so the canceled requests can complete.
        //

        while (found) {

            (VOID) KeDelayExecutionThread( KernelMode, FALSE, &interval );

            found = FALSE;

            //
            // Raise the IRQL to prevent modification to the IRP list by the
            // thread's APC routine.
            //

            KeRaiseIrql( APC_LEVEL, &irql );

            //
            // Check the IRP list for requests which refer to the specified
            // file object.
            //

            entry = thread->IrpList.Flink;

            while (header != entry) {

                //
                // An IRP has been found for this thread.  If the IRP refers
                // to the appropriate file object,  remember that it
                // was found;  otherwise, simply continue the loop.
                //

                irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
                if (irp->Tail.Overlay.OriginalFileObject == fileObject) {
                    found = TRUE;
                    break;
                }

                entry = entry->Flink;
            }

            //
            // Lower the IRQL back down to what it was on entry to this procedure.
            //

            KeLowerIrql( irql );

        }
    }

    try {

        //
        // Write the status back to the user.
        //

        IoStatusBlock->Status = STATUS_SUCCESS;
        IoStatusBlock->Information = 0L;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to write the caller's
        // I/O status block; however, the service completed sucessfully so
        // just return sucess.
        //

    }

    //
    // Dereference the file object.
    //

    ObDereferenceObject( fileObject );

    return STATUS_SUCCESS;
}

NTSTATUS
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This service deletes the specified file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    HANDLE handle;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    //
    // Build a parse open packet that tells the parse method to open the file
    // for open for delete access w/the delete bit set, and then close it.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.CreateOptions = FILE_DELETE_ON_CLOSE;
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.DeleteOnly = TRUE;
    openPacket.TraversedMountPoint = FALSE;
    openPacket.LocalFileObject = &localFileObject;

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Open the object by its name.  Because of the special DeleteOnly flag
    // set in the open packet, the parse routine will open the file, and
    // then realize that it is only deleting the file, and will therefore
    // immediately dereference the file.  This will cause the cleanup and
    // the close to be sent to the file system, thus causing the file to
    // be deleted.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 DELETE,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        return openPacket.FinalStatus;
    }
}

NTSTATUS
NtFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This service causes all buffered data to the file to be written.

Arguments:

    FileHandle - Supplies a handle to the file whose buffers should be flushed.

    IoStatusBlock - Address of the caller's I/O status block.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    OBJECT_HANDLE_INFORMATION objectHandleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller's
            // I/O status block.  Simply return an appropriate error status
            // code.
            //

            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &objectHandleInformation );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Ensure that the caller has either WRITE or APPEND access to the file
    // before allowing this call to continue.  This is especially important
    // if the caller opened a volume, where a flush operation may flush more
    // than what this opener has written to buffers.  Note however that if
    // this is a pipe, then the APPEND access cannot be made since this
    // access code is overlaid with the CREATE_PIPE_INSTANCE access.
    //

    if (SeComputeGrantedAccesses( objectHandleInformation.GrantedAccess,
                                  (!(fileObject->Flags & FO_NAMED_PIPE) ?
                                  FILE_APPEND_DATA : 0) |
                                  FILE_WRITE_DATA ) == 0) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
        event = NULL;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An exception was incurred while attempting to allocate the IRP.
        // Cleanup and return an appropriate error status code.
        //

        if (event) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This is used
    // to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = fileObject;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtQueryAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_BASIC_INFORMATION FileInformation
    )

/*++

Routine Description:

    This service queries the basic attributes information for a specified file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    FileInformation - Supplies an output buffer to receive the returned file
        attributes information.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    FILE_NETWORK_OPEN_INFORMATION networkInformation;
    HANDLE handle;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {

        try {

            //
            // The caller's mode is not kernel, so probe the output buffer.
            //

            ProbeForWriteSmallStructure( FileInformation,
                                         sizeof( FILE_BASIC_INFORMATION ),
                                         sizeof( ULONG_PTR ));

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }

    //
    // Build a parse open packet that tells the parse method to open the file,
    // query the file's basic attributes, and close the file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.CreateOptions = FILE_OPEN_REPARSE_POINT|FILE_OPEN_FOR_BACKUP_INTENT;
    openPacket.BasicInformation = FileInformation;
    openPacket.NetworkInformation = &networkInformation;
    openPacket.QueryOnly = TRUE;
    openPacket.TraversedMountPoint = FALSE;
    openPacket.LocalFileObject = &localFileObject;

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file, and then
    // realize that it is only performing a query.  It will therefore perform
    // the query, and immediately close the file.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 FILE_READ_ATTRIBUTES,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        if (NT_SUCCESS(status)) {
            ZwClose(handle);
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }
        return status;
    } else {
        return openPacket.FinalStatus;
    }
}

#pragma warning(push)
#pragma warning(disable:4701)

NTSTATUS
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )

/*++

Routine Description:

    This service queries the network attributes information for a specified
    file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    FileInformation - Supplies an output buffer to receive the returned file
        attributes information.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    FILE_NETWORK_OPEN_INFORMATION networkInformation;
    HANDLE handle;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if (requestorMode != KernelMode) {

        try {

            //
            // The caller's mode is not kernel, so probe the output buffer.
            //

            ProbeForWriteSmallStructure( FileInformation,
                                         sizeof( FILE_NETWORK_OPEN_INFORMATION ),
#if defined(_X86_)
                                         sizeof( LONG ));
#else
                                         sizeof( LONGLONG ));
#endif // defined(_X86_)

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }

    //
    // Build a parse open packet that tells the parse method to open the file,
    // query the file's full attributes, and close the file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.CreateOptions = FILE_OPEN_REPARSE_POINT|FILE_OPEN_FOR_BACKUP_INTENT;
    openPacket.QueryOnly = TRUE;
    openPacket.FullAttributes = TRUE;
    openPacket.TraversedMountPoint = FALSE;
    openPacket.LocalFileObject = &localFileObject;
    if (requestorMode != KernelMode) {
        openPacket.NetworkInformation = &networkInformation;
    } else {
        openPacket.NetworkInformation = FileInformation;
    }

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file, and then
    // realize that it is only performing a query.  It will therefore perform
    // the query, and immediately close the file.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 FILE_READ_ATTRIBUTES,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        if (NT_SUCCESS(status)) {
            ZwClose(handle);
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }
        return status;
    } else {
        status = openPacket.FinalStatus;
    }

    if (NT_SUCCESS( status )) {
        if (requestorMode != KernelMode) {
            try {

                //
                // The query worked, so copy the returned information to the
                // caller's output buffer.
                //

                RtlCopyMemory( FileInformation,
                               &networkInformation,
                               sizeof( FILE_NETWORK_OPEN_INFORMATION ) );

            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        }
    }

    return status;
}

#pragma warning(pop)

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    )
{
    PIO_WORKITEM ioWorkItem;
    PWORK_QUEUE_ITEM exWorkItem;

    //
    // Allocate a new workitem structure.
    // 

    ioWorkItem = ExAllocatePool( NonPagedPool, sizeof( IO_WORKITEM ));
    if (ioWorkItem != NULL) {

        //
        // Initialize the invariant portions of both ioWorkItem and
        // exWorkItem.
        //

#if DBG
        ioWorkItem->Size = sizeof( IO_WORKITEM );
#endif

        ioWorkItem->DeviceObject = DeviceObject;

        exWorkItem = &ioWorkItem->WorkItem;
        ExInitializeWorkItem( exWorkItem, IopProcessWorkItem, ioWorkItem );
    }

    return ioWorkItem;
}

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    )

/*++

Routine Description:

    This function is the "wrapper" routine for IoQueueWorkItem.  It calls
    the original worker function, then dereferences the device object to
    (possibly) allow the driver object to go away.

Arguments:

    Parameter - Supplies a pointer to an IO_WORKITEM for us to process.

Return Value:

    None

--*/

{
    ASSERT( IoWorkItem->Size == sizeof( IO_WORKITEM ));

    ExFreePool( IoWorkItem );
}

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    )
/*++

Routine Description:

    This function inserts a work item into a work queue that is processed
    by a worker thread of the corresponding type.  It effectively
    "wraps" ExQueueWorkItem, ensuring that the device object is referenced
    for the duration of the call.

Arguments:

    IoWorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must have been allocated via IoAllocateWorkItem().

    WorkerRoutine - Supplies a pointer to the routine that is to be called
        in system thread context.

    QueueType - Specifies the type of work queue that the work item
        should be placed in.

    Context - Supplies the context parameter for the callback routine.

Return Value:

    None

--*/

{
    PWORK_QUEUE_ITEM exWorkItem;

    ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );
    ASSERT( IoWorkItem->Size == sizeof( IO_WORKITEM ));

    //
    // Keep a reference on the device object so it doesn't go away.
    //

    ObReferenceObject( IoWorkItem->DeviceObject );

    //
    // Initialize the fields in IoWorkItem
    //

    IoWorkItem->Routine = WorkerRoutine;
    IoWorkItem->Context = Context;

    //
    // Get a pointer to the ExWorkItem, queue it, and return.
    // IopProcessWorkItem() will perform the dereference.
    // 

    exWorkItem = &IoWorkItem->WorkItem;
    ExQueueWorkItem( exWorkItem, QueueType );
}

VOID
IopProcessWorkItem(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This function is the "wrapper" routine for IoQueueWorkItem.  It calls
    the original worker function, then dereferences the device object to
    (possibly) allow the driver object to go away.

Arguments:

    Parameter - Supplies a pointer to an IO_WORKITEM for us to process.

Return Value:

    None

--*/

{
    PIO_WORKITEM ioWorkItem;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the ioWorkItem and store a copy of DeviceObject
    // locally.  This allow us to function properly if the worker routine
    // elects to free the work item.
    //

    ioWorkItem = (PIO_WORKITEM)Parameter;
    deviceObject = ioWorkItem->DeviceObject;

    //
    // Call the original worker.
    //

    ioWorkItem->Routine( deviceObject,
                         ioWorkItem->Context );

    //
    // Now we can dereference the device object, since its code is no longer
    // being executed for this work item.
    //

    ObDereferenceObject( deviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\objsup.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    objsup.c

Abstract:

    This module contains the object support routine for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 30-May-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

NTSTATUS
IopSetDeviceSecurityDescriptors(
    IN PDEVICE_OBJECT           OriginalDeviceObject,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    );

NTSTATUS
IopSetDeviceSecurityDescriptor(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopCloseFile)
#pragma alloc_text(PAGE, IopDeleteFile)
#pragma alloc_text(PAGE, IopDeleteDevice)
#pragma alloc_text(PAGE, IopDeleteDriver)
#pragma alloc_text(PAGE, IopGetSetSecurityObject)
#pragma alloc_text(PAGE, IopSetDeviceSecurityDescriptors)
#pragma alloc_text(PAGE, IopSetDeviceSecurityDescriptor)
#endif

VOID
IopCloseFile(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ULONG GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )

/*++

Routine Description:

    This routine is invoked whenever a handle to a file is deleted.  If the
    handle being deleted is the last handle to the file (the ProcessHandleCount
    parameter is one), then all locks for the file owned by the specified
    process must be released.

    Likewise, if the SystemHandleCount is one then this is the last handle
    for this for file object across all processes.  For this case, the file
    system is notified so that it can perform any necessary cleanup on the
    file.

Arguments:

    Process - A pointer to the process that closed the handle.

    Object - A pointer to the file object that the handle referenced.

    GrantedAccess - Access that was granted to the object through the handle.

    ProcessHandleCount - Count of handles outstanding to the object for the
        process specified by the Process argument.  If the count is one
        then this is the last handle to this file by that process.

    SystemHandleCount - Count of handles outstanding to the object for the
        entire system.  If the count is one then this is the last handle
        to this file in the system.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    KEVENT event;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    UNREFERENCED_PARAMETER( GrantedAccess );

    PAGED_CODE();

    //
    // If the handle count is not one then this is not the last close of
    // this file for the specified process so there is nothing to do.
    //

    if (ProcessHandleCount != 1) {
        return;
    }

    fileObject = (PFILE_OBJECT) Object;

    if (fileObject->LockOperation && SystemHandleCount != 1) {

        IO_STATUS_BLOCK localIoStatus;

        //
        // This is the last handle for the specified process and the process
        // called the NtLockFile or NtUnlockFile system services at least once.
        // Also, this is not the last handle for this file object system-wide
        // so unlock all of the pending locks for this process.  Note that
        // this check causes an optimization so that if this is the last
        // system-wide handle to this file object the cleanup code will take
        // care of releasing any locks on the file rather than having to
        // send the file system two different packets to get them shut down.

        //
        // Get the address of the target device object and the Fast I/O dispatch
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Turbo unlock support.  If the fast Io Dispatch specifies a fast lock
        // routine then we'll first try and calling it with the specified lock
        // parameters.  If this is all successful then we do not need to do
        // the Irp based unlock all call.
        //

        if (fastIoDispatch &&
            fastIoDispatch->FastIoUnlockAll &&
            fastIoDispatch->FastIoUnlockAll( fileObject,
                                             PsGetCurrentProcess(),
                                             &localIoStatus,
                                             deviceObject )) {

            NOTHING;

        } else {

            //
            // Initialize the local event that will be used to synchronize access
            // to the driver completing this I/O operation.
            //

            KeInitializeEvent( &event, SynchronizationEvent, FALSE );

            //
            // Reset the event in the file object.
            //

            KeClearEvent( &fileObject->Event );

            //
            // Allocate and initialize the I/O Request Packet (IRP) for this
            // operation.
            //

            irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
            irp->Tail.Overlay.OriginalFileObject = fileObject;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->RequestorMode = KernelMode;

            //
            // Fill in the service independent parameters in the IRP.
            //

            irp->UserEvent = &event;
            irp->UserIosb = &irp->IoStatus;
            irp->Flags = IRP_SYNCHRONOUS_API;
            irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

            //
            // Get a pointer to the stack location for the first driver.  This will
            // be used to pass the original function codes and parameters.  No
            // function-specific parameters are required for this operation.
            //

            irpSp = IoGetNextIrpStackLocation( irp );
            irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
            irpSp->MinorFunction = IRP_MN_UNLOCK_ALL;
            irpSp->FileObject = fileObject;

            //
            //  Reference the fileobject again for the IRP (cleared on completion)
            //

            ObReferenceObject( fileObject );

            //
            // Insert the packet at the head of the IRP list for the thread.
            //

            IopQueueThreadIrp( irp );

            //
            // Invoke the driver at its appropriate dispatch entry with the IRP.
            //

            status = IoCallDriver( deviceObject, irp );

            //
            // If no error was incurred, wait for the I/O operation to complete.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              UserRequest,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }
        }

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    if (SystemHandleCount == 1) {

        //
        // The last handle to this file object for all of the processes in the
        // system has just been closed, so invoke the driver's "cleanup" handler
        // for this file.  This is the file system's opportunity to remove any
        // share access information for the file, to indicate that if the file
        // is opened for a caching operation and this is the last file object
        // to the file, then it can do whatever it needs with memory management
        // to cleanup any information.
        //
        // Begin by getting the address of the target device object.
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        //
        // Ensure that the I/O system believes that this file has a handle
        // associated with it in case it doesn't actually get one from the
        // Object Manager.  This is done because sometimes the Object Manager
        // actually creates a handle, but the I/O system never finds out
        // about it so it attempts to send two cleanups for the same file.
        //

        fileObject->Flags |= FO_HANDLE_CREATED;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        // Note : We need to do this only if IopCloseFile is not called from
        // IopDeleteFile
        //

        if (Process && fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Initialize the local event that will be used to synchronize access
        // to the driver completing this I/O operation.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->RequestorMode = KernelMode;

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->UserEvent = &event;
        irp->UserIosb = &irp->IoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
        irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.  No
        // function-specific parameters are required for this operation.
        //

        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_CLEANUP;
        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Update the operation count statistic for the current process for
        // operations other than read and write.
        //

        IopUpdateOtherOperationCount();

        //
        // Invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If no error was incurred, wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // The following code tears down the IRP by hand since it may not
        // either be possible to it to be completed (because this code was
        // invoked as APC_LEVEL in the first place - or because the reference
        // count on the object cannot be incremented due to this routine
        // being invoked by the delete file procedure below).  Cleanup IRPs
        // therefore use close sematics (the close operation flag is set
        // in the IRP) so that the I/O complete request routine itself sets
        // the event to the Signaled state.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        //
        // Also, free the IRP.
        //

        IoFreeIrp( irp );

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        // Note : We need to do this only if IopCloseFile is not called from
        // IopDeleteFile
        //

        if (Process && fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return;
}

VOID
IopDeleteFile(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the last handle to a specific file handle is
    being closed and the file object is going away.  It is the responsibility
    of this routine to perform the following functions:

        o  Notify the device driver that the file object is open on that the
           file is being closed.

        o  Dereference the user's error port for the file object, if there
           is one associated with the file object.

        o  Decrement the device object reference count.

Arguments:

    Object - Pointer to the file object being deleted.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT fsDevice = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL irql;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KEVENT event;
    PVPB vpb;
    BOOLEAN referenceCountDecremented;

    //
    // Obtain a pointer to the file object.
    //

    fileObject = (PFILE_OBJECT) Object;

    //
    // Get a pointer to the first device driver which should be notified that
    // this file is going away.  If the device driver field is NULL, then this
    // file is being shut down due to an error attempting to get it open in the
    // first place, so do not do any further processing.
    //

    if (fileObject->DeviceObject) {
        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        // 
        // On IopDeleteFile path the lock should always be ours as there should be
        // no one else using this object.
        //

        ASSERT (!(fileObject->Flags & FO_SYNCHRONOUS_IO) ||
                 (InterlockedExchange( (PLONG) &fileObject->Busy, (ULONG) TRUE ) == FALSE ));

        //
        // If this file has never had a file handle created for it, and yet
        // it exists, invoke the close file procedure so that the file system
        // gets the cleanup IRP it is expecting before sending the close IRP.
        //

        if (!(fileObject->Flags & FO_HANDLE_CREATED)) {
            IopCloseFile( (PEPROCESS) NULL,
                          Object,
                          0,
                          1,
                          1 );
        }

        //
        // Reset a local event that can be used to wait for the device driver
        // to close the file.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate an I/O Request Packet (IRP) to be used in communicating with
        // the appropriate device driver that the file is being closed.  Notice
        // that the allocation of this packet is done without charging quota so
        // that the operation will not fail.  This is done because there is no
        // way to return an error to the caller at this point.
        //

        irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
        if (!irp) {
            irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        }

        //
        // Get a pointer to the stack location for the first driver.  This is
        // where the function codes and parameters are placed.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Fill in the IRP, indicating that this file object is being deleted.
        //

        irpSp->MajorFunction = IRP_MJ_CLOSE;
        irpSp->FileObject = fileObject;
        irp->UserIosb = &ioStatusBlock;
        irp->UserEvent = &event;
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
        irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

        //
        // Place this packet in the thread's I/O pending queue.
        //

        IopQueueThreadIrp( irp );

        //
        // Decrement the reference count on the VPB, if necessary.  We
        // have to do this BEFORE handing the Irp to the file system
        // because of a trick the file systems play with close, and
        // believe me, you really don't want to know what it is.
        //
        // Since there is not a error path here (close cannot fail),
        // and the file system is the only ome who can actually synchronize
        // with the actual completion of close processing, the file system
        // is the one responsible for Vpb deletion.
        //

        vpb = fileObject->Vpb;


        if (vpb && !(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                          (PLONG) &vpb->ReferenceCount );

            //
            // Bump the handle count of the filesystem volume device object.
            // This will prevent the filesystem filter stack from being torn down
            // until after the close IRP completes.
            //

            fsDevice = vpb->DeviceObject;
            if (fsDevice) {
                IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                              &fsDevice->ReferenceCount );
            }
        }

        //
        // If this device object has stated for a fact that it knows it will
        // never have the final non-zero reference count among the other
        // device objects associated with our driver object, then decrement
        // our reference count here BEFORE calling the file system.  This
        // is required because for a special class of device objects, the
        // file system may delete them.
        //

        if (fileObject->DeviceObject->Flags & DO_NEVER_LAST_DEVICE) {
            IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                          &fileObject->DeviceObject->ReferenceCount );

            referenceCountDecremented = TRUE;
        } else {
            referenceCountDecremented = FALSE;
        }

        //
        // Give the device driver the packet.  If this request does not work,
        // there is nothing that can be done about it.  This is unfortunate
        // because the driver may have had problems that it was about to
        // report about other operations (e.g., write behind failures, etc.)
        // that it can no longer report.  The reason is that this routine
        // is really initially invoked by NtClose, which has already closed
        // the caller's handle, and that's what the return status from close
        // indicates:  the handle has successfully been closed.
        //

        status = IoCallDriver( deviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // Perform any completion operations that need to be performed on
        // the IRP that was used for this request.  This is done here as
        // as opposed to in normal completion code because there is a race
        // condition between when this routine executes if it was invoked
        // from a special kernel APC (e.g., some IRP was just completed and
        // dereferenced this file object for the last time), and when the
        // special kernel APC because of this packet's completion executing.
        //
        // This problem is solved by not having to queue a special kernel
        // APC routine for completion of this packet.  Rather, it is treated
        // much like a synchronous paging I/O operation, except that the
        // packet is not even freed during I/O completion.  This is because
        // the packet is still in this thread's queue, and there is no way
        // to get it out except at APC_LEVEL.  Unfortunately, the part of
        // I/O completion that needs to dequeue the packet is running at
        // DISPATCH_LEVEL.
        //
        // Hence, the packet must be removed from the queue (synchronized,
        // of course), and then it must be freed.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        IoFreeIrp( irp );

        //
        // Free the file name string buffer if there was one.
        //

        if (fileObject->FileName.Length != 0) {
            ExFreePool( fileObject->FileName.Buffer );
        }

        //
        // If there was an completion port associated w/this file object, dereference
        // it now, and deallocate the completion context pool.
        //

        if (fileObject->CompletionContext) {
            ObDereferenceObject( fileObject->CompletionContext->Port );
            ExFreePool( fileObject->CompletionContext );
        }

        //
        // Free the file context control structure if it exists.
        //

        if (fileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
            FsRtlPTeardownPerFileObjectContexts(fileObject);
        }

        //
        // Get a pointer to the real device object so its reference count
        // can be decremented.
        //

        deviceObject = fileObject->DeviceObject;

        //
        // Decrement the reference count on the device object.  Note that
        // if the driver has been marked for an unload operation, and the
        // reference count goes to zero, then the driver may need to be
        // unloaded at this point.
        //
        // Note: only do this if the reference count was not already done
        // above.  The device object may be gone in this case.
        //

        if (!referenceCountDecremented) {

            IopDecrementDeviceObjectRef(
                deviceObject,
                FALSE,
                !ObIsObjectDeletionInline(Object)
                );
        }

        //
        // Decrement the filesystem's volume device object handle count
        // so that deletes can proceed.
        //

        if (fsDevice && vpb) {
            IopDecrementDeviceObjectRef(fsDevice,
                                         FALSE,
                                         !ObIsObjectDeletionInline(Object)
                                         );
        }
    }
}

VOID
IopDeleteDriver(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the reference count for a driver object
    becomes zero.  That is, the last reference for the driver has gone away.
    This routine ensures that the object is cleaned up and the driver
    unloaded.

Arguments:

    Object - Pointer to the driver object whose reference count has gone
        to zero.

Return value:

    None.

--*/

{
    PDRIVER_OBJECT driverObject = (PDRIVER_OBJECT) Object;
    PIO_CLIENT_EXTENSION extension;
    PIO_CLIENT_EXTENSION nextExtension;

    PAGED_CODE();

    ASSERT( !driverObject->DeviceObject );

    //
    // Free any client driver object extensions.
    //

    extension = driverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        nextExtension = extension->NextExtension;
        ExFreePool( extension );
        extension = nextExtension;
    }

    //
    // If there is a driver section then unload the driver.
    //

    if (driverObject->DriverSection != NULL) {
        //
        // Make sure any DPC's that may be running inside the driver have completed
        //
        KeFlushQueuedDpcs ();

        MmUnloadSystemImage( driverObject->DriverSection );
    }

    //
    // Free the pool associated with the name of the driver.
    //

    if (driverObject->DriverName.Buffer) {
        ExFreePool( driverObject->DriverName.Buffer );
    }

    //
    // Free the pool associated with the service key name of the driver.
    //

    if (driverObject->DriverExtension->ServiceKeyName.Buffer) {
        ExFreePool( driverObject->DriverExtension->ServiceKeyName.Buffer );
    }

    //
    // Free the pool associated with the FsFilterCallbacks structure.
    //

    if (driverObject->DriverExtension->FsFilterCallbacks) {
        ExFreePool( driverObject->DriverExtension->FsFilterCallbacks );
    }
}

VOID
IopDeleteDevice(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the reference count for a device object
    becomes zero.  That is, the last reference for the device has gone away.
    This routine ensures that the object is cleaned up and the driver object
    is dereferenced.

Arguments:

    Object - Pointer to the driver object whose reference count has gone
        to zero.

Return value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject = (PDEVICE_OBJECT) Object;
    PVPB vpb = NULL;

    PAGED_CODE();

    IopDestroyDeviceNode(deviceObject->DeviceObjectExtension->DeviceNode);

    //
    // If there's still a VPB attached then free it.
    //

    vpb = InterlockedExchangePointer(&(deviceObject->Vpb), vpb);

    if(vpb != NULL) {

        ASSERTMSG("Unreferenced device object to be deleted is still in use",
                  ((vpb->Flags & (VPB_MOUNTED | VPB_LOCKED)) == 0));

        ASSERT(vpb->ReferenceCount == 0);
        ExFreePool(vpb);
    }
    if (deviceObject->DriverObject != NULL) {
        ObDereferenceObject( deviceObject->DriverObject );
    }
}


PDEVICE_OBJECT
IopGetDevicePDO(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Call this routine to obtain the Base PDO for a device object

Arguments:

    DeviceObject - pointer to device object to get PDO for

ReturnValue:

    PDO if DeviceObject is attached to a PDO, otherwise NULL
    The returned PDO is reference-counted

--*/
{
    PDEVICE_OBJECT deviceBaseObject;
    KIRQL irql;

    ASSERT(DeviceObject);

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    deviceBaseObject = IopGetDeviceAttachmentBase(DeviceObject);
    if ((deviceBaseObject->Flags & DO_BUS_ENUMERATED_DEVICE) != 0) {
        //
        // we have determined that this is attached to a PDO
        //
        ObReferenceObject( deviceBaseObject );

    } else {
        //
        // not a PDO
        //
        deviceBaseObject = NULL;
    }
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return deviceBaseObject;
}


NTSTATUS
IopSetDeviceSecurityDescriptor(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    )
/*++

Routine Description:

    This routine sets the security descriptor on a single device object

Arguments:

    DeviceObject - pointer to base device object

    SecurityInformation - Fields of SD to change
    SecurityDescriptor  - New security descriptor
    PoolType            - Pool type for alloctions
    GenericMapping      - Generic mapping for this object

ReturnValue:

    success, or error while setting the descriptor for the device object.

--*/
{

    PSECURITY_DESCRIPTOR OldDescriptor;
    PSECURITY_DESCRIPTOR NewDescriptor;
    PSECURITY_DESCRIPTOR CachedDescriptor;
    NTSTATUS Status;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    //
    // In order to preserve some protected fields in the SD (like the SACL) we need to make sure that only one
    // thread updates it at any one time. If we didn't do this another modification could wipe out a SACL
    // an administrator was adding.
    //
    CurrentThread = KeGetCurrentThread ();
    while (1) {

        //
        // Reference the security descriptor
        //

        KeEnterCriticalRegionThread(CurrentThread);
        ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

        OldDescriptor = DeviceObject->SecurityDescriptor;
        if (OldDescriptor != NULL) {
            ObReferenceSecurityDescriptor( OldDescriptor, 1 );
        }

        ExReleaseResourceLite( &IopSecurityResource );
        KeLeaveCriticalRegionThread(CurrentThread);

        NewDescriptor = OldDescriptor;

        Status = SeSetSecurityDescriptorInfo( NULL,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              &NewDescriptor,
                                              PoolType,
                                              GenericMapping );
        //
        //  If we successfully set the new security descriptor then we
        //  need to log it in our database and get yet another pointer
        //  to the finaly security descriptor
        //
        if ( NT_SUCCESS( Status )) {
            Status = ObLogSecurityDescriptor( NewDescriptor,
                                              &CachedDescriptor,
                                              1 );
            ExFreePool( NewDescriptor );
            if ( NT_SUCCESS( Status )) {
                //
                // Now we need to see if anyone else update this security descriptor inside the
                // gap where we didn't hold the lock. If they did then we just try it all again.
                //
                KeEnterCriticalRegionThread(CurrentThread);
                ExAcquireResourceExclusiveLite( &IopSecurityResource, TRUE );

                if (DeviceObject->SecurityDescriptor == OldDescriptor) {
                    //
                    // Do the swap
                    //
                    DeviceObject->SecurityDescriptor = CachedDescriptor;

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(CurrentThread);

                    //
                    // If there was an original object then we need to work out how many
                    // cached references there were (if any) and return them.
                    //
                    ObDereferenceSecurityDescriptor( OldDescriptor, 2 );
                    break;
                } else {

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(CurrentThread);

                    ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                    ObDereferenceSecurityDescriptor( CachedDescriptor, 1);
                }

            } else {

                //
                //  Dereference old SecurityDescriptor
                //

                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                break;
            }
        } else {

            //
            //  Dereference old SecurityDescriptor
            //
            if (OldDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
            }
            break;
        }
    }

    //
    //  And return to our caller
    //

    return( Status );
}


NTSTATUS
IopSetDeviceSecurityDescriptors(
    IN PDEVICE_OBJECT           OriginalDeviceObject,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    )
/*++

Routine Description:

    This routine sets the security descriptor on all the devices on the
    device stack for a PNP device. Ideally when the object manager asks the
    IO manager to set the security descriptor of a device object the IO manager
    should set the descriptor only on that device object. This is the classical
    behaviour.
    Unfortunately for PNP devices there may be multiple devices on a device
    stack with names.
    If the descriptor is applied to only one of the devices on the stack its
    opens up a security hole as there may be other devices with name on the
    stack which can be opened by a random program.
    To protect against this the descriptor is applied to all device objects on
    the stack.
    Its important that to protect compatibility we need to return the same
    status as what would have been returned if only the requested device
    object's descriptor was set.

Arguments:

    OriginalDeviceObject - Pointer to the device object passed by the object manager
    DeviceObject - pointer to base device object (first one to set)
    SecurityInformation )_ passed directly from IopGetSetSecurityObject
    SecurityDescriptor  )
    PoolType            )
    GenericMapping      )

ReturnValue:

    success, or error while setting the descriptor for the original device object.

--*/
{
    PDEVICE_OBJECT NewDeviceObject = NULL;
    NTSTATUS status;
    NTSTATUS returnStatus = STATUS_SUCCESS;

    ASSERT(DeviceObject);

    PAGED_CODE();

    //
    // pre-reference this object to match the dereference later
    //

    ObReferenceObject( DeviceObject );

    do {

        //
        // Reference the existing security descriptor so it can't be reused.
        // We will only do the final security change if nobody else changes
        // the security while we don't hold the lock. Doing this prevents
        // privileged information being lost like the SACL.
        //

        //
        // Save away and return the device status only for the main device object
        // For example if OldSecurityDescriptor is NULL the IO manager should
        // return STATUS_NO_SECURITY_ON_OBJECT.
        //

        status = IopSetDeviceSecurityDescriptor( DeviceObject,
                                                 SecurityInformation,
                                                 SecurityDescriptor,
                                                 PoolType,
                                                 GenericMapping );


        if (DeviceObject == OriginalDeviceObject) {
            returnStatus = status;
        }


        //
        // We don't need to acquire the database lock because
        // we have a handle to this device stack.
        //

        NewDeviceObject = DeviceObject->AttachedDevice;
        if ( NewDeviceObject != NULL ) {
            ObReferenceObject( NewDeviceObject );
        }

        ObDereferenceObject( DeviceObject );
        DeviceObject = NewDeviceObject;

    } while (NewDeviceObject);

    return returnStatus;
}


NTSTATUS
IopGetSetSecurityObject(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine is invoked to either query or set the security descriptor
    for a file, directory, volume, or device.  It implements these functions
    by either performing an in-line check if the file is a device or a
    volume, or an I/O Request Packet (IRP) is generated and given to the
    driver to perform the operation.

Arguments:

    Object - Pointer to the file or device object representing the open object.

    SecurityInformation - Information about what is being done to or obtained
        from the object's security descriptor.

    SecurityDescriptor - Supplies the base security descriptor and returns
        the final security descriptor.  Note that if this buffer is coming
        from user space, it has already been probed by the object manager
        to length "CapturedLength", otherwise it points to kernel space and
        should not be probed.  It must, however, be referenced in a try
        clause.

    CapturedLength - For a query operation this specifies the size, in
        bytes, of the output security descriptor buffer and on return
        contains the number of bytes needed to store the complete security
        descriptor.  If the length needed is greater than the length
        supplied the operation will fail.  This parameter is ignored for
        the set and delete operations.  It is expected to point into
        system space, ie, it need not be probed and it will not change.

    ObjectsSecurityDescriptor - Supplies and returns the object's security
        descriptor.

    PoolType - Specifies from which type of pool memory is to be allocated.

    GenericMapping - Supplies the generic mapping for the object type.

Return Value:

    The final status of the operation is returned as the function value.

--*/

{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT devicePDO = NULL;
    BOOLEAN synchronousIo;
    PSECURITY_DESCRIPTOR oldSecurityDescriptor, CachedSecurityDescriptor;
    PETHREAD CurrentThread;

    UNREFERENCED_PARAMETER( ObjectsSecurityDescriptor );
    UNREFERENCED_PARAMETER( PoolType );

    PAGED_CODE();


    //
    // Begin by determining whether the security operation is to be performed
    // in this routine or by the driver.  This is based upon whether the
    // object represents a device object, or it represents a file object
    // to a device, or a file on the device. If the open is a direct device
    // open then use the device object.
    //

    if (((PDEVICE_OBJECT) (Object))->Type == IO_TYPE_DEVICE) {
        deviceObject = (PDEVICE_OBJECT) Object;
        fileObject = (PFILE_OBJECT) NULL;
    } else {
        fileObject = (PFILE_OBJECT) Object;
        deviceObject = fileObject->DeviceObject;
    }

    if (!fileObject ||
        (!fileObject->FileName.Length && !fileObject->RelatedFileObject) ||
        (fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {

        //
        // This security operation is for the device itself, either through
        // a file object, or directly to the device object.  For the latter
        // case, assignment operations are also possible.  Also note that
        // this may be a stream file object, which do not have security.
        // The security for a stream file is actually represented by the
        // security descriptor on the file itself, or the volume, or the
        // device.
        //

        if (OperationCode == AssignSecurityDescriptor) {

            //
            // Simply assign the security descriptor to the device object,
            // if this is a device object.
            //

            status = STATUS_SUCCESS;

            if (fileObject == NULL || !(fileObject->Flags & FO_STREAM_FILE)) {

                status = ObLogSecurityDescriptor( SecurityDescriptor,
                                                  &CachedSecurityDescriptor,
                                                  1 );
                ExFreePool (SecurityDescriptor);
                if (NT_SUCCESS( status )) {

                    CurrentThread = PsGetCurrentThread ();
                    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
                    ExAcquireResourceExclusiveLite( &IopSecurityResource, TRUE );

                    deviceObject->SecurityDescriptor = CachedSecurityDescriptor;

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);
                }
            }

        } else if (OperationCode == SetSecurityDescriptor) {

            //
            // This is a set operation.  The SecurityInformation parameter
            // determines what part of the SecurityDescriptor is going to
            // be applied to the ObjectsSecurityDescriptor.
            //

            //
            // if this deviceObject is attached to a PDO then we want
            // to modify the security on the PDO and apply it up the
            // device chain. This applies to PNP device objects only. See
            // comment in IopSetDeviceSecurityDescriptors
            //
            devicePDO = IopGetDevicePDO(deviceObject);

            if (devicePDO) {

                //
                // set PDO and all attached device objects
                //

                status = IopSetDeviceSecurityDescriptors(
                                deviceObject,
                                devicePDO,
                                SecurityInformation,
                                SecurityDescriptor,
                                PoolType,
                                GenericMapping );

                ObDereferenceObject( devicePDO );

            } else {

                //
                // set this device object only
                //

                status = IopSetDeviceSecurityDescriptor( deviceObject,
                                                         SecurityInformation,
                                                         SecurityDescriptor,
                                                         PoolType,
                                                         GenericMapping );

            }

        } else if (OperationCode == QuerySecurityDescriptor) {

            //
            // This is a get operation.  The SecurityInformation parameter
            // determines what part of the SecurityDescriptor is going to
            // be returned from the ObjectsSecurityDescriptor.
            //

            CurrentThread = PsGetCurrentThread ();
            KeEnterCriticalRegionThread(&CurrentThread->Tcb);
            ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

            oldSecurityDescriptor = deviceObject->SecurityDescriptor;
            if (oldSecurityDescriptor != NULL) {
                ObReferenceSecurityDescriptor( oldSecurityDescriptor, 1 );
            }

            ExReleaseResourceLite( &IopSecurityResource );
            KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

            status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                                    SecurityDescriptor,
                                                    CapturedLength,
                                                    &oldSecurityDescriptor );

            if (oldSecurityDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( oldSecurityDescriptor, 1 );
            }

        } else {

            //
            // This is a delete operation.  Simply indicate that everything
            // worked just fine.
            //

            status = STATUS_SUCCESS;

        }

    } else if (OperationCode == DeleteSecurityDescriptor) {

        //
        // This is a delete operation for the security descriptor on a file
        // object.  This function will be performed by the file system once
        // the FCB itself is deleted.  Simply indicate that the operation
        // was successful.
        //

        status = STATUS_SUCCESS;

    } else {

        PIRP irp;
        IO_STATUS_BLOCK localIoStatus;
        KEVENT event;
        PIO_STACK_LOCATION irpSp;
        KPROCESSOR_MODE requestorMode;

        //
        // This file object does not refer to the device itself.  Rather, it
        // refers to either a file or a directory on the device.  This means
        // that the request must be passed to the file system for processing.
        // Note that the only requests that are passed through in this manner
        // are SET or QUERY security operations.  DELETE operations have
        // already been taken care of above since the file system which just
        // drop the storage on the floor when it really needs to, and ASSIGN
        // operations are irrelevant to file systems since they never
        // generate one because they never assign the security descriptor
        // to the object in the first place, they just assign it to the FCB.
        //

        CurrentThread = PsGetCurrentThread ();
        requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

        //
        // Begin by referencing the object by pointer.   Note that the object
        // handle has already been checked for the appropriate access by the
        // object system caller.  This reference must be performed because
        // standard I/O completion will dereference the object.
        //

        ObReferenceObject( fileObject );

        //
        // Make a special check here to determine whether this is a synchronous
        // I/O operation.  If it is, then wait here until the file is owned by
        // the current thread.  If this is not a (serialized) synchronous I/O
        // operation, then initialize the local event.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                status = IopAcquireFileObjectLock( fileObject,
                                                   requestorMode,
                                                   (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                                   &interrupted );
                if (interrupted) {
                    ObDereferenceObject( fileObject );
                    return status;
                }
            }
            synchronousIo = TRUE;
        } else {
            KeInitializeEvent( &event, SynchronizationEvent, FALSE );
            synchronousIo = FALSE;
        }

        //
        // Set the file object to the Not-Signaled state.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Get the address of the target device object.
        //

        deviceObject = IoGetRelatedDeviceObject( fileObject );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.  The allocation is performed with an exception handler
        // in case the caller does not have enough quota to allocate the packet.

        irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
        if (!irp) {

            //
            // An IRP could not be allocated.  Cleanup and return an
            // appropriate error status code.
            //

            IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = CurrentThread;
        irp->RequestorMode = requestorMode;

        //
        // Fill in the service independent parameters in the IRP.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            irp->UserEvent = (PKEVENT) NULL;
        } else {
            irp->UserEvent = &event;
            irp->Flags = IRP_SYNCHRONOUS_API;
        }
        irp->UserIosb = &localIoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Now determine whether this is a set or a query operation.
        //

        if (OperationCode == QuerySecurityDescriptor) {

            //
            // This is a query operation.  Fill in the appropriate fields in
            // the stack location for the packet, as well as the fixed part
            // of the packet.  Note that each of these parameters has been
            // captured as well, so there is no need to perform any probing.
            // The only exception is the UserBuffer memory may change, but
            // that is the file system's responsibility to check.  Note that
            // it has already been probed, so the pointer is at least not
            // in an address space that the caller should not be accessing
            // because of mode.
            //

            irpSp->MajorFunction = IRP_MJ_QUERY_SECURITY;
            irpSp->Parameters.QuerySecurity.SecurityInformation = *SecurityInformation;
            irpSp->Parameters.QuerySecurity.Length = *CapturedLength;
            irp->UserBuffer = SecurityDescriptor;

        } else {

            //
            // This is a set operation.  Fill in the appropriate fields in
            // the stack location for the packet.  Note that access to the
            // SecurityInformation parameter is safe, as the parameter was
            // captured by the caller.  Likewise, the SecurityDescriptor
            // refers to a captured copy of the descriptor.
            //

            irpSp->MajorFunction = IRP_MJ_SET_SECURITY;
            irpSp->Parameters.SetSecurity.SecurityInformation = *SecurityInformation;
            irpSp->Parameters.SetSecurity.SecurityDescriptor = SecurityDescriptor;

        }

        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Update the operation count statistic for the current process for
        // operations other than read and write.
        //

        IopUpdateOtherOperationCount();

        //
        // Everything has been properly set up, so simply invoke the driver.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If this operation was a synchronous I/O operation, check the return
        // status to determine whether or not to wait on the file object.  If
        // the file object is to be waited on, wait for the operation to be
        // completed and obtain the final status from the file object itself.
        //

        if (synchronousIo) {
            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &fileObject->Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
                status = fileObject->FinalStatus;
            }
            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait
            // for the local event and return the final status information
            // back to the caller.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
                status = localIoStatus.Status;
            }
        }

        //
        // If this operation was just attempted on a file system or a device
        // driver of some kind that does not implement security, then return
        // a normal null security descriptor.
        //

        if (status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            // The file system does not implement a security policy.  Determine
            // what type of operation this was and implement the correct
            // semantics for the file system.
            //

            if (OperationCode == QuerySecurityDescriptor) {

                //
                // The operation is a query.  If the caller's buffer is too
                // small, then indicate that this is the case and let him know
                // what size buffer is required.  Otherwise, attempt to return
                // a null security descriptor.
                //

               try {
                    status = SeAssignWorldSecurityDescriptor(
                                 SecurityDescriptor,
                                 CapturedLength,
                                 SecurityInformation
                                 );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // An exception was incurred while attempting to
                    // access the caller's buffer.  Clean everything
                    // up and return an appropriate status code.
                    //

                    status = GetExceptionCode();
                }

            } else {

                //
                // This was an operation other than a query.  Simply indicate
                // that the operation was successful.
                //

                status = STATUS_SUCCESS;
            }

        } else if (OperationCode == QuerySecurityDescriptor) {

            //
            // The final return status from the file system was something
            // other than invalid device request.  This means that the file
            // system actually implemented the query.  Copy the size of the
            // returned data, or the size of the buffer required in order
            // to query the security descriptor.  Note that once again the
            // assignment is performed inside of an exception handler in case
            // the caller's buffer is inaccessible.  Also note that in order
            // for the Information field of the I/O status block to be set,
            // the file system must return a warning status.  Return the
            // status that the caller expects if the buffer really is too
            // small.
            //

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            try {

                *CapturedLength = (ULONG) localIoStatus.Information;

            } except( EXCEPTION_EXECUTE_HANDLER ) {
                status = GetExceptionCode();
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\loadunld.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    loadunld.c

Abstract:

    This module contains the code to implement the NtLoadDriver and
    NtUnLoadDriver system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 5-Apr-1992

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtLoadDriver)
#pragma alloc_text(PAGE, NtUnloadDriver)
#pragma alloc_text(PAGE, IopUnloadDriver)
#endif

NTSTATUS
NtLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    )

/*++

Routine Description:

    This service dynamically loads a device or file system driver into
    the currently running system.  It requires that the caller have the
    appropriate privilege to execute this service.

Arguments:

    DriverServiceName - Specifies the name of the node in the registry
        associated with the driver to be loaded.

Return Value:

    The status returned is the final completion status of the load operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    UNICODE_STRING driverServiceName;
    PWCHAR nameBuffer = (PWCHAR) NULL;
    LOAD_PACKET loadPacket;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so check to ensure that
        // the caller has the privilege to load a driver and probe and
        // capture the name of the driver service entry.
        //

        if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, requestorMode )) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // The caller has the appropriate privilege to load and unload
        // drivers, so capture the driver service name string so that it
        // can be used to locate the driver from the registry node.
        //

        try {

            driverServiceName = ProbeAndReadUnicodeString( DriverServiceName );

            if (!driverServiceName.Length) {
                return STATUS_INVALID_PARAMETER;
            }

            ProbeForRead( driverServiceName.Buffer,
                          driverServiceName.Length,
                          sizeof( WCHAR ) );

            nameBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                  driverServiceName.Length );

            RtlCopyMemory( nameBuffer,
                           driverServiceName.Buffer,
                           driverServiceName.Length );

            driverServiceName.Buffer = nameBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to capture the
            // input name string or while attempting to allocate the name
            // string buffer.  Simply clean everything up and return an
            // appropriate error status code.
            //

            if (nameBuffer) {
                ExFreePool( nameBuffer );
            }
            return GetExceptionCode();
        }
    } else {
        driverServiceName = *DriverServiceName;
    }

    //
    // Because drivers may wish to create a system thread and execute in
    // its context, the remainder of this service must be executed in the
    // context of the primary system process.  This is accomplished by
    // queueing a request to one of the EX worker threads and having it
    // invoke the I/O system routine to complete this work.
    //
    // Fill in a request packet and queue it to the worker thread then, so
    // that it can actually do the load.
    //

    KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
    loadPacket.DriverObject = (PDRIVER_OBJECT) NULL;
    loadPacket.DriverServiceName = &driverServiceName;

    if (PsGetCurrentProcessByThread(CurrentThread) == PsInitialSystemProcess) {

        //
        // If we are already in the system process, just use this thread.
        //

        IopLoadUnloadDriver(&loadPacket);

    } else {

        ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                              IopLoadUnloadDriver,
                              &loadPacket );

        ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );

        KeWaitForSingleObject( &loadPacket.Event,
                               UserRequest,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );

    }

    //
    // The load operation is now complete.  If a name buffer was allocated,
    // deallocate it now, and return the final status of the load operation.
    //

    if (nameBuffer) {
         ExFreePool( nameBuffer );
    }

    return loadPacket.FinalStatus;
}

NTSTATUS
IopCheckUnloadDriver(
    IN PDRIVER_OBJECT driverObject,
    OUT PBOOLEAN unloadDriver
    )
{
    PDEVICE_OBJECT deviceObject;
    KIRQL irql;

    //
    // Check to see whether the driver has already been marked for an unload
    // operation by anyone in the past.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if ((driverObject->DeviceObject == NULL &&
        (driverObject->Flags & DRVO_UNLOAD_INVOKED)) ||
        (!(driverObject->Flags & DRVO_BASE_FILESYSTEM_DRIVER) && driverObject->DeviceObject &&
        driverObject->DeviceObject->DeviceObjectExtension->ExtensionFlags
        & DOE_UNLOAD_PENDING)) {

        //
        // The driver has already been marked for unload or is being
        // unloaded.  Simply return a successful completion status since
        // the driver is on its way out and therefore has been "marked for
        // unload".
        //

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

        ObDereferenceObject( driverObject );
        return STATUS_SUCCESS;
    }

    //
    // The driver exists, and it implements unload, and it has not, so far,
    // been marked for an unload operation.  Simply mark all of the devices
    // that the driver owns as being marked for unload.  While this is going
    // on, count the references for each of the devices.  If all of the
    // devices have a zero reference count, then tell the driver that it
    // should unload itself.
    //

    deviceObject = driverObject->DeviceObject;
    *unloadDriver = TRUE;

    while (deviceObject) {
        deviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_UNLOAD_PENDING;
        if (deviceObject->ReferenceCount || deviceObject->AttachedDevice) {
	    *unloadDriver = FALSE;
        }
        deviceObject = deviceObject->NextDevice;
    }

    //
    // If this is a base filesystem driver then delay the unload until all its device objects
    // are deleted.
    // 

    if (driverObject->Flags & DRVO_BASE_FILESYSTEM_DRIVER && driverObject->DeviceObject) {
	    *unloadDriver = FALSE;
    }

    if (*unloadDriver) {
        driverObject->Flags |= DRVO_UNLOAD_INVOKED;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
NtUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    )
{
    return (IopUnloadDriver(DriverServiceName, FALSE));
}

NTSTATUS
IopUnloadDriver(
    IN PUNICODE_STRING DriverServiceName,
    IN BOOLEAN InvokedByPnpMgr
    )
/*++

Routine Description:

    This service dynamically unloads a device or file system driver from
    the currently running system.  It requires that the caller have the
    appropriate privilege to execute this service.

Arguments:

    DriverServiceName - Specifies the name of the node in the registry
        associated with the driver to be unloaded.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    KPROCESSOR_MODE requestorMode;
    UNICODE_STRING driverServiceName;
    PWCHAR nameBuffer = (PWCHAR) NULL;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE keyHandle;
    UNICODE_STRING driverName;
    HANDLE driverHandle;
    PDRIVER_OBJECT driverObject;
    BOOLEAN unloadDriver;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if ((requestorMode != KernelMode) && (InvokedByPnpMgr == FALSE)) {

        //
        // The caller's access mode is not kernel so check to ensure that
        // the caller has the privilege to unload a driver and probe and
        // capture the name of the driver service entry.
        //

        if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, requestorMode )) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        //
        // The caller has the appropriate privilege to load and unload
        // drivers, so capture the driver service name string so that it
        // can be used to locate the driver from the registry node.
        //

        try {

            driverServiceName = ProbeAndReadUnicodeString( DriverServiceName );

            if (!driverServiceName.Length) {
                return STATUS_INVALID_PARAMETER;
            }

            ProbeForRead( driverServiceName.Buffer,
                          driverServiceName.Length,
                          sizeof( WCHAR ) );

            nameBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                  driverServiceName.Length );

            RtlCopyMemory( nameBuffer,
                           driverServiceName.Buffer,
                           driverServiceName.Length );

            driverServiceName.Buffer = nameBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to capture the
            // input name string or while attempting to allocate the name
            // string buffer.  Simply clean everything up and return an
            // appropriate error status code.
            //

            if (nameBuffer) {
                ExFreePool( nameBuffer );
            }
            return GetExceptionCode();
        }

        //
        // Now that the caller's parameters have been captured and everything
        // appears to have checked out, actually attempt to unload the driver.
        // This is done with a previous mode of kernel so that drivers will
        // not fail to unload because the caller didn't happen to have access
        // to some resource that the driver needs in order to complete its
        // unload operation.
        //

        status = ZwUnloadDriver( &driverServiceName );
        ExFreePool( nameBuffer );
        return status;
    }

    //
    // The caller's mode is now kernel mode.  Attempt to actually unload the
    // driver specified by the indicated registry node.  Begin by opening
    // the registry node for this driver.
    //

    status = IopOpenRegistryKey( &keyHandle,
                                 (HANDLE) NULL,
                                 DriverServiceName,
                                 KEY_READ,
                                 FALSE );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the optional object name for this driver from the value for this
    // key.  If one exists, then its name overrides the default name of the
    // driver.
    //

    status = IopGetDriverNameFromKeyNode( keyHandle,
                                          &driverName );
    ObCloseHandle( keyHandle, KernelMode );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Now attempt to open the driver object for the specified driver.
    //

    InitializeObjectAttributes( &objectAttributes,
                                &driverName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ObOpenObjectByName( &objectAttributes,
                                 IoDriverObjectType,
                                 KernelMode,
                                 NULL,
                                 FILE_READ_DATA,
                                 (PVOID) NULL,
                                 &driverHandle );

    //
    // Perform some common cleanup by getting rid of buffers that have been
    // allocated up to this point so that error conditions do not have as
    // much work to do on each exit path.
    //

    ExFreePool( driverName.Buffer );

    //
    // If the driver object could not be located in the first place, then
    // return now before attempting to do anything else.
    //

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // The driver object was located, so convert the handle into a pointer
    // so that the driver object itself can be examined.
    //

    status = ObReferenceObjectByHandle( driverHandle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &driverObject,
                                        NULL );
    ObCloseHandle( driverHandle , KernelMode);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Check to see whether or not this driver implements unload.  Also,
    // if the driver has no section associated with it, then it was loaded
    // be the OS loader and therefore cannot be unloaded.  If either is true,
    // return an appropriate error status code.
    //

    if (driverObject->DriverUnload == (PDRIVER_UNLOAD) NULL ||
        !driverObject->DriverSection) {
        ObDereferenceObject( driverObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (!InvokedByPnpMgr && !IopIsLegacyDriver(driverObject)) {

        ObDereferenceObject( driverObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Check to see whether the driver has already been marked for an unload
    // operation by anyone in the past.
    //

    status = IopCheckUnloadDriver(driverObject,&unloadDriver);

    if ( NT_SUCCESS(status) ) {
        return status;
    }

    if (unloadDriver) {

        if (PsGetCurrentProcess() == PsInitialSystemProcess) {

            //
            // The current thread is alrady executing in the context of the
            // system process, so simply invoke the driver's unload routine.
            //

            driverObject->DriverUnload( driverObject );

        } else {

            //
            // The current thread is not executing in the context of the system
            // process, which is required in order to invoke the driver's unload
            // routine.  Queue a worker item to one of the worker threads to
            // get into the appropriate process context and then invoke the
            // routine.
            //

            LOAD_PACKET loadPacket;

            KeInitializeEvent( &loadPacket.Event, NotificationEvent, FALSE );
            loadPacket.DriverObject = driverObject;
            ExInitializeWorkItem( &loadPacket.WorkQueueItem,
                                  IopLoadUnloadDriver,
                                  &loadPacket );
            ExQueueWorkItem( &loadPacket.WorkQueueItem, DelayedWorkQueue );
            (VOID) KeWaitForSingleObject( &loadPacket.Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }
        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    }

    //
    // The driver has either been unloaded, or it has successfully been
    // marked for an unload operation.  Simply dereference the pointer to
    // the object and return success.
    //

    ObDereferenceObject( driverObject );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\iosubs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iosubs.c

Abstract:

    This module contains the subroutines for the I/O system.

Author:

    Darryl E. Havens (darrylh) 16-Apr-1989

    Nar Ganapathy (narg) 1-Jan-1999

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

//
// This is the overall system device configuration record.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif
static CONFIGURATION_INFORMATION ConfigurationInformation = {
    0,                                 // DiskCount
    0,                                 // FloppyCount
    0,                                 // CdRomCount
    0,                                 // TapeCount
    0,                                 // ScsiPortCount
    0,                                 // SerialCount
    0,                                 // ParallelCount
    FALSE,                             // Primary ATDISK IO address claimed
    FALSE,                             // Secondary ATDISK IO address claimed
    sizeof(CONFIGURATION_INFORMATION), // Version
    0                                  // MediumChangerCount
};
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

//
// This value may be overridden by the registry.
//

LOGICAL IoCountOperations = TRUE;
LONG    IoPageReadIrpAllocationFailure;


#ifdef ALLOC_PRAGMA
NTSTATUS
IopDeleteSessionSymLinks(
    IN PUNICODE_STRING LinkName
    );
#pragma alloc_text(PAGE, IoAttachDevice)
#pragma alloc_text(PAGE, IoCancelThreadIo)
#pragma alloc_text(PAGE, IoCheckDesiredAccess)
#pragma alloc_text(PAGE, IoCheckEaBufferValidity)
#pragma alloc_text(PAGE, IoCheckFunctionAccess)
#pragma alloc_text(PAGE, IoCheckQuotaBufferValidity)
#pragma alloc_text(PAGE, IoCheckShareAccess)
#pragma alloc_text(PAGE, IoConnectInterrupt)
#pragma alloc_text(PAGE, IoCreateController)
#pragma alloc_text(PAGE, IoCreateDevice)
#pragma alloc_text(PAGE, IoCreateDriver)
#pragma alloc_text(PAGE, IoCreateFile)
#pragma alloc_text(PAGE, IopCreateFile)
#pragma alloc_text(PAGE, IoCreateNotificationEvent)
#pragma alloc_text(PAGE, IoCreateStreamFileObject)
#pragma alloc_text(PAGE, IoCreateStreamFileObjectEx)
#pragma alloc_text(PAGE, IoCreateStreamFileObjectLite)
#pragma alloc_text(PAGE, IoCreateSymbolicLink)
#pragma alloc_text(PAGE, IoCreateSynchronizationEvent)
#pragma alloc_text(PAGE, IoCreateUnprotectedSymbolicLink)
#pragma alloc_text(PAGE, IoDeleteController)
#pragma alloc_text(PAGE, IoDeleteDriver)
#pragma alloc_text(PAGE, IoDeleteSymbolicLink)
#pragma alloc_text(PAGE, IopDeleteSessionSymLinks)
#pragma alloc_text(PAGE, IoDisconnectInterrupt)
#pragma alloc_text(PAGE, IoEnqueueIrp)
#pragma alloc_text(PAGE, IoGetFileObjectGenericMapping)
#pragma alloc_text(PAGE, IoGetInitialStack)
#pragma alloc_text(PAGE, IoFastQueryNetworkAttributes)
#pragma alloc_text(PAGE, IoGetConfigurationInformation)
#pragma alloc_text(PAGE, IoGetDeviceObjectPointer)
#pragma alloc_text(PAGE, IoComputeDesiredAccessFileObject)
#pragma alloc_text(PAGE, IoInitializeTimer)
#pragma alloc_text(PAGE, IoIsValidNameGraftingBuffer)
#pragma alloc_text(PAGE, IopDoNameTransmogrify)
#pragma alloc_text(PAGE, IoQueryFileDosDeviceName)
#pragma alloc_text(PAGE, IoQueryFileInformation)
#pragma alloc_text(PAGE, IoQueryVolumeInformation)
#pragma alloc_text(PAGE, IoRegisterBootDriverReinitialization)
#pragma alloc_text(PAGE, IoRegisterDriverReinitialization)
#pragma alloc_text(PAGE, IoRegisterFileSystem)
#pragma alloc_text(PAGE, IoRegisterFsRegistrationChange)
#pragma alloc_text(PAGE, IoRegisterLastChanceShutdownNotification)
#pragma alloc_text(PAGE, IoRegisterShutdownNotification)
#pragma alloc_text(PAGE, IoRemoveShareAccess)
#pragma alloc_text(PAGE, IoSetInformation)
#pragma alloc_text(PAGE, IoSetShareAccess)
#pragma alloc_text(PAGE, IoSetSystemPartition)
#pragma alloc_text(PAGE, IoUnregisterFileSystem)
#pragma alloc_text(PAGE, IoUnregisterFsRegistrationChange)
#pragma alloc_text(PAGE, IoUpdateShareAccess)
#pragma alloc_text(PAGE, IoVerifyVolume)
#pragma alloc_text(PAGE, IoGetBootDiskInformation)
#pragma alloc_text(PAGE, IopCreateDefaultDeviceSecurityDescriptor)
#pragma alloc_text(PAGE, IopCreateVpb)
#pragma alloc_text(PAGE, IoCancelFileOpen)
#pragma alloc_text(PAGE, IopNotifyAlreadyRegisteredFileSystems)
#pragma alloc_text(PAGE, IoCreateFileSpecifyDeviceObjectHint)
#pragma alloc_text(PAGELK, IoShutdownSystem)
#pragma alloc_text(PAGELK, IoUnregisterShutdownNotification)
#pragma alloc_text(PAGE, IoCheckQuerySetFileInformation)
#pragma alloc_text(PAGE, IoCheckQuerySetVolumeInformation)
#endif

VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to acquire the cancel spin lock.  This spin lock
    must be acquired before setting the address of a cancel routine in an
    IRP.

Arguments:

    Irql - Address of a variable to receive the old IRQL.

Return Value:

    None.

--*/

{

    //
    // Simply acquire the cancel spin lock and return.
    //

    *Irql = KeAcquireQueuedSpinLock( LockQueueIoCancelLock );
}

VOID
IoAcquireVpbSpinLock(
    OUT PKIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to acquire the Volume Parameter Block (VPB) spin
    lock.  This spin lock must be acquired before accessing the mount flag,
    reference count, and device object fields of a VPB.

Arguments:

    Irql - Address of a variable to receive the old IRQL.

Return Value:

    None.

--*/

{

    //
    // Simply acquire the IopLoadFileSystemDriverVPB spin lock and return.
    //

    *Irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    return;
}


NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by calling HalAllocateAdapterChannel which does all of
    the work.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
#if !defined(NO_LEGACY_DRIVERS)
    PWAIT_CONTEXT_BLOCK wcb;

    wcb = &DeviceObject->Queue.Wcb;

    wcb->DeviceObject = DeviceObject;
    wcb->CurrentIrp = DeviceObject->CurrentIrp;
    wcb->DeviceContext = Context;

    return( HalAllocateAdapterChannel( AdapterObject,
                                       wcb,
                                       NumberOfMapRegisters,
                                       ExecutionRoutine ) );
#else
    return( (*((PDMA_ADAPTER)AdapterObject)->DmaOperations->
             AllocateAdapterChannel)( (PDMA_ADAPTER)AdapterObject,
                                      DeviceObject,
                                      NumberOfMapRegisters,
                                      ExecutionRoutine,
                                      Context) );

#endif // NO_LEGACY_DRIVERS
}


VOID
IoAllocateController(
    IN PCONTROLLER_OBJECT ControllerObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the controller specified by the controller object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the controller on the controller's queue.  If the queue is
    already "busy", then the controller has already been allocated, so the
    device object is simply placed onto the queue and waits until the controller
    becomes free.

    Once the controller becomes free (or if it already is), then the driver's
    execution routine is invoked.

Arguments:

    ControllerObject - Pointer to the controller object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the controller.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the controller has been allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    None.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    IO_ALLOCATION_ACTION action;

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the controller.
    //

    DeviceObject->Queue.Wcb.DeviceRoutine = ExecutionRoutine;
    DeviceObject->Queue.Wcb.DeviceContext = Context;

    //
    // Allocate the controller object for this particular device.  If the
    // controller cannot be allocated because it has already been allocated
    // to another device, then return to the caller now;  otherwise,
    // continue.
    //

    if (!KeInsertDeviceQueue( &ControllerObject->DeviceWaitQueue,
                              &DeviceObject->Queue.Wcb.WaitQueueEntry )) {

        //
        // The controller was not busy so it has been allocated.  Simply
        // invoke the driver's execution routine now.
        //

        action = ExecutionRoutine( DeviceObject,
                                   DeviceObject->CurrentIrp,
                                   0,
                                   Context );

        //
        // If the driver would like to have the controller deallocated,
        // then deallocate it now.
        //

        if (action == DeallocateObject) {
            IoFreeController( ControllerObject );
        }
    }
}

NTSTATUS
IoAllocateDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress,
    IN ULONG DriverObjectExtensionSize,
    OUT PVOID *DriverObjectExtension
    )

/*++

Routine Description:
    This routine allocates per driver storage for helper or class drivers
    which may support several different mini-drivers.  The storage is tagged
    with a client identification address which is used to retrieve a pointer
    to the storage.  The client id must be unique.

    The allocated storage is freed when the driver object is deleted.

Arguments:

    DriverObject - The driver object to which the extension is to be
        associated.

    ClientIdentificationAddress - Unique identifier used to retrieve the
        extension.

    DriverObjectExtensionSize - Specifies the size in bytes of the extension.

    DriverObjectExtension - Returns a pointer to the allocated extension.

Return Value:

    Returns the status of the operation.  Failure cases are
    STATUS_INSUFFICIENT_RESOURCES and STATUS_OBJECT_NAME_COLLISION.

--*/

{
    KIRQL irql;
    BOOLEAN inserted = FALSE;
    PIO_CLIENT_EXTENSION extension;
    PIO_CLIENT_EXTENSION newExtension;

    *DriverObjectExtension = NULL;

    newExtension = ExAllocatePoolWithTag( NonPagedPool,
                                          DriverObjectExtensionSize +
                                          sizeof( IO_CLIENT_EXTENSION ),
                                          'virD');

    if (newExtension == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory( newExtension,
                    DriverObjectExtensionSize +
                    sizeof( IO_CLIENT_EXTENSION )
                    );

    newExtension->ClientIdentificationAddress = ClientIdentificationAddress;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    extension = DriverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        if (extension->ClientIdentificationAddress == ClientIdentificationAddress) {
            break;
        }

        extension = extension->NextExtension;
    }

    if (extension == NULL) {

        //
        // The client id does not exist.  Insert the new extension in the
        // list.
        //

        newExtension->NextExtension =
            DriverObject->DriverExtension->ClientDriverExtension;
        DriverObject->DriverExtension->ClientDriverExtension = newExtension;
        inserted = TRUE;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    if (!inserted) {
        ExFreePool( newExtension );
        return(STATUS_OBJECT_NAME_COLLISION);
    }

    //
    // Return a pointer to the client's data area.
    //

    *DriverObjectExtension = newExtension + 1;
    return(STATUS_SUCCESS);
}

PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    )

/*++

Routine Description:

    This routine allocates and initializes an error log entry buffer and returns
    a pointer to the data entry portion of the buffer.

Arguments:

    IoObject - Pointer to driver's device object or driver object.

    EntrySize - Size of entry to be allocated, in bytes.  The maximum size is
        specified by ERROR_LOG_MAXIMUM_SIZE.

Return Value:

    Pointer to the body of the allocated error log entry, or NULL, if there are
    no free entries in the system.

Note:

    This routine assumes that the caller wants an error log entry within the
    bounds of the maximum size.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDRIVER_OBJECT driverObject;

    //
    // Make sure that a I/O object pointer was passed in.
    //

    if (IoObject == NULL) {
        return(NULL);
    }

    //
    // Assume for a moment this is a device object.
    //

    deviceObject = IoObject;

    //
    // Determine if this is a driver object or device object or if we
    // are allocating a generic error log entry.   This is determined
    // from the Type field of the object passed in.
    //

    if (deviceObject->Type == IO_TYPE_DEVICE) {

        driverObject = deviceObject->DriverObject;

    } else if (deviceObject->Type == IO_TYPE_DRIVER) {

        driverObject = (PDRIVER_OBJECT) IoObject;
        deviceObject = NULL;

    } else {

        return(NULL);

    }

    return (IopAllocateErrorLogEntry(
                deviceObject,
                driverObject,
                EntrySize));

}

PVOID
IoAllocateGenericErrorLogEntry(
    IN  UCHAR   EntrySize
    )

/*++

Routine Description:

    This routine allocates and initializes an error log entry buffer and returns
    a pointer to the data entry portion of the buffer. It's expected to be
    called from inside the kernel where there may not be a driver object
    or a device object.

Arguments:


    EntrySize - Size of entry to be allocated, in bytes.  The maximum size is
        specified by ERROR_LOG_MAXIMUM_SIZE.

Return Value:

    Pointer to the body of the allocated error log entry, or NULL, if there are
    no free entries in the system.

Note:

    This routine assumes that the caller wants an error log entry within the
    bounds of the maximum size.

--*/

{
    return(IopAllocateErrorLogEntry(NULL, NULL, EntrySize));
}

PVOID
IopAllocateErrorLogEntry(
    IN PDEVICE_OBJECT deviceObject,
    IN PDRIVER_OBJECT driverObject,
    IN UCHAR EntrySize
    )
{
    PERROR_LOG_ENTRY elEntry;
    PVOID returnValue;
    ULONG size;
    ULONG oldSize;

    //
    // Make sure the packet is large enough but not too large.
    //

    if (EntrySize < sizeof(IO_ERROR_LOG_PACKET) ||
        EntrySize > ERROR_LOG_MAXIMUM_SIZE) {

        return(NULL);
    }

    //
    // Round entry size to a PVOID size boundary.
    //

    EntrySize = (UCHAR) ((EntrySize + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1));

    //
    // Calculate the size of the entry needed.
    //

    size = sizeof(ERROR_LOG_ENTRY) + EntrySize;

    //
    // Make sure that there are not too many outstanding packets.
    //


    oldSize = InterlockedExchangeAdd(&IopErrorLogAllocation, size);

    if (oldSize > IOP_MAXIMUM_LOG_ALLOCATION) {

        //
        // Fail the request.
        //

        InterlockedExchangeAdd(&IopErrorLogAllocation, -(LONG)size);

        return(NULL);
    }

    //
    // Allocate the packet.
    //

    elEntry = ExAllocatePoolWithTag( NonPagedPool, size, 'rEoI' );

    if (elEntry == NULL) {

        //
        // Drop the allocation and return.
        //

        InterlockedExchangeAdd(&IopErrorLogAllocation, -(LONG)size);

        return(NULL);
    }

    //
    // Reference the device object and driver object. So they don't
    // go away before the name gets pulled out.
    //

    if (deviceObject != NULL) {

        ObReferenceObject( deviceObject );
    }

    if (driverObject != NULL) {

        ObReferenceObject( driverObject );
    }

    //
    // Initialize the fields.
    //

    RtlZeroMemory(elEntry, size);

    elEntry->Type = IO_TYPE_ERROR_LOG;
    elEntry->Size = (USHORT) size;
    elEntry->DeviceObject = deviceObject;
    elEntry->DriverObject = driverObject;

    returnValue = elEntry+1;


    return returnValue;
}

VOID
IoFreeErrorLogEntry(
    IN PVOID ElEntry
    )
/*++

Routine Description:

    This routine frees an entry allocated using IoAllocateErrorLogEntry. Its used to
    free an entry if its not used to actually write an errorlog entry.

Arguments:

    ElEntry - Pointer to the entry that was allocated by IoAllocateErrorLogEntry.

Return Value:

--*/
{
    PERROR_LOG_ENTRY entry;

    //
    // Get the address of the error log entry header,
    //

    entry = ((PERROR_LOG_ENTRY) ElEntry) - 1;

    //
    // Drop the reference counts.
    //

    if (entry->DeviceObject != NULL) {
        ObDereferenceObject (entry->DeviceObject);
    }

    if (entry->DriverObject != NULL) {
        ObDereferenceObject (entry->DriverObject);
    }

    InterlockedExchangeAdd( &IopErrorLogAllocation,
                           -((LONG) (entry->Size )));

    ExFreePool (entry);

    return;
}

PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    )
{
    return (pIoAllocateIrp(StackSize, ChargeQuota));
}


PIRP
IopAllocateIrpPrivate(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    )

/*++

Routine Description:

    This routine allocates an I/O Request Packet from the system nonpaged pool.
    The packet will be allocated to contain StackSize stack locations.  The IRP
    will also be initialized.

Arguments:

    StackSize - Specifies the maximum number of stack locations required.

    ChargeQuota - Specifies whether quota should be charged against thread.

Return Value:

    The function value is the address of the allocated/initialized IRP,
    or NULL if one could not be allocated.

--*/

{
    USHORT allocateSize;
    UCHAR fixedSize;
    PIRP irp;
    UCHAR lookasideAllocation;
    PGENERAL_LOOKASIDE lookasideList;
    PP_NPAGED_LOOKASIDE_NUMBER number;
    USHORT packetSize;
    PKPRCB prcb;
    CCHAR   largeIrpStackLocations;

    //
    // If the size of the packet required is less than or equal to those on
    // the lookaside lists, then attempt to allocate the packet from the
    // lookaside lists.
    //

    if (IopIrpProfileStackCountEnabled()) {
        IopProfileIrpStackCount(StackSize);
    }


    irp = NULL;

    fixedSize = 0;
    packetSize = IoSizeOfIrp(StackSize);
    allocateSize = packetSize;
    prcb = KeGetCurrentPrcb();

    //
    // Capture this value once as it can change and use it.
    //

    largeIrpStackLocations = (CCHAR)IopLargeIrpStackLocations;

    if ((StackSize <= (CCHAR)largeIrpStackLocations) &&
        ((ChargeQuota == FALSE) || (prcb->LookasideIrpFloat > 0))) {
        fixedSize = IRP_ALLOCATED_FIXED_SIZE;
        number = LookasideSmallIrpList;
        if (StackSize != 1) {
            allocateSize = IoSizeOfIrp((CCHAR)largeIrpStackLocations);
            number = LookasideLargeIrpList;
        }

        lookasideList = prcb->PPLookasideList[number].P;
        lookasideList->TotalAllocates += 1;
        irp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);

        if (irp == NULL) {
            lookasideList->AllocateMisses += 1;
            lookasideList = prcb->PPLookasideList[number].L;
            lookasideList->TotalAllocates += 1;
            irp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);
            if (irp == NULL) {
                lookasideList->AllocateMisses += 1;
            }
        }

        if (IopIrpAutoSizingEnabled() && irp) {

            //
            // See if this IRP is a stale entry. If so just free it.
            // This can happen if we decided to change the lookaside list size.
            // We need to get the size of the IRP from the information field as the size field
            // is overlayed with single list entry.
            //

            if (irp->IoStatus.Information < packetSize) {
                lookasideList->TotalFrees += 1;
                ExFreePool(irp);
                irp = NULL;

            } else {

                //
                // Update allocateSize to the correct value.
                //
                allocateSize = (USHORT)irp->IoStatus.Information;
            }
        }
    }


    //
    // If an IRP was not allocated from the lookaside list, then allocate
    // the packet from nonpaged pool and charge quota if requested.
    //

    lookasideAllocation = 0;
    if (!irp) {

        //
        // There are no free packets on the lookaside list, or the packet is
        // too large to be allocated from one of the lists, so it must be
        // allocated from nonpaged pool. If quota is to be charged, charge it
        // against the current process. Otherwise, allocate the pool normally.
        //

        if (ChargeQuota) {
            irp = ExAllocatePoolWithQuotaTag(NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                             allocateSize,' prI');

        } else {

            //
            // Attempt to allocate the pool from non-paged pool.  If this
            // fails, and the caller's previous mode was kernel then allocate
            // the pool as must succeed.
            //

            irp = ExAllocatePoolWithTag(NonPagedPool, allocateSize, ' prI');
        }

        if (!irp) {
            return NULL;
        }

    } else {
        if (ChargeQuota != FALSE) {
            lookasideAllocation = IRP_LOOKASIDE_ALLOCATION;
            InterlockedDecrement( &prcb->LookasideIrpFloat );
        }

        ChargeQuota = FALSE;
    }

    //
    // Initialize the packet.
    // Note that irp->Size may not be equal to IoSizeOfIrp(StackSize)
    //

    IopInitializeIrp(irp, allocateSize, StackSize);
    irp->AllocationFlags = (fixedSize | lookasideAllocation);
    if (ChargeQuota) {
        irp->AllocationFlags |= IRP_QUOTA_CHARGED;
    }

    return irp;
}

PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine allocates a Memory Descriptor List (MDL) large enough to map
    the buffer specified by the VirtualAddress and Length parameters.  If the
    routine is given a pointer to an Irp, then it will chain the MDL to the
    IRP in the appropriate way.

    If this routine is not given a pointer to an Irp it is up to the caller to
    set the MDL address in the IRP that the MDL is being allocated for.

    Note that the header information of the MDL will also be initialized.

Arguments:

    VirtualAddress - Starting virtual address of the buffer to be mapped.

    Length - Length, in bytes, of the buffer to be mapped.

    SecondaryBuffer - Indicates whether this is a chained buffer.

    ChargeQuota - Indicates whether quota should be charged if MDL allocated.

        N.B. This parameter is ignored.

    Irp - Optional pointer to IRP that MDL is being allocated for.

Return Value:

    A pointer to the allocated MDL, or NULL if one could not be allocated.
    Note that if no MDL could be allocated because there was not enough quota,
    then it is up to the caller to catch the raised exception.

--*/

{
    ULONG allocateSize;
    USHORT fixedSize;
    PMDL mdl;
    ULONG size;
    PMDL tmpMdlPtr;

    ASSERT(Length);

    UNREFERENCED_PARAMETER (ChargeQuota);

    //
    // If the requested length is greater than 2Gb, then we're not going
    // to be able to map the memory, so fail the request.
    //

    if (Length & 0x80000000) {
        return NULL;
    }


    //
    // Allocate an MDL from the lookaside list or pool as appropriate.
    //

    mdl = NULL;
    fixedSize = 0;
    size = ADDRESS_AND_SIZE_TO_SPAN_PAGES(VirtualAddress, Length);
    if (size > IOP_FIXED_SIZE_MDL_PFNS) {
        allocateSize = sizeof(MDL) + (sizeof(PFN_NUMBER) * size);
        if (allocateSize > MAXUSHORT) {
            return NULL;
        }

    } else {
        fixedSize = MDL_ALLOCATED_FIXED_SIZE;
        allocateSize =  sizeof(MDL) + (sizeof(PFN_NUMBER) * IOP_FIXED_SIZE_MDL_PFNS);
        mdl = (PMDL)ExAllocateFromPPLookasideList(LookasideMdlList);
    }

    if (!mdl) {
        mdl = ExAllocatePoolWithTag(NonPagedPool, allocateSize, ' ldM');
        if (!mdl) {
            return NULL;
        }
    }

    //
    // Now fill in the header of the MDL.
    //

    MmInitializeMdl(mdl, VirtualAddress, Length);
    mdl->MdlFlags |= (fixedSize);

    //
    // Finally, if an IRP was specified, store the address of the MDL
    // based on whether or not this is a secondary buffer.
    //

    if (Irp) {
        if (!SecondaryBuffer) {
            Irp->MdlAddress = mdl;

        } else {
            tmpMdlPtr = Irp->MdlAddress;
            while (tmpMdlPtr->Next != NULL) {
                tmpMdlPtr = tmpMdlPtr->Next;
            }

            tmpMdlPtr->Next = mdl;
        }
    }

    return mdl;
}

NTSTATUS
IoAsynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PIO_APC_ROUTINE ApcRoutine,
    IN PVOID ApcContext,
    IN IO_PAGING_PRIORITY Priority,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PIRP *Irp OPTIONAL
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Modified Page Writer
    (MPW) to write pages to the disk quickly and with very little overhead.  All
    of the special handling for this request is recognized by setting the
    IRP_PAGING_IO flag in the IRP flags word.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the write should be performed on.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be written to the disk.  All of the pages have been locked
        in memory.  The MDL also describes the length of the write operation.

    StartingOffset - Pointer to the offset in the file from which the write
        should take place.

    ApcRoutine - The address of a kernel APC routine which should be executed
        after the write operation has completed.

    ApcContext - A context parameter which should be supplied to the kernel APC
        routine when it executes.

    Priority  - Priority that should be given to this request by the storage stack

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

    Irp - If specified, allows the caller to squirrel away a pointer to the Irp.

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.


--*/

{
    PIRP irp;
    KIRQL irql;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;

    //
    // Increment performance counters
    //

    if (CcIsFileCached(FileObject)) {
        CcDataFlushes += 1;
        CcDataPages += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this out-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  If specified, let the caller know what Irp is responsible for this
    //  transfer.  While this is mainly for debugging purposes, it is
    //  absolutely essential to debug certain types of problems, and is
    //  very cheap, thus is included in the FREE build as well.
    //

    if (ARGUMENT_PRESENT(Irp)) {
        *Irp = irp;
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    irp->MdlAddress = MemoryDescriptorList;
    irp->Flags = IRP_PAGING_IO | IRP_NOCACHE;

    if ( Priority == IoPagingPriorityHigh ) {
        irp->Flags |= IRP_HIGH_PRIORITY_PAGING_IO;
    }

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Fill in the normal write parameters.
    //

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->Parameters.Write.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Write.ByteOffset = *StartingOffset;
    irpSp->FileObject = FileObject;


    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    status = IoCallDriver( deviceObject, irp );

    if (NT_ERROR( status )) {
        IoStatusBlock->Status = status;
        IoStatusBlock->Information = 0;
        KeRaiseIrql( APC_LEVEL, &irql );
        ApcRoutine( ApcContext, IoStatusBlock, 0 );
        KeLowerIrql( irql );
        status = STATUS_PENDING;
    }

    return status;
}


NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    )

/*++

Routine Description:

    This routine "attaches" a device to another device.  That is, it associates
    the source device to a target device which enables the I/O system to ensure
    that the target device a) exists, and b) cannot be unloaded until the source
    device has detached.  Also, requests bound for the target device are given
    to the source device first, where applicable.

Arguments:

    SourceDevice - Pointer to device object to be attached to the target.

    TargetDevice - Supplies the name of the target device to which the attach
        is to occur.

    AttachedDevice - Returns a pointer to the device to which the attach
        occurred.  This is the device object that the source driver should
        use to communicate with the target driver.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT targetDevice;
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();

    //
    // Attempt to open the target device for attach access.  This ensures that
    // the device itself will be opened, with all of the special considerations
    // thereof.
    //

    InitializeObjectAttributes( &objectAttributes,
                                TargetDevice,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenFile( &fileHandle,
                         FILE_READ_ATTRIBUTES,
                         &objectAttributes,
                         &ioStatus,
                         0,
                         FILE_NON_DIRECTORY_FILE | IO_ATTACH_DEVICE_API );

    if (NT_SUCCESS( status )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );
        if (NT_SUCCESS( status )) {

            //
            // Get a pointer to the device object for this file, and close
            // the handle.
            //

            targetDevice = IoGetRelatedDeviceObject( fileObject );
            (VOID) ZwClose( fileHandle );

        } else {

            return status;
        }

    } else {

        return status;

    }

    //
    // Set the attached device pointer so that the driver being attached to
    // cannot unload until the detach occurs, and so that attempts to open the
    // device object go through the attached driver.  Note that the reference
    // count is not incremented since exclusive drivers can only be opened once
    // and this would count as an open.  At that point, both device objects
    // would become useless.
    //

    status = IoAttachDeviceToDeviceStackSafe( SourceDevice, targetDevice, AttachedDevice );

    //
    // Finally, dereference the file object.  This decrements the reference
    // count for the target device so that when the detach occurs the device
    // can go away if necessary.
    //

    ObDereferenceObject( fileObject );

    //
    // Return the final status of the operation.
    //

    return status;
}

NTSTATUS
IoAttachDeviceByPointer(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine attaches the source device object to the target device
    object.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to take place.

Return Value:

    The function value is the final status of the attach operation.

Note:

    THIS FUNCTION IS OBSOLETE!!! see IoAttachDeviceToDeviceStack

--*/

{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the TargetDevice.
    //

    deviceObject = IoAttachDeviceToDeviceStack( SourceDevice, TargetDevice );
    if( deviceObject == NULL ){
        status = STATUS_NO_SUCH_DEVICE;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )
/*++

Routine Description:

    This routine attaches the source device object to the target device
    object and returns a pointer to the actual device attached to, if
    successful.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to occur.

Return Value:

    If successful, this function returns a pointer to the device object to
    which the attachment actually occurred.

    If unsuccessful, this function returns NULL.  (This could happen if the
    device currently at the top of the attachment chain is being unloaded,
    deleted or initialized.)

--*/
{

    return (IopAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, NULL));

}

NTSTATUS
IoAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    )
/*++

Routine Description:

    This routine attaches the source device object to the target device
    object.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to occur.

    AttachedToDeviceObject - Specifies a pointer  where the attached to device object
        is stored. Its updated while holding the database lock so that when a filter gets an IRP
        its attached to device object field is updated correctly.

Return Value:

    None.

--*/
{

    if (IopAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, AttachedToDeviceObject) == NULL)
        return STATUS_NO_SUCH_DEVICE;
    else
        return STATUS_SUCCESS;
}

PDEVICE_OBJECT
IopAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject OPTIONAL
    )

/*++

Routine Description:

    This routine attaches the source device object to the target device
    object and returns a pointer to the actual device attached to, if
    successful.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to occur.

    AttachedToDeviceObject - Specifies a pointer  where the attached to device object
        is stored. Its updated while holding the database lock so that when a filter gets an IRP
        its attached to device object field is updated correctly.

Return Value:

    If successful, this function returns a pointer to the device object to
    which the attachment actually occurred.

    If unsuccessful, this function returns NULL.  (This could happen if the
    device currently at the top of the attachment chain is being unloaded,
    deleted or initialized.)

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDEVOBJ_EXTENSION sourceExtension;
    KIRQL irql;

    //
    // Retrieve a pointer to the source device object's extension outside
    // of the IopDatabaseLock, since it isn't protected by that.
    //

    sourceExtension = SourceDevice->DeviceObjectExtension;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the TargetDevice, and attach to it.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Tell the Special IRP code the stack has changed. Code that will reexamine
    // the stack takes the database lock, so we can place the call here. This
    // also allows us to assert correct behavoir *before* the stack is built up.
    //

    IOV_ATTACH_DEVICE_TO_DEVICE_STACK(SourceDevice, TargetDevice);

    deviceObject = IoGetAttachedDevice( TargetDevice );

    //
    // Make sure that the SourceDevice object isn't already attached to
    // something else, this is now illegal.
    //

    ASSERT( sourceExtension->AttachedTo == NULL );

    //
    // Now attach to the device, provided that it is not being unloaded,
    // deleted or initializing.
    //

    if (deviceObject->Flags & DO_DEVICE_INITIALIZING ||
        deviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED)) {

        //
        // The device currently at the top of the attachment chain is being
        // unloaded, deleted or initialized.
        //

        deviceObject = (PDEVICE_OBJECT) NULL;

    } else {

        //
        // Perform the attachment.  First update the device previously at the
        // top of the attachment chain.
        //
        deviceObject->AttachedDevice = SourceDevice;
        deviceObject->Spare1++;

        //
        // Now update the new top-of-attachment-chain.
        //

        SourceDevice->StackSize = (UCHAR) (deviceObject->StackSize + 1);
        SourceDevice->AlignmentRequirement = deviceObject->AlignmentRequirement;
        SourceDevice->SectorSize = deviceObject->SectorSize;

        if (deviceObject->DeviceObjectExtension->ExtensionFlags & DOE_START_PENDING)  {
            SourceDevice->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;
        }

        //
        // Attachment chain is doubly-linked.
        //

        sourceExtension->AttachedTo = deviceObject;
    }

    //
    // Atomically update this field inside the lock.
    // The caller has to ensure that this location is in non-paged pool.
    // This is required so that a filesystem filter can attach to a device and before it
    // gets an IRP it can update its lower device object pointer.
    //

    if (AttachedToDeviceObject) {
        *AttachedToDeviceObject = deviceObject;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return deviceObject;
}

PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN
        IRP_MJ_POWER

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    IoStatusBlock - Pointer to the I/O status block for completion status
        information.  This parameter is optional since most asynchronous FSD
        requests will be synchronized by using completion routines, and so the
        I/O status block will not be written.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {
        return irp;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code.
    //

    irpSp->MajorFunction = (UCHAR) MajorFunction;

    if (MajorFunction != IRP_MJ_FLUSH_BUFFERS &&
        MajorFunction != IRP_MJ_SHUTDOWN &&
        MajorFunction != IRP_MJ_PNP &&
        MajorFunction != IRP_MJ_POWER) {

        //
        // Now allocate a buffer or lock the pages of the caller's buffer into
        // memory based on whether the target device performs direct or buffered
        // I/O operations.
        //

        if (DeviceObject->Flags & DO_BUFFERED_IO) {

            //
            // The target device supports buffered I/O operations.  Allocate a
            // system buffer and, if this is a write, fill it in.  Otherwise,
            // the copy will be done into the caller's buffer in the completion
            // code.  Also note that the system buffer should be deallocated on
            // completion.  Also, set the parameters based on whether this is a
            // read or a write operation.
            //

            irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     Length,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            if (MajorFunction == IRP_MJ_WRITE) {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, Buffer, Length );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
                irp->UserBuffer = Buffer;
            }

        } else if (DeviceObject->Flags & DO_DIRECT_IO) {

            //
            // The target device supports direct I/O operations.  Allocate
            // an MDL large enough to map the buffer and lock the pages into
            // memory.
            //

            irp->MdlAddress = IoAllocateMdl( Buffer,
                                             Length,
                                             FALSE,
                                             FALSE,
                                             NULL );

            if (irp->MdlAddress == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            try {
                MmProbeAndLockPages( irp->MdlAddress,
                                     KernelMode,
                                     (LOCK_OPERATION) (MajorFunction == IRP_MJ_READ ? IoWriteAccess : IoReadAccess) );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                  if (irp->MdlAddress != NULL) {
                      IoFreeMdl( irp->MdlAddress );
                  }
                  IoFreeIrp( irp );
                  return (PIRP) NULL;
            }

        } else {

            //
            // The operation is neither buffered nor direct.  Simply pass the
            // address of the buffer in the packet to the driver.
            //

            irp->UserBuffer = Buffer;
        }

        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            irpSp->Parameters.Write.Length = Length;
            irpSp->Parameters.Write.ByteOffset = *StartingOffset;
        } else {
            irpSp->Parameters.Read.Length = Length;
            irpSp->Parameters.Read.ByteOffset = *StartingOffset;
        }
    }

    //
    // Finally, set the address of the I/O status block and return a pointer
    // to the IRP.
    //

    irp->UserIosb = IoStatusBlock;
    return irp;
}

PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) that can be used to
    perform a synchronous internal or normal device I/O control function.

Arguments:

    IoControlCode - Specifies the device I/O control code that is to be
        performed by the target device driver.

    DeviceObject - Specifies the target device on which the I/O control
        function is to be performed.

    InputBuffer - Optional pointer to an input buffer that is to be passed
        to the device driver.

    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-
        Buffer parameter is not passed, this parameter must be zero.

    OutputBuffer - Optional pointer to an output buffer that is to be passed
        to the device driver.

    OutputBufferLength - Length of the OutputBuffer in bytes.  If the
        OutputBuffer parameter is not passed, this parameter must be zero.

    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether
        the packet that gets generated should have a major function code
        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or
        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).

    Event - Supplies a pointer to a kernel event that is to be set to the
        Signaled state when the I/O operation is complete.  Note that the
        Event must already be set to the Not-Signaled state.

    IoStatusBlock - Supplies a pointer to an I/O status block that is to
        be filled in with the final status of the operation once it
        completes.

Return Value:

    The function value is a pointer to the generated IRP suitable for calling
    the target device driver.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG method;

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {
        return irp;
    }

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code based on the type of device I/O control
    // function the caller has specified.
    //

    if (InternalDeviceIoControl) {
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    } else {
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all four methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Get the method bits from the I/O control code to determine how the
    // buffers are to be passed to the driver.
    //

    method = IoControlCode & 3;

    //
    // Based on the method that the buffers are being passed, either allocate
    // buffers or build MDLs or do nothing.
    //

    switch ( method ) {

    case METHOD_BUFFERED:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer
        // to the allocated buffer and set the appropriate IRP fields.
        //

        if (InputBufferLength != 0 || OutputBufferLength != 0) {
            irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     InputBufferLength > OutputBufferLength ? InputBufferLength : OutputBufferLength,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            if (ARGUMENT_PRESENT( InputBuffer )) {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
            }
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            irp->UserBuffer = OutputBuffer;
            if (ARGUMENT_PRESENT( OutputBuffer )) {
                irp->Flags |= IRP_INPUT_OPERATION;
            }
        } else {
            irp->Flags = 0;
            irp->UserBuffer = (PVOID) NULL;
        }

        break;

    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that an output buffer must have been specified.
        //

        if (ARGUMENT_PRESENT( InputBuffer )) {
            irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     InputBufferLength,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                           InputBuffer,
                           InputBufferLength );
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        } else {
            irp->Flags = 0;
        }

        if (ARGUMENT_PRESENT( OutputBuffer )) {
            irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                             OutputBufferLength,
                                             FALSE,
                                             FALSE,
                                             NULL );
            if (irp->MdlAddress == NULL) {
                if (ARGUMENT_PRESENT( InputBuffer )) {
                    ExFreePool( irp->AssociatedIrp.SystemBuffer );
                }
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            try {

                MmProbeAndLockPages( irp->MdlAddress,
                                     KernelMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                  if (irp->MdlAddress != NULL) {
                      IoFreeMdl( irp->MdlAddress );
                  }

                  if (ARGUMENT_PRESENT( InputBuffer )) {
                      ExFreePool( irp->AssociatedIrp.SystemBuffer );
                  }

                  IoFreeIrp( irp );
                  return (PIRP) NULL;
            }
        }

        break;

    case METHOD_NEITHER:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

    //
    // Finally, set the address of the I/O status block and the address of
    // the kernel event object.  Note that I/O completion will not attempt
    // to dereference the event since there is no file object associated
    // with this operation.
    //

    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;

    //
    // Also set the address of the current thread in the packet so the
    // completion code will have a context to execute in.  The IRP also
    // needs to be queued to the thread since the caller is going to set
    // the file object pointer.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IopQueueThreadIrp( irp );

    //
    // Simply return a pointer to the packet.
    //

    return irp;
}

VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine maps a portion of a buffer as described by an MDL.  The
    portion of the buffer to be mapped is specified via a virtual address
    and an optional length.  If the length is not supplied, then the
    remainder of the buffer is mapped.

Arguments:

    SourceMdl - MDL for the current buffer.

    TargetMdl - MDL to map the specified portion of the buffer.

    VirtualAddress - Base of the buffer to begin mapping.

    Length - Length of buffer to be mapped;  if zero, remainder.

Return Value:

    None.

Notes:

    This routine assumes that the target MDL is large enough to map the
    desired portion of the buffer.  If the target is not large enough
    then an exception will be raised.

    It is also assumed that the remaining length of the buffer to be mapped
    is non-zero.

--*/

{
    ULONG_PTR baseVa;
    ULONG offset;
    ULONG newLength;
    ULONG pageOffset;
    PPFN_NUMBER basePointer;
    PPFN_NUMBER copyPointer;

    //
    // Calculate the base address of the buffer that the source Mdl maps.
    // Then, determine the length of the buffer to be mapped, if not
    // specified.
    //

    baseVa = (ULONG_PTR) MmGetMdlBaseVa( SourceMdl );
    offset = (ULONG) ((ULONG_PTR)VirtualAddress - baseVa) - MmGetMdlByteOffset(SourceMdl);

    if (Length == 0) {
        newLength = MmGetMdlByteCount( SourceMdl ) - offset;
    } else {
        newLength = Length;
        //if (newLength > (MmGetMdlByteCount(SourceMdl) - offset)) {
        //    KeBugCheck( TARGET_MDL_TOO_SMALL );
        //}
    }

    //
    // Initialize the target MDL header.  Note that the original size of
    // the MDL structure itself is left unchanged.
    //

    //ASSERT ((SourceMdl->MdlFlags & MDL_PARTIAL) == 0);
    TargetMdl->Process = SourceMdl->Process;

    TargetMdl->StartVa = (PVOID) PAGE_ALIGN( VirtualAddress );
    pageOffset = ((ULONG)((ULONG_PTR) TargetMdl->StartVa - (ULONG_PTR) SourceMdl->StartVa)) >> PAGE_SHIFT;


    TargetMdl->ByteCount = newLength;
    TargetMdl->ByteOffset = BYTE_OFFSET( VirtualAddress );
    newLength = ADDRESS_AND_SIZE_TO_SPAN_PAGES( VirtualAddress, newLength );
    if (((TargetMdl->Size - sizeof( MDL )) / sizeof (PFN_NUMBER)) < newLength ) {
        KeBugCheck( TARGET_MDL_TOO_SMALL );
    }

    //
    // Set the MdlFlags in the target MDL.  Clear all flags but
    // carry across the allocation information, page read and the
    // system mapped info.
    //

    TargetMdl->MdlFlags &= (MDL_ALLOCATED_FIXED_SIZE | MDL_ALLOCATED_MUST_SUCCEED);
    TargetMdl->MdlFlags |= SourceMdl->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL |
                                                  MDL_MAPPED_TO_SYSTEM_VA |
                                                  MDL_IO_PAGE_READ);
    TargetMdl->MdlFlags |= MDL_PARTIAL;

#if DBG
    if (TargetMdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) {
        TargetMdl->MdlFlags |= MDL_PARENT_MAPPED_SYSTEM_VA;
    }
#endif //DBG

    //
    // Preserved the mapped system address.
    //

    TargetMdl->MappedSystemVa = (PUCHAR)SourceMdl->MappedSystemVa + offset;

    //
    // Determine the base address of the first PFN in the source MDL that
    // needs to be copied to the target.  Then, copy as many PFNs as are
    // needed.
    //

    basePointer = MmGetMdlPfnArray(SourceMdl);
    basePointer += pageOffset;
    copyPointer = MmGetMdlPfnArray(TargetMdl);

    while (newLength > 0) {
        *copyPointer = *basePointer;
        copyPointer++;
        basePointer++;
        newLength--;
    }
}

PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

    The IRP created by this function causes the I/O system to complete the
    request by setting the specified event to the Signaled state.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    Event - Pointer to a kernel event structure for synchronization.  The event
        will be set to the Signaled state when the I/O has completed.

    IoStatusBlock - Pointer to I/O status block for completion status info.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;

    //
    // Do all of the real work in real IRP build routine.
    //

    irp = IoBuildAsynchronousFsdRequest( MajorFunction,
                                         DeviceObject,
                                         Buffer,
                                         Length,
                                         StartingOffset,
                                         IoStatusBlock );
    if (irp == NULL) {
        return irp;
    }

    //
    // Now fill in the event to the completion code will do the right thing.
    // Notice that because there is no FileObject, the I/O completion code
    // will not attempt to dereference the event.
    //

    irp->UserEvent = Event;

    //
    // There will be a file object associated w/this packet, so it must be
    // queued to the thread.
    //

    IopQueueThreadIrp( irp );
    return irp;
}


NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    if (pIofCallDriver != NULL) {

        //
        // This routine will either jump immediately to IovCallDriver or
        // IoPerfCallDriver.
        //
        return pIofCallDriver(DeviceObject, Irp, _ReturnAddress());
    }

    return IopfCallDriver(DeviceObject, Irp);
}

NTSTATUS
FASTCALL
IofCallDriverSpecifyReturn(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress   OPTIONAL
    )
{
    if (pIofCallDriver != NULL) {

        //
        // This routine will either jump immediately to IovCallDriver or
        // IoPerfCallDriver.
        //
        return pIofCallDriver(DeviceObject, Irp, ReturnAddress);
    }

    return IopfCallDriver(DeviceObject, Irp);
}


BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to cancel an individual I/O Request Packet.
    It acquires the cancel spin lock, sets the cancel flag in the IRP, and
    then invokes the cancel routine specified by the appropriate field in
    the IRP, if a routine was specified.  It is expected that the cancel
    routine will relaease the cancel spinlock.  If there is no cancel routine,
    then the cancel spin lock is released.

Arguments:

    Irp - Supplies a pointer to the IRP to be cancelled.

Return Value:

    The function value is TRUE if the IRP was in a cancelable state (it
    had a cancel routine), else FALSE is returned.

Notes:

    It is assumed that the caller has taken the necessary action to ensure
    that the packet cannot be fully completed before invoking this routine.

--*/

{
    PDRIVER_CANCEL cancelRoutine;
    KIRQL irql;
    BOOLEAN returnValue;


    ASSERT( Irp->Type == IO_TYPE_IRP );

    if (IopVerifierOn) {
        if (IOV_CANCEL_IRP(Irp, &returnValue)) {
            return returnValue;
        }
    }

    //
    // Acquire the cancel spin lock.
    //

    IoAcquireCancelSpinLock( &irql );

    //
    // Set the cancel flag in the IRP.
    //

    Irp->Cancel = TRUE;

    //
    // Obtain the address of the cancel routine, and if one was specified,
    // invoke it.
    //

    cancelRoutine = (PDRIVER_CANCEL) (ULONG_PTR) InterlockedExchangePointer( (PVOID *) &Irp->CancelRoutine,
                                                                 NULL );

    if (cancelRoutine) {
        if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1)) {
            KeBugCheckEx( CANCEL_STATE_IN_COMPLETED_IRP, (ULONG_PTR) Irp, (ULONG_PTR) cancelRoutine, 0, 0 );
        }
        Irp->CancelIrql = irql;

        cancelRoutine( Irp->Tail.Overlay.CurrentStackLocation->DeviceObject,
                       Irp );
        //
        // The cancel spinlock should have been released by the cancel routine.
        //

        return(TRUE);

    } else {

        //
        // There was no cancel routine, so release the cancel spinlock and
        // return indicating the Irp was not currently cancelable.
        //

        IoReleaseCancelSpinLock( irql );

        return(FALSE);
    }
}



VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine cancels all of the I/O operations for the specified thread.
    This is accomplished by walking the list of IRPs in the thread IRP list
    and canceling each one individually.  No other I/O operations can be
    started for the thread since this routine has control of the thread itself.

Arguments:

    Tcb - Pointer to the Thread Control Block for the thread.

Return Value:

    None.

--*/

{
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;
    PETHREAD thread;
    PIRP irp;
    ULONG count;
    LARGE_INTEGER interval;

    PAGED_CODE();

    DBG_UNREFERENCED_PARAMETER( Thread );

    thread = PsGetCurrentThread();

    header = &thread->IrpList;

    if ( IsListEmpty( header )) {
        return;
    }

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    entry = header->Flink;

    //
    // Walk the list of pending IRPs, canceling each of them.
    //

    while (header != entry) {
        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        IoCancelIrp( irp );
        entry = entry->Flink;
    }

    //
    // Wait for the requests to complete.  Note that waiting may eventually
    // timeout, in which case more work must be done.
    //

    count = 0;
    interval.QuadPart = -10 * 1000 * 100;

    while (!IsListEmpty( header )) {

        //
        // Lower the IRQL so that the thread APC can fire which will complete
        // the requests.  Delay execution for a time and let the request
        // finish.  The delay time is 100ms.
        //

        KeLowerIrql( irql );
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        if (count++ > 3000) {

            //
            // This I/O request has timed out, as it has not been completed
            // for a full 5 minutes. Attempt to remove the packet's association
            // with this thread.  Note that by not resetting the count, the
            // next time through the loop the next packet, if there is one,
            // which has also timed out, will be dealt with, although it
            // will be given another 100ms to complete.
            //

            IopDisassociateThreadIrp();
        }

        KeRaiseIrql( APC_LEVEL, &irql );
    }

    KeLowerIrql( irql );
}

NTSTATUS
IoCheckDesiredAccess(
    IN OUT PACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not the granted access
    to a file allows the access specified by a desired access.

Arguments:

    DesiredAccess - Pointer to a variable containing the access desired to
        the file.

    GrantedAccess - Access currently granted to the file.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has the access to the file, then STATUS_SUCCESS is returned;
    otherwise, STATUS_ACCESS_DENIED is returned.

    Also, the DesiredAccess is returned with no generic mapping.

--*/

{
    PAGED_CODE();

    //
    // Convert the desired access to a non-generic access mask.
    //

    RtlMapGenericMask( DesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    //
    // Determine whether the desired access to the file is allowed, given
    // the current granted access.
    //

    if (!SeComputeDeniedAccesses( GrantedAccess, *DesiredAccess )) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_ACCESS_DENIED;
    }
}

NTSTATUS
IoCheckEaBufferValidity(
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    OUT PULONG ErrorOffset
    )

/*++

Routine Description:

    This routine checks the validity of the specified EA buffer to guarantee
    that its format is proper, no fields hang over, that it is not recursive,
    etc.

Arguments:

    EaBuffer - Pointer to the buffer containing the EAs to be checked.

    EaLength - Specifies the length of EaBuffer.

    ErrorOffset - A variable to receive the offset of the offending entry
        in the EA buffer if an error is incurred.  This variable is only
        valid if an error occurs.

Return Value:

    The function value is STATUS_SUCCESS if the EA buffer contains a valid,
    properly formed list, otherwise STATUS_EA_LIST_INCONSISTENT.

--*/

#define ALIGN_LONG( Address ) ( (ULONG) ((Address + 3) & ~3) )

#define GET_OFFSET_LENGTH( CurrentEa, EaBase ) (    \
    (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )

{
    LONG tempLength;
    ULONG entrySize;
    PFILE_FULL_EA_INFORMATION eas;

    PAGED_CODE();

    //
    // Walk the buffer and ensure that its format is valid.  That is, ensure
    // that it does not walk off the end of the buffer, is not recursive,
    // etc.
    //

    eas = EaBuffer;
    tempLength = EaLength;

    for (;;) {

        //
        // Get the size of the current entry in the buffer.  The minimum
        // size of the entry is the fixed size part of the structure plus
        // the length of the name, a single termination character byte which
        // must be present (a 0), plus the length of the value.  If this
        // is not the last entry, then there will also be pad bytes to get
        // to the next longword boundary.
        //

        //
        // Start by checking that the fixed size lies within the stated length.
        //

        if (tempLength < FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0])) {

            *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
            return STATUS_EA_LIST_INCONSISTENT;
        }

        entrySize = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                        eas->EaNameLength + 1 + eas->EaValueLength;

        //
        // Confirm that the full length lies within the stated buffer length.
        //

        if ((ULONG) tempLength < entrySize) {

            *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
            return STATUS_EA_LIST_INCONSISTENT;
        }

        //
        // Confirm that there is a NULL terminator after the name.
        //

        if (eas->EaName[eas->EaNameLength] != '\0') {

            *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
            return STATUS_EA_LIST_INCONSISTENT;
        }

        if (eas->NextEntryOffset) {

            //
            // There is another entry in the buffer and it must be longword
            // aligned.  Ensure that the offset indicates that it is.  If it
            // isn't, return invalid parameter.
            //

            if (ALIGN_LONG( entrySize ) != eas->NextEntryOffset ||
                (LONG) eas->NextEntryOffset < 0) {
                *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
                return STATUS_EA_LIST_INCONSISTENT;

            } else {

                //
                // There is another entry in the buffer, so account for the
                // size of the current entry in the length and get a pointer
                // to the next entry.
                //

                tempLength -= eas->NextEntryOffset;
                if (tempLength < 0) {
                    *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
                    return STATUS_EA_LIST_INCONSISTENT;
                }
                eas = (PFILE_FULL_EA_INFORMATION) ((PCHAR) eas + eas->NextEntryOffset);

            }

        } else {

            //
            // There are no other entries in the buffer.  Simply account for
            // the overall buffer length according to the size of the current
            // entry and exit the loop.
            //

            tempLength -= entrySize;
            break;

        }
    }

    //
    // All of the entries in the buffer have been processed.  Check to see
    // whether the overall buffer length went negative.  If so, return an
    // error.
    //

    if (tempLength < 0) {
        *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
        return STATUS_EA_LIST_INCONSISTENT;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IoCheckFunctionAccess(
    IN ACCESS_MASK GrantedAccess,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN ULONG IoControlCode,
    IN PVOID Arg1 OPTIONAL,
    IN PVOID Arg2 OPTIONAL
    )

/*++

Routine Description:

    This routine checks the parameters and access for the function and
    parameters specified by the input parameters against the current access
    to the file as described by the GrantedAccess mask parameter.  If the
    caller has the access to the file, then a successful status code is
    returned.  Otherwise, an error status code is returned as the function
    value.

Arguments:

    GrantedAccess - Access granted to the file for the caller.

    MajorFunction - Major function code for the operation being performed.

    MinorFunction - Minor function code for the operation being performed.

    IoControlCode - I/O function control code for a device or file system I/O
        code.  Used only for those two function types.

    Arg1 - Optional argument that depends on the major function. Its
         FileInformationClass if the major function code indicates a query or set
         file information function is being performed. It points to Security Info
         if major function code is IRP_MJ_*_SECURITY.

    Arg2 - Optional second argument that depends on the major function. Currently its
        FsInformationClass.This parameter MUST be supplied if the major function
        code indicates that a query or set file system information function is
        being performed.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has the access to the file, then STATUS_SUCCESS is returned;
    otherwise, STATUS_ACCESS_DENIED is returned.

Note:

    The GrantedAccess mask may not contain any generic mappings.  That is,
    the IoCheckDesiredAccess function must have been previously invoked to
    return a full mask.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PFILE_INFORMATION_CLASS FileInformationClass;
    PFS_INFORMATION_CLASS FsInformationClass;
    SECURITY_INFORMATION SecurityInformation;
    ACCESS_MASK DesiredAccess;

    UNREFERENCED_PARAMETER( MinorFunction );

    PAGED_CODE();

    //
    // Determine the major function being performed.  If the function code
    // is invalid, then return an error.
    //

    FileInformationClass = (PFILE_INFORMATION_CLASS)Arg1;
    FsInformationClass = (PFS_INFORMATION_CLASS)Arg2;

    switch( MajorFunction ) {

    case IRP_MJ_CREATE:
    case IRP_MJ_CLOSE:

        break;

    case IRP_MJ_READ:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_READ_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_WRITE:

        if (!SeComputeGrantedAccesses( GrantedAccess, FILE_WRITE_DATA | FILE_APPEND_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_QUERY_INFORMATION:

        if (IopQueryOperationAccess[*FileInformationClass] != 0) {
            if (SeComputeDeniedAccesses( GrantedAccess, IopQueryOperationAccess[*FileInformationClass] )) {
                status = STATUS_ACCESS_DENIED;
            }
        }
        break;

    case IRP_MJ_SET_INFORMATION:

        if (IopSetOperationAccess[*FileInformationClass] != 0) {
            if (SeComputeDeniedAccesses( GrantedAccess, IopSetOperationAccess[*FileInformationClass] )) {
                status = STATUS_ACCESS_DENIED;
            }
        }
        break;

    case IRP_MJ_QUERY_EA:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_READ_EA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_SET_EA:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_WRITE_EA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_FLUSH_BUFFERS:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_WRITE_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_QUERY_VOLUME_INFORMATION:

        if (SeComputeDeniedAccesses( GrantedAccess, IopQueryFsOperationAccess[*FsInformationClass] )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_SET_VOLUME_INFORMATION:

        if (SeComputeDeniedAccesses( GrantedAccess, IopSetFsOperationAccess[*FsInformationClass] )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_DIRECTORY_CONTROL:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_LIST_DIRECTORY )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_FILE_SYSTEM_CONTROL:
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        {
            ULONG accessMode = (IoControlCode >> 14) & 3;

            if (accessMode != FILE_ANY_ACCESS) {

                //
                // This I/O control requires that the caller have read, write,
                // or read/write access to the object.  If this is not the case,
                // then cleanup and return an appropriate error status code.
                //

                if (!(SeComputeGrantedAccesses( GrantedAccess, accessMode ))) {
                    status = STATUS_ACCESS_DENIED;
                }
            }

        }
        break;

    case IRP_MJ_LOCK_CONTROL:

        if (!SeComputeGrantedAccesses( GrantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_SET_SECURITY:

        SecurityInformation = *((PSECURITY_INFORMATION)Arg1);
        SeSetSecurityAccessMask(SecurityInformation, &DesiredAccess);

        if (SeComputeDeniedAccesses( GrantedAccess, DesiredAccess )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_QUERY_SECURITY:

        SecurityInformation = *((PSECURITY_INFORMATION)Arg1);
        SeQuerySecurityAccessMask(SecurityInformation, &DesiredAccess);

        if (SeComputeDeniedAccesses( GrantedAccess, DesiredAccess )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;
    default:

        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    return status;
}

NTKERNELAPI
NTSTATUS
IoCheckQuerySetFileInformation(
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    )

/*++

Routine Description:

    This routine checks the validity of the parameters for either a query or a
    set file information operation.  It is used primarily by network servers
    running in kernel mode since no such parameter validity checking is done
    in the normal path.

Arguments:

    FileInformationClass - Specifies the information class to check checked.

    Length - Specifies the length of the buffer supplied.

    SetOperation - Specifies that the operation was a set file information as
        opposed to a query operation.

Return Value:

    The function value is STATUS_SUCCESS if the parameters were valid,
    otherwise an appropriate error is returned.

--*/

{
    PCHAR operationLength;

    //
    // The file information class itself must be w/in the valid range of file
    // information classes, otherwise this is an invalid information class.
    //

    if ((ULONG) FileInformationClass >= FileMaximumInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    // Determine whether this is a query or a set operation and act accordingly.
    //

    if (SetOperation) {
        operationLength = (PCHAR) IopSetOperationLength;
    }
    else {
        operationLength = (PCHAR) IopQueryOperationLength;
    }

    if (!operationLength[FileInformationClass]) {
        return STATUS_INVALID_INFO_CLASS;
    }
    if (Length < (ULONG) operationLength[FileInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    return STATUS_SUCCESS;
}
NTKERNELAPI
NTSTATUS
IoCheckQuerySetVolumeInformation(
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    )

/*++

Routine Description:

    This routine checks the validity of the parameters for either a query or a
    set volume information operation.  It is used primarily by network servers
    running in kernel mode since no such parameter validity checking is done
    in the normal path.

Arguments:

    FsInformationClass - Specifies the information class to check.

    Length - Specifies the length of the buffer supplied.

    SetOperation - Specifies that the operation was a set volume information as
        opposed to a query operation.

Return Value:

    The function value is STATUS_SUCCESS if the parameters were valid,
    otherwise an appropriate error is returned.

--*/

{
    PCHAR operationLength;

    if (SetOperation) {
        operationLength = (PCHAR) IopSetFsOperationLength;
    }
    else {
        operationLength = (PCHAR) IopQueryFsOperationLength;
    }

    //
    // The volume information class itself must be w/in the valid range of file
    // information classes, otherwise this is an invalid information class.
    //
    if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
        operationLength[ FsInformationClass ] == 0 ) {

        return STATUS_INVALID_INFO_CLASS;
    }

    if (Length < (ULONG) operationLength[FsInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IoCheckQuotaBufferValidity(
    IN PFILE_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG ErrorOffset
    )

/*++

Routine Description:

    This routine checks the validity of the specified quota buffer to guarantee
    that its format is proper, no fields hang over, that it is not recursive,
    etc.

Arguments:

    QuotaBuffer - Pointer to the buffer containing the quota entries to be
        checked.

    QuotaLength - Specifies the length of the QuotaBuffer.

    ErrorOffset - A variable to receive the offset of the offending entry in
        the quota buffer if an error is incurred.  This variable is only valid
        if an error occurs.

Return Value:

    The function value is STATUS_SUCCESS if the quota buffer contains a valid,
    properly formed list, otherwise STATUS_QUOTA_LIST_INCONSISTENT.

--*/

#if defined(_X86_)
#define REQUIRED_QUOTA_ALIGNMENT sizeof( ULONG )
#else
#define REQUIRED_QUOTA_ALIGNMENT sizeof( ULONGLONG )
#endif

#define ALIGN_QUAD( Address ) ( (ULONG) ((Address + 7) & ~7) )

#define GET_OFFSET_LENGTH( CurrentEntry, QuotaBase ) (\
    (ULONG) ((PCHAR) CurrentEntry - (PCHAR) QuotaBase) )

{
    LONG tempLength;
    ULONG entrySize;
    PFILE_QUOTA_INFORMATION quotas;

    PAGED_CODE();

    //
    // Walk the buffer and ensure that its format is valid.  That is, ensure
    // that it does not walk off the end of the buffer, is not recursive,
    // etc.
    //

    quotas = QuotaBuffer;
    tempLength = QuotaLength;

    //
    // Ensure the buffer has the correct alignment.
    //

    if ((ULONG_PTR) quotas & (REQUIRED_QUOTA_ALIGNMENT - 1)) {
        *ErrorOffset = 0;
        return STATUS_DATATYPE_MISALIGNMENT;
    }

    for (;;) {

        ULONG sidLength;

        //
        // Get the size of the current entry in the buffer.  The minimum size
        // of the entry is the fixed size part of the structure plus the actual
        // length of the SID.  If this is not the last entry, then there will
        // also be pad bytes to get to the next longword boundary.  Likewise,
        // ensure that the SID itself is valid.
        //

        if (tempLength < FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) ||
            !RtlValidSid( &quotas->Sid )) {
            goto error_exit;
        }

        sidLength = RtlLengthSid( (&quotas->Sid) );
        entrySize = FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) + sidLength;

        //
        // Confirm that the full length lies within the stated buffer length.
        //

        if ((ULONG) tempLength < entrySize ||
            quotas->SidLength != sidLength) {
            goto error_exit;
        }

        if (quotas->NextEntryOffset) {

            //
            // There is another entry in the buffer and it must be longword
            // aligned.  Ensure that the offset indicates that it is.  If it
            // is not, return error status code.
            //

            if (entrySize > quotas->NextEntryOffset ||
                quotas->NextEntryOffset & (REQUIRED_QUOTA_ALIGNMENT - 1) ||
                (LONG) quotas->NextEntryOffset < 0) {
                goto error_exit;

            } else {

                //
                // There is another entry in the buffer, so account for the size
                // of the current entry in the length and get a pointer to the
                // next entry.
                //

                tempLength -= quotas->NextEntryOffset;
                if (tempLength < 0) {
                    goto error_exit;
                }
                quotas = (PFILE_QUOTA_INFORMATION) ((PCHAR) quotas + quotas->NextEntryOffset);
            }

        } else {

            //
            // There are no more entries in the buffer.  Simply account for the
            // overall buffer length according to the size of the current
            // entry and exit the loop.
            //

            tempLength -= entrySize;
            break;
        }
    }

    //
    // All of the entries in the buffer have been processed.  Check to see
    // whether the overall buffer length went negative.  If so, return an
    // error.
    //

    if (tempLength < 0) {
        goto error_exit;
    }

    return STATUS_SUCCESS;

error_exit:

    *ErrorOffset = GET_OFFSET_LENGTH( quotas, QuotaBuffer );
    return STATUS_QUOTA_LIST_INCONSISTENT;

}

NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not a new accessor to
    a file actually has shared access to it.  The check is made according
    to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    If the open should succeed, then the access information about how the
    file is currently opened is updated, according to the Update parameter.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

    Update - Specifies whether or not the share access information for the
        file is to be updated.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,
    STATUS_SHARING_VIOLATION is returned.

Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    ULONG ocount;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);


    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // If this is a special filter fileobject ignore share access check if necessary.
        //

        if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

            if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {
                return STATUS_SUCCESS;
            }
        }

        //
        // Now check to see whether or not the desired accesses are compatible
        // with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ( (FileObject->ReadAccess && (ShareAccess->SharedRead < ocount))
             ||
             (FileObject->WriteAccess && (ShareAccess->SharedWrite < ocount))
             ||
             (FileObject->DeleteAccess && (ShareAccess->SharedDelete < ocount))
             ||
             ((ShareAccess->Readers != 0) && !FileObject->SharedRead)
             ||
             ((ShareAccess->Writers != 0) && !FileObject->SharedWrite)
             ||
             ((ShareAccess->Deleters != 0) && !FileObject->SharedDelete)
           ) {

            //
            // The check failed.  Simply return to the caller indicating that the
            // current open cannot access the file.
            //

            return STATUS_SHARING_VIOLATION;

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        } else if (Update) {

            ShareAccess->OpenCount++;

            ShareAccess->Readers += FileObject->ReadAccess;
            ShareAccess->Writers += FileObject->WriteAccess;
            ShareAccess->Deleters += FileObject->DeleteAccess;

            ShareAccess->SharedRead += FileObject->SharedRead;
            ShareAccess->SharedWrite += FileObject->SharedWrite;
            ShareAccess->SharedDelete += FileObject->SharedDelete;
        }
    }
    return STATUS_SUCCESS;
}

VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    //
    // This routine will either jump immediately to IopfCompleteRequest, or
    // rather IovCompleteRequest.
    //
    pIofCompleteRequest(Irp, PriorityBoost);
}

VOID
FASTCALL
IopfCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is invoked to complete an I/O request.  It is invoked by the
    driver in its DPC routine to perform the final completion of the IRP.  The
    functions performed by this routine are as follows.

        1.  A check is made to determine whether the packet's stack locations
            have been exhausted.  If not, then the stack location pointer is set
            to the next location and if there is a routine to be invoked, then
            it will be invoked.  This continues until there are either no more
            routines which are interested or the packet runs out of stack.

            If a routine is invoked to complete the packet for a specific driver
            which needs to perform work a lot of work or the work needs to be
            performed in the context of another process, then the routine will
            return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.
            This indicates that this completion routine should simply return to
            its caller because the operation will be "completed" by this routine
            again sometime in the future.

        2.  A check is made to determine whether this IRP is an associated IRP.
            If it is, then the count on the master IRP is decremented.  If the
            count for the master becomes zero, then the master IRP will be
            completed according to the steps below taken for a normal IRP being
            completed.  If the count is still non-zero, then this IRP (the one
            being completed) will simply be deallocated.

        3.  If this is paging I/O or a close operation, then simply write the
            I/O status block and set the event to the signaled state, and
            dereference the event.  If this is paging I/O, deallocate the IRP
            as well.

        4.  Unlock the pages, if any, specified by the MDL by calling
            MmUnlockPages.

        5.  A check is made to determine whether or not completion of the
            request can be deferred until later.  If it can be, then this
            routine simply exits and leaves it up to the originator of the
            request to fully complete the IRP.  By not initializing and queueing
            the special kernel APC to the calling thread (which is the current
            thread by definition), a lot of interrupt and queueing processing
            can be avoided.


        6.  The final rundown routine is invoked to queue the request packet to
            the target (requesting) thread as a special kernel mode APC.

Arguments:

    Irp - Pointer to the I/O Request Packet to complete.

    PriorityBoost - Supplies the amount of priority boost that is to be given
        to the target thread when the special kernel APC is queued.

Return Value:

    None.

--*/

#define ZeroIrpStackLocation( IrpSp ) {         \
    (IrpSp)->MinorFunction = 0;                 \
    (IrpSp)->Flags = 0;                         \
    (IrpSp)->Control = 0 ;                      \
    (IrpSp)->Parameters.Others.Argument1 = 0;   \
    (IrpSp)->Parameters.Others.Argument2 = 0;   \
    (IrpSp)->Parameters.Others.Argument3 = 0;   \
    (IrpSp)->Parameters.Others.Argument4 = 0;   \
    (IrpSp)->FileObject = (PFILE_OBJECT) NULL; }

{
    PIRP masterIrp;
    NTSTATUS status;
    PIO_STACK_LOCATION stackPointer;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    KIRQL irql;
    PVOID saveAuxiliaryPointer = NULL;

    //
    // Begin by ensuring that this packet has not already been completed
    // by someone.
    //

    if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1) ||
        Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }

    //
    // Ensure that the packet being completed really is still an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Ensure that no one believes that this request is still in a cancelable
    // state.
    //

    ASSERT( !Irp->CancelRoutine );

    //
    // Ensure that the packet is not being completed with a thoroughly
    // confusing status code.  Actually completing a packet with a pending
    // status probably means that someone forgot to set the real status in
    // the packet.
    //

    ASSERT( Irp->IoStatus.Status != STATUS_PENDING );

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( Irp->IoStatus.Status != 0xffffffff );

    //
    // Now check to see whether this is the last driver that needs to be
    // invoked for this packet.  If not, then bump the stack and check to
    // see whether the driver wishes to see the completion.  As each stack
    // location is examined, invoke any routine which needs to be invoked.
    // If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the
    // processing of this packet.
    //

    for (stackPointer = IoGetCurrentIrpStackLocation( Irp ),
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++;
         Irp->CurrentLocation <= (CCHAR) (Irp->StackCount + 1);
         stackPointer++,
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++) {

        //
        // A stack location was located.  Check to see whether or not it
        // has a completion routine and if so, whether or not it should be
        // invoked.
        //
        // Begin by saving the pending returned flag in the current stack
        // location in the fixed part of the IRP.
        //

        Irp->PendingReturned = stackPointer->Control & SL_PENDING_RETURNED;

        if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
             (!NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_ERROR) ||
             (Irp->Cancel &&
             stackPointer->Control & SL_INVOKE_ON_CANCEL)
           ) {

            //
            // This driver has specified a completion routine.  Invoke the
            // routine passing it a pointer to its device object and the
            // IRP that is being completed.
            //

            ZeroIrpStackLocation( stackPointer );

            if (Irp->CurrentLocation == (CCHAR) (Irp->StackCount + 1)) {
                deviceObject = NULL;
            }
            else {
                deviceObject = IoGetCurrentIrpStackLocation( Irp )->DeviceObject;
            }

            status = stackPointer->CompletionRoutine( deviceObject,
                                                      Irp,
                                                      stackPointer->Context );

            if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                //
                // Note:  Notice that if the driver has returned the above
                //        status value, it may have already DEALLOCATED the
                //        packet!  Therefore, do NOT touch any part of the
                //        IRP in the following code.
                //

                return;
            }

        } else {
            if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
                IoMarkIrpPending( Irp );
            }
            ZeroIrpStackLocation( stackPointer );
        }
    }

    //
    // Check to see whether this is an associated IRP.  If so, then decrement
    // the count in the master IRP.  If the count is decremented to zero,
    // then complete the master packet as well.
    //

    if (Irp->Flags & IRP_ASSOCIATED_IRP) {
        ULONG count;

        masterIrp = Irp->AssociatedIrp.MasterIrp;

        //
        // After this decrement master IRP cannot be touched except if count == 1.
        //

        count = IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                              &masterIrp->AssociatedIrp.IrpCount );

        //
        // Deallocate this packet and any MDLs that are associated with it
        // by either doing direct deallocations if they were allocated from
        // a zone or by queueing the packet to a thread to perform the
        // deallocation.
        //
        // Also, check the count of the master IRP to determine whether or not
        // the count has gone to zero.  If not, then simply get out of here.
        // Otherwise, complete the master packet.
        //

        IopFreeIrpAndMdls( Irp );
        if (count == 1) {
            IoCompleteRequest( masterIrp, PriorityBoost );
        }
        return;
    }

    //
    // Check to see if we have a name junction. If so set the stage to
    // transmogrify the reparse point data in IopCompleteRequest.
    //

    if ((Irp->IoStatus.Status == STATUS_REPARSE )  &&
        (Irp->IoStatus.Information > IO_REPARSE_TAG_RESERVED_RANGE)) {

        if (Irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {

            //
            // For name junctions, we save the pointer to the auxiliary
            // buffer and use it below.
            //

            ASSERT( Irp->Tail.Overlay.AuxiliaryBuffer != NULL );

            saveAuxiliaryPointer = (PVOID) Irp->Tail.Overlay.AuxiliaryBuffer;

            //
            // We NULL the entry to avoid its de-allocation at this time.
            // This buffer get deallocated in IopDoNameTransmogrify
            //

            Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
        } else {

            //
            // Fail the request. A driver needed to act on this IRP prior
            // to getting to this point.
            //

            Irp->IoStatus.Status = STATUS_IO_REPARSE_TAG_NOT_HANDLED;
        }
    }

    //
    // Check the auxiliary buffer pointer in the packet and if a buffer was
    // allocated, deallocate it now.  Note that this buffer must be freed
    // here since the pointer is overlayed with the APC that will be used
    // to get to the requesting thread's context.
    //

    if (Irp->Tail.Overlay.AuxiliaryBuffer) {
        ExFreePool( Irp->Tail.Overlay.AuxiliaryBuffer );
        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    }

    //
    // Check to see if this is paging I/O or a close operation.  If either,
    // then special processing must be performed.  The reasons that special
    // processing must be performed is different based on the type of
    // operation being performed.  The biggest reasons for special processing
    // on paging operations are that using a special kernel APC for an in-
    // page operation cannot work since the special kernel APC can incur
    // another pagefault.  Likewise, all paging I/O uses MDLs that belong
    // to the memory manager, not the I/O system.
    //
    // Close operations are special because the close may have been invoked
    // because of a special kernel APC (some IRP was completed which caused
    // the reference count on the object to become zero while in the I/O
    // system's special kernel APC routine).  Therefore, a special kernel APC
    // cannot be used since it cannot execute until the close APC finishes.
    //
    // The special steps are as follows for a synchronous paging operation
    // and close are:
    //
    //     1.  Copy the I/O status block (it is in SVAS, nonpaged).
    //     2.  Signal the event
    //     3.  If paging I/O, deallocate the IRP
    //
    // The special steps taken for asynchronous paging operations (out-pages)
    // are as follows:
    //
    //     1.  Initialize a special kernel APC just for page writes.
    //     1.  Queue the special kernel APC.
    //
    // It should also be noted that the logic for completing a Mount request
    // operation is exactly the same as a Page Read.  No assumptions should be
    // made here about this being a Page Read operation w/o carefully checking
    // to ensure that they are also true for a Mount.  That is:
    //
    //     IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION
    //
    // are the same flag in the IRP.
    //
    // Also note that the last time the IRP is touched for a close operation
    // must be just before the event is set to the signaled state.  Once this
    // occurs, the IRP can be deallocated by the thread waiting for the event.
    //
    //
    // IRP_CLOSE_OPERATION and IRP_SET_USER_EVENT are the same flags. They both indicate
    // that only the user event field should be set and no APC should be queued. Unfortunately
    // IRP_CLOSE_OPERATION is used by some drivers to do exactly this so it cannot be renamed.
    //
    //

    if (Irp->Flags & (IRP_PAGING_IO | IRP_CLOSE_OPERATION |IRP_SET_USER_EVENT)) {
        if (Irp->Flags & (IRP_SYNCHRONOUS_PAGING_IO | IRP_CLOSE_OPERATION |IRP_SET_USER_EVENT)) {
            ULONG flags;

            flags = Irp->Flags & (IRP_SYNCHRONOUS_PAGING_IO|IRP_PAGING_IO);
            *Irp->UserIosb = Irp->IoStatus;
            (VOID) KeSetEvent( Irp->UserEvent, PriorityBoost, FALSE );
            if (flags) {
                if (IopIsReserveIrp(Irp)) {
                    IopFreeReserveIrp(PriorityBoost);
                } else {
                    IoFreeIrp( Irp );
                }
            }
        } else {
            thread = Irp->Tail.Overlay.Thread;
            KeInitializeApc( &Irp->Tail.Apc,
                             &thread->Tcb,
                             Irp->ApcEnvironment,
                             IopCompletePageWrite,
                             (PKRUNDOWN_ROUTINE) NULL,
                             (PKNORMAL_ROUTINE) NULL,
                             KernelMode,
                             (PVOID) NULL );
            (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                     (PVOID) NULL,
                                     (PVOID) NULL,
                                     PriorityBoost );
        }
        return;
    }

    //
    // Check to see whether any pages need to be unlocked.
    //

    if (Irp->MdlAddress != NULL) {

        //
        // Unlock any pages that may be described by MDLs.
        //

        mdl = Irp->MdlAddress;
        while (mdl != NULL) {
            MmUnlockPages( mdl );
            mdl = mdl->Next;
        }
    }

    //
    // Make a final check here to determine whether or not this is a
    // synchronous I/O operation that is being completed in the context
    // of the original requestor.  If so, then an optimal path through
    // I/O completion can be taken.
    //

    if (Irp->Flags & IRP_DEFER_IO_COMPLETION && !Irp->PendingReturned) {

        if ((Irp->IoStatus.Status == STATUS_REPARSE )  &&
            (Irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            //
            // For name junctions we reinstate the address of the appropriate
            // buffer. It is freed in parse.c
            //

            Irp->Tail.Overlay.AuxiliaryBuffer = saveAuxiliaryPointer;
        }

        return;
    }

    //
    // Finally, initialize the IRP as an APC structure and queue the special
    // kernel APC to the target thread.
    //

    thread = Irp->Tail.Overlay.Thread;
    fileObject = Irp->Tail.Overlay.OriginalFileObject;

    if (!Irp->Cancel) {

        KeInitializeApc( &Irp->Tail.Apc,
                         &thread->Tcb,
                         Irp->ApcEnvironment,
                         IopCompleteRequest,
                         IopAbortRequest,
                         (PKNORMAL_ROUTINE) NULL,
                         KernelMode,
                         (PVOID) NULL );

        (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                 fileObject,
                                 (PVOID) saveAuxiliaryPointer,
                                 PriorityBoost );
    } else {

        //
        // This request has been cancelled.  Ensure that access to the thread
        // is synchronized, otherwise it may go away while attempting to get
        // through the remainder of completion for this request.  This happens
        // when the thread times out waiting for the request to be completed
        // once it has been cancelled.
        //
        // Note that it is safe to capture the thread pointer above, w/o having
        // the lock because the cancel flag was not set at that point, and
        // the code that disassociates IRPs must set the flag before looking to
        // see whether or not the packet has been completed, and this packet
        // will appear to be completed because it no longer belongs to a driver.
        //

        irql = KeAcquireQueuedSpinLock( LockQueueIoCompletionLock );

        thread = Irp->Tail.Overlay.Thread;

        if (thread) {

            KeInitializeApc( &Irp->Tail.Apc,
                             &thread->Tcb,
                             Irp->ApcEnvironment,
                             IopCompleteRequest,
                             IopAbortRequest,
                             (PKNORMAL_ROUTINE) NULL,
                             KernelMode,
                             (PVOID) NULL );

            (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                     fileObject,
                                     (PVOID) saveAuxiliaryPointer,
                                     PriorityBoost );

            KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, irql );

        } else {

            //
            // This request has been aborted from completing in the caller's
            // thread.  This can only occur if the packet was cancelled, and
            // the driver did not complete the request, so it was timed out.
            // Attempt to drop things on the floor, since the originating thread
            // has probably exited at this point.
            //

            KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, irql );

            ASSERT( Irp->Cancel );

            //
            // Drop the IRP on the floor.
            //

            IopDropIrp( Irp, fileObject );

        }
    }
}

NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This routine allocates, initializes, and connects interrupt objects for
    all of the processors specified in the processor enable mask.

Arguments:

    InterruptObject - Address of a variable to receive a pointer to the first
        interrupt object allocated and initialized.

    ServiceRoutine - Address of the interrupt service routine (ISR) that should
        be executed when the interrupt occurs.

    ServiceContext - Supplies a pointer to the context information required
        by the ISR.

    SpinLock - Supplies a pointer to a spin lock to be used when synchronizing
        with the ISR.

    Vector - Supplies the vector upon which the interrupt occurs.

    Irql - Supplies the IRQL upon which the interrupt occurs.

    SynchronizeIrql - The request priority that the interrupt should be
        synchronized with.

    InterruptMode - Specifies the interrupt mode of the device.

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorEnableMask - Specifies a bit-vector for each processor on which
        the interrupt is to be connected.  A value of one in the bit position
        cooresponding to the processor number indicates that the interrupt
        should be allowed on that processor.  At least one bit must be set.

    FloatingSave - A BOOLEAN that specifies whether or not the machine's
        floating point state should be saved before invoking the ISR.

Return Value:

    The function value is the final function status.  The three status values
    that this routine can itself return are:

        STATUS_SUCCESS - Everything worked successfully.
        STATUS_INVALID_PARAMETER - No processors were specified.
        STATUS_INSUFFICIENT_RESOURCES - There was not enough nonpaged pool.

--*/

{
    CCHAR count;
    BOOLEAN builtinUsed;
    PKINTERRUPT interruptObject;
    KAFFINITY processorMask;
    NTSTATUS status;
    PIO_INTERRUPT_STRUCTURE interruptStructure;
    PKSPIN_LOCK spinLock;
#ifdef  INTR_BINDING
    ULONG AssignedProcessor;
#endif  // INTR_BINDING

    PAGED_CODE();

    //
    // Initialize the return pointer and assume success.
    //

    *InterruptObject = (PKINTERRUPT) NULL;
    status = STATUS_SUCCESS;

    //
    // Determine how much memory is to be allocated based on how many
    // processors this system may have and how many bits are set in the
    // processor enable mask.
    //

    processorMask = ProcessorEnableMask & KeActiveProcessors;
    count = 0;

    while (processorMask) {
        if (processorMask & 1) {
            count++;
        }
        processorMask >>= 1;
    }

    //
    // If any interrupt objects are to be allocated and initialized, allocate
    // the memory now.
    //

    if (count) {

        interruptStructure = ExAllocatePoolWithTag( NonPagedPool,
                                                    ((count - 1) * sizeof( KINTERRUPT )) +
                                                    sizeof( IO_INTERRUPT_STRUCTURE ),
                                                    'nioI' );
        if (interruptStructure == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the caller specified a spin lock to be used for the interrupt object,
    // use it.  Otherwise, provide one by using the one in the structure that
    // was just allocated.
    //

    if (ARGUMENT_PRESENT( SpinLock )) {
        spinLock = SpinLock;
    } else {
        spinLock = &interruptStructure->SpinLock;
    }

    //
    // Initialize and connect the
    // interrupt objects to the appropriate processors.
    //

    //
    // Return the address of the first interrupt object in case an
    // interrupt is pending for the device when it is initially connected
    // and the driver must synchronize its execution with the ISR.
    //

    *InterruptObject = &interruptStructure->InterruptObject;

    //
    // Begin by getting a pointer to the start of the memory to be used
    // for interrupt objects other than the builtin object.
    //

    interruptObject = (PKINTERRUPT) (interruptStructure + 1);
    builtinUsed = FALSE;
    processorMask = ProcessorEnableMask & KeActiveProcessors;

    //
    // Now zero the interrupt structure itself so that if something goes
    // wrong it can be backed out.
    //

    RtlZeroMemory( interruptStructure, sizeof( IO_INTERRUPT_STRUCTURE ) );

    //
    // For each entry in the processor enable mask that is set, connect
    // and initialize an interrupt object.  The first bit that is set
    // uses the builtin interrupt object, and all others use the pointers
    // that follow it.
    //

    for (count = 0; processorMask; count++, processorMask >>= 1) {

        if (processorMask & 1) {
            KeInitializeInterrupt( builtinUsed ?
                                   interruptObject :
                                   &interruptStructure->InterruptObject,
                                   ServiceRoutine,
                                   ServiceContext,
                                   spinLock,
                                   Vector,
                                   Irql,
                                   SynchronizeIrql,
                                   InterruptMode,
                                   ShareVector,
                                   count,
                                   FloatingSave );

            if (!KeConnectInterrupt( builtinUsed ?
                                     interruptObject :
                                     &interruptStructure->InterruptObject )) {

                //
                // An error occurred while attempting to connect the
                // interrupt.  This means that the driver either specified
                // the wrong type of interrupt mode, or attempted to connect
                // to some processor that didn't exist, or whatever.  In
                // any case, the problem turns out to be an invalid
                // parameter was specified.  Simply back everything out
                // and return an error status.
                //
                // Note that if the builtin entry was used, then the entire
                // structure needs to be walked as there are entries that
                // were successfully connected.  Otherwise, the first
                // attempt to connect failed, so simply free everything
                // in-line.
                //

                if (builtinUsed) {
                    IoDisconnectInterrupt( &interruptStructure->InterruptObject );
                } else {
                    ExFreePool( interruptStructure );
                }
                status = STATUS_INVALID_PARAMETER;
                break;
            }


            //
            // If the builtin entry has been used, then the interrupt
            // object just connected was one of the pointers, so fill
            // it in with the address of the memory actually used.
            //

            if (builtinUsed) {
                interruptStructure->InterruptArray[count] = interruptObject++;

            } else {

                //
                // Otherwise, the builtin entry was used, so indicate
                // that it is no longer valid to use and start using
                // the pointers instead.
                //

                builtinUsed = TRUE;
            }
        }
    }

    //
    // Finally, reset the address of the interrupt object if the function
    // failed and return the final status of the operation.
    //

    if (!NT_SUCCESS( status )) {
        *InterruptObject = (PKINTERRUPT) NULL;
    }

    return status;
}

PCONTROLLER_OBJECT
IoCreateController(
    IN ULONG Size
    )

/*++

Routine Description:

    This routine creates a controller object that can be used to synchronize
    access to a physical device controller from two or more devices.

Arguments:

    Size - Size of the adapter extension in bytes.

Return Value:

    A pointer to the controller object that was created or a NULL pointer.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PCONTROLLER_OBJECT controllerObject;
    HANDLE handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the object attributes structure in preparation for creating
    // the controller object.
    //

    InitializeObjectAttributes( &objectAttributes,
                                (PUNICODE_STRING) NULL,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the controller object itself.
    //

    status = ObCreateObject( KernelMode,
                             IoControllerObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) sizeof( CONTROLLER_OBJECT ) + Size,
                             0,
                             0,
                             (PVOID *) &controllerObject );
    if (NT_SUCCESS( status )) {

        //
        // Insert the controller object into the table.
        //

        status = ObInsertObject( controllerObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 1,
                                 (PVOID *) &controllerObject,
                                 &handle );

        //
        // If the insert operation fails, set return value to NULL.
        //

        if (!NT_SUCCESS( status )) {
            controllerObject = (PCONTROLLER_OBJECT) NULL;
        } else {

            //
            // The insert completed successfully.  Close the handle so that if
            // the driver is unloaded, the controller object can go away.
            //

            (VOID) ObCloseHandle( handle, KernelMode );

            //
            // Zero the memory for the controller object.
            //

            RtlZeroMemory( controllerObject, sizeof( CONTROLLER_OBJECT ) + Size );

            //
            // Set the type and size of this controller object.
            //

            controllerObject->Type = IO_TYPE_CONTROLLER;
            controllerObject->Size = (USHORT) (sizeof( CONTROLLER_OBJECT ) + Size);
            controllerObject->ControllerExtension = (PVOID) (controllerObject + 1);

            //
            // Finally, initialize the controller's device queue.
            //

            KeInitializeDeviceQueue( &controllerObject->DeviceWaitQueue );
        }
    } else {
        controllerObject = (PCONTROLLER_OBJECT) NULL;
    }

    return controllerObject;
}

VOID
IopInsertRemoveDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Insert
    )

{
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    if (Insert) {
        DeviceObject->NextDevice = DriverObject->DeviceObject;
        DriverObject->DeviceObject = DeviceObject;
        }
    else {
        PDEVICE_OBJECT *prevPoint;

        prevPoint = &DeviceObject->DriverObject->DeviceObject;
        while (*prevPoint != DeviceObject) {
            prevPoint = &(*prevPoint)->NextDevice;
        }
        *prevPoint = DeviceObject->NextDevice;
    }
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
}

NTSTATUS
IopCreateVpb (
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PVPB Vpb;

    Vpb = ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof( VPB ),
                ' bpV'
                );

    if (!Vpb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory (Vpb, sizeof(VPB));
    Vpb->Type = IO_TYPE_VPB;
    Vpb->Size = sizeof( VPB );
    Vpb->RealDevice = DeviceObject;
    DeviceObject->Vpb = Vpb;

    return STATUS_SUCCESS;
}

NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine creates a device object and links it into the I/O database.

Arguments:

    DriverObject - A pointer to the driver object for this device.

    DeviceExtensionSize - Size, in bytes, of extension to device object;
        i.e., the size of the driver-specific data for this device object.

    DeviceName - Optional name that should be associated with this device.
        If the DeviceCharacteristics has the FILE_AUTOGENERATED_DEVICE_NAME
        flag set, this parameter is ignored.

    DeviceType - The type of device that the device object should represent.

    DeviceCharacteristics - The characteristics for the device.

    Exclusive - Indicates that the device object should be created with using
        the exclusive object attribute.

        NOTE: This flag should not be used for WDM drivers.  Since only the
        PDO is named, it is the only device object in a devnode attachment
        stack that is openable.  However, since this device object is created
        by the underlying bus driver (which has no knowledge about what type
        of device this is), there is no way to know whether this flag should
        be set.  Therefore, this parameter should always be FALSE for WDM
        drivers.  Drivers attached to the PDO (e.g., the function driver) must
        enforce any exclusivity rules.

    DeviceObject - Pointer to the device object pointer we will return.

Return Value:

    The function value is the final status of the operation.


--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PDEVICE_OBJECT deviceObject;
    PDEVOBJ_EXTENSION deviceObjectExt;
    HANDLE handle;
    BOOLEAN deviceHasName = FALSE;
    UCHAR localSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;
    PACL acl;
    ULONG RoundedSize;
    NTSTATUS status;
    USHORT sectorSize = 0;
    LONG nextUniqueDeviceObjectNumber;
    UNICODE_STRING autoGeneratedDeviceName;
    BOOLEAN retryWithNewName = FALSE;
    WCHAR deviceNameBuffer[17];             // "\Device\xxxxxxxx"

    PAGED_CODE();

    acl = NULL;

    //
    // Enclose the creation of the device object in a do/while, in the rare
    // event where we have to retry because some other driver is using our
    // naming scheme for auto-generated device object names.
    //

    do {

        if (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME) {

            //
            // The caller has requested that we automatically generate a device
            // object name.  Retrieve the next available number to use for this
            // purpose, and create a name of the form "\Device\<n>", where <n>
            // is the (8 hexadecimal digit) character representation of the unique
            // number we retrieve.
            //

            nextUniqueDeviceObjectNumber = InterlockedIncrement( &IopUniqueDeviceObjectNumber );
            swprintf( deviceNameBuffer, L"\\Device\\%08lx", nextUniqueDeviceObjectNumber );

            if (retryWithNewName) {

                //
                // We've already done this once (hence, the unicode device name string
                // is all set up, as is all the security information).  Thus, we can
                // skip down to where we re-attempt the creation of the device object
                // using our new name.
                //

                retryWithNewName = FALSE;
                goto attemptDeviceObjectCreation;

            } else {

                //
                // Set the DeviceName parameter to point to our unicode string, just as
                // if the caller had specified it (note, we explicitly ignore anything
                // the caller passes us for device name if the FILE_AUTOGENERATED_DEVICE_NAME
                // characteristic is specified.
                //

                RtlInitUnicodeString( &autoGeneratedDeviceName, deviceNameBuffer );
                DeviceName = &autoGeneratedDeviceName;
            }
        }

        //
        // Remember whether or not this device was created with a name so that
        // it can be deallocated later.
        //

        deviceHasName = (BOOLEAN) (ARGUMENT_PRESENT( DeviceName ) ? TRUE : FALSE);


        //
        // Detmermine whether or not this device needs to have a security descriptor
        // placed on it that allows read/write access, or whether the system default
        // should be used.  Disks, virtual disks, and file systems simply use the
        // system default descriptor.  All others allow read/write access.
        //
        // NOTE: This routine assumes that it is in the system's security context.
        //       In particular, it assumes that the Default DACL is the system's
        //       Default DACL.  If this assumption changes in future releases,
        //       then use of the Default DACL below should be reviewed for
        //       appropriateness.
        //

        //
        // If the device is a pnp device then wait until it registers a device
        // class before doing the default setup.
        //

        securityDescriptor = IopCreateDefaultDeviceSecurityDescriptor(
                                DeviceType,
                                DeviceCharacteristics,
                                deviceHasName,
                                localSecurityDescriptor,
                                &acl,
                                NULL
                                );

        switch ( DeviceType ) {

        case FILE_DEVICE_DISK_FILE_SYSTEM:

            sectorSize = 512;
            break;

        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:

            sectorSize = 2048;
            break;

        case FILE_DEVICE_DISK:
        case FILE_DEVICE_VIRTUAL_DISK:

            sectorSize = 512;
            break;
        }

attemptDeviceObjectCreation:
        //
        // Initialize the object attributes structure in preparation for creating
        // device object.  Note that the device may be created as an exclusive
        // device so that only one open can be done to it at a time.  This saves
        // single user devices from having drivers that implement special code to
        // make sure that only one connection is ever valid at any given time.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    DeviceName,
                                    OBJ_KERNEL_HANDLE,
                                    (HANDLE) NULL,
                                    securityDescriptor );



        if (Exclusive) {
            objectAttributes.Attributes |= OBJ_EXCLUSIVE;
        } else {
            objectAttributes.Attributes |= 0;
        }

        if (deviceHasName) {
            objectAttributes.Attributes |= OBJ_PERMANENT;
        }

        //
        // Create the device object itself.
        //

        RoundedSize = (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize)
                       % sizeof (LONGLONG);
        if (RoundedSize) {
            RoundedSize = sizeof (LONGLONG) - RoundedSize;
        }

        RoundedSize += DeviceExtensionSize;

        status = ObCreateObject( KernelMode,
                                 IoDeviceObjectType,
                                 &objectAttributes,
                                 KernelMode,
                                 (PVOID) NULL,
                                 (ULONG) sizeof( DEVICE_OBJECT ) + sizeof ( DEVOBJ_EXTENSION ) +
                                         RoundedSize,
                                 0,
                                 0,
                                 (PVOID *) &deviceObject );

        if ((status == STATUS_OBJECT_NAME_COLLISION) &&
            (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME)) {

            //
            // Some other driver is using our naming scheme, and we've picked a
            // device name already in use.  Try again, with a new number.
            //

            retryWithNewName = TRUE;
        }

    } while (retryWithNewName);

    if (!NT_SUCCESS( status )) {

        //
        // Creating the device object was not successful.  Clean everything
        // up and indicate that the object was not created.
        //

        deviceObject = (PDEVICE_OBJECT) NULL;

    } else {

        //
        // The device was successfully created.  Initialize the object so
        // that it can be inserted into the object table.  Begin by zeroing
        // the memory for the device object.
        //

        RtlZeroMemory( deviceObject,
                       sizeof( DEVICE_OBJECT ) + sizeof ( DEVOBJ_EXTENSION ) +
                       RoundedSize );

        //
        // Fill in deviceObject & deviceObjectExtension cross pointers
        //

        deviceObjectExt = (PDEVOBJ_EXTENSION)  (((PCHAR) deviceObject) +
                            sizeof (DEVICE_OBJECT) + RoundedSize);

        deviceObjectExt->DeviceObject = deviceObject;
        deviceObject->DeviceObjectExtension = deviceObjectExt;

        //
        // Initialize deviceObjectExt
        // Note: the size of a Device Object Extension is initialized specifically
        // to ZERO so no driver will depend on it.
        //

        deviceObjectExt->Type = IO_TYPE_DEVICE_OBJECT_EXTENSION;
        deviceObjectExt->Size = 0;

        PoInitializeDeviceObject(deviceObjectExt);

        //
        // Set the type and size of this device object.
        //

        deviceObject->Type = IO_TYPE_DEVICE;
        deviceObject->Size = (USHORT) (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize);

        //
        // Set the device type field in the object so that later code can
        // check the type.  Likewise, set the device characteristics.
        //

        deviceObject->DeviceType = DeviceType;
        deviceObject->Characteristics = DeviceCharacteristics;

        //
        // If this device is either a tape or a disk, allocate a Volume
        // Parameter Block (VPB) which indicates that the volume has
        // never been mounted, and set the device object's VPB pointer to
        // it.
        //

        if ((DeviceType == FILE_DEVICE_DISK) ||
            (DeviceType == FILE_DEVICE_TAPE) ||
            (DeviceType == FILE_DEVICE_CD_ROM) ||
            (DeviceType == FILE_DEVICE_VIRTUAL_DISK)) {

            status = IopCreateVpb (deviceObject);

            if (!NT_SUCCESS(status)) {

                ObDereferenceObject(deviceObject);

                if (acl != NULL) {
                    ExFreePool( acl );
                }

                *DeviceObject = (PDEVICE_OBJECT)NULL;
                return status;
            }

            KeInitializeEvent( &deviceObject->DeviceLock,
                               SynchronizationEvent,
                               TRUE );
        }

        //
        // Initialize the remainder of the device object.
        //
        deviceObject->AlignmentRequirement = HalGetDmaAlignmentRequirement() - 1;
        deviceObject->SectorSize = sectorSize;
        deviceObject->Flags = DO_DEVICE_INITIALIZING;

        if (Exclusive) {
            deviceObject->Flags |= DO_EXCLUSIVE;
        }
        if (deviceHasName) {
            deviceObject->Flags |= DO_DEVICE_HAS_NAME;
        }

        if(DeviceExtensionSize) {
            deviceObject->DeviceExtension = deviceObject + 1;
        } else {
            deviceObject->DeviceExtension = NULL;
        }

        deviceObject->StackSize = 1;
        switch ( DeviceType ) {

        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
        case FILE_DEVICE_DISK_FILE_SYSTEM:
        case FILE_DEVICE_FILE_SYSTEM:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
        case FILE_DEVICE_TAPE_FILE_SYSTEM:

            //
            // This device represents a file system of some sort.  Simply
            // initialize the queue list head in the device object.
            //

            InitializeListHead( &deviceObject->Queue.ListEntry );
            break;

        default:

            //
            // This is a real device of some sort.  Allocate a spin lock
            // and initialize the device queue object in the device object.
            //

            KeInitializeDeviceQueue( &deviceObject->DeviceQueue );
            break;
        }

        //
        // Insert the device object into the table.
        //

        status = ObInsertObject( deviceObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 1,
                                 (PVOID *) &deviceObject,
                                 &handle );

        if (NT_SUCCESS( status )) {

            //
            // Reference the driver object.   When the device object goes
            // away the reference will be removed.  This prevents the
            // driver object and driver image from going away while the
            // device object is in the pending delete state.
            //

            ObReferenceObject( DriverObject );

            ASSERT((DriverObject->Flags & DRVO_UNLOAD_INVOKED) == 0);

            //
            // The insert completed successfully.  Link the device object
            // and driver objects together.  Close the handle so that if
            // the driver is unloaded, the device object can go away.
            //

            deviceObject->DriverObject = DriverObject;

            IopInsertRemoveDevice( DriverObject, deviceObject, TRUE );
            if (deviceObject->Vpb) {
                PoVolumeDevice(deviceObject);
            }

            (VOID) ObCloseHandle( handle, KernelMode );

        } else {

            //
            // The insert operation failed.  Fortunately it dropped the
            // reference count on the device - since that was the last one
            // all the cleanup should be done for us.
            //

            //
            // indicate that no device object was created.
            //

            deviceObject = (PDEVICE_OBJECT) NULL;
        }
    }

    //
    // Free the DACL if we allocated it...
    //

    if (acl != NULL) {
        ExFreePool( acl );
    }

    *DeviceObject = deviceObject;
    return status;
}

NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    )
/*++

Routine Description:

    This is the common routine for both NtCreateFile and NtOpenFile to allow
    a user to create or open a file.  This procedure is also used internally
    by kernel mode components, such as the network server, to perform the
    same type of operation, but allows kernel mode code to force checking
    arguments and access to the file, rather than bypassing these checks
    because the code is running in kernel mode.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    DesiredAccess - Supplies the types of access that the caller would like
        to the file.

    ObjectAttributes - Supplies the attributes to be used for the file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.
        This parameter only has an affect if the file is created.  Further,
        if not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    Disposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    EaBuffer - Optionally specifies a set of EAs to be applied to the file
        if it is created.

    EaLength - Supplies the length of the EaBuffer.

    CreateFileType - The type of file to create.

    ExtraCreateParameters - Optionally specifies a pointer to extra create
        parameters.  The format of the parameters depends on the value of
        CreateFileType.

    Options - Specifies the options that are to be used during generation
        of the create IRP.

Return Value:

    The function value is the final status of the create/open operation.

Warning:

    If a pointer to ExtraCreateParameters is passed the data must be
    readable from kernel mode.


--*/
{
    NTSTATUS status;
    LONG CapturedSequence;

    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    do {

        //
        //  Capture the sequence
        //

        CapturedSequence = ExHotpSyncRenameSequence;

        status =  IopCreateFile( FileHandle,
                                 DesiredAccess,
                                 ObjectAttributes,
                                 IoStatusBlock,
                                 AllocationSize,
                                 FileAttributes,
                                 ShareAccess,
                                 Disposition,
                                 CreateOptions,
                                 EaBuffer,
                                 EaLength,
                                 CreateFileType,
                                 ExtraCreateParameters,
                                 Options,
                                 0,
                                 NULL
                                 );

    } while ( (!NT_SUCCESS(status))
                 &&
              ((CapturedSequence & 1) || (CapturedSequence != ExHotpSyncRenameSequence)));

    return status;

}

NTSTATUS
IoCreateFileSpecifyDeviceObjectHint(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PVOID DeviceObject
    )
{

    ULONG   internalFlags = 0;

    if (DeviceObject != NULL) {
        internalFlags = IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT;
    }

    if (Options & IO_IGNORE_SHARE_ACCESS_CHECK) {
        internalFlags |= IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK;
    }

    return IopCreateFile(
            FileHandle,
            DesiredAccess,
            ObjectAttributes,
            IoStatusBlock,
            AllocationSize,
            FileAttributes,
            ShareAccess,
            Disposition,
            CreateOptions,
            EaBuffer,
            EaLength,
            CreateFileType,
            ExtraCreateParameters,
            Options|IO_NO_PARAMETER_CHECKING,
            internalFlags,
            DeviceObject
            );
}

NTSTATUS
IopCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN ULONG InternalFlags,
    IN PVOID DeviceObject
    )

/*++

Routine Description:

    This is the common routine for both NtCreateFile and NtOpenFile to allow
    a user to create or open a file.  This procedure is also used internally
    by kernel mode components, such as the network server, to perform the
    same type of operation, but allows kernel mode code to force checking
    arguments and access to the file, rather than bypassing these checks
    because the code is running in kernel mode.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    DesiredAccess - Supplies the types of access that the caller would like
        to the file.

    ObjectAttributes - Supplies the attributes to be used for the file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.
        This parameter only has an affect if the file is created.  Further,
        if not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    Disposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    EaBuffer - Optionally specifies a set of EAs to be applied to the file
        if it is created.

    EaLength - Supplies the length of the EaBuffer.

    CreateFileType - The type of file to create.

    ExtraCreateParameters - Optionally specifies a pointer to extra create
        parameters.  The format of the parameters depends on the value of
        CreateFileType.

    Options - Specifies the options that are to be used during generation
        of the create IRP.

    DeviceObject - Specifies which device object to use when issuing the create IRP.

Return Value:

    The function value is the final status of the create/open operation.

Warning:

    If a pointer to ExtraCreateParameters is passed the data must be
    readable from kernel mode.


--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    HANDLE handle;
    POPEN_PACKET openPacket;
    BOOLEAN SuccessfulIoParse;
    LARGE_INTEGER initialAllocationSize;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if (Options & IO_NO_PARAMETER_CHECKING) {
        requestorMode = KernelMode;
    }

    openPacket = ExAllocatePoolWithTag( NonPagedPool,
                                        sizeof(OPEN_PACKET),
                                        'pOoI');

    if (openPacket == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (requestorMode != KernelMode || Options & IO_CHECK_CREATE_PARAMETERS) {

        //
        // Check for any invalid parameters.
        //

        if (

            //
            // Check that no invalid file attributes flags were specified.
            //

//          (FileAttributes & ~FILE_ATTRIBUTE_VALID_SET_FLAGS)
            (FileAttributes & ~FILE_ATTRIBUTE_VALID_FLAGS)

            ||

            //
            // Check that no invalid share access flags were specified.
            //

            (ShareAccess & ~FILE_SHARE_VALID_FLAGS)

            ||

            //
            // Ensure that the disposition value is in range.
            //

            (Disposition > FILE_MAXIMUM_DISPOSITION)

            ||

            //
            // Check that no invalid create options were specified.
            //

            (CreateOptions & ~FILE_VALID_OPTION_FLAGS)

            ||

            //
            // If the caller specified synchronous I/O, then ensure that
            // (s)he also asked for synchronize desired access to the
            // file.
            //

            (CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT) &&
            (!(DesiredAccess & SYNCHRONIZE)))

            ||

            //
            // Also, if the caller specified that the file is to be deleted
            // on close, then ensure that delete is specified as one of the
            // desired accesses requested.
            //

            (CreateOptions & FILE_DELETE_ON_CLOSE &&
            (!(DesiredAccess & DELETE)))

            ||

            //
            // Likewise, ensure that if one of the synchronous I/O modes
            // is specified that the other one is not specified as well.
            //

            ((CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ==
                              (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT))

            ||

            //
            // If this create or open is for a directory operation, check
            // that all of the other flags, dispositions, and desired
            // access parameters were also specified correctly.
            //
            // These are as follows:
            //
            //     o  No other flags other than the synchronous I/O flags,
            //        write-through, or open by file ID are set.
            //
            //     o  The disposition value is one of create, open, or
            //        open-if.
            //
            //     o  No non-directory accesses have been specified.
            //

            ((CreateOptions & FILE_DIRECTORY_FILE)
             && !(CreateOptions & FILE_NON_DIRECTORY_FILE)
             && ((CreateOptions & ~(FILE_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_ALERT |
                                    FILE_SYNCHRONOUS_IO_NONALERT |
                                    FILE_WRITE_THROUGH |
                                    FILE_COMPLETE_IF_OPLOCKED |
                                    FILE_OPEN_FOR_BACKUP_INTENT |
                                    FILE_DELETE_ON_CLOSE |
                                    FILE_OPEN_FOR_FREE_SPACE_QUERY |
                                    FILE_OPEN_BY_FILE_ID |
                                    FILE_NO_COMPRESSION|
                                    FILE_OPEN_REPARSE_POINT))
                 || ((Disposition != FILE_CREATE)
                     && (Disposition != FILE_OPEN)
                     && (Disposition != FILE_OPEN_IF))
                )
            )

            ||

            //
            //  FILE_COMPLETE_IF_OPLOCK and FILE_RESERVE_OPFILTER are
            //  incompatible options.
            //

            ((CreateOptions & FILE_COMPLETE_IF_OPLOCKED) &&
             (CreateOptions & FILE_RESERVE_OPFILTER))

            ||

            //
            // Fail the create if desired access is zero.
            //
            (IopFailZeroAccessCreate && !DesiredAccess)

            ||

            //
            // Finally, if the no intermediate buffering option was
            // specified, ensure that the caller did not also request
            // append access to the file.
            //

            (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING &&
            (DesiredAccess & FILE_APPEND_DATA)) ) {

            ExFreePool(openPacket);
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Check the file type specific creation parameters.
        //

        if (CreateFileType == CreateFileTypeNone) {

            NOTHING;

        } else if (CreateFileType == CreateFileTypeNamedPipe) {

            if (!ARGUMENT_PRESENT( ExtraCreateParameters ) ) {

                ExFreePool(openPacket);
                return STATUS_INVALID_PARAMETER;

            } else {

                PNAMED_PIPE_CREATE_PARAMETERS NamedPipeCreateParameters;

                NamedPipeCreateParameters = ExtraCreateParameters;

                //
                // Check the parameters for creating a named pipe to
                // ensure that no invalid parameters were passed.
                //

                if (

                    //
                    // Check the NamedPipeType field to ensure that it
                    // is within range.
                    //

                    (NamedPipeCreateParameters->NamedPipeType >
                        FILE_PIPE_MESSAGE_TYPE)

                    ||

                    //
                    // Check the ReadMode field to ensure that it is
                    // within range.
                    //

                    (NamedPipeCreateParameters->ReadMode >
                        FILE_PIPE_MESSAGE_MODE)

                    ||

                    //
                    // Check the CompletionMode field to ensure that
                    // it is within range.
                    //

                    (NamedPipeCreateParameters->CompletionMode >
                        FILE_PIPE_COMPLETE_OPERATION)

                    ||

                    //
                    // Check the ShareAccess parameter to ensure that
                    // it does not specify shared delete access.  The
                    // Named Pipe File System itself will need to ensure
                    // that at least one of SHARE_READ or SHARE_WRITE
                    // is specified if the first instance of the pipe
                    // is being created.
                    //

                    (ShareAccess & FILE_SHARE_DELETE)

                    ||

                    //
                    // Check the Disposition parameter to ensure that
                    // is does not specify anything other than create,
                    // open, or open if.
                    //

                    (Disposition < FILE_OPEN || Disposition > FILE_OPEN_IF)

                    ||

                    //
                    // Finally, check the CreateOptions parameter to
                    // ensure that it does not contain any invalid
                    // options for named pipes.
                    //

                    (CreateOptions & ~FILE_VALID_PIPE_OPTION_FLAGS)) {
                    ExFreePool(openPacket);
                    return STATUS_INVALID_PARAMETER;
                }

            }

        } else if (CreateFileType == CreateFileTypeMailslot) {

            if (!ARGUMENT_PRESENT( ExtraCreateParameters ) ) {

                ExFreePool(openPacket);
                return STATUS_INVALID_PARAMETER;

            } else {

                PMAILSLOT_CREATE_PARAMETERS mailslotCreateParameters;

                mailslotCreateParameters = ExtraCreateParameters;

                //
                // Check the parameters for creating a mailslot to ensure
                // that no invalid parameters were passed.
                //

                if (

                    //
                    // Check the ShareAccess parameter to ensure that
                    // it does not specify shared delete access.
                    //

                    (ShareAccess & FILE_SHARE_DELETE)

                    ||

                    //
                    // Check the ShareAccess parameter to ensure that
                    // shared write access is specified.
                    //

                    !(ShareAccess & ~FILE_SHARE_WRITE)

                    ||

                    //
                    // Check the Disposition parameter to ensure that
                    // it specifies that the file is to be created.
                    //

                    (Disposition != FILE_CREATE)

                    ||

                    //
                    // Check the CreateOptions parameter to ensure that
                    // it does not contain any options that are invalid
                    // for mailslots.
                    //

                    (CreateOptions & ~FILE_VALID_MAILSLOT_OPTION_FLAGS)) {
                    ExFreePool(openPacket);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
    }

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the
        // arguments and capture them as necessary.  If any failures occur,
        // the condition handler will be invoked to handle them.  It will
        // simply cleanup and return an access violation status code back
        // to the system service dispatcher.
        //

        openPacket->EaBuffer = (PFILE_FULL_EA_INFORMATION) NULL;

        try {

            //
            // The FileHandle parameter must be writeable by the caller.
            // Probe it for a write operation.
            //

            ProbeAndWriteHandle( FileHandle, 0L );

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The AllocationSize parameter must be readable by the caller
            // if it is present.  If so, probe and capture it.
            //

            if (ARGUMENT_PRESENT( AllocationSize )) {
                ProbeForReadSmallStructure( AllocationSize,
                              sizeof( LARGE_INTEGER ),
                              sizeof( ULONG ) );
                initialAllocationSize = *AllocationSize;
            } else {
                initialAllocationSize.QuadPart = 0;
            }

            if (initialAllocationSize.QuadPart < 0) {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to access the
            // caller's parameters.  Simply return the reason for the
            // exception as the service status.
            //

            ExFreePool(openPacket);
            return GetExceptionCode();
        }

        //
        // Finally, if an EaBuffer was specified, ensure that it is readable
        // from the caller's mode and capture it.
        //

        if (ARGUMENT_PRESENT( EaBuffer ) && EaLength) {

            ULONG errorOffset;

            try {

                ProbeForRead( EaBuffer, EaLength, sizeof( ULONG ) );
                openPacket->EaBuffer = ExAllocatePoolWithQuotaTag( NonPagedPool,
                                                                  EaLength,
                                                                  'aEoI' );
                openPacket->EaLength = EaLength;
                RtlCopyMemory( openPacket->EaBuffer, EaBuffer, EaLength );

                //
                // Walk the buffer and ensure that its format is valid.  Note
                // that has been probed.
                //

                status = IoCheckEaBufferValidity( openPacket->EaBuffer,
                                                  EaLength,
                                                  &errorOffset );

                if (!NT_SUCCESS( status )) {
                    IoStatusBlock->Status = status;
                    IoStatusBlock->Information = errorOffset;
                    ExRaiseStatus( status );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while attempting to access the
                // caller's parameters.  Check to see whether or not an EA
                // buffer was allocated and deallocate if so.
                //

                if (openPacket->EaBuffer != NULL) {
                    ExFreePool( openPacket->EaBuffer );
                }

                ExFreePool(openPacket);
                return GetExceptionCode();

            }

        } else {

            //
            // No EAs were specified.
            //

            openPacket->EaBuffer = (PVOID) NULL;
            openPacket->EaLength = 0L;
        }

    } else {

        //
        // The caller's mode is kernel.  Copy the input parameters to their
        // expected locations for later use.  Also, put move attach device
        // flag where it belongs.
        //

        if (CreateOptions & IO_ATTACH_DEVICE_API) {
            Options |= IO_ATTACH_DEVICE;
            CreateOptions &= ~IO_ATTACH_DEVICE_API;

        }

        if (ARGUMENT_PRESENT( AllocationSize )) {
            initialAllocationSize = *AllocationSize;
        } else {
            initialAllocationSize.QuadPart = 0;
        }

        if (ARGUMENT_PRESENT( EaBuffer ) && EaLength) {

            ULONG errorOffset;

            openPacket->EaBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                                         EaLength,
                                                         'aEoI' );
            if (!openPacket->EaBuffer) {
                ExFreePool(openPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            openPacket->EaLength = EaLength;
            RtlCopyMemory( openPacket->EaBuffer, EaBuffer, EaLength );

            //
            // Walk the buffer and ensure that its format is valid.  Note
            // that has been probed.
            //

            status = IoCheckEaBufferValidity( openPacket->EaBuffer,
                                              EaLength,
                                              &errorOffset );

            if (!NT_SUCCESS( status )) {
                ExFreePool(openPacket->EaBuffer);
                IoStatusBlock->Status = status;
                IoStatusBlock->Information = errorOffset;
                ExFreePool(openPacket);
                return status;
            }

        } else {
            openPacket->EaBuffer = (PVOID) NULL;
            openPacket->EaLength = 0L;
        }
    }

    //
    // Now fill in an Open Packet (OP) to be used in calling the device object
    // parse routine.  This packet will allow information to be passed between
    // this routine and the parse routine so that a common context may be kept.
    // For most services this would be done with an I/O Request Packet (IRP),
    // but this cannot be done here because the number of stack entries which
    // need to be allocated in the IRP is not yet known.
    //

    openPacket->Type = IO_TYPE_OPEN_PACKET;
    openPacket->Size = sizeof( OPEN_PACKET );
    openPacket->ParseCheck = 0L;
    openPacket->AllocationSize = initialAllocationSize;
    openPacket->CreateOptions = CreateOptions;
    openPacket->FileAttributes = (USHORT) FileAttributes;
    openPacket->ShareAccess = (USHORT) ShareAccess;
    openPacket->Disposition = Disposition;
    openPacket->Override = FALSE;
    openPacket->QueryOnly = FALSE;
    openPacket->DeleteOnly = FALSE;
    openPacket->Options = Options;
    openPacket->RelatedFileObject = (PFILE_OBJECT) NULL;
    openPacket->CreateFileType = CreateFileType;
    openPacket->ExtraCreateParameters = ExtraCreateParameters;
    openPacket->TraversedMountPoint = FALSE;
    openPacket->InternalFlags = InternalFlags;
    openPacket->TopDeviceObjectHint = DeviceObject;

    //
    // Assume that the operation is going to be successful.
    //

    openPacket->FinalStatus = STATUS_SUCCESS;

    //
    // Zero the file object field in the OP so the parse routine knows that
    // this is the first time through.  For reparse operations it will continue
    // to use the same file object that it allocated the first time.
    //

    openPacket->FileObject = (PFILE_OBJECT) NULL;

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Attempt to open the file object by name.  This will yield the handle
    // that the user is to use as his handle to the file in all subsequent
    // calls, if it works.
    //
    // This call performs a whole lot of the work for actually getting every-
    // thing set up for the I/O system.  The object manager will take the name
    // of the file and will translate it until it reaches a device object (or
    // it fails).  If the former, then it will invoke the parse routine set up
    // by the I/O system for device objects.  This routine will actually end
    // up creating the file object, allocating an IRP, filling it in, and then
    // invoking the driver's dispatch routine with the packet.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 DesiredAccess,
                                 openPacket,
                                 &handle );

    //
    // If an EA buffer was allocated, deallocate it now before attempting to
    // determine whether or not the operation was successful so that it can be
    // done in one place rather than in two places.
    //

    if (openPacket->EaBuffer) {
        ExFreePool( openPacket->EaBuffer );
    }

    //
    // Check the status of the open.  If it was not successful, cleanup and
    // get out.  Notice that it is also possible, because this code does not
    // explicitly request that a particular type of object (because the Object
    // Manager does not check when a parse routine is present and because the
    // name first refers to a device object and then a file object), a check
    // must be made here to ensure that what was returned was really a file
    // object.  The check is to see whether the device object parse routine
    // believes that it successfully returned a pointer to a file object.  If
    // it does, then OK;  otherwise, something went wrong somewhere.
    //

    SuccessfulIoParse = (BOOLEAN) (openPacket->ParseCheck == OPEN_PACKET_PATTERN);

    if (!NT_SUCCESS( status ) || !SuccessfulIoParse) {

        if (NT_SUCCESS( status )) {

            //
            // The operation was successful as far as the object system is
            // concerned, but the I/O system device parse routine was never
            // successfully completed so this operation has actually completed
            // with an error because of an object mismatch.  Therefore, this is
            // the wrong type of object so dereference whatever was actually
            // referenced by closing the handle that was created for it.
            // We have to do a ZwClose as this handle can be a kernel handle if
            // IoCreateFile was called by a driver.
            //

            ZwClose( handle );
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        //
        // If the final status according to the device parse routine
        // indicates that the operation was not successful, then use that
        // routine's final status because it is more descriptive than the
        // status which was returned by the object manager.
        //

        if (!NT_SUCCESS( openPacket->FinalStatus )) {
            status = openPacket->FinalStatus;

            if (NT_WARNING( status )) {

                try {

                    IoStatusBlock->Status = openPacket->FinalStatus;
                    IoStatusBlock->Information = openPacket->Information;

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    status = GetExceptionCode();

                }

            }

        } else if (openPacket->FileObject != NULL && !SuccessfulIoParse) {

            //
            // Otherwise, one of two things occurred:
            //
            //     1)  The parse routine was invoked at least once and a
            //         reparse was performed but the parse routine did not
            //         actually complete.
            //
            //     2)  The parse routine was successful so everything worked
            //         but the object manager incurred an error after the
            //         parse routine completed.
            //
            // For case #1, there is an outstanding file object that still
            // exists.  This must be cleaned up.
            //
            // For case #2, nothing must be done as the object manager has
            // already dereferenced the file object.  Note that this code is
            // not invoked if the parse routine completed with a successful
            // status return (SuccessfulIoParse is TRUE).
            //

            if (openPacket->FileObject->FileName.Length != 0) {
                ExFreePool( openPacket->FileObject->FileName.Buffer );
            }
            openPacket->FileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            ObDereferenceObject( openPacket->FileObject );
        }

        //
        // When an NTFS file junction or an NTFS directory junction is traversed
        // OBJ_MAX_REPARSE_ATTEMPTS namy times, the object manager gives up and
        // returns the code STATUS_OBJECT_NAME_NOT_FOUND.
        //
        // This can happen in the following cases:
        //
        //      1) One encounters a legal chain of directory junctions that happen
        //         to be longer than the value of the above constant.
        //
        //      2) One encounters a self-referential file or directory junction that
        //         is, in effect, a tight name cycle.
        //
        //      3) One encounters a name cycle composed of several NTFS junctions.
        //
        // To improve on this return code see if  openPacket->Information  is
        // the trace of an NTFS name junction.
        //

        if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
            (openPacket->Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            status = STATUS_REPARSE_POINT_NOT_RESOLVED;
        }

    } else {

        //
        // At this point, the open/create operation has been successfully
        // completed.  There is a handle to the file object, which has been
        // created, and the file object has been signaled.
        //
        // The remaining work to be done is to complete the operation.  This is
        // performed as follows:
        //
        //    1.  The file object has been signaled, so no work needs to be done
        //        for it.
        //
        //    2.  The file handle is returned to the user.
        //
        //    3.  The I/O status block is written with the final status.
        //

        openPacket->FileObject->Flags |= FO_HANDLE_CREATED;

        ASSERT( openPacket->FileObject->Type == IO_TYPE_FILE );

        try {

            //
            // Return the file handle.
            //

            *FileHandle = handle;

            //
            // Write the I/O status into the caller's buffer.
            //

            IoStatusBlock->Information = openPacket->Information;
            IoStatusBlock->Status = openPacket->FinalStatus;
            status = openPacket->FinalStatus;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            status = GetExceptionCode();

        }

    }

    //
    // If the parse routine successfully created a file object then
    // derefence it here.
    //

    if (SuccessfulIoParse && openPacket->FileObject != NULL) {

        ObDereferenceObject( openPacket->FileObject );
    }

    ExFreePool(openPacket);
    return status;
}

PKEVENT
IoCreateNotificationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    This routine creates a named notification event for use in notifying
    different system components or drivers that an event occurred.

Arguments:

    EventName - Supplies the full name of the event.

    EventHandle - Supplies a location to return a handle to the event.

Return Value:

    The function value is a pointer to the created/opened event, or NULL if
    the event could not be created/opened.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE eventHandle;
    PKEVENT eventObject;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes.
    //

    InitializeObjectAttributes( &objectAttributes,
                                EventName,
                                OBJ_OPENIF|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Now create or open the event.
    //

    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            &objectAttributes,
                            NotificationEvent,
                            TRUE );
    if (!NT_SUCCESS( status )) {
        return (PKEVENT) NULL;
    }

    //
    // Reference the object by its handle to get a pointer that can be returned
    // to the caller.
    //

    (VOID) ObReferenceObjectByHandle( eventHandle,
                                      0,
                                      ExEventObjectType,
                                      KernelMode,
                                      (PVOID *) &eventObject,
                                      NULL );
    ObDereferenceObject( eventObject );

    //
    // Return the handle and the pointer to the event.
    //

    *EventHandle = eventHandle;

    return eventObject;
}

PFILE_OBJECT
IoCreateStreamFileObject(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    )
{
    return (IoCreateStreamFileObjectEx(FileObject, DeviceObject, NULL));
}


PFILE_OBJECT
IoCreateStreamFileObjectEx(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PHANDLE FileHandle OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a new file object that represents an
    alternate data stream for an existing file object.  The input file object
    represents the file object that already exists for a file, and the newly
    created stream file object is used to access other parts of the file
    other than the data.  Some uses of stream file objects are the EAs or
    the SECURITY_DESCRIPTORs on the file.  The stream file object allows
    the file system to cache these parts of the file just as if they were
    an entire to themselves.

    It is also possible to use stream file objects to represent virtual
    volume files.  This allows various parts of the on-disk structure to
    be viewed as a virtual file and therefore be cached using the same logic
    in the file system.  For this case, the device object pointer is used
    to create the file object.

Arguments:

    FileObject - Pointer to the file object to which the new stream file
        is related.  This pointer is optional.

    DeviceObject - Pointer to the device object on which the stream file
        is to be opened.  This pointer is not optional if the FileObject
        pointer is not specified.

    FileHandle - Out parameter for handle if necessary.

Return Value:

    The function value is a pointer to the newly created stream file object.

--*/

{
    PFILE_OBJECT newFileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by getting the device object from either the file object or
    // the device object parameter.
    //

    if (ARGUMENT_PRESENT( FileObject )) {
        DeviceObject = FileObject->DeviceObject;
    }

    //
    // Increment the reference count for the target device object.  Note
    // that no check is made to determine whether or not the device driver
    // is attempting to unload since this is an implicit open of a pseudo-
    // file that is being made, not a real file open request.  In essence,
    // no new file is really being opened.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );

    //
    // Initialize the object attributes that will be used to create the file
    // object.
    //

    InitializeObjectAttributes( &objectAttributes,
                                (PUNICODE_STRING) NULL,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the new file object.
    //

    status = ObCreateObject( KernelMode,
                             IoFileObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) sizeof( FILE_OBJECT ),
                             (ULONG) sizeof( FILE_OBJECT ),
                             0,
                             (PVOID *) &newFileObject );

    if (!NT_SUCCESS( status )) {
        IopDecrementDeviceObjectRef( DeviceObject, FALSE, FALSE );
        ExRaiseStatus( status );
    }

    //
    // Initialize the common fields of the file object.
    //

    RtlZeroMemory( newFileObject, sizeof( FILE_OBJECT ) );
    newFileObject->Type = IO_TYPE_FILE;
    newFileObject->Size = sizeof( FILE_OBJECT );
    newFileObject->DeviceObject = DeviceObject;
    newFileObject->Flags = FO_STREAM_FILE;
    KeInitializeEvent( &newFileObject->Event, SynchronizationEvent, FALSE );

    //
    // Insert the device object into the table.  Note that this is done w/a
    // pointer bias so that the object cannot go away if some random user
    // application closes the handle before this code is finished w/it.
    //

    status = ObInsertObject( newFileObject,
                             NULL,
                             FILE_READ_DATA,
                             1,
                             (PVOID *) &newFileObject,
                             &handle );

    if (!NT_SUCCESS( status )) {
        ExRaiseStatus( status );
    }

    //
    // The insert completed successfully.  Update the bookkeeping so that the
    // fact that there is a handle is reflected.
    //

    newFileObject->Flags |= FO_HANDLE_CREATED;
    ASSERT( newFileObject->Type == IO_TYPE_FILE );

    //
    // Synchronize here with the file system to make sure that
    // volumes don't go away while en route to the FS.
    //

    if (DeviceObject->Vpb) {
        IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                      (PLONG) &DeviceObject->Vpb->ReferenceCount );
    }

    //
    // Finally, close the handle to the file. and clear the forward cluster
    //

    if (FileHandle == NULL) {
        ObCloseHandle( handle , KernelMode);
    } else {
        *FileHandle = handle;

        //
        // Get rid of the reference in ObInsertObject.
        //

        ObDereferenceObject(newFileObject);
    }

    ASSERT( NT_SUCCESS( status ) );

    return newFileObject;
}



PFILE_OBJECT
IoCreateStreamFileObjectLite(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a new file object that represents an
    alternate data stream for an existing file object.  The input file object
    represents the file object that already exists for a file, and the newly
    created stream file object is used to access other parts of the file
    other than the data.  Some uses of stream file objects are the EAs or
    the SECURITY_DESCRIPTORs on the file.  The stream file object allows
    the file system to cache these parts of the file just as if they were
    an entire to themselves.

    It is also possible to use stream file objects to represent virtual
    volume files.  This allows various parts of the on-disk structure to
    be viewed as a virtual file and therefore be cached using the same logic
    in the file system.  For this case, the device object pointer is used
    to create the file object.

    This call differs from IoCreateStreamFileObject in that it performs no
    handle management and does not result in a call to the file system
    cleanup entry.

Arguments:

    FileObject - Pointer to the file object to which the new stream file
        is related.  This pointer is optional.

    DeviceObject - Pointer to the device object on which the stream file
        is to be opened.  This pointer is not optional if the FileObject
        pointer is not specified.

Return Value:

    The function value is a pointer to the newly created stream file object.

--*/

{
    PFILE_OBJECT newFileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by getting the device object from either the file object or
    // the device object parameter.
    //

    if (ARGUMENT_PRESENT( FileObject )) {
        DeviceObject = FileObject->DeviceObject;
    }

    //
    // if the driver has been marked for an unload or deleted operation, and
    // the reference count goes to zero, then the driver may need to be
    // unloaded or deleted at this point.
    // file that is being made, not a real file open request.  In essence,
    // no new file is really being opened.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );

    //
    // Initialize the object attributes that will be used to create the file
    // object.
    //

    InitializeObjectAttributes( &objectAttributes,
                                (PUNICODE_STRING) NULL,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the new file object.
    //

    status = ObCreateObject( KernelMode,
                             IoFileObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) sizeof( FILE_OBJECT ),
                             (ULONG) sizeof( FILE_OBJECT ),
                             0,
                             (PVOID *) &newFileObject );

    if (!NT_SUCCESS( status )) {
        IopDecrementDeviceObjectRef( DeviceObject, FALSE, FALSE );
        ExRaiseStatus( status );
    }

    //
    // Initialize the common fields of the file object.
    //

    RtlZeroMemory( newFileObject, sizeof( FILE_OBJECT ) );
    newFileObject->Type = IO_TYPE_FILE;
    newFileObject->Size = sizeof( FILE_OBJECT );
    newFileObject->DeviceObject = DeviceObject;
    newFileObject->Flags = FO_STREAM_FILE;
    KeInitializeEvent( &newFileObject->Event, SynchronizationEvent, FALSE );

    //
    //  Clean up from the creation.
    //

    ObFreeObjectCreateInfoBuffer(OBJECT_TO_OBJECT_HEADER(newFileObject)->ObjectCreateInfo);
    OBJECT_TO_OBJECT_HEADER(newFileObject)->ObjectCreateInfo = NULL;

    newFileObject->Flags |= FO_HANDLE_CREATED;
    ASSERT( newFileObject->Type == IO_TYPE_FILE );

    //
    // Synchronize here with the file system to make sure that
    // volumes don't go away while en route to the FS.
    //

    if (DeviceObject->Vpb) {
        IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                      (PLONG) &DeviceObject->Vpb->ReferenceCount );
    }

    return newFileObject;
}


NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine is invoked to assign a symbolic link name to a device.

Arguments:

    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.

    DeviceName - Supplies the name to which the symbolic link name refers.

Return Value:

    The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                SePublicDefaultUnrestrictedSd );

    //
    // Note that the following assignment can fail (because it is not system
    // initialization time and therefore the \ARCname directory does not
    // exist - if this is really a call to IoAssignArcName), but that is fine.
    //

    status = ZwCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         DeviceName );
    if (NT_SUCCESS( status )) {
        ZwClose( linkHandle );
    }

    return status;
}

PKEVENT
IoCreateSynchronizationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    This routine creates a named synchronization event for use in serialization
    of access to hardware between two otherwise non-related drivers.  The event
    is created if it does not already exist, otherwise it is simply opened.

Arguments:

    EventName - Supplies the full name of the event.

    EventHandle - Supplies a location to return a handle to the event.

Return Value:

    The function value is a pointer to the created/opened event, or NULL if
    the event could not be created/opened.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE eventHandle;
    PKEVENT eventObject;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes.
    //

    InitializeObjectAttributes( &objectAttributes,
                                EventName,
                                OBJ_OPENIF|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Now create or open the event.
    //

    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            &objectAttributes,
                            SynchronizationEvent,
                            TRUE );
    if (!NT_SUCCESS( status )) {
        return (PKEVENT) NULL;
    }

    //
    // Reference the object by its handle to get a pointer that can be returned
    // to the caller.
    //

    (VOID) ObReferenceObjectByHandle( eventHandle,
                                      0,
                                      ExEventObjectType,
                                      KernelMode,
                                      (PVOID *) &eventObject,
                                      NULL );
    ObDereferenceObject( eventObject );

    //
    // Return the handle and the pointer to the event.
    //

    *EventHandle = eventHandle;

    return eventObject;
}

NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine is invoked to assign an unprotected symbolic link name to
    a device.  That is, a symbolic link that can be dynamically reassigned
    without any special authorization. The security descriptor is inherited
    from the container (like DosDevices) which has the right symbolic link.


Arguments:

    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.

    DeviceName - Supplies the name to which the symbolic link name refers.

Return Value:

    The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();


    //
    // Initialize the object attributes for the symbolic link.
    // We pass a NULL so that the security descriptor is inherited
    // from the parent.
    // Prior to .NET server this routine set a NULL DACL that could be overridden
    // by inheritable ACLs. This was essentially the same as passing a NULL to
    // ObjectAttributes.
    //

    InitializeObjectAttributes( &objectAttributes,
                            SymbolicLinkName,
                            OBJ_PERMANENT | OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                            (HANDLE) NULL,
                            NULL );

    //
    // Note that the following assignment can fail (because it is not system
    // initialization time and therefore the \ARCname directory does not
    // exist - if this is really a call to IoAssignArcName), but that is fine.
    //

    status = ZwCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         DeviceName );
    if (NT_SUCCESS( status )) {
        ZwClose( linkHandle );
    }

    return status;
}

VOID
IoDeleteController(
    IN PCONTROLLER_OBJECT ControllerObject
    )

/*++

Routine Description:

    This routine deletes the specified controller object from the system
    so that it may no longer be referenced from a driver.  It is invoked
    when either the driver is being unloaded from the system, or the driver's
    initialization routine failed to properly initialize the device or a
    fatal driver initialization error was encountered.

Arguments:

    ControllerObject - Pointer to the controller object that is to be
        deleted.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // The controller was created as a temporary object, and all of the
    // handles for the object have already been closed.  At this point,
    // simply dereferencing the object will cause it to be deleted.
    //

    ObDereferenceObject( ControllerObject );
}

VOID
IopRemoveTimerFromTimerList(
    IN PIO_TIMER timer
    )
{
    KIRQL irql;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (irql);
#endif

    ExAcquireFastLock( &IopTimerLock, &irql );
    RemoveEntryList( &timer->TimerList );
    if (timer->TimerFlag) {
        IopTimerCount--;
    }
    ExReleaseFastLock( &IopTimerLock, irql );
}

VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine deletes the specified device object from the system so that
    it may no longer be referenced.  It is invoked when either the device
    driver is being unloaded from the system, or the driver's initialization
    routine failed to properly initialize the device or a fatal driver
    initialization error was encountered, or when the device is being removed
    from the system.

Arguments:

    DeviceObject - Pointer to the device object that is to be deleted.

Return Value:

    None.

--*/

{
    KIRQL irql;

    IOV_DELETE_DEVICE(DeviceObject);

    //
    // Check to see whether or not the device has registered a shutdown
    // handler if necessary, and if so, unregister it.
    //

    if (DeviceObject->Flags & DO_SHUTDOWN_REGISTERED) {
        IoUnregisterShutdownNotification( DeviceObject );
    }

    //
    // Release the pool that was allocated to contain the timer dispatch
    // routine and its associated context if there was one.
    //

    if (DeviceObject->Timer) {
        PIO_TIMER timer;

        timer = DeviceObject->Timer;
        IopRemoveTimerFromTimerList(timer);
        ExFreePool( timer );
    }

    //
    // If this device has a name, then mark the
    // object as temporary so that when it is dereferenced it will be
    // deleted.
    //

    if (DeviceObject->Flags & DO_DEVICE_HAS_NAME) {
        ObMakeTemporaryObject( DeviceObject );
    }

    //
    // PoRunDownDeviceObject will clean up any power management
    // structures attached to the device object.
    //

    PoRunDownDeviceObject(DeviceObject);

    //
    // Mark the device object as deleted.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    DeviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_DELETE_PENDING;

    if (!DeviceObject->ReferenceCount) {
        IopCompleteUnloadOrDelete( DeviceObject, FALSE, irql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    }
}


NTSTATUS
IopDeleteSessionSymLinks(
    IN PUNICODE_STRING LinkName
    )
/*++

Routine Description:

    This routine is called from IoDeleteSymbolic Link. It enumerates all the
    Terminal Server session specific object directories and deletes the specified
    symbolic link from the DosDevices object directory of each sesssion. This
    routine is only called when Terminal Services is enabled.

Arguments:

    SymbolicLinkName - Provides the Unicode name string to be deassigned.

Return Values:

    None.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING SymbolicLinkName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    HANDLE linkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan;
    ULONG Context = 0;
    ULONG ReturnedLength;
    PWCHAR NameBuf;
    PUCHAR DirInfoBuffer;
    ULONG Size;
    WCHAR Prefix[13]; // sizeof L"\\DosDevices\\"



    //
    // Only delete links that start with \DosDevices\
    //

    if (LinkName->Length < (sizeof(L"\\DosDevices\\"))) {
        return STATUS_SUCCESS;
    }
    RtlInitUnicodeString( &UnicodeString, L"\\DosDevices\\" );

    wcsncpy(Prefix,LinkName->Buffer,(sizeof(L"\\DosDevices\\")/sizeof(WCHAR)) - 1);
    RtlInitUnicodeString( &SymbolicLinkName, Prefix);

    if (RtlCompareUnicodeString(&UnicodeString, &SymbolicLinkName,TRUE)) {

        return STATUS_SUCCESS;

    }


    //
    // Open the root Sessions Directory.
    //
    RtlInitUnicodeString( &UnicodeString, L"\\Sessions" );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );

    Status = ZwOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (NT_SUCCESS( Status )) {


        //
        // Since SessionId is a ULONG , the prefix (\\Sessions\\<SessionId>\\DosDevices)
        // cannot be more that 128 characters in length
        //
        Size = (LinkName->Length + 128) * sizeof(WCHAR);
        NameBuf = (PWCHAR)ExAllocatePoolWithTag(PagedPool, Size, ' oI');

        if (NameBuf == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        SymbolicLinkName.Buffer = (PWSTR)NameBuf;
        SymbolicLinkName.Length = (USHORT)Size;
        SymbolicLinkName.MaximumLength = (USHORT)Size;


        //
        // 4k should be more than enough to query a directory object entry
        //
        Size = 4096;
        DirInfoBuffer = (PUCHAR)ExAllocatePoolWithTag(PagedPool, Size, ' oI');

        if (DirInfoBuffer == NULL) {
            ExFreePool(NameBuf);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RestartScan = TRUE;
        DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;


        while (TRUE) {

            Status = ZwQueryDirectoryObject( DirectoryHandle,
                                             (PVOID)DirInfo,
                                             Size,
                                             TRUE,
                                             RestartScan,
                                             &Context,
                                             &ReturnedLength
                                           );

            RestartScan = FALSE;

            //
            //  Check the status of the operation.
            //

            if (!NT_SUCCESS( Status )) {
                if (Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                    }

                break;
                }


            //
            // This generates session specific symbolic link path
            // \Sessions\<id>\DosDevices\<LinkName>
            //
            RtlInitUnicodeString( &UnicodeString, L"\\Sessions\\" );
            RtlCopyUnicodeString( &SymbolicLinkName, &UnicodeString );
            RtlAppendUnicodeStringToString( &SymbolicLinkName, &(DirInfo->Name) );
            RtlAppendUnicodeStringToString( &SymbolicLinkName, LinkName );
            //
            // Begin by initializing the object attributes for the symbolic link.
            //

            InitializeObjectAttributes( &Attributes,
                                        &SymbolicLinkName,
                                        OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                        NULL,
                                        NULL );

            //
            // Open the symbolic link itself so that it can be marked temporary and
            // closed.
            //

            Status = ZwOpenSymbolicLinkObject( &linkHandle,
                                               DELETE,
                                               &Attributes );
            if (NT_SUCCESS( Status )) {

                //
                // The symbolic link was successfully opened.  Attempt to make it a
                // temporary object, and then close the handle.  This will cause the
                // object to go away.
                //

                Status = ZwMakeTemporaryObject( linkHandle );
                if (NT_SUCCESS( Status )) {
                    ZwClose( linkHandle );
                }
            }



         }

         ZwClose(DirectoryHandle);
         ExFreePool(NameBuf);
         ExFreePool(DirInfoBuffer);
    }

     return Status;
}


NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is invoked to remove a symbolic link from the system.  This
    generally occurs whenever a driver that has assigned a symbolic link needs
    to exit.  It can also be used when a driver no longer needs to redirect
    a name.

Arguments:

    SymbolicLinkName - Provides the Unicode name string to be deassigned.

Return Values:

    None.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Open the symbolic link itself so that it can be marked temporary and
    // closed.
    //

    status = ZwOpenSymbolicLinkObject( &linkHandle,
                                       DELETE,
                                       &objectAttributes );
    if (NT_SUCCESS( status )) {

        //
        // The symbolic link was successfully opened.  Attempt to make it a
        // temporary object, and then close the handle.  This will cause the
        // object to go away.
        //

        status = ZwMakeTemporaryObject( linkHandle );
        if (NT_SUCCESS( status )) {
            ZwClose( linkHandle );
        }

        //
        // When LUID DosDevices are disabled and Terminal Services are
        // enabled, then remove the possible multiple copies of the symbolic
        // link from the DosDevices in the TS sessions
        // When LUID DosDevices are enabled or TS is not enabled, then
        // the symbolic link is not copied and no cleanup is needed.
        //

        if ((ObIsLUIDDeviceMapsEnabled() == 0) &&
            (ExVerifySuite(TerminalServer) == TRUE)) {

            IopDeleteSessionSymLinks( SymbolicLinkName );
        }
    }


    return status;
}

VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine detaches the device object which is currently attached to the
    target device.

Arguments:

    TargetDevice - Pointer to device object to be detached from.

Return Value:

    None.


--*/

{
    KIRQL irql;
    PDEVICE_OBJECT detachingDevice;
    PDEVOBJ_EXTENSION detachingExtension;

    //
    // Detach the device object attached to the target device.  This also
    // includes decrementing the reference count for the device.  Note that
    // if the driver has been marked for an unload operation, and the
    // reference count goes to zero, then the driver may need to be unloaded
    // at this point.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Tell the Special IRP code the stack has changed. Code that will reexamine
    // the stack takes the database lock, so we can place the call here. This
    // also allows us to assert correct behavoir *before* the stack is torn
    // down.
    //
    IOV_DETACH_DEVICE(TargetDevice);

    detachingDevice = TargetDevice->AttachedDevice;
    detachingExtension = detachingDevice->DeviceObjectExtension;
    ASSERT( detachingExtension->AttachedTo == TargetDevice );

    //
    // Unlink the device from the doubly-linked attachment chain.
    //

    detachingExtension->AttachedTo = NULL;
    TargetDevice->AttachedDevice = NULL;

    if (TargetDevice->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING) &&
        !TargetDevice->ReferenceCount) {
        IopCompleteUnloadOrDelete( TargetDevice, FALSE, irql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    }
}

VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    )

/*++

Routine Description:

    This routine disconnects all of the interrupt objects that were
    initialized and connected by the IoConnectInterrupt routine.  Note
    that no interrupt objects directly connected using the kernel
    services may be input to this routine.

Arguments:

    InterruptObject - Supplies a pointer to the interrupt object allocated
        by the IoConnectInterrupt routine.

Return Value:

    None.

--*/

{
    PIO_INTERRUPT_STRUCTURE interruptStructure;
    ULONG i;

    PAGED_CODE();

    //
    // Obtain a pointer to the builtin interrupt object in the I/O interrupt
    // structure.
    //

    interruptStructure = CONTAINING_RECORD( InterruptObject,
                                            IO_INTERRUPT_STRUCTURE,
                                            InterruptObject );

    //
    // The builtin interrupt object is always used, so simply disconnect
    // it.
    //

    KeDisconnectInterrupt( &interruptStructure->InterruptObject );

    //
    // Now loop through each of the interrupt objects pointed to by the
    // structure and disconnect each.
    //

    for (i = 0; i < MAXIMUM_PROCESSORS; i++) {
        if (interruptStructure->InterruptArray[i] != NULL) {
            KeDisconnectInterrupt( interruptStructure->InterruptArray[i] );
        }
    }

    //
    // Finally, deallocate the memory associated with the entire structure.
    //

    ExFreePool( interruptStructure );
}

VOID
IoEnqueueIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the specified I/O Request Packet (IRP) to the thread's
    IRP pending queue.  The thread that the IRP is queued to is specified by
    the IRP's Thread field.

Arguments:

    Irp - Supplies a pointer to the IRP to be enqueued.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Simply enqueue the IRP to the thread's IRP queue.
    //

    IopQueueThreadIrp( Irp );
    return;
}

BOOLEAN
IoFastQueryNetworkAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine attempts to perform a fast I/O call to obtain the network
    attributes for a file.  This involves a specialized interface between
    this function and the I/O system's device parse method.  This allows the
    parse method to have the file system pseudo-open the file, obtain the
    appropriate attributes for the file, and return them to the caller w/as
    little overhead as possbile from either the Object Manager or the I/O
    system itself.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for opening the
        file (e.g., the file's name, etc).

    DesiredAccess - Supplies the type(s) of access that the caller would like
        to the file.

    OpenOptions - Supplies standard NtOpenFile open options.

    IoStatus - Supplies a pointer to a variable to receive the final status
        of the operation.

    Buffer - Supplies an output buffer to receive the network attributes for
        the specified file.

Return Value:

    The final function value indicates whether or not the fast path could
    be taken successfully.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;

    //
    // Build a parse open packet that tells the parse method to open the
    // file and query its network attributes using the fast path, if it
    // exists for this file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.CreateOptions = OpenOptions | FILE_OPEN_REPARSE_POINT;
    openPacket.Options = IO_FORCE_ACCESS_CHECK;
    openPacket.NetworkInformation = Buffer;
    openPacket.QueryOnly = TRUE;
    openPacket.FullAttributes = TRUE;
    openPacket.LocalFileObject = &localFileObject;

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file using the fast
    // path open and perform the query, effectively closing it as well.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 KernelMode,
                                 NULL,
                                 DesiredAccess,
                                 &openPacket,
                                 &handle );

    //
    // The opeation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.  The QueryOnly field is
    // set to whether or not the fast path was invoked.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {

        //
        // The parse routine was not invoked properly so the operation did
        // not work at all.
        //

        if (NT_SUCCESS(status)) {
            ZwClose(handle);
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        IoStatus->Status = status;
    } else {

        //
        // The fast path routine was successfully invoked so return the
        // final status of the operation.
        //

        IoStatus->Status = openPacket.FinalStatus;
        IoStatus->Information = openPacket.Information;
    }
    return TRUE;
}

VOID
IoFreeController(
    IN PCONTROLLER_OBJECT ControllerObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified controller object.
    No checks are made to ensure that the controller is really allocated
    to a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the controller
    object it will be pulled from the queue and its execution routine will
    be invoked.

Arguments:

    ControllerObject - Pointer to the controller object to be deallocated.

Return Value:

    None.

--*/

{
    PKDEVICE_QUEUE_ENTRY packet;
    PDEVICE_OBJECT deviceObject;
    IO_ALLOCATION_ACTION action;

    //
    // Simply remove the next entry from the controller's device wait queue.
    // If one was successfully removed, invoke its execution routine.
    //

    packet = KeRemoveDeviceQueue( &ControllerObject->DeviceWaitQueue );
    if (packet != NULL) {
        deviceObject = CONTAINING_RECORD( packet,
                                          DEVICE_OBJECT,
                                          Queue.Wcb.WaitQueueEntry );
        action = deviceObject->Queue.Wcb.DeviceRoutine( deviceObject,
                                                        deviceObject->CurrentIrp,
                                                        0,
                                                        deviceObject->Queue.Wcb.DeviceContext );

        //
        // If the execution routine wants the controller to be deallocate
        // now, deallocate it.
        //

        if (action == DeallocateObject) {
            IoFreeController( ControllerObject );
        }
    }
}

VOID
IoFreeIrp(
    IN PIRP Irp
    )
{
    pIoFreeIrp(Irp);
}


VOID
IopFreeIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deallocates the specified I/O Request Packet.

Arguments:

    Irp - I/O Request Packet to deallocate.

Return Value:

    None.

--*/

{
    PGENERAL_LOOKASIDE lookasideList;
    PP_NPAGED_LOOKASIDE_NUMBER number;
    PKPRCB prcb;

    //
    // Ensure that the data structure being freed is really an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    if (Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }


    ASSERT(IsListEmpty(&(Irp)->ThreadListEntry));
    Irp->Type = 0;

    //
    // Ensure that all of the owners of the IRP have at least been notified
    // that the request is going away.
    //

    ASSERT( Irp->CurrentLocation >= Irp->StackCount );

    //
    // Deallocate the IRP.
    //

    prcb = KeGetCurrentPrcb();
    if (Irp->AllocationFlags & IRP_LOOKASIDE_ALLOCATION) {
        Irp->AllocationFlags ^= IRP_LOOKASIDE_ALLOCATION;
        InterlockedIncrement( &prcb->LookasideIrpFloat );
    }

    if (!(Irp->AllocationFlags & IRP_ALLOCATED_FIXED_SIZE) ||
        (Irp->AllocationFlags & IRP_ALLOCATED_MUST_SUCCEED)) {
        ExFreePool( Irp );

    } else {

        if (IopIrpAutoSizingEnabled() &&
            (Irp->Size != IoSizeOfIrp(IopLargeIrpStackLocations)) &&
            (Irp->Size != IoSizeOfIrp(1))) {

            ExFreePool( Irp );
            return;
        }

        //
        // Store the size in a different field as this will get overwritten by single list entry.
        //

        Irp->IoStatus.Information = Irp->Size;

        number = LookasideSmallIrpList;
        if (Irp->StackCount != 1) {
            number = LookasideLargeIrpList;
        }

        lookasideList = prcb->PPLookasideList[number].P;
        lookasideList->TotalFrees += 1;
        if (ExQueryDepthSList( &lookasideList->ListHead ) >= lookasideList->Depth) {
            lookasideList->FreeMisses += 1;
            lookasideList = prcb->PPLookasideList[number].L;
            lookasideList->TotalFrees += 1;
            if (ExQueryDepthSList( &lookasideList->ListHead ) >= lookasideList->Depth) {
                lookasideList->FreeMisses += 1;
                ExFreePool( Irp );

            } else {
                if (Irp->AllocationFlags & IRP_QUOTA_CHARGED) {
                    Irp->AllocationFlags ^= IRP_QUOTA_CHARGED;
                    ExReturnPoolQuota( Irp );
                }

                InterlockedPushEntrySList( &lookasideList->ListHead,
                                           (PSLIST_ENTRY) Irp );
            }

        } else {
            if (Irp->AllocationFlags & IRP_QUOTA_CHARGED) {
                Irp->AllocationFlags ^= IRP_QUOTA_CHARGED;
                ExReturnPoolQuota( Irp );
            }

            InterlockedPushEntrySList( &lookasideList->ListHead,
                                       (PSLIST_ENTRY) Irp );
        }
    }

    return;
}

VOID
IoFreeMdl(
    IN PMDL Mdl
    )

/*++

Routine Description:

    This routine frees a Memory Descriptor List (MDL).  It only frees the
    specified MDL; any chained MDLs must be freed explicitly through another
    call to this routine.

Arguments:

    Mdl - Pointer to the Memory Descriptor List to be freed.

Return Value:

    None.

--*/

{

    //
    // Tell memory management that this MDL will be re-used.  This will
    // cause MM to unmap any pages that have been mapped for this MDL if
    // it is a partial MDL.
    //

    MmPrepareMdlForReuse(Mdl);
    if (((Mdl->MdlFlags & MDL_ALLOCATED_FIXED_SIZE) == 0) ||
        ((Mdl->MdlFlags & MDL_ALLOCATED_MUST_SUCCEED) != 0)) {
        ExFreePool(Mdl);

    } else {
        ExFreeToPPLookasideList(LookasideMdlList, Mdl);
    }
}

PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine returns the highest level device object associated with
    the specified device.

    N.B. Caller must own the IopDatabaseLock. External callers of this
    function must ensure nobody is attaching or detaching from the stack.
    If they cannot, they *must* use IoGetAttachedDeviceReference.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the attached
        device is to be returned.

Return Value:

    The function value is the highest level device attached to the specified
    device.  If no devices are attached, then the pointer to the device
    object itself is returned.

--*/

{
    //
    // Loop through all of the device object's attached to the specified
    // device.  When the last device object is found that is not attached
    // to, return it.
    //

    while (DeviceObject->AttachedDevice) {
        DeviceObject = DeviceObject->AttachedDevice;
    }

    return DeviceObject;
}

PDEVICE_OBJECT
IoGetAttachedDeviceReference(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine synchronizes with the Io database and returns a refernce
    to the highest level device object associated withthe specified device.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the attached
        device is to be returned.

Return Value:

    The function value is a reference to the highest level device attached
    to the specified device.  If no devices are attached, then the pointer
    to the device object itself is returned.

--*/
{
    KIRQL               irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    DeviceObject = IoGetAttachedDevice (DeviceObject);
    ObReferenceObject (DeviceObject);
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return DeviceObject;
}

PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the base (lowest-level) file system volume device
    object associated with a file.  I.e., it locates the file system w/o
    walking the attached device object list.

Arguments:

    FileObject - Supplies a pointer to the file object for which the base
        file system device object is to be returned.

Return Value:

    The function value is the lowest level volume device object associated
    w/the file.

--*/

{
    PDEVICE_OBJECT deviceObject;

    //
    // If the file object has a mounted Vpb, use its DeviceObject.
    //

    if (FileObject->Vpb != NULL && FileObject->Vpb->DeviceObject != NULL) {
        deviceObject = FileObject->Vpb->DeviceObject;

    //
    // Otherwise, if the real device has a VPB that indicates that it is
    // mounted, then use the file system device object associated with the
    // VPB.
    //

    } else if (!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
               FileObject->DeviceObject->Vpb != NULL &&
               FileObject->DeviceObject->Vpb->DeviceObject != NULL) {

            deviceObject = FileObject->DeviceObject->Vpb->DeviceObject;

    //
    // Otherwise, just return the real device object.
    //

    } else {

        deviceObject = FileObject->DeviceObject;
    }

    ASSERT( deviceObject != NULL );

    //
    // Simply return the resultant file object.
    //

    return deviceObject;
}

PCONFIGURATION_INFORMATION
IoGetConfigurationInformation( VOID )

/*++

Routine Description:

    This routine returns a pointer to the system's device configuration
    information structure so that drivers and the system can determine how
    many different types of devices exist in the system.

Arguments:

    None.

Return Value:

    The function value is a pointer to the configuration information
    structure.

--*/

{
    PAGED_CODE();

    //
    // Simply return a pointer to the built-in configuration information
    // structure.
    //

    return (&ConfigurationInformation);
}

PEPROCESS
IoGetCurrentProcess( VOID )

/*++

Routine Description:

    This routine returns a pointer to the current process.  It is actually
    a jacket routine for the PS version of the same function since device
    drivers using the ntddk header file cannot see into a thread object.

Arguments:

    None.

Return Value:

    The function value is a pointer to the current process.

Note:

    Note that this function cannot be paged because it is invoked at raised
    IRQL in debug builds, which is the only time that the PAGED_CODE macro
    actually does anything.  Therefore, it is impossible to find code that
    invokes this function at raised IRQL in a normal system w/o simply running
    into the "proper conditions".  This is too risky to actually page this
    routine, so it is left nonpaged.

--*/

{
    //
    // Simply return a pointer to the current process.
    //

    return PsGetCurrentProcess();
}

NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine returns a pointer to the device object specified by the
    object name.  It also returns a pointer to the referenced file object
    that has been opened to the device that ensures that the device cannot
    go away.

    To close access to the device, the caller should dereference the file
    object pointer.

Arguments:

    ObjectName - Name of the device object for which a pointer is to be
        returned.

    DesiredAccess - Access desired to the target device object.

    FileObject - Supplies the address of a variable to receive a pointer
        to the file object for the device.

    DeviceObject - Supplies the address of a variable to receive a pointer
        to the device object for the specified device.

Return Value:

    The function value is a referenced pointer to the specified device
    object, if the device exists.  Otherwise, NULL is returned.

--*/

{
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the object attributes to open the device.
    //

    InitializeObjectAttributes( &objectAttributes,
                                ObjectName,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenFile( &fileHandle,
                         DesiredAccess,
                         &objectAttributes,
                         &ioStatus,
                         0,
                         FILE_NON_DIRECTORY_FILE );

    if (NT_SUCCESS( status )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );
        if (NT_SUCCESS( status )) {

            *FileObject = fileObject;

            //
            // Get a pointer to the device object for this file.
            //
            *DeviceObject = IoGetRelatedDeviceObject( fileObject );
        }

        (VOID) ZwClose( fileHandle );
    }

    return status;
}

PDEVICE_OBJECT
IoGetDeviceToVerify(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a pointer to the device object that is to be verified.
    The pointer is set in the thread object by a device driver when the disk
    or CD-ROM media appears to have changed since the last access to the device.

Arguments:

    Thread - Pointer to the thread whose field is to be queried.

Return Value:

    The function value is a pointer to the device to be verified, or NULL.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.


--*/

{
    //
    // Simply return the device to be verified.
    //

    return Thread->DeviceToVerify;
}

NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress
    )
/*++

Routine Description:

    This routine returns a pointer to the client driver object extension.
    This extension was allocated using IoAllocateDriverObjectExtension. If
    an extension with the create Id does not exist for the specified driver
    object then NULL is returned.

Arguments:

    DriverObject - Pointer to driver object owning the extension.

    ClientIdentificationAddress - Supplies the unique identifier which was
        used to create the extension.

Return Value:

    The function value is a pointer to the client driver object extension,
    or NULL.

--*/

{
    KIRQL irql;
    PIO_CLIENT_EXTENSION extension;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    extension = DriverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        if (extension->ClientIdentificationAddress == ClientIdentificationAddress) {
            break;
        }

        extension = extension->NextExtension;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    if (extension == NULL) {
        return NULL;
    }

    return extension + 1;
}

PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    )

/*++

Routine Description:

    This routine returns a pointer to the generic mapping for a file object.

Arguments:

    None.

Return Value:

    A pointer to the generic mapping for a file object.

--*/

{
    PAGED_CODE()

    //
    // Simply return a pointer to the generic mapping for a file object.
    //

    return (PGENERIC_MAPPING)&IopFileMapping;
}

PVOID
IoGetInitialStack(
    VOID
    )

/*++

Routine Description:

    This routine returns the base initial address of the current thread's
    stack.

Arguments:

    None.

Return Value:

    The base initial address of the current thread's stack.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply return the initial stack for this thread.
    //

    return PsGetCurrentThread()->Tcb.InitialStack;
}


NTSTATUS
IoComputeDesiredAccessFileObject(
    IN PFILE_OBJECT FileObject,
    OUT PNTSTATUS DesiredAccess
    )

/*++

Routine Description

    This routine is called by ObReferenceFileObjectForWrite (from NtWriteFile)
    to determine which access is desired for the passed file object.  The desired
    access differs if the FileObject is a file or a pipe.

Arguments

    FileObject - the file object to access

    DesiredAccess - the computed access for the object

Return Value

    STATUS_OBJECT_TYPE_MISMATCH if the object is not of type IoFileObjectType
    STATUS_SUCCESS if successful

--*/

{
    POBJECT_HEADER ObjectHeader = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *DesiredAccess = 0;
    ObjectHeader = OBJECT_TO_OBJECT_HEADER(FileObject);

    if (ObjectHeader->Type == IoFileObjectType) {

        *DesiredAccess = (!(FileObject->Flags & FO_NAMED_PIPE) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA;
        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_OBJECT_TYPE_MISMATCH;
    }

    return Status;
}


PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns a pointer to the actual device object than an I/O
    Request Packet (IRP) should be given to based on the specified file
    object.

    N.B. - Callers of this function must ensure no device object is
    attaching or detaching from this stack for the duration of this call.
    This is because the database lock is *not* held!

Arguments:

    FileObject - Pointer to the file object representing the open file.

Return Value:

    The return value is a pointer to the device object for the driver to
    whom the request is to be given.

--*/

{
    PDEVICE_OBJECT deviceObject;

    //
    // If the file object was taken out against the mounted file system, it
    // will have a Vpb. Traverse it to get to the DeviceObject. Note that in
    // this case we should never follow FileObject->DeviceObject, as that
    // mapping may be invalid after a forced dismount.
    //

    if (FileObject->Vpb != NULL && FileObject->Vpb->DeviceObject != NULL) {

        ASSERT(!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN));
        deviceObject = FileObject->Vpb->DeviceObject;


        //
        // If a driver opened a disk device using direct device open and
        // later on it uses IoGetRelatedTargetDeviceObject to find the
        // device object it wants to send an IRP then it should not get the
        // filesystem device object. This is so that if the device object is in the
        // process of being mounted then vpb is not stable.
        //

    } else if (!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
               FileObject->DeviceObject->Vpb != NULL &&
               FileObject->DeviceObject->Vpb->DeviceObject != NULL) {

            deviceObject = FileObject->DeviceObject->Vpb->DeviceObject;

    //
    // This is a direct open against the device stack (and there is no mounted
    // file system to strain the IRPs through).
    //

    } else {

        deviceObject = FileObject->DeviceObject;
    }

    ASSERT( deviceObject != NULL );

    //
    // Check to see whether or not the device has any associated devices.
    // If so, return the highest level device; otherwise, return a pointer
    // to the device object itself.
    //

    if (deviceObject->AttachedDevice != NULL) {
        if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {

            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =
                (PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

            ASSERT(!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN));

            if (fileObjectExtension->TopDeviceObjectHint != NULL &&
                IopVerifyDeviceObjectOnStack(deviceObject, fileObjectExtension->TopDeviceObjectHint)) {
                return fileObjectExtension->TopDeviceObjectHint;
            }
        }
        deviceObject = IoGetAttachedDevice( deviceObject );
    }

    return deviceObject;
}

ULONG
IoGetRequestorProcessId(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns a 32-bit value that is unique to the process that
    originally requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    The function value is the 32-bit process ID.


--*/

{
    PEPROCESS process;

    process = IoGetRequestorProcess( Irp );
    if (process != NULL) {

        //
        // UniqueProcessId is a kernel-mode handle, safe to truncate to ULONG.
        //

        return HandleToUlong( process->UniqueProcessId );
    } else {

        //
        // Return a PID of zero if there is no process associated with the IRP.
        //

        return 0;
    }
}

PEPROCESS
IoGetRequestorProcess(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns a pointer to the process that originally
    requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    The function value is a pointer to the original requesting process.


--*/

{
    //
    // Return the address of the process that requested the I/O operation.
    //

    PETHREAD thread = Irp->Tail.Overlay.Thread;
    if (thread) {

        //
        // The thread was not attached when the IRP was issued. So get
        // the original process. Note that this API could be called from
        // another process or thread.
        //

        if (Irp->ApcEnvironment == OriginalApcEnvironment) {
            return (THREAD_TO_PROCESS(thread));

        //
        // The thread was attached when the IRP was issued. In this case
        // give the process to which the thread is currently attached. Note that
        // this only works if the thread that issued the IO request while it was
        // attached does not attach again. This is not allowed.
        //

        } else if (Irp->ApcEnvironment == AttachedApcEnvironment) {
            return (CONTAINING_RECORD(((thread)->Tcb.ApcState.Process),EPROCESS,Pcb));

        } else {
            return NULL;
        }
    } else {
        return NULL;
    }
}

PIRP
IoGetTopLevelIrp(
    VOID
    )

/*++

Routine Description:

    This routine returns the contents of the TopLevelIrp field of the current
    thread.

Arguments:

    None.

Return Value:

    The final function value is the contents of the TopLevelIrp field.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply return the TopLevelIrp field of the thread.
    //

    return (PIRP) (PsGetCurrentThread()->TopLevelIrp);
}

VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    Initializes an IRP.

Arguments:

    Irp - a pointer to the IRP to initialize.

    PacketSize - length, in bytes, of the IRP.

    StackSize - Number of stack locations in the IRP.

Return Value:

    None.

--*/

{
    IOV_INITIALIZE_IRP(Irp, PacketSize, StackSize);

    //
    // Begin by zeroing the entire packet.
    //

    RtlZeroMemory( Irp, PacketSize );

    //
    // Initialize the remainder of the packet by setting the appropriate fields
    // and setting up the I/O stack locations in the packet.
    //

    Irp->Type = (CSHORT) IO_TYPE_IRP;
    Irp->Size = (USHORT) PacketSize;
    Irp->StackCount = (CCHAR) StackSize;
    Irp->CurrentLocation = (CCHAR) (StackSize + 1);
    Irp->ApcEnvironment = KeGetCurrentApcEnvironment();
    InitializeListHead (&(Irp)->ThreadListEntry);
    Irp->Tail.Overlay.CurrentStackLocation =
        ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) +
            sizeof( IRP ) +
            ( (StackSize) * sizeof( IO_STACK_LOCATION ))));
}

VOID
IoReuseIrp(
    PIRP Irp,
    NTSTATUS Status)
/*++

Routine Description:

    This routine is used by drivers to initialize an already allocated IRP for reuse.
    It does what IoInitializeIrp does but it saves the allocation flags so that we know
    how to free the Irp and take care of quote requirements. Drivers should call IoReuseIrp
    instead of calling IoInitializeIrp to reinitialize an IRP.

Arguments:

    Irp - Pointer to Irp to be reused

    Status - Status to preinitialize the Iostatus field.

--*/
{

    USHORT  PacketSize;
    CCHAR   StackSize;
    UCHAR   AllocationFlags;

    // Did anyone forget to pull their cancel routine?
    ASSERT(Irp->CancelRoutine == NULL) ;

    // We probably don't want thread enqueue'd IRPs to be used
    // ping-pong style as they cannot be dequeue unless they
    // complete entirely. Not really an issue for worker threads,
    // but definitely for operations on application threads.
    ASSERT(IsListEmpty(&Irp->ThreadListEntry)) ;

    AllocationFlags = Irp->AllocationFlags;
    StackSize = Irp->StackCount;
    PacketSize =  IoSizeOfIrp(StackSize);
    IopInitializeIrp(Irp, PacketSize, StackSize);
    Irp->AllocationFlags = AllocationFlags;
    Irp->IoStatus.Status = Status;

}



NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used by drivers to initialize a timer entry for a device
    object.

Arguments:

    DeviceObject - Pointer to device object to be used.

    TimerRoutine - Driver routine to be executed when timer expires.

    Context - Context parameter that is passed to the driver routine.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/

{
    PIO_TIMER timer;

    PAGED_CODE();

    //
    // Begin by getting the address of the timer to be used.  If no timer has
    // been allocated, allocate one and initialize it.
    //

    timer = DeviceObject->Timer;
    if (!timer) {
        timer = ExAllocatePoolWithTag( NonPagedPool, sizeof( IO_TIMER ), 'iToI' );
        if (!timer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Initialize the timer entry so that it is suitable for being placed
        // into the I/O system's timer queue.
        //

        RtlZeroMemory( timer, sizeof( IO_TIMER ) );
        timer->Type = IO_TYPE_TIMER;
        timer->DeviceObject = DeviceObject;
        DeviceObject->Timer = timer;
    }

    //
    // Set the address of the driver's timer routine and the context parameter
    // passed to it and insert it onto the timer queue.  Note that the timer
    // enable flag is not set, so this routine will not actually be invoked
    // yet.
    //

    timer->TimerRoutine = TimerRoutine;
    timer->Context = Context;

    ExInterlockedInsertTailList( &IopTimerQueueHead,
                                 &timer->TimerList,
                                 &IopTimerLock );
    return STATUS_SUCCESS;
}

BOOLEAN
IoIsOperationSynchronous(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines whether an I/O operation is to be considered
    synchronous or an asynchronous, from the implementors point-of-view.
    Synchronous I/O is defined by how the file was opened, or the API being
    used to perform the operation, or by the type of paging I/O being
    performed, if the operation is paging I/O.

    It is possible for asynchronous paging I/O to occur to a file that was
    opened for synchronous I/O.  This occurs when the Modified Page Writer
    is doing I/O to a file that is mapped, when too many modified pages exist
    in the system.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) representing the operation
        to be performed.

Return Value:

    A value of TRUE is returned if the operation is synchronous, otherwise
    FALSE is returned.

--*/

{
    //
    // Determine whether this is a synchronous I/O operation.  Synchronous I/O
    // is defined as an operation that is:
    //
    //     A file opened for synchronous I/O
    //         OR
    //     A synchronous API operation
    //         OR
    //     A synchronous paging I/O operation
    //
    //  AND this is NOT an asynchronous paging I/O operation occurring to some
    //  file that was opened for either synchronous or asynchronous I/O.
    //

    if ((IoGetCurrentIrpStackLocation( Irp )->FileObject->Flags & FO_SYNCHRONOUS_IO ||
        Irp->Flags & IRP_SYNCHRONOUS_API ||
        Irp->Flags & IRP_SYNCHRONOUS_PAGING_IO) &&
        !(Irp->Flags & IRP_PAGING_IO &&
        !(Irp->Flags & IRP_SYNCHRONOUS_PAGING_IO))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
IoIsSystemThread(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a BOOLEAN indicating whether or not the specified
    thread is a system thread.

Arguments:

    Thread - Pointer to the thread to be checked.

Return Value:

    A value of TRUE is returned if the indicated thread is a system thread,
    else FALSE.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    return (BOOLEAN) IS_SYSTEM_THREAD(Thread);
}

BOOLEAN
IoIsValidNameGraftingBuffer(
    IN PIRP Irp,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    )

/*++

Routine Description:

    This routine returns a BOOLEAN indicating whether or not the specified
    buffer is a valid name grafting buffer. All internal validity checks are
    encapsulated in this routine.

    Among the checks performed is whether the name lengths stored within the
    buffer in the private data section are compatible with the total size of
    the buffer that has been passed in.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) representing the operation
        to be performed.

    Buffer - Pointer to a reparse data buffer that is supposed to contain
        a self-consistent set of names to perform name grafting.

Return Value:

    A value of TRUE is returned if the buffer is correct for name grafting,
    else FALSE.

Note:

    This function needs to be kept synchronized with the definition of
    REPARSE_DATA_BUFFER.

--*/

{
    PIO_STACK_LOCATION thisStackPointer = NULL;
    UNICODE_STRING     drivePath;

    PAGED_CODE();

    ASSERT( FIELD_OFFSET( REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0] ) ==
            FIELD_OFFSET( REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0] ) );
    ASSERT( ReparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );

    //
    // Determine whether we have the correct kind of reparse tag in the buffer.
    //

    if (ReparseBuffer->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {

        //
        // The reparse tag is not an NT name grafting tag.
        //

        return FALSE;
    }

    //
    // Determine whether we have enough data for all the length fields.
    //

    if (ReparseBuffer->ReparseDataLength <
        (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) {

        //
        // The buffer is shorter than the minimum needed to express a pair of valid
        // names.
        //

        return FALSE;
    }

    //
    // Get the address of the current stack location.
    //

    thisStackPointer = IoGetCurrentIrpStackLocation( Irp );

    //
    // Determine whether the data lengths returned are consistent with the buffer in
    // which they are retrieved.
    //
    // This check is meaningful only when the buffer has been allocated. When this routine
    // is used when a name grafting is being set there is no allocated output buffer.
    //

    if ((thisStackPointer->Parameters.FileSystemControl.OutputBufferLength > 0) &&
        (thisStackPointer->Parameters.FileSystemControl.OutputBufferLength <
        (ULONG)(FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) +
                ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
                ReparseBuffer->MountPointReparseBuffer.PrintNameLength +
                2 * sizeof( UNICODE_NULL )))) {

        //
        // The length of the appropriate buffer header, plus the lengths of the substitute
        // and print names are longer than the length of the buffer passed in.
        // Thus, this data is not self-consistent.
        //
        // Note that it is only the I/O subsystem that needs to check for this internal
        // consistency in the buffer as it will do a blind data copy using these lengths
        // when transmogrifying the names. The file system returning the buffer only needs
        // to ascertain that the total syze of the data retrieved does not exceed the size
        // of the output buffer.
        //

        return FALSE;
    }

    //
    // Now we determine whether the names were placed according to the reparse point
    // specification.
    //

    //
    // Determine whether the SubstituteNameOffset is zero.
    //

    if (ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset != 0) {

        //
        // Incorrect offset for the substitute name.
        //

        return FALSE;
    }

    //
    // Determine whether PrintNameOffset is correct.
    //

    if (ReparseBuffer->MountPointReparseBuffer.PrintNameOffset !=
        (ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength + sizeof( UNICODE_NULL )) ) {

        //
        // Incorrect offset for the print name.
        //

        return FALSE;
    }

    //
    // Determine whether ReparseDataLength is correct for name grafting operations.
    // We require a buffer of type REPARSE_DATA_BUFFER.
    //

    if (ReparseBuffer->ReparseDataLength !=
        (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE) +
        ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
        ReparseBuffer->MountPointReparseBuffer.PrintNameLength +
        2 * sizeof( UNICODE_NULL )) {

        //
        // Incorrect length of the reparse data.
        //

        return FALSE;
    }

    //
    // Determine that the substitute name is not a UNC name.
    // This assumes that ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset is zero (0).
    //

    {
        //
        // This conditional is a transcription of part of the code of RtlDetermineDosPathNameType_U
        // present in ntos\dll\curdir.c
        //
        // The only two legal names that can begin with \\ are:  \\.  and  \\?
        // All other names that begin with  \\  are disallowed.
        //

        if ((ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength > 6) &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'\\') &&
            !((ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'.') ||
              (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?'))) {

            //
            // The name is not one we want to deal with.
            //

            return FALSE;
        }

        //
        // When  RtlDosPathNameToNtPathName_U  is used, the UNC names are returned with a prefix
        // of the form  \??\UNC\
        //

        if ((ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength > 16) &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[3] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[4] == L'U') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[5] == L'N') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[6] == L'C') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[7] == L'\\')) {

            //
            // The name is not one we want to deal with.
            //

            return FALSE;
        }

        //
        // See whether there is a drive letter that is mapped at the beginning of the name.
        // If the drive letter is C, then the prefix has the form  \??\C:
        // Note that we skip the offset 4 on purpose.
        //

        if ((ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength > 12) &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[3] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[5] == L':')) {

            NTSTATUS           status;
            UNICODE_STRING     linkValue;
            OBJECT_ATTRIBUTES  objectAttributes;
            HANDLE             linkHandle;
            PWCHAR             linkValueBuffer = NULL;   //  MAX_PATH is 260
            WCHAR              pathNameValue[sizeof(L"\\??\\C:\0")];

            RtlCopyMemory( &pathNameValue[0], L"\\??\\C:\0", sizeof(L"\\??\\C:\0") );

            RtlInitUnicodeString( &drivePath, pathNameValue );

            //
            // Place the appropriate drive letter in the buffer overwriting offset 4.
            //

            drivePath.Buffer[4] = ReparseBuffer->MountPointReparseBuffer.PathBuffer[4];

            InitializeObjectAttributes( &objectAttributes,
                                        &drivePath,
                                        OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                        (HANDLE) NULL,
                                        (PSECURITY_DESCRIPTOR) NULL );

            status = ZwOpenSymbolicLinkObject( &linkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &objectAttributes );


            if ( NT_SUCCESS( status ) ) {

                //
                // Now query the link and see if there is a redirection
                //

                linkValueBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                                         2 * 260,
                                                         '  oI' );
                if ( !linkValueBuffer ) {

                    //
                    // Insufficient resources. Return FALSE.
                    //

                    ZwClose( linkHandle );
                    return FALSE;
                }

                linkValue.Buffer = linkValueBuffer;
                linkValue.Length = 0;
                linkValue.MaximumLength = (USHORT)(2 * 260);

                status = ZwQuerySymbolicLinkObject( linkHandle,
                                                    &linkValue,
                                                    NULL );
                ZwClose( linkHandle );


                if ( NT_SUCCESS( status ) ) {

                    //
                    // The link is a re-directed drive when it has the prefix
                    // \Device\LanmanRedirector\
                    //

                    if ((linkValue.Buffer[ 0] == L'\\') &&
                        (linkValue.Buffer[ 1] == L'D') &&
                        (linkValue.Buffer[ 2] == L'e') &&
                        (linkValue.Buffer[ 3] == L'v') &&
                        (linkValue.Buffer[ 4] == L'i') &&
                        (linkValue.Buffer[ 5] == L'c') &&
                        (linkValue.Buffer[ 6] == L'e') &&
                        (linkValue.Buffer[ 7] == L'\\') &&
                        (linkValue.Buffer[ 8] == L'L') &&
                        (linkValue.Buffer[ 9] == L'a') &&
                        (linkValue.Buffer[10] == L'n') &&
                        (linkValue.Buffer[14] == L'R') &&
                        (linkValue.Buffer[15] == L'e') &&
                        (linkValue.Buffer[16] == L'd') &&
                        (linkValue.Buffer[17] == L'i') &&
                        (linkValue.Buffer[18] == L'r') &&
                        (linkValue.Buffer[23] == L'r') &
                        (linkValue.Buffer[24] == L'\\')) {

                        //
                        // Free the buffer.
                        //

                        ExFreePool( linkValueBuffer );

                        return FALSE;
                    }

                }

                //
                // Free the buffer.
                //

                ExFreePool( linkValueBuffer );
            }
        }
    }

    //
    // Fix for penetration bug. May be relaxed in the future 03/99.
    // Determine that we either have an NT file name or a volume mount point target name.
    //
    // This closes the door of having an arbitrary device name that, with the help of the
    // server, can be used to bypass access checks to the underlying device.
    //

    {
        UNICODE_STRING volumeName;

        if (
            //
            // The shortest valid name is one of the kind \??\C: whose length is 12 when
            // in Unicode. All names used by volume mount points are longer.
            //

            ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength < 12 ) {

            return FALSE;
        }

        //
        // The name has at least 6 Unicode characters.
        //
        // We have verified above that MountPointReparseBuffer.SubstituteNameOffset
        // is zero.
        //

        volumeName.Length =
        volumeName.MaximumLength = ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength;
        volumeName.Buffer = (PWSTR) ReparseBuffer->MountPointReparseBuffer.PathBuffer;

        //
        // When we do not have a name that begins with a drive letter and it is not
        // a valid volume mount point name then we return false.
        //

        if ( !((ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'?') &&
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?') &&
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[3] == L'\\') &&
               //
               // Notice that we skip index 4, where the drive letter is to be.
               //
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[5] == L':'))

             &&

             !MOUNTMGR_IS_VOLUME_NAME( &volumeName ) ) {

            return FALSE;
        }
    }

    //
    // Otherwise return TRUE.
    //

    return TRUE;
}

VOID
IopDoNameTransmogrify(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    )

/*++

Routine Description:

    This routine is called to do the name grafting needed for junctions.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) representing the operation
        to be performed.

    FileObject - Pointer to the file object whose name is being affected.

    ReparseBuffer - Pointer to a reparse data buffer that is supposed to contain
        a self-consistent set of names to perform name grafting.

Return Value:

    No explicit return value. The appropriate fields off the IRP are set.

Note:

    This function needs to be kept synchronized with the definition of
    REPARSE_DATA_BUFFER.

--*/

{
    USHORT pathLength = 0;
    USHORT neededBufferLength = 0;
    PVOID outBuffer = NULL;
    PWSTR pathBuffer = NULL;

    PAGED_CODE();

    //
    // We do the appropriate paste of the new name in the FileName buffer
    // and deallocate the buffer that brought the data from the file system.
    //

    ASSERT( Irp->IoStatus.Status == STATUS_REPARSE );
    ASSERT( Irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT );

    ASSERT( Irp->Tail.Overlay.AuxiliaryBuffer != NULL );

    ASSERT( ReparseBuffer != NULL );
    ASSERT( ReparseBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
    ASSERT( ReparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
    ASSERT( ReparseBuffer->Reserved < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );


    //
    // Determine whether we have enough data for all the length fields.
    //
    // Determine whether the lengths returned are consistent with the maximum
    // buffer. This is the best self-defense check we can do at this time as
    // the stack pointer is already invalid.
    //

    if (ReparseBuffer->ReparseDataLength >=
        (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) {

        if (MAXIMUM_REPARSE_DATA_BUFFER_SIZE <
            (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) +
                ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
                ReparseBuffer->MountPointReparseBuffer.PrintNameLength)) {

            Irp->IoStatus.Status = STATUS_IO_REPARSE_DATA_INVALID;
        }
    } else {
        Irp->IoStatus.Status = STATUS_IO_REPARSE_DATA_INVALID;
    }

    //
    // The value in  ReparseBuffer->Reserved  is the length of the file
    // name that has still to be parsed.
    //

    //
    // Copy the buffer when it has the appropriate length, else return a null UNICODE name:
    //   (1) Do defensive sanity checks on the name lengths returned.
    //
    // We only care to do this if we have no error conditions.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        pathBuffer = (PWSTR)((PCHAR)ReparseBuffer->MountPointReparseBuffer.PathBuffer +
                             ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset);
        pathLength = ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength;
    }

    //
    // Notice that if the data returned in AuxiliaryBuffer is not long enough then
    // pathLength has value 0 and pathBuffer has value NULL.
    //
    // The value in  ReparseBuffer->Reserved  is the length of the file name that
    // has still to be parsed.
    //
    // We only care to do this if we have no error conditions.
    //

    if (ReparseBuffer->Reserved < 0) {

        //
        // This is an invalid offset.
        //

        Irp->IoStatus.Status = STATUS_IO_REPARSE_DATA_INVALID;
    }

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        // Check for overflow. (pathLength <= MAXIMUM_REPARSE_DATA_BUFFER_SIZE)
        // so pathLength + sizeof(UNICODE_NULL) cannot overflow.
        //

        if (((USHORT)MAXUSHORT - ReparseBuffer->Reserved ) > (pathLength +(USHORT)sizeof(UNICODE_NULL))) {
            neededBufferLength = pathLength + ReparseBuffer->Reserved + sizeof( UNICODE_NULL );
            //
            // If the out name buffer isn't large enough, allocate a new one.
            //

            if (FileObject->FileName.MaximumLength < neededBufferLength) {
                outBuffer = ExAllocatePoolWithTag( PagedPool,
                                                   neededBufferLength,
                                                   'cFoI' );
                if (!outBuffer) {
                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                outBuffer = FileObject->FileName.Buffer;
            }
        } else {
            Irp->IoStatus.Status = STATUS_NAME_TOO_LONG;
        }
    }

    //
    // Place in the out name buffer the remaining part of the name.
    //
    // We only care to do this if we have no error conditions.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        if (ReparseBuffer->Reserved) {

            RtlMoveMemory ( (PCHAR)outBuffer + pathLength,
                            (PCHAR)FileObject->FileName.Buffer +
                                  (FileObject->FileName.Length - ReparseBuffer->Reserved),
                            ReparseBuffer->Reserved );
        }

        //
        // Copy into the front of the out name buffer the value of the
        // reparse point.
        //

        if (pathLength) {

            RtlCopyMemory( (PCHAR)outBuffer,
                           (PCHAR)pathBuffer,
                           pathLength );
        }

        FileObject->FileName.Length = neededBufferLength - sizeof( UNICODE_NULL );

        //
        // Free the old name buffer when needed and update the appropriate values.
        //

        if (outBuffer != FileObject->FileName.Buffer) {

            if (FileObject->FileName.Buffer != NULL) {
                ExFreePool( FileObject->FileName.Buffer );
            }
            FileObject->FileName.Buffer = outBuffer;
            FileObject->FileName.MaximumLength = neededBufferLength;
            ((PWSTR)outBuffer)[ (neededBufferLength / sizeof( WCHAR ))-1 ] = UNICODE_NULL;
        }
    }

    //
    // Free the buffer that came from the file system.
    // NULL the pointer.
    //

    ExFreePool( ReparseBuffer );
    ReparseBuffer = NULL;
}

PIRP
IoMakeAssociatedIrp(
    IN PIRP Irp,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine allocates an I/O Request Packet from the system nonpaged pool
    and makes it an associated IRP to the specified IRP.  The packet will be
    allocated to contain StackSize stack locations.  The IRP will also be
    initialized.

    Note that it is up to the caller to have set the number of associated IRPs
    in the master packet before calling this routine for the first time.  The
    count should be set in the master packet in:  AssociatedIrp.IrpCount.

Arguments:

    Irp - Pointer to master IRP to be associated with.

    StackSize - Specifies the maximum number of stack locations required.

Return Value:

    The function value is the address of the associated IRP or NULL, if the
    IRP could be allocated.

--*/

{
    USHORT allocateSize;
    UCHAR fixedSize;
    PIRP associatedIrp;
    PGENERAL_LOOKASIDE lookasideList;
    PP_NPAGED_LOOKASIDE_NUMBER number;
    USHORT packetSize;
    PKPRCB prcb;
    CCHAR   largeIrpStackLocations;

    //
    // If the size of the packet required is less than or equal to those on
    // the lookaside lists, then attempt to allocate the packet from the
    // lookaside lists.
    //


    associatedIrp = NULL;
    fixedSize = 0;
    packetSize = IoSizeOfIrp(StackSize);
    allocateSize = packetSize;
    largeIrpStackLocations = (CCHAR)IopLargeIrpStackLocations;

    if (StackSize <= largeIrpStackLocations) {
        fixedSize = IRP_ALLOCATED_FIXED_SIZE;
        number = LookasideSmallIrpList;
        if (StackSize != 1) {
            allocateSize = IoSizeOfIrp(largeIrpStackLocations);
            number = LookasideLargeIrpList;
        }

        prcb = KeGetCurrentPrcb();
        lookasideList = prcb->PPLookasideList[number].P;
        lookasideList->TotalAllocates += 1;
        associatedIrp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);

        if (associatedIrp == NULL) {
            lookasideList->AllocateMisses += 1;
            lookasideList = prcb->PPLookasideList[number].L;
            lookasideList->TotalAllocates += 1;
            associatedIrp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);
            if (!associatedIrp) {
                lookasideList->AllocateMisses += 1;
            }
        }

        if (IopIrpAutoSizingEnabled() && associatedIrp) {

            //
            // See if this IRP is a stale entry. If so just free it.
            // This can happen if we decided to change the lookaside list size.
            // We need to get the size of the IRP from the information field as the
            // size field is overlaid with the single list entry.
            //

            if (associatedIrp->IoStatus.Information < packetSize) {
                lookasideList->TotalFrees += 1;
                ExFreePool(associatedIrp);
                associatedIrp = NULL;
            } else {

                //
                // Update allocateSize to the correct value.
                //
                allocateSize = (USHORT)associatedIrp->IoStatus.Information;
            }
        }
    }

    //
    // If an IRP was not allocated from the lookaside list, then allocate
    // the packet from nonpaged pool.
    //

    if (!associatedIrp) {

        //
        // There are no free packets on the lookaside list, or the packet is
        // too large to be allocated from one of the lists, so it must be
        // allocated from general non-paged pool.
        //

        associatedIrp = ExAllocatePoolWithTag(NonPagedPool, allocateSize, ' prI');
        if (!associatedIrp) {
            return NULL;
        }

    }

    //
    // Initialize the packet.
    //

    IopInitializeIrp(associatedIrp, allocateSize, StackSize);
    associatedIrp->Flags |= IRP_ASSOCIATED_IRP;
    associatedIrp->Flags |= (Irp->Flags & IRP_HIGH_PRIORITY_PAGING_IO);
    associatedIrp->AllocationFlags |= (fixedSize);

    //
    // Set the thread ID to be that of the master.
    //

    associatedIrp->Tail.Overlay.Thread = Irp->Tail.Overlay.Thread;

    //
    // Now make the association between this packet and the master.
    //

    associatedIrp->AssociatedIrp.MasterIrp = Irp;
    return associatedIrp;
}



NTSTATUS
IopPageReadInternal(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN BOOLEAN Async
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Pager to read pages
    in from the disk quickly and with very little overhead.  All of the special
    handling for this request is recognized by setting the IRP_PAGING_IO flag
    in the IRP flags word.  In-page operations are detected by using the IRP
    flag IRP_INPUT_OPERATION.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the read should be performed from.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be read into from the disk.  All of the pages have been
        locked in memory.  The MDL also describes the length of the read
        operation.

    StartingOffset - Pointer to the offset in the file from which the read
        should take place.

    Event - A pointer to a kernel event structure to be used for synchronization
        purposes.  The event will be set to the Signaled state once the in-page
        operation completes.

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

    Async - If TRUE the operation is asynchronous

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.

Notes:

    This routine is invoked at APC_LEVEL; this level is honored throughout the
    execution of the entire I/O request, including completion.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Increment performance counter.  The Cache Manager I/Os always are
    // "recursive".
    //

    if (MmIsRecursiveIoFault()) {
        *CcMissCounter += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this in-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        if (MmIsFileObjectAPagingFile(FileObject)) {
            InterlockedIncrement(&IoPageReadIrpAllocationFailure);
            irp = IopAllocateReserveIrp(deviceObject->StackSize);
        }

        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    irp->MdlAddress = MemoryDescriptorList;

    if (Async) {
        irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SET_USER_EVENT;
    } else {
        irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SYNCHRONOUS_PAGING_IO | IRP_INPUT_OPERATION;
    }

    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the normal read parameters.
    //

    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = FileObject;
    irpSp->Parameters.Read.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Read.ByteOffset = *StartingOffset;

    //
    // For debugging purposes.
    //

    IoStatusBlock->Information = (ULONG_PTR)irp;

    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    return IoCallDriver( deviceObject, irp );
}

NTSTATUS
IoPageRead(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
{
    return IopPageReadInternal(FileObject,
                        MemoryDescriptorList,
                        StartingOffset,
                        Event,
                        IoStatusBlock,
                        FALSE
                        );
}

NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FileInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FileInformationClass,
                                   Length,
                                   KernelMode,
                                   FileInformation,
                                   ReturnedLength,
                                   TRUE );
}

NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified volume.
    The information returned is determined by the FsInformationClass that
    is specified, and it is placed into the caller's FsInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

    Length - Supplies the length of the FsInformation buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FsInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FsInformationClass,
                                   Length,
                                   KernelMode,
                                   FsInformation,
                                   ReturnedLength,
                                   FALSE );
}

VOID
IoQueueThreadIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine queues the specified I/O Request Packet (IRP) to the current
    thread's IRP pending queue.  This queue locates all of the outstanding
    I/O requests for the thread.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) to be queued.

Return Value:

    None.

--*/

{
    //
    // Simply queue the packet using the internal queueing routine.
    //

    IopQueueThreadIrp( Irp );
}

VOID
IoRaiseHardError(
    IN PIRP Irp,
    IN PVPB Vpb OPTIONAL,
    IN PDEVICE_OBJECT RealDeviceObject
    )

/*++

Routine Description:

    This routine pops up a hard error in the context of the thread that
    originally requested the I/O operation specified by the input IRP.  This
    is done by queueing a kernel APC to the original thread, passing it a
    pointer to the device objects and the IRP.  Once the pop up is performed,
    the routine either completes the I/O request then, or it calls the driver
    back with the same IRP.

    If the original request was an IoPageRead, then it was at APC level and
    we have to create a thread to "hold" this pop-up.  Note that we have to
    queue to an ExWorker thread to create the thread since this can only be
    done from the system process.

Arguments:

    Irp - A pointer to the I/O Request Packet (IRP) for the request that
        failed.

    Vpb - This is the volume parameter block of the offending media.  If the
        media not yet mounted, this parameter should be absent.

    RealDeviceObject - A pointer to the device object that represents the
        device that the file system believes it has mounted.  This is
        generally the "real" device object in the VPB, but may, in fact,
        be a device object attached to the physical device.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    ULONG              irpFlags;

    //
    // If pop-ups are disabled for the requesting thread, just complete the
    // request.
    //

    if ((Irp->Tail.Overlay.Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) {

        //
        // An error was incurred, so zero out the information field before
        // completing the request if this was an input operation.  Otherwise,
        // IopCompleteRequest will try to copy to the user's buffer.
        //

        if (Irp->Flags & IRP_INPUT_OPERATION) {
            Irp->IoStatus.Information = 0;
        }

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return;
    }

    //
    //  If this Irp resulted from a call to IoPageRead(), the caller must
    //  have been at APC level, so don't try enqueing an APC.
    //
    //  Also if this is a cleanup Irp, force this pop-up to go to the new
    //  thread so that it cannot be disabled.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    irpFlags = Irp->Flags & (~IRP_VERIFIER_MASK);
    if ((irpFlags == (IRP_PAGING_IO |
                        IRP_NOCACHE |
                        IRP_SYNCHRONOUS_PAGING_IO |
                        IRP_INPUT_OPERATION)) ||
        (IrpSp->MajorFunction == IRP_MJ_CLEANUP)) {

        PIOP_APC_HARD_ERROR_PACKET packet;

        packet = ExAllocatePoolWithTag( NonPagedPool,
                                        sizeof( IOP_APC_HARD_ERROR_PACKET ),
                                        'rEoI' );

        if ( packet == NULL ) {

            IoCompleteRequest( Irp, IO_DISK_INCREMENT );
            return;
        }

        ExInitializeWorkItem( &packet->Item, IopStartApcHardError, packet );
        packet->Irp = Irp;
        packet->Vpb = Vpb;
        packet->RealDeviceObject = RealDeviceObject;

        ExQueueWorkItem( &packet->Item, CriticalWorkQueue );

    } else {

        PKAPC apc;

        //
        // Begin by allocating and initializing an APC that can be sent to the
        // target thread.
        //

        apc = ExAllocatePoolWithTag( NonPagedPool, sizeof( KAPC ), 'CPAK' );

        //
        // If we could not get the pool, we have no choice but to just complete
        // the Irp, thereby passing the error onto the caller.
        //

        if ( apc == NULL ) {

            IoCompleteRequest( Irp, IO_DISK_INCREMENT );
            return;
        }

        KeInitializeApc( apc,
                         &Irp->Tail.Overlay.Thread->Tcb,
                         Irp->ApcEnvironment,
                         IopDeallocateApc,
                         IopAbortRequest,
                         IopRaiseHardError,
                         KernelMode,
                         Irp );

        (VOID) KeInsertQueueApc( apc,
                                 Vpb,
                                 RealDeviceObject,
                                 0 );
    }
}

BOOLEAN
IoRaiseInformationalHardError(
    IN NTSTATUS ErrorStatus,
    IN PUNICODE_STRING String OPTIONAL,
    IN PKTHREAD Thread OPTIONAL
    )
/*++

Routine Description:

    This routine pops up a hard error in the hard error popup thread.  The
    routine returns immediately, enqueuing the actual pop-up to a worker
    thread.  The hard error that is raised is informational in the sense that
    only the OK button is displayed.

Arguments:

    ErrorStatus - The error condition.

    String - Depending on the error, a string may have to be enqueued.

    Thread - If present, enqueue an APC to this thread rather than using
        the hard error thread.

Return Value:

    BOOLEAN - TRUE if we decided to dispatch a pop-up.  FALSE if we decided
        not to because:

        - pop-ups are disabled in the requested thread, or

        - a pool allocation failed, or

        - an equivalent pop-up is currently pending a user response (i.e.
          waiting for the user to press <OK>) or in the queue, or

        - too many pop-ups have already been queued.

--*/

//
//  This macro compares two pop-ups to see if they are content equivalent.
//

#define ArePacketsEquivalent(P1,P2) (                              \
    (P1->ErrorStatus == P2->ErrorStatus) &&                        \
    ((!P1->String.Buffer && !P2->String.Buffer) ||                 \
     ((P1->String.Length == P2->String.Length) &&                  \
      (RtlEqualMemory(P1->String.Buffer,                           \
                        P2->String.Buffer,                         \
                        P1->String.Length))))                      \
)

{
    KIRQL oldIrql;
    PVOID stringBuffer;
    PLIST_ENTRY links;

    PIOP_HARD_ERROR_PACKET hardErrorPacket;

    //
    // If pop-ups are disabled for the requesting thread, just return.
    //

    if (ARGUMENT_PRESENT(Thread) ?
        ((CONTAINING_RECORD(Thread, ETHREAD, Tcb)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) :
        ((PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0)) {

        return FALSE;
    }

    //
    // If this is one of those special error popup codes that CSRSS expects
    // to be called with a correct set of arguments, disallow from a driver
    //
    if ( ErrorStatus == STATUS_VDM_HARD_ERROR ||
         ErrorStatus == STATUS_UNHANDLED_EXCEPTION ||
         ErrorStatus == STATUS_SERVICE_NOTIFICATION ) {
        return FALSE;
    }

    //
    //  If this request is going to be sent to the hard error thread, and
    //  there are more than 25 entries already in the queue, don't
    //  add any more.  We'll do another safe check later on.
    //

    if ( !ARGUMENT_PRESENT( Thread ) &&
         (KeReadStateSemaphore( &IopHardError.WorkQueueSemaphore ) >=
          IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS) ) {

        return FALSE;
    } else {
        if (IopHardError.NumPendingApcPopups > IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS) {
            return FALSE;
        }
    }

    //
    //  Allocate the packet, and a buffer for the string if present.
    //

    hardErrorPacket = ExAllocatePoolWithTag( NonPagedPool,
                                             sizeof(IOP_HARD_ERROR_PACKET),
                                             'rEoI');

    if (!hardErrorPacket) { return FALSE; }

    //
    //  Zero out the packet and fill the NT_STATUS we will pop up.
    //

    RtlZeroMemory( hardErrorPacket, sizeof(IOP_HARD_ERROR_PACKET) );

    hardErrorPacket->ErrorStatus = ErrorStatus;

    //
    //  If there is a string, copy it.
    //

    if ( ARGUMENT_PRESENT( String ) && String->Length ) {

        stringBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                              String->Length,
                                              'rEoI' );

        if (!stringBuffer) {
            ExFreePool( hardErrorPacket );
            return FALSE;
        }

        hardErrorPacket->String.Length = String->Length;
        hardErrorPacket->String.MaximumLength = String->Length;

        hardErrorPacket->String.Buffer = stringBuffer;

        RtlCopyMemory( stringBuffer, String->Buffer, String->Length );
    }

    //
    //  If there is an Thread, enqueue an APC for ourself, otherwise send
    //  it off to the to the hard error thread.
    //

    if ( ARGUMENT_PRESENT( Thread ) ) {

        PKAPC apc;

        //
        // Begin by allocating and initializing an APC that can be sent to the
        // target thread.
        //

        apc = ExAllocatePoolWithTag( NonPagedPool, sizeof( KAPC ), 'CPAK' );

        //
        // If we could not get the pool, we have no choice but to just
        // free the packet and return.
        //

        if ( apc == NULL ) {

            if ( hardErrorPacket->String.Buffer ) {
                ExFreePool( hardErrorPacket->String.Buffer );
            }

            ExFreePool( hardErrorPacket );

            return FALSE;
        }

        InterlockedIncrement(&IopHardError.NumPendingApcPopups);
        KeInitializeApc( apc,
                         Thread,
                         OriginalApcEnvironment,
                         IopDeallocateApc,
                         NULL,
                         IopRaiseInformationalHardError,
                         KernelMode,
                         hardErrorPacket );

        (VOID) KeInsertQueueApc( apc, NULL, NULL, 0 );

    } else {

        //
        //  Get exclusive access to the work queue.
        //

        ExAcquireSpinLock( &IopHardError.WorkQueueSpinLock, &oldIrql );

        //
        //  Check the Signal state again, if OK, go ahead and enqueue.
        //

        if ( KeReadStateSemaphore( &IopHardError.WorkQueueSemaphore ) >=
             IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS ) {

            ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

            if ( hardErrorPacket->String.Buffer ) {
                ExFreePool( hardErrorPacket->String.Buffer );
            }
            ExFreePool( hardErrorPacket );
            return FALSE;
        }

        //
        //  If there is a pop-up currently up, check for a match
        //

        if (IopCurrentHardError &&
            ArePacketsEquivalent( hardErrorPacket, IopCurrentHardError )) {

            ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

            if ( hardErrorPacket->String.Buffer ) {
                ExFreePool( hardErrorPacket->String.Buffer );
            }
            ExFreePool( hardErrorPacket );
            return FALSE;
        }

        //
        //  Run down the list of queued pop-ups looking for a match.
        //

        links = IopHardError.WorkQueue.Flink;

        while (links != &IopHardError.WorkQueue) {

            PIOP_HARD_ERROR_PACKET queueHardErrorPacket;

            queueHardErrorPacket = CONTAINING_RECORD( links,
                                                      IOP_HARD_ERROR_PACKET,
                                                      WorkQueueLinks );

            if (ArePacketsEquivalent( hardErrorPacket,
                                      queueHardErrorPacket )) {

                ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

                if ( hardErrorPacket->String.Buffer ) {
                    ExFreePool( hardErrorPacket->String.Buffer );
                }
                ExFreePool( hardErrorPacket );
                return FALSE;
            }

            links = links->Flink;
        }

        //
        //  Enqueue this packet.
        //

        InsertTailList( &IopHardError.WorkQueue,
                        &hardErrorPacket->WorkQueueLinks );

        //
        //  Bump the count on the semaphore so that the hard error thread
        //  will know that an entry has been placed in the queue.
        //

        (VOID) KeReleaseSemaphore( &IopHardError.WorkQueueSemaphore,
                                   0,
                                   1L,
                                   FALSE );

        //
        //  If we are not currently running in an ExWorkerThread, queue
        //  a work item.
        //

        if ( !IopHardError.ThreadStarted ) {
            IopHardError.ThreadStarted = TRUE;
            ExQueueWorkItem( &IopHardError.ExWorkItem, DelayedWorkQueue );
        }

        //
        //  Finally, release the spinlockevent, allowing access to the work queue again.
        //  The combination of releasing both the event and the semaphore will
        //  enable the thread to wake up and obtain the entry.
        //

        ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );
    }

    return TRUE;
}

VOID
IoRegisterBootDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by boot drivers during their initialization or
    during their reinitialization to register with the I/O system to be
    called again once all devices have been enumerated and started.
    Note that it  is possible for this to occur during a normally running
    system, if the  driver is loaded dynamically, so all references to the
    reinitialization queue must be synchronized.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverReinitializationRoutine - The address of the reinitialization
        routine that is to be invoked.

    Context - Pointer to the context that is passed to the driver's
        reinitialization routine.

Return Value:

    None.

--*/

{
    PREINIT_PACKET reinitEntry;

    PAGED_CODE();

    //
    // Allocate a reinitialization entry to be inserted onto the list.  Note
    // that if the entry cannot be allocated, then the request is simply
    // dropped on the floor.
    //

    reinitEntry = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof( REINIT_PACKET ),
                                         'iRoI' );
    if (!reinitEntry) {
        return;
    }

    DriverObject->Flags |= DRVO_BOOTREINIT_REGISTERED;
    reinitEntry->DriverObject = DriverObject;
    reinitEntry->DriverReinitializationRoutine = DriverReinitializationRoutine;
    reinitEntry->Context = Context;

    IopInterlockedInsertTailList( &IopBootDriverReinitializeQueueHead,
                                  &reinitEntry->ListEntry );
}

VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by drivers during their initialization or during
    their reinitialization to register with the I/O system to be called again
    before I/O system initialization is complete.  Note that it is possible
    for this to occur during a normally running system, if the driver is
    loaded dynamically, so all references to the reinitialization queue must
    be synchronized.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverReinitializationRoutine - The address of the reinitialization
        routine that is to be invoked.

    Context - Pointer to the context that is passed to the driver's
        reinitialization routine.

Return Value:

    None.

--*/

{
    PREINIT_PACKET reinitEntry;

    PAGED_CODE();

    //
    // Allocate a reinitialization entry to be inserted onto the list.  Note
    // that if the entry cannot be allocated, then the request is simply
    // dropped on the floor.
    //

    reinitEntry = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof( REINIT_PACKET ),
                                         'iRoI' );
    if (!reinitEntry) {
        return;
    }

    DriverObject->Flags |= DRVO_REINIT_REGISTERED;
    reinitEntry->DriverObject = DriverObject;
    reinitEntry->DriverReinitializationRoutine = DriverReinitializationRoutine;
    reinitEntry->Context = Context;

    IopInterlockedInsertTailList( &IopDriverReinitializeQueueHead,
                                  &reinitEntry->ListEntry );
}

VOID
IoRegisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine inserts the device object for the file system which the device
    object represents into the list of file systems in the system.

Arguments:

    DeviceObject - Pointer to device object for the file system.

Return Value:

    None.


--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY listHead = NULL;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Allocate the I/O database resource for a write operation.
    //

    (VOID) ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Insert the device object into the appropriate file system queue based on
    // the driver type in the device object.  Notice that if the device type is
    // unrecognized, the file system is simply not registered.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {
        listHead = &IopNetworkFileSystemQueueHead;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM) {
        listHead = &IopCdRomFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
        listHead = &IopDiskFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_TAPE_FILE_SYSTEM) {
        listHead = &IopTapeFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    }

    //
    //  Low priority filesystems are inserted one-from-back on the queue (ahead of
    //  raw, behind everything else), as opposed to on the front.
    //

    if (listHead != NULL) {
        if (DeviceObject->Flags & DO_LOW_PRIORITY_FILESYSTEM ) {
            InsertTailList( listHead->Blink,
                            &DeviceObject->Queue.ListEntry );
        } else {
            InsertHeadList( listHead,
                            &DeviceObject->Queue.ListEntry );
        }
    }

    IopFsRegistrationOps++;

    //
    // Ensure that this file system's device is operable.
    //

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Notify all of the registered drivers that this file system has been
    // registered as an active file system of some type.
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        entry = entry->Flink;
        nPacket->NotificationRoutine( DeviceObject, TRUE );
    }

    //
    // Release the I/O database resource.
    //

    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Increment the number of reasons that this driver cannot be unloaded.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );
}

VOID
IopNotifyAlreadyRegisteredFileSystems(
    IN PLIST_ENTRY  ListHead,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine,
    IN BOOLEAN SkipRaw
    )
/*++

Routine Description:

    This routine calls the driver notification routine for filesystems
    that have already been registered at the time of the call.

Arguments:

    ListHead - Pointer to the filesystem registration list head.
    DriverNotificationRoutine - Pointer to the routine that has to be called.

Return Value:

    None.

--*/
{
    PLIST_ENTRY entry;
    PDEVICE_OBJECT fsDeviceObject;

    entry = ListHead->Flink;
    while (entry != ListHead) {

        //
        // Skip raw filesystem notification
        //
        if ((entry->Flink == ListHead) && (SkipRaw)) {
            break;
        }

        fsDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );
        entry = entry->Flink;
        DriverNotificationRoutine( fsDeviceObject, TRUE );
    }
}

NTSTATUS
IoRegisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    )

/*++

Routine Description:

    This routine registers the specified driver's notification routine to be
    invoked whenever a file system registers or unregisters itself as an active
    file system in the system.

Arguments:

    DriverObject - Pointer to the driver object for the driver.

    DriverNotificationRoutine - Address of routine to invoke when a file system
        registers or unregisters itself.

Return Value:

    The return status is the final value of the function.

--*/

{
    PNOTIFICATION_PACKET nPacket;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    nPacket = ExAllocatePoolWithTag( PagedPool|POOL_COLD_ALLOCATION,
                                     sizeof( NOTIFICATION_PACKET ),
                                     'sFoI' );
    if (!nPacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the notification packet and insert it onto the tail of the
    // list.
    //

    nPacket->DriverObject = DriverObject;
    nPacket->NotificationRoutine = DriverNotificationRoutine;

    ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );
    InsertTailList( &IopFsNotifyChangeQueueHead, &nPacket->ListEntry );

    IopNotifyAlreadyRegisteredFileSystems(&IopNetworkFileSystemQueueHead, DriverNotificationRoutine, FALSE);
    IopNotifyAlreadyRegisteredFileSystems(&IopCdRomFileSystemQueueHead, DriverNotificationRoutine, TRUE);
    IopNotifyAlreadyRegisteredFileSystems(&IopDiskFileSystemQueueHead, DriverNotificationRoutine, TRUE);
    IopNotifyAlreadyRegisteredFileSystems(&IopTapeFileSystemQueueHead, DriverNotificationRoutine, TRUE);

    //
    // Notify this driver about all already notified filesystems
    // registered as an active file system of some type.
    //


    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Increment the number of reasons that this driver cannot be unloaded.
    //

    ObReferenceObject( DriverObject );

    return STATUS_SUCCESS;
}



NTSTATUS
IoRegisterLastChanceShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows a driver to register that it would like to have its
    shutdown routine invoked at very late in system shutdown.  This gives
    the driver an opportunity to get control just before the system is fully
    shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PSHUTDOWN_PACKET shutdown;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    shutdown = ExAllocatePoolWithTag( NonPagedPool,
                                      sizeof( SHUTDOWN_PACKET ),
                                      'hSoI' );
    if (!shutdown) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the shutdown packet and insert it onto the head of the list.
    // Note that this is done because some drivers have dependencies on LIFO
    // notification ordering.
    //

    ObReferenceObject(DeviceObject);    // Ensure that the driver remains
    shutdown->DeviceObject = DeviceObject;

    IopInterlockedInsertHeadList( &IopNotifyLastChanceShutdownQueueHead,
                                  &shutdown->ListEntry );

    //
    // Do the bookkeeping to indicate that this driver has successfully
    // registered a shutdown notification routine.
    //

    DeviceObject->Flags |= DO_SHUTDOWN_REGISTERED;

    return STATUS_SUCCESS;
}

NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows a driver to register that it would like to have its
    shutdown routine invoked when the system is being shutdown.  This gives
    the driver an opportunity to get control just before the system is fully
    shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PSHUTDOWN_PACKET shutdown;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    shutdown = ExAllocatePoolWithTag( NonPagedPool,
                                      sizeof( SHUTDOWN_PACKET ),
                                      'hSoI' );
    if (!shutdown) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the shutdown packet and insert it onto the head of the list.
    // Note that this is done because some drivers have dependencies on LIFO
    // notification ordering.
    //

    shutdown->DeviceObject = DeviceObject;
    ObReferenceObject(DeviceObject);    // Ensure that the driver remains

    IopInterlockedInsertHeadList( &IopNotifyShutdownQueueHead,
                                  &shutdown->ListEntry );

    //
    // Do the bookkeeping to indicate that this driver has successfully
    // registered a shutdown notification routine.
    //

    DeviceObject->Flags |= DO_SHUTDOWN_REGISTERED;

    return STATUS_SUCCESS;
}

VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to release the cancel spin lock.  This spin lock
    must be acquired before setting the address of a cancel routine in an
    IRP and released after the cancel routine has been set.

Arguments:

    Irql - Supplies the IRQL value returned from acquiring the spin lock.

Return Value:

    None.

--*/

{
    //
    // Simply release the cancel spin lock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoCancelLock, Irql );
}

VOID
IoReleaseVpbSpinLock(
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to release the Volume Parameter Block (VPB) spin
    lock.  This spin lock must be acquired before accessing the mount flag,
    reference count, and device object fields of a VPB.

Arguments:

    Irql - Supplies the IRQL value returned from acquiring the spin lock.

Return Value:

    None.

--*/

{
    //
    // Simply release the VPB spin lock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, Irql );
}

VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    FileObject - Pointer to the file object of the current access being closed.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {
            return;
        }
    }

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        //
        // For each access type, decrement the appropriate count in the Share
        // Access structure.
        //

        if (FileObject->ReadAccess) {
            ShareAccess->Readers--;
        }

        if (FileObject->WriteAccess) {
            ShareAccess->Writers--;
        }

        if (FileObject->DeleteAccess) {
            ShareAccess->Deleters--;
        }

        //
        // For each shared access type, decrement the appropriate count in the
        // Share Access structure.
        //

        if (FileObject->SharedRead) {
            ShareAccess->SharedRead--;
        }

        if (FileObject->SharedWrite) {
            ShareAccess->SharedWrite--;
        }

        if (FileObject->SharedDelete) {
            ShareAccess->SharedDelete--;
        }
    }
}

VOID
IoSetDeviceToVerify(
    IN PETHREAD Thread,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine sets the device to verify field in the thread object.  This
    function is invoked by file systems to NULL this field, or to set it to
    predefined values.

Arguments:

    Thread - Pointer to the thread whose field is to be set.

    DeviceObject - Pointer to the device to be verified, or NULL, or ...

Return Value:

    None.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply set the device to be verified in the specified thread.
    //

    Thread->DeviceToVerify = DeviceObject;
}

VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked when a driver realizes that the media
    has possibly changed on a device, and it must be verified before
    continuing, or a hard error has occured.  The device is stored
    in the thread local storage of the Irp's originating thread.

Arguments:

    Irp - Pointer to an I/O Request Packet to get the thread.

    DeviceObject - This is the device that needs to be verified.

Return Value:

    None.

--*/

{

    //
    // If this IRP is not associated with a thread do nothing.
    // Its a defensive check to catch drivers that pass
    // all kinds of IRPs to this routine.
    //

    if (!Irp->Tail.Overlay.Thread) {
        return;
    }


    //
    // Store the address of the device object that needs verification in
    // the appropriate field of the thread pointed to by the specified I/O
    // Request Packet.
    //



    Irp->Tail.Overlay.Thread->DeviceToVerify = DeviceObject;
}

NTSTATUS
IoSetInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN PVOID FileInformation
    )

/*++

Routine Description:

    This routine sets the requested information for the specified file.
    The information that is set is determined by the FileInformationClass
    paramter, and the information itself is passed in the FileInformation
    buffer.

Arguments:

    FileObject - Supplies a pointer to the file object for the file that
        is to be changed.

    FileInformationClass - Specifies the type of information that should
        be set on the file.

    Length - Supplies the length of the FileInformation buffer in bytes.

    FileInformation - A buffer containing the file information to set.  This
        buffer must not be pageable and must reside in system space.

Return Value:

    The status returned is the final completion status of the operation.


--*/

{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    HANDLE targetHandle = NULL;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then initialize the local event.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( FileObject )) {
            status = IopAcquireFileObjectLock( FileObject,
                                               KernelMode,
                                               (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( FileObject );
                return status;
            }
        }
        KeClearEvent( &FileObject->Event );
        synchronousIo = TRUE;
    } else {
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case there is
    // not enough memory to satisfy the request.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( FileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
    } else {
        irp->UserEvent = &event;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->UserIosb = &localIoStatus;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;
    irp->Flags |= IRP_BUFFERED_IO;

    //
    // Copy the caller's parameters to the service-specific portion of the IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants to
    // set is device independent (I/O system dependent).  If this is the case,
    // then the request can be satisfied here without having to have all of
    // the drivers implement the same code.  Note that having the IRP is still
    // necessary since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Set or clear the appropriate flags in the file object.
        //

        if (!(FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {
            if (modeBuffer->Mode & FILE_WRITE_THROUGH) {
                FileObject->Flags |= FO_WRITE_THROUGH;
            } else {
                FileObject->Flags &= ~FO_WRITE_THROUGH;
            }
        }

        if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
            FileObject->Flags |= FO_SEQUENTIAL_ONLY;
        } else {
            FileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
        }

        if (modeBuffer->Mode & FO_SYNCHRONOUS_IO) {
            if (modeBuffer->Mode & FILE_SYNCHRONOUS_IO_ALERT) {
                FileObject->Flags |= FO_ALERTABLE_IO;
            } else {
                FileObject->Flags &= ~FO_ALERTABLE_IO;
            }
        }

        status = STATUS_SUCCESS;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

        IoSetNextIrpStackLocation( irp );
        IoCompleteRequest( irp, 0 );

    } else if (FileInformationClass == FileRenameInformation ||
               FileInformationClass == FileLinkInformation ||
               FileInformationClass == FileMoveClusterInformation) {

        //
        // Note that the following code assumes that a rename information
        // and a set link information structure look exactly the same.
        //

        PFILE_RENAME_INFORMATION renameBuffer = FileInformation;

        //
        // Copy the value of the replace BOOLEAN (or the ClusterCount field)
        // from the caller's buffer to the I/O stack location parameter
        // field where it is expected by file systems.
        //

        if (FileInformationClass == FileMoveClusterInformation) {
            irpSp->Parameters.SetFile.ClusterCount =
                ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)->ClusterCount;
        } else {
            irpSp->Parameters.SetFile.ReplaceIfExists = renameBuffer->ReplaceIfExists;
        }

        //
        // Check to see whether or not a fully qualified pathname was supplied.
        // If so, then more processing is required.
        //

        if (renameBuffer->FileName[0] == (UCHAR) OBJ_NAME_PATH_SEPARATOR ||
            renameBuffer->RootDirectory != NULL) {

            //
            // A fully qualified file name was specified as the target of the
            // rename operation.  Attempt to open the target file and ensure
            // that the replacement policy for the file is consistent with the
            // caller's request, and ensure that the file is on the same volume.
            //

            status = IopOpenLinkOrRenameTarget( &targetHandle,
                                                irp,
                                                renameBuffer,
                                                FileObject );
            if (!NT_SUCCESS( status )) {
                IoSetNextIrpStackLocation( irp );
                IoCompleteRequest( irp, 2 );

            } else {

                //
                // The fully qualified file name specifies a file on the same
                // volume and if it exists, then the caller specified that it
                // should be replaced.
                //

                status = IoCallDriver( deviceObject, irp );

            }

        } else {

            //
            // This is a simple rename operation, so call the driver and let
            // it perform the rename operation within the same directory as
            // the source file.
            //

            status = IoCallDriver( deviceObject, irp );

        }

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (synchronousIo) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject( &FileObject->Event,
                                            Executive,
                                            KernelMode,
                                            (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );
            if (status == STATUS_ALERTED) {
                IopCancelAlertedRequest( &FileObject->Event, irp );
            }
            status = localIoStatus.Status;
        }
        IopReleaseFileObjectLock( FileObject );

    } else {

        //
        // This is a normal synchronous I/O operation, as opposed to a
        // serialized synchronous I/O operation.  For this case, wait for
        // the local event and copy the final status information back to
        // the caller.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = localIoStatus.Status;
        }
    }

    //
    // If a target handle was created because of a rename operation, close
    // the handle now.
    //

    if (targetHandle != (HANDLE) NULL) {
        ObCloseHandle( targetHandle , KernelMode);
    }

    return status;
}

VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to set the access and share access information
    in a file system Share Access structure for the first open.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    BOOLEAN update = TRUE;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {

            //
            //  This fileobject is marked to ignore share access checks
            //  so we also don't want to affect the file/directory's
            //  ShareAccess structure counts.
            //

            update = FALSE;
        }
    }

    //
    // Check to see whether the current file opener would like to read,
    // write, or delete the file.  If so, account for it in the share access
    // structure; otherwise, skip it.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Only update the share modes if the user wants to read, write or
        // delete the file.
        //

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        if (update) {

            //
            // Set the Share Access structure open count.
            //

            ShareAccess->OpenCount = 1;

            //
            // Set the number of readers, writers, and deleters in the Share Access
            // structure.
            //

            ShareAccess->Readers = FileObject->ReadAccess;
            ShareAccess->Writers = FileObject->WriteAccess;
            ShareAccess->Deleters = FileObject->DeleteAccess;

            //
            // Set the number of shared readers, writers, and deleters in the Share
            // Access structure.
            //

            ShareAccess->SharedRead = FileObject->SharedRead;
            ShareAccess->SharedWrite = FileObject->SharedWrite;
            ShareAccess->SharedDelete = FileObject->SharedDelete;
        }

    } else {

        //
        // No read, write, or delete access has been requested.  Simply zero
        // the appropriate fields in the structure so that the next accessor
        // sees a consistent state.
        //

        if (update) {

            ShareAccess->OpenCount = 0;
            ShareAccess->Readers = 0;
            ShareAccess->Writers = 0;
            ShareAccess->Deleters = 0;
            ShareAccess->SharedRead = 0;
            ShareAccess->SharedWrite = 0;
            ShareAccess->SharedDelete = 0;
        }
    }
}

BOOLEAN
IoSetThreadHardErrorMode(
    IN BOOLEAN EnableHardErrors
    )

/*++

Routine Description:

    This routine either enables or disables hard errors for the current
    thread and returns the old state of the flag.

Arguments:

    EnableHardErrors - Supplies a BOOLEAN value indicating whether or not
        hard errors are to be enabled for the current thread.

Return Value:

    The final function value is the previous state of whether or not hard
    errors were enabled.

--*/

{
    PETHREAD thread;
    BOOLEAN oldFlag;

    //
    // Get a pointer to the current thread, capture the current state of
    // hard errors, and set the new state.
    //

    thread = PsGetCurrentThread();

    if ((thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) == 0) {
        oldFlag = TRUE;
    }
    else {
        oldFlag = FALSE;
    }

    if (EnableHardErrors) {
        PS_CLEAR_BITS (&thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    } else {
        PS_SET_BITS (&thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    }

    return oldFlag;
}

VOID
IoSetTopLevelIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the top level IRP field in the current thread's thread
    object.  This function is invoked by file systems to either set this field
    to the address of an I/O Request Packet (IRP) or to null it.

Arguments:

    Irp - Pointer to the IRP to be stored in the top level IRP field.

Return Value:

    None.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply set the top level IRP field in the current thread's thread
    // object.
    //

    PsGetCurrentThread()->TopLevelIrp = (ULONG_PTR) Irp;
    return;
}

VOID
IoShutdownSystem (
    IN ULONG Phase
    )

/*++

Routine Description:

    This routine shuts down the I/O portion of the system in preparation
    for a power-off or reboot.

Arguments:

    RebootPending - Indicates whether a reboot is imminently pending.

    Phase - Indicates which phase of shutdown is being performed.

Return Value:

    None

--*/

{
    PSHUTDOWN_PACKET shutdown;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PLIST_ENTRY entry;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();

    //
    // Initialize the event used to synchronize the complete of all of the
    // shutdown routines.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    if (Phase == 0) {

        ZwClose(IopLinkTrackingServiceEventHandle);

        IoShutdownPnpDevices();

        //
        // Walk the list of the drivers in the system that have registered
        // themselves as wanting to know when the system is about to be
        // shutdown and invoke each.
        //

        while ((entry = IopInterlockedRemoveHeadList( &IopNotifyShutdownQueueHead )) != NULL) {
            shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );

            //
            // Another driver has been found that has indicated that it requires
            // shutdown notification.  Invoke the driver's shutdown entry point.
            //

            deviceObject = IoGetAttachedDeviceReference( shutdown->DeviceObject );

            irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                deviceObject,
                                                (PVOID) NULL,
                                                0,
                                                (PLARGE_INTEGER) NULL,
                                                &event,
                                                &ioStatus );

            //
            // If we get an IRP issue the shutdown. Otherwise just skip the driver. Its unfortunate but even
            // drivers if they fail in memory allocations on shutdown have to skip it.
            //

            if (irp) {
                if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
#if DBG
                    PUNICODE_STRING DeviceName = ObGetObjectName( shutdown->DeviceObject );

                    DbgPrint( "IO: Waiting for shutdown of device object (%x) - %wZ\n",
                              shutdown->DeviceObject,
                              DeviceName
                            );
#endif // DBG
                    (VOID) KeWaitForSingleObject( &event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  (PLARGE_INTEGER) NULL );
                }
            }

            ObDereferenceObject(deviceObject);
            ObDereferenceObject(shutdown->DeviceObject);
            ExFreePool( shutdown );
            KeClearEvent( &event );
        }

        IOV_UNLOAD_DRIVERS();

    } else if (Phase == 1) {

#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot client then allow the cache to close the database and
        // mark it clean.
        //

        IopShutdownCsc();
#endif // defined(REMOTE_BOOT)

        // Gain access to the file system header queues by acquiring the
        // database resource for shared access.
        //

        ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

        IopShutdownBaseFileSystems(&IopDiskFileSystemQueueHead);

        IopShutdownBaseFileSystems(&IopCdRomFileSystemQueueHead);

        IopShutdownBaseFileSystems(&IopTapeFileSystemQueueHead);


        //
        // Walk the list of the drivers in the system that have registered
        // themselves as wanting to know at the last chance when the system
        // is about to be shutdown and invoke each.
        //

        while ((entry = IopInterlockedRemoveHeadList( &IopNotifyLastChanceShutdownQueueHead )) != NULL) {
            shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );

            //
            // Another driver has been found that has indicated that it requires
            // shutdown notification.  Invoke the driver's shutdown entry point.
            //

            deviceObject = IoGetAttachedDeviceReference( shutdown->DeviceObject );

            irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                deviceObject,
                                                (PVOID) NULL,
                                                0,
                                                (PLARGE_INTEGER) NULL,
                                                &event,
                                                &ioStatus );

            if (irp) {
                if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
#if DBG
                    PUNICODE_STRING DeviceName = ObGetObjectName( shutdown->DeviceObject );

                    DbgPrint( "IO: Waiting for last chance shutdown of device object (%x) - %wZ\n",
                              shutdown->DeviceObject,
                              DeviceName
                            );
#endif // DBG
                    (VOID) KeWaitForSingleObject( &event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  (PLARGE_INTEGER) NULL );
                }
            }

            ObDereferenceObject(deviceObject);
            ObDereferenceObject(shutdown->DeviceObject);

            ExFreePool( shutdown );
            KeClearEvent( &event );
        }

        //
        // N.B. The system has stopped.  The IopDatabaseResource lock is
        // not released so that no other mount operations can take place.
        //
        // ExReleaseResourceLite( &IopDatabaseResource );
        //
    }

    return ;
}

VOID
IopShutdownBaseFileSystems(
    IN PLIST_ENTRY  ListHead
    )
{
    PLIST_ENTRY entry;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_OBJECT baseDeviceObject;
    PDEVICE_OBJECT deviceObject;
    PIRP    irp;

    //
    // Loop through each of the disk file systems, invoking each to shutdown
    // each of their mounted volumes.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    entry = RemoveHeadList(ListHead);

    while (entry != ListHead) {

        baseDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );

        //
        // We have removed the entry. If the filesystem in this thread calls IoUnregisterFileSystem
        // then we won't remove the entry from the list as the Flink == NULL.
        //


        baseDeviceObject->Queue.ListEntry.Flink = NULL;
        baseDeviceObject->Queue.ListEntry.Blink = NULL;

        //
        // Prevent the driver from getting unloaded while shutdown handler is in progress.
        // Also prevent the base device object from going away as we need to decrement the
        // reasons for unload count later.
        //

        ObReferenceObject(baseDeviceObject);
        IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                      &baseDeviceObject->ReferenceCount );

        deviceObject = baseDeviceObject;
        if (baseDeviceObject->AttachedDevice) {
            deviceObject = IoGetAttachedDevice( baseDeviceObject );
        }

        //
        // Another file system has been found.  Invoke this file system at
        // its shutdown entry point.
        //

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                            deviceObject,
                                            (PVOID) NULL,
                                            0,
                                            (PLARGE_INTEGER) NULL,
                                            &event,
                                            &ioStatus );
        //
        // Its possible that the drivers are unloaded before this call returns but IoCallDriver
        // takes a reference to the device object before calling the driver. So the image will not
        // get unloaded.
        //

        if (irp) {
            if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }
        }
        entry = RemoveHeadList(ListHead);

        KeClearEvent( &event );

        IopDecrementDeviceObjectRef(baseDeviceObject, FALSE, TRUE);
        ObDereferenceObject(baseDeviceObject);
    }
}


VOID
IopStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN LOGICAL Cancelable
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.  If the Cancelable paramter is TRUE, then the update of
    current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/

{
    KIRQL cancelIrql = PASSIVE_LEVEL;
    PIRP irp;
    PKDEVICE_QUEUE_ENTRY packet;

    //
    // Begin by checking to see whether or not this driver's requests are
    // to be considered cancelable.  If so, then acquire the cancel spinlock.
    //

    if (Cancelable) {
        IoAcquireCancelSpinLock( &cancelIrql );
    }

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Remove the next packet from the head of the queue.  If a packet was
    // found, then process it.
    //

    packet = KeRemoveDeviceQueue( &DeviceObject->DeviceQueue );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was located so make it the current packet for this
        // device.
        //

        DeviceObject->CurrentIrp = irp;
        if (Cancelable) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                irp->CancelRoutine = NULL;
            }

           IoReleaseCancelSpinLock( cancelIrql );
        }

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );
    } else {

        //
        // No packet was found, so simply release the cancel spinlock if
        // it was acquired.
        //

        if (Cancelable) {
           IoReleaseCancelSpinLock( cancelIrql );
        }
    }
}

VOID
IopStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN LOGICAL Cancelable,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.  If the Cancelable paramter is TRUE, then the
    update of current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    KIRQL                cancelIrql = PASSIVE_LEVEL;
    PIRP                 irp;
    PKDEVICE_QUEUE_ENTRY packet;

    //
    // Begin by determining whether or not requests for this device are to
    // be considered cancelable.  If so, then acquire the cancel spinlock.
    //

    if (Cancelable) {
        IoAcquireCancelSpinLock( &cancelIrql );
    }

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Attempt to remove the indicated packet according to the key from the
    // device queue.  If one is found, then process it.
    //

    packet = KeRemoveByKeyDeviceQueue( &DeviceObject->DeviceQueue, Key );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was successfully located.  Make it the current packet
        // and invoke the driver's start I/O routine for it.
        //

        DeviceObject->CurrentIrp = irp;

        if (Cancelable) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                irp->CancelRoutine = NULL;
            }

           IoReleaseCancelSpinLock( cancelIrql );
        }

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

    } else {

        //
        // No packet was found, so release the cancel spinlock if it was
        // acquired.
        //

        if (Cancelable) {
           IoReleaseCancelSpinLock( cancelIrql );
        }
    }
}

VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to start the specified packet request (IRP) on the
    specified device.  If the device is already busy, then the packet is
    simply queued to the device queue. If a non-NULL CancelFunction is
    supplied, it will be put in the IRP.  If the IRP has been canceled, the
    CancelFunction will be called after the IRP has been inserted into the
    queue or made the current packet.

Arguments:

    DeviceObject - Pointer to device object itself.

    Irp - I/O Request Packet which should be started on the device.

    Key - Key to be used in inserting packet into device queue;  optional
        (if not specified, then packet is inserted at the tail).

    CancelFunction - Pointer to an optional cancel routine.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    KIRQL cancelIrql = PASSIVE_LEVEL;
    BOOLEAN i;

    //
    // Raise the IRQL of the processor to dispatch level for synchronization.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // If the driver has indicated that packets are cancelable, then acquire
    // the cancel spinlock and set the address of the cancel function to
    // indicate that the packet is not only cancelable, but indicates what
    // routine to invoke should it be cancelled.
    //

    if (CancelFunction) {
        IoAcquireCancelSpinLock( &cancelIrql );
        Irp->CancelRoutine = CancelFunction;
    }

    //
    // If a key parameter was specified, then insert the request into the
    // work queue according to the key;  otherwise, simply insert it at the
    // tail.
    //

    if (Key) {
        i = KeInsertByKeyDeviceQueue( &DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry,
                                      *Key );
    } else {
        i = KeInsertDeviceQueue( &DeviceObject->DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry );
    }

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!i) {

        DeviceObject->CurrentIrp = Irp;

        if (CancelFunction) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                Irp->CancelRoutine = NULL;
            }

            IoReleaseCancelSpinLock( cancelIrql );
        }

        //
        // Invoke the driver's start I/O routine to get the request going on the device.
        // The StartIo routine should handle the cancellation.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, Irp );

    } else {

        //
        // The packet was successfully inserted into the device's work queue.
        // Make one last check to determine whether or not the packet has
        // already been marked cancelled.  If it has, then invoke the
        // driver's cancel routine now.  Note that because the cancel
        // spinlock is currently being held, an attempt to cancel the request
        // from another processor at this point will simply wait until this
        // routine is finished, and then get it cancelled.
        //

        if (CancelFunction) {
            if (Irp->Cancel) {
                Irp->CancelIrql = cancelIrql;
                Irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
                CancelFunction( DeviceObject, Irp );
            } else {
                IoReleaseCancelSpinLock( cancelIrql );
            }
        }
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller.
    //

    KeLowerIrql( oldIrql );
}

VOID
IopStartNextPacketByKeyEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG   Key,
    IN int     Flags)
/*++

Routine Description:

    This routine ensures that if the IoStartPacket* routines are called from inside StartIo then
    it defers calling the startio until after the StartIo call returns. It does this by keeping a count.
    It also keeps track of whether its cancelable or has a key by storing the value in the
    device object extension. They are updated without a lock because its incorrect to have two parallel
    calls to IoStartNextPacket or IoStartNextPacketByKey.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

    Flags - Specifies if the deferred call has a key or is cancelable.

Return Value:

    None.

--*/
{
    LOGICAL Cancelable;
    int doAnotherIteration;

    do {
            doAnotherIteration = 0;
            if (InterlockedIncrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) > 1) {
                DeviceObject->DeviceObjectExtension->StartIoFlags |= Flags;
                DeviceObject->DeviceObjectExtension->StartIoKey = Key;
            } else {
                Cancelable = Flags & DOE_STARTIO_CANCELABLE;
                DeviceObject->DeviceObjectExtension->StartIoFlags &=
                    ~(DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
                DeviceObject->DeviceObjectExtension->StartIoKey = 0;
                if (Flags & DOE_STARTIO_REQUESTED_BYKEY) {
                    IopStartNextPacketByKey(DeviceObject, Cancelable, Key);
                }else if (Flags &DOE_STARTIO_REQUESTED){
                    IopStartNextPacket(DeviceObject, Cancelable);
                }
            }
            if (InterlockedDecrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) == 0) {
                Flags = DeviceObject->DeviceObjectExtension->StartIoFlags &
                    (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
                Key = DeviceObject->DeviceObjectExtension->StartIoKey;
                if (Flags & (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY)) {
                    doAnotherIteration++;
                }
            }
    } while (doAnotherIteration);
}


VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable)
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/
{
    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        IopStartNextPacketByKeyEx(DeviceObject, 0, DOE_STARTIO_REQUESTED|(Cancelable ? DOE_STARTIO_CANCELABLE : 0));
    } else {
        IopStartNextPacket(DeviceObject, Cancelable);
    }
}

VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG   Key)
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/
{
    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        IopStartNextPacketByKeyEx(DeviceObject, Key, DOE_STARTIO_REQUESTED_BYKEY|(Cancelable ? DOE_STARTIO_CANCELABLE : 0));
    } else {
        IopStartNextPacketByKey(DeviceObject, Cancelable, Key);
    }
}


VOID
IoSetStartIoAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeferredStartIo,
    IN BOOLEAN NonCancelable
    )
/*++

Routine Description:

    This routine sets the StartIo attributes so that drivers can change the
    behaviour of when StartIo can be called.

Arguments:

    DeviceObject - Pointer to device object itself.

    NonCancelable - If TRUE that IRP passed to StartIo is not in the cancelable state.

    DeferredStartIo - If TRUE startIo is not called recursively and is deferred until the previous
                      StartIo call returns to the IO manager.

Return Value:

    None.

--*/
{
    if (DeferredStartIo) {
          DeviceObject->DeviceObjectExtension->StartIoFlags |= DOE_STARTIO_DEFERRED;
    }

    if (NonCancelable) {
        DeviceObject->DeviceObjectExtension->StartIoFlags |= DOE_STARTIO_NO_CANCEL;
    }
}


VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine starts the timer associated with the specified device object.

Arguments:

    DeviceObject - Device object associated with the timer to be started.

Return Value:

    None.

--*/

{
    PIO_TIMER timer;
    KIRQL irql;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (irql);
#endif

    //
    // Get the address of the timer.
    //

    timer = DeviceObject->Timer;

    //
    // If the driver is not being unloaded, then it is okay to start timers.
    //

    if (!(DeviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) {

        //
        // Likewise, check to see whether or not the timer is already
        // enabled.  If so, then simply exit.  Otherwise, enable the timer
        // by placing it into the I/O system timer queue.
        //

        ExAcquireFastLock( &IopTimerLock, &irql );
        if (!timer->TimerFlag) {
            timer->TimerFlag = TRUE;
            IopTimerCount++;
        }
        ExReleaseFastLock( &IopTimerLock, irql );
    }
}

VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routines stops the timer associated with the specified device object
    from invoking being invoked.

Arguments:

    DeviceObject - Device object associated with the timer to be stopped.

Return Value:

    None.

--*/

{
    KIRQL irql;
    PIO_TIMER timer;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (irql);
#endif

    //
    // Obtain the I/O system timer queue lock, and disable the specified
    // timer.
    //

    timer = DeviceObject->Timer;

    ExAcquireFastLock( &IopTimerLock, &irql );
    if (timer->TimerFlag) {
        timer->TimerFlag = FALSE;
        IopTimerCount--;
    }
    ExReleaseFastLock( &IopTimerLock, irql );
}

NTSTATUS
IoSynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Modified Page Writer
    (MPW) to write pages to the disk quickly and with very little overhead.  All
    of the special handling for this request is recognized by setting the
    IRP_PAGING_IO flag in the IRP flags word.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the write should be performed on.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be written to the disk.  All of the pages have been locked
        in memory.  The MDL also describes the length of the write operation.

    StartingOffset - Pointer to the offset in the file from which the write
        should take place.

    Event - A pointer to a kernel event structure to be used for synchronization
        purposes.  The event will be set to the Signlaged state once the pages
        have been written.

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.


--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Increment performance counters
    //

    if (CcIsFileCached(FileObject)) {
        CcDataFlushes += 1;
        CcDataPages += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this out-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    irp->MdlAddress = MemoryDescriptorList;
    irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SYNCHRONOUS_PAGING_IO;

    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the normal write parameters.
    //

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->Parameters.Write.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Write.ByteOffset = *StartingOffset;
    irpSp->FileObject = FileObject;

    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    return IoCallDriver( deviceObject, irp );
}

PEPROCESS
IoThreadToProcess(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a pointer to the process for the specified thread.

Arguments:

    Thread - Thread whose process is to be returned.

Return Value:

    A pointer to the thread's process.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.


--*/

{
    //
    // Simply return the thread's process.
    //

    return THREAD_TO_PROCESS( Thread );
}

VOID
IoUnregisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine removes the device object for the file system from the active
    list of file systems in the system.

Arguments:

    DeviceObject - Pointer to device object for the file system.

Return Value:

    None.


--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Acquire the I/O database resource for a write operation.
    //

    (VOID)ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Remove the device object from whatever queue it happens to be in at the
    // moment.  There is no need to check here to determine if the device queue
    // is in a queue since it is assumed that the caller registered it as a
    // valid file system.
    //

    if (DeviceObject->Queue.ListEntry.Flink != NULL) {
        RemoveEntryList( &DeviceObject->Queue.ListEntry );
    }

    //
    // Notify all of the registered drivers that this file system has been
    // unregistered as an active file system of some type.
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        entry = entry->Flink;
        nPacket->NotificationRoutine( DeviceObject, FALSE );
    }

    IopFsRegistrationOps++;

    //
    // Release the I/O database resource.
    //

    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Decrement the number of reasons that this driver cannot be unloaded.
    //

    IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );
}

VOID
IoUnregisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    )

/*++

Routine Description:

    This routine unregisters the specified driver's notification routine from
    begin invoked whenever a file system registers or unregisters itself as an
    active file system in the system.

Arguments:

    DriverObject - Pointer to the driver object for the driver.

    DriverNotificationRoutine - Address of routine to unregister.

Return Value:

    None.

--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Begin by acquiring the database resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Walk the list of registered notification routines and unregister the
    // specified routine.
    //

    for (entry = IopFsNotifyChangeQueueHead.Flink;
        entry != &IopFsNotifyChangeQueueHead;
        entry = entry->Flink) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        if (nPacket->DriverObject == DriverObject &&
            nPacket->NotificationRoutine == DriverNotificationRoutine) {
            RemoveEntryList( entry );
            ExFreePool( nPacket );
            break;
        }
    }

    ExReleaseResourceLite( &IopDatabaseResource );

    ObDereferenceObject( DriverObject );

}

VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine removes a registered driver from the shutdown notification
    queue.  Henceforth, the driver will not be notified when the system is
    being shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY entry;
    PSHUTDOWN_PACKET shutdown;
    KIRQL irql;

    PAGED_CODE();

    //
    // Lock this code into memory for the duration of this function's execution.
    //

    ASSERT(ExPageLockHandle);
    MmLockPagableSectionByHandle( ExPageLockHandle );

    //
    // Acquire the spinlock that protects the shutdown notification queue, and
    // walk the queue looking for the caller's entry.  Once found, remove it
    // from the queue.  It is an error to not find it, but it is ignored here.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (entry = IopNotifyShutdownQueueHead.Flink;
         entry != &IopNotifyShutdownQueueHead;
         entry = entry->Flink) {

        //
        // An entry has been located.  If it is the one that is being searched
        // for, simply remove it from the list and deallocate it.
        //

        shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );
        if (shutdown->DeviceObject == DeviceObject) {
            RemoveEntryList( entry );
            entry = entry->Blink;
            ObDereferenceObject(DeviceObject);
            ExFreePool( shutdown );
        }
    }

    for (entry = IopNotifyLastChanceShutdownQueueHead.Flink;
         entry != &IopNotifyLastChanceShutdownQueueHead;
         entry = entry->Flink) {

        //
        // An entry has been located.  If it is the one that is being searched
        // for, simply remove it from the list and deallocate it.
        //

        shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );
        if (shutdown->DeviceObject == DeviceObject) {
            RemoveEntryList( entry );
            entry = entry->Blink;
            ObDereferenceObject(DeviceObject);
            ExFreePool( shutdown );
        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    MmUnlockPagableImageSection( ExPageLockHandle );

    DeviceObject->Flags &= ~DO_SHUTDOWN_REGISTERED;

}

VOID
IoUpdateShareAccess(
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine updates the share access context for a file according to
    the desired access and share access by the current open requestor.  The
    IoCheckShareAccess routine must already have been invoked and succeeded
    in order to invoke this routine.  Note that when the former routine was
    invoked the Update parameter must have been FALSE.

Arguments:

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

Return Value:

    None.

--*/

{
    BOOLEAN update = TRUE;

    PAGED_CODE();

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {

            //
            //  This fileobject is marked to ignore share access checks
            //  so we also don't want to affect the file/directory's
            //  ShareAccess structure counts.
            //

            update = FALSE;
        }
    }

    //
    // Check to see whether or not the desired accesses need read, write,
    // or delete access to the file.
    //

    if ((FileObject->ReadAccess ||
         FileObject->WriteAccess ||
         FileObject->DeleteAccess) &&
        update) {

        //
        // The open request requires read, write, or delete access so update
        // the share access context for the file.
        //

        ShareAccess->OpenCount++;

        ShareAccess->Readers += FileObject->ReadAccess;
        ShareAccess->Writers += FileObject->WriteAccess;
        ShareAccess->Deleters += FileObject->DeleteAccess;

        ShareAccess->SharedRead += FileObject->SharedRead;
        ShareAccess->SharedWrite += FileObject->SharedWrite;
        ShareAccess->SharedDelete += FileObject->SharedDelete;
    }
}


NTSTATUS
IoVerifyVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    )

/*++

Routine Description:

    This routine is invoked to check a mounted volume on the specified device
    when it appears as if the media may have changed since it was last
    accessed.  If the volume is not the same volume, and a new mount is not
    to be attempted, return the error.

    If the verify fails, this routine is used to perform a new mount operation
    on the device.  In this case, a "clean" VPB is allocated and a new mount
    operation is attempted.  If no mount operation succeeds, then again the
    error handling described above occurs.

Arguments:

    DeviceObject - Pointer to device object on which the volume is to be
        mounted.

    AllowRawMount - Indicates that this verify is on behalf of a DASD open
        request, thus we want to allow a raw mount if the verify fails.

Return Value:

    The function value is a successful status code if a volume was successfully
    mounted on the device.  Otherwise, an error code is returned.


--*/

{
    NTSTATUS status;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN verifySkipped = FALSE;
    PDEVICE_OBJECT fsDeviceObject;
    PDEVICE_OBJECT fsBaseDeviceObject;
    PVPB    mountVpb;
    PVPB    vpb;

    PAGED_CODE();

    //
    //  Acquire the DeviceObject lock.  Nothing in this routine can raise
    //  so no try {} finally {} is required.
    //

    status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL );

    ASSERT( status == STATUS_SUCCESS );

    //
    // If this volume is not mounted by anyone, skip the verify operation,
    // but do the mount.
    //

    if (!IopReferenceVerifyVpb(DeviceObject, &vpb, &fsBaseDeviceObject)) {


        verifySkipped = TRUE;

        status = STATUS_SUCCESS;

    } else {

        //
        // This volume needs to be verified.  Initialize the event to be
        // used while waiting for the operation to complete.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );
        status = STATUS_UNSUCCESSFUL;

        //
        // Allocate and initialize an IRP for this verify operation.  Notice
        // that the flags for this operation appear the same as a page read
        // operation.  This is because the completion code for both of the
        // operations is exactly the same logic.
        //

        fsDeviceObject = fsBaseDeviceObject;

        while (fsDeviceObject->AttachedDevice) {
            fsDeviceObject = fsDeviceObject->AttachedDevice;
        }
        irp = IoAllocateIrp( fsDeviceObject->StackSize, FALSE );
        if (!irp) {

            KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irp->Flags = IRP_MOUNT_COMPLETION | IRP_SYNCHRONOUS_PAGING_IO;
        irp->RequestorMode = KernelMode;
        irp->UserEvent = &event;
        irp->UserIosb = &ioStatus;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = IRP_MN_VERIFY_VOLUME;
        irpSp->Flags = AllowRawMount ? SL_ALLOW_RAW_MOUNT : 0;
        irpSp->Parameters.VerifyVolume.Vpb = vpb;
        irpSp->Parameters.VerifyVolume.DeviceObject = fsBaseDeviceObject;

        status = IoCallDriver( fsDeviceObject, irp );

        //          IopLoadFileSystemDriver
        // Wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = ioStatus.Status;
        }

        //
        // Deref the VPB obtained above.
        //

        IopDereferenceVpbAndFree(vpb);
    }

    //
    // If the verify operation was skipped or unsuccessful perform a mount
    // operation.
    //

    if ((status == STATUS_WRONG_VOLUME) || verifySkipped) {

        //
        // A mount operation is to be attempted.  Allocate a new VPB
        // for this device and attempt to mount it.
        //

        if (NT_SUCCESS(IopCreateVpb (DeviceObject))) {

            PoVolumeDevice (DeviceObject);

            //
            // Now mount the volume.
            //

            mountVpb = NULL;
            if (!NT_SUCCESS( IopMountVolume( DeviceObject, AllowRawMount, TRUE, FALSE, &mountVpb ) )) {
                DeviceObject->Flags &= ~DO_VERIFY_VOLUME;
            } else {
                if (mountVpb) {

                    //
                    // Decrement  the reference allocated in IopMountVolume.
                    //

                    IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                                  (PLONG) &mountVpb->ReferenceCount );
                }
            }
        } else {
            DeviceObject->Flags &= ~DO_VERIFY_VOLUME;
        }
    }

    //
    //  Release the device lock.
    //

    KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );

    //
    // Return the status from the verify operation as the final status of
    // this function.
    //

    return status;
}

VOID
IoWriteErrorLogEntry(
    IN OUT PVOID ElEntry
    )

/*++

Routine Description:

    This routine places the error log entry specified by the input argument
    onto the queue of buffers to be written to the error log process's port.
    The error log thread will then actually send it.

Arguments:

    ElEntry Pointer to the error log entry.

Return Value:

    None.

--*/

{
    PERROR_LOG_ENTRY entry;
    KIRQL oldIrql;

    //
    // Get the address of the error log entry header, acquire the spin lock,
    // insert the entry onto the queue, if there are no pending requests
    // then queue a worker thread request and release the spin lock.
    //

    entry = ((PERROR_LOG_ENTRY) ElEntry) - 1;

    if (IopErrorLogDisabledThisBoot) {
        //
        // Do nothing, drop the reference.
        //

        if (entry->DeviceObject != NULL) {
            //
            // IopErrorLogThread tests for NULL before derefing.
            // So do the same here.
            //
            ObDereferenceObject (entry->DeviceObject);
        }
        if (entry->DriverObject != NULL) {
            ObDereferenceObject (entry->DriverObject);
        }

        InterlockedExchangeAdd( &IopErrorLogAllocation,
                               -((LONG) (entry->Size )));
        ExFreePool (entry);
        return;

    }

    //
    // Set the time that the entry was logged.
    //

    KeQuerySystemTime( (PVOID) &entry->TimeStamp );

    ExAcquireSpinLock( &IopErrorLogLock, &oldIrql );

    //
    // Queue the request to the error log queue.
    //

    InsertTailList( &IopErrorLogListHead, &entry->ListEntry );

    //
    // If there is no pending work, then queue a request to a worker thread.
    //

    if (!IopErrorLogPortPending) {

        IopErrorLogPortPending = TRUE;

        ExInitializeWorkItem( &IopErrorLogWorkItem, IopErrorLogThread, NULL );
        ExQueueWorkItem( &IopErrorLogWorkItem, DelayedWorkQueue );

    }

    ExReleaseSpinLock(&IopErrorLogLock, oldIrql);
}

NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine provides the caller with the signature and offset of
    the boot disk and system disk. This information is obtained from the
    loader block. The callers have to be boot drivers which have registered
    for a callback once all disk devices have been started
Arguments:

    BootDiskInformation - Supplies a pointer to the structure allocated by the
    caller for requested information.
    Size - Size of the BootDiskInformation structure.

Return Value:

    STATUS_SUCCESS - successful.
    STATUS_TOO_LATE - indicates that the Loader Block has already been freed
    STATUS_INVALID_PARAMETER - size allocated for boot disk information
    is insufficient.

--*/

{
    PLOADER_PARAMETER_BLOCK LoaderBlock = NULL;
    STRING arcBootDeviceString;
    CHAR deviceNameBuffer[128];
    STRING deviceNameString;
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    CHAR arcNameBuffer[128];
    STRING arcNameString;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    DISK_GEOMETRY diskGeometry;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayout;
    PLIST_ENTRY listEntry;
    PARC_DISK_SIGNATURE diskBlock;
    ULONG diskNumber;
    ULONG partitionNumber;
    PCHAR arcName;
    PIRP irp;
    KEVENT event;
    BOOLEAN singleBiosDiskFound;
    PARC_DISK_INFORMATION arcInformation;
    ULONG totalDriverDisksFound = IoGetConfigurationInformation()->DiskCount;
    STRING arcSystemDeviceString;
    PARTITION_INFORMATION_EX PartitionInfo;
    PBOOTDISK_INFORMATION_EX    bootDiskInformationEx;
    ULONG diskSignature = 0;

    PAGED_CODE();

    if (IopLoaderBlock == NULL) {
        return STATUS_TOO_LATE;
    }

    if (Size < sizeof(BOOTDISK_INFORMATION)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Size < sizeof(BOOTDISK_INFORMATION_EX)) {
        bootDiskInformationEx = NULL;
    } else {
        bootDiskInformationEx = (PBOOTDISK_INFORMATION_EX)BootDiskInformation;
    }

    LoaderBlock = (PLOADER_PARAMETER_BLOCK)IopLoaderBlock;
    arcInformation = LoaderBlock->ArcDiskInformation;

    //
    // If a single bios disk was found if there is only a
    // single entry on the disk signature list.
    //
    singleBiosDiskFound = (arcInformation->DiskSignatures.Flink->Flink ==
                           &arcInformation->DiskSignatures) ? (TRUE) : (FALSE);

    //
    // Get ARC boot device name from loader block.
    //

    RtlInitAnsiString( &arcBootDeviceString,
                       LoaderBlock->ArcBootDeviceName );
    //
    // Get ARC system device name from loader block.
    //

    RtlInitAnsiString( &arcSystemDeviceString,
                       LoaderBlock->ArcHalDeviceName );
    //
    // For each disk, get its drive layout and check to see if the
    // signature is among the list of signatures in the loader block.
    // If yes, check to see if the disk contains the boot or system
    // partitions. If yes, fill up the requested structure.
    //

    for (diskNumber = 0;
         diskNumber < totalDriverDisksFound;
         diskNumber++) {

        //
        // Construct the NT name for a disk and obtain a reference.
        //

        sprintf( deviceNameBuffer,
                 "\\Device\\Harddisk%d\\Partition0",
                 diskNumber );
        RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
        status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                               &deviceNameString,
                                               TRUE );
        if (!NT_SUCCESS( status )) {
            continue;
        }

        status = IoGetDeviceObjectPointer( &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );
        RtlFreeUnicodeString( &deviceNameUnicodeString );

        if (!NT_SUCCESS( status )) {
            continue;
        }

        //
        // Create IRP for get drive geometry device control.
        //

        irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &diskGeometry,
                                             sizeof(DISK_GEOMETRY),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
        if (!irp) {
            ObDereferenceObject( fileObject );
            continue;
        }

        KeInitializeEvent( &event,
                           NotificationEvent,
                           FALSE );
        status = IoCallDriver( deviceObject,
                               irp );

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &event,
                                   Suspended,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            status = ioStatusBlock.Status;
        }

        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Get partition information for this disk.
        //

        status = IoReadPartitionTableEx( deviceObject,
                                       &driveLayout );


        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Make sure sector size is at least 512 bytes.
        //

        if (diskGeometry.BytesPerSector < 512) {
            diskGeometry.BytesPerSector = 512;
        }



        ObDereferenceObject( fileObject );

        //
        // For each ARC disk information record in the loader block
        // match the disk signature and checksum to determine its ARC
        // name and construct the NT ARC names symbolic links.
        //

        for (listEntry = arcInformation->DiskSignatures.Flink;
             listEntry != &arcInformation->DiskSignatures;
             listEntry = listEntry->Flink) {

            //
            // Get next record and compare disk signatures.
            //

            diskBlock = CONTAINING_RECORD( listEntry,
                                           ARC_DISK_SIGNATURE,
                                           ListEntry );

            //
            // Compare disk signatures.
            //
            // Or if there is only a single disk drive from
            // both the bios and driver viewpoints then
            // assign an arc name to that drive.
            //

            if ((singleBiosDiskFound &&
                 (totalDriverDisksFound == 1) &&
                 (driveLayout->PartitionStyle == PARTITION_STYLE_MBR)) ||
                IopVerifyDiskSignature(driveLayout, diskBlock, &diskSignature)) {

                //
                // Create unicode ARC name for this partition.
                //

                arcName = diskBlock->ArcName;
                sprintf( arcNameBuffer,
                         "\\ArcName\\%s",
                         arcName );
                RtlInitAnsiString( &arcNameString, arcNameBuffer );

                //
                // Create an ARC name for every partition on this disk.
                //

                for (partitionNumber = 0;
                     partitionNumber < driveLayout->PartitionCount;
                     partitionNumber++) {

                    //
                    // Create unicode NT device name.
                    //

                    sprintf( deviceNameBuffer,
                             "\\Device\\Harddisk%d\\Partition%d",
                             diskNumber,
                             partitionNumber+1 );
                    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

                    status = RtlAnsiStringToUnicodeString(
                                                       &deviceNameUnicodeString,
                                                       &deviceNameString,
                                                       TRUE );

                    if (!NT_SUCCESS( status )) {
                        continue;
                    }


                    //
                    // If we came through the single disk case.
                    //

                    if (diskSignature == 0) {
                        diskSignature = driveLayout->Mbr.Signature;
                    }

                    //
                    // Create unicode ARC name for this partition and
                    // check to see if this is the boot disk.
                    //

                    sprintf( arcNameBuffer,
                             "%spartition(%d)",
                             arcName,
                             partitionNumber+1 );
                    RtlInitAnsiString( &arcNameString, arcNameBuffer );
                    if (RtlEqualString( &arcNameString,
                                        &arcBootDeviceString,
                                        TRUE )) {


                        BootDiskInformation->BootDeviceSignature = diskSignature;

                        //
                        // Get Partition Information for the offset of the
                        // partition within the disk
                        //
                        status = IoGetDeviceObjectPointer(
                                           &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );

                        if (!NT_SUCCESS( status )) {
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        //
                        // Create IRP for get drive geometry device control.
                        //

                        irp = IoBuildDeviceIoControlRequest(
                                             IOCTL_DISK_GET_PARTITION_INFO_EX,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &PartitionInfo,
                                             sizeof(PARTITION_INFORMATION_EX),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
                        if (!irp) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        KeInitializeEvent( &event,
                                           NotificationEvent,
                                           FALSE );
                        status = IoCallDriver( deviceObject,
                                               irp );

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject( &event,
                                                   Suspended,
                                                   KernelMode,
                                                   FALSE,
                                                   NULL );
                            status = ioStatusBlock.Status;
                        }

                        if (!NT_SUCCESS( status )) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }
                        BootDiskInformation->BootPartitionOffset =
                                        PartitionInfo.StartingOffset.QuadPart;

                        if (driveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->BootDeviceIsGpt = TRUE;

                                //
                                // Structure copy.
                                //

                                bootDiskInformationEx->BootDeviceGuid = driveLayout->Gpt.DiskId;
                            }
                        } else {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->BootDeviceIsGpt = FALSE;
                            }
                        }

                        ObDereferenceObject( fileObject );
                    }

                    //
                    // See if this is the system partition.
                    //
                    if (RtlEqualString( &arcNameString,
                                        &arcSystemDeviceString,
                                        TRUE )) {
                        BootDiskInformation->SystemDeviceSignature = diskSignature;
                        //
                        // Get Partition Information for the offset of the
                        // partition within the disk
                        //

                        status = IoGetDeviceObjectPointer(
                                           &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );

                        if (!NT_SUCCESS( status )) {
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        //
                        // Create IRP for get drive geometry device control.
                        //

                        irp = IoBuildDeviceIoControlRequest(
                                             IOCTL_DISK_GET_PARTITION_INFO_EX,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &PartitionInfo,
                                             sizeof(PARTITION_INFORMATION_EX),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
                        if (!irp) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        KeInitializeEvent( &event,
                                           NotificationEvent,
                                           FALSE );
                        status = IoCallDriver( deviceObject,
                                               irp );

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject( &event,
                                                   Suspended,
                                                   KernelMode,
                                                   FALSE,
                                                   NULL );
                            status = ioStatusBlock.Status;
                        }

                        if (!NT_SUCCESS( status )) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }
                        BootDiskInformation->SystemPartitionOffset =
                                        PartitionInfo.StartingOffset.QuadPart;

                        if (driveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->SystemDeviceIsGpt = TRUE;

                                //
                                // Structure copy.
                                //

                                bootDiskInformationEx->SystemDeviceGuid = driveLayout->Gpt.DiskId;
                            }
                        } else {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->SystemDeviceIsGpt = FALSE;
                            }
                        }

                        ObDereferenceObject( fileObject );
                    }

                    RtlFreeUnicodeString( &deviceNameUnicodeString );
                }
            }
        }
        ExFreePool( driveLayout );
    }
    return STATUS_SUCCESS;
}

//
// Thunks to support standard call callers
//

#ifdef IoCallDriver
#undef IoCallDriver
#endif

NTSTATUS
IoCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    return IofCallDriver (DeviceObject, Irp);
}



#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif

VOID
IoCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    IofCompleteRequest (Irp, PriorityBoost);
}

PSECURITY_DESCRIPTOR
IopCreateDefaultDeviceSecurityDescriptor(
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN DeviceHasName,
    IN PUCHAR Buffer,
    OUT PACL *AllocatedAcl,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    )
/*++

Routine Description:

    This routine creates a security descriptor for a device object. The security descriptor is
    set based on the device type.
    This can be called from PnP MGR or IoCreateDevice.

Arguments:

    DeviceType  - Type of Device
    DeviceCharacteristics - Characterisctics of the device.
    DeviceHasName - TRUE if device object has a name
    Buffer - Storage for security descriptor
    AllocatedAcl - Is non-null if this routine allocated an ACL.
    SecurityInformation - OUT parameter where SecurityInformation is passed.

Return Value:

    PSECURITY_DESCRIPTOR. NULL on error.
--*/
{
    PSECURITY_DESCRIPTOR descriptor = (PSECURITY_DESCRIPTOR) Buffer;

    NTSTATUS status;

    PAGED_CODE();

    if(ARGUMENT_PRESENT(SecurityInformation)) {
        (*SecurityInformation) = 0;
    }

    *AllocatedAcl = NULL;


    switch ( DeviceType ) {

        case FILE_DEVICE_DISK_FILE_SYSTEM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
        case FILE_DEVICE_FILE_SYSTEM:
        case FILE_DEVICE_TAPE_FILE_SYSTEM: {

            //
            // Use the standard public default protection for these types of devices.
            //
            status = IopCreateSecurityDescriptorPerType(
                                descriptor,
                                IO_SD_SYS_ALL_ADM_ALL_WORLD_E_RES_E,
                                SecurityInformation
                                );

            break;
        }

        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_MASS_STORAGE:
        case FILE_DEVICE_DISK:
        case FILE_DEVICE_VIRTUAL_DISK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
        case FILE_DEVICE_DFS_FILE_SYSTEM:
        case FILE_DEVICE_NETWORK: {

            if ((DeviceHasName) &&
                ((DeviceCharacteristics & FILE_FLOPPY_DISKETTE) != 0)) {

                status = IopCreateSecurityDescriptorPerType(
                                    descriptor,
                                    IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE,
                                    SecurityInformation
                                    );

            } else {

                UCHAR i;
                PACL acl;
                BOOLEAN aceFound;
                BOOLEAN aceFoundForCDROM;
                PACCESS_ALLOWED_ACE ace;

                //
                // Protect the device so that an administrator can run chkdsk
                // on it. This is done by making a copy of the default public
                // ACL and changing the accesses granted to the administrators
                // alias.
                //
                // The logic here is:
                //
                //      - Copy the public default dacl into another buffer
                //
                //      - Find the ACE granting ADMINISTRATORS access
                //
                //      - Change the granted access mask of that ACE to give
                //        administrators write access.
                //
                //

                acl = ExAllocatePoolWithTag(
                        PagedPool,
                        SePublicDefaultUnrestrictedDacl->AclSize,
                        'eSoI' );

                if (!acl) {
                    return NULL;
                }

                RtlCopyMemory( acl,
                               SePublicDefaultUnrestrictedDacl,
                               SePublicDefaultUnrestrictedDacl->AclSize );

                //
                // Find the Administrators ACE
                //

                aceFound = FALSE;
                aceFoundForCDROM = FALSE;

                for ( i = 0, status = RtlGetAce(acl, 0, &ace);
                      NT_SUCCESS(status);
                      i++, status = RtlGetAce(acl, i, &ace)) {

                    PSID sid;

                    sid = &(ace->SidStart);
                    if (RtlEqualSid( SeAliasAdminsSid, sid )) {

                        ace->Mask |= ( GENERIC_READ |
                                       GENERIC_WRITE |
                                       GENERIC_EXECUTE );

                        aceFound = TRUE;
                    }

                    if (DeviceType == FILE_DEVICE_CD_ROM) {

                         if (RtlEqualSid( SeWorldSid, sid )) {
                             ace->Mask |= GENERIC_READ;
                             aceFoundForCDROM = TRUE;
                         }
                     }
                }

                //
                // If the ACE wasn't found, then the public default ACL has been
                // changed.  For this case, this code needs to be updated to match
                // the new public default DACL.
                //

                ASSERT(aceFound == TRUE);

                if (DeviceType == FILE_DEVICE_CD_ROM) {
                    ASSERT(aceFoundForCDROM == TRUE);
                }

                //
                // Finally, build a full security descriptor from the above DACL.
                //

                RtlCreateSecurityDescriptor( descriptor,
                                             SECURITY_DESCRIPTOR_REVISION );

                RtlSetDaclSecurityDescriptor( descriptor,
                                              TRUE,
                                              acl,
                                              FALSE );

                if(ARGUMENT_PRESENT(SecurityInformation)) {
                    (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
                }

                *AllocatedAcl = acl;
                status = STATUS_SUCCESS;
            }

            break;
        }

        default: {

            status = IopCreateSecurityDescriptorPerType(
                                descriptor,
                                IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE,
                                SecurityInformation
                                );

            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    return descriptor;
}

NTSTATUS
IopCreateSecurityDescriptorPerType(
    IN  PSECURITY_DESCRIPTOR  Descriptor,
    IN  ULONG                 SecurityDescriptorFlavor,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    )
/*++

Routine Description:

    This routine creates a security descriptor based on the flavor.

Arguments:

    Descriptor - Storage for security descriptor
    SecurityInformation - OUT parameter where SecurityInformation is passed.
    SecurityDescriptorFlavor - Type used to determine the security descriptor flavor.

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS    status;
    PACL        acl;

    switch (SecurityDescriptorFlavor) {
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_E           :
            acl = SePublicDefaultDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_E_RES_E     :
            acl = SePublicDefaultUnrestrictedDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE         :
            acl = SePublicOpenDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE  :
            acl = SePublicOpenUnrestrictedDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_RE                    :
            acl = SeSystemDefaultDacl;
            break;
        default:
            ASSERT(0);
            return STATUS_INVALID_PARAMETER;
    }

    status = RtlCreateSecurityDescriptor(
                Descriptor,
                SECURITY_DESCRIPTOR_REVISION );

    ASSERT( NT_SUCCESS( status ) );

    status = RtlSetDaclSecurityDescriptor(
                Descriptor,
                TRUE,
                acl,
                FALSE );


    if(ARGUMENT_PRESENT(SecurityInformation)) {
        (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
    }
    return status;
}

NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    )

/*++

Routine Description:

    This routine returns the session ID for process that originally
    requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

    pSessionId - Pointer to the session Id which is set upon successful return.

Return Value:

    Returns STATUS_SUCCESS if the session ID was available, otherwise
    STATUS_UNSUCCESSFUL.

--*/

{
    PEPROCESS Process;

    //
    // Get the address of the process that requested the I/O operation.
    //

    if (Irp->Tail.Overlay.Thread) {
        Process = THREAD_TO_PROCESS( Irp->Tail.Overlay.Thread );
        *pSessionId = MmGetSessionId(Process);
        return(STATUS_SUCCESS);
    }

    *pSessionId = (ULONG) -1;
    return(STATUS_UNSUCCESSFUL);
}


VOID
IopUpdateOtherOperationCount(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to update the operation count for the current
    process to indicate that an I/O service other than a read or write
    has been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        IoOtherOperationCount += 1;
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->OtherOperationCount, 1);
    }
}


VOID
IopUpdateReadOperationCount(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to update the read operation count for the
    current process to indicate that the NtReadFile system service has
    been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        IoReadOperationCount += 1;
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->ReadOperationCount, 1);
    }
}


VOID
IopUpdateWriteOperationCount(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to update the write operation count for the
    current process to indicate that the NtWriteFile service other has
    been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        IoWriteOperationCount += 1;
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->WriteOperationCount, 1);
    }
}

VOID
IopUpdateOtherTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the transfer count for the current
    process for an operation other than a read or write system service.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        ExInterlockedAddLargeStatistic( &IoOtherTransferCount, TransferCount );
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->OtherTransferCount, TransferCount);
    }
}


VOID
IopUpdateReadTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the read transfer count for the
    current process.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        ExInterlockedAddLargeStatistic( &IoReadTransferCount, TransferCount );
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->ReadTransferCount, TransferCount);
    }
}

VOID
IopUpdateWriteTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the write transfer count for the
    current process.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {
        ExInterlockedAddLargeStatistic( &IoWriteTransferCount, TransferCount );
        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->WriteTransferCount, TransferCount);
    }
}

VOID
IoCancelFileOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine is invoked by a filter driver to send a close to the
    next filesystem driver below. It's needed as part of the file open
    process. The filter driver forwards the open to the FSD and the FSD
    returns success. The filter driver then examines some stuff and
    decides that the open has to be failed. In this case it has to send
    a close to the FSD.

    We can safely assume a thread context because it has to be called only
    in the context of file open. If the file object already has a handle
    then the owner of the handle can then simply close the handle to the
    file object and we will close the file.

    This code is extracted from IopCloseFile and IopDeleteFile. So it is
    duplication of code but it prevents duplication elsewhere in other FSDs.

Arguments:

    FileObject - Points to the file that needs to be closed.

    DeviceObject - Points to the device object of the filesystem driver below
        the filter driver.

Return Value:

    None

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    KEVENT event;
    KIRQL irql;
    IO_STATUS_BLOCK ioStatusBlock;
    PVPB vpb;

    //
    // Cannot call this function if a handle has already been created
    // for this file.
    //
    ASSERT(!(FileObject->Flags & FO_HANDLE_CREATED));

    if (ObReferenceObject(FileObject) > 2 || (FileObject->Flags & FO_HANDLE_CREATED)) {
        KeBugCheckEx( INVALID_CANCEL_OF_FILE_OPEN, (ULONG_PTR) FileObject, (ULONG_PTR)DeviceObject, 0, 0 );
        return;
    }

    ObDereferenceObject(FileObject);

    //
    // Initialize the local event that will be used to synchronize access
    // to the driver completing this I/O operation.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Reset the event in the file object.
    //

    KeClearEvent( &FileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.
    //

    irp = IopAllocateIrpMustSucceed( DeviceObject->StackSize );
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = &event;
    irp->UserIosb = &irp->IoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.  No
    // function-specific parameters are required for this operation.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_CLEANUP;
    irpSp->FileObject = FileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Invoke the driver at its appropriate dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // If no error was incurred, wait for the I/O operation to complete.
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
    }

    //
    // The following code tears down the IRP by hand since it may not
    // be possible for it to be completed (either because this code was
    // invoked as APC_LEVEL in the first place - or because the reference
    // count on the object cannot be incremented due to this routine
    // being invoked by the delete file procedure below).  Cleanup IRPs
    // therefore use close semantics (the close operation flag is set
    // in the IRP) so that the I/O complete request routine itself sets
    // the event to the Signaled state.
    //

    KeRaiseIrql( APC_LEVEL, &irql );
    IopDequeueThreadIrp( irp );
    KeLowerIrql( irql );

    //
    // Reuse the IRP for the next operation.
    //

    IoReuseIrp( irp , STATUS_SUCCESS);

    //
    // Reset the event in the file object.
    //

    KeClearEvent( &FileObject->Event );
    KeClearEvent(&event);

    //
    // Get a pointer to the stack location for the first driver.  This is
    // where the function codes and parameters are placed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP, indicating that this file object is being deleted.
    //

    irpSp->MajorFunction = IRP_MJ_CLOSE;
    irpSp->FileObject = FileObject;
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = &event;
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

    //
    // Place this packet in the thread's I/O pending queue.
    //

    IopQueueThreadIrp( irp );

    //
    // Decrement the reference count on the VPB, if necessary.  We
    // have to do this BEFORE handing the Irp to the file system
    // because of a trick the file systems play with close, and
    // believe me, you really don't want to know what it is.
    //
    // Since there is not a error path here (close cannot fail),
    // and the file system is the only ome who can actually synchronize
    // with the actual completion of close processing, the file system
    // is the one responsible for Vpb deletion.
    //

    vpb = FileObject->Vpb;

    if (vpb && !(FileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                      (PLONG) &vpb->ReferenceCount );

        FileObject->Flags |= FO_FILE_OPEN_CANCELLED;
    }

    //
    // Give the device driver the packet.  If this request does not work,
    // there is nothing that can be done about it.  This is unfortunate
    // because the driver may have had problems that it was about to
    // report about other operations (e.g., write behind failures, etc.)
    // that it can no longer report.  The reason is that this routine
    // is really initially invoked by NtClose, which has already closed
    // the caller's handle, and that's what the return status from close
    // indicates:  the handle has successfully been closed.
    //

    status = IoCallDriver( DeviceObject, irp );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
    }

    //
    // Perform any completion operations that need to be performed on
    // the IRP that was used for this request.  This is done here as
    // as opposed to in normal completion code because there is a race
    // condition between when this routine executes if it was invoked
    // from a special kernel APC (e.g., some IRP was just completed and
    // dereferenced this file object for the last time), and when the
    // special kernel APC because of this packet's completion executing.
    //
    // This problem is solved by not having to queue a special kernel
    // APC routine for completion of this packet.  Rather, it is treated
    // much like a synchronous paging I/O operation, except that the
    // packet is not even freed during I/O completion.  This is because
    // the packet is still in this thread's queue, and there is no way
    // to get it out except at APC_LEVEL.  Unfortunately, the part of
    // I/O completion that needs to dequeue the packet is running at
    // DISPATCH_LEVEL.
    //
    // Hence, the packet must be removed from the queue (synchronized,
    // of course), and then it must be freed.
    //

    KeRaiseIrql( APC_LEVEL, &irql );
    IopDequeueThreadIrp( irp );
    KeLowerIrql( irql );

    IoFreeIrp( irp );

}

VOID
IoRetryIrpCompletions(
    VOID
    )
/*++

Routine Description:

    This routine is called from Mm when a page fault has completed. It's
    called on the special occasion when a thread faults a page and then when
    it's waiting for the inpage to complete, an IopCompleteRequest APC fires
    and we fault the same page again (say if the user buffer falls on the
    same page).  Note the fault during the APC may be referencing the same or
    a different user virtual address but this is irrelevant - the problem lies
    in the fact that both virtual address references are to the same physical
    page and thus result in a collided fault in the Mm.

    Mm detects this case (to avoid deadlock) and returns STATUS_FAULT_COLLISION
    and the I/O manager bails out the APC after marking the Irp with the flag
    IRP_RETRY_IO_COMPLETION. Later on when Mm has decided the fault has
    progressed far enough to avoid deadlock, it calls back into this routine
    which calls IopCompleteRequest again.  The code in IopCompleteRequest is
    written in a reentrant way so that the retry knows the completion is only
    partially processed so far. We can fault in two places in IopCompleteRequest
    and in both cases if we call IopCompleteRequest again they will now work.

    This call must be called in the context of the thread that is faulting.
    This function is called at APC_LEVEL or below.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL irql;
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    PETHREAD thread;
    PIRP irp;
    PVOID saveAuxiliaryPointer = NULL;
    PFILE_OBJECT fileObject;

    thread = PsGetCurrentThread();

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    header = &thread->IrpList;
    entry = thread->IrpList.Flink;

    //
    // Walk the list of pending IRPs, completing each of them.
    //

    while (header != entry) {

        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        entry = entry->Flink;

        if (irp->Flags & IRP_RETRY_IO_COMPLETION) {

            ASSERT(!(irp->Flags & IRP_CREATE_OPERATION));

            irp->Flags &= ~IRP_RETRY_IO_COMPLETION;
            fileObject = irp->Tail.Overlay.OriginalFileObject;
            IopCompleteRequest(
                    &irp->Tail.Apc,
                    NULL,
                    NULL,
                    &fileObject,
                    &saveAuxiliaryPointer);
        }
    }

    KeLowerIrql( irql );
}

#if defined(_WIN64)
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp OPTIONAL
    )
/*+++

Routine Description:

   This API returns TRUE if the process that originated the IRP is running a 32 bit x86
   application. If there is no IRP then a NULL can be passed to the API and that implies
   that the current process context is used to test if its running a 32 bit x86 application.
   Its assumed a NULL will be passed by drivers executing in the fast io path.

Arguments:

    IRP  OPTIONAL.

Return Value:

    None.

--*/
{
    if (Irp) {
        if (Irp->RequestorMode == UserMode) {
            PEPROCESS Process;
            Process = IoGetRequestorProcess(Irp);
            if (Process && PsGetProcessWow64Process(Process)) {
                return TRUE;
            }
        }
    } else {
        if ((ExGetPreviousMode() == UserMode) &&
                (PsGetProcessWow64Process(PsGetCurrentProcess()))) {
            return TRUE;
        }
    }
    return FALSE;
}
#endif

NTSTATUS
IoAsynchronousPageRead(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
{
    return IopPageReadInternal(FileObject,
                        MemoryDescriptorList,
                        StartingOffset,
                        Event,
                        IoStatusBlock,
                        TRUE
                        );
}

NTSTATUS
IoQueryFileDosDeviceName(
    IN PFILE_OBJECT FileObject,
    OUT POBJECT_NAME_INFORMATION *ObjectNameInformation
    )

/*++

Routine Description:

    Thin shell around IopQueryNameInternal that returns a dos device name
    for a file e.g c:\foo

Arguments:

    FileObject - Points to the file that needs to be closed.

    ObjectNameInformation - structure to return name in note this will be a flat
      unicode string where the buffer is adjancent to the string

    RetLength - returned length of structure

Return Value:

    None

--*/

{
    ULONG ObjectNameInfoLength;
    POBJECT_NAME_INFORMATION ObjectNameInfo;
    NTSTATUS Status;

    //
    //  Allocate an initial buffer to query the filename, query, then
    //  retry if needed with the correct length.
    //

    ObjectNameInfoLength = 96*sizeof(WCHAR) + sizeof(UNICODE_STRING);

    while (TRUE) {

        ObjectNameInfo = ExAllocatePoolWithTag( PagedPool, ObjectNameInfoLength, 'nDoI');

        if (ObjectNameInfo == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Status = IopQueryNameInternal( FileObject,
                                       TRUE,
                                       TRUE,
                                       ObjectNameInfo,
                                       ObjectNameInfoLength,
                                       &ObjectNameInfoLength,
                                       KernelMode );

        if (Status == STATUS_SUCCESS) {
            *ObjectNameInformation = ObjectNameInfo;
            break;
        }

        ExFreePool( ObjectNameInfo );

        if (Status != STATUS_BUFFER_OVERFLOW) {
            break;
        }
    }

    return Status;
}


NTSTATUS
IopUnloadSafeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_UNLOAD_SAFE_COMPLETION_CONTEXT Usc = Context;
    NTSTATUS Status;

    ObReferenceObject (Usc->DeviceObject);

    Status = Usc->CompletionRoutine (DeviceObject, Irp, Usc->Context);

    ObDereferenceObject (Usc->DeviceObject);
    ExFreePool (Usc);
    return Status;
}


NTSTATUS
IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN InvokeOnSuccess,
    IN BOOLEAN InvokeOnError,
    IN BOOLEAN InvokeOnCancel
    )
//++
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver. This routine obtains a reference count to the specified device object
//     to protect the completion routine from unload problems.
//
// Arguments:
//
//     DeviceObject - Device object to take references on.
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--
{
    PIO_UNLOAD_SAFE_COMPLETION_CONTEXT Usc;

    Usc = ExAllocatePoolWithTag (NonPagedPool, sizeof (*Usc), 'sUoI');
    if (Usc == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Usc->DeviceObject      = DeviceObject;
    Usc->CompletionRoutine = CompletionRoutine;
    Usc->Context           = Context;
    IoSetCompletionRoutine (Irp, IopUnloadSafeCompletion, Usc, InvokeOnSuccess, InvokeOnError, InvokeOnCancel);
    return STATUS_SUCCESS;
}

NTSTATUS
IoCreateDriver(
    IN PUNICODE_STRING DriverName    OPTIONAL,
    IN PDRIVER_INITIALIZE InitializationFunction
    )
/*++

Routine Description:

    This routine creates a driver object for a kernel component that
    was not loaded as a driver.  If the creation of the driver object
    succeeds, Initialization function is invoked with the same parameters
    as passed to DriverEntry.

Parameters:

    DriverName - Supplies the name of the driver for which a driver object
                 is to be created.

    InitializationFunction - Equivalent to DriverEntry().

ReturnValue:

    Status code that indicates whether or not the function was successful.

Notes:

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    PDRIVER_OBJECT driverObject;
    HANDLE driverHandle;
    ULONG objectSize;
    USHORT length;
    UNICODE_STRING driverName, serviceName;
    WCHAR buffer[60];
    ULONG i;

    PAGED_CODE();

    if (DriverName == NULL) {

        //
        // Madeup a name for the driver object.
        //

        length = (USHORT) _snwprintf(buffer, (sizeof(buffer) / sizeof(WCHAR)) - 1, L"\\Driver\\%08u", KiQueryLowTickCount());
        driverName.Length = length * sizeof(WCHAR);
        driverName.MaximumLength = driverName.Length + sizeof(UNICODE_NULL);
        driverName.Buffer = buffer;                                                           \
    } else {
        driverName = *DriverName;
    }

    //
    // Attempt to create the driver object
    //

    InitializeObjectAttributes( &objectAttributes,
                                &driverName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    objectSize = sizeof( DRIVER_OBJECT ) + sizeof( DRIVER_EXTENSION );
    status = ObCreateObject( KernelMode,
                             IoDriverObjectType,
                             &objectAttributes,
                             KernelMode,
                             NULL,
                             objectSize,
                             0,
                             0,
                             &driverObject );

    if( !NT_SUCCESS( status )){

        //
        // Driver object creation failed
        //

        return status;
    }

    //
    // We've created a driver object, initialize it.
    //

    RtlZeroMemory( driverObject, objectSize );
    driverObject->DriverExtension = (PDRIVER_EXTENSION)(driverObject + 1);
    driverObject->DriverExtension->DriverObject = driverObject;
    driverObject->Type = IO_TYPE_DRIVER;
    driverObject->Size = sizeof( DRIVER_OBJECT );
    driverObject->Flags = DRVO_BUILTIN_DRIVER;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        driverObject->MajorFunction[i] = IopInvalidDeviceRequest;
    driverObject->DriverInit = InitializationFunction;

    serviceName.Buffer = (PWSTR)ExAllocatePool(PagedPool, driverName.Length + sizeof(WCHAR));
    if (serviceName.Buffer) {
        serviceName.MaximumLength = driverName.Length + sizeof(WCHAR);
        serviceName.Length = driverName.Length;
        RtlCopyMemory(serviceName.Buffer, driverName.Buffer, driverName.Length);
        serviceName.Buffer[serviceName.Length / sizeof(WCHAR)] = UNICODE_NULL;
        driverObject->DriverExtension->ServiceKeyName = serviceName;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto errorFreeDriverObject;
    }

    //
    // Insert it into the object table.
    //

    status = ObInsertObject( driverObject,
                             NULL,
                             FILE_READ_DATA,
                             OBJ_KERNEL_HANDLE,
                             NULL,
                             &driverHandle );

    if( !NT_SUCCESS( status )){

        //
        // Couldn't insert the driver object into the table.
        // The object got dereferenced by the object manager. Just exit
        //

        goto errorReturn;
    }

    //
    // Reference the handle and obtain a pointer to the driver object so that
    // the handle can be deleted without the object going away.
    //

    status = ObReferenceObjectByHandle( driverHandle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &driverObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    if( !NT_SUCCESS( status )) {
       //
       // Backout here is probably bogus. If the ref didn't work then the handle is probably bad
       // Do this right though just in case there are other common error returns for ObRef...
       //
       ZwMakeTemporaryObject( driverHandle ); // Cause handle close to free the object
       ZwClose( driverHandle ); // Close the handle.
       goto errorReturn;
    }

    ZwClose( driverHandle );

    //
    // Store the name of the device driver in the driver object so that it
    // can be easily found by the error log thread.
    //

    driverObject->DriverName.Buffer = ExAllocatePool( PagedPool,
                                                      driverName.MaximumLength );
    if (driverObject->DriverName.Buffer) {
        driverObject->DriverName.MaximumLength = driverName.MaximumLength;
        driverObject->DriverName.Length = driverName.Length;

        RtlCopyMemory( driverObject->DriverName.Buffer,
                       driverName.Buffer,
                       driverName.MaximumLength );
    }

    //
    // Call the driver initialization routine
    //

    status = (*InitializationFunction)(driverObject, NULL);

    if( !NT_SUCCESS( status )){

errorFreeDriverObject:

        //
        // If we were unsuccessful, we need to get rid of the driverObject
        // that we created.
        //

        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    }
errorReturn:
    return status;
}

VOID
IoDeleteDriver(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine deletes a driver object created explicitly through
    IoCreateDriver.

Parameters:

    DriverObject - Supplies a pointer to the driver object to be deleted.

ReturnValue:

    Status code that indicates whether or not the function was successful.

Notes:

--*/
{

    ObDereferenceObject(DriverObject);
}

PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose next device object needs
                    to be obtained.

ReturnValue:

    NULL if driver is unloaded or marked for unload or if there is no attached deviceobject.
    Otherwise a referenced pointer to the deviceobject is returned.

Notes:

--*/
{
    KIRQL   irql;
    PDEVICE_OBJECT  targetDeviceObject;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if ((DeviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) {

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return NULL;
    }

    targetDeviceObject = NULL;
    if (DeviceObject->DeviceObjectExtension->AttachedTo) {
        targetDeviceObject = DeviceObject->DeviceObjectExtension->AttachedTo;
        ObReferenceObject(targetDeviceObject);
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return targetDeviceObject;
}

NTSTATUS
IoEnumerateDeviceObjectList(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  *DeviceObjectList,
    IN  ULONG           DeviceObjectListSize,
    OUT PULONG          ActualNumberDeviceObjects
    )
/*++

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DriverObject - Driver Object whose device objects have to be enumerated.

    DeviceObjectList - Pointer to an array where device object lists will be stored.

    DeviceObjectListSize - Size in bytes of the DeviceObjectList array

    ActualNumberDeviceObjects - The actual number of device objects in a driver object.

ReturnValue:

    If size is not sufficient it will return STATUS_BUFFER_TOO_SMALL.

Notes:

--*/
{
    KIRQL   irql;
    PDEVICE_OBJECT  deviceObject;
    ULONG   numListEntries;
    ULONG   numDeviceObjects = 0;
    NTSTATUS status = STATUS_SUCCESS;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    deviceObject = DriverObject->DeviceObject;

    numListEntries = DeviceObjectListSize / sizeof(PDEVICE_OBJECT);

    while (deviceObject) {
        numDeviceObjects++;
        deviceObject = deviceObject->NextDevice;
    }

    *ActualNumberDeviceObjects = numDeviceObjects;

    if (numDeviceObjects > numListEntries) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    deviceObject = DriverObject->DeviceObject;

    while ((numListEntries > 0) && deviceObject) {
        ObReferenceObject(deviceObject);
        *DeviceObjectList = deviceObject;
        DeviceObjectList++;
        deviceObject = deviceObject->NextDevice;
        numListEntries--;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return status;
}

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine returns the lowest level device object associated with
    the specified device.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.

Return Value:

    The function value is a reference to the lowest level device attached
    to the specified device.  If the supplied device object is that device
    object, then a pointer to it is returned.

    A reference is taken on the returned device object.  It is the
    responsibility of the caller to release it.

--*/

{
    PDEVICE_OBJECT baseDeviceObject;
    KIRQL irql;

    //
    // Any examination of attachment chain linkage must be done with
    // IopDatabaseLock taken.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Find the base of the attachment chain.
    //

    baseDeviceObject = IopGetDeviceAttachmentBase( DeviceObject );

    //
    // Reference the device object before releasing the database lock.
    //

    ObReferenceObject( baseDeviceObject );
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return baseDeviceObject;
}

NTSTATUS
IoGetDiskDeviceObject(
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    )
/*++

Routine Description:

    This routine returns the disk device object associated with a filesystem
    volume device object. The disk device object need not be an actual disk but
    in general associated with storage.

Arguments:

    FileSystemDeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.
    DiskDeviceObject     - Supplies storage for the return value.

Return Value:

    The function returns the disk device object associated with a filesystem
    device object. Returns a referenced device object. If the VPB reference count
    is zero we cannot rely on the device object pointer.

--*/
{
    KIRQL   irql;
    PVPB    vpb;

    //
    // Filesystem deviceobject's VPB field should be NULL
    //

    if (FileSystemDeviceObject->Vpb) {
        return STATUS_INVALID_PARAMETER;
    }

    IoAcquireVpbSpinLock(&irql);

    vpb = FileSystemDeviceObject->DeviceObjectExtension->Vpb;

    if (!vpb) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_INVALID_PARAMETER;
    }

    if (vpb->ReferenceCount == 0) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_VOLUME_DISMOUNTED;
    }

    if (!(vpb->Flags & VPB_MOUNTED)) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_VOLUME_DISMOUNTED;
    }

    *DiskDeviceObject = vpb->RealDevice;
    ObReferenceObject( *DiskDeviceObject);
    IoReleaseVpbSpinLock(irql);

    return STATUS_SUCCESS;
}

NTSTATUS
IoSetSystemPartition(
    PUNICODE_STRING VolumeNameString
    )
/*++

Routine Description:

    This routine sets system partition regisry key to the volume name string. Used
    by the mount manager in case volume name changes.

Arguments:

    VolumeNameString - Name of the volume that is the system partition.

Return Value:

    NTSTATUS

--*/
{
    HANDLE systemHandle, setupHandle;
    UNICODE_STRING nameString, machineSystemName;
    NTSTATUS    status;

    //
    // Declare a unicode buffer big enough to contain the longest string we'll be using.
    // (ANSI string in 'sizeof()' below on purpose--we want the number of chars here.)
    //
    WCHAR nameBuffer[sizeof("SystemPartition")];

    //
    // Open HKLM\SYSTEM key.
    //

    RtlInitUnicodeString(&machineSystemName, L"\\REGISTRY\\MACHINE\\SYSTEM");
    status = IopOpenRegistryKeyEx( &systemHandle,
                                   NULL,
                                   &machineSystemName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Now open/create the setup subkey.
    //

    ASSERT( sizeof(L"Setup") <= sizeof(nameBuffer) );

    nameBuffer[0] = L'S';
    nameBuffer[1] = L'e';
    nameBuffer[2] = L't';
    nameBuffer[3] = L'u';
    nameBuffer[4] = L'p';
    nameBuffer[5] = L'\0';

    nameString.MaximumLength = sizeof(L"Setup");
    nameString.Length        = sizeof(L"Setup") - sizeof(WCHAR);
    nameString.Buffer        = nameBuffer;

    status = IopCreateRegistryKeyEx( &setupHandle,
                                     systemHandle,
                                     &nameString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    NtClose(systemHandle);  // Don't need the handle to the HKLM\System key anymore.

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT( sizeof(L"SystemPartition") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'S';
    nameBuffer[1]  = L'y';
    nameBuffer[2]  = L's';
    nameBuffer[3]  = L't';
    nameBuffer[4]  = L'e';
    nameBuffer[5]  = L'm';
    nameBuffer[6]  = L'P';
    nameBuffer[7]  = L'a';
    nameBuffer[8]  = L'r';
    nameBuffer[9]  = L't';
    nameBuffer[10] = L'i';
    nameBuffer[11] = L't';
    nameBuffer[12] = L'i';
    nameBuffer[13] = L'o';
    nameBuffer[14] = L'n';
    nameBuffer[15] = L'\0';

    nameString.MaximumLength = sizeof(L"SystemPartition");
    nameString.Length        = sizeof(L"SystemPartition") - sizeof(WCHAR);



    status = ZwSetValueKey(setupHandle,
                            &nameString,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            VolumeNameString->Buffer,
                            VolumeNameString->Length + sizeof(WCHAR)
                           );


    return status;
}


BOOLEAN
IoIsFileOriginRemote(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the origin of the original create request for the
    specified file.  That is, was it created locally on this machine or remotely
    on another machine via a network provider.

Arguments:

    FileObject - Supplies the file object that is to be checked.

Return Value:

    TRUE - Means the create request originated on a remote machine.

    FALSE - Means the create request originated on the local machine.

--*/

{
    BOOLEAN Remote;


    //
    //  Check the origin flag and return the appropriate result.
    //

    if (FileObject->Flags & FO_REMOTE_ORIGIN) {

        Remote = TRUE;

    } else {

        Remote = FALSE;
    }

    return Remote;
}

NTSTATUS
IoSetFileOrigin(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Remote
    )

/*++

Routine Description:

    This routine sets the origin of the original create request for the
    specified file.  That is, was it created locally on this machine or remotely
    on another machine via a network provider.  By default file objects are
    considered to have a local origin.  Network providers should call this
    function in their server for any file objects that were created to satisfy
    a create request from their client.

Arguments:

    FileObject - Supplies the file object that is to be set.

    Remote - Supplies whether the file object is for a remote create request or not.

Return Value:

    Returns STATUS_SUCCESS unless the origin is already set to what the caller is requesting.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER_MIX;


    //
    //  Set or clear the origin flag per the callers request.
    //

    if (Remote) {

        if ((FileObject->Flags & FO_REMOTE_ORIGIN) == 0) {

            FileObject->Flags |= FO_REMOTE_ORIGIN;
            Status = STATUS_SUCCESS;
        }

    } else {

        if (FileObject->Flags & FO_REMOTE_ORIGIN) {

            FileObject->Flags &= ~FO_REMOTE_ORIGIN;
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}


PVOID
IoGetFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    This routine returns the filter context associated with a fileobject that has an extension.

Arguments:

    FileObject  - FileObject for which the filter context is retrieved

Return Value:

    NTSTATUS

--*/
{
    PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);
        return (fileObjectExtension->FilterContext);
    }
    return NULL;
}


NTSTATUS
IoChangeFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject,
    IN  PVOID           FilterContext,
    IN  BOOLEAN         Set
    )
/*++

Routine Description:

    This routine set or clear fileobject filter context. It can be set only once.

Arguments:

    FileObject  - FileObject for which the filter context is retrieved
    FilterContext - New Filter context to be set in the fileobject extension
    Set - If TRUE allows FilterContext to be set in the fileobject only if the old value is NULL
          If FALSE allows fileObject field to be cleared only if FileContext is the old value in the fileobject.

Return Value:

    Returns NTSTATUS

--*/
{
    PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);
        if (Set) {
            if (InterlockedCompareExchangePointer(&fileObjectExtension->FilterContext, FilterContext, NULL) != NULL)
                return STATUS_ALREADY_COMMITTED;
            return STATUS_SUCCESS;
        } else {
            if (InterlockedCompareExchangePointer(&fileObjectExtension->FilterContext, NULL, FilterContext) != FilterContext)
                return STATUS_ALREADY_COMMITTED;
            return STATUS_SUCCESS;
        }
    }
    return STATUS_INVALID_PARAMETER;
}


BOOLEAN
IoIsDeviceEjectable(
    IN  PDEVICE_OBJECT DeviceObject
    )
{
    if ((FILE_FLOPPY_DISKETTE & DeviceObject->Characteristics)
            || (InitWinPEModeType & INIT_WINPEMODE_INRAM)) {

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
IoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    )
/*++

Routine Description:

    This routine validates ioctl access bits based on granted access information passed in the IRP.
    This routine is called by a driver to validate IOCTL access bits for IOCTLs that were originally
    defined as FILE_ANY_ACCESS and cannot be changed for compatibility reasons but really has to be
    validated for read/write access.


Arguments:

    IRP  - IRP for the device control
    RequiredAccess - Is the expected access required by the driver. Should be FILE_READ_ACCESS, FILE_WRITE_ACCESS
    or both.

Return Value:

    Returns NTSTATUS

--*/
{
    ACCESS_MASK         grantedAccess;
    PIO_STACK_LOCATION  irpSp;

    //
    // Validate RequiredAccess.
    //

    if (RequiredAccess & (FILE_READ_ACCESS|FILE_WRITE_ACCESS)){

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // If the driver passes the wrong IRP fail the API.
        //

        if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) &&
            (irpSp->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Kernel mode IRPs always succeed.
        //

        if (Irp->RequestorMode == KernelMode) {
            return STATUS_SUCCESS;
        }

        //
        // Get the granted access bits from the IRP.
        //

        grantedAccess = (irpSp->Flags & SL_READ_ACCESS_GRANTED) ? FILE_READ_DATA : 0;
        grantedAccess |= (irpSp->Flags & SL_WRITE_ACCESS_GRANTED) ? FILE_WRITE_DATA : 0;

        if (SeComputeGrantedAccesses ( grantedAccess, RequiredAccess ) != RequiredAccess ) {
            return STATUS_ACCESS_DENIED;
        } else {
            return STATUS_SUCCESS;
        }

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}


IO_PAGING_PRIORITY
FASTCALL
IoGetPagingIoPriority(
    IN    PIRP    Irp
    )
/*++

Routine Description:

    This routine returns the paging priority for an IRP. Its
    called by the storage stack to determine how to queue the IRP to the
    disk.

Arguments:

    IRP  - IRP for paging IO.

Return Value:

    Returns IO_PAGING_PRIORITY

--*/
{
    if (Irp->Flags & IRP_HIGH_PRIORITY_PAGING_IO) {
        return IoPagingPriorityHigh;
    }
    if (!(Irp->Flags & IRP_PAGING_IO)) {
        return IoPagingPriorityInvalid;
    }
    return IoPagingPriorityNormal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\open.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    open.c

Abstract:

    This module contains the code to implement the NtOpenFile system
    service.

Author:

    Darryl E. Havens (darrylh) 25-Oct-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtOpenFile)
#endif

NTSTATUS
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )

/*++

Routine Description:

    This service opens a file or a device.  It is used to establish a file
    handle to the open device/file that can then be used in subsequent
    operations to perform I/O operations on.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    OpenOptions - Caller options for how to perform the open.

Return Value:

    The function value is the final completion status of the open/create
    operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         FILE_OPEN,
                         OpenOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeNone,
                         (PVOID) NULL,
                         0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\parse.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains the code to implement the device object parse routine.

Author:

    Darryl E. Havens (darrylh) 15-May-1988

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

//
// Define macro to round up the size of a name for buffer optimization.
//

#define RoundNameSize( Length ) ( \
    (Length < 64 - 8) ? 64 - 8 :  \
    (Length < 128 - 8) ? 128 - 8 :\
    (Length < 256 - 8) ? 256 - 8 : Length )

#define IO_MAX_REMOUNT_REPARSE_ATTEMPTS 32

NTSTATUS
IopGetNetworkOpenInformation(
    IN  PFILE_OBJECT    FileObject,
    IN  POPEN_PACKET    Op
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopParseFile)
#pragma alloc_text(PAGE, IopParseDevice)
#pragma alloc_text(PAGE, IopQueryName)
#pragma alloc_text(PAGE, IopQueryNameInternal)
#pragma alloc_text(PAGE, IopCheckBackupRestorePrivilege)
#pragma alloc_text(PAGE, IopGetNetworkOpenInformation)
#endif

NTSTATUS
IopCheckDeviceAndDriver(
    IN POPEN_PACKET op,
    IN PDEVICE_OBJECT parseDeviceObject
    )
{
    NTSTATUS status;
    KIRQL irql;

    //
    // Make sure that the device and its driver are really there and they are
    // going to stay there.  The object itself cannot go away just yet because
    // the object management system has performed a reference which bumps the
    // count of the number of reasons why the object must stick around.
    // However, the driver could be attempting to unload itself, so perform
    // this check.  If the driver is being unloaded, then set the final status
    // of the operation to "No such device" and return with a NULL file object
    // pointer.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if (parseDeviceObject->DeviceObjectExtension->ExtensionFlags &
            (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED | DOE_START_PENDING) ||
        parseDeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        status = STATUS_NO_SUCH_DEVICE;

    } else if (parseDeviceObject->Flags & DO_EXCLUSIVE &&
               parseDeviceObject->ReferenceCount != 0 &&
               op->RelatedFileObject == NULL &&
               !(op->Options & IO_ATTACH_DEVICE)) {

        status = STATUS_ACCESS_DENIED;

    } else {

        parseDeviceObject->ReferenceCount++;
        status = STATUS_SUCCESS;

    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return status;
}

PVPB
IopCheckVpbMounted(
    IN POPEN_PACKET op,
    IN PDEVICE_OBJECT parseDeviceObject,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PNTSTATUS status
    )
{
    PVPB vpb;
    PVPB mountVpb;
    KIRQL irql;
    BOOLEAN alertable;

    //
    // Loop here until the VPB_MOUNTED test can be passed while holding the
    // VPB spinlock.  After the mount succeeds, it is still necessary to acquire
    // the spinlock to check that the VPB (which may be different from the one
    // before the mount) is still mounted.  If it is, then its reference count
    // is incremented before releasing the spinlock.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );

    while (!(parseDeviceObject->Vpb->Flags & VPB_MOUNTED)) {

        KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

        alertable = (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) ? TRUE : FALSE;

        //
        // Try to mount the volume, allowing only RAW to perform the mount if
        // this is a DASD open.
        //

        mountVpb = NULL;
        *status = IopMountVolume( parseDeviceObject,
                                 (BOOLEAN) (!RemainingName->Length && !op->RelatedFileObject),
                                 FALSE,
                                 alertable,
                                 &mountVpb );
        //
        // If the mount operation was unsuccessful, adjust the reference
        // count for the device and return now.
        //

        if (!NT_SUCCESS( *status ) || *status == STATUS_USER_APC || *status == STATUS_ALERTED) {

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (!NT_SUCCESS( *status )) {
                return NULL;
            } else {
                *status = STATUS_WRONG_VOLUME;
                return NULL;
            }
        } else {

            //
            // In this case IopMountVolume did the synchronization already.
            //

            if (mountVpb) {
                return mountVpb;
            }
        }

        irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    }

    //
    // Synchronize here with the file system to make sure that volumes do not
    // go away while en route to the FS.
    //

    vpb = parseDeviceObject->Vpb;

    //
    //  Check here that the VPB is not locked.
    //

    if (vpb->Flags & VPB_LOCKED) {

        *status = STATUS_ACCESS_DENIED;
        vpb = NULL;

    } else {

        vpb->ReferenceCount += 1;
    }

    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

    //
    // This is because VPB is locked.
    // Do the decrement outside the VPB lock because of possible deadlocks.
    //

    if (!vpb) {
        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );
    }

    return vpb;
}

VOID
IopDereferenceVpbAndFree(
    IN PVPB Vpb
    )
{
    KIRQL irql;
    PVPB vpb = (PVPB) NULL;

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    Vpb->ReferenceCount--;
    if ((Vpb->ReferenceCount == 0) &&
        (Vpb->RealDevice->Vpb != Vpb) &&
        !(Vpb->Flags & VPB_PERSISTENT)) {
        vpb = Vpb;
    }
    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );
    if (vpb) {
        ExFreePool( vpb );
    }
}



NTSTATUS
IopParseDevice(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and the
    name translates to a device object.  This routine is specified as the parse
    routine for all device objects.

    In the normal case of an NtCreateFile, the user specifies either the name
    of a device or of a file.  In the former situation, this routine is invoked
    with a pointer to the device and a null ("") string.  For this case, the
    routine simply allocates an IRP, fills it in, and passes it to the driver
    for the device.  The driver will then perform whatever rudimentary functions
    are necessary and will return a status code indicating whether an error was
    incurred.  This status code is remembered in the Open Packet (OP).

    In the latter situation, the name string to be opened/created is non-null.
    That is, it contains the remainder of the pathname to the file that is to
    be opened or created.  For this case, the routine allocates an IRP, fills
    it in, and passes it to the driver for the device.  The driver may then
    need to take further action or it may complete the request immediately.  If
    it needs to perform some work asynchronously, then it can queue the request
    and return a status of STATUS_PENDING.  This allows this routine and its
    caller to return to the user so that he can continue.  Otherwise, the open/
    create is basically finished.

    If the driver supports symbolic links, then it is also possible for the
    driver to return a new name.  This name will be returned to the Object
    Manager as a new name to look up.  The parsing will then begin again from
    the start.

    It is also the responsibility of this routine to create a file object for
    the file, if the name specifies a file.  The file object's address is
    returned to the NtCreateFile service through the OP.

Arguments:

    ParseObject - Pointer to the device object the name translated into.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    SecurityQos - Optional security quality of service indicator.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{


    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    POPEN_PACKET op;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    IO_SECURITY_CONTEXT securityContext;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT parseDeviceObject;
    BOOLEAN directDeviceOpen;
    PVPB vpb;
    ACCESS_MASK desiredAccess;
    PDUMMY_FILE_OBJECT localFileObject;
    LOGICAL realFileObjectRequired;
    KPROCESSOR_MODE modeForPrivilegeCheck;
    ULONG retryCount = 0;
    BOOLEAN  relativeVolumeOpen = FALSE;     // True if opening a filesystem volume
    PETHREAD CurrentThread;
    ULONG returnedLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ObjectType);

    CurrentThread = PsGetCurrentThread ();

reparse_loop:

    //
    // Assume failure by setting the returned object pointer to NULL.
    //

    *Object = (PVOID) NULL;

    //
    // Get the address of the Open Packet (OP).
    //

    op = Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Obtain a pointer to the parse object as a device object, which is the
    // actual type of the object anyway.
    //

    parseDeviceObject = (PDEVICE_OBJECT) ParseObject;

    //
    // If we passed through a mountpoint do an extra set of validation checks
    // that we don't go to a remote device. We really have to let the object manager
    // open the new path. If we fail it in the path that obtains the reparse point and
    // validates the name (using IoIsValidNameGraftingBuffer) its not sufficient. This is because
    // the path may be valid at that time and change before OB does the reparse.
    //

    if (op->TraversedMountPoint) {

        ASSERT (op->Information == IO_REPARSE_TAG_MOUNT_POINT);

        if ((parseDeviceObject->DeviceType != FILE_DEVICE_DISK) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_CD_ROM) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_VIRTUAL_DISK) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_TAPE)) {

            status = STATUS_IO_REPARSE_DATA_INVALID;
            return op->FinalStatus = status;
        }
    }

    //
    // If this is a relative open, then get the device on which the file
    // is really being opened from the related file object and use that for
    // the remainder of this function and for all operations performed on
    // the file object that is about to be created.
    //

    if (op->RelatedFileObject) {
        parseDeviceObject = op->RelatedFileObject->DeviceObject;
    }

    //
    // Make sure that the device and its driver are really there and they are
    // going to stay there.  The object itself cannot go away just yet because
    // the object management system has performed a reference which bumps the
    // count of the number of reasons why the object must stick around.
    // However, the driver could be attempting to unload itself, so perform
    // this check.  If the driver is being unloaded, then set the final status
    // of the operation to "No such device" and return with a NULL file object
    // pointer.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    status = IopCheckDeviceAndDriver( op, parseDeviceObject );

    if (!NT_SUCCESS(status)) {
        return op->FinalStatus = status;
    }

    //
    // Since ObOpenObjectByName is called without being passed
    // any object type information, we need to map the generic
    // bits in the DesiredAccess mask here.  We also need to save
    // the object's generic mapping in the access state structure
    // here, because this is the earliest opportunity we have
    // to do so.
    //

    RtlMapGenericMask( &AccessState->RemainingDesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    RtlMapGenericMask( &AccessState->OriginalDesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    SeSetAccessStateGenericMapping( AccessState, &IoFileObjectType->TypeInfo.GenericMapping );

    desiredAccess = AccessState->RemainingDesiredAccess;

    //
    // Compute the previous mode to be passed in to the privilege check
    //

    if (AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) {
        modeForPrivilegeCheck = UserMode;
    } else {
        modeForPrivilegeCheck = KernelMode;
    }

    IopCheckBackupRestorePrivilege( AccessState,
                                    &op->CreateOptions,
                                    modeForPrivilegeCheck,
                                    op->Disposition
                                    );

    //
    // If this is not the first time through here for this object, and the
    // object itself is being opened, then the desired access must also
    // include the previously granted access from the last pass.  Likewise,
    // if the privileges have been checked already, then this is another
    // pass through for a file, so add in the previously granted access.
    //

    if ((op->Override && !RemainingName->Length) ||
        AccessState->Flags & SE_BACKUP_PRIVILEGES_CHECKED) {
        desiredAccess |= AccessState->PreviouslyGrantedAccess;
    }

    //
    // If its a filesystem volume open and we are doing a relative open to it
    // then do the access check. Note that relative opens can be nested and we propagate
    // the fact that the relative open is for a volume using the FO_VOLUME_OPEN flag.
    //

    if (op->RelatedFileObject) {
        if ((op->RelatedFileObject->Flags & FO_VOLUME_OPEN) && RemainingName->Length == 0) {
            relativeVolumeOpen = TRUE;
        }
    }

    //
    // Now determine what type of security check should be made.  This is
    // based on whether the remaining name string is null.  If it is null,
    // then the device itself is being opened, so a full security check is
    // performed.  Otherwise, only a check to ensure that the caller can
    // traverse the device object is made.  Note that these checks are only
    // made if the caller's mode is user, or if access checking is being
    // forced.  Note also that if an access check was already made on the
    // device itself, and this code is being executed again because of a
    // reparse, then the access check need not be made the second time
    // around.
    //


    if ((AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) &&
        (!op->RelatedFileObject || relativeVolumeOpen) &&
        !op->Override) {

        BOOLEAN subjectContextLocked = FALSE;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;

        //
        // The caller's mode is either user or access checking is being
        // forced.  Perform the appropriate access check on the device
        // object.
        //

        if (!RemainingName->Length) {

            UNICODE_STRING nameString;
            PPRIVILEGE_SET privileges = NULL;

            //
            // The device itself is being opened.  Make a full security check
            // to ensure that the caller has the appropriate access.
            //

            KeEnterCriticalRegionThread( &CurrentThread->Tcb );
            ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

            SeLockSubjectContext( &AccessState->SubjectSecurityContext );
            subjectContextLocked = TRUE;

            accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                           &AccessState->SubjectSecurityContext,
                                           subjectContextLocked,
                                           desiredAccess,
                                           0,
                                           &privileges,
                                           &IoFileObjectType->TypeInfo.GenericMapping,
                                           UserMode,
                                           &grantedAccess,
                                           &status );

            if (privileges) {
                (VOID) SeAppendPrivileges( AccessState,
                                           privileges );
                SeFreePrivileges( privileges );
            }

            if (accessGranted) {
                AccessState->PreviouslyGrantedAccess |= grantedAccess;
                AccessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
                op->Override = TRUE;
            }

            nameString.Length = 8;
            nameString.MaximumLength = 8;
            nameString.Buffer = L"File";

            SeOpenObjectAuditAlarm( &nameString,
                                    parseDeviceObject,
                                    CompleteName,
                                    parseDeviceObject->SecurityDescriptor,
                                    AccessState,
                                    FALSE,
                                    accessGranted,
                                    UserMode,
                                    &AccessState->GenerateOnClose );

            ExReleaseResourceLite( &IopSecurityResource );
            KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

        } else {

            //
            // The device is not being opened, rather, a file on the device
            // is being opened or created.  Therefore, only perform a check
            // here for traverse access to the device.
            //

            //
            // First determine if we have to perform traverse checking at all.
            // Traverse checking only needs to be done if the device being
            // traversed is a disk, or if the caller does not already have
            // traverse checking privilege.  Note that the former case is so
            // that an administrator can turn off access to the "system
            // partition", or someone would be able to install a trojan horse
            // into the system by simply replacing one of the files there with
            // something of their own.
            //

            if (!(AccessState->Flags & TOKEN_HAS_TRAVERSE_PRIVILEGE) ||
                parseDeviceObject->DeviceType == FILE_DEVICE_DISK ||
                parseDeviceObject->DeviceType == FILE_DEVICE_CD_ROM ) {

                KeEnterCriticalRegionThread( &CurrentThread->Tcb );
                ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

                accessGranted = SeFastTraverseCheck( parseDeviceObject->SecurityDescriptor,
                                                     AccessState,
                                                     FILE_TRAVERSE,
                                                     UserMode );

                if (!accessGranted) {

                    PPRIVILEGE_SET privileges = NULL;

                    //
                    // The caller was not granted traverse access through the
                    // normal fast path lookup.  Perform a full-blown access
                    // check to determine whether some other ACE allows traverse
                    // access.
                    //

                    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

                    subjectContextLocked = TRUE;

                    accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                                   &AccessState->SubjectSecurityContext,
                                                   subjectContextLocked,
                                                   FILE_TRAVERSE,
                                                   0,
                                                   &privileges,
                                                   &IoFileObjectType->TypeInfo.GenericMapping,
                                                   UserMode,
                                                   &grantedAccess,
                                                   &status );

                    if (privileges) {

                        (VOID) SeAppendPrivileges( AccessState,
                                                   privileges );
                        SeFreePrivileges( privileges );
                    }

                }

                ExReleaseResourceLite( &IopSecurityResource );
                KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

            } else {

                accessGranted = TRUE;
            }
        }

        //
        // Unlock the subject's security context so that it can be changed,
        // if it was locked.
        //

        if (subjectContextLocked) {
            SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
        }

        //
        // Finally, determine whether or not access was granted to the device.
        // If not, clean everything up and get out now without even invoking
        // the device driver.
        //

        if (!accessGranted) {

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );
            return STATUS_ACCESS_DENIED;
        }

    }

    realFileObjectRequired = !(op->QueryOnly || op->DeleteOnly);

    if (RemainingName->Length == 0 &&
        op->RelatedFileObject == NULL &&
        ((desiredAccess & ~(SYNCHRONIZE |
                            FILE_READ_ATTRIBUTES |
                            READ_CONTROL |
                            ACCESS_SYSTEM_SECURITY |
                            WRITE_OWNER |
                            WRITE_DAC)) == 0) &&
        realFileObjectRequired) {

        //
        // If the name of the object being opened is just the name of the
        // device itself, and there is no related file object, and the caller
        // is opening the device for only read attributes access, then this
        // device will not be mounted.  This allows applications to obtain
        // attributes about the device without actually mounting it.
        //
        // Note that if this *is* a direct device open, then the normal path
        // through the I/O system and drivers may never be used, even if
        // the device appears to be mounted.  This is because the user may
        // remove the media from the drive (even though it is mounted), and
        // now attempting to determine what type of drive it is will still
        // fail, this time very hard, because a whole mount process is now
        // required, thus defeating this feature.
        //

        directDeviceOpen = TRUE;

    } else {

        //
        // Otherwise, this is a normal open of a file, directory, device, or
        // volume.
        //

        directDeviceOpen = FALSE;
    }

    //
    // There are now five different cases.  These are as follows:
    //
    //    1)  This is a relative open, in which case we want to send the
    //        request to then same device that opened the relative file object.
    //
    //    2)  The VPB pointer in the device object is NULL.  This means that
    //        this device does not support a file system.  This includes
    //        devices such as terminals, etc.
    //
    //    3)  The VPB pointer in the device object is not NULL and:
    //
    //        a)  The VPB is "blank".  That is, the VPB has never been filled
    //            in, which means that the device has never been mounted.
    //
    //        b)  The VPB is non-blank, but the verify flag on the device is
    //            set, indicating that the door to the drive may have been
    //            opened and the media may therefore have been changed.
    //
    //        c)  The VPB is non-blank and the verify flag is not set.
    //
    //        Both of the latter are not explicitly checked for, as #c is
    //        the normal case, and #b is the responsibility of the file
    //        system to check.
    //

    //
    //  If this is a file system that supports volumes, vpbRefCount will
    //  be filled in to point to the reference count in the Vpb.  Error
    //  exits paths later on key off this value to see if they should
    //  decrement the ref count.  Note that a direct device open does not
    //  make it to the file system, so no increment is needed, and no
    //  decrement will be performed in objsup.c IopDeleteFile().
    //

    vpb = NULL;

    //
    // If the related open was a direct device open then we should go through the full mount
    // path for this open as this may not be a direct device open.
    //
    if (op->RelatedFileObject && (!(op->RelatedFileObject->Flags & FO_DIRECT_DEVICE_OPEN))) {

        deviceObject = (PDEVICE_OBJECT)ParseObject;

        if (op->RelatedFileObject->Vpb) {

            vpb = op->RelatedFileObject->Vpb;

            //
            // Synchronize here with the file system to make sure that
            // volumes don't go away while en route to the FS.
            //

            IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                          (PLONG) &vpb->ReferenceCount);
        }

    } else {

        deviceObject = parseDeviceObject;

        if (parseDeviceObject->Vpb && !directDeviceOpen) {
            vpb = IopCheckVpbMounted( op,
                                      parseDeviceObject,
                                      RemainingName,
                                      &status );
            //
            // Device object reference is decremented in IopCheckVpbMounted.
            //

            if ( !vpb ) {
                return status;
            }

            //
            // Set the address of the device object associated with the VPB.
            //

            deviceObject = vpb->DeviceObject;
        }


        //
        // If the top deviceobject hint is set use the hint if possible.
        //

        if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {

            //
            // You cannot use the device object hint if you are trying to
            // open the device directly or if you are dealing with a device
            // that is not a file system.  In these cases, return an error.
            //

            if (directDeviceOpen ||
                (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
                 deviceObject->DeviceType != FILE_DEVICE_DFS_FILE_SYSTEM)) {

                if (vpb) {
                    IopDereferenceVpbAndFree( vpb );
                }

                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                return STATUS_INVALID_PARAMETER;
            }

            if  (IopVerifyDeviceObjectOnStack(deviceObject, op->TopDeviceObjectHint)) {

                deviceObject = op->TopDeviceObjectHint;

            } else {
                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }

                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                if (op->TraversedMountPoint) {
                    op->TraversedMountPoint = FALSE;
                    return STATUS_MOUNT_POINT_NOT_RESOLVED;
                } else {
                    return STATUS_INVALID_DEVICE_OBJECT_PARAMETER;
                }
            }

        } else {

            //
            // Walk the attached device list.
            //

            if (deviceObject->AttachedDevice) {
                deviceObject = IoGetAttachedDevice( deviceObject );
            }
        }
    }

    //
    //  If the TraversedMountPoint flag is still set, clear it now.  We needed
    //  to keep it to return the correct status if IopVerifyDeviceObjectOnStack
    //  failed above.
    //

    if (op->TraversedMountPoint) {
        op->TraversedMountPoint = FALSE;
    }

    //
    //  If the driver says that the IO manager should do the access checks, lets do it here.
    //  We do the check against the parse device object as that device object has a name
    //  and we can set an ACL against it.
    //  We only worry about related opens of devices as the other case is taken care of in the
    //  filesystem.
    //
    if ((deviceObject->Characteristics & FILE_DEVICE_SECURE_OPEN) &&
        (AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) &&
        (op->RelatedFileObject || RemainingName->Length) &&  (!relativeVolumeOpen)) {

        BOOLEAN subjectContextLocked = FALSE;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;
        UNICODE_STRING nameString;
        PPRIVILEGE_SET privileges = NULL;

        //
        // If the device wants to ensure secure opens then lets check the two
        // cases which were skipped earlier. These cases are if its a relative
        // open or if there are trailing names.
        //

        KeEnterCriticalRegionThread( &CurrentThread->Tcb );
        ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

        SeLockSubjectContext( &AccessState->SubjectSecurityContext );
        subjectContextLocked = TRUE;

        accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       subjectContextLocked,
                                       desiredAccess,
                                       0,
                                       &privileges,
                                       &IoFileObjectType->TypeInfo.GenericMapping,
                                       UserMode,
                                       &grantedAccess,
                                       &status );

        if (privileges) {
            (VOID) SeAppendPrivileges( AccessState,
                                       privileges );
            SeFreePrivileges( privileges );
        }

        if (accessGranted) {
            AccessState->PreviouslyGrantedAccess |= grantedAccess;
            AccessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        }

        nameString.Length = 8;
        nameString.MaximumLength = 8;
        nameString.Buffer = L"File";

        SeOpenObjectAuditAlarm( &nameString,
                                deviceObject,
                                CompleteName,
                                parseDeviceObject->SecurityDescriptor,
                                AccessState,
                                FALSE,
                                accessGranted,
                                UserMode,
                                &AccessState->GenerateOnClose );

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
        ExReleaseResourceLite( &IopSecurityResource );
        KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

        if (!accessGranted) {
            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
                IopDereferenceVpbAndFree(vpb);
            }
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Allocate and fill in the I/O Request Packet (IRP) to use in interfacing
    // to the driver.  The allocation is done using an exception handler in
    // case the caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if (vpb) {
            IopDereferenceVpbAndFree(vpb);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = AccessMode;
    irp->Flags = IRP_CREATE_OPERATION | IRP_SYNCHRONOUS_API | IRP_DEFER_IO_COMPLETION;

    securityContext.SecurityQos = SecurityQos;
    securityContext.AccessState = AccessState;
    securityContext.DesiredAccess = desiredAccess;
    securityContext.FullCreateOptions = op->CreateOptions;

    //
    // Get a pointer to the stack location for the first driver.  This is where
    // the original function codes and parameters are passed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Control = 0;

    if (op->CreateFileType == CreateFileTypeNone) {

        //
        // This is a normal file open or create function.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE;
        irpSp->Parameters.Create.EaLength = op->EaLength;
        irpSp->Flags = (UCHAR) op->Options;
        if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
            irpSp->Flags |= SL_CASE_SENSITIVE;
        }

    } else if (op->CreateFileType == CreateFileTypeNamedPipe) {

        //
        // A named pipe is being created.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE_NAMED_PIPE;
        irpSp->Parameters.CreatePipe.Parameters = op->ExtraCreateParameters;

    } else {

        //
        // A mailslot is being created.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE_MAILSLOT;
        irpSp->Parameters.CreateMailslot.Parameters = op->ExtraCreateParameters;
    }

    //
    // Also fill in the NtCreateFile service's caller's parameters.
    //

    irp->Overlay.AllocationSize = op->AllocationSize;
    irp->AssociatedIrp.SystemBuffer = op->EaBuffer;
    irpSp->Parameters.Create.Options = (op->Disposition << 24) | (op->CreateOptions & 0x00ffffff);
    irpSp->Parameters.Create.FileAttributes = op->FileAttributes;
    irpSp->Parameters.Create.ShareAccess = op->ShareAccess;
    irpSp->Parameters.Create.SecurityContext = &securityContext;

    //
    // Fill in local parameters so this routine can determine when the I/O is
    // finished, and the normal I/O completion code will not get any errors.
    //

    irp->UserIosb = &ioStatus;
    irp->MdlAddress = (PMDL) NULL;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->UserEvent = (PKEVENT) NULL;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;

    //
    // Allocate and initialize the file object that will be used in dealing
    // with the device for the remainder of this session with the user.  How
    // the file object is allocated is based on whether or not a real file
    // object is actually required.  It is not required for the query and
    // delete only operations.
    //

    if (realFileObjectRequired) {

        OBJECT_ATTRIBUTES objectAttributes;
        ULONG             fileObjectSize;

        //
        // A real, full-blown file object is actually required.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    (PUNICODE_STRING) NULL,
                                    Attributes,
                                    (HANDLE) NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                  );

        if (op->InternalFlags &
            (IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT|IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK)) {
            fileObjectSize = sizeof(FILE_OBJECT) + sizeof(IOP_FILE_OBJECT_EXTENSION);
        } else {
            fileObjectSize = sizeof(FILE_OBJECT);
        }

        status = ObCreateObject( KernelMode,
                                 IoFileObjectType,
                                 &objectAttributes,
                                 AccessMode,
                                 (PVOID) NULL,
                                 fileObjectSize,
                                 0,
                                 0,
                                 (PVOID *) &fileObject );

        if (!NT_SUCCESS( status )) {
            IoFreeIrp( irp );

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
               IopDereferenceVpbAndFree(vpb);
            }
            return op->FinalStatus = status;
        }

        IopPerfLogFileCreate(fileObject, CompleteName);

        RtlZeroMemory( fileObject, sizeof( FILE_OBJECT ) );
        if (op->CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
            fileObject->Flags = FO_SYNCHRONOUS_IO;
            if (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) {
                fileObject->Flags |= FO_ALERTABLE_IO;
            }
        }

        if (op->InternalFlags &
            (IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT|IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK)) {

            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

            fileObject->Flags |= FO_FILE_OBJECT_HAS_EXTENSION;
            fileObjectExtension = (PIOP_FILE_OBJECT_EXTENSION)(fileObject + 1);
            fileObjectExtension->FileObjectExtensionFlags = 0;
            fileObjectExtension->TopDeviceObjectHint = NULL;
            fileObjectExtension->FilterContext = NULL;

            if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {
                fileObjectExtension->TopDeviceObjectHint = deviceObject;
            }

            if (op->InternalFlags & IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK) {
                fileObjectExtension->FileObjectExtensionFlags |=FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK;
            }
        }

        //
        // Now fill in the file object as best is possible at this point and set
        // a pointer to it in the IRP so everyone else can find it.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            KeInitializeEvent( &fileObject->Lock, SynchronizationEvent, FALSE );
            fileObject->Waiters = 0;
            fileObject->CurrentByteOffset.QuadPart = 0;
        }
        if (op->CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) {
            fileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
        }
        if (op->CreateOptions & FILE_WRITE_THROUGH) {
            fileObject->Flags |= FO_WRITE_THROUGH;
        }
        if (op->CreateOptions & FILE_SEQUENTIAL_ONLY) {
            fileObject->Flags |= FO_SEQUENTIAL_ONLY;
        }
        if (op->CreateOptions & FILE_RANDOM_ACCESS) {
            fileObject->Flags |= FO_RANDOM_ACCESS;
        }

    } else {

        //
        // This is either a quick delete or query operation.  For these cases,
        // it is possible to optimize the Object Manager out of the picture by
        // simply putting together something that "looks" like a file object,
        // and then operating on it.
        //

        localFileObject = op->LocalFileObject;
        RtlZeroMemory( localFileObject, sizeof( DUMMY_FILE_OBJECT ) );
        fileObject = (PFILE_OBJECT) &localFileObject->ObjectHeader.Body;
        localFileObject->ObjectHeader.Type = IoFileObjectType;
        localFileObject->ObjectHeader.PointerCount = 1;
    }

    if (directDeviceOpen) {
        fileObject->Flags |= FO_DIRECT_DEVICE_OPEN;
    }
    if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
        fileObject->Flags |= FO_OPENED_CASE_SENSITIVE;
    }

    fileObject->Type = IO_TYPE_FILE;
    fileObject->Size = sizeof( FILE_OBJECT );
    fileObject->RelatedFileObject = op->RelatedFileObject;
    fileObject->DeviceObject = parseDeviceObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Allocate a file name string buffer which is large enough to contain
    // the entire remaining name string and initialize the maximum length.
    //

    if (RemainingName->Length) {
        fileObject->FileName.MaximumLength = RoundNameSize( RemainingName->Length );
        fileObject->FileName.Buffer = ExAllocatePoolWithTag( PagedPool,
                                                             fileObject->FileName.MaximumLength,
                                                             'mNoI' );
        if (!fileObject->FileName.Buffer) {
            IoFreeIrp( irp );

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
               IopDereferenceVpbAndFree(vpb);
            }
            fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Now copy the name string into the file object from the remaining name
    // that is being reparsed.  If the driver decides to reparse, then it must
    // replace this name.
    //

    RtlCopyUnicodeString( &fileObject->FileName, RemainingName );

    //
    // Before invoking the driver's open routine, check to see whether or not
    // this is a fast network attributes query and, if so, and the driver
    // implements the function, attempt to call it here.
    //

    if (op->QueryOnly) {
        PFAST_IO_DISPATCH fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;
        BOOLEAN result;

        if (fastIoDispatch &&
            fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoQueryOpen ) &&
            fastIoDispatch->FastIoQueryOpen) {

            IoSetNextIrpStackLocation( irp );
            irpSp->DeviceObject = deviceObject;
            result = (fastIoDispatch->FastIoQueryOpen)( irp,
                                                        op->NetworkInformation,
                                                        deviceObject );
            if (result) {
                op->FinalStatus = irp->IoStatus.Status;
                op->Information = irp->IoStatus.Information;

                //
                // The operation worked, so simply dereference and free the
                // resources acquired up to this point.
                //

                if ((op->FinalStatus == STATUS_REPARSE) &&
                    irp->Tail.Overlay.AuxiliaryBuffer) {
                    ASSERT( op->Information > IO_REPARSE_TAG_RESERVED_ONE );
                    ExFreePool( irp->Tail.Overlay.AuxiliaryBuffer );
                    irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    op->RelatedFileObject = (PFILE_OBJECT) NULL;
                }

                if (fileObject->FileName.Length) {
                    ExFreePool( fileObject->FileName.Buffer );
                }

                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }

#if DBG
                irp->CurrentLocation = irp->StackCount + 2;
#endif // DBG

                IoFreeIrp( irp );

                //
                // Finally, indicate that the parse routine was actually
                // invoked and that the information returned herein can be
                // used.
                //

                op->ParseCheck = OPEN_PACKET_PATTERN;
                status = STATUS_SUCCESS;

                if (!op->FullAttributes) {
                    try {
                        op->BasicInformation->FileAttributes = op->NetworkInformation->FileAttributes;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        status = GetExceptionCode();
                    }
                }

                return status;

            } else {

                //
                // The fast I/O operation did not work, so take the longer
                // route.
                //

                irp->Tail.Overlay.CurrentStackLocation++;
                irp->CurrentLocation++;
            }
        }
    }

    //
    // Finally, initialize the file object's event to the Not Signaled state
    // and remember that a file object was created.
    //

    KeInitializeEvent( &fileObject->Event, NotificationEvent, FALSE );
    op->FileObject = fileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now invoke the driver itself to open the file.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // One of four things may have happened when the driver was invoked:
    //
    //    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can
    //        occur on devices which need to perform some sort of device
    //        manipulation (such as opening a file for a file system).
    //
    //    2.  The driver returned an error (Status < 0). This occurs when either
    //        a supplied parameter was in error, or the device or file system
    //        incurred or discovered an error.
    //
    //    3.  The operation ended in a reparse (Status == STATUS_REPARSE).  This
    //        occurs when a file system opens the file, only to discover that it
    //        represents a symbolic link.
    //
    //    4.  The operation is complete and was successful (Status ==
    //        STATUS_SUCCESS).  Note that for this case the only action is to
    //        return a pointer to the file object.
    //

    if (status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &fileObject->Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;

    } else {

        //
        // The I/O operation was completed without returning a status of
        // pending.  This means that at this point, the IRP has not been
        // fully completed.  Complete it now.
        //

        KIRQL irql;

        ASSERT( !irp->PendingReturned );
        ASSERT( !irp->MdlAddress );

        //
        // In the case of name junctions do the transmogrify work.
        //

        if (irp->IoStatus.Status == STATUS_REPARSE &&
            irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT ) {

            PREPARSE_DATA_BUFFER reparseBuffer = NULL;

            ASSERT ( irp->Tail.Overlay.AuxiliaryBuffer != NULL );

            reparseBuffer = (PREPARSE_DATA_BUFFER) irp->Tail.Overlay.AuxiliaryBuffer;

            ASSERT( reparseBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
            ASSERT( reparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
            ASSERT( reparseBuffer->Reserved < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );


            IopDoNameTransmogrify( irp,
                                   fileObject,
                                   reparseBuffer );

        }

        //
        // Now finish up the request.
        //

        KeRaiseIrql( APC_LEVEL, &irql );

        //
        // Note that normally the system would simply call IopCompleteRequest
        // here to complete the packet.  However, because this is a create
        // operation, several assumptions can be made that make it much faster
        // to perform the couple of operations that completing the request
        // would perform.  These include:  copying the I/O status block,
        // dequeueing the IRP and freeing it, and setting the file object's
        // event to the signalled state.  The latter is done here by hand,
        // since it is known that it is not possible for any thread to be
        // waiting on the event.
        //

        ioStatus = irp->IoStatus;
        status = ioStatus.Status;

        fileObject->Event.Header.SignalState = 1;

        IopDequeueThreadIrp( irp );

        //
        // The SystemBuffer is in some cases used by the driver, and
        // needs to be freed if present.
        //

        if ((irp->Flags & IRP_BUFFERED_IO) && (irp->Flags & IRP_DEALLOCATE_BUFFER)) {
            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }

        IoFreeIrp( irp );

        KeLowerIrql( irql );
    }

    //
    // Copy the information field of the I/O status block back to the
    // original caller in case it is required.
    //

    op->Information = ioStatus.Information;

    if (!NT_SUCCESS( status )) {
        int openCancelled;

        //
        // The operation ended in an error.  Kill the file object, dereference
        // the device object, and return a null pointer.
        //

        if (fileObject->FileName.Length) {
            ExFreePool( fileObject->FileName.Buffer );
            fileObject->FileName.Length = 0;
        }

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        openCancelled = (fileObject->Flags & FO_FILE_OPEN_CANCELLED);

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if ((!openCancelled) && (vpb )) {
            IopDereferenceVpbAndFree(vpb);
        }

        return op->FinalStatus = status;

    } else if (status == STATUS_REPARSE) {

        //
        // The operation resulted in a reparse.  This means that the file
        // name in the file object is the new name to be looked up. Replace
        // the complete name string with the new name and return STATUS_REPARSE
        // so the object manager knows to start over again.  Note, however,
        // that the file name buffer in the file object itself is kept intact
        // so that it can be reused when coming back here again.
        //
        // A reparse status may also have been returned from the file system if
        // the volume that was in a drive needed to have been verified, but
        // the verification failed, and a new volume was mounted.  In this
        // case, everything starts over again using the new volume.
        //

        ASSERT( IO_REPARSE == IO_REPARSE_TAG_RESERVED_ZERO );

        if ((ioStatus.Information == IO_REPARSE) ||
            (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            //
            // If the complete name buffer isn't large enough, reallocate it.
            //

            if (CompleteName->MaximumLength < fileObject->FileName.Length) {

                PVOID buffer;

                buffer = ExAllocatePoolWithTag( PagedPool,
                                                fileObject->FileName.Length,
                                                'cFoI' );
                if (!buffer) {
                    return op->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    if (CompleteName->Buffer) {
                        ExFreePool( CompleteName->Buffer );
                    }
                    CompleteName->Buffer = buffer;
                    CompleteName->MaximumLength = fileObject->FileName.Length;
                }
            }

            RtlCopyUnicodeString( CompleteName, &fileObject->FileName );

            //
            // For NTFS directory junction points we NULL the RelatedFileObject.
            // If the prior call was a relative open, the subsequent one will
            // not be.
            //

            if (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {

                op->RelatedFileObject = (PFILE_OBJECT) NULL;
            }
        }

        //
        // Kill the file object, dereference the device object, and return a
        // null pointer.
        //

        if (fileObject->FileName.Length) {
            ExFreePool( fileObject->FileName.Buffer );
            fileObject->FileName.Length = 0;
        }

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if (vpb) {
            IopDereferenceVpbAndFree(vpb);
        }

        ASSERT( IO_REMOUNT == IO_REPARSE_TAG_RESERVED_ONE );

        if (ioStatus.Information == IO_REPARSE_TAG_RESERVED_ONE) {

            //
            // If we are reparsing to verify a volume, restart the reparse
            // by attempting to parse the device once again.  Note that it
            // would be best to simply recurse, but it's not possible since
            // there is a limited amount of stack available to kernel mode
            // and a limit needs to be enforced for the number of times that
            // verify reparse can occur.
            //

            if (++retryCount > IO_MAX_REMOUNT_REPARSE_ATTEMPTS) {

                return STATUS_UNSUCCESSFUL;
            }
            goto reparse_loop;

        } else {

            //
            // Really reparsing a symbolic link, so go back to the object
            // manager so it can begin the parse from the top.
            //

            op->RelatedFileObject = (PFILE_OBJECT) NULL;

            //
            // Note that the mountpoint should be set only for the correct
            // tag. IO_REMOUNT is sent by FAT,CDFS and UDFS to remount a volume.
            // IO_REPARSE is set by the network filesystems to just use a different path.
            //

            if (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {
                op->TraversedMountPoint = TRUE;
            }

            //
            // No driver should return this status for a volume open.
            // If they do then we would skip the security check as override is true.
            // To catch that case we bugcheck here.
            //

            if (op->Override) {
                KeBugCheckEx(DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN,
                             (ULONG_PTR)parseDeviceObject,
                             (ULONG_PTR)deviceObject,
                             (ULONG_PTR)CompleteName,
                             (ULONG_PTR)ioStatus.Information
                             );
            }

            return STATUS_REPARSE;
        }

    } else {

        //
        // The operation was successful. The first thing to do is to see if
        // the device that processed the open also opened the file. If
        // not, we need to adjust the vpb reference counts. Then, if this is
        // not a query or a delete, but rather a normal open/create, return
        // the address of the FileObject to the caller and set the
        // information returned in the original requestor's I/O status block.
        // Also set the value of the parse check field in the open packet to
        // a value which will let the caller know that this routine was
        // successful in creating the file object. Finally, return the status
        // of the operation to the caller.
        //

        PDEVICE_OBJECT deviceObjectThatOpenedFile;

        deviceObjectThatOpenedFile = IoGetRelatedDeviceObject(fileObject);
        if (deviceObject != deviceObjectThatOpenedFile) {
            PVPB    newVpb;

            //
            // The device that opened the related file is not the one
            // that opened this file. So, readjust the vpb reference
            // counts.
            //

            newVpb = fileObject->Vpb;

            //
            // If the new VPB is not the same as the original VPB
            // then reference the new one before freeing the old one.
            // If a filter was just added to the fileobject stack the VPB will not
            // change. So check for a difference in VPB as well.
            //

            if (newVpb != vpb) {
                if (newVpb) {
                    IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                                  (PLONG) &newVpb->ReferenceCount);
                }

                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }
            }
        }

        if (realFileObjectRequired) {

            *Object = fileObject;
            op->ParseCheck = OPEN_PACKET_PATTERN;

            //
            // Add a reference so the file object cannot go away before
            // the create routine gets chance to flag the object for handle
            // create.
            //

            ObReferenceObject( fileObject );

            //
            // If the filename length is zero and its not a relative open or
            // its a relative open to a volume open then set the volume open flag.
            // Also set it only for filesystem device object volume.
            //
            if ((!fileObject->RelatedFileObject || fileObject->RelatedFileObject->Flags & FO_VOLUME_OPEN) &&
                (!fileObject->FileName.Length)) {
                switch (deviceObjectThatOpenedFile->DeviceType) {
                case FILE_DEVICE_DISK_FILE_SYSTEM:
                case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                case FILE_DEVICE_TAPE_FILE_SYSTEM:
                case FILE_DEVICE_FILE_SYSTEM:

                    fileObject->Flags |= FO_VOLUME_OPEN;
                    break;

                default:
                    break;
                }
            }

            return op->FinalStatus = ioStatus.Status;

        } else {

            //
            // This is either a quick query or delete operation.  Determine
            // which it is and quickly perform the operation.
            //

            if (op->QueryOnly) {
                PFAST_IO_DISPATCH fastIoDispatch;
                BOOLEAN queryResult = FALSE;

                fastIoDispatch = deviceObjectThatOpenedFile->DriverObject->FastIoDispatch;

                if (!op->FullAttributes) {
                    PFILE_BASIC_INFORMATION basicInfo = NULL;

                    //
                    // This is a simple FAT file attribute query.  Attempt to
                    // obtain the basic information about the file.
                    //

                    try {

                        if (fastIoDispatch && fastIoDispatch->FastIoQueryBasicInfo) {
                            queryResult = fastIoDispatch->FastIoQueryBasicInfo(
                                            fileObject,
                                            TRUE,
                                            op->BasicInformation,
                                            &ioStatus,
                                            deviceObjectThatOpenedFile
                                            );
                        }
                        if (!queryResult) {

                            basicInfo = ExAllocatePool( NonPagedPool,
                                                        sizeof( FILE_BASIC_INFORMATION ) );
                            if (basicInfo) {
                                status = IoQueryFileInformation(
                                            fileObject,
                                            FileBasicInformation,
                                            sizeof( FILE_BASIC_INFORMATION ),
                                            basicInfo,
                                            &returnedLength
                                            );
                                if (NT_SUCCESS( status )) {
                                    RtlCopyMemory( op->BasicInformation,
                                                   basicInfo,
                                                   returnedLength );
                                }
                                ExFreePool( basicInfo );
                            } else {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        } else {
                            status = ioStatus.Status;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        if (basicInfo) {
                            ExFreePool( basicInfo );
                        }
                        status = GetExceptionCode();
                    }

                } else {

                    //
                    // This is a full attribute query.  Attempt to obtain the
                    // full network attributes for the file.  This includes
                    // both the basic and standard information about the
                    // file.  Try the fast path first, if it exists.
                    //

                    if (fastIoDispatch &&
                        fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoQueryNetworkOpenInfo ) &&
                        fastIoDispatch->FastIoQueryNetworkOpenInfo) {
                        queryResult = fastIoDispatch->FastIoQueryNetworkOpenInfo(
                                        fileObject,
                                        TRUE,
                                        op->NetworkInformation,
                                        &ioStatus,
                                        deviceObjectThatOpenedFile
                                        );
                    }
                    if (!queryResult) {

                        //
                        // Either the fast dispatch routine did not exist, or
                        // it simply wasn't callable at this time.  Attempt to
                        // obtain all of the information at once via an IRP-
                        // based call.
                        //

                        status = IoQueryFileInformation(
                                    fileObject,
                                    FileNetworkOpenInformation,
                                    sizeof( FILE_NETWORK_OPEN_INFORMATION ),
                                    op->NetworkInformation,
                                    &returnedLength
                                    );

                        if (!NT_SUCCESS( status )) {
                            if (status == STATUS_INVALID_PARAMETER ||
                                status == STATUS_NOT_IMPLEMENTED) {
                                status = IopGetNetworkOpenInformation(fileObject, op);
                            }
                        }
                    }
                }

            } else {

                //
                // There is nothing to do for a quick delete since the caller
                // set the FILE_DELETE_ON_CLOSE CreateOption so it is already
                // set in the file system.
                //

                NOTHING;

            }

            op->ParseCheck = OPEN_PACKET_PATTERN;
            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            } else {
                IopDeleteFile( fileObject );
            }
            op->FileObject = (PFILE_OBJECT) NULL;

            op->FinalStatus = status;

            return status;
        }
    }
}

NTSTATUS
IopGetNetworkOpenInformation(
    IN  PFILE_OBJECT    FileObject,
    IN  POPEN_PACKET    Op
    )
/*++

Routine Description:

    This routines gets the network information in two steps.
    Its called out as a separate routine from IopParseDevice to save stack for
    common create paths.

Arguments:

    FileObject  - Pointer to the fileobject for the opened file.

    Op          - Pointer to the open packet.


Return Value:

    NTSTATUS

--*/
{
#define COPY_ATTRIBUTES( n, b, s ) {                                    \
        (n)->CreationTime.QuadPart = (b)->CreationTime.QuadPart;        \
        (n)->LastAccessTime.QuadPart = (b)->LastAccessTime.QuadPart;    \
        (n)->LastWriteTime.QuadPart = (b)->LastWriteTime.QuadPart;      \
        (n)->ChangeTime.QuadPart = (b)->ChangeTime.QuadPart;            \
        (n)->AllocationSize.QuadPart = (s)->AllocationSize.QuadPart;    \
        (n)->EndOfFile.QuadPart = (s)->EndOfFile.QuadPart;              \
        (n)->FileAttributes = (b)->FileAttributes; }

    FILE_BASIC_INFORMATION     basicInfo;
    FILE_STANDARD_INFORMATION  stdInfo;
    ULONG                      returnedLength;
    NTSTATUS                   status;

    PAGED_CODE();

    //
    // The IRP-based call did not work either, so
    // simply try to obtain the information by
    // doing IRP-based queries for the basic and
    // standard information and piecing together
    // the results into the caller's buffer.  Note
    // that it might be possible to perform fast
    // I/O operations to get the data, but it
    // might also fail because of the above.  So
    // simply query the information the long way.
    //

    status = IoQueryFileInformation(
                FileObject,
                FileBasicInformation,
                sizeof( FILE_BASIC_INFORMATION ),
                &basicInfo,
                &returnedLength
                );

    if (NT_SUCCESS( status )) {
        status = IoQueryFileInformation(
                    FileObject,
                    FileStandardInformation,
                    sizeof( FILE_STANDARD_INFORMATION ),
                    &stdInfo,
                    &returnedLength
                    );
        if (NT_SUCCESS( status )) {
            COPY_ATTRIBUTES( Op->NetworkInformation,
                             &basicInfo,
                             &stdInfo );
        }
    }
    return status;
}

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and is
    also given a handle to a directory file object that the operation is to be
    performed relative to.  This routine is specified as the parse routine for
    all file objects.

    This routine simply invokes the parse routine for the appropriate device
    that is associated with the file object.  It is the responsibility of that
    routine to perform the operation.

Arguments:

    ParseObject - Pointer to the file object that the name is to be opened or
        created relative to.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    SecurityQos - Supplies a pointer to the captured QOS information
        if available.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{
    PDEVICE_OBJECT deviceObject;
    POPEN_PACKET op;

    PAGED_CODE();

    //
    // Get the address of the Open Packet (OP).
    //

    op = (POPEN_PACKET) Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Get a pointer to the device object for this file.
    //

    deviceObject = IoGetRelatedDeviceObject( (PFILE_OBJECT) ParseObject );

    //
    // Pass the related file object to the device object parse routine.
    //

    op->RelatedFileObject = (PFILE_OBJECT) ParseObject;

    //
    // Open or create the specified file.
    //

    return IopParseDevice( deviceObject,
                           ObjectType,
                           AccessState,
                           AccessMode,
                           Attributes,
                           CompleteName,
                           RemainingName,
                           Context,
                           SecurityQos,
                           Object );
}

NTSTATUS
IopQueryNameInternal(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    IN BOOLEAN UseDosDeviceName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE  Mode
    )

/*++

Routine Description:

    This function implements the query name procedure for the Object Manager
    for querying the names of file objects.

Arguments:

    Object - Pointer to the file object whose name is to be retrieved.

    HasObjectName - Indicates whether or not the object has a name.

    UseDosDeviceName - Indicates whether to translate the device object part
                        of the fileobject into the dosdevice name space or the
                        regular \device namespace via ob

    ObjectNameInfo - Buffer in which to return the name.

    Length - Specifies the length of the output buffer, in bytes.

    ReturnLength - Specifies the number of bytes actually returned in the
        output buffer or the number of bytes needed if Length is smaller
        than needed.

Return Value:

    The function return value is the final status of the query operation.

--*/

{
    NTSTATUS status;
    ULONG lengthNeeded;
    PFILE_OBJECT fileObject;
    PUCHAR buffer;
    PWSTR p;
    POBJECT_NAME_INFORMATION deviceNameInfo;
    PFILE_NAME_INFORMATION fileNameInfo;
    ULONG length;
    BOOLEAN deviceNameOverflow;
    BOOLEAN dosLookupSuccess = 0;

    UNREFERENCED_PARAMETER( HasObjectName );

    PAGED_CODE();

    ASSERT( FIELD_OFFSET( FILE_NAME_INFORMATION, FileName ) < sizeof( OBJECT_NAME_INFORMATION ) );

    //
    // Ensure that the size of the output buffer is at least the minimum
    // size required to include the basic object name information structure.
    //

    if (Length < sizeof( OBJECT_NAME_INFORMATION )) {
        *ReturnLength = sizeof(OBJECT_NAME_INFORMATION);
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Begin by allocating a buffer in which to build the name of the file.
    //

    buffer = ExAllocatePoolWithTag( PagedPool, Length, '  oI' );

    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the name of the device on which the file is open.
    //

    fileObject = (PFILE_OBJECT) Object;
    deviceNameInfo = (POBJECT_NAME_INFORMATION) buffer;

    if (UseDosDeviceName) {
        if (fileObject->DeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {

            lengthNeeded = sizeof(OBJECT_NAME_INFORMATION) + 2*sizeof(WCHAR); // For the extra '\' and '\0'

            if (lengthNeeded > Length) {
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            deviceNameInfo->Name.Length = sizeof(WCHAR);
            deviceNameInfo->Name.MaximumLength = sizeof(WCHAR);
            p = (PWSTR) (deviceNameInfo + 1);
            *p = '\\'; // Start with a '\' as RDR does not return the extra
            deviceNameInfo->Name.Buffer = p;

        } else {
            status = IoVolumeDeviceToDosName( fileObject->DeviceObject, &deviceNameInfo->Name );
            lengthNeeded = sizeof(OBJECT_NAME_INFORMATION) + deviceNameInfo->Name.Length + sizeof(WCHAR);
        }

        //
        // If querying the dos name fails try to atleast get the real device name
        //

        if (!NT_SUCCESS(status)) {
            status = ObQueryNameString( (PVOID) fileObject->DeviceObject,
                                    deviceNameInfo,
                                    Length,
                                    &lengthNeeded );
        } else {
            dosLookupSuccess++;
        }
    } else {
        status = ObQueryNameString( (PVOID) fileObject->DeviceObject,
                                deviceNameInfo,
                                Length,
                                &lengthNeeded );
    }

    if (!NT_SUCCESS( status )) {
        if (status != STATUS_INFO_LENGTH_MISMATCH) {
            return status;
        }
    }

    //
    // Ensure that there is enough room in the output buffer to return the
    // name and copy it.
    //

    p = (PWSTR) (ObjectNameInfo + 1);

    //
    // If we got a DOS name, note the name isn't contiguous to the device name info,
    // and that we should free it (the Rtl call did not know we allocated this big
    // buffer, and made a new one).
    //

    try {

        if (UseDosDeviceName && dosLookupSuccess) {

            ULONG BaseCopyLength;
            ULONG NameCopyLength;

            //
            // We will never take an exception in this path. That's why we don't have to free
            // the device name buffer in the exception handler.
            //

            ASSERT(Mode == KernelMode);

            //
            //  Figure out how much of each part we can copy.
            //

            BaseCopyLength = sizeof(UNICODE_STRING);

            if ( Length < lengthNeeded ) {
                if ( Length < sizeof(UNICODE_STRING)) {
                    BaseCopyLength = Length;
                    NameCopyLength = 0;
                } else {
                    NameCopyLength = Length - BaseCopyLength;
                }
            } else {
                NameCopyLength = deviceNameInfo->Name.Length;
            }

            //
            // Copy in two parts - the base chunk of the UNICODE_STRING and then
            // as much of the name as will fit.
            //

            RtlCopyMemory( ObjectNameInfo,
                           deviceNameInfo,
                           BaseCopyLength );
            RtlCopyMemory( p,
                           deviceNameInfo->Name.Buffer,
                           NameCopyLength );

            if (fileObject->DeviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM) {
                ExFreePool( deviceNameInfo->Name.Buffer );
            }

        } else {

            RtlCopyMemory( ObjectNameInfo,
                           deviceNameInfo,
                           lengthNeeded > Length ? Length : lengthNeeded );
        }

        ObjectNameInfo->Name.Buffer = p;
        p = (PWSTR) ((PCHAR) p + deviceNameInfo->Name.Length);

        //
        // If the buffer is already full, note and continue to pick up the filename length.
        // We want to return the required length for the entire result.
        //

        deviceNameOverflow = FALSE;
        if (lengthNeeded > Length) {
            *ReturnLength = lengthNeeded;
            deviceNameOverflow = TRUE;
        }

        //
        // Reset the state for the buffer to obtain the filename portion of the
        // name and calculate the remaining length of the caller's buffer.  Note
        // that in the following calculations, there are two assumptions and
        // and dependencies:
        //
        //     1)  The above query of the device name's returned length needed
        //         include a NULL character which will be included at the end
        //         of the entire name.  This is included in the calculations
        //         although it does not appear to be included.
        //
        //     2)  The sizeof the object name information buffer is assumed
        //         (and guaranteed because it can never change) to be larger
        //         than the filename offset in a file name information buffer.
        //         Therefore it is known that the new length of the "buffer"
        //         variable can be set to the remaining length plus at least 4.
        //

        fileNameInfo = (PFILE_NAME_INFORMATION) buffer;

        if (deviceNameOverflow) {
            length = Length;
        } else {
            length = Length - lengthNeeded;
            length += FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        }

        if (((Mode == UserMode) && (!UseDosDeviceName)) ||
            !(fileObject->Flags & FO_SYNCHRONOUS_IO)) {

            //
            // Query the name of the file based using an intermediary buffer.
            //

            status = IopQueryXxxInformation( fileObject,
                                             FileNameInformation,
                                             length,
                                             Mode,
                                             (PVOID) fileNameInfo,
                                             &lengthNeeded,
                                             TRUE );
        } else {

            //
            // This is a kernel mode request for a file that was opened for
            // synchronous I/O.  A special function that does not obtain the
            // file object lock is required, otherwise the request may deadlock
            // since the lock is probably already owned.
            //

            status = IopGetFileInformation( fileObject,
                                     length,
                                     FileNameInformation,
                                     fileNameInfo,
                                     &lengthNeeded );
        }

        //
        // If an error occurred attempting to obtain the filename return now.  Note
        // that buffer overflow is a warning, not an error.
        //

        if (NT_ERROR( status )) {
            if (status == STATUS_INVALID_PARAMETER ||
                status == STATUS_INVALID_DEVICE_REQUEST ||
                status == STATUS_NOT_IMPLEMENTED ||
                status == STATUS_INVALID_INFO_CLASS) {

                lengthNeeded = FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
                fileNameInfo->FileNameLength = 0;
                fileNameInfo->FileName[0] = OBJ_NAME_PATH_SEPARATOR;
                status = STATUS_SUCCESS;
            } else {
                leave;
            }
        }

        //
        // Compute the correct length
        // Note that ReturnLength already contains a space for NULL added by the previous ObQueryNameString.
        //

        if (deviceNameOverflow) {
            *ReturnLength += fileNameInfo->FileNameLength;
            status = STATUS_BUFFER_OVERFLOW;
            leave;
        }

        //
        // Set the remaining length of the caller's buffer as well as the total
        // length needed to contain the entire name of the file.
        //

        length = lengthNeeded - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        lengthNeeded = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo) + fileNameInfo->FileNameLength;

        //
        // Attempt to copy the name of the file into the output buffer.  Note
        // that if the file name does not begin w/a '\', then it is not volume
        // relative, so the name of the file cannot be expressed as the
        // concatenation of the name of the device and the file.  Therefore an
        // error is returned.
        //
        // The only example of this situation known at this time is when one
        // opens a directory by file ID, and then opens a file relative to that
        // directory.  When attempting to query the path, if the caller did not
        // have traverse access to open the directory, then the only name that
        // can be returned is the path name to the file from the directory, but
        // the volume-relative name cannot be returned.  Therefore, the file
        // system returns only the name of the directory and the path to the
        // file, but this is not volume-relative so the only recourse is to
        // return an error.
        //
        // Note that if the caller were to call NtQueryInformationFile and
        // request FileNameInformation, then the name above named will be
        // successfully returned from the file system.
        //

        if (fileNameInfo->FileName[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_PATH_INVALID;
            leave;
        }

        RtlCopyMemory( p,
                       fileNameInfo->FileName,
                       length );
        p = (PWSTR) ((PCH) p + length);
        *p = '\0';
        lengthNeeded += sizeof( WCHAR );

        *ReturnLength = lengthNeeded;

        length = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo);
        ObjectNameInfo->Name.Length = (USHORT) (length - sizeof( *ObjectNameInfo ));
        ObjectNameInfo->Name.MaximumLength =  (USHORT) ((length - sizeof( *ObjectNameInfo )) + sizeof( WCHAR ));
    }

    finally {

        //
        // Finally, free the temporary buffer.
        //

        ExFreePool( buffer );
    }

    return status;
}

NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function implements the query name procedure for the Object Manager
    for querying the names of file objects.

Arguments:

    Object - Pointer to the file object whose name is to be retrieved.

    HasObjectName - Indicates whether or not the object has a name.

    ObjectNameInfo - Buffer in which to return the name.

    Length - Specifies the length of the output buffer, in bytes.

    ReturnLength - Specifies the number of bytes actually returned in the
        output buffer.

    Mode = Processor mode of the caller

Return Value:

    The function return value is the final status of the query operation.

--*/

{
    UNREFERENCED_PARAMETER (Mode);

    return IopQueryNameInternal( Object,
                                 HasObjectName,
                                 FALSE,
                                 ObjectNameInfo,
                                 Length,
                                 ReturnLength,
                                 Mode );
}



VOID
IopCheckBackupRestorePrivilege(
    IN PACCESS_STATE AccessState,
    IN OUT PULONG CreateOptions,
    IN KPROCESSOR_MODE PreviousMode,
    IN ULONG Disposition
    )

/*++

Routine Description:

    This funcion will determine if the caller is asking for any accesses
    that may be satisfied by Backup or Restore privileges, and if so,
    perform the privilge checks.  If the privilege checks succeed, then
    the appropriate bits will be moved out of the RemainingDesiredAccess
    field in the AccessState structure and placed into the PreviouslyGrantedAccess
    field.

    Note that access is not denied if the caller does not have either or
    both of the privileges, since he may be granted the desired access
    via the security descriptor on the object.

    This routine will also set a flag in the AccessState structure so that
    it will not perform these privilege checks again in case we come through
    this way again due to a reparse.

Arguments:

    AccessState - The AccessState containing the current state of this access
        attempt.

    CreateOptions - The CreateOptions field from the OPEN_PACKET structure for
        this open attempt.

    PreviousMode - The processor mode to be used in checking parameters.

    Disposition - The create disposition for this request.

Return Value:

    None.

--*/

{
    ACCESS_MASK desiredAccess;
    ACCESS_MASK readAccess;
    ACCESS_MASK writeAccess;
    PRIVILEGE_SET requiredPrivileges;
    BOOLEAN accessGranted;
    BOOLEAN keepBackupIntent = FALSE;
    BOOLEAN ForceRestoreCheck = FALSE;

    PAGED_CODE();

    //
    // Check to determine whether or not this check has already been made.
    // If so, simply return back to the caller.
    //

    if (AccessState->Flags & SE_BACKUP_PRIVILEGES_CHECKED) {
        return;
    }

    if (*CreateOptions & FILE_OPEN_FOR_BACKUP_INTENT) {
        AccessState->Flags |= SE_BACKUP_PRIVILEGES_CHECKED;

        readAccess = READ_CONTROL | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ | FILE_TRAVERSE;
        writeAccess = WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY | DELETE;

        desiredAccess = AccessState->RemainingDesiredAccess;

        //
        // If the caller has requested MAXIMUM_ALLOWED, then make it appear as
        // if the request was for everything permitted by Backup and Restore,
        // and then grant everything that can actually be granted.
        //

        if (desiredAccess & MAXIMUM_ALLOWED) {
            desiredAccess |= ( readAccess | writeAccess );
        }

        //
        // If the disposition says that we're opening the file, check for both backup
        // and restore privilege, depending on what's in the desired access.
        //
        // If the disposition says that we're creating or trying to overwrite the file,
        // then all we need to do is to check for restore privilege, and if it's there,
        // grant every possible access.
        //

        if ((Disposition == FILE_OPEN )  || (Disposition == FILE_OPEN_IF) || (Disposition == FILE_OVERWRITE_IF)) {

            //
            // If the request was for any of the bits in the read access mask, then
            // assume that this is a backup operation, and check for the Backup
            // privielege.  If the caller has it, then grant the intersection of
            // the desired access and read access masks.
            //

            if (readAccess & desiredAccess) {

                requiredPrivileges.PrivilegeCount = 1;
                requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
                requiredPrivileges.Privilege[0].Luid = SeBackupPrivilege;
                requiredPrivileges.Privilege[0].Attributes = 0;

                accessGranted = SePrivilegeCheck( &requiredPrivileges,
                                                  &AccessState->SubjectSecurityContext,
                                                  PreviousMode );

                if (accessGranted) {

                    //
                    // The caller has Backup privilege, so grant the appropriate
                    // accesses.
                    //

                    keepBackupIntent = TRUE;
                    (VOID) SeAppendPrivileges( AccessState, &requiredPrivileges );
                    AccessState->PreviouslyGrantedAccess |= ( desiredAccess & readAccess );
                    AccessState->RemainingDesiredAccess &= ~readAccess;
                    desiredAccess &= ~readAccess;
                    AccessState->Flags |= TOKEN_HAS_BACKUP_PRIVILEGE;
                }
            }

        } else {

            ForceRestoreCheck = TRUE;
        }

        //
        // If the request was for any of the bits in the write access mask, then
        // assume that this is a restore operation, so check for the Restore
        // privilege.  If the caller has it, then grant the intersection of
        // the desired access and write access masks.
        //

        if ((writeAccess & desiredAccess) || ForceRestoreCheck) {

            requiredPrivileges.PrivilegeCount = 1;
            requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
            requiredPrivileges.Privilege[0].Luid = SeRestorePrivilege;
            requiredPrivileges.Privilege[0].Attributes = 0;

            accessGranted = SePrivilegeCheck( &requiredPrivileges,
                                              &AccessState->SubjectSecurityContext,
                                              PreviousMode );

            if (accessGranted) {

                //
                // The caller has Restore privilege, so grant the appropriate
                // accesses.
                //

                keepBackupIntent = TRUE;
                (VOID) SeAppendPrivileges( AccessState, &requiredPrivileges );
                AccessState->PreviouslyGrantedAccess |= (desiredAccess & writeAccess);
                AccessState->RemainingDesiredAccess &= ~writeAccess;
                AccessState->Flags |= TOKEN_HAS_RESTORE_PRIVILEGE;
            }
        }

        //
        // If either of the access types was granted because the caller had
        // backup or restore privilege, then the backup intent flag is kept.
        // Otherwise, it is cleared so that it is not passed onto the driver
        // so that it is not incorrectly propogated anywhere else, since this
        // caller does not actually have the privilege enabled.
        //

        if (!keepBackupIntent) {
            *CreateOptions &= ~FILE_OPEN_FOR_BACKUP_INTENT;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\qsea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    qsea.c

Abstract:

    This module contains the code to implement the NtQueryEaFile and the
    NtSetEaFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 20-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtQueryEaFile)
#pragma alloc_text(PAGE, NtSetEaFile)
#endif

NTSTATUS
NtQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service returns the Extended Attributes (EAs) associated with the
    file specified by the FileHandle parameter.  The amount of information
    returned is based on the size of the EAs, and the size of the buffer.
    That is, either all of the EAs are written to the buffer, or the buffer
    is filled with complete EAs if the buffer is not large enough to contain
    all of the EAs.  Only complete EAs are ever written to the buffer; no
    partial EAs will ever be returned.

Arguments:

    FileHandle - Supplies a handle to the file for which the EAs are returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the EAs for the file.

    Length - Supplies the length, in bytes, of the buffer.

    ReturnSingleEntry - Indicates that only a single entry should be returned
        rather than filling the buffer with as many EAs as possible.

    EaList - Optionally supplies a list of EA names whose values are returned.

    EaListLength - Supplies the length of the EA list, if an EA list was
        specified.

    EaIndex - Supplies the optional index of an EA whose value is to be
        returned.  If specified, then only that EA is returned.

    RestartScan - Indicates whether the scan of the EAs should be restarted
        from the beginning.

Return Value:

    The status returned is the final completion status of the operation.

--*/

#define GET_OFFSET_LENGTH( CurrentEa, EaBase ) (    \
    (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )


{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    BOOLEAN eaListPresent = FALSE;
    ULONG eaIndexValue = 0L;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The buffer must be writeable by the caller.
            //

            ProbeForWrite( Buffer, Length, sizeof( ULONG ) );

            //
            // If the optional EaIndex parameter was specified, then it must be
            // readable by the caller.  Capture its value.
            //

            if (ARGUMENT_PRESENT( EaIndex )) {
                eaIndexValue = ProbeAndReadUlong( EaIndex );
            }

            //
            // If the optional EaList parameter was specified, then it must be
            // readable by the caller.  Validate that the buffer contains a
            // legal get information structure.
            //

            if (ARGUMENT_PRESENT( EaList ) && EaListLength != 0) {

                PFILE_GET_EA_INFORMATION eas;
                LONG tempLength;
                ULONG entrySize;

                eaListPresent = TRUE;

                ProbeForRead( EaList, EaListLength, sizeof( ULONG ) );
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           EaListLength );
                RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );

                eas = (PFILE_GET_EA_INFORMATION) auxiliaryBuffer;
                tempLength = EaListLength;

                //
                // Walk the request buffer and ensure that its format is
                // valid.  That is, ensure that it does not walk off the
                // end of the buffer that has been captured.
                //

                for (;;) {

                    //
                    // Get the size of the current entry in the buffer.
                    //

                    if (tempLength < FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0])) {
                        tempLength = 0;
                        ExFreePool( auxiliaryBuffer );
                        auxiliaryBuffer = (PVOID) NULL;
                        IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                        IoStatusBlock->Information = tempLength;
                        return STATUS_EA_LIST_INCONSISTENT;
                        }

                    entrySize = FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) + eas->EaNameLength + 1;

                    if ((ULONG) tempLength < entrySize) {
                        tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                        ExFreePool( auxiliaryBuffer );
                        auxiliaryBuffer = (PVOID) NULL;
                        IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                        IoStatusBlock->Information = tempLength;
                        return STATUS_EA_LIST_INCONSISTENT;
                        }

                    if (eas->NextEntryOffset != 0) {

                        //
                        // There is another entry in the buffer and it must
                        // be longword aligned.  Ensure that the offset
                        // indicates that it is.  If it isn't, return an
                        // invalid parameter status.
                        //

                        if ((((entrySize + 3) & ~3) != eas->NextEntryOffset) ||
                            ((LONG) eas->NextEntryOffset < 0)) {
                            tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                            ExFreePool( auxiliaryBuffer );
                            auxiliaryBuffer = (PVOID) NULL;
                            IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                            IoStatusBlock->Information = tempLength;
                            return STATUS_EA_LIST_INCONSISTENT;

                        } else {

                            //
                            // There is another entry in the buffer, so
                            // account for the size of the current entry
                            // in the length and get a pointer to the next
                            // entry.
                            //

                            tempLength -= eas->NextEntryOffset;
                            if (tempLength < 0) {
                                tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                                ExFreePool( auxiliaryBuffer );
                                auxiliaryBuffer = (PVOID) NULL;
                                IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                                IoStatusBlock->Information = tempLength;
                                return STATUS_EA_LIST_INCONSISTENT;
                            }
                            eas = (PFILE_GET_EA_INFORMATION) ((PCHAR) eas + eas->NextEntryOffset);
                        }

                    } else {

                        //
                        // There are no other entries in the buffer.  Simply
                        // account for the overall buffer length according
                        // to the size of the current entry and exit the
                        // loop.
                        //

                        tempLength -= entrySize;
                        break;
                    }
                }

                //
                // All of the entries in the buffer have been processed.
                // Check to see whether the overall buffer length went
                // negative.  If so, return an error.
                //

                if (tempLength < 0) {
                    tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                    ExFreePool( auxiliaryBuffer );
                    auxiliaryBuffer = (PVOID) NULL;
                    IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                    IoStatusBlock->Information = tempLength;
                    return STATUS_EA_LIST_INCONSISTENT;
                }

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters, allocating the pool buffer, or copying the
            // caller's EA list to the buffer.  Cleanup and return an
            // appropriate error status code.
            //

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was KernelMode.  Simply allocate pool for the
        // EaList, if one was specified, and copy the string to it.  Also,
        // if an EaIndex was specified copy it as well.
        //

        if (ARGUMENT_PRESENT( EaList ) && (EaListLength != 0)) {
            eaListPresent = TRUE;
            try {
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           EaListLength );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
            RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );
        }

        if (ARGUMENT_PRESENT( EaIndex )) {
            eaIndexValue = *EaIndex;
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_EA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        if (eaListPresent) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eaListPresent) {
                    ExFreePool( auxiliaryBuffer );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            if (eaListPresent) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (eaListPresent) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_EA;
    irpSp->FileObject = fileObject;

    //
    // If the caller specified an EA list of names to be queried, then pass
    // the address of the intermediary buffer containing the list to the
    // driver.
    //

    if (eaListPresent) {
        irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
        irpSp->Parameters.QueryEa.EaList = auxiliaryBuffer;
        irpSp->Parameters.QueryEa.EaListLength = EaListLength;
    }

    //
    // Now determine whether this driver expects to have data buffered
    // to it or whether it performs direct I/O.  This is based on the
    // DO_BUFFERED_IO flag in the device object.  If the flag is set,
    // then a system buffer is allocated and the driver's data will be
    // copied to it.  If the DO_DIRECT_IO flag is set in the device
    // object, then a Memory Descriptor List (MDL) is allocated and
    // the caller's buffer is locked down using it.  Finally, if the
    // driver specifies neither of the flags, then simply pass the
    // address and length of the buffer and allow the driver to perform
    // all of the checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The driver wishes the caller's buffered be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also indicate
        // that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception
        // handler that will perform cleanup if the operation fails.
        //

        if (Length) {
            try {

                //
                // Allocate the intermediary system buffer from nonpaged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                   ExAllocatePoolWithQuota( NonPagedPool, Length );
 
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the system buffer.
                // Determine what actually happened, clean everything
                // up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can
            // take place during I/O completion.  Also, set the flags so
            // that the completion code knows to do the copy and to deallocate
            // the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                                   IRP_DEALLOCATE_BUFFER |
                                   IRP_INPUT_OPERATION);
        } else {
            //
            // This is a zero-length request.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_INPUT_OPERATION);

        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke
        // the memory management routine to lock the buffer into memory.
        // This is done using an exception handler that will perform
        // cleanup if the operation fails.
        //

        if (Length) {
            mdl = (PMDL) NULL;

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off
                // of the IRP.  Probe and lock the pages associated with
                // the caller's buffer for write access and fill in the MDL
                // with the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the MDL.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access
        // to it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryEa.Length = Length;
    irpSp->Parameters.QueryEa.EaIndex = eaIndexValue;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }
    if (ARGUMENT_PRESENT( EaIndex )) {
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This service replaces the Extended Attributes (EAs) associated with the file
    specified by the FileHandle parameter.  All of the EAs associated with the
    file are replaced by the EAs in the specified buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose EAs should be changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the new EAs which should be
        used to replace the EAs currently associated with the file.

    Length - Supplies the length, in bytes, of the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The Buffer parameter must be readable by the caller.
            //

            ProbeForRead( Buffer, Length, sizeof( ULONG ) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Cleanup and return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }


    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_WRITE_EA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_EA;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this driver expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  if the flag is set, then a system buffer is
    // allocated and driver's data is copied to it.  If the DO_DIRECT_IO flag
    // is set in the device object, then a Memory Descriptor List (MDL) is
    // allocated and the caller's buffer is locked down using it.  Finally, if
    // the driver specifies neither of the flags, then simply pass the address
    // and length of the buffer and allow the driver to perform all of the
    // checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        PFILE_FULL_EA_INFORMATION systemBuffer;
        ULONG errorOffset;

        //
        // The driver wishes the caller's buffer to be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also check to
        // ensure that the caller's EA list is valid.  All of this is
        // performed within an exception handler that will perform
        // cleanup if the operation fails.
        //

        if (Length) {
            try {

            //
            // Allocate the intermediary system buffer and charge the caller
            // quota for its allocation.  Copy the caller's EA buffer into the
            // buffer and check to ensure that it is valid.
            //

                systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

                irp->AssociatedIrp.SystemBuffer = systemBuffer;

                RtlCopyMemory( systemBuffer, Buffer, Length );

                status = IoCheckEaBufferValidity( systemBuffer,
                                                  Length,
                                                  &errorOffset );

                if (!NT_SUCCESS( status )) {
                    IoStatusBlock->Status = status;
                    IoStatusBlock->Information = errorOffset;
                    ExRaiseStatus( status );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while allocating the buffer, copying
                // the caller's data into it, or walking the EA buffer.  Determine
                // what happened, cleanup, and return an appropriate error status
                // code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }

            //
            // Set the flags so that the completion code knows to deallocate the
            // buffer.
            //
    
            irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
        }


    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This is
        // done using an exception handler that will perform cleanup if the
        // operation fails.
        //

        mdl = (PMDL) NULL;

        if (Length) {
            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of the
                // IRP.  Probe and lock the pages associated with the caller's
                // buffer for read access and fill in the MDL with the PFNs of those
                // pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually happened,
                // clean everything up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetEa.Length = Length;


    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\qsfs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    qsfs.c

Abstract:

    This module contains the code to implement the NtQueryVolumeInformationFile
    and NtSetVolumeInformationFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 22-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"
#pragma hdrstop
#include <ioevent.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtQueryVolumeInformationFile)
#pragma alloc_text(PAGE, NtSetVolumeInformationFile)
#endif

NTSTATUS
NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service returns information about the volume associated with the
    FileHandle parameter.  The information returned in the buffer is defined
    by the FsInformationClass parameter.  The legal values for this parameter
    are as follows:

        o  FileFsVolumeInformation

        o  FileFsSizeInformation

        o  FileFsDeviceInformation

        o  FileFsAttributeInformation

Arguments:

    FileHandle - Supplies a handle to an open volume, directory, or file
        for which information about the volume is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();


    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FsInformationClass parameter is legal for querying
        // information about the volume.
        //

        if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
            IopQueryFsOperationLength[FsInformationClass] == 0) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Finally, ensure that the supplied buffer is large enough to contain
        // the information associated with the specified query operation that
        // is to be performed.
        //

        if (Length < (ULONG) IopQueryFsOperationLength[FsInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FsInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FsInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FsInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FsInformation,
                               Length,
                               IopQuerySetFsAlignmentRequirement[FsInformationClass] );

            }
#else
            ProbeForWrite( FsInformation,
                           Length,
                           IopQuerySetFsAlignmentRequirement[FsInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's parameters.
            // Simply return an appropriate error status code.
            //


            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopQueryFsOperationAccess[FsInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this open file object represents an open device that was explicitly
    // opened for querying the device's attributes, then ensure that the type
    // of information class was device information.
    //

    if ((fileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
        FsInformationClass != FileFsDeviceInformation) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.  A special check is made
    // here to determine whether this query is for device information.  If
    // it is, and either:
    //
    //     a)  The open was for the device itself, or
    //
    //     b)  The open was for a file but this is not a redirected device,
    //
    // then perform the query operation in-line.  That is, do not allocate
    // an IRP and call the driver, rather, simply copy the device type and
    // characteristics information from the target device object pointed
    // to by the device object in the file object (the "real" device object
    // in a mass storage device stack).
    //

    if (FsInformationClass == FileFsDeviceInformation &&
        (fileObject->Flags & FO_DIRECT_DEVICE_OPEN ||
        fileObject->DeviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM)) {

        PFILE_FS_DEVICE_INFORMATION deviceAttributes;
        BOOLEAN deviceMounted = FALSE;

        //
        // This query operation can be performed in-line.  Simply copy the
        // information directly from the target device object and indicate
        // that the operation was successful.  Begin, however, by determining
        // whether or not the device is mounted.  This cannot be done at the
        // same time as attempting to touch the user's buffer, as looking at
        // the mounted bit occurs at raised IRQL.
        //

        deviceObject = fileObject->DeviceObject;
        if (deviceObject->Vpb) {
            deviceMounted = IopGetMountFlag( deviceObject );
        }

        //
        // Copy the characteristics information from the device's object
        // into the caller's buffer.
        //

        deviceAttributes = (PFILE_FS_DEVICE_INFORMATION) FsInformation;

        try {

            deviceAttributes->DeviceType = deviceObject->DeviceType;
            deviceAttributes->Characteristics = deviceObject->Characteristics;
            if (deviceMounted) {
                deviceAttributes->Characteristics |= FILE_DEVICE_IS_MOUNTED;
            }

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_FS_DEVICE_INFORMATION );
            status = STATUS_SUCCESS;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            // An error occurred attempting to write into one of the caller's
            // buffers.  Simply indicate that the error occurred, and fall
            // through.
            //

            status = GetExceptionCode();
        }

        //
        // If this operation was performed as synchronous I/O, then release
        // the file object lock.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }

        //
        // Now simply cleanup and return the final status of the operation.
        //

        ObDereferenceObject( fileObject );
        return status;

    }

    if (FsInformationClass == FileFsDriverPathInformation) {

        PFILE_FS_DRIVER_PATH_INFORMATION systemBuffer = NULL;
        PFILE_FS_DRIVER_PATH_INFORMATION userBuffer = FsInformation;

        try {


            systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

            RtlCopyMemory( systemBuffer,
                           userBuffer,
                           Length );

            status = IopGetDriverPathInformation(fileObject, systemBuffer, Length);

            if (!NT_SUCCESS(status)) {
                ExRaiseStatus(status);
            }

            userBuffer->DriverInPath = systemBuffer->DriverInPath; 

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_FS_DRIVER_PATH_INFORMATION );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while allocating the intermediary
            // system buffer or while copying the caller's data into the
            // buffer. Cleanup and return an appropriate error status code.
            //

            status = GetExceptionCode();

        }

        if (systemBuffer) {
            ExFreePool(systemBuffer);
        }

        //
        // If this operation was performed as synchronous I/O, then release
        // the file object lock.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }

        ObDereferenceObject( fileObject);
        return status;
    }

    //
    // This is either a query that is not for device characteristics
    // information, or it is a query for device information, but it is
    // a query for a redirected device.  Take the long route and actually
    // invoke the driver for the target device to get the information.
    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get a pointer to the device object for the target device.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // If this I/O operation is not being performed as synchronous I/O,
    // then allocate an event that will be used to synchronize the
    // completion of this operation.  That is, this system service is
    // a synchronous API being invoked for a file that is opened for
    // asynchronous I/O.
    //

    if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an
        // appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer which should be used to put the information into
    // by the driver.  This will be copied back to the caller's buffer when
    // the service completes.  This is done by setting the flag which says
    // that this is an input operation.
    //

    irp->UserBuffer = FsInformation;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // Allocate the system buffer using an exception handler in case the
    // caller doesn't have enough quota remaining.
    //

    try {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to allocate the inter-
        // mediary buffer.  Cleanup and return with an appropriate error
        // status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();

    }

    irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                           IRP_DEALLOCATE_BUFFER |
                           IRP_INPUT_OPERATION |
                           IRP_DEFER_IO_COMPLETION);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryVolume.Length = Length;
    irpSp->Parameters.QueryVolume.FsInformationClass = FsInformationClass;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service changes information about the volume "mounted" on the device
    specified by the FileHandle parameter.  The information to be changed is
    in the FsInformation buffer.  Its contents are defined by the FsInformation-
    Class parameter, whose values may be as follows:

        o  FileFsLabelInformation

Arguments:

    FileHandle - Supplies a handle to the volume whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer containing the information which should
        be changed on the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        changed about the volume.

Return Value:

    The status returned is the final completion status of the operation.
    block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    PFILE_FS_LABEL_INFORMATION labelInformation;
    BOOLEAN synchronousIo;
    PDEVICE_OBJECT targetDeviceObject;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FsInformationClass parameter is legal for setting
        // information about the volume.
        //

        if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
            IopSetFsOperationLength[FsInformationClass] == 0) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Finally, ensure that the supplied buffer is large enough to contain
        // the information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopSetFsOperationLength[FsInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FsInformation buffer must be readable by the caller.
            //

#if defined(_X86_)
            ProbeForRead( FsInformation, Length, sizeof( ULONG ) );
#elif defined(_IA64_)
            // If we are a wow64 process, follow the X86 rules
            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForRead( FsInformation, Length, sizeof( ULONG ) );
            }
            else {
                ProbeForRead( FsInformation,
                              Length,
                              IopQuerySetFsAlignmentRequirement[FsInformationClass] );

            }
#else
            ProbeForRead( FsInformation,
                          Length,
                          IopQuerySetFsAlignmentRequirement[FsInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopSetFsOperationAccess[FsInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Retrieve the device object associated with this file handle.
    //
    
    status = IoGetRelatedTargetDevice( fileObject, &targetDeviceObject );

    if (NT_SUCCESS( status )) {
        //
        // The PDO associated with the devnode we got back from
        // IoGetRelatedTargetDevice has already been referenced by that
        // routine.  Store this reference away in the notification entry,
        // so we can deref it later when the notification entry is unregistered.
        //
    
        ASSERT(targetDeviceObject);
    
    } else {
        targetDeviceObject = NULL;
    }


    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  if this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                if (targetDeviceObject != NULL) {
                    ObDereferenceObject( targetDeviceObject );
                }
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            if (targetDeviceObject != NULL) {
                ObDereferenceObject( targetDeviceObject );
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (targetDeviceObject != NULL) {
            ObDereferenceObject( targetDeviceObject );
        }
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer and copy the information that is to be set on the
    // file into it.  Also, set the flags so that the completion code will
    // properly handle getting rid of the buffer and will not attempt to
    // copy data.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
        RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, FsInformation, Length );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to allocate the intermediary
        // buffer or while copying the caller's data to the buffer. Determine
        // what happened, cleanup, and return an appropriate error status
        // code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        if (targetDeviceObject != NULL) {
            ObDereferenceObject( targetDeviceObject );
        }
        
        return GetExceptionCode();

    }

    //
    // If the previous mode was not kernel, check the captured label buffer
    // for consistency.
    //

    if (requestorMode != KernelMode &&
        FsInformationClass == FileFsLabelInformation) {

        //
        // The previous mode was something other than kernel.  Check to see
        // whether or not the length of the label specified within the label
        // structure is consistent with the overall length of the structure
        // itself.  If not, then cleanup and get out.
        //

        labelInformation = (PFILE_FS_LABEL_INFORMATION) irp->AssociatedIrp.SystemBuffer;

        if ((LONG) labelInformation->VolumeLabelLength < 0 ||
            labelInformation->VolumeLabelLength +
            FIELD_OFFSET( FILE_FS_LABEL_INFORMATION, VolumeLabel ) > Length) {

            IopExceptionCleanup( fileObject,
                                 irp,
                                 (PKEVENT) NULL,
                                 event );

            if (targetDeviceObject != NULL) {
                ObDereferenceObject( targetDeviceObject );
            }
            
            return STATUS_INVALID_PARAMETER;
        }
    }

    irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetVolume.Length = Length;
    irpSp->Parameters.SetVolume.FsInformationClass = FsInformationClass;


    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    //
    //  Notify anyone who cares about the label change
    //

    if (targetDeviceObject != NULL) {
        if (NT_SUCCESS( status )) {
            TARGET_DEVICE_CUSTOM_NOTIFICATION ChangeEvent;
    
            ChangeEvent.Version = 1;
            ChangeEvent.FileObject = NULL;
            ChangeEvent.NameBufferOffset = -1;
            ChangeEvent.Size = (USHORT)FIELD_OFFSET( TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer );
            
            RtlCopyMemory( &ChangeEvent.Event, &GUID_IO_VOLUME_CHANGE, sizeof( GUID_IO_VOLUME_CHANGE ));
            
            IoReportTargetDeviceChange( targetDeviceObject, &ChangeEvent );
        }

        ObDereferenceObject( targetDeviceObject );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\qsinfo.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    qsinfo.c

Abstract:

    This module contains the code to implement the NtQueryInformationFile and
    NtSetInformationFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 6-Jun-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

//
// Create local definitions for long flag names to make code slightly more
// readable.
//

#define FSIO_A  FILE_SYNCHRONOUS_IO_ALERT
#define FSIO_NA FILE_SYNCHRONOUS_IO_NONALERT

//
// Forward declarations of local routines.
//

ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopGetModeInformation)
#pragma alloc_text(PAGE, NtQueryInformationFile)
#pragma alloc_text(PAGE, NtSetInformationFile)
#endif


ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This encapsulates extracting and translating the mode bits from
    the passed file object, to be returned from a query information call.

Arguments:

    FileObject - Specifies the file object for which to return Mode info.

Return Value:

    The translated mode information is returned.

--*/

{
    ULONG mode = 0;

    if (FileObject->Flags & FO_WRITE_THROUGH) {
        mode = FILE_WRITE_THROUGH;
    }
    if (FileObject->Flags & FO_SEQUENTIAL_ONLY) {
        mode |= FILE_SEQUENTIAL_ONLY;
    }
    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        mode |= FILE_NO_INTERMEDIATE_BUFFERING;
    }
    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        if (FileObject->Flags & FO_ALERTABLE_IO) {
            mode |= FILE_SYNCHRONOUS_IO_ALERT;
        } else {
            mode |= FILE_SYNCHRONOUS_IO_NONALERT;
        }
    }
    if (FileObject->Flags & FO_DELETE_ON_CLOSE) {
        mode |= FILE_DELETE_ON_CLOSE;
    }
    return mode;
}

NTSTATUS
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file about which the requested
        information should be returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus = {0};
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    BOOLEAN skipDriver;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FileInformationClass parameter is legal for querying
        // information about the file.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Ensure that the supplied buffer is large enough to contain the
        // information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FileInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FileInformation,
                               Length,
                               IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
#else
            ProbeForWrite( FileInformation,
                           Length,
                           IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters.  Simply return an appropriate error status
            // code.
            //


            return GetExceptionCode();
        }

#if DBG

    } else {

        //
        // The caller's mode is kernel.  Ensure that at least the information
        // class and lengths are appropriate.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

#endif // DBG

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopQueryOperationAccess[FileInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.  Also get the address of the Fast Io
    // dispatch structure.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to query the file position pointer.  If so, then
        // return it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested the current file position context
            // information.  This is a relatively frequent call, so it is
            // optimized here to cut through the normal IRP path.
            //
            // Begin by establishing a condition handler and attempting to
            // return both the file position information as well as the I/O
            // status block.  If writing the output buffer fails, then return
            // an appropriate error status code.  If writing the I/O status
            // block fails, then ignore the error.  This is what would
            // normally happen were everything to go through normal special
            // kernel APC processing.
            //

            BOOLEAN writingBuffer = TRUE;
            PFILE_POSITION_INFORMATION fileInformation = FileInformation;

            try {

                //
                // Return the current position information.
                //

                fileInformation->CurrentByteOffset = fileObject->CurrentByteOffset;
                writingBuffer = FALSE;

                //
                // Write the I/O status block.
                //

                IoStatusBlock->Status = STATUS_SUCCESS;
                IoStatusBlock->Information = sizeof( FILE_POSITION_INFORMATION );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // One of writing the caller's buffer or writing the I/O
                // status block failed.  Set the final status appropriately.
                //

                if (writingBuffer) {
                    status = GetExceptionCode();
                }

            }

            //
            // Note that the state of the event in the file object has not yet
            // been reset, so it need not be set either.  Therefore, simply
            // cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;

        //
        // Also do a special check if the caller it doing a query for basic or
        // standard information and if so then try the fast query calls if they
        // exist.
        //

        } else if (fastIoDispatch &&
                   (((FileInformationClass == FileBasicInformation) &&
                     fastIoDispatch->FastIoQueryBasicInfo) ||
                    ((FileInformationClass == FileStandardInformation) &&
                     fastIoDispatch->FastIoQueryStandardInfo))) {

            IO_STATUS_BLOCK localIoStatus;
            BOOLEAN queryResult = FALSE;
            BOOLEAN writingStatus = FALSE;

            //
            // Do the query and setting of the IoStatusBlock inside an exception
            // handler.  Note that if an exception occurs, other than writing
            // the status back, then the IRP route will be taken.  If an error
            // occurs attempting to write the status back to the caller's buffer
            // then it will be ignored, just as it would be on the long path.
            //

            try {

                if (FileInformationClass == FileBasicInformation) {
                    queryResult = fastIoDispatch->FastIoQueryBasicInfo( fileObject,
                                                                        TRUE,
                                                                        FileInformation,
                                                                        &localIoStatus,
                                                                        deviceObject );
                } else {
                    queryResult = fastIoDispatch->FastIoQueryStandardInfo( fileObject,
                                                                           TRUE,
                                                                           FileInformation,
                                                                           &localIoStatus,
                                                                           deviceObject );
                }

                if (queryResult) {
                    status = localIoStatus.Status;
                    writingStatus = TRUE;
                    *IoStatusBlock = localIoStatus;
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // If the result of the preceeding block is an exception that
                // occurred after the Fast I/O path itself, then the query
                // actually succeeded so everything is done already, but the
                // user's I/O status buffer is not writable.  This case is
                // ignored to be consistent w/the long path.
                //

                if (!writingStatus) {
                    status = GetExceptionCode();
                }
            }

            //
            // If the results of the preceeding statement block is true, then
            // the fast query call succeeeded, so simply cleanup and return.
            //

            if (queryResult) {

                //
                // Note that once again, the event in the file object has not
                // yet been set reset, so it need not be set to the Signaled
                // state, so simply cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer which should be used to put the information into by
    // the driver.  This will be copied back to the caller's buffer when the
    // service completes.  This is done by setting the flag which says that
    // this is an input operation.
    //

    irp->UserBuffer = FileInformation;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        //
        // Allocate the system buffer using an exception handler so that
        // errors can be caught and handled.
        //

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred by attempting to allocate the intermediary
        // system buffer.  Cleanup everything and return an appropriate error
        // status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();
    }

    irp->Flags |= IRP_BUFFERED_IO |
                  IRP_DEALLOCATE_BUFFER |
                  IRP_INPUT_OPERATION |
                  IRP_DEFER_IO_COMPLETION;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // is device independent.  If this is the case, then the request can
    // be satisfied here without having to have all of the drivers implement
    // the same code.  Note that having the IRP is still necessary since
    // the I/O completion code requires it.
    //

    skipDriver = FALSE;

    if (FileInformationClass == FileAccessInformation) {

        PFILE_ACCESS_INFORMATION accessBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the access information for this file.
        //

        accessBuffer->AccessFlags = handleInformation.GrantedAccess;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ACCESS_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the mode information for this file.
        //

        modeBuffer->Mode = IopGetModeInformation( fileObject );

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_MODE_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAlignmentInformation) {

        PFILE_ALIGNMENT_INFORMATION alignmentInformation = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the alignment information for this file.
        //

        alignmentInformation->AlignmentRequirement = deviceObject->AlignmentRequirement;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ALIGNMENT_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAllInformation) {

        PFILE_ALL_INFORMATION allInformation = irp->AssociatedIrp.SystemBuffer;

        //
        // The caller has requested all of the information about the file.
        // This request is handled specially because the service will fill
        // in the Access and Mode and Alignment information in the buffer
        // and then pass the buffer to the driver to fill in the remainder.
        //
        // Begin by returning the Access information for the file.
        //

        allInformation->AccessInformation.AccessFlags =
            handleInformation.GrantedAccess;

        //
        // Return the mode information for this file.
        //

        allInformation->ModeInformation.Mode =
            IopGetModeInformation( fileObject );

        //
        // Return the alignment information for this file.
        //

        allInformation->AlignmentInformation.AlignmentRequirement =
            deviceObject->AlignmentRequirement;

        //
        // Finally, set the information field of the IoStatus block in the IRP
        // to account for the amount information already filled in and invoke
        // the driver to fill in the remainder.
        //

        irp->IoStatus.Information = sizeof( FILE_ACCESS_INFORMATION ) +
                                    sizeof( FILE_MODE_INFORMATION ) +
                                    sizeof( FILE_ALIGNMENT_INFORMATION );
    }

    if (skipDriver) {

        //
        // The requested operation has already been performed.  Simply
        // set the final status in the packet and the return state.
        //

        status = STATUS_SUCCESS;
        irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        //
        // This is not a request that can be [completely] performed here, so
        // invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            requestorMode,
                                            (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists so that synchronization
                // with the file object will remain intact.
                //

                IopCancelAlertedRequest( &fileObject->Event, irp );

            }

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( event,
                                            Executive,
                                            requestorMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists or the event will not
                // be around to set to the Signaled state.
                //

                IopCancelAlertedRequest( event, irp );

            }

            status = localIoStatus.Status;

            try {

                *IoStatusBlock = localIoStatus;

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred attempting to write the caller's I/O
                // status block.  Simply change the final status of the operation
                // to the exception code.
                //

                status = GetExceptionCode();
            }

            ExFreePool( event );

        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
            ExFreePool( event );
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return status;
}

NTSTATUS
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the information which should
        be changed on the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        changed about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus = {0};
    HANDLE targetHandle = (HANDLE) NULL;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FileInformationClass parameter is legal for setting
        // information about the file.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopSetOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Ensure that the supplied buffer is large enough to contain the
        // information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FileInformation buffer must be readable by the caller.
            //

#if defined(_X86_)
            ProbeForRead( FileInformation,
                          Length,
                          Length == sizeof( BOOLEAN ) ? sizeof( BOOLEAN ) : sizeof( ULONG ) );
#elif defined(_WIN64)
            // If we are a wow64 process, follow the X86 rules
            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForRead( FileInformation,
                              Length,
                              Length == sizeof( BOOLEAN ) ? sizeof( BOOLEAN ) : sizeof( ULONG ) );
            }
            else {
                ProbeForRead( FileInformation,
                              Length,
                              IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
#else
            ProbeForRead( FileInformation,
                          Length,
                          IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();

        }

#if DBG

    } else {

        //
        // The caller's mode is kernel.  Ensure that at least the information
        // class and lengths are appropriate.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopSetOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

#endif // DBG

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopSetOperationAccess[FileInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to set the file position pointer information.  If so,
        // then set it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested setting the current file position
            // context information.  This is a relatively frequent call, so
            // it is optimized here to cut through the normal IRP path.
            //
            // Begin by checking to see whether the file was opened with no
            // intermediate buffering.  If so, then the file pointer must be
            // set in a manner consistent with the alignment requirement of
            // read and write operations to a non-buffered file.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;
            LARGE_INTEGER currentByteOffset;

            try {

                //
                // Attempt to read the position information from the buffer.
                //

                currentByteOffset.QuadPart = fileInformation->CurrentByteOffset.QuadPart;

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return GetExceptionCode();
            }

            if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING &&
                 (deviceObject->SectorSize &&
                 (currentByteOffset.LowPart &
                 (deviceObject->SectorSize - 1)))) ||
                 currentByteOffset.HighPart < 0) {

                    status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set the current file position information.
                //

                fileObject->CurrentByteOffset.QuadPart = currentByteOffset.QuadPart;

                try {

                    //
                    // Write the I/O status block.
                    //

                    IoStatusBlock->Status = STATUS_SUCCESS;
                    IoStatusBlock->Information = 0;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // Writes to I/O status blocks are ignored since the
                    // operation succeeded.
                    //

                    NOTHING;

                }

            }

            //
            // Update the transfer count statistic for the current process for
            // operations other than read and write.
            //
        
            IopUpdateOtherTransferCount( Length );

            //
            // Note that the file object's event has not yet been reset,
            // so it is not necessary to set it to the Signaled state, since
            // that is it's state at this point by definition.  Therefore,
            // simply cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // If a link is being tracked, handle this out-of-line.
    //

    if (FileInformationClass == FileTrackingInformation) {
        status = IopTrackLink( fileObject,
                               &localIoStatus,
                               FileInformation,
                               Length,
                               synchronousIo ? &fileObject->Event : event,
                               requestorMode );
        if (NT_SUCCESS( status )) {
            try {
                IoStatusBlock->Information = 0;
                IoStatusBlock->Status = status;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }
        }

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        } else {
            ExFreePool( event );
        }
        ObDereferenceObject( fileObject );
        return status;
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer and copy the information that is to be set on the
    // file into it.  Also, set the flags so that the completion code will
    // properly handle getting rid of the buffer and will not attempt to
    // copy data.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        PVOID systemBuffer;

        systemBuffer =
        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
        RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                       FileInformation,
                       Length );

        //
        //  Negative file offsets are illegal.
        //

        ASSERT((FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION, EndOfFile) |
                FIELD_OFFSET(FILE_ALLOCATION_INFORMATION, AllocationSize) |
                FIELD_OFFSET(FILE_POSITION_INFORMATION, CurrentByteOffset)) == 0);

        if (((FileInformationClass == FileEndOfFileInformation) ||
             (FileInformationClass == FileAllocationInformation) ||
             (FileInformationClass == FilePositionInformation)) &&
            (((PFILE_POSITION_INFORMATION)systemBuffer)->CurrentByteOffset.HighPart < 0)) {

            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }



    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while allocating the intermediary
        // system buffer or while copying the caller's data into the
        // buffer. Cleanup and return an appropriate error status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();

    }

    irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_DEFER_IO_COMPLETION;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();


    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // to set is device independent.  If this is the case, then the request
    // can be satisfied here without having to have all of the drivers
    // implement the same code.  Note that having the IRP is still necessary
    // since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Set the various flags in the mode field for the file object, if
        // they are reasonable.  There are 4 different invalid combinations
        // that the caller may not specify:
        //
        //     1)  An invalid flag was set in the mode field.  Not all Create/
        //         Open options may be changed.
        //
        //     2)  The caller set one of the synchronous I/O flags (alert or
        //         nonalert), but the file is not opened for synchronous I/O.
        //
        //     3)  The file is opened for synchronous I/O but the caller did
        //         not set either of the synchronous I/O flags (alert or non-
        //         alert).
        //
        //     4)  The caller set both of the synchronous I/O flags (alert and
        //         nonalert).
        //

        if ((modeBuffer->Mode & ~FILE_VALID_SET_FLAGS) ||
            ((modeBuffer->Mode & (FSIO_A | FSIO_NA)) && (!(fileObject->Flags & FO_SYNCHRONOUS_IO))) ||
            ((!(modeBuffer->Mode & (FSIO_A | FSIO_NA))) && (fileObject->Flags & FO_SYNCHRONOUS_IO)) ||
            (((modeBuffer->Mode & FSIO_A) && (modeBuffer->Mode & FSIO_NA) ))) {
            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Set or clear the appropriate flags in the file object.
            //

            if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {
                if (modeBuffer->Mode & FILE_WRITE_THROUGH) {
                    fileObject->Flags |= FO_WRITE_THROUGH;
                } else {
                    fileObject->Flags &= ~FO_WRITE_THROUGH;
                }
            }

            if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
                fileObject->Flags |= FO_SEQUENTIAL_ONLY;
            } else {
                fileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
            }

            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                if (modeBuffer->Mode & FSIO_A) {
                    fileObject->Flags |= FO_ALERTABLE_IO;
                } else {
                    fileObject->Flags &= ~FO_ALERTABLE_IO;
                }
            }

            status = STATUS_SUCCESS;
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0L;

    } else if (FileInformationClass == FileRenameInformation ||
               FileInformationClass == FileLinkInformation ||
               FileInformationClass == FileMoveClusterInformation) {

        //
        // Note that following code depends on the fact that the rename
        // information, link information and copy-on-write information
        // structures look exactly the same.
        //

        PFILE_RENAME_INFORMATION renameBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // The information being set is a variable-length structure with
        // embedded size information.  Walk the structure to ensure that
        // it is valid so the driver does not walk off the end and incur
        // an access violation in kernel mode.
        //
 
        if (renameBuffer->FileNameLength <= 0 || (renameBuffer->FileNameLength & (sizeof(WCHAR) -1))) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
        } else if ((ULONG) (Length - FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName[0] )) < renameBuffer->FileNameLength) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        } else {

            //
            // Copy the value of the replace BOOLEAN (or the ClusterCount field)
            // from the caller's buffer to the I/O stack location parameter
            // field where it is expected by file systems.
            //

            if (FileInformationClass == FileMoveClusterInformation) {
                irpSp->Parameters.SetFile.ClusterCount =
                    ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)->ClusterCount;
            } else {
                irpSp->Parameters.SetFile.ReplaceIfExists = renameBuffer->ReplaceIfExists;
            }

            //
            // Check to see whether or not a fully qualified pathname was
            // supplied.  If so, then more processing is required.
            //

            if (renameBuffer->FileName[0] == (WCHAR) OBJ_NAME_PATH_SEPARATOR ||
                renameBuffer->RootDirectory) {

                //
                // A fully qualified file name was specified as the target of
                // the rename operation.  Attempt to open the target file and
                // ensure that the replacement policy for the file is consistent
                // with the caller's request, and ensure that the file is on the
                // same volume.
                //

                status = IopOpenLinkOrRenameTarget( &targetHandle,
                                                    irp,
                                                    renameBuffer,
                                                    fileObject );
                if (!NT_SUCCESS( status )) {
                    irp->IoStatus.Status = status;

                } else {

                    //
                    // The fully qualified file name specifies a file on the
                    // same volume and if it exists, then the caller specified
                    // that it should be replaced.
                    //

                    status = IoCallDriver( deviceObject, irp );

                }

            } else {

                //
                // This is a simple rename operation, so call the driver and
                // let it perform the rename operation within the same directory
                // as the source file.
                //

                status = IoCallDriver( deviceObject, irp );

            }
        }

    } else if (FileInformationClass == FileShortNameInformation) {

        PFILE_NAME_INFORMATION shortnameBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // The information being set is a variable-length structure with
        // embedded size information.  Walk the structure to ensure that
        // it is valid so the driver does not walk off the end and incur
        // an access violation in kernel mode.
        //
 
        if (shortnameBuffer->FileNameLength <= 0) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
        } else if ((ULONG) (Length - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] )) < shortnameBuffer->FileNameLength) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        //
        // The short name must not begin with a separator character.
        //

        } else if (shortnameBuffer->FileName[0] == (WCHAR) OBJ_NAME_PATH_SEPARATOR) {

            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        //
        // Pass the request to the driver below.
        //

        } else {

            status = IoCallDriver( deviceObject, irp );
        }

    } else if (FileInformationClass == FileDispositionInformation) {

        PFILE_DISPOSITION_INFORMATION disposition = irp->AssociatedIrp.SystemBuffer;

        //
        // Check to see whether the disposition delete field has been set to
        // TRUE and, if so, copy the handle being used to do this to the IRP
        // stack location parameter.
        //

        if (disposition->DeleteFile) {
            irpSp->Parameters.SetFile.DeleteHandle = FileHandle;
        }

        //
        // Simply invoke the driver to perform the (un)delete operation.
        //

        status = IoCallDriver( deviceObject, irp );

    } else if (FileInformationClass == FileCompletionInformation) {

        PFILE_COMPLETION_INFORMATION completion = irp->AssociatedIrp.SystemBuffer;
        PIO_COMPLETION_CONTEXT context;
        PVOID portObject;

        //
        // It is an error if this file object already has an LPC port associated
        // with it.
        //

        if (fileObject->CompletionContext || fileObject->Flags & FO_SYNCHRONOUS_IO) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Attempt to reference the port object by its handle and convert it
            // into a pointer to the port object itself.
            //

            status = ObReferenceObjectByHandle( completion->Port,
                                                IO_COMPLETION_MODIFY_STATE,
                                                IoCompletionObjectType,
                                                requestorMode,
                                                (PVOID *) &portObject,
                                                NULL );
            if (NT_SUCCESS( status )) {

                //
                // Allocate the memory to be associated w/this file object
                //

                context = ExAllocatePoolWithTag( PagedPool,
                                                 sizeof( IO_COMPLETION_CONTEXT ),
                                                 'cCoI' );
                if (!context) {

                    ObDereferenceObject( portObject );
                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Everything was successful.  Capture the completion port
                    // and the key.
                    //

                    context->Port = portObject;
                    context->Key = completion->Key;

                    if (!InterlockedCompareExchangePointer( &fileObject->CompletionContext, context, NULL )) {

                        status = STATUS_SUCCESS;

                    } else {

                        //
                        // Someone set the completion context after the check.
                        // Simply drop everything on the floor and return an
                        // error.
                        //

                        ExFreePool( context );
                        ObDereferenceObject( portObject );
                        status = STATUS_PORT_ALREADY_SET;
                    }
                }
            }
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            requestorMode,
                                            (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists so that synchronization
                // with the file object will remain intact.
                //

                IopCancelAlertedRequest( &fileObject->Event, irp );

            }

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( event,
                                            Executive,
                                            requestorMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists or the event will not
                // be around to set to the Signaled state.
                //

                IopCancelAlertedRequest( event, irp );

            }

            status = localIoStatus.Status;

            try {

                *IoStatusBlock = localIoStatus;

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred attempting to write the caller's I/O
                // status block.  Simply change the final status of the
                // operation to the exception code.
                //

                status = GetExceptionCode();
            }

            ExFreePool( event );

        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
            ExFreePool( event );
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }

    }

    //
    // If there was a target handle generated because of a rename operation,
    // close it now.
    //

    if (targetHandle) {
        ObCloseHandle( targetHandle, KernelMode );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\query.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the subroutines to Query Device Descriptions from
    the Hardware tree in the registry

Author:

    Andre Vachon (andreva) 20-Jun-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

typedef struct _IO_QUERY_DESC {
    PINTERFACE_TYPE BusType;
    PULONG BusNumber;
    PCONFIGURATION_TYPE ControllerType;
    PULONG ControllerNumber;
    PCONFIGURATION_TYPE PeripheralType;
    PULONG PeripheralNumber;
    PIO_QUERY_DEVICE_ROUTINE CalloutRoutine;
    PVOID Context;
} IO_QUERY_DESC, *PIO_QUERY_DESC;


NTSTATUS
pIoQueryBusDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    PULONG BusNum,
    BOOLEAN HighKey
    );

NTSTATUS
pIoQueryDeviceDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    ULONG BusNum,
    PKEY_VALUE_FULL_INFORMATION *BusValueInfo
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoQueryDeviceDescription)
#pragma alloc_text(PAGE, pIoQueryBusDescription)
#pragma alloc_text(PAGE, pIoQueryDeviceDescription)
#endif




NTSTATUS
IoQueryDeviceDescription(
    IN PINTERFACE_TYPE BusType OPTIONAL,
    IN PULONG BusNumber OPTIONAL,
    IN PCONFIGURATION_TYPE ControllerType OPTIONAL,
    IN PULONG ControllerNumber OPTIONAL,
    IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,
    IN PULONG PeripheralNumber OPTIONAL,
    IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:

    BusType - Supplies an optional bus type being searched for in the
        description tree. Valid types are Mca, Isa, Eisa ... If no bus type
        is specified, the system information (i.e. machine BIOS) is returned.

    BusNumber - Supplies an optional value determining which bus should be
        queried.

    ControllerType - Supplies an optional controller type being searched for.
        If no Controller type is specified, only the Bus information is
        returned.

    ControllerNumber - Supplies an optional value determining which
        controller should be queried.

    PeripheralType - Supplies an optional peripheral type being searched for.
        If no Controller type is specified, only the Bus information and the
        controller information are returned.

    PeripheralNumber - Supplies an optional value determining which
        peripheral should be queried.

    CalloutRoutine - Supplies a pointer to a routine that gets called
       for each successful match of PeripheralType.

    Context - Supplies a context value that is passed back to the callback
        routine.

Return Value:

    The status returned is the final completion status of the operation.

Notes:

--*/

{

#define UNICODE_NUM_LENGTH 14
#define UNICODE_REGISTRY_PATH_LENGTH 1024

    IO_QUERY_DESC queryDesc;

    NTSTATUS status;
    UNICODE_STRING registryPathName;
    HANDLE rootHandle;
    ULONG busNumber = (ULONG) -1;


    PAGED_CODE();

    ASSERT( CalloutRoutine != NULL );

    //
    // Check if we need to return the machine information
    //

    if (!ARGUMENT_PRESENT( BusType )) {
        return STATUS_NOT_IMPLEMENTED;
    }

    queryDesc.BusType = BusType;
    queryDesc.BusNumber = BusNumber;
    queryDesc.ControllerType = ControllerType;
    queryDesc.ControllerNumber = ControllerNumber;
    queryDesc.PeripheralType = PeripheralType;
    queryDesc.PeripheralNumber = PeripheralNumber;
    queryDesc.CalloutRoutine = CalloutRoutine;
    queryDesc.Context = Context;


    //
    // Set up a string with the pathname to the hardware description
    // portion of the registry.
    //

    registryPathName.Length = 0;
    registryPathName.MaximumLength = UNICODE_REGISTRY_PATH_LENGTH *
                                     sizeof(WCHAR);

    registryPathName.Buffer = ExAllocatePoolWithTag( PagedPool,
                                                     UNICODE_REGISTRY_PATH_LENGTH,
                                                     'NRoI' );

    if (!registryPathName.Buffer) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlAppendUnicodeStringToString( &registryPathName,
                                    &CmRegistryMachineHardwareDescriptionSystemName );


    //
    // Open a handle to the root path we have.
    //

    status = IopOpenRegistryKey( &rootHandle,
                                 (HANDLE) NULL,
                                 &registryPathName,
                                 KEY_READ,
                                 FALSE );

    if (NT_SUCCESS( status )) {

        status = pIoQueryBusDescription(&queryDesc,
                                        registryPathName,
                                        rootHandle,
                                        &busNumber,
                                        TRUE );

        ZwClose( rootHandle );

    }

    ExFreePool( registryPathName.Buffer );

    //
    // For compatibility with old version of the function.
    //

    if (status == STATUS_NO_MORE_ENTRIES) {

        return STATUS_OBJECT_NAME_NOT_FOUND;


    } else {

        return status;

    }
}


NTSTATUS
pIoQueryBusDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    PULONG BusNum,
    BOOLEAN HighKey
    )

/*++

Routine Description:


Arguments:

    QueryDescription - Buffer containing all the query information requested
        by the driver.

    PathName - Registry path name of the key we are dealing with.  This is
        a unicode strig so that we don't have to bother with resetting NULLs
        at the end of the string - the length determines how much of the
        string is valid.

    RootHandle - Handle equivalent to the registry path.

    BusNum - Pointer to a variable that keeps track of the bus number we are
        searching for (buses have to be accumulated.

    HighKey - Determines is this is a high key (a root key with a list of
        bus types) or a low level key (under which the number of the various
        buses will be little).

Return Value:

    The status returned is the final completion status of the operation.

Notes:

--*/

{
    NTSTATUS status;
    ULONG i;
    UNICODE_STRING unicodeString;

    UNICODE_STRING registryPathName;

    ULONG keyBasicInformationSize;
    PKEY_BASIC_INFORMATION keyBasicInformation = NULL;
    HANDLE handle;

    PKEY_FULL_INFORMATION keyInformation;
    ULONG size;

    PKEY_VALUE_FULL_INFORMATION busValueInfo[IoQueryDeviceMaxData];


    PAGED_CODE();

    status = IopGetRegistryKeyInformation( RootHandle,
                                           &keyInformation );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // With the keyInformation, allocate a buffer that will be large
    // enough for all the subkeys
    //

    keyBasicInformationSize = keyInformation->MaxNameLen +
                              sizeof(KEY_NODE_INFORMATION);

    keyBasicInformation = ExAllocatePoolWithTag( PagedPool,
                                                 keyBasicInformationSize,
                                                 'BKoI' );

    ExFreePool(keyInformation);

    if (keyBasicInformation == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Now we need to enumerate the keys and see if one of them is a bus
    //

    for (i = 0; NT_SUCCESS( status ); i++) {


        //
        // If we have found the Bus we are looking for, break
        //

        if ((ARGUMENT_PRESENT( QueryDescription->BusNumber )) &&
            (*(QueryDescription->BusNumber) == *BusNum)) {

            break;

        }

        status = ZwEnumerateKey( RootHandle,
                                 i,
                                 KeyBasicInformation,
                                 keyBasicInformation,
                                 keyBasicInformationSize,
                                 &size );

        //
        // If the sub function enumerated all the buses till the end, then
        // treat that as success.
        //

        if (!NT_SUCCESS( status )) {

            break;

        }

        //
        // Only if this is a high key (otherwise we are in the callback
        // pass which we will process later on).
        //
        // If the string is any valid bus string, then we have to go down
        // the tree recursively.
        // Otherwise, go on to the next key.
        //

        if (HighKey) {

            if (wcsncmp( keyBasicInformation->Name,
                         CmTypeString[MultiFunctionAdapter],
                         keyBasicInformation->NameLength / sizeof(WCHAR) )  &&
                wcsncmp( keyBasicInformation->Name,
                         CmTypeString[EisaAdapter],
                         keyBasicInformation->NameLength / sizeof(WCHAR) )  &&
                wcsncmp( keyBasicInformation->Name,
                         CmTypeString[TcAdapter],
                         keyBasicInformation->NameLength / sizeof(WCHAR) )) {

                //
                // All the comparisons returned 1 (which means they all were
                // unsuccessful) so we do not have a bus.
                //
                // Go on to the next key.
                //

                continue;
            }
        }

        //
        // We have a bus. Open that key and enumerate it's clidren
        // (which should be numbers)
        //

        unicodeString.Buffer = keyBasicInformation->Name;
        unicodeString.Length = (USHORT) keyBasicInformation->NameLength;
        unicodeString.MaximumLength = (USHORT) keyBasicInformation->NameLength;

        if (!NT_SUCCESS( IopOpenRegistryKey( &handle,
                                             RootHandle,
                                             &unicodeString,
                                             KEY_READ,
                                             FALSE ) )) {

            //
            // The key could not be opened. Go to the next key
            //

            continue;

        }

        //
        // We have the key. now build the name for this path.
        //
        // Reset the string to its original value
        //

        registryPathName = PathName;

        RtlAppendUnicodeToString( &registryPathName,
                                  L"\\" );

        RtlAppendUnicodeStringToString( &registryPathName,
                                        &unicodeString );


        if (!HighKey) {

            //
            // We have a Key. Get the information for that key
            //

            status = IopGetRegistryValues( handle,
                                           &busValueInfo[0] );

            if (NT_SUCCESS( status )) {

                //
                // Verify that the identifier value for this bus
                // sub-key matches the user-specified bus type.
                // If not, do not increment the number of *found*
                // buses.
                //

                if (( busValueInfo[IoQueryDeviceConfigurationData] != NULL ) &&
                    ( busValueInfo[IoQueryDeviceConfigurationData]->DataLength != 0 ) &&
                    ( ((PCM_FULL_RESOURCE_DESCRIPTOR)
                        ((PCCHAR) busValueInfo[IoQueryDeviceConfigurationData] +
                        busValueInfo[IoQueryDeviceConfigurationData]->DataOffset))
                        ->InterfaceType == *(QueryDescription->BusType) )) {

                    //
                    // Increment the number of buses of desired type we
                    // have found.
                    //

                    (*BusNum)++;

                    //
                    // If we are looking for a specific bus number,
                    // check to see if we are at the right number.
                    // If we are not goto the next bus.  Otherwise
                    // (i.e we have the right bus number, or we
                    // specified all buses), then go on so the
                    // information can be reported.
                    //

                    if ( (QueryDescription->BusNumber == NULL) ||
                         (*(QueryDescription->BusNumber) == *BusNum) ) {


                        //
                        // If we want controller information, call
                        // the controller function.
                        // Otherwise just return the bus information.
                        //

                        if (QueryDescription->ControllerType != NULL) {

                            status = pIoQueryDeviceDescription(
                                         QueryDescription,
                                         registryPathName,
                                         handle,
                                         *BusNum,
                                         (PKEY_VALUE_FULL_INFORMATION *) busValueInfo );

                        } else {

                            status = QueryDescription->CalloutRoutine(
                                         QueryDescription->Context,
                                         &registryPathName,
                                         *(QueryDescription->BusType),
                                         *BusNum,
                                         (PKEY_VALUE_FULL_INFORMATION *) busValueInfo,
                                         0,
                                         0,
                                         NULL,
                                         0,
                                         0,
                                         NULL );

                        }
                    }
                }

                //
                // Free the pool allocated for the controller value data.
                //

                if (busValueInfo[0]) {
                    ExFreePool( busValueInfo[0] );
                    busValueInfo[0] = NULL;
                }
                if (busValueInfo[1]) {
                    ExFreePool( busValueInfo[1] );
                    busValueInfo[1] = NULL;
                }
                if (busValueInfo[2]) {
                    ExFreePool( busValueInfo[2] );
                    busValueInfo[2] = NULL;
                }

            }


            //
            // Shortcurt exit to avoid the recursive call.
            //

            if ((QueryDescription->BusNumber !=NULL ) &&
                (*(QueryDescription->BusNumber) == *BusNum)) {
                ZwClose( handle );
                handle = NULL;
                continue;

            }
        }

        //
        // If we have the key handle, do recursive enumeration.
        // enumaration (for both high and low keys)
        //

        status = pIoQueryBusDescription(
                     QueryDescription,
                     registryPathName,
                     handle,
                     BusNum,
                     (BOOLEAN)!HighKey );

        //
        // If the sub function enumerated all the buses till the end, then
        // treat that as success.
        //

        if (status == STATUS_NO_MORE_ENTRIES) {

            status = STATUS_SUCCESS;

        }

        ZwClose( handle );
        handle = NULL;

    }

    ASSERT (keyBasicInformation != NULL);

    ExFreePool( keyBasicInformation );

    return status;
}




NTSTATUS
pIoQueryDeviceDescription(
    PIO_QUERY_DESC QueryDescription,
    UNICODE_STRING PathName,
    HANDLE RootHandle,
    ULONG BusNum,
    PKEY_VALUE_FULL_INFORMATION *BusValueInfo
    )

{

    NTSTATUS status;
    UNICODE_STRING registryPathName = PathName;
    UNICODE_STRING controllerBackupRegistryPathName;
    UNICODE_STRING peripheralBackupRegistryPathName;
    HANDLE controllerHandle = NULL;
    HANDLE peripheralHandle = NULL;
    PKEY_FULL_INFORMATION controllerTypeInfo = NULL;
    PKEY_FULL_INFORMATION peripheralTypeInfo = NULL;
    ULONG maxControllerNum;
    ULONG maxPeripheralNum;
    ULONG controllerNum;
    ULONG peripheralNum;
    WCHAR numBuffer[UNICODE_NUM_LENGTH];
    UNICODE_STRING bufferUnicodeString;
    PKEY_VALUE_FULL_INFORMATION controllerValueInfo[IoQueryDeviceMaxData];
    PKEY_VALUE_FULL_INFORMATION peripheralValueInfo[IoQueryDeviceMaxData];

    UNREFERENCED_PARAMETER (RootHandle);

    //
    // Set up a string for the number translation.
    //

    bufferUnicodeString.MaximumLength = UNICODE_NUM_LENGTH * sizeof(WCHAR);
    bufferUnicodeString.Buffer = &numBuffer[0];


    //         For each controller of the specified type (subkeys 0..M)
    //             if we are looking for controller information
    //                 call the specified callout routine
    //             else
    //                 For each peripheral of the specified type (subkeys 0..N)
    //                     call the specified callout routine

    //
    // Add the controller name to the registry path name.
    //

    status = RtlAppendUnicodeToString( &registryPathName,
                                       L"\\" );

    if (NT_SUCCESS( status )) {

        status = RtlAppendUnicodeToString( &registryPathName,
                                           CmTypeString[*(QueryDescription->ControllerType)] );

    }

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If a Contoller number was specified by the caller, use that
    // controller number. Otherwise, find out how many buses are present
    // by querying the key.
    //

    if (ARGUMENT_PRESENT( QueryDescription->ControllerNumber )) {

        controllerNum = *(QueryDescription->ControllerNumber);
        maxControllerNum = controllerNum + 1;

    } else {

        //
        // Open the registry key for the controller and
        // Get the full key information for the controller key to
        // determine the number of sub-keys (controller numbers).
        // And we fail, then go on to the next bus.
        // Note the memory allocated by the query must be freed.
        //

        status = IopOpenRegistryKey( &controllerHandle,
                                     (HANDLE) NULL,
                                     &registryPathName,
                                     KEY_READ,
                                     FALSE );

        if (NT_SUCCESS( status )) {

            status = IopGetRegistryKeyInformation( controllerHandle,
                                                   &controllerTypeInfo );

            ZwClose( controllerHandle );
            controllerHandle = NULL;
        }

        //
        // If no controller of this type was found on the bus, go on to
        // the next bus; goto the end of the loop with a successful status
        // so that the memory gets freed, but we continue looping.
        //

        if (!NT_SUCCESS( status )) {

            return status;

        }

        //
        // Get the number of controller sub-keys for this controller
        // type and free the pool.
        //

        maxControllerNum = controllerTypeInfo->SubKeys;
        controllerNum = 0;

        ExFreePool( controllerTypeInfo );
        controllerTypeInfo = NULL;
    }

    //
    // Make a backup of the string since we want to start where we were
    // on the next loop iteration.
    //

    controllerBackupRegistryPathName = registryPathName;

    //
    // For each controller of the specified type (subkeys 0..M).
    // We use BusNumber as the initial value since it is zero if we want
    // all buses, and we only want the bus specified if the value  is not
    // zero.
    //

    for ( ; controllerNum < maxControllerNum; controllerNum++) {

        //
        // Reset the string to its original value
        //

        registryPathName = controllerBackupRegistryPathName;

        //
        // Convert the controller number to a unicode string and append
        // it to the registry path name.
        //

        bufferUnicodeString.Length = (UNICODE_NUM_LENGTH-1) * sizeof(WCHAR);
        status = RtlIntegerToUnicodeString( controllerNum,
                                            10,
                                            &bufferUnicodeString );

        if (NT_SUCCESS( status )) {

            status = RtlAppendUnicodeToString( &registryPathName,
                                               L"\\" );

            if (NT_SUCCESS( status )) {

                status = RtlAppendUnicodeStringToString(
                                                     &registryPathName,
                                                     &bufferUnicodeString );

            }
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

        //
        // Open the registry key for the controller number and
        // Get the value data for this controller and save it for later.
        //


        status = IopOpenRegistryKey( &controllerHandle,
                                     (HANDLE) NULL,
                                     &registryPathName,
                                     KEY_READ,
                                     FALSE );

        if (NT_SUCCESS( status )) {

            status = IopGetRegistryValues( controllerHandle,
                                           &controllerValueInfo[0] );

            ZwClose( controllerHandle );
            controllerHandle = NULL;
        }

        //
        // If we could not open the key and get the info, just continue
        // since there is no memory to free and we are using the for
        // loop to determine when we get to the last controller.
        //

        if (!NT_SUCCESS( status )) {
            continue;
        }

        //
        // Check if we want the controller and bus information only. If
        // it is the case, invoque the callout routine and go on to the
        // next loop (unless an error occurs in the callout).
        //

        if (!ARGUMENT_PRESENT( (QueryDescription->PeripheralType) )) {

            status = QueryDescription->CalloutRoutine(
                         QueryDescription->Context,
                         &registryPathName,
                         *(QueryDescription->BusType),
                         BusNum,
                         BusValueInfo,
                         *(QueryDescription->ControllerType),
                         controllerNum,
                         (PKEY_VALUE_FULL_INFORMATION *) controllerValueInfo,
                         0,
                         0,
                         NULL );

            goto IoQueryDeviceControllerLoop;
        }

        //
        // Add the peripheral name to the registry path name.
        //

        status = RtlAppendUnicodeToString( &registryPathName,
                                           L"\\" );

        if (NT_SUCCESS( status )) {

            status = RtlAppendUnicodeToString(
                                             &registryPathName,
                                             CmTypeString[*(QueryDescription->PeripheralType)] );

        }

        if (!NT_SUCCESS( status )) {
            goto IoQueryDeviceControllerLoop;
        }

        //
        // If a Peripheralnumber was specified by the caller, use that
        // peripheral number. Otherwise, find out how many buses are
        // present by querying the key.
        //

        if (ARGUMENT_PRESENT( (QueryDescription->PeripheralNumber) )) {

            peripheralNum = *(QueryDescription->PeripheralNumber);
            maxPeripheralNum = peripheralNum + 1;

        } else {

            //
            // Open the registry key for the peripheral and
            // Get the full key information for the peripheral key to
            // determine the number of sub-keys (peripheral numbers).
            // And we fail, then go on to the next controller.
            // Note the memory allocated by the query must be freed.
            //

            status = IopOpenRegistryKey( &peripheralHandle,
                                         (HANDLE) NULL,
                                         &registryPathName,
                     KEY_READ,
                     FALSE );

            if (NT_SUCCESS( status )) {

                status = IopGetRegistryKeyInformation( peripheralHandle,
                           &peripheralTypeInfo );

                ZwClose( peripheralHandle );
                peripheralHandle = NULL;
            }

            //
            // If no controller of this type was found on the bus, go on to
            // the next bus; goto the end of the loop with a successful
            // status so that the memory gets freed, but we continue looping.
            //

            if (!NT_SUCCESS( status )) {
                status = STATUS_SUCCESS;
                goto IoQueryDeviceControllerLoop;
            }

            //
            // Get the number of peripheral sub-keys for this peripheral
            // type and free the pool.
            //

            maxPeripheralNum = peripheralTypeInfo->SubKeys;
            peripheralNum = 0;

            ExFreePool( peripheralTypeInfo );
            peripheralTypeInfo = NULL;
        }

        //
        // Make a backup of the string since we want to start where we
        // were on the next loop iteration.
        //

        peripheralBackupRegistryPathName = registryPathName;

        //
        // For each peripheral of the specified type (subkeys 0..N).
        // We use BusNumber as the initial value since it is zero if we
        // want all buses, and we only want the bus specified if the
        // value is not zero.
        //

        for ( ; peripheralNum < maxPeripheralNum; peripheralNum++) {

            //
            // Reset the string to its original value.
            //

            registryPathName = peripheralBackupRegistryPathName;

            //
            // Convert the peripheral number to a unicode string and append
            // it to the registry path name.
            //

            bufferUnicodeString.Length =
                (UNICODE_NUM_LENGTH-1) * sizeof(WCHAR);
            status = RtlIntegerToUnicodeString( peripheralNum,
                                                10,
                                                &bufferUnicodeString );

            if (NT_SUCCESS( status )) {

                status = RtlAppendUnicodeToString( &registryPathName,
                                                   L"\\" );

                if (NT_SUCCESS( status )) {

                    status = RtlAppendUnicodeStringToString(
                                                     &registryPathName,
                                                     &bufferUnicodeString );

                }
            }

            if (!NT_SUCCESS( status )) {
                break;
            }

            //
            // Open the registry key for the peripheral number and
            // Get the value data for this peripheral and save it for
            // later.
            //

            status = IopOpenRegistryKey( &peripheralHandle,
                                         (HANDLE) NULL,
                                         &registryPathName,
                                         KEY_READ,
                                         FALSE );

            if (NT_SUCCESS( status )) {

                status = IopGetRegistryValues( peripheralHandle,
                                               &peripheralValueInfo[0] );

                ZwClose( peripheralHandle );
                peripheralHandle = NULL;
            }

            //
            // If getting the peripheral information worked properly,
            // call the user-specified callout routine.
            //

            if (NT_SUCCESS( status )) {

                status = QueryDescription->CalloutRoutine(
                             QueryDescription->Context,
                             &registryPathName,
                             *(QueryDescription->BusType),
                             BusNum,
                             BusValueInfo,
                             *(QueryDescription->ControllerType),
                             controllerNum,
                             (PKEY_VALUE_FULL_INFORMATION *) controllerValueInfo,
                             *(QueryDescription->PeripheralType),
                             peripheralNum,
                             (PKEY_VALUE_FULL_INFORMATION *) peripheralValueInfo );

                //
                // Free the pool allocated for the peripheral value data.
                //

                if (peripheralValueInfo[0]) {
                    ExFreePool( peripheralValueInfo[0] );
                    peripheralValueInfo[0] = NULL;
                }
                if (peripheralValueInfo[1]) {
                    ExFreePool( peripheralValueInfo[1] );
                    peripheralValueInfo[1] = NULL;
                }
                if (peripheralValueInfo[2]) {
                    ExFreePool( peripheralValueInfo[2] );
                    peripheralValueInfo[2] = NULL;
                }

                //
                // If the user-specified callout routine returned with
                // an unsuccessful status, quit.
                //

                if (!NT_SUCCESS( status )) {
                    break;
               }
            }

        } // for ( ; peripheralNum < maxPeripheralNum ...

IoQueryDeviceControllerLoop:

        //
        // Free the pool allocated for the controller value data.
        //

        if (controllerValueInfo[0]) {
            ExFreePool( controllerValueInfo[0] );
            controllerValueInfo[0] = NULL;
        }
        if (controllerValueInfo[1]) {
            ExFreePool( controllerValueInfo[1] );
            controllerValueInfo[1] = NULL;
        }
        if (controllerValueInfo[2]) {
            ExFreePool( controllerValueInfo[2] );
            controllerValueInfo[2] = NULL;
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

    } // for ( ; controllerNum < maxControllerNum...


    return( status );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=io

TARGETNAME=iomgr
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosiomgr$(NT_UP)

INCLUDES=..;..\..;\
         ..\..\..\inc;\
         $(DDK_INC_PATH);\
         $(NET_INC_PATH);\
         $(SDKTOOLS_INC_PATH);\
         $(HALKIT_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES= \
        ..\arcsec.c \
        ..\cancelapi.c \
        ..\complete.c \
        ..\create.c   \
        ..\devctrl.c  \
        ..\dev2dos.c \
        ..\dumpctl.c \
        ..\dir.c      \
        ..\errorlog.c \
        ..\fsctrl.c   \
        ..\internal.c \
        ..\iodata.c   \
        ..\ioinit.c   \
        ..\iosubs.c   \
        ..\ioverifier.c \
        ..\ioPerf.c \
        ..\loadunld.c \
        ..\lock.c     \
        ..\misc.c     \
        ..\objsup.c   \
        ..\open.c     \
        ..\parse.c    \
        ..\qsea.c     \
        ..\qsfs.c     \
        ..\qsinfo.c   \
        ..\qsquota.c  \
        ..\query.c \
        ..\read.c     \
        ..\triage.c \
        ..\write.c

NTTEST=
OPTIONAL_NTTEST=tio

PRECOMPILED_INCLUDE=..\iomgr.h
PRECOMPILED_PCH=iomgr.pch
PRECOMPILED_OBJ=iomgr.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\read.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code to implement the NtReadFile system service.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
const KPRIORITY IopCacheHitIncrement = IO_NO_INCREMENT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtReadFile)
#pragma alloc_text(PAGE, NtReadFileScatter)
#endif

NTSTATUS
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    Buffer.  If the end of the file is reached before Length bytes have
    been read, then the operation will terminate.  The actual length of
    the data read from the file will be returned in the second longword
    of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Address of buffer to receive the data read from the file.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS exceptionCode;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        exceptionCode = STATUS_SUCCESS;

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx(IoStatusBlock , ApcRoutine);

            //
            // The caller's data buffer must be writable from the caller's
            // mode.  This check ensures that this is the case.  Since the
            // buffer address is captured, the caller cannot change it,
            // even though he/she can change the protection from another
            // thread.  This error will be caught by the probe/lock or
            // buffer copy operations later.
            //

            ProbeForWrite( Buffer, Length, sizeof( UCHAR ) );

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Also ensure that the ByteOffset parameter is readable from
            // the caller's mode and capture it if it is present.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following Buffer
            // and ByteOffset parameter checks differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1))) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ||
                        (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it
                // is a valid argument.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the same parameters that are
        // required from any other mode.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }

#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the Buffer is properly aligned, and that the
            // length is an integral number of the block size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1))) ||
                (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it
            // is a valid argument.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the driver object's Fast I/O dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        //
        // Turbo read support.  If the file is currently cached on this
        // file object, then call the Cache Manager directly via FastIoRead
        // and try to successfully complete the request here.  Note if
        // FastIoRead returns FALSE or we get an I/O error, we simply
        // fall through and go the "long way" and create an Irp.
        //

        if (fileObject->PrivateCacheMap) {

            IO_STATUS_BLOCK localIoStatus;

            ASSERT(fastIoDispatch && fastIoDispatch->FastIoRead);

            //
            //  Negative file offsets are illegal.
            //

            if (fileOffset.HighPart < 0) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            if (fastIoDispatch->FastIoRead( fileObject,
                                            &fileOffset,
                                            Length,
                                            TRUE,
                                            keyValue,
                                            Buffer,
                                            &localIoStatus,
                                            deviceObject )

                    &&

                ((localIoStatus.Status == STATUS_SUCCESS) ||
                 (localIoStatus.Status == STATUS_BUFFER_OVERFLOW) ||
                 (localIoStatus.Status == STATUS_END_OF_FILE))) {

                //
                // Boost the priority of the current thread so that it appears
                // as if it just did I/O.  This causes background jobs that
                // get cache hits to be more responsive in terms of getting
                // more CPU time.
                //

                if (IopCacheHitIncrement) {
                    KeBoostPriorityThread( &CurrentThread->Tcb,
                                           IopCacheHitIncrement );
                }

                //
                // Carefully return the I/O status.
                //

                IopUpdateReadOperationCount( );
                IopUpdateReadTransferCount( (ULONG)localIoStatus.Information );

                try {
                    *IoStatusBlock = localIoStatus;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.
                //

                //
                // Cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );

                return localIoStatus.Status;
            }
        }
        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the driver's data will be copied into it.  Otherwise, a
    // Memory Descriptor List (MDL) is allocated and the caller's buffer is
    // locked down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer
        // and specify that it should be deallocated on completion.  Also
        // indicate that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception handler
        // that will perform cleanup if the operation fails.  Note that this
        // is only done if the operation has a non-zero length.
        //

        if (Length) {

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool
                // and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPoolCacheAligned, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the system buffer.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can take
            // place during I/O completion.  Also, set the flags so that the
            // completion code knows to do the copy and to deallocate the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags = IRP_BUFFERED_IO |
                         IRP_DEALLOCATE_BUFFER |
                         IRP_INPUT_OPERATION;

        } else {

            //
            // This is a zero-length read.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;

        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

        PMDL mdl;

        irp->Flags = 0;

        if (Length) {

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for write access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually
                // happened, clean everything up, and return an appropriate
                // error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->Flags = 0;
        irp->UserBuffer = Buffer;
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.Key = keyValue;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         requestorMode,
                                         synchronousIo,
                                         ReadTransfer );

    return status;
}

NTSTATUS
NtReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    buffer segments.  The buffer segments are not virtually contiguous,
    but are 8 KB in length and alignment. If the end of the file is reached
    before Length bytes have been read, then the operation will terminate.
    The actual length of the data read from the file will be returned in
    the second longword of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Unused the I/O must use a completion port.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be placed.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

    Key - Unused.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:

    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFILE_SEGMENT_ELEMENT capturedArray = NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS exceptionCode;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    ULONG i;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //
    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Verify this is a valid scatter read request.  In particular it must be
    // non cached, asynchronous, use completion ports, non buffer I/O device
    // and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (fileObject->Flags & FO_SYNCHRONOUS_IO) ||
        deviceObject->Flags & DO_BUFFERED_IO ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME )) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES(Length);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        exceptionCode = STATUS_SUCCESS;

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Also ensure that the ByteOffset parameter is readable from
            // the caller's mode and capture it if it is present.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following ByteOffset
            // parameter check differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1)))) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize)) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it
                // is a valid argument.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // The SegmentArray paramter must be accessible.
            //

#ifdef _X86_
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          sizeof( ULONG )
                          );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcess()->Wow64Process) {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              sizeof( ULONG )
                              );
            } else {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                              );
            }
#else
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                          );
#endif

            if (Length != 0) {

                //
                // Capture the segment array so it cannot be changed after
                // it has been looked at.
                //

                capturedArray = ExAllocatePoolWithQuota( PagedPool,
                                                elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                                                );

                RtlCopyMemory( capturedArray,
                               SegmentArray,
                               elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                               );

                SegmentArray = capturedArray;

                //
                // Verify that all the addresses are page aligned.
                //

                for (i = 0; i < elementCount; i++) {

                    if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the same parameters that are
        // required from any other mode.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }

#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the the length is an integral number of the block
            //  size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1)))) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize)) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it
            // is a valid argument.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        if (Length != 0) {

            //
            // Verify that all the addresses are page aligned.
            //

            for (i = 0; i < elementCount; i++) {

                if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {

                    ObDereferenceObject( fileObject );
                    ASSERT(FALSE);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the driver object's Fast I/O dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                if (capturedArray != NULL) {
                    ExFreePool( capturedArray );
                }
                return status;
            }
        }

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Always allocate a Memory Descriptor List (MDL) and lock down the
    // caller's buffer. This way the file system do not have change to
    // build a scatter MDL. Note buffered I/O is not supported for this
    // routine.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;


    //
    // This is a direct I/O operation.  Allocate an MDL and invoke the
    // memory management routine to lock the buffer into memory.  This
    // is done using an exception handler that will perform cleanup if
    // the operation fails.  Note that no MDL is allocated, nor is any
    // memory probed or locked if the length of the request was zero.
    //

    irp->Flags = 0;

    if (Length) {

        PMDL mdl;

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of
            // the IRP.  Probe and lock the pages associated with the
            // caller's buffer for write access and fill in the MDL with
            // the PFNs of those pages.
            //

            mdl = IoAllocateMdl( (PVOID)(ULONG_PTR) SegmentArray[0].Buffer, Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // The address of the first file segment is used as a base
            // address.
            //

            MmProbeAndLockSelectedPages( mdl,
                                         SegmentArray,
                                         requestorMode,
                                         IoWriteAccess );

            irp->UserBuffer = (PVOID)(ULONG_PTR) SegmentArray[0].Buffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either probing the caller's
            // buffer or allocating the MDL.  Determine what actually
            // happened, clean everything up, and return an appropriate
            // error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return GetExceptionCode();

        }

    }

    //
    // We are done with the captured buffer.
    //

    if (capturedArray != NULL) {
        ExFreePool( capturedArray );
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.Key = keyValue;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         requestorMode,
                                         synchronousIo,
                                         ReadTransfer );

    return status;

}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\qsquota.c ===
/*++

Copyright (c) 1989 - 1995  Microsoft Corporation

Module Name:

    qsquota.c

Abstract:

    This module contains the code to implement the NtQueryQuotaInformationFile
    and the NtSetQuotaInformationFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 20-Jun-1995

Environment:

    Kernel mode only

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtQueryQuotaInformationFile)
#pragma alloc_text(PAGE, NtSetQuotaInformationFile)
#endif

NTSTATUS
NtQueryQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID SidList OPTIONAL,
    IN ULONG SidListLength,
    IN PULONG StartSid OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service returns quota entries associated with the volume specified
    by the FileHandle parameter.  The amount of information returned is based
    on the size of the quota information associated with the volume, the size
    of the buffer, and whether or not a specific set of entries has been
    requested.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the quota
        information is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the quota information for the volume.

    Length - Supplies the length, in bytes, of the buffer.

    ReturnSingleEntry - Indicates that only a single entry should be returned
        rather than filling the buffer with as many entries as possible.

    SidList - Optionally supplies a list of SIDs whose quota information is to
        be returned.

    SidListLength - Supplies the length of the SID list, if one was specified.

    StartSid - Supplies an optional SID that indicates that the returned
        information is to start with an entry other than the first.  This
        parameter is ignored if a SidList is specified.

    RestartScan - Indicates whether the scan of the quota information is to be
        restarted from the beginning.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{

#define ALIGN_LONG( Address ) ( (Address + 3) & ~3 )

    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    ULONG startSidLength = 0;
    PSID startSid = (PSID) NULL;
    PFILE_GET_QUOTA_INFORMATION sidList = (PFILE_GET_QUOTA_INFORMATION) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    UCHAR subCount;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( Buffer, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( Buffer, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( Buffer, Length, sizeof( ULONGLONG ) );
            }
#else
            ProbeForWrite( Buffer, Length, sizeof( ULONGLONG ) );
#endif

            //
            // If the optional StartSid parameter was specified, then it must
            // be readable by the caller.  Begin by capturing the length of
            // the SID so that the SID itself can be captured.
            //

            if (ARGUMENT_PRESENT( StartSid )) {

                subCount = ProbeAndReadUchar( &(((SID *)(StartSid))->SubAuthorityCount) );
                startSidLength = RtlLengthRequiredSid( subCount );
                ProbeForRead( StartSid, startSidLength, sizeof( ULONG ) );
            }
            else {
                subCount = 0;
            }

            //
            // If the optional SidList parameter was specified, then it must
            // be readable by the caller.  Validate that the buffer contains
            // a legal get information structure.
            //

            if (ARGUMENT_PRESENT( SidList ) && SidListLength) {

                ProbeForRead( SidList, SidListLength, sizeof( ULONG ) );
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           ALIGN_LONG( SidListLength ) +
                                                           startSidLength );
                sidList = (PFILE_GET_QUOTA_INFORMATION) auxiliaryBuffer;

                RtlCopyMemory( auxiliaryBuffer, SidList, SidListLength );

            } else {

                //
                // No SidList was specified.  Check to see whether or not a
                // StartSid was specified and, if so, capture it.  Note that
                // the SID has already been probed.
                //

                SidListLength = 0;
                if (ARGUMENT_PRESENT( StartSid )) {
                    auxiliaryBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                               startSidLength );
                }
            }

            //
            // If a StartSid was specified tack it onto the end of the auxiliary
            // buffer.
            //

            if (ARGUMENT_PRESENT( StartSid )) {
                startSid = (PSID) (auxiliaryBuffer + ALIGN_LONG( SidListLength ));

                RtlCopyMemory( startSid, StartSid, startSidLength );
                ((SID *) startSid)->SubAuthorityCount = subCount;
            }


        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters, allocating the pool buffer, or copying the
            // caller's EA list to the buffer.  Cleanup and return an
            // appropriate error status code.
            //

            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was KernelMode.  Simply allocate pool for the
        // SidList, if one was specified, and copy the string to it.  Also,
        // if a StartSid was specified copy it as well.
        //

        if (ARGUMENT_PRESENT( SidList ) && SidListLength) {
            sidList = SidList;
        }

        if (ARGUMENT_PRESENT( StartSid )) {
            startSid = StartSid;
        }
    }

    //
    // Always check the validity of the buffer since the server uses this 
    // routine.
    //

    if (sidList != NULL) {

        ULONG_PTR   errorOffset = 0;

        status = IopCheckGetQuotaBufferValidity( sidList,
                                                 SidListLength,
                                                 (PULONG_PTR)&errorOffset );

        if (!NT_SUCCESS( status )) {

            try {

                IoStatusBlock->Information = errorOffset;

            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }
            return status;
        }
    }

    if (startSid != NULL) {

        if (!RtlValidSid( startSid )) {
            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }
            return STATUS_INVALID_SID;
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (!event) {
            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_QUOTA;
    irpSp->FileObject = fileObject;

    //
    // If the caller specified an SID list of names to be queried, then pass
    // the address of the intermediary buffer containing the list to the
    // driver.
    //

    irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
    irpSp->Parameters.QueryQuota.SidList = sidList;
    irpSp->Parameters.QueryQuota.SidListLength = SidListLength;

    //
    // Now determine whether this driver expects to have data buffered
    // to it or whether it performs direct I/O.  This is based on the
    // DO_BUFFERED_IO flag in the device object.  If the flag is set,
    // then a system buffer is allocated and the driver's data will be
    // copied to it.  If the DO_DIRECT_IO flag is set in the device
    // object, then a Memory Descriptor List (MDL) is allocated and
    // the caller's buffer is locked down using it.  Finally, if the
    // driver specifies neither of the flags, then simply pass the
    // address and length of the buffer and allow the driver to perform
    // all of the checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The driver wishes the caller's buffered be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also indicate
        // that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception
        // handler that will perform cleanup if the operation fails.
        //

        if (Length) {
            try {

                //
                // Allocate the intermediary system buffer from nonpaged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPool, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the system buffer.
                // Determine what actually happened, clean everything
                // up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();
            }

            //
            // Remember the address of the caller's buffer so the copy can
            // take place during I/O completion.  Also, set the flags so
            // that the completion code knows to do the copy and to deallocate
            // the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                                   IRP_DEALLOCATE_BUFFER |
                                   IRP_INPUT_OPERATION);
        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->UserBuffer = Buffer;
        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke
        // the memory management routine to lock the buffer into memory.
        // This is done using an exception handler that will perform
        // cleanup if the operation fails.
        //

        mdl = (PMDL) NULL;

        if (Length) {
            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off
                // of the IRP.  Probe and lock the pages associated with
                // the caller's buffer for write access and fill in the MDL
                // with the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (!mdl) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the MDL.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access
        // to it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryQuota.Length = Length;
    irpSp->Parameters.QueryQuota.StartSid = StartSid;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }
    if (ARGUMENT_PRESENT( StartSid )) {
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This service changes quota entries for the volume associated with the
    FileHandle parameter.  All of the quota entries in the specified buffer
    are applied to the volume.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the quota
        entries are to be applied.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer containing the new quota entries that should
        be applied to the volume.

    Length - Supplies the length, in bytes, of the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply return the status from the internal common routine for setting
    // EAs on a file or quotas on a volume.
    //

    return IopSetEaOrQuotaInformationFile( FileHandle,
                                           IoStatusBlock,
                                           Buffer,
                                           Length,
                                           FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\triage.c ===
/*++

Copyright(c) 1999 Microsoft Corporation

Module Name:

    triage.c

Abstract:

    Triage dump support.

Author:

    Matthew D. Hendel (math) 20-Jan-1999

Comments:

    Do not merge this file with some other file. By leaving it in its own
    compiland, we avoid having to link with all the other random variables
    in crashlib.


--*/

#include "iomgr.h"
#include "dumpctl.h"
#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <stdio.h>
#include <malloc.h>
#include <triage.h>
#include <ntverp.h>


#ifndef NtBuildNumber
#  if DBG
#    define NtBuildNumber   (VER_PRODUCTBUILD | 0xC0000000)
#  else
#    define NtBuildNumber (VER_PRODUCTBUILD | 0xF0000000)
# endif
#endif


//
// NOTE: Pages sizes copied from ntos\inc. These must be kept in sync with
// global header files.
//

#define PAGE_SIZE_I386      0x1000
#define PAGE_SIZE_AMD64     0x1000
#define PAGE_SIZE_IA64      0x2000


ULONG TriageImagePageSize = (ULONG) -1;

BOOLEAN
TriagepVerifyDump(
    IN LPVOID TriageDumpBlock
    );

ULONG
TriagepGetPageSize(
    ULONG Architecture
    );

PTRIAGE_DUMP
TriagepGetTriagePointer(
    IN PVOID TriageDumpBlock
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text (INIT, TriagepVerifyDump)
#pragma alloc_text (INIT, TriagepGetPageSize)
#pragma alloc_text (INIT, TriagepGetTriagePointer)

#pragma alloc_text (INIT, TriageGetVersion)
#pragma alloc_text (INIT, TriageGetDriverCount)
#pragma alloc_text (INIT, TriageGetContext)
#pragma alloc_text (INIT, TriageGetExceptionRecord)
#pragma alloc_text (INIT, TriageGetBugcheckData)
#pragma alloc_text (INIT, TriageGetDriverEntry)

#endif


//++
//
// PULONG
// IndexByUlong(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index ULONGs into Pointer. That is,
//     Index * sizeof (ULONG) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of ULONGs to index into.
//
// Return Value:
//
//     PULONG representing the pointer described above.
//
//--

#define IndexByUlong(Pointer,Index) (&(((ULONG*) (Pointer)) [Index]))


//++
//
// PBYTE
// IndexByByte(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index BYTEs into Pointer. That is,
//     Index * sizeof (BYTE) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of BYTEs to index into.
//
// Return Value:
//
//     PBYTE representing the pointer described above.
//
//--

#define IndexByByte(Pointer, Index) (&(((BYTE*) (Pointer)) [Index]))


ULONG
TriagepGetPageSize(
    ULONG Architecture
    )
{
    switch (Architecture) {

        case IMAGE_FILE_MACHINE_I386:
            return PAGE_SIZE_I386;

        case IMAGE_FILE_MACHINE_AMD64:
            return PAGE_SIZE_AMD64;

        case IMAGE_FILE_MACHINE_IA64:
            return PAGE_SIZE_IA64;

        default:
            return (ULONG) -1;
    }
}



BOOLEAN
TriagepVerifyDump(
    IN LPVOID TriageDumpBlock
    )
{
    BOOLEAN Succ = FALSE;
    PMEMORY_DUMP MemoryDump = NULL;

    if (!TriageDumpBlock) {
        return FALSE;
    }

    MemoryDump = (PMEMORY_DUMP) TriageDumpBlock;

    try {

        if (MemoryDump->Header.ValidDump != 'PMUD' ||
            MemoryDump->Header.Signature != 'EGAP' ||
            TriagepGetPageSize (MemoryDump->Header.MachineImageType) == -1) {

            Succ = FALSE;
            leave;
        }

        TriageImagePageSize = TriagepGetPageSize (MemoryDump->Header.MachineImageType);

        if ( MemoryDump->Header.DumpType != DUMP_TYPE_TRIAGE ||
             *(ULONG*)IndexByByte (MemoryDump, MemoryDump->Triage.SizeOfDump - sizeof (DWORD)) != TRIAGE_DUMP_VALID ) {

            Succ = FALSE;
            leave;
        }

        // else

        Succ = TRUE;
    }

    except (EXCEPTION_EXECUTE_HANDLER) {

        Succ = FALSE;
    }

    return Succ;
}


PTRIAGE_DUMP
TriagepGetTriagePointer(
    IN PVOID TriageDumpBlock
    )
{
    ASSERT (TriageImagePageSize != -1);
    ASSERT (TriagepVerifyDump (TriageDumpBlock));

    return (PTRIAGE_DUMP) IndexByByte (TriageDumpBlock, TriageImagePageSize);
}



NTSTATUS
TriageGetVersion(
    IN LPVOID TriageDumpBlock,
    OUT ULONG * MajorVersion,
    OUT ULONG * MinorVersion,
    OUT ULONG * ServicePackBuild
    )
{
    PTRIAGE_DUMP TriageDump;
    PDUMP_HEADER DumpHeader;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    DumpHeader = (PDUMP_HEADER) TriageDumpBlock;

    if (MajorVersion) {
        *MajorVersion = DumpHeader->MajorVersion;
    }

    if (MinorVersion) {
        *MinorVersion = DumpHeader->MinorVersion;
    }

    if (ServicePackBuild) {
        *ServicePackBuild = TriageDump->ServicePackBuild;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
TriageGetDriverCount(
    IN LPVOID TriageDumpBlock,
    OUT ULONG * DriverCount
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    *DriverCount = TriageDump->DriverCount;

    return STATUS_SUCCESS;
}



#if 0

NTSTATUS
TriageGetContext(
    IN LPVOID TriageDumpBlock,
    OUT LPVOID Context,
    IN ULONG SizeInBytes
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy the CONTEXT record.
    //

    if (SizeInBytes == -1) {
        SizeInBytes = sizeof (CONTEXT);
    }

    RtlCopyMemory (Context,
                   IndexByUlong (TriageDumpBlock, TriageDump->ContextOffset),
                   SizeInBytes
                   );

    return STATUS_SUCCESS;
}


NTSTATUS
TriageGetExceptionRecord(
    IN LPVOID TriageDumpBlock,
    OUT EXCEPTION_RECORD * ExceptionRecord
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory (ExceptionRecord,
                   IndexByUlong (TriageDumpBlock, TriageDump->ExceptionOffset),
                   sizeof (*ExceptionRecord)
                   );

    return STATUS_SUCCESS;
}
#endif


LOGICAL
TriageActUpon(
    IN PVOID TriageDumpBlock
    )
{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return FALSE;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return FALSE;
    }

    if ((TriageDump->TriageOptions & DCB_TRIAGE_DUMP_ACT_UPON_ENABLED) == 0) {
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
TriageGetBugcheckData(
    IN LPVOID TriageDumpBlock,
    OUT ULONG * BugCheckCode,
    OUT UINT_PTR * BugCheckParam1,
    OUT UINT_PTR * BugCheckParam2,
    OUT UINT_PTR * BugCheckParam3,
    OUT UINT_PTR * BugCheckParam4
    )
{
    PDUMP_HEADER DumpHeader;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return STATUS_INVALID_PARAMETER;
    }

    DumpHeader = (PDUMP_HEADER) TriageDumpBlock;

    *BugCheckCode = DumpHeader->BugCheckCode;
    *BugCheckParam1 = DumpHeader->BugCheckParameter1;
    *BugCheckParam2 = DumpHeader->BugCheckParameter2;
    *BugCheckParam3 = DumpHeader->BugCheckParameter3;
    *BugCheckParam4 = DumpHeader->BugCheckParameter4;

    return STATUS_SUCCESS;
}



PKLDR_DATA_TABLE_ENTRY
TriageGetLoaderEntry(
    IN PVOID TriageDumpBlock,
    IN ULONG ModuleIndex
    )

/*++

Routine Description:

    This function retrieves a loaded module list entry.

Arguments:

    TriageDumpBlock - Supplies the triage dump to reference.

    ModuleIndex - Supplies the driver index number to locate.

Return Value:

    A pointer to a loader data table entry if one is available, NULL if not.

Environment:

    Kernel mode, APC_LEVEL or below.  Phase 0 only.

    N.B. This function is for use by memory management ONLY.

--*/

{
    PDUMP_STRING DriverName;
    PDUMP_DRIVER_ENTRY DriverList;
    PTRIAGE_DUMP TriageDump;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return NULL;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (ModuleIndex >= TriageDump->DriverCount) {
        return NULL;
    }

    DriverList = (PDUMP_DRIVER_ENTRY)
            IndexByByte (TriageDumpBlock, TriageDump->DriverListOffset);


    DataTableEntry = (PKLDR_DATA_TABLE_ENTRY) (&DriverList[ModuleIndex].LdrEntry);

    //
    // Repoint the module driver name into the triage buffer.
    //

    DriverName = (PDUMP_STRING)
            IndexByByte (TriageDumpBlock,
                         DriverList [ ModuleIndex ].DriverNameOffset);

    DataTableEntry->BaseDllName.Length = (USHORT) (DriverName->Length * sizeof (WCHAR));
    DataTableEntry->BaseDllName.MaximumLength = DataTableEntry->BaseDllName.Length;
    DataTableEntry->BaseDllName.Buffer = DriverName->Buffer;

    return DataTableEntry;
}


PVOID
TriageGetMmInformation(
    IN PVOID TriageDumpBlock
    )

/*++

Routine Description:

    This function retrieves a loaded module list entry.

Arguments:

    TriageDumpBlock - Supplies the triage dump to reference.

Return Value:

    A pointer to an opaque Mm information structure.

Environment:

    Kernel mode, APC_LEVEL or below.  Phase 0 only.

    N.B. This function is for use by memory management ONLY.

--*/

{
    PTRIAGE_DUMP TriageDump;

    if (!TriagepVerifyDump (TriageDumpBlock)) {
        return NULL;
    }

    TriageDump = TriagepGetTriagePointer (TriageDumpBlock);

    if (!TriageDump) {
        return NULL;
    }

    return (PVOID)IndexByByte (TriageDumpBlock, TriageDump->MmOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\iomgr\write.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code to implement the NtWriteFile system service.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iomgr.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtWriteFile)
#pragma alloc_text(PAGE, NtWriteFile64)
#pragma alloc_text(PAGE, NtWriteFileGather)
#endif

NTSTATUS
NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    file associated with FileHandle starting at StartingBlock|ByteOffset.
    The actual number of bytes written to the file will be returned in the
    second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    Buffer - Supplies the address of the buffer containing data to be written
        to the file.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl;
    PIO_STACK_LOCATION irpSp;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    NTSTATUS exceptionCode;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceFileObjectForWrite( FileHandle,
                                            requestorMode,
                                            (PVOID *) &fileObject,
                                            &handleInformation);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Attempt to probe the caller's parameters within the exception
        // handler block.
        //

        exceptionCode = STATUS_SUCCESS;

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The caller's data buffer must be readable from the caller's
            // mode.  This check ensures that this is the case.  Since the
            // buffer address is captured, the caller cannot change it,
            // even though he/she can change the protection from another
            // thread.  This error will be caught by the probe/lock or
            // buffer copy operations later.
            //

            ProbeForRead( Buffer, Length, sizeof( UCHAR ) );

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Check that the ByteOffset parameter is readable from the
            // caller's mode, if one was specified, and capture it.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following Buffer
            // and ByteOffset parameter checks differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of the block size.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1))) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ||
                        (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it is
                // is of the proper type.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                        fileOffset.HighPart == -1) {
                        NOTHING;
                    } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                               fileOffset.HighPart == -1 &&
                               (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                        NOTHING;
                    } else if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Simply cleanup, dereference the file
            // object, and return with the appropriate status code.
            //

            ObDereferenceObject( fileObject );
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the appropriate parameters to
        // their expected locations without making all of the checks.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }
#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the Buffer is properly aligned, and that the
            // length is an integral number of the block size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1))) ||
                (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it is
            // is of the proper type.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                    fileOffset.HighPart == -1) {
                    NOTHING;
                } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                           fileOffset.HighPart == -1 &&
                           (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                    NOTHING;
                } else if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG

    }

    //
    // If the caller has only append access to the file, ignore the input
    // parameters and set the ByteOffset to indicate that this write is
    // to the end of the file.  Otherwise, ensure that the parameters are
    // valid.
    //

    if (SeComputeGrantedAccesses( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {

        //
        // This is an append operation to the end of a file.  Set the
        // ByteOffset parameter to give drivers a consistent view of
        // this type of call.
        //

        fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        fileOffset.HighPart = -1;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the fast io dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        //
        // Turbo write support.  If the file is currently cached on this
        // file object, then call the Cache Manager directly via FsRtl
        // and try to successfully complete the request here.  Note if
        // FastIoWrite returns FALSE or we get an I/O error, we simply
        // fall through and go the "long way" and create an Irp.
        //

        if (fileObject->PrivateCacheMap) {

            IO_STATUS_BLOCK localIoStatus;

            ASSERT(fastIoDispatch && fastIoDispatch->FastIoWrite);

            //
            //  Negative file offsets are illegal.
            //

            if (fileOffset.HighPart < 0 &&
                (fileOffset.HighPart != -1 ||
                fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            if (fastIoDispatch->FastIoWrite( fileObject,
                                             &fileOffset,
                                             Length,
                                             TRUE,
                                             keyValue,
                                             Buffer,
                                             &localIoStatus,
                                             deviceObject )

                    &&

                (localIoStatus.Status == STATUS_SUCCESS)) {

                IopUpdateWriteOperationCount( );
                IopUpdateWriteTransferCount( (ULONG)localIoStatus.Information );

                //
                // Carefully return the I/O status.

                try {
                    *IoStatusBlock = localIoStatus;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.
                //

                //
                // Cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return localIoStatus.Status;
            }
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function code here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) irpSp;
    *majorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer,
        // and copy the caller's data into it.  This is done using an
        // exception handler that will perform cleanup if the operation
        // fails.  Note that this is only done if the operation has a non-zero
        // length.
        //

        if (Length) {

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool,
                // charge quota for it, and copy the caller's data into it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPoolCacheAligned, Length );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, Buffer, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer, allocating the system buffer, or copying the data
                // from the caller's buffer to the system buffer.  Determine
                // what actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Set the IRP_BUFFERED_IO flag in the IRP so that I/O completion
            // will know that this is not a direct I/O operation.  Also set the
            // IRP_DEALLOCATE_BUFFER flag so it will deallocate the buffer.
            //

            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

        } else {

            //
            // This is a zero-length write.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->Flags = IRP_BUFFERED_IO;
        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

        mdl = (PMDL) NULL;
        irp->Flags = 0;

        if (Length) {

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for read access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either allocating the MDL
                // or while attempting to probe and lock the caller's buffer.
                // Determine what actually happened, clean everything up, and
                // return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();
            }

        }

    } else {

        //
        // Pass the address of the caller's buffer to the device driver.  It
        // is now up to the driver to do everything.
        //

        irp->Flags = 0;
        irp->UserBuffer = Buffer;

    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.Key = keyValue;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        WriteTransfer );

    return status;
}

NTSTATUS
NtWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's segment
    buffers to the file associated with FileHandle starting at
    StartingBlock|ByteOffset. The actual number of bytes written to the file
    will be returned in the second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be read from.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:
    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFILE_SEGMENT_ELEMENT capturedArray = NULL;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl;
    PIO_STACK_LOCATION irpSp;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    NTSTATUS exceptionCode;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    ULONG i;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Verify this is a valid gather write request.  In particular it must
    // be non cached, asynchronous, use completion ports, non buffer I/O
    // device and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (fileObject->Flags & FO_SYNCHRONOUS_IO) ||
        deviceObject->Flags & DO_BUFFERED_IO ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES( Length );

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either WRITE_DATA or APPEND_DATA
        // access to the file.  If not, cleanup and return an access denied
        // error status value.  Note that if this is a pipe then the APPEND_DATA
        // access check may not be made since this access code is overlaid with
        // CREATE_PIPE_INSTANCE access.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, (!(fileObject->Flags & FO_NAMED_PIPE) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        exceptionCode = STATUS_SUCCESS;

        //
        // Attempt to probe the caller's parameters within the exception
        // handler block.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatusEx( IoStatusBlock , ApcRoutine);

            //
            // The SegmentArray paramter must be accessible.
            //

#ifdef _X86_
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          sizeof( ULONG )
                          );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcess()->Wow64Process) {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              sizeof( ULONG )
                              );
            } else {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                              );
            }
#else
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                          );
#endif

            if (Length != 0) {

                //
                // Capture the segment array so it cannot be changed after
                // it has been looked at.
                //

                capturedArray = ExAllocatePoolWithQuota( PagedPool,
                                                         elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                                                         );

                RtlCopyMemory( capturedArray,
                               SegmentArray,
                               elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                               );

                SegmentArray = capturedArray;

                //
                // Verify that all the addresses are page aligned.
                //

                for (i = 0; i < elementCount; i++) {

                    if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {

                ExRaiseStatus(STATUS_INVALID_PARAMETER);

            }

            //
            // Check that the ByteOffset parameter is readable from the
            // caller's mode, if one was specified, and capture it.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following ByteOffset
            // parameter check differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1)))) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ) {

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it is
                // is of the proper type.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                        fileOffset.HighPart == -1) {
                        NOTHING;
                    } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                               fileOffset.HighPart == -1 &&
                               (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                        NOTHING;
                    } else if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Simply cleanup, dereference the file
            // object, and return with the appropriate status code.
            //

            ObDereferenceObject( fileObject );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }

            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the appropriate parameters to
        // their expected locations without making all of the checks.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }
#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the the length is an integral number of the block
            //  size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1)))) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize)) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it is
            // is of the proper type.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                    fileOffset.HighPart == -1) {
                    NOTHING;
                } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                           fileOffset.HighPart == -1 &&
                           (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                    NOTHING;
                } else if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        if (Length != 0) {

            //
            // Verify that all the addresses are page aligned.
            //

            for (i = 0; i < elementCount; i++) {

                if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {

                    ObDereferenceObject( fileObject );
                    ASSERT(FALSE);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG

    }

    //
    // If the caller has only append access to the file, ignore the input
    // parameters and set the ByteOffset to indicate that this write is
    // to the end of the file.  Otherwise, ensure that the parameters are
    // valid.
    //

    if (SeComputeGrantedAccesses( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {

        //
        // This is an append operation to the end of a file.  Set the
        // ByteOffset parameter to give drivers a consistent view of
        // this type of call.
        //

        fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        fileOffset.HighPart = -1;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the fast io dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                if (capturedArray != NULL) {
                    ExFreePool( capturedArray );
                }
                return status;
            }
        }

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function code here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) irpSp;
    *majorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // This is a direct I/O operation.  Allocate an MDL and invoke the
    // memory management routine to lock the buffer into memory.  This
    // is done using an exception handler that will perform cleanup if
    // the operation fails.  Note that no MDL is allocated, nor is any
    // memory probed or locked if the length of the request was zero.
    //

    mdl = (PMDL) NULL;
    irp->Flags = 0;

    if (Length) {

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of
            // the IRP.  Probe and lock the pages associated with the
            // caller's buffer for write access and fill in the MDL with
            // the PFNs of those pages.
            //

            mdl = IoAllocateMdl( (PVOID)(ULONG_PTR) SegmentArray[0].Buffer, Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // The address of the first file segment is used as a base
            // address.
            //

            MmProbeAndLockSelectedPages( mdl,
                                         SegmentArray,
                                         requestorMode,
                                         IoReadAccess );

            irp->UserBuffer = (PVOID)(ULONG_PTR) SegmentArray[0].Buffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either allocating the MDL
            // or while attempting to probe and lock the caller's buffer.
            // Determine what actually happened, clean everything up, and
            // return an appropriate error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
           return GetExceptionCode();
        }

    }

    //
    // We are done with the captured buffer.
    //

    if (capturedArray != NULL) {
        ExFreePool( capturedArray );
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.Key = keyValue;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        WriteTransfer );

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\assign.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    assign.c

Abstract:

    IoAssignResources

Author:

    Ken Reneris

Environment:
    EDIT IN 110 COLUMN MODE

Revision History:

    Add PnP support - shielint
    
    Cleanup - SantoshJ

--*/

#include "pnpmgrp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,IoAssignResources)
#endif  // ALLOC_PRAGMA

NTSTATUS
IoAssignResources (
    IN      PUNICODE_STRING                 RegistryPath,
    IN      PUNICODE_STRING                 DriverClassName OPTIONAL,
    IN      PDRIVER_OBJECT                  DriverObject,
    IN      PDEVICE_OBJECT                  DeviceObject OPTIONAL,
    IN      PIO_RESOURCE_REQUIREMENTS_LIST  RequestedResources,
    IN OUT  PCM_RESOURCE_LIST               *pAllocatedResources
    )
/*++

Routine Description:

    This routine takes an input request of RequestedResources, and returned
    allocated resources in pAllocatedResources.   The allocated resources are
    automatically recorded in the registry under the ResourceMap for the
    DriverClassName/DriverObject/DeviceObject requestor.

Arguments:

    RegistryPath
        For a simple driver, this would be the value passed to the drivers
        initialization function.  For drivers call IoAssignResources with
        multiple DeviceObjects are responsible for passing in a unique
        RegistryPath for each object.

        The registry path is checked for:
            RegitryPath:
                AssignedSystemResources.

        AssignSystemResources is of type REG_RESOURCE_REQUIREMENTS_LIST

        If present, IoAssignResources will attempt to use these settings to
        satisify the requested resources.  If the listed settings do
        not conform to the resource requirements, then IoAssignResources
        will fail.

        Note: IoAssignResources may store other internal binary information
        in the supplied RegisteryPath.

    DriverObject:
        The driver object of the caller.

    DeviceObject:
        If non-null, then requested resoruce list refers to this device.
        If null, the requested resource list refers to the driver.

    DriverClassName
        Used to partition allocated resources into different device classes.

    RequestedResources
        A list of resources to allocate.

        Allocated resources may be appended or freed by re-invoking
        IoAssignResources with the same RegistryPath, DriverObject and
        DeviceObject.  (editing requirements on a resource list by using
        sucessive calls is not preferred driver behaviour).

    AllocatedResources
        Returns the allocated resources for the requested resource list.

        Note that the driver is responsible for passing in a pointer to
        an uninitialized pointer.  IoAssignResources will initialize the
        pointer to point to the allocated CM_RESOURCE_LIST.  The driver
        is responisble for returning the memory back to pool when it is
        done with them structure.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    PDEVICE_NODE    deviceNode;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);
    UNREFERENCED_PARAMETER(DriverClassName);

    if (DeviceObject) {

        deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
        if (    deviceNode &&
                !(deviceNode->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)) {

            PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(DriverObject);
            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceObject);
            KeBugCheckEx(
                PNP_DETECTED_FATAL_ERROR, 
                PNP_ERR_INVALID_PDO, 
                (ULONG_PTR)DeviceObject, 
                (ULONG_PTR)DriverObject,
                0);
        }
    }
    if (RequestedResources) {

        if (    RequestedResources->AlternativeLists == 0 ||
                RequestedResources->List[0].Count == 0) {

            RequestedResources = NULL;
        }
    }
    if (pAllocatedResources) {

        *pAllocatedResources = NULL;
    }
    return IopLegacyResourceAllocation (    
            ArbiterRequestLegacyAssigned,
            DriverObject,
            DeviceObject,
            RequestedResources,
            pAllocatedResources);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\convert.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    convert.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Shie-Lin Tzong (shielint) 12-Apr-1995

Environment:

    Kernel mode only.

Revision History:

Note:

    This file is shared between the io subsystem and the ISAPNP bus driver.

    It is not compiled directly but is included by:
        base\ntos\io\pnpmgr\pnpcvrt.c
        base\busdrv\isapnp\convert.c

    ***** If you change this file make sure you build in *BOTH* places *****

--*/

#include "pbios.h"
#include "pnpcvrt.h"

#if UMODETEST
#undef IsNEC_98
#define IsNEC_98 0
#endif

//
// internal structures for resource translation
//

typedef struct _PB_DEPENDENT_RESOURCES {
    ULONG Count;
    UCHAR Flags;
    UCHAR Priority;
    struct _PB_DEPENDENT_RESOURCES *Next;
} PB_DEPENDENT_RESOURCES, *PPB_DEPENDENT_RESOURCES;

#define DEPENDENT_FLAGS_END  1

typedef struct _PB_ATERNATIVE_INFORMATION {
    PPB_DEPENDENT_RESOURCES Resources;
    ULONG NoDependentFunctions;
    ULONG TotalResourceCount;
} PB_ALTERNATIVE_INFORMATION, *PPB_ALTERNATIVE_INFORMATION;

//
// Internal function references
//

PPB_DEPENDENT_RESOURCES
PbAddDependentResourcesToList (
    IN OUT PUCHAR *ResourceDescriptor,
    IN ULONG ListNo,
    IN PPB_ALTERNATIVE_INFORMATION AlternativeList
    );

NTSTATUS
PbBiosIrqToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PbBiosDmaToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PbBiosPortFixedToIoDescriptor (
    IN OUT PUCHAR               *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR   IoDescriptor,
    IN BOOLEAN                   ForceFixedIoTo16bit
    );

NTSTATUS
PbBiosPortToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PbBiosMemoryToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    );

NTSTATUS
PpCmResourcesToBiosResources (
    IN PCM_RESOURCE_LIST CmResources,
    IN PUCHAR BiosRequirements,
    IN PUCHAR *BiosResources,
    IN PULONG Length
    );

NTSTATUS
PbCmIrqToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

NTSTATUS
PbCmDmaToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

NTSTATUS
PbCmPortToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

NTSTATUS
PbCmMemoryToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, PpBiosResourcesToNtResources)
#pragma alloc_text(PAGE, PpBiosResourcesSetToDisabled)
#pragma alloc_text(PAGE, PbAddDependentResourcesToList)
#pragma alloc_text(PAGE, PbBiosIrqToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosDmaToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosPortFixedToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosPortToIoDescriptor)
#pragma alloc_text(PAGE, PbBiosMemoryToIoDescriptor)
#pragma alloc_text(PAGE, PpCmResourcesToBiosResources)
#pragma alloc_text(PAGE, PbCmIrqToBiosDescriptor)
#pragma alloc_text(PAGE, PbCmDmaToBiosDescriptor)
#pragma alloc_text(PAGE, PbCmPortToBiosDescriptor)
#pragma alloc_text(PAGE, PbCmMemoryToBiosDescriptor)
#endif
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif

NTSTATUS
PpBiosResourcesToNtResources (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PUCHAR *BiosData,
    IN ULONG ConvertFlags,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *ReturnedList,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine parses the Bios resource list and generates
    a NT resource list.  The returned Nt resource list could be either IO
    format or CM format.  It is caller's responsibility to release the
    returned data buffer.

Arguments:

    SlotNumber - specifies the slot number of the BIOS resource.

    BiosData - Supplies a pointer to a variable which specifies the bios resource
        data buffer and which to receive the pointer to next bios resource data.

    ReturnedList - supplies a variable to receive the desired resource list.

    ReturnedLength - Supplies a variable to receive the length of the resource list.

Return Value:

    NTSTATUS code

--*/
{
    PUCHAR buffer;
    USHORT mask16, increment;
    UCHAR tagName, mask8;
    NTSTATUS status;
    PPB_ALTERNATIVE_INFORMATION alternativeList = NULL;
    ULONG commonResCount = 0, dependDescCount = 0, i, j;
    ULONG alternativeListCount = 0, dependFunctionCount = 0;
    PIO_RESOURCE_DESCRIPTOR ioDesc;
    PPB_DEPENDENT_RESOURCES dependResList = NULL, dependResources;
    BOOLEAN dependent = FALSE;
    BOOLEAN forceFixedIoTo16bit;
    ULONG listSize, noResLists;
    ULONG totalDescCount, descCount;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResReqList;
    PIO_RESOURCE_LIST ioResList;

    PAGED_CODE();

    //
    // First, scan the bios data to determine the memory requirement and
    // the information to build internal data structures.
    //

    *ReturnedLength = 0;
    alternativeListCount = 0;
    buffer = *BiosData;
    tagName = *buffer;

    forceFixedIoTo16bit =
        (BOOLEAN)((ConvertFlags & PPCONVERTFLAG_FORCE_FIXED_IO_16BIT_DECODE) != 0);

    for ( ; ; ) {

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            increment += 1;     // length of small tag
            tagName &= SMALL_TAG_MASK;
        } else {
            increment = *(USHORT UNALIGNED *)(buffer+1);
            increment += 3;     // length of large tag
        }

        if (tagName == TAG_END) {
            buffer += increment;
            break;
        }

        //
        // Based on the type of the BIOS resource, determine the count of
        // the IO descriptors.
        //

        switch (tagName) {
        case TAG_IRQ:
             mask16 = ((PPNP_IRQ_DESCRIPTOR)buffer)->IrqMask;
             i = 0;

             while (mask16) {
                 if(mask16 & 1) {
                    i++;
                 }
                 mask16 >>= 1;
             }
             if (!dependent) {
                 commonResCount += i;
             } else {
                 dependDescCount += i;
             }
             break;

        case TAG_DMA:
             mask8 = ((PPNP_DMA_DESCRIPTOR)buffer)->ChannelMask;
             i = 0;

             while (mask8) {
                 if (mask8 & 1) {
                     i++;
                 }
                 mask8 >>= 1;
             }
             if (!dependent) {
                 commonResCount += i;
             } else {
                 dependDescCount += i;
             }
             break;
        case TAG_START_DEPEND:
             dependent = TRUE;
             dependFunctionCount++;
             break;
        case TAG_END_DEPEND:
             dependent = FALSE;
             alternativeListCount++;
             break;
        case TAG_IO_FIXED:
        case TAG_IO:
        case TAG_MEMORY:
        case TAG_MEMORY32:
        case TAG_MEMORY32_FIXED:
             if (!dependent) {
                 commonResCount++;
             } else {
                 dependDescCount++;
             }
             break;
        default:

             //
             // Unknown tag. Skip it.
             //

             break;
        }

        //
        // Move to next bios resource descriptor.
        //

        buffer += increment;
        tagName = *buffer;
        if ((tagName & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
            break;
        }
    }

    if (dependent) {
        //
        // TAG_END_DEPEND was not found before we hit TAG_COMPLETE_END, so
        // simulate it.
        //
        dependent = FALSE;
        alternativeListCount++;
    }

    //
    // if empty bios resources, simply return.
    //

    if (commonResCount == 0 && dependFunctionCount == 0) {
        *ReturnedList = NULL;
        *ReturnedLength = 0;
        *BiosData = buffer;
        return STATUS_SUCCESS;
    }

    //
    // Allocate memory for our internal data structures
    //

    dependFunctionCount += commonResCount;
    dependResources = (PPB_DEPENDENT_RESOURCES)ExAllocatePoolWithTag(
                          PagedPool,
                          dependFunctionCount * sizeof(PB_DEPENDENT_RESOURCES) +
                              (commonResCount + dependDescCount) * sizeof(IO_RESOURCE_DESCRIPTOR),
                          'bPnP'
                          );
    if (!dependResources) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    dependResList = dependResources;  // remember it so we can free it.

    alternativeListCount += commonResCount;
    alternativeList = (PPB_ALTERNATIVE_INFORMATION)ExAllocatePoolWithTag(
                          PagedPool,
                          sizeof(PB_ALTERNATIVE_INFORMATION) * (alternativeListCount + 1),
                          'bPnP'
                          );
    if (!alternativeList) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit0;
    }
    RtlZeroMemory(alternativeList,
                  sizeof(PB_ALTERNATIVE_INFORMATION) * alternativeListCount
                  );

    alternativeList[0].Resources = dependResources;
    ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);

    //
    // Now start over again to process the bios data and initialize our internal
    // resource representation.
    //

    dependDescCount = 0;
    alternativeListCount = 0;
    buffer = *BiosData;
    tagName = *buffer;
    dependent = FALSE;

    for ( ; ; ) {
        if (!(tagName & LARGE_RESOURCE_TAG)) {
            tagName &= SMALL_TAG_MASK;
        }

        if (tagName == TAG_END) {
            buffer += (*buffer & SMALL_TAG_SIZE_MASK) + 1;
            break;
        }

        switch (tagName) {
        case TAG_DMA:
        case TAG_IRQ:
        case TAG_IO:
        case TAG_IO_FIXED:
        case TAG_MEMORY:
        case TAG_MEMORY32:
        case TAG_MEMORY32_FIXED:

             if (tagName == TAG_DMA) {
                 status = PbBiosDmaToIoDescriptor(&buffer, ioDesc);
             } else if (tagName == TAG_IRQ) {
                 status = PbBiosIrqToIoDescriptor(&buffer, ioDesc);
             } else if (tagName == TAG_IO) {
                 status = PbBiosPortToIoDescriptor(&buffer, ioDesc);
             } else if (tagName == TAG_IO_FIXED) {
                 status = PbBiosPortFixedToIoDescriptor(&buffer, ioDesc, forceFixedIoTo16bit);
             } else {
                 status = PbBiosMemoryToIoDescriptor(&buffer, ioDesc);
             }

             if (NT_SUCCESS(status)) {
                 ioDesc++;
                 if (dependent) {
                     dependDescCount++;
                 } else {
                     alternativeList[alternativeListCount].NoDependentFunctions = 1;
                     alternativeList[alternativeListCount].TotalResourceCount = 1;
                     dependResources->Count = 1;
                     dependResources->Flags = DEPENDENT_FLAGS_END;
                     dependResources->Next = alternativeList[alternativeListCount].Resources;
                     alternativeListCount++;
                     alternativeList[alternativeListCount].Resources = (PPB_DEPENDENT_RESOURCES)ioDesc;
                     dependResources = alternativeList[alternativeListCount].Resources;
                     ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
                 }
             }
             break;
        case TAG_START_DEPEND:
             //
             // Some card (OPTI) put empty START_DEPENDENT functions
             //

             dependent = TRUE;
             if (alternativeList[alternativeListCount].NoDependentFunctions != 0) {

                 //
                 // End of current dependent function
                 //

                 dependResources->Count = dependDescCount;
                 dependResources->Flags = 0;
                 dependResources->Next = (PPB_DEPENDENT_RESOURCES)ioDesc;
                 dependResources = dependResources->Next;
                 ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
                 alternativeList[alternativeListCount].TotalResourceCount += dependDescCount;
             }
             alternativeList[alternativeListCount].NoDependentFunctions++;
             if (*buffer & SMALL_TAG_SIZE_MASK) {
                 dependResources->Priority = *(buffer + 1);
             }
             dependDescCount = 0;
             buffer += 1 + (*buffer & SMALL_TAG_SIZE_MASK);
             break;
        case TAG_END_DEPEND:
             alternativeList[alternativeListCount].TotalResourceCount += dependDescCount;
             dependResources->Count = dependDescCount;
             dependResources->Flags = DEPENDENT_FLAGS_END;
             dependResources->Next = alternativeList[alternativeListCount].Resources;
             dependent = FALSE;
             dependDescCount = 0;
             alternativeListCount++;
             alternativeList[alternativeListCount].Resources = (PPB_DEPENDENT_RESOURCES)ioDesc;
             dependResources = alternativeList[alternativeListCount].Resources;
             ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
             buffer++;
             break;
        default:

            //
            // Don't-care tag simply advance the buffer pointer to next tag.
            //

            if (*buffer & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(buffer+1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT)(*buffer & SMALL_TAG_SIZE_MASK);
                increment += 1;     // length of small tag
            }
            buffer += increment;
        }
        tagName = *buffer;
        if ((tagName & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
            break;
        }
    }

    if (dependent) {
        //
        // TAG_END_DEPEND was not found before we hit TAG_COMPLETE_END, so
        // simulate it.
        //
        alternativeList[alternativeListCount].TotalResourceCount += dependDescCount;
        dependResources->Count = dependDescCount;
        dependResources->Flags = DEPENDENT_FLAGS_END;
        dependResources->Next = alternativeList[alternativeListCount].Resources;
        dependent = FALSE;
        dependDescCount = 0;
        alternativeListCount++;
        alternativeList[alternativeListCount].Resources = (PPB_DEPENDENT_RESOURCES)ioDesc;
        dependResources = alternativeList[alternativeListCount].Resources;
        ioDesc = (PIO_RESOURCE_DESCRIPTOR)(dependResources + 1);
    }

    if (alternativeListCount != 0) {
        alternativeList[alternativeListCount].Resources = NULL; // dummy alternativeList record
    }
    *BiosData = buffer;

    //
    // prepare IoResourceList
    //

    noResLists = 1;
    for (i = 0; i < alternativeListCount; i++) {
        noResLists *= alternativeList[i].NoDependentFunctions;
    }
    totalDescCount = 0;
    for (i = 0; i < alternativeListCount; i++) {
        descCount = 1;
        for (j = 0; j < alternativeListCount; j++) {
            if (j == i) {
                descCount *= alternativeList[j].TotalResourceCount;
            } else {
                descCount *= alternativeList[j].NoDependentFunctions;
            }
        }
        totalDescCount += descCount;
    }
    listSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
               sizeof(IO_RESOURCE_LIST) * (noResLists - 1) +
               sizeof(IO_RESOURCE_DESCRIPTOR) * totalDescCount -
               sizeof(IO_RESOURCE_DESCRIPTOR) * noResLists +
               sizeof(IO_RESOURCE_DESCRIPTOR) * commonResCount *  noResLists;

    if (ConvertFlags & PPCONVERTFLAG_SET_RESTART_LCPRI) {
        listSize += noResLists * sizeof(IO_RESOURCE_DESCRIPTOR);
    }

    ioResReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePoolWithTag(PagedPool, listSize, 'bPnP');
    if (!ioResReqList) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit1;
    }

    ioResReqList->ListSize = listSize;
    ioResReqList->InterfaceType = Isa;
    ioResReqList->BusNumber = BusNumber;
    ioResReqList->SlotNumber = SlotNumber;
    ioResReqList->Reserved[0] = 0;
    ioResReqList->Reserved[1] = 0;
    ioResReqList->Reserved[2] = 0;
    ioResReqList->AlternativeLists = noResLists;
    ioResList = &ioResReqList->List[0];

    //
    // Build resource lists
    //

    for (i = 0; i < noResLists; i++) {

        ioResList->Version = 1;
        ioResList->Revision = 0x30 | (USHORT)i;

        if (ConvertFlags & PPCONVERTFLAG_SET_RESTART_LCPRI) {

            RtlZeroMemory(&ioResList->Descriptors[0], sizeof(IO_RESOURCE_DESCRIPTOR));

            ioResList->Descriptors[0].Option = IO_RESOURCE_PREFERRED;
            ioResList->Descriptors[0].Type = CmResourceTypeConfigData;
            ioResList->Descriptors[0].u.ConfigData.Priority = LCPRI_RESTART;

            buffer = (PUCHAR)&ioResList->Descriptors[1];

        } else {

            buffer = (PUCHAR)&ioResList->Descriptors[0];
        }

        //
        // Copy dependent functions if any.
        //

        if (alternativeList) {
            PbAddDependentResourcesToList(&buffer, 0, alternativeList);
        }

        //
        // Update io resource list ptr
        //

        ioResList->Count = ((ULONG)((ULONG_PTR)buffer - (ULONG_PTR)&ioResList->Descriptors[0])) /
                             sizeof(IO_RESOURCE_DESCRIPTOR);

        //
        // Hack for user mode pnp mgr
        //

        for (j = 0; j < ioResList->Count; j++) {
            ioResList->Descriptors[j].Spare2 = (USHORT)j;
        }
        ioResList = (PIO_RESOURCE_LIST)buffer;
    }

    *ReturnedLength = listSize;
    status = STATUS_SUCCESS;
    *ReturnedList = ioResReqList;
exit1:
    if (alternativeList) {
        ExFreePool(alternativeList);
    }
exit0:
    if (dependResList) {
        ExFreePool(dependResList);
    }
    return status;
}

VOID
PpBiosResourcesSetToDisabled (
    IN OUT PUCHAR BiosData,
    OUT    PULONG Length
    )

/*++

Routine Description:

    This routine modifies the passed in Bios resource list so that it reflects
    what PnPBIOS expects to see if a device is disabled.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer

    Length   - This points to a ULONG that will contain the length of the single
               resource list that has been programmed to look disabled.

Return Value:

    None.

--*/
{
    PUCHAR buffer;
    USHORT increment;
    UCHAR tagName;

    PAGED_CODE();

    //
    // First, scan the bios data to determine the memory requirement and
    // the information to build internal data structures.
    //

    buffer = BiosData;

    do {

        tagName = *buffer;

        //
        // Determine the size of the BIOS resource descriptor
        //
        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            tagName &= SMALL_TAG_MASK;

            //
            // Be careful not to wipe out the version field. That's very bad.
            //
            if (tagName != TAG_VERSION) {
               RtlZeroMemory(buffer+1, increment);
            }
            increment += 1;     // length of small tag
        } else {
            increment = *(USHORT UNALIGNED *)(buffer+1);
            RtlZeroMemory(buffer+3, increment);
            increment += 3;     // length of large tag
        }

        buffer += increment;
    } while (tagName != TAG_END) ;

    *Length = (ULONG)(buffer - BiosData) ;
}

PPB_DEPENDENT_RESOURCES
PbAddDependentResourcesToList (
    IN OUT PUCHAR *ResourceDescriptor,
    IN ULONG ListNo,
    IN PPB_ALTERNATIVE_INFORMATION AlternativeList
    )

/*++

Routine Description:

    This routine adds dependent functions to caller specified list.

Arguments:

    ResourceDescriptor - supplies a pointer to the descriptor buffer.

    ListNo - supplies an index to the AlternativeList.

    AlternativeList - supplies a pointer to the alternativelist array.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PPB_DEPENDENT_RESOURCES dependentResources, ptr;
    ULONG size;

    PAGED_CODE();

    //
    // Copy dependent resources to caller supplied list buffer and
    // update the list buffer pointer.
    //

    dependentResources = AlternativeList[ListNo].Resources;
    size = sizeof(IO_RESOURCE_DESCRIPTOR) *  dependentResources->Count;
    RtlMoveMemory(*ResourceDescriptor, dependentResources + 1, size);
    *ResourceDescriptor = *ResourceDescriptor + size;

    //
    // Add dependent resource of next list to caller's buffer
    //

    if (AlternativeList[ListNo + 1].Resources) {
        ptr = PbAddDependentResourcesToList(ResourceDescriptor, ListNo + 1, AlternativeList);
    } else {
        ptr = NULL;
    }
    if (ptr == NULL) {
        AlternativeList[ListNo].Resources = dependentResources->Next;
        if (!(dependentResources->Flags & DEPENDENT_FLAGS_END)) {
            ptr = dependentResources->Next;
        }
    }
    return ptr;
}

NTSTATUS
PbBiosIrqToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS IRQ information to NT usable format.
    This routine stops when an irq io resource is generated.  if there are
    more irq io resource descriptors available, the BiosData pointer will
    not advance.  So caller will pass us the same resource tag again.

    Note, BIOS DMA info alway uses SMALL TAG.  A tag structure is repeated
    for each seperated channel required.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    static ULONG bitPosition = 0;
    USHORT mask;
    ULONG irq;
    PPNP_IRQ_DESCRIPTOR buffer;
    UCHAR size, option;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    buffer = (PPNP_IRQ_DESCRIPTOR)*BiosData;

    //
    // if this is not the first descriptor for the tag, set
    // its option to alternative.
    //

    if (bitPosition == 0) {
        option = 0;
    } else {
        option = IO_RESOURCE_ALTERNATIVE;
    }
    size = buffer->Tag & SMALL_TAG_SIZE_MASK;
    mask = buffer->IrqMask;
    mask >>= bitPosition;
    irq = (ULONG) -1;

    while (mask) {
        if (mask & 1) {
            irq = bitPosition;
            break;
        }
        mask >>= 1;
        bitPosition++;
    }

    //
    // Fill in Io resource descriptor
    //

    if (irq != (ULONG)-1) {
        IoDescriptor->Option = option;
        IoDescriptor->Type = CmResourceTypeInterrupt;
        IoDescriptor->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
        IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
        if (size == 3 && buffer->Information & 0x0C) {
            IoDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            IoDescriptor->ShareDisposition = CmResourceShareShared;
        }
        IoDescriptor->Spare1 = 0;
        IoDescriptor->Spare2 = 0;
        IoDescriptor->u.Interrupt.MinimumVector = irq;
        IoDescriptor->u.Interrupt.MaximumVector = irq;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // try to move bitPosition to next 1 bit.
        //

        while (mask) {
            mask >>= 1;
            bitPosition++;
            if (mask & 1) {
                return status;
            }
        }
    }

    //
    // Done with current irq tag, advance pointer to next tag
    //

    bitPosition = 0;
    *BiosData = (PUCHAR)buffer + size + 1;
    return status;
}

NTSTATUS
PbBiosDmaToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS DMA information to NT usable format.
    This routine stops when an dma io resource is generated.  if there are
    more dma io resource descriptors available, the BiosData pointer will
    not advance.  So caller will pass us the same resource tag again.

    Note, BIOS DMA info alway uses SMALL TAG.  A tag structure is repeated
    for each seperated channel required.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    static ULONG bitPosition = 0;
    ULONG dma;
    PPNP_DMA_DESCRIPTOR buffer;
    UCHAR mask, option;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    buffer = (PPNP_DMA_DESCRIPTOR)*BiosData;

    //
    // if this is not the first descriptor for the tag, set
    // its option to alternative.
    //

    if (bitPosition == 0) {
        option = 0;
    } else {
        option = IO_RESOURCE_ALTERNATIVE;
    }
    mask = buffer->ChannelMask;
    mask >>= bitPosition;
    dma = (ULONG) -1;

    while (mask) {
        if (mask & 1) {
            dma = bitPosition;
            break;
        }
        mask >>= 1;
        bitPosition++;
    }

    //
    // Fill in Io resource descriptor
    //

    if (dma != (ULONG)-1) {
        IoDescriptor->Option = option;
        IoDescriptor->Type = CmResourceTypeDma;
        IoDescriptor->Flags = 0;
        IoDescriptor->ShareDisposition = CmResourceShareUndetermined;
        IoDescriptor->Spare1 = 0;
        IoDescriptor->Spare2 = 0;
        IoDescriptor->u.Dma.MinimumChannel = dma;
        IoDescriptor->u.Dma.MaximumChannel = dma;
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // try to move bitPosition to next 1 bit.
        //

        while (mask) {
            mask >>= 1;
            bitPosition++;
            if (mask & 1) {
                return status;
            }
        }
    }

    //
    // Done with current dma tag, advance pointer to next tag
    //

    bitPosition = 0;
    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return status;
}

NTSTATUS
PbBiosPortFixedToIoDescriptor (
    IN OUT PUCHAR               *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR   IoDescriptor,
    IN BOOLEAN                   ForceFixedIoTo16bit
    )

/*++

Routine Description:

    This routine translates BIOS FIXED IO information to NT usable format.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

    ForceFixedIoTo16bit - hack option to force fixed I/O resources to 16bit
        for far too pessimistic BIOS's.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PPNP_FIXED_PORT_DESCRIPTOR buffer;

    PAGED_CODE();

    buffer = (PPNP_FIXED_PORT_DESCRIPTOR)*BiosData;

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = 0;
    IoDescriptor->Type = CmResourceTypePort;

    if (ForceFixedIoTo16bit) {

        IoDescriptor->Flags = CM_RESOURCE_PORT_IO + CM_RESOURCE_PORT_16_BIT_DECODE;

    } else {

        IoDescriptor->Flags = CM_RESOURCE_PORT_IO + CM_RESOURCE_PORT_10_BIT_DECODE;
    }

#if defined(_X86_)

    //
    // Workaround:
    //  NEC PC9800 series's PnPBIOS report I/O resources between 0x00 and 0xFF as FIXED IO.
    //  But These resources are 16bit DECODE resource, not 10bit DECODE one. We need to check
    //  the range of I/O resources .
    //

    if (IsNEC_98) {
        if ( (ULONG)buffer->MinimumAddress < 0x100 ) {
            IoDescriptor->Flags = CM_RESOURCE_PORT_IO + CM_RESOURCE_PORT_16_BIT_DECODE;
        }
    }
#endif                                                                                 // <--end changing code

    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Port.Length = (ULONG)buffer->Length;
    IoDescriptor->u.Port.MinimumAddress.LowPart = (ULONG)(buffer->MinimumAddress & 0x3ff);
    IoDescriptor->u.Port.MinimumAddress.HighPart = 0;
    IoDescriptor->u.Port.MaximumAddress.LowPart = IoDescriptor->u.Port.MinimumAddress.LowPart +
                                                      IoDescriptor->u.Port.Length - 1;
    IoDescriptor->u.Port.MaximumAddress.HighPart = 0;
    IoDescriptor->u.Port.Alignment = 1;

    //
    // Done with current fixed port tag, advance pointer to next tag
    //

    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}

NTSTATUS
PbBiosPortToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS IO information to NT usable format.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PPNP_PORT_DESCRIPTOR buffer;

    PAGED_CODE();

    buffer = (PPNP_PORT_DESCRIPTOR)*BiosData;

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = 0;
    IoDescriptor->Type = CmResourceTypePort;
    IoDescriptor->Flags = CM_RESOURCE_PORT_IO;
    if (buffer->Information & 1) {
        IoDescriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
    } else {
        IoDescriptor->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
    }
    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Port.Length = (ULONG)buffer->Length;

#if defined(_X86_)
    if (IsNEC_98) {
        if (buffer->Information & 0x80) {
            IoDescriptor->u.Port.Length *= 2;
        }
    }
#endif

    IoDescriptor->u.Port.MinimumAddress.LowPart = (ULONG)buffer->MinimumAddress;
    IoDescriptor->u.Port.MinimumAddress.HighPart = 0;
    IoDescriptor->u.Port.MaximumAddress.LowPart = (ULONG)buffer->MaximumAddress +
                                                     IoDescriptor->u.Port.Length - 1;
    IoDescriptor->u.Port.MaximumAddress.HighPart = 0;
    IoDescriptor->u.Port.Alignment = (ULONG)buffer->Alignment;

    //
    // Done with current fixed port tag, advance pointer to next tag
    //

    buffer += 1;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}

NTSTATUS
PbBiosMemoryToIoDescriptor (
    IN OUT PUCHAR *BiosData,
    IN PIO_RESOURCE_DESCRIPTOR IoDescriptor
    )

/*++

Routine Description:

    This routine translates BIOS MEMORY information to NT usable format.

Arguments:

    BiosData - Supplies a pointer to the bios resource data buffer.

    IoDescriptor - supplies a pointer to an IO_RESOURCE_DESCRIPTOR buffer.
        Converted resource will be stored here.

Return Value:

    return NTSTATUS code to indicate the result of the operation.

--*/
{
    PUCHAR buffer;
    UCHAR tag;
    PHYSICAL_ADDRESS minAddr, maxAddr;
    ULONG alignment, length;
    USHORT increment;
    USHORT flags = 0;

    PAGED_CODE();

    buffer = *BiosData;
    tag = ((PPNP_MEMORY_DESCRIPTOR)buffer)->Tag;
    increment = ((PPNP_MEMORY_DESCRIPTOR)buffer)->Length + 3; // larg tag size = 3

    minAddr.HighPart = 0;
    maxAddr.HighPart = 0;
    switch (tag) {
    case TAG_MEMORY:
         minAddr.LowPart = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)buffer)->MinimumAddress)) << 8;
         if ((alignment = ((PPNP_MEMORY_DESCRIPTOR)buffer)->Alignment) == 0) {
             alignment = 0x10000;
         }
         length = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)buffer)->MemorySize)) << 8;
         maxAddr.LowPart = (((ULONG)(((PPNP_MEMORY_DESCRIPTOR)buffer)->MaximumAddress)) << 8) + length - 1;
         flags = CM_RESOURCE_MEMORY_24;
         break;
    case TAG_MEMORY32:
         length = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->MemorySize;
         minAddr.LowPart = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->MinimumAddress;
         maxAddr.LowPart = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->MaximumAddress + length - 1;
         alignment = ((PPNP_MEMORY32_DESCRIPTOR)buffer)->Alignment;
         break;
    case TAG_MEMORY32_FIXED:
         length = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)buffer)->MemorySize;
         minAddr.LowPart = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)buffer)->BaseAddress;
         maxAddr.LowPart = minAddr.LowPart + length - 1;
         alignment = 1;
         break;
    default:
         alignment = 0;
         length = 0;
         break;
    }

    //
    // Fill in Io resource descriptor
    //

    IoDescriptor->Option = 0;
    IoDescriptor->Type = CmResourceTypeMemory;
    IoDescriptor->Flags = CM_RESOURCE_PORT_MEMORY + flags;
    IoDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
    IoDescriptor->Spare1 = 0;
    IoDescriptor->Spare2 = 0;
    IoDescriptor->u.Memory.MinimumAddress = minAddr;
    IoDescriptor->u.Memory.MaximumAddress = maxAddr;
    IoDescriptor->u.Memory.Alignment = alignment;
    IoDescriptor->u.Memory.Length = length;

    //
    // Done with current tag, advance pointer to next tag
    //

    buffer += increment;
    *BiosData = (PUCHAR)buffer;
    return STATUS_SUCCESS;
}

NTSTATUS
PpCmResourcesToBiosResources (
    IN PCM_RESOURCE_LIST CmResources,
    IN PUCHAR BiosRequirements,
    IN PUCHAR *BiosResources,
    IN PULONG Length
    )

/*++

Routine Description:

    This routine parses the Cm resource list and generates
    a Pnp BIOS resource list.  It is caller's responsibility to release the
    returned data buffer.

Arguments:

    CmResources - Supplies a pointer to a Cm resource list buffer.

    BiosRequirements - supplies a pointer to the PnP BIOS possible resources.

    BiosResources - Supplies a variable to receive the pointer to the
        converted bios resource buffer.

    Length - supplies a pointer to a variable to receive the length
        of the Pnp Bios resources.

Return Value:

    a pointer to a Pnp Bios resource list if succeeded.  Else,
    a NULL pointer will be returned.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    ULONG i, l, count, length, totalSize = 0;
    PUCHAR p, px;
    PNP_MEMORY_DESCRIPTOR biosDesc;
    NTSTATUS status;

    PAGED_CODE();

    *BiosResources = NULL;
    *Length = 0;
    CmResources->Count;
    if (CmResources->Count == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Determine pool size needed
    //

    count = 0;
    cmFullDesc = &CmResources->List[0];
    for (l = 0; l < CmResources->Count; l++) {
        cmDesc = cmFullDesc->PartialResourceList.PartialDescriptors;
        for (i = 0; i < cmFullDesc->PartialResourceList.Count; i++) {
            switch (cmDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:
                 count++;
                 cmDesc++;
                 break;
            case CmResourceTypeDeviceSpecific:
                 length = cmDesc->u.DeviceSpecificData.DataSize;
                 cmDesc++;
                 cmDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDesc + length);
                 break;
            default:
                 count++;
                 cmDesc++;
                 break;
            }
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDesc;
    }

    if (count == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Allocate max amount of memory
    //

    px = p= ExAllocatePoolWithTag(PagedPool,
                             count * sizeof(PNP_MEMORY_DESCRIPTOR),
                             'bPnP');
    if (!p) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    status = STATUS_RESOURCE_TYPE_NOT_FOUND;
    cmFullDesc = &CmResources->List[0];
    for (l = 0; l < CmResources->Count; l++) {
        cmDesc = cmFullDesc->PartialResourceList.PartialDescriptors;
        for (i = 0; i < cmFullDesc->PartialResourceList.Count; i++) {
            switch (cmDesc->Type) {
            case CmResourceTypePort:
                 status = PbCmPortToBiosDescriptor (
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeInterrupt:
                 status = PbCmIrqToBiosDescriptor(
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeMemory:
                 status = PbCmMemoryToBiosDescriptor (
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeDma:
                 status = PbCmDmaToBiosDescriptor (
                                  BiosRequirements,
                                  cmDesc,
                                  &biosDesc,
                                  &length
                                  );
                 break;
            case CmResourceTypeDeviceSpecific:
                 length = cmDesc->u.DeviceSpecificData.DataSize;
                 cmDesc++;
                 cmDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDesc + length);
                 continue;
            default:
                 cmDesc++;
                 continue;
            }
            if (NT_SUCCESS(status)) {
                cmDesc++;
                RtlCopyMemory(p, &biosDesc, length);
                p += length;
                totalSize += length;
            } else {
                ExFreePool(px);
                goto exit;
            }
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDesc;
    }

exit:
    if (NT_SUCCESS(status)) {
        *p = TAG_COMPLETE_END;
        p++;
        *p = 0;            // checksum ignored
        totalSize += 2;
        *BiosResources = px;
        *Length = totalSize;
    }
    return status;
}

NTSTATUS
PbCmIrqToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM IRQ information to Pnp BIOS format.
    Since there is not enough information in the CM int descriptor to
    convert it to Pnp BIOS descriptor.  We will search the Bios
    possible resource lists for the corresponding resource information.

Arguments:

    BiosRequirements - Supplies a pointer to the bios possible resource lists.

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    ReturnDescriptor - Supplies a buffer to receive the returned BIOS descriptor.

    Length - Supplies a variable to receive the length of the returned bios descriptor.

Return Value:

    return a pointer to the desired dma descriptor in the BiosRequirements.  Null
    if not found.

--*/
{
    USHORT irqMask;
    UCHAR tag;
    PPNP_IRQ_DESCRIPTOR biosDesc;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG increment;
    PPNP_IRQ_DESCRIPTOR irqDesc = (PPNP_IRQ_DESCRIPTOR)ReturnDescriptor;

    PAGED_CODE();

    if (!(CmDescriptor->u.Interrupt.Level & 0xfffffff0)) {
        irqMask = (USHORT)(1 << CmDescriptor->u.Interrupt.Level);
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    if (!BiosRequirements) {
        irqDesc->Tag = TAG_IRQ | (sizeof(PNP_IRQ_DESCRIPTOR) - 2);  // No Information
        irqDesc->IrqMask = irqMask;
        *Length = sizeof(PNP_IRQ_DESCRIPTOR) - 1;
        status = STATUS_SUCCESS;
    } else {
        tag = *BiosRequirements;
        while (tag != TAG_COMPLETE_END) {
            if ((tag & SMALL_TAG_MASK) == TAG_IRQ) {
                biosDesc = (PPNP_IRQ_DESCRIPTOR)BiosRequirements;
                if (biosDesc->IrqMask & irqMask) {
                    *Length = (biosDesc->Tag & SMALL_TAG_SIZE_MASK) + 1;
                    RtlCopyMemory(ReturnDescriptor, BiosRequirements, *Length);
                    ((PPNP_IRQ_DESCRIPTOR)ReturnDescriptor)->IrqMask = irqMask;
                    status = STATUS_SUCCESS;
                    break;
                }
            }

            //
            // Don't-care tag simply advance the buffer pointer to next tag.
            //

            if (tag & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
                increment += 1;     // length of small tag
            }
            BiosRequirements += increment;
            tag = *BiosRequirements;
        }
    }
    return status;
}

NTSTATUS
PbCmDmaToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM DMA information to Pnp BIOS format.
    Since there is not enough information in the CM descriptor to
    convert it to Pnp BIOS descriptor.  We will search the Bios
    possible resource lists for the corresponding resource information.

Arguments:

    BiosRequirements - Supplies a pointer to the bios possible resource lists.

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    BiosDescriptor - Supplies a variable to receive the returned BIOS descriptor.

    Length - Supplies a variable to receive the length of the returned bios descriptor.

Return Value:

    return a pointer to the desired dma descriptor in the BiosRequirements.  Null
    if not found.

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    UCHAR dmaMask, tag;
    PPNP_DMA_DESCRIPTOR biosDesc;
    ULONG increment;
    PPNP_DMA_DESCRIPTOR dmaDesc = (PPNP_DMA_DESCRIPTOR)ReturnDescriptor;
    USHORT flags = CmDescriptor->Flags;

    PAGED_CODE();

    if (!(CmDescriptor->u.Dma.Channel & 0xfffffff0)) {
        dmaMask = (UCHAR)(1 << CmDescriptor->u.Dma.Channel);
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    if (!BiosRequirements) {
        dmaDesc->Tag = TAG_DMA | (sizeof(PNP_DMA_DESCRIPTOR) - 1);
        dmaDesc->ChannelMask = dmaMask;
        dmaDesc->Flags = 0;
        if (flags & CM_RESOURCE_DMA_8_AND_16) {
            dmaDesc->Flags += 1;
        } else if (flags & CM_RESOURCE_DMA_16) {
            dmaDesc->Flags += 2;
        }
        if (flags & CM_RESOURCE_DMA_BUS_MASTER) {
            dmaDesc->Flags += 4;
        }
        if (flags & CM_RESOURCE_DMA_TYPE_A) {
            dmaDesc->Flags += 32;
        }
        if (flags & CM_RESOURCE_DMA_TYPE_B) {
            dmaDesc->Flags += 64;
        }
        if (flags & CM_RESOURCE_DMA_TYPE_F) {
            dmaDesc->Flags += 96;
        }
        *Length = sizeof(PNP_DMA_DESCRIPTOR);
        status = STATUS_SUCCESS;
    } else {
        tag = *BiosRequirements;
        while (tag != TAG_COMPLETE_END) {
            if ((tag & SMALL_TAG_MASK) == TAG_DMA) {
                biosDesc = (PPNP_DMA_DESCRIPTOR)BiosRequirements;
                if (biosDesc->ChannelMask & dmaMask) {
                    *Length = (biosDesc->Tag & SMALL_TAG_SIZE_MASK) + 1;
                    RtlMoveMemory(ReturnDescriptor, BiosRequirements, *Length);
                    ((PPNP_DMA_DESCRIPTOR)ReturnDescriptor)->ChannelMask = dmaMask;
                    status = STATUS_SUCCESS;
                    break;
                }
            }

            //
            // Don't-care tag simply advance the buffer pointer to next tag.
            //

            if (tag & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
                increment += 1;     // length of small tag
            }
            BiosRequirements += increment;
            tag = *BiosRequirements;
        }
    }
    return status;
}

NTSTATUS
PbCmPortToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM PORT information to Pnp BIOS format.
    Since there is not enough information in the CM descriptor to
    convert it to Pnp BIOS full function port descriptor.  We will
    convert it to Pnp Bios fixed PORT descriptor.  It is caller's
    responsibility to release the returned data buffer.

Arguments:

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    BiosDescriptor - supplies a variable to receive the buffer which contains
        the desired Bios Port descriptor.

    Length - supplies a variable to receive the size the returned bios port
        descriptor.

    ReturnDescriptor - supplies a buffer to receive the desired Bios Port descriptor.

    Length - Supplies a variable to receive the length of the returned bios descriptor.

Return Value:

    A NTSTATUS code.

--*/
{
    PPNP_PORT_DESCRIPTOR portDesc = (PPNP_PORT_DESCRIPTOR)ReturnDescriptor;
    USHORT minAddr, maxAddr, address;
    UCHAR alignment, length, size, information = 0, tag, returnTag;
    USHORT increment;
    BOOLEAN test = FALSE;

    PAGED_CODE();

    if (CmDescriptor->u.Port.Start.HighPart != 0 ||
        CmDescriptor->u.Port.Start.LowPart & 0xffff0000 ||
        CmDescriptor->u.Port.Length & 0xffffff00) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Search the possible resource list to get the information
    // for the port range described by CmDescriptor.
    //

    address = (USHORT) CmDescriptor->u.Port.Start.LowPart;
    size = (UCHAR) CmDescriptor->u.Port.Length;
    if (!BiosRequirements) {

        //
        // No BiosRequirement.  Use TAG_IO as default.
        //

        portDesc->Tag = TAG_IO | (sizeof(PNP_PORT_DESCRIPTOR) - 1);
        if (CmDescriptor->Flags & CM_RESOURCE_PORT_16_BIT_DECODE) {
            portDesc->Information = 1;
        } else {
            portDesc->Information = 0;
        }
        portDesc->Length = size;
        portDesc->Alignment = 1;
        portDesc->MinimumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
        portDesc->MaximumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
        *Length = sizeof(PNP_PORT_DESCRIPTOR);
    } else {
        returnTag = TAG_END;
        tag = *BiosRequirements;
        minAddr = 0;
        maxAddr = 0;
        alignment = 0;
        while (tag != TAG_COMPLETE_END) {
            test = FALSE;
            switch (tag & SMALL_TAG_MASK) {
            case TAG_IO:
                 minAddr = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->MinimumAddress;
                 alignment = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->Alignment;
                 length = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->Length;
                 maxAddr = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->MaximumAddress;
                 information = ((PPNP_PORT_DESCRIPTOR)BiosRequirements)->Information;
                 test = TRUE;
                 returnTag = TAG_IO;
                 if (!alignment) {
                    if (minAddr == maxAddr) {

                       //
                       // If the max is equal to the min, the alignment is
                       // meaningless. As we told OEMs 0 is appropriate here,
                       // let us handle it.
                       //
                       alignment = 1;
                    }
                 }
                 maxAddr += length - 1;
                 break;
            case TAG_IO_FIXED:
                 length = ((PPNP_FIXED_PORT_DESCRIPTOR)BiosRequirements)->Length;
                 minAddr = ((PPNP_FIXED_PORT_DESCRIPTOR)BiosRequirements)->MinimumAddress;
                 maxAddr = minAddr + length - 1;
                 alignment = 1;
                 information = 0;  // 10 bit decode
                 returnTag = TAG_IO_FIXED;
                 test = TRUE;
                 break;
            }
            if (test) {
                if (minAddr <= address && maxAddr >= (address + size - 1) && !(address & (alignment - 1 ))) {
                    break;
                }
                test = FALSE;
            }

            //
            // Advance to next tag
            //

            if (tag & LARGE_RESOURCE_TAG) {
                increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
                increment += 3;     // length of large tag
            } else {
                increment = (USHORT) tag & SMALL_TAG_SIZE_MASK;
                increment += 1;     // length of small tag
            }
            BiosRequirements += increment;
            tag = *BiosRequirements;
        }
        if (tag == TAG_COMPLETE_END) {
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Set the return port descriptor
        //

        if (returnTag == TAG_IO) {
            portDesc->Tag = TAG_IO + (sizeof(PNP_PORT_DESCRIPTOR) - 1);
            portDesc->Information = information;
            portDesc->Length = size;
            portDesc->Alignment = alignment;
            portDesc->MinimumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
            portDesc->MaximumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
            *Length = sizeof(PNP_PORT_DESCRIPTOR);
        } else {
            PPNP_FIXED_PORT_DESCRIPTOR fixedPortDesc = (PPNP_FIXED_PORT_DESCRIPTOR)ReturnDescriptor;

            fixedPortDesc->Tag = TAG_IO_FIXED + (sizeof(PPNP_FIXED_PORT_DESCRIPTOR) - 1);
            fixedPortDesc->MinimumAddress = (USHORT)CmDescriptor->u.Port.Start.LowPart;
            fixedPortDesc->Length = size;
            *Length = sizeof(PNP_FIXED_PORT_DESCRIPTOR);
        }
    }
    return STATUS_SUCCESS;

}

NTSTATUS
PbCmMemoryToBiosDescriptor (
    IN PUCHAR BiosRequirements,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor,
    OUT PVOID ReturnDescriptor,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine translates CM Memory information to Pnp BIOS format.
    Since there is not enough information in the CM descriptor to
    convert it to Pnp BIOS descriptor.  We will search the Bios
    possible resource lists for the corresponding resource information and
    build a Pnp BIOS memory descriptor from there.  It is caller's responsibility
    to release the returned buffer.

Arguments:

    BiosRequirements - Supplies a pointer to the bios possible resource lists.

    CmDescriptor - supplies a pointer to an CM_PARTIAL_RESOURCE_DESCRIPTOR buffer.

    ReturnDescriptor - supplies a buffer to receive the desired Bios Memory descriptor.

    Length - supplies a variable to receive the size the returned bios port
        descriptor.

Return Value:

    A NTSTATUS code.

--*/
{
    UCHAR tag, information;
    PPNP_FIXED_MEMORY32_DESCRIPTOR memoryDesc = (PPNP_FIXED_MEMORY32_DESCRIPTOR)ReturnDescriptor;
    ULONG address, size, length, minAddr, maxAddr, alignment;
    USHORT increment;
    BOOLEAN test = FALSE;

    PAGED_CODE();

    //
    // Search the possible resource list to get the information
    // for the memory range described by CmDescriptor.
    //

    address = CmDescriptor->u.Memory.Start.LowPart;
    size = CmDescriptor->u.Memory.Length;
    if (!BiosRequirements) {

        //
        // We don't support reserving legacy device's memory ranges from PNP
        // BIOS.  There isn't really any reason why not it just wasn't
        // implemented for Windows 2000.  It isn't near as necessary as it is
        // for I/O ports since ROM memory has a signature and is self
        // describing.
        //

        *Length = 0;
        return STATUS_SUCCESS;
    }
    information = 0;
    tag = *BiosRequirements;
    while (tag != TAG_COMPLETE_END) {
        switch (tag & SMALL_TAG_MASK) {
        case TAG_MEMORY:
             minAddr = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MinimumAddress)) << 8;
             if ((alignment = ((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->Alignment) == 0) {
                 alignment = 0x10000;
             }
             length = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MemorySize)) << 8;
             maxAddr = (((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MaximumAddress)) << 8)
                             + length - 1;
             test = TRUE;
             break;
        case TAG_MEMORY32:
             length = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
             minAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MinimumAddress;
             maxAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MaximumAddress
                             + length - 1;
             alignment = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->Alignment;
             break;
        case TAG_MEMORY32_FIXED:
             length = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
             minAddr = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->BaseAddress;
             maxAddr = minAddr + length - 1;
             alignment = 1;
             test = TRUE;
             break;

        default:

             //
             // Any tag we don't understand is treated as a corrupt list.
             //

             ASSERT (FALSE);
             return STATUS_UNSUCCESSFUL;
        }

        if (test) {
            if (minAddr <= address && maxAddr >= (address + size - 1) && !(address & (alignment - 1 ))) {
                information = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->Information;
                break;
            }
            test = FALSE;
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = (USHORT) tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    if (tag == TAG_COMPLETE_END) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up Pnp BIOS memory descriptor
    //

    memoryDesc->Tag = TAG_MEMORY32_FIXED;
    memoryDesc->Length = sizeof (PNP_FIXED_MEMORY32_DESCRIPTOR);
    memoryDesc->Information = information;
    memoryDesc->BaseAddress = address;
    memoryDesc->MemorySize = size;
    *Length = sizeof(PNP_FIXED_MEMORY32_DESCRIPTOR);
    return STATUS_SUCCESS;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\devices.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    devices.c

Abstract:

    Plug and Play Manager routines dealing with device manipulation/registration.

Author:

    Lonny McMichael (lonnym) 02/14/95

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

typedef struct {
    BOOLEAN Add;
} PROCESS_DRIVER_CONTEXT, *PPROCESS_DRIVER_CONTEXT;

typedef NTSTATUS (*PDEVICE_SERVICE_ITERATOR_ROUTINE)(
    IN PUNICODE_STRING DeviceInstancePath,
    IN PUNICODE_STRING ServiceName,
    IN ULONG ServiceType,
    IN PVOID Context
    );

typedef struct {
    PUNICODE_STRING DeviceInstancePath;
    PDEVICE_SERVICE_ITERATOR_ROUTINE Iterator;
    PVOID Context;
} DEVICE_SERVICE_ITERATOR_CONTEXT, *PDEVICE_SERVICE_ITERATOR_CONTEXT;

//
// Prototype utility functions internal to this file.
//

NTSTATUS
PiFindDevInstMatch(
    IN HANDLE ServiceEnumHandle,
    IN PUNICODE_STRING DeviceInstanceName,
    OUT PULONG InstanceCount,
    OUT PUNICODE_STRING MatchingValueName,
    OUT PULONG MatchingInstance
    );

NTSTATUS PiProcessDriverInstance(
    IN PUNICODE_STRING DeviceInstancePath,
    IN PUNICODE_STRING ServiceName,
    IN ULONG ServiceType,
    IN PPROCESS_DRIVER_CONTEXT Context
    );

NTSTATUS
PpForEachDeviceInstanceDriver(
    PUNICODE_STRING DeviceInstancePath,
    PDEVICE_SERVICE_ITERATOR_ROUTINE IteratorRoutine,
    PVOID Context
    );

NTSTATUS
PiForEachDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PDEVICE_SERVICE_ITERATOR_CONTEXT InternalContext,
    IN ULONG ServiceType
    );

VOID
PiRearrangeDeviceInstances(
    IN HANDLE ServiceEnumHandle,
    IN ULONG InstanceCount,
    IN ULONG InstanceDeleted
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpDeviceRegistration)
#pragma alloc_text(PAGE, PiDeviceRegistration)
#pragma alloc_text(PAGE, PiProcessDriverInstance)
#pragma alloc_text(PAGE, PiFindDevInstMatch)
#pragma alloc_text(PAGE, PpForEachDeviceInstanceDriver)
#pragma alloc_text(PAGE, PiForEachDriverQueryRoutine)
#pragma alloc_text(PAGE, PiRearrangeDeviceInstances)
#endif // ALLOC_PRAGMA

NTSTATUS
PpDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    )

/*++

Routine Description:

    If Add is set to TRUE, this Plug and Play Manager API creates (if necessary)
    and populates the volatile Enum subkey of a device's service list entry, based
    on the device instance path specified.  If Add is set to FALSE, the specified
    device instance will be removed from the volatile Enum subkey of a device's
    service list entry.

    For example, if there is a device in the Enum tree as follows:

    HKLM\System\Enum\PCI
        \foo
            \0000
                Service = REG_SZ bar
            \0001
                Service = REG_SZ other

    The result of the call, PpDeviceRegistration("PCI\foo\0000", Add = TRUE), would be:

    HKLM\CurrentControlSet\Services
        \bar
            \Enum
                Count = REG_DWORD 1
                0 = REG_SZ PCI\foo\0000

Arguments:

    DeviceInstancePath - Supplies the path in the registry (relative to
                         HKLM\CCS\System\Enum) of the device to be registered/deregistered.
                         This path must point to an instance subkey.

    Add - Supplies a BOOLEAN value to indicate the operation is for addition or removal.

    ServiceKeyName - Optionally, supplies the address of a unicode string to
                     receive the name of the registry key for this device
                     instance's service (if one exists).  The caller must
                     release the space once done with it.

Return Value:

    NTSTATUS code indicating whether or not the function was successful

--*/

{

    NTSTATUS Status;

    PAGED_CODE();

    //
    // Acquire PnP device-specific registry resource for exclusive (read/write) access.
    //
    PiLockPnpRegistry(TRUE);

    Status = PiDeviceRegistration(DeviceInstancePath,
                                  Add,
                                  ServiceKeyName);

    PiUnlockPnpRegistry();

    return Status;
}


NTSTATUS
PiDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    )

/*++

Routine Description:

    If Add is set to TRUE, this Plug and Play Manager API creates (if necessary)
    and populates the volatile Enum subkey of a device's service list entry, based
    on the device instance path specified.  If Add is set to FALSE, the specified
    device instance will be removed from the volatile Enum subkey of a device's
    service list entry.

    For example, if there is a device in the Enum tree as follows:

    HKLM\System\Enum\PCI
        \foo
            \0000
                Service = REG_SZ bar
            \0001
                Service = REG_SZ other

    The result of the call, PpDeviceRegistration("PCI\foo\0000", Add = TRUE), would be:

    HKLM\CurrentControlSet\Services
        \bar
            \Enum
                Count = REG_DWORD 1
                0 = REG_SZ PCI\foo\0000

Arguments:

    DeviceInstancePath - Supplies the path in the registry (relative to
                         HKLM\CCS\System\Enum) of the device to be registered/deregistered.
                         This path must point to an instance subkey.

    Add - Supplies a BOOLEAN value to indicate the operation is for addition or removal.

    ServiceKeyName - Optionally, supplies the address of a unicode string to
                     receive the name of the registry key for this device
                     instance's service (if one exists).  The caller must
                     release the space once done with it.

Return Value:

    NTSTATUS code indicating whether or not the function was successful

--*/

{

    NTSTATUS Status;
    UNICODE_STRING ServiceName;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    HANDLE TempKeyHandle;
    HANDLE DeviceInstanceHandle = NULL;

    PAGED_CODE();

    //
    // Assume successful completion.
    //
    Status = STATUS_SUCCESS;

    if (ServiceKeyName) {
        PiWstrToUnicodeString(ServiceKeyName, NULL);
    }

    //
    // 'Normalize' the DeviceInstancePath by stripping off a trailing
    // backslash (if present)
    //

    if (DeviceInstancePath->Length <= sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        goto PrepareForReturn1;
    }

    if (DeviceInstancePath->Buffer[CB_TO_CWC(DeviceInstancePath->Length) - 1] ==
                                                            OBJ_NAME_PATH_SEPARATOR) {
        DeviceInstancePath->Length -= sizeof(WCHAR);
    }

    //
    // Open HKLM\System\CurrentControlSet\Enum
    //
    Status = IopOpenRegistryKeyEx( &TempKeyHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );
    if(!NT_SUCCESS(Status)) {
        goto PrepareForReturn1;
    }

    //
    // Open the specified device instance key under HKLM\CCS\System\Enum
    //

    Status = IopOpenRegistryKeyEx( &DeviceInstanceHandle,
                                   TempKeyHandle,
                                   DeviceInstancePath,
                                   KEY_READ
                                   );
    ZwClose(TempKeyHandle);
    if(!NT_SUCCESS(Status)) {
        goto PrepareForReturn1;
    }

    //
    // Read Service= value entry of the specified device instance key.
    //

    Status = IopGetRegistryValue(DeviceInstanceHandle,
                                 REGSTR_VALUE_SERVICE,
                                 &KeyValueInformation
                                 );
    ZwClose(DeviceInstanceHandle);
    if (NT_SUCCESS(Status)) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength > sizeof(UNICODE_NULL)) {
                IopRegistryDataToUnicodeString(&ServiceName,
                                               (PWSTR)KEY_VALUE_DATA(KeyValueInformation),
                                               KeyValueInformation->DataLength
                                               );
                Status = STATUS_SUCCESS;
                if (ServiceKeyName) {

                    //
                    // If need to return ServiceKeyName, make a copy now.
                    //
                    Status = PipConcatenateUnicodeStrings(  ServiceKeyName,
                                                            &ServiceName,
                                                            NULL);
                }
            }
        }
        ExFreePool(KeyValueInformation);

    } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        //
        // The device instance key may have no Service value entry if the device
        // is raw capable.
        //
        Status = STATUS_SUCCESS;
        goto PrepareForReturn1;
    }

    if (NT_SUCCESS(Status)) {

        PROCESS_DRIVER_CONTEXT context;
        context.Add = Add;

        Status = PpForEachDeviceInstanceDriver(
                    DeviceInstancePath,
                    (PDEVICE_SERVICE_ITERATOR_ROUTINE) PiProcessDriverInstance,
                    &context);

        if(!NT_SUCCESS(Status) && Add) {

            context.Add = FALSE;
            PpForEachDeviceInstanceDriver(DeviceInstancePath,
                                          PiProcessDriverInstance,
                                          &context);
        }
    }

PrepareForReturn1:

    if (!NT_SUCCESS(Status)) {
        if (ServiceKeyName) {
            if (ServiceKeyName->Length != 0) {
                ExFreePool(ServiceKeyName->Buffer);
                ServiceKeyName->Buffer = NULL;
                ServiceKeyName->Length = ServiceKeyName->MaximumLength = 0;
            }
        }
    }

    return Status;
}

NTSTATUS
PiProcessDriverInstance(
    IN PUNICODE_STRING DeviceInstancePath,
    IN PUNICODE_STRING ServiceName,
    IN ULONG ServiceType,
    IN PPROCESS_DRIVER_CONTEXT Context
    )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;

    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = NULL;
    HANDLE ServiceEnumHandle;
    UNICODE_STRING MatchingDeviceInstance;
    UNICODE_STRING TempUnicodeString;
    CHAR UnicodeBuffer[20];
    BOOLEAN UpdateCount = FALSE;
    ULONG Count, instance;

    UNREFERENCED_PARAMETER( ServiceType );

    PAGED_CODE();

    ASSERT(Context != NULL);

    //
    // Next, open the service entry, and volatile Enum subkey
    // under HKLM\System\CurrentControlSet\Services (creating it if it
    // doesn't exist)
    //

    Status = PipOpenServiceEnumKeys(ServiceName,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &ServiceEnumHandle,
                                    TRUE
                                   );
    if(!NT_SUCCESS(Status)) {
        goto PrepareForReturn2;
    }

    //
    // Now, search through the service's existing list of device instances, to see
    // if this instance has previously been registered.
    //

    Status = PiFindDevInstMatch(ServiceEnumHandle,
                                DeviceInstancePath,
                                &Count,
                                &MatchingDeviceInstance,
                                &instance
                                );

    if (!NT_SUCCESS(Status)) {
        goto PrepareForReturn3;
    }

    if (!MatchingDeviceInstance.Buffer) {

        //
        // If we didn't find a match and caller wants to register the device, then we add
        // this instance to the service's Enum list.
        //

        if (Context->Add) {
            PWSTR instancePathBuffer;
            ULONG instancePathLength;
            PWSTR freeBuffer = NULL;

            //
            // Create the value entry and update NextInstance= for the madeup key
            //

            instancePathBuffer = DeviceInstancePath->Buffer;
            instancePathLength = DeviceInstancePath->Length;

            if (instancePathBuffer[instancePathLength / sizeof(WCHAR) - 1] !=
                UNICODE_NULL) {
                freeBuffer = (PWSTR)ExAllocatePool(PagedPool, instancePathLength + sizeof(WCHAR));
                if (freeBuffer) {
                    RtlCopyMemory(freeBuffer,
                                  instancePathBuffer,
                                  instancePathLength
                                  );
                    freeBuffer[instancePathLength / sizeof(WCHAR)] = UNICODE_NULL;
                    instancePathBuffer = freeBuffer;
                    instancePathLength += sizeof(WCHAR);
                }
            }
            PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, Count);
            Status = ZwSetValueKey(
                        ServiceEnumHandle,
                        &TempUnicodeString,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        instancePathBuffer,
                        instancePathLength
                        );
            if (freeBuffer) {
                ExFreePool(freeBuffer);
            }
            Count++;
            UpdateCount = TRUE;
        }
    } else {

        //
        // If we did find a match and caller wants to deregister the device, then we remove
        // this instance from the service's Enum list.
        //
        ASSERT(instance != (ULONG)-1);

        if (Context->Add == FALSE) {

            ZwDeleteValueKey(ServiceEnumHandle, &MatchingDeviceInstance);
            Count--;
            UpdateCount = TRUE;

            //
            // Finally, if Count is not zero we need to physically reorganize the
            // instances under the ServiceKey\Enum key to make them contiguous. We 
            // optimize by simply moving the last value into the empty slot. This behavior
            // is different for .Net Server release from previous releases but we hope
            // that no one depends on the ordering of values in this list. This list in a 
            // way really represents the order in which devices (using this service) were 
            // enumerated.
            //
            if (Count != 0) {

                PiRearrangeDeviceInstances(
                    ServiceEnumHandle,
                    Count,
                    instance
                    );
            }
        }
    }
    if (UpdateCount) {
        PiWstrToUnicodeString(&TempUnicodeString, REGSTR_VALUE_COUNT);
        ZwSetValueKey(
                ServiceEnumHandle,
                &TempUnicodeString,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &Count,
                sizeof(Count)
                );
        PiWstrToUnicodeString(&TempUnicodeString, REGSTR_VALUE_NEXT_INSTANCE);
        ZwSetValueKey(
                ServiceEnumHandle,
                &TempUnicodeString,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &Count,
                sizeof(Count)
                );
    }

    //
    // Need to release the matching device value name
    //

    if (MatchingDeviceInstance.Buffer) {
        RtlFreeUnicodeString(&MatchingDeviceInstance);
    }
    Status = STATUS_SUCCESS;

PrepareForReturn3:

    ZwClose(ServiceEnumHandle);

PrepareForReturn2:

    if (KeyValueInformation) {
        ExFreePool(KeyValueInformation);
    }

    return Status;
}


NTSTATUS
PiFindDevInstMatch(
    IN HANDLE ServiceEnumHandle,
    IN PUNICODE_STRING DeviceInstanceName,
    OUT PULONG Count,
    OUT PUNICODE_STRING MatchingValueName,
    OUT PULONG MatchingInstance
    )

/*++

Routine Description:

    This routine searches through the specified Service\Enum values entries
    for a device instance matching the one specified by KeyInformation.
    If a matching is found, the MatchingValueName is returned and caller must
    free the unicode string when done with it.

Arguments:

    ServiceEnumHandle - Supplies a handle to service enum key.

    DeviceInstanceName - Supplies a pointer to a unicode string specifying the
                         name of the device instance key to search for.

    InstanceCount - Supplies a pointer to a ULONG variable to receive the device
                    instance count under the service enum key.

    MatchingNameFound - Supplies a pointer to a UNICODE_STRING to receive the value
                        name of the matched device instance.

Return Value:

    A NTSTATUS code.  if a matching is found, the MatchingValueName is the unicode
    string of the value name.  Otherwise its length and Buffer will be set to empty.

--*/

{
    NTSTATUS status;
    ULONG i, instanceCount, length = 256, junk;
    UNICODE_STRING valueName, unicodeValue;
    PWCHAR unicodeBuffer;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;

    PAGED_CODE();

    //
    // Find out how many instances are referenced in the service's Enum key.
    //

    MatchingValueName->Length = 0;
    MatchingValueName->Buffer = NULL;
    *Count = instanceCount = 0;
    *MatchingInstance = (ULONG)-1;

    status = IopGetRegistryValue(ServiceEnumHandle,
                                 REGSTR_VALUE_COUNT,
                                 &keyValueInformation
                                );
    if (NT_SUCCESS(status)) {

        if((keyValueInformation->Type == REG_DWORD) &&
           (keyValueInformation->DataLength >= sizeof(ULONG))) {

            instanceCount = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            *Count = instanceCount;
        }
        ExFreePool(keyValueInformation);

    } else if(status != STATUS_OBJECT_NAME_NOT_FOUND) {
        return status;
    } else {

        //
        // If 'Count' value entry not found, consider this to mean there are simply
        // no device instance controlled by this service.  Thus we don't have a match.
        //

        return STATUS_SUCCESS;
    }

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(
                                    PagedPool, length);
    if (!keyValueInformation) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate heap to store value name
    //

    unicodeBuffer = (PWSTR)ExAllocatePool(PagedPool, 10 * sizeof(WCHAR));
    if (!unicodeBuffer) {
        ExFreePool(keyValueInformation);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Next scan thru each value key to find a match
    //

    for (i = 0; i < instanceCount ; i++) {
       PiUlongToUnicodeString(&valueName, unicodeBuffer, 20, i);
       status = ZwQueryValueKey (
                        ServiceEnumHandle,
                        &valueName,
                        KeyValueFullInformation,
                        keyValueInformation,
                        length,
                        &junk
                        );
        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                ExFreePool(keyValueInformation);
                length = junk;
                keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(
                                        PagedPool, length);
                if (!keyValueInformation) {
                    ExFreePool(unicodeBuffer);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                i--;
            }
            continue;
        }

        if (keyValueInformation->Type == REG_SZ) {
            if (keyValueInformation->DataLength > sizeof(UNICODE_NULL)) {
                IopRegistryDataToUnicodeString(&unicodeValue,
                                               (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                               keyValueInformation->DataLength
                                               );
            } else {
                continue;
            }
        } else {
            continue;
        }

        if (RtlEqualUnicodeString(&unicodeValue,
                                  DeviceInstanceName,
                                  TRUE)) {
            //
            // We found a match.
            //
            *MatchingValueName= valueName;
            *MatchingInstance = i;
            break;
        }
    }
    if (keyValueInformation) {
        ExFreePool(keyValueInformation);
    }
    if (MatchingValueName->Length == 0) {

        //
        // If we did not find a match, we need to release the buffer.  Otherwise
        // it is caller's responsibility to release the buffer.
        //

        ExFreePool(unicodeBuffer);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PpForEachDeviceInstanceDriver(
    PUNICODE_STRING DeviceInstancePath,
    PDEVICE_SERVICE_ITERATOR_ROUTINE IteratorRoutine,
    PVOID Context
    )
/*++

Routine Description:

    This routine will call the iterator routine once for each driver listed
    for this particular device instance.  It will walk through any class
    filter drivers and device filter drivers, as well as the service, in the
    order they will be added to the PDO.  If the iterator routine returns
    a failure status at any point the iteration will be terminated.

Arguments:

    DeviceInstancePath - the registry path (relative to CCS\Enum)

    IteratorRoutine - the routine to be called for each service.  This routine
                      will be passed:

                       * The device instance path
                       * The type of driver that this is (filter, service, etc.)
                       * the Context value passed in
                       * The name of the service

    Context - an arbitrary context passed into the iterator routine

Return Value:

    STATUS_SUCCCESS if everything was run across properly

    status if an error occurred opening critical keys or if the iterator
    routine returns an error.

--*/

{
    HANDLE enumKey,instanceKey, classKey, controlKey;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    DEVICE_SERVICE_ITERATOR_CONTEXT internalContext;
    RTL_QUERY_REGISTRY_TABLE queryTable[4];
    NTSTATUS status;
    UNICODE_STRING unicodeClassGuid;


    PAGED_CODE();

    //
    // Open the HKLM\System\CCS\Enum key.
    //

    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Open the instance key for this devnode
    //

    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   DeviceInstancePath,
                                   KEY_READ
                                   );

    ZwClose(enumKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    classKey = NULL;
    status = IopGetRegistryValue(instanceKey,
                                 REGSTR_VALUE_CLASSGUID,
                                 &keyValueInformation);
    if(NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_SZ &&
                keyValueInformation->DataLength) {

            IopRegistryDataToUnicodeString(
                &unicodeClassGuid,
                (PWSTR) KEY_VALUE_DATA(keyValueInformation),
                keyValueInformation->DataLength);
            //
            // Open the class key
            //
            status = IopOpenRegistryKeyEx( &controlKey,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetControlClass,
                                           KEY_READ
                                           );
            if(NT_SUCCESS(status)) {

                status = IopOpenRegistryKeyEx( &classKey,
                                               controlKey,
                                               &unicodeClassGuid,
                                               KEY_READ
                                               );
                ZwClose(controlKey);
            }
        }
        ExFreePool(keyValueInformation);
        keyValueInformation = NULL;
    }

    //
    // For each type of filter driver we want to query for the list and
    // call into our callback routine.  We should do this in order from
    // bottom to top.
    //

    internalContext.Context = Context;
    internalContext.DeviceInstancePath = DeviceInstancePath;
    internalContext.Iterator = IteratorRoutine;

    //
    // First get all the information we have to out of the instance key and
    // the device node.
    //

    if(classKey != NULL) {
        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].QueryRoutine =
            (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
        queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
        queryTable[0].EntryContext = (PVOID) 0;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) classKey,
                                        queryTable,
                                        &internalContext,
                                        NULL);

        if(!NT_SUCCESS(status)) {
            goto PrepareForReturn;
        }
    }

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
    queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
    queryTable[0].EntryContext = (PVOID) 1;

    queryTable[1].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
    queryTable[1].Name = REGSTR_VAL_SERVICE;
    queryTable[1].EntryContext = (PVOID) 2;

    queryTable[2].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
    queryTable[2].Name = REGSTR_VAL_UPPERFILTERS;
    queryTable[2].EntryContext = (PVOID) 3;

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR) instanceKey,
                                    queryTable,
                                    &internalContext,
                                    NULL);

    if(!NT_SUCCESS(status)) {
        goto PrepareForReturn;
    }

    if(classKey != NULL) {

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].QueryRoutine =
            (PRTL_QUERY_REGISTRY_ROUTINE) PiForEachDriverQueryRoutine;
        queryTable[0].Name = REGSTR_VAL_UPPERFILTERS;
        queryTable[0].EntryContext = (PVOID) 4;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) classKey,
                                        queryTable,
                                        &internalContext,
                                        NULL);
        if(!NT_SUCCESS(status)) {
            goto PrepareForReturn;
        }
    }

PrepareForReturn:

    if(classKey != NULL) {
        ZwClose(classKey);
    }

    ZwClose(instanceKey);

    return status;
}

NTSTATUS
PiForEachDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PDEVICE_SERVICE_ITERATOR_CONTEXT InternalContext,
    IN ULONG ServiceType
    )
{
    UNICODE_STRING ServiceName;

    UNREFERENCED_PARAMETER( ValueName );

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    //
    // Make sure the string is a reasonable length.
    // copied directly from IopCallDriverAddDeviceQueryRoutine
    //

    if (ValueLength <= sizeof(WCHAR)) {
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&ServiceName, ValueData);

    return InternalContext->Iterator(
                InternalContext->DeviceInstancePath,
                &ServiceName,
                ServiceType,
                InternalContext->Context);
}

VOID
PiRearrangeDeviceInstances(
    IN HANDLE ServiceEnumHandle,
    IN ULONG InstanceCount,
    IN ULONG InstanceDeleted
    )
{
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    CHAR UnicodeBuffer[20];
    UNICODE_STRING TempUnicodeString;
    ULONG i, j, junk, maxCount;    
    BOOLEAN PreserveOrdering;
    KEY_FULL_INFORMATION keyInfo;
    ULONG tmp;

    PAGED_CODE();

    KeyValueInformation = NULL;
    PreserveOrdering = TRUE;
    maxCount = 0x200;
    Status = ZwQueryKey(
                ServiceEnumHandle, 
                KeyFullInformation, 
                &keyInfo, 
                sizeof(keyInfo), 
                &tmp
                );
    if (NT_SUCCESS(Status) && keyInfo.Values) {

        maxCount = keyInfo.Values;
        if (maxCount > 28) {

            PreserveOrdering = FALSE;
        }
    }

    if (PreserveOrdering == FALSE) {

        //
        // Read the last value.
        //
        PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, InstanceCount);
        Status = IopGetRegistryValue(ServiceEnumHandle,
                                     TempUnicodeString.Buffer,
                                     &KeyValueInformation
                                     );
        if (NT_SUCCESS(Status)) {

            //
            // Delete the last value.
            //
            ZwDeleteValueKey(ServiceEnumHandle, &TempUnicodeString);

            //
            // Set the new value with the instance we just deleted above..
            //
            PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, InstanceDeleted);
            ZwSetValueKey (ServiceEnumHandle,
                           &TempUnicodeString,
                           TITLE_INDEX_VALUE,
                           REG_SZ,
                           (PVOID)KEY_VALUE_DATA(KeyValueInformation),
                           KeyValueInformation->DataLength
                           );

            ExFreePool(KeyValueInformation);
            KeyValueInformation = NULL;
        }

    } else {

        i = j = 0;
        while (j < InstanceCount && i < maxCount) {

            PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, i);
            Status = ZwQueryValueKey( 
                        ServiceEnumHandle,
                        &TempUnicodeString,
                        KeyValueFullInformation,
                        (PVOID)NULL,
                        0,
                        &junk
                        );
            if ((Status != STATUS_OBJECT_NAME_NOT_FOUND) && (Status != STATUS_OBJECT_PATH_NOT_FOUND)) {

                if (i != j) {

                    //
                    // Need to change the instance i to instance j
                    //
                    Status = IopGetRegistryValue(
                                ServiceEnumHandle,
                                TempUnicodeString.Buffer,
                                &KeyValueInformation
                                );
                    if (NT_SUCCESS(Status)) {

                        ZwDeleteValueKey(ServiceEnumHandle, &TempUnicodeString);

                        PiUlongToUnicodeString(&TempUnicodeString, UnicodeBuffer, 20, j);
                        ZwSetValueKey(
                            ServiceEnumHandle,
                            &TempUnicodeString,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            (PVOID)KEY_VALUE_DATA(KeyValueInformation),
                            KeyValueInformation->DataLength
                            );

                        ExFreePool(KeyValueInformation);
                        KeyValueInformation = NULL;

                    } else {

                        IopDbgPrint((
                            IOP_WARNING_LEVEL,
                            "PiRearrangeDeviceInstances: Failed to rearrange device instances %x\n",
                            Status
                            ));
                        break;
                    }
                }
                j++;
            }
            i++;
        }
    }

    //
    // Cleanup.
    //
    if (KeyValueInformation) {

        ExFreePool(KeyValueInformation);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\dockhwp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dock.c

Abstract:


Author:

    Kenneth D. Ray (kenray) Feb 1998

Revision History:

--*/

#include "pnpmgrp.h"
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#include "..\config\cmp.h"
#include <string.h>
#include <profiles.h>
#include <wdmguid.h>

//
// Internal functions to dockhwp.c
//

NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                    * ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT PHANDLE                     NewProfile,
    OUT PBOOLEAN                    ProfileChanged
    );

NTSTATUS
IopExecuteHwpDefaultSelect(
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopExecuteHwpDefaultSelect)
#pragma alloc_text(PAGE, IopExecuteHardwareProfileChange)
#endif // ALLOC_PRAGMA


NTSTATUS
IopExecuteHwpDefaultSelect(
    IN  PCM_HARDWARE_PROFILE_LIST   ProfileList,
    OUT PULONG                      ProfileIndexToUse,
    IN  PVOID                       Context
    )
{
    UNREFERENCED_PARAMETER(ProfileList);
    UNREFERENCED_PARAMETER(Context);

    * ProfileIndexToUse = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                     *ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT HANDLE                     *NewProfile,
    OUT BOOLEAN                    *ProfileChanged
    )
/*++

Routine Description:

    A docking event has occured and now, given a list of Profile Serial Numbers
    that describe the new docking state:
    Transition to the given docking state.
    Set the Current Hardware Profile to based on the new state.
    (Possibly Prompt the user if there is ambiguity)
    Send Removes to those devices that are turned off in this profile,

Arguments:
    Bus - This is the bus that is supplying the hardware profile change.
            (currently only HardwareProfileBusTypeAcpi is supported).

    ProfileSerialNumbers - A list of serial numbers (a list of null terminated
                           UCHAR lists) representing this new docking state.
                           These can be listed in any order, and form a
                           complete representation of the new docking state
    caused by a docking even on the given bus.  A Serial Number string of "\0"
    represents an "undocked state" and should not be listed with any other
    strings.  This list need not be sorted.

    SerialNumbersCount - The number of serial numbers listed.

    NewProfile - a handle to the registry key representing the new hardware
    profile (IE \CCS\HardwareProfiles\Current".)

    ProfileChanged - set to TRUE if new current profile (as a result of this
    docking event, is different that then old current profile.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    ULONG           len;
    ULONG           tmplen;
    ULONG           i, j;
    PWCHAR          tmpStr;
    UNICODE_STRING  tmpUStr;
    PUNICODE_STRING sortedSerials = NULL;

    PPROFILE_ACPI_DOCKING_STATE dockState = NULL;

    IopDbgPrint((   IOP_TRACE_LEVEL,
                    "Execute Profile (BusType %x), (SerialNumCount %x)\n", Bus, SerialNumbersCount));

    //
    // Sort the list of serial numbers
    //
    len = sizeof(UNICODE_STRING) * SerialNumbersCount;
    sortedSerials = ExAllocatePool(NonPagedPool, len);

    if (NULL == sortedSerials) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean;
    }

    for(i=0; i < SerialNumbersCount; i++) {

        RtlInitUnicodeString(&sortedSerials[i], ProfileSerialNumbers[i]);
    }

    //
    // I do not anticipate getting more than a few serial numbers, and I am
    // just lazy enough to write this comment and use a bubble sort.
    //
    for(i = 0; i < SerialNumbersCount; i++) {
        for(j = 0; j < SerialNumbersCount - 1; j++) {

            if (0 < RtlCompareUnicodeString(&sortedSerials[j],
                                            &sortedSerials[j+1],
                                            FALSE)) {

                tmpUStr = sortedSerials[j];
                sortedSerials[j] = sortedSerials[j+1];
                sortedSerials[j+1] = tmpUStr;
            }
        }
    }

    //
    // Construct the DockState ID
    //
    len = 0;
    for(i=0; i < SerialNumbersCount; i++) {

        len += sortedSerials[i].Length;
    }

    len += sizeof(WCHAR); // NULL termination;

    dockState = (PPROFILE_ACPI_DOCKING_STATE) ExAllocatePool(
        NonPagedPool,
        len + sizeof(PROFILE_ACPI_DOCKING_STATE)
        );

    if (NULL == dockState) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Clean;
    }

    for(i = 0, tmpStr = dockState->SerialNumber, tmplen = 0;
        i < SerialNumbersCount;
        i++) {

        tmplen = sortedSerials[i].Length;
        ASSERT(tmplen <= len - ((PCHAR)tmpStr - (PCHAR)dockState->SerialNumber));

        RtlCopyMemory(tmpStr, sortedSerials[i].Buffer, tmplen);
        tmpStr = (PWCHAR)((PCHAR)tmpStr + tmplen);
    }

    *(tmpStr++) = L'\0';

    ASSERT(len == (ULONG) ((PCHAR) tmpStr - (PCHAR) dockState->SerialNumber));
    dockState->SerialLength = (USHORT) len;

    if ((SerialNumbersCount > 1) || (L'\0' !=  dockState->SerialNumber[0])) {

        dockState->DockingState = HW_PROFILE_DOCKSTATE_DOCKED;

    } else {

        dockState->DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
    }

    //
    // Set the new Profile
    //
    switch(Bus) {

        case HardwareProfileBusTypeACPI:

            status = CmSetAcpiHwProfile(
                dockState,
                IopExecuteHwpDefaultSelect,
                NULL,
                NewProfile,
                ProfileChanged
                );

            ASSERT(NT_SUCCESS(status) || (!(*ProfileChanged)));
            break;

        default:
            *ProfileChanged = FALSE;
            status = STATUS_NOT_SUPPORTED;
            goto Clean;
    }

Clean:

    if (NULL != sortedSerials) {

        ExFreePool(sortedSerials);
    }

    if (NULL != dockState) {

        ExFreePool(dockState);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\devintrf.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    devintrf.c

Abstract:

    This module contains APIs and routines for handling Device Interfaces.

Author:


Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Guid related definitions
//

#define GUID_STRING_LENGTH  38
#define GUID_STRING_SIZE    (GUID_STRING_LENGTH * sizeof(WCHAR))

//
// Definitions for IoGetDeviceInterfaces
//

#define INITIAL_INFO_BUFFER_SIZE         512
#define INFO_BUFFER_GROW_SIZE            64
#define INITIAL_SYMLINK_BUFFER_SIZE      1024
#define SYMLINK_BUFFER_GROW_SIZE         128
#define INITIAL_RETURN_BUFFER_SIZE       4096
#define RETURN_BUFFER_GROW_SIZE          512

//
// This should never have to grow, since it accomodates the maximum length of a
// device instance name.
//
#define INITIAL_DEVNODE_NAME_BUFFER_SIZE   \
    (FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + \
        (MAX_DEVICE_ID_LEN * sizeof(WCHAR)))

//
// Definitions for IoOpenDeviceInterfaceRegistryKey
//

#define KEY_STRING_PREFIX                  TEXT("##?#")

//
// Definitions for IoRegisterDeviceInterface
//

#define SEPERATOR_STRING                   TEXT("\\")
#define SEPERATOR_CHAR                     (L'\\')
#define ALT_SEPERATOR_CHAR                 (L'/')
#define REPLACED_SEPERATOR_STRING          TEXT("#")
#define REPLACED_SEPERATOR_CHAR            (L'#')
#define USER_SYMLINK_STRING_PREFIX         TEXT("\\\\?\\")
#define KERNEL_SYMLINK_STRING_PREFIX       TEXT("\\??\\")
#define GLOBAL_SYMLINK_STRING_PREFIX       TEXT("\\GLOBAL??\\")
#define REFSTRING_PREFIX_CHAR              (L'#')

//
// Prototypes
//

NTSTATUS
IopAppendBuffer(
    IN PBUFFER_INFO Info,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
IopBuildSymbolicLinkStrings(
    IN PUNICODE_STRING DeviceString,
    IN PUNICODE_STRING GuidString,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    OUT PUNICODE_STRING UserString,
    OUT PUNICODE_STRING KernelString
    );

NTSTATUS
IopBuildGlobalSymbolicLinkString(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING GlobalString
    );

NTSTATUS
IopDeviceInterfaceKeysFromSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceClassKey     OPTIONAL,
    OUT PHANDLE DeviceInterfaceKey          OPTIONAL,
    OUT PHANDLE DeviceInterfaceInstanceKey  OPTIONAL
    );

NTSTATUS
IopDropReferenceString(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
IopOpenOrCreateDeviceInterfaceSubKeys(
    OUT PHANDLE InterfaceKeyHandle           OPTIONAL,
    OUT PULONG InterfaceKeyDisposition       OPTIONAL,
    OUT PHANDLE InterfaceInstanceKeyHandle   OPTIONAL,
    OUT PULONG InterfaceInstanceDisposition  OPTIONAL,
    IN HANDLE InterfaceClassKeyHandle,
    IN PUNICODE_STRING DeviceInterfaceName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
IopParseSymbolicLinkName(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING PrefixString        OPTIONAL,
    OUT PUNICODE_STRING MungedPathString    OPTIONAL,
    OUT PUNICODE_STRING GuidString          OPTIONAL,
    OUT PUNICODE_STRING RefString           OPTIONAL,
    OUT PBOOLEAN        RefStringPresent    OPTIONAL,
    OUT LPGUID Guid                         OPTIONAL
    );

NTSTATUS
IopReplaceSeperatorWithPound(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
IopSetRegistryStringValue(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN PUNICODE_STRING ValueData
    );

NTSTATUS
PiDeferSetInterfaceState(
    IN PDEVICE_NODE DeviceNode,
    IN PUNICODE_STRING SymbolicLinkName
    );

NTSTATUS
PiRemoveDeferredSetInterfaceState(
    IN PDEVICE_NODE DeviceNode,
    IN PUNICODE_STRING SymbolicLinkName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoGetDeviceInterfaceAlias)
#pragma alloc_text(PAGE, IoGetDeviceInterfaces)
#pragma alloc_text(PAGE, IoOpenDeviceInterfaceRegistryKey)
#pragma alloc_text(PAGE, IoRegisterDeviceInterface)
#pragma alloc_text(PAGE, IoSetDeviceInterfaceState)

#pragma alloc_text(PAGE, IopAllocateBuffer)
#pragma alloc_text(PAGE, IopAllocateUnicodeString)
#pragma alloc_text(PAGE, IopAppendBuffer)
#pragma alloc_text(PAGE, IopBuildSymbolicLinkStrings)
#pragma alloc_text(PAGE, IopBuildGlobalSymbolicLinkString)
#pragma alloc_text(PAGE, IopDeviceInterfaceKeysFromSymbolicLink)
#pragma alloc_text(PAGE, IopDropReferenceString)
#pragma alloc_text(PAGE, IopFreeBuffer)
#pragma alloc_text(PAGE, IopGetDeviceInterfaces)
#pragma alloc_text(PAGE, IopOpenOrCreateDeviceInterfaceSubKeys)
#pragma alloc_text(PAGE, IopParseSymbolicLinkName)
#pragma alloc_text(PAGE, IopProcessSetInterfaceState)
#pragma alloc_text(PAGE, IopRegisterDeviceInterface)
#pragma alloc_text(PAGE, IopRemoveDeviceInterfaces)
#pragma alloc_text(PAGE, IopDisableDeviceInterfaces)
#pragma alloc_text(PAGE, IopReplaceSeperatorWithPound)
#pragma alloc_text(PAGE, IopResizeBuffer)
#pragma alloc_text(PAGE, IopSetRegistryStringValue)
#pragma alloc_text(PAGE, IopUnregisterDeviceInterface)
#pragma alloc_text(PAGE, IopDoDeferredSetInterfaceState)
#pragma alloc_text(PAGE, PiDeferSetInterfaceState)
#pragma alloc_text(PAGE, PiRemoveDeferredSetInterfaceState)

#endif // ALLOC_PRAGMA



NTSTATUS
IopAllocateBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates a buffer of Size bytes and initialises the BUFFER_INFO
    structure so the current position is at the start of the buffer.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the new
           buffer

    Size - The number of bytes to be allocated for the buffer

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PAGED_CODE();

    ASSERT(Info);

    Info->Buffer = ExAllocatePool(PagedPool, Size);
    Info->Current = Info->Buffer;
    if (Info->Buffer == NULL) {

        Info->MaxSize = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Info->MaxSize = Size;

    return STATUS_SUCCESS;
}


NTSTATUS
IopResizeBuffer(
    IN PBUFFER_INFO Info,
    IN ULONG NewSize,
    IN BOOLEAN CopyContents
    )

/*++

Routine Description:

    Allocates a new buffer of NewSize bytes and associates it with Info, freeing 
    the old buffer.  It will optionally copy the data stored in the old buffer 
    into the new buffer and update the current position.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

    NewSize - The new size of the buffer in bytes

    CopyContents - If TRUE indicates that the contents of the old buffer should 
        be copied to the new buffer

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ULONG used;
    PCHAR newBuffer;

    PAGED_CODE();

    ASSERT(Info);

    newBuffer = ExAllocatePool(PagedPool, NewSize);
    if (newBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (CopyContents) {
        //
        // Assert there is room in the buffer
        //
        used = (ULONG)(Info->Current - Info->Buffer);
        ASSERT(used < NewSize);

        RtlCopyMemory(newBuffer, Info->Buffer, used);

        Info->Current = newBuffer + used;

    } else {

        Info->Current = newBuffer;
    }

    ExFreePool(Info->Buffer);

    Info->Buffer = newBuffer;
    Info->MaxSize = NewSize;

    return STATUS_SUCCESS;
}

VOID
IopFreeBuffer(
    IN PBUFFER_INFO Info
    )

/*++

Routine Description:

    Frees the buffer associated with Info and resets all Info fields

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PAGED_CODE();

    ASSERT(Info);

    //
    // Free the buffer
    //
    if (Info->Buffer) {

        ExFreePool(Info->Buffer);
    }

    //
    // Zero out the info parameters so we can't accidently used the free buffer
    //
    Info->Buffer = NULL;
    Info->Current = NULL;
    Info->MaxSize = 0;
}

NTSTATUS
IopAppendBuffer(
    IN PBUFFER_INFO Info,
    IN PVOID Data,
    IN ULONG DataSize
    )

/*++

Routine Description:

    Copies the data to the end of the buffer, resizing if necessary.  The 
    current position is set to the end of the data just added.

Parameters:

    Info - Pointer to a buffer info structure to be used to manage the buffer

    Data - Pointer to the data to be added to the buffer

    DataSize - The size of the data pointed to by Data in bytes

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    ULONG free, used;

    PAGED_CODE();

    ASSERT(Info);

    used = (ULONG)(Info->Current - Info->Buffer);
    free = Info->MaxSize - used;

    if (free < DataSize) {

        status = IopResizeBuffer(Info, used + DataSize, TRUE);

        if (!NT_SUCCESS(status)) {

            return status;
        }
    }

    //
    // Copy the data into the buffer
    //
    RtlCopyMemory(Info->Current, Data, DataSize);

    //
    // Advance down the buffer
    //
    Info->Current += DataSize;

    return status;

}

NTSTATUS
IopGetDeviceInterfaces(
        IN CONST GUID *InterfaceClassGuid,
        IN PUNICODE_STRING DevicePath   OPTIONAL,
        IN ULONG Flags,
        IN BOOLEAN UserModeFormat,
        OUT PWSTR *SymbolicLinkList,
        OUT PULONG SymbolicLinkListSize OPTIONAL
        )

/*++

Routine Description:

    This API allows a WDM driver to get a list of paths that represent all
    devices registered for the specified interface class.

Parameters:

    InterfaceClassGuid - Supplies a pointer to a GUID representing the interface 
        class for whom a list of members is to be retrieved

    DevicePath - Optionally, supplies a pointer to a unicode string containing 
        the enumeration path for a device for whom interfaces of the specified 
        class are to be re-trieved.  If this parameter  is not supplied, then 
        all interface devices (regardless of what physical device exposes them) 
        will be returned.

    Flags - Supplies flags that modify the behavior of list retrieval.
        The following flags are presently defined:

        DEVICE_INTERFACE_INCLUDE_NONACTIVE -- If this flag is specified, then 
            all interface devices, whether currently active or not, will be 
            returned (potentially filtered based on the Physi-calDeviceObject, 
            if specified).

    UserModeFormat - If TRUE the multi-sz returned will have user mode prefixes
        (\\?\) otherwise they will have kernel mode prefixes (\??\).

    SymbolicLinkList - Supplies the address of a character pointer, that on
        success will contain a multi-sz list of \??\ symbolic link
        names that provide the requested functionality.  The caller is
        responsible for freeing the memory via ExFreePool.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING tempString, defaultString;
    UNICODE_STRING guidString, symLinkString, devnodeString;
    BUFFER_INFO returnBuffer, infoBuffer, symLinkBuffer, devnodeNameBuffer;
    PKEY_VALUE_FULL_INFORMATION pDefaultInfo = NULL;
    ULONG keyIndex, instanceKeyIndex, resultSize;
    HANDLE hDeviceClasses, hClass, hKey, hInstanceKey, hControl;
    BOOLEAN defaultPresent = FALSE;

    PAGED_CODE();

    //
    // Initialise out parameters
    //

    *SymbolicLinkList = NULL;

    //
    // Convert the GUID into a string
    //

    status = RtlStringFromGUID(InterfaceClassGuid, &guidString);
    if (!NT_SUCCESS(status)) {
        returnBuffer.Buffer = NULL;
        returnBuffer.MaxSize = 0;
        goto finalClean;
    }

    //
    // Allocate initial buffers
    //

    status = IopAllocateBuffer(&returnBuffer,
                               INITIAL_RETURN_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    status = IopAllocateBuffer(&infoBuffer,
                               INITIAL_INFO_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    status = IopAllocateBuffer(&symLinkBuffer,
                               INITIAL_SYMLINK_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    status = IopAllocateBuffer(&devnodeNameBuffer,
                               INITIAL_DEVNODE_NAME_BUFFER_SIZE
                               );

    if (!NT_SUCCESS(status)) {
        goto clean2a;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry 
    // manipulation portion solves this problem
    //

    PiLockPnpRegistry(TRUE);

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses key
    //

    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopCreateRegistryKeyEx( &hDeviceClasses,
                                     NULL,
                                     &tempString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Open function class GUID key
    //

    status = IopOpenRegistryKeyEx( &hClass,
                                   hDeviceClasses,
                                   &guidString,
                                   KEY_ALL_ACCESS
                                   );
    ZwClose(hDeviceClasses);

    if(status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {

        //
        // The path does not exist - return a single null character buffer
        //

        status = STATUS_SUCCESS;
        goto clean5;
    } else if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Get the default value if it exists
    //

    status = IopGetRegistryValue(hClass,
                                 REGSTR_VAL_DEFAULT,
                                 &pDefaultInfo
                                 );


    if (NT_SUCCESS(status)
        && pDefaultInfo->Type == REG_SZ
        && pDefaultInfo->DataLength >= sizeof(WCHAR)) {

        //
        // We have a default - construct a counted string from the default
        //

        defaultPresent = TRUE;
        defaultString.Buffer = (PWSTR) KEY_VALUE_DATA(pDefaultInfo);
        defaultString.Length = (USHORT) pDefaultInfo->DataLength - sizeof(UNICODE_NULL);
        defaultString.MaximumLength = defaultString.Length;

        //
        // Open the device interface instance key for the default name.
        //
        status = IopOpenOrCreateDeviceInterfaceSubKeys(NULL,
                                                       NULL,
                                                       &hKey,
                                                       NULL,
                                                       hClass,
                                                       &defaultString,
                                                       KEY_READ,
                                                       FALSE
                                                      );

        if (!NT_SUCCESS(status)) {
            defaultPresent = FALSE;
            ExFreePool(pDefaultInfo);
            //
            // Continue with the call but ignore the invalid default entry
            //
        } else {

            //
            // If we are just supposed to return live interfaces, then make sure this default
            // interface is linked.
            //

            if (!(Flags & DEVICE_INTERFACE_INCLUDE_NONACTIVE)) {

                defaultPresent = FALSE;

                //
                // Open the control subkey
                //

                PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &hControl,
                                               hKey,
                                               &tempString,
                                               KEY_ALL_ACCESS
                                               );

                if (NT_SUCCESS(status)) {
                    //
                    // Get the linked value
                    //

                    PiWstrToUnicodeString(&tempString, REGSTR_VAL_LINKED);
                    ASSERT(infoBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
                    status = ZwQueryValueKey(hControl,
                                             &tempString,
                                             KeyValuePartialInformation,
                                             (PVOID) infoBuffer.Buffer,
                                             infoBuffer.MaxSize,
                                             &resultSize
                                             );

                    //
                    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
                    // was not enough room for even the fixed portions of the structure.
                    //
                    ASSERT(status != STATUS_BUFFER_TOO_SMALL);

                    ZwClose(hControl);

                    //
                    // We don't need to check the buffer was big enough because it starts
                    // off that way and doesn't get any smaller!
                    //

                    if (NT_SUCCESS(status)
                        && (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Type == REG_DWORD)
                        && (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->DataLength == sizeof(ULONG))) {

                        defaultPresent = *(PULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Data)
                                       ? TRUE
                                       : FALSE;
                    }
                }
            }

            ZwClose(hKey);

            if(defaultPresent) {
                //
                // Add the default as the first entry in the return buffer and patch to usermode if necessary
                //
                status = IopAppendBuffer(&returnBuffer,
                                         defaultString.Buffer,
                                         defaultString.Length + sizeof(UNICODE_NULL)
                                        );

                if (!UserModeFormat) {

                    RtlCopyMemory(returnBuffer.Buffer,
                                  KERNEL_SYMLINK_STRING_PREFIX,
                                  IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX)
                                  );
                }

            } else {
                //
                // The default device interface isn't active--free the memory for the name buffer now.
                //
                ExFreePool(pDefaultInfo);
            }
        }

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {
        //
        // Do nothing - there is no default
        //
    } else {
        //
        // An unexpected error occured - clean up
        //
        if (NT_SUCCESS(status)) {

            ExFreePool(pDefaultInfo);
            status = STATUS_UNSUCCESSFUL;
        }

        ZwClose(hClass);
        goto clean4;
    }

    //
    // Iterate through the subkeys under this interface class key.
    //
    keyIndex = 0;
    ASSERT(infoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
    while((status = ZwEnumerateKey(hClass,
                                   keyIndex,
                                   KeyBasicInformation,
                                   (PVOID) infoBuffer.Buffer,
                                   infoBuffer.MaxSize,
                                   &resultSize
                                   )) != STATUS_NO_MORE_ENTRIES) {

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (status == STATUS_BUFFER_OVERFLOW) {
            status = IopResizeBuffer(&infoBuffer, resultSize, FALSE);
            continue;
        } else if (!NT_SUCCESS(status)) {
            ZwClose(hClass);
            goto clean4;
        }

        //
        // Open up this interface key.
        //
        tempString.Length = (USHORT) ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->NameLength;
        tempString.MaximumLength = tempString.Length;
        tempString.Buffer = ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->Name;

        //
        // Open the associated key
        //

        status = IopOpenRegistryKeyEx( &hKey,
                                       hClass,
                                       &tempString,
                                       KEY_READ
                                       );

        if (!NT_SUCCESS(status)) {
            //
            // For some reason we couldn't open this key--skip it and move on.
            //
            keyIndex++;
            continue;
        }

        //
        // If we're filtering on a particular PDO, then retrieve the owning device
        // instance name for this interface key, and make sure they match.
        //
        PiWstrToUnicodeString(&tempString, REGSTR_VAL_DEVICE_INSTANCE);
        ASSERT(devnodeNameBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
        while ((status = ZwQueryValueKey(hKey,
                                         &tempString,
                                         KeyValuePartialInformation,
                                         devnodeNameBuffer.Buffer,
                                         devnodeNameBuffer.MaxSize,
                                         &resultSize
                                         )) == STATUS_BUFFER_OVERFLOW) {

            status = IopResizeBuffer(&devnodeNameBuffer, resultSize, FALSE);

            if (!NT_SUCCESS(status)) {
                ZwClose(hKey);
                ZwClose(hClass);
                goto clean4;
            }
        }

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (!(NT_SUCCESS(status)
              && ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->Type == REG_SZ
              && ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->DataLength > sizeof(WCHAR))) {
            goto CloseInterfaceKeyAndContinue;
        }

        //
        // Build counted string
        //

        devnodeString.Length = (USHORT) ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->DataLength - sizeof(UNICODE_NULL);
        devnodeString.MaximumLength = tempString.Length;
        devnodeString.Buffer = (PWSTR) ((PKEY_VALUE_PARTIAL_INFORMATION)(devnodeNameBuffer.Buffer))->Data;

        //
        // Enumerate each interface instance subkey under this PDO's interface key.
        //
        instanceKeyIndex = 0;
        ASSERT(infoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
        while((status = ZwEnumerateKey(hKey,
                                       instanceKeyIndex,
                                       KeyBasicInformation,
                                       (PVOID) infoBuffer.Buffer,
                                       infoBuffer.MaxSize,
                                       &resultSize
                                       )) != STATUS_NO_MORE_ENTRIES) {

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            //
            ASSERT(status != STATUS_BUFFER_TOO_SMALL);

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = IopResizeBuffer(&infoBuffer, resultSize, FALSE);
                continue;
            } else if (!NT_SUCCESS(status)) {
                ZwClose(hKey);
                ZwClose(hClass);
                goto clean4;
            }

            //
            // Open up this interface instance key.
            //
            tempString.Length = (USHORT) ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->NameLength;
            tempString.MaximumLength = tempString.Length;
            tempString.Buffer = ((PKEY_BASIC_INFORMATION)(infoBuffer.Buffer))->Name;

            //
            // Open the associated key
            //

            status = IopOpenRegistryKeyEx( &hInstanceKey,
                                           hKey,
                                           &tempString,
                                           KEY_READ
                                           );

            if (!NT_SUCCESS(status)) {
                //
                // For some reason we couldn't open this key--skip it and move on.
                //
                instanceKeyIndex++;
                continue;
            }

            if (!(Flags & DEVICE_INTERFACE_INCLUDE_NONACTIVE)) {

                //
                // Open the control subkey
                //

                PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &hControl,
                                               hInstanceKey,
                                               &tempString,
                                               KEY_READ
                                               );

                if (!NT_SUCCESS(status)) {

                    //
                    // We have no control subkey so can't be linked -
                    // continue enumerating the keys ignoring this one
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }

                //
                // Get the linked value
                //

                PiWstrToUnicodeString(&tempString, REGSTR_VAL_LINKED);
                ASSERT(infoBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
                status = ZwQueryValueKey(hControl,
                                         &tempString,
                                         KeyValuePartialInformation,
                                         (PVOID) infoBuffer.Buffer,
                                         infoBuffer.MaxSize,
                                         &resultSize
                                         );

                //
                // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
                // was not enough room for even the fixed portions of the structure.
                //
                ASSERT(status != STATUS_BUFFER_TOO_SMALL);

                ZwClose(hControl);

                //
                // We don't need to check the buffer was big enough because it starts
                // off that way and doesn't get any smaller!
                //

                if (!NT_SUCCESS(status)
                    || (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Type != REG_DWORD)
                    || (((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->DataLength != sizeof(ULONG))
                    || !*(PULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)(infoBuffer.Buffer))->Data)) {

                    //
                    // We are NOT linked so continue enumerating the keys ignoring this one
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }
            }

            //
            // Open the "SymbolicLink" value and place the information into the symLink buffer
            //

            PiWstrToUnicodeString(&tempString, REGSTR_VAL_SYMBOLIC_LINK);
            ASSERT(symLinkBuffer.MaxSize >= sizeof(KEY_VALUE_PARTIAL_INFORMATION));
            while ((status = ZwQueryValueKey(hInstanceKey,
                                             &tempString,
                                             KeyValuePartialInformation,
                                             symLinkBuffer.Buffer,
                                             symLinkBuffer.MaxSize,
                                             &resultSize
                                             )) == STATUS_BUFFER_OVERFLOW) {

                status = IopResizeBuffer(&symLinkBuffer, resultSize, FALSE);

                if (!NT_SUCCESS(status)) {
                    ZwClose(hInstanceKey);
                    ZwClose(hKey);
                    ZwClose(hClass);
                    goto clean4;
                }
            }

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            //
            ASSERT(status != STATUS_BUFFER_TOO_SMALL);

            if (!(NT_SUCCESS(status)
                && ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->Type == REG_SZ
                && ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->DataLength > sizeof(WCHAR))) {
                goto CloseInterfaceInstanceKeyAndContinue;
            }

            //
            // Build counted string from value data
            //

            symLinkString.Length = (USHORT) ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->DataLength - sizeof(UNICODE_NULL);
            symLinkString.MaximumLength = symLinkString.Length;
            symLinkString.Buffer = (PWSTR) ((PKEY_VALUE_PARTIAL_INFORMATION)(symLinkBuffer.Buffer))->Data;

            //
            // If we have a default, check this is not it
            //

            if (defaultPresent) {

                if (RtlCompareUnicodeString(&defaultString, &symLinkString, TRUE) == 0) {

                    //
                    // We have already added the default to the beginning of the buffer so skip it
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }
            }

            //
            // If we are only returning interfaces for a particular PDO then check
            // this is from that PDO
            //
            if (ARGUMENT_PRESENT(DevicePath)) {
                //
                // Check if it is from the same PDO
                //
                if (RtlCompareUnicodeString(DevicePath, &devnodeString, TRUE) != 0) {
                    //
                    // If not then go onto the next key
                    //
                    goto CloseInterfaceInstanceKeyAndContinue;
                }
            }

            //
            // Copy the symLink string to the return buffer including the NULL termination
            //

            status = IopAppendBuffer(&returnBuffer,
                                     symLinkString.Buffer,
                                     symLinkString.Length + sizeof(UNICODE_NULL)
                                     );

            ASSERT(((PWSTR) returnBuffer.Current)[-1] == UNICODE_NULL);

            //
            // If we are returning KM strings then patch the prefix
            //

            if (!UserModeFormat) {

                RtlCopyMemory(returnBuffer.Current - (symLinkString.Length + sizeof(UNICODE_NULL)),
                              KERNEL_SYMLINK_STRING_PREFIX,
                              IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX)
                              );
            }

CloseInterfaceInstanceKeyAndContinue:
            ZwClose(hInstanceKey);
            instanceKeyIndex++;
        }

CloseInterfaceKeyAndContinue:
        ZwClose(hKey);
        keyIndex++;
    }

    ZwClose(hClass);

clean5:
    //
    // We've got then all!  Resize to leave space for a terminating NULL.
    //

    status = IopResizeBuffer(&returnBuffer,
                             (ULONG) (returnBuffer.Current - returnBuffer.Buffer + sizeof(UNICODE_NULL)),
                             TRUE
                             );

    if (NT_SUCCESS(status)) {

        //
        // Terminate the buffer
        //
        *((PWSTR) returnBuffer.Current) = UNICODE_NULL;
    }

clean4:
    if (defaultPresent) {
        ExFreePool(pDefaultInfo);
    }

clean3:
    PiUnlockPnpRegistry();
    IopFreeBuffer(&devnodeNameBuffer);

clean2a:
    IopFreeBuffer(&symLinkBuffer);

clean2:
    IopFreeBuffer(&infoBuffer);

clean1:
    if (!NT_SUCCESS(status)) {
        IopFreeBuffer(&returnBuffer);
    }

clean0:
    RtlFreeUnicodeString(&guidString);

finalClean:
    if (NT_SUCCESS(status)) {

        *SymbolicLinkList = (PWSTR) returnBuffer.Buffer;

        if (ARGUMENT_PRESENT(SymbolicLinkListSize)) {
            *SymbolicLinkListSize = returnBuffer.MaxSize;
        }

    } else {

        *SymbolicLinkList = NULL;

        if (ARGUMENT_PRESENT(SymbolicLinkListSize)) {
            *SymbolicLinkListSize = 0;
        }

    }

    return status;
}

NTSTATUS
IoGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN ULONG Flags,
    OUT PWSTR *SymbolicLinkList
    )

/*++

Routine Description:

    This API allows a WDM driver to get a list of paths that represent all
    device interfaces registered for the specified interface class.

Parameters:

    InterfaceClassGuid - Supplies a pointer to a GUID representing the interface 
        class for whom a list of members is to be retrieved

    PhysicalDeviceObject - Optionally, supplies a pointer to the PDO for whom
        interfaces of the specified class are to be re-trieved.  If this 
        parameteris not supplied, then all interface devices (regardless of what 
        physical device exposes them) will be returned.

    Flags - Supplies flags that modify the behavior of list retrieval.
        The following flags are presently defined:

        DEVICE_INTERFACE_INCLUDE_NONACTIVE -- If this flag is specified, then 
            all device interfaces, whether currently active or not, will be 
            returned (potentially filtered based on the PhysicalDeviceObject, if 
            specified).

    SymbolicLinkList - Supplies the address of a character pointer, that on
        success will contain a multi-sz list of \DosDevices\ symbolic link
        names that provide the requested functionality.  The caller is
        responsible for freeing the memory via ExFreePool

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    PUNICODE_STRING pDeviceName = NULL;

    PAGED_CODE();

    //
    // Check we have a PDO and if so extract the instance path from it
    //
    if (ARGUMENT_PRESENT(PhysicalDeviceObject)) {

        ASSERT_PDO(PhysicalDeviceObject);

        pDeviceName = &PP_DO_TO_DN(PhysicalDeviceObject)->InstancePath;
    }

    status = IopGetDeviceInterfaces(
                InterfaceClassGuid,
                pDeviceName,
                Flags,
                FALSE,
                SymbolicLinkList,
                NULL);

    return status;
}

NTSTATUS
IoSetDeviceInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This DDI allows a device class to activate and deactivate an association
    previously registered using IoRegisterDeviceInterface

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name which was
        returned by IoRegisterDeviceInterface when the interface was registered,
        or as returned by IoGetDeviceInterfaces.

    Enable - If TRUE (non-zero), the interface will be enabled.  If FALSE, it
        will be disabled.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry 
    // manipulation portion solves this problem
    //
    PiLockPnpRegistry(TRUE);

    status = IopProcessSetInterfaceState(SymbolicLinkName, Enable, TRUE);

    PiUnlockPnpRegistry();

    if (!NT_SUCCESS(status)) {

        //
        // If we failed to disable an interface (most likely because the
        // interface keys have already been deleted) report success.
        //
        if (!Enable) {

            status = STATUS_SUCCESS;
        }
    }

    return status;
}

NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceKey
    )

/*++

Routine Description:

    This routine will open the registry key where the data associated with a
    specific device interface can be stored.

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name which was
        returned by IoRegisterDeviceInterface when the device class was 
        registered.

    DesiredAccess - Supplies the access privileges to the key the caller wants.

    DeviceInterfaceKey - Supplies a pointer to a handle which on success will
        contain the handle to the requested registry key.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    HANDLE hKey;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry 
    // manipulation portion solves this problem
    //
    PiLockPnpRegistry(TRUE);

    //
    // Open the interface device key
    //
    status = IopDeviceInterfaceKeysFromSymbolicLink(
                SymbolicLinkName,
                KEY_READ,
                NULL,
                NULL,
                &hKey);
    if(NT_SUCCESS(status)) {

        //
        // Open the "Device Parameters" subkey.
        //
        PiWstrToUnicodeString(&unicodeString, REGSTR_KEY_DEVICEPARAMETERS);
        status = IopCreateRegistryKeyEx( 
                    DeviceInterfaceKey,
                    hKey,
                    &unicodeString,
                    DesiredAccess,
                    REG_OPTION_NON_VOLATILE,
                    NULL);

        ZwClose(hKey);
    }

    PiUnlockPnpRegistry();

    return status;
}

NTSTATUS
IopDeviceInterfaceKeysFromSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceClassKey    OPTIONAL,
    OUT PHANDLE DeviceInterfaceKey         OPTIONAL,
    OUT PHANDLE DeviceInterfaceInstanceKey OPTIONAL
    )

/*++

Routine Description:

    This routine will open the registry key where the data associated with the
    device pointed to by SymbolicLinkName is stored.  If the path does not exist
    it will not be created.

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name.

    DesiredAccess - Supplies the access privto the function class instance key 
        the caller wants.

    DeviceInterfaceClassKey - Optionally, supplies the address of a variable 
        that receives a handle to the device class key for the interface.

    DeviceInterfaceKey - Optionally, supplies the address of a variable that 
        receives a handle to the device interface (parent) key.

    DeviceInterfaceInstanceKey - Optionally, Supplies the address of a variable 
        that receives a handle to the device interface instance key (i.e., the
        refstring-specific one).

Return Value:

    Status code that indicates whether or not the function was successful.


--*/

{
    NTSTATUS status;
    UNICODE_STRING guidString, tempString;
    HANDLE hDeviceClasses, hFunctionClass;

    PAGED_CODE();

    //
    // Check that the supplied symbolic link can be parsed to extract the device
    // class guid string - note that this is also a way of verifying that the
    // SymbolicLinkName string is valid.
    //
    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      NULL,
                                      &guidString,
                                      NULL,
                                      NULL,
                                      NULL);
    if(!NT_SUCCESS(status)){
        goto clean0;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry 
    // manipulation portion solves this problem
    //

    PiLockPnpRegistry(TRUE);        

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses key
    //

    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopOpenRegistryKeyEx( &hDeviceClasses,
                                   NULL,
                                   &tempString,
                                   KEY_READ
                                   );

    if( !NT_SUCCESS(status) ){
        goto clean1;
    }

    //
    // Open function class GUID key
    //

    status = IopOpenRegistryKeyEx( &hFunctionClass,
                                   hDeviceClasses,
                                   &guidString,
                                   KEY_READ
                                   );

    if( !NT_SUCCESS(status) ){
        goto clean2;
    }

    //
    // Open device interface instance key
    //
    status = IopOpenOrCreateDeviceInterfaceSubKeys(DeviceInterfaceKey,
                                                   NULL,
                                                   DeviceInterfaceInstanceKey,
                                                   NULL,
                                                   hFunctionClass,
                                                   SymbolicLinkName,
                                                   DesiredAccess,
                                                   FALSE
                                                  );

    if((!NT_SUCCESS(status)) || (!ARGUMENT_PRESENT(DeviceInterfaceClassKey))) {
        ZwClose(hFunctionClass);
    } else {
        *DeviceInterfaceClassKey = hFunctionClass;
    }

clean2:
    ZwClose(hDeviceClasses);
clean1:
    PiUnlockPnpRegistry();
clean0:
    return status;

}

NTSTATUS
IoRegisterDeviceInterface(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    OUT PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This device driver interface allows a WDM driver to register a particular
    interface of its underlying hardware (ie PDO) as a member of a function 
    class.

Parameters:

    PhysicalDeviceObject - Supplies a pointer to the PDO for the P&P device
        instance associated with the functionality being registered

    InterfaceClassGuid - Supplies a pointer to the GUID representring the 
        functionality to be registered

    ReferenceString - Optionally, supplies an additional context string which is
        appended to the enumeration path of the device

    SymbolicLinkName - Supplies a pointer to a string which on success will 
        contain the kernel mode path of the symbolic link used to open this 
        device.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE pDeviceNode;
    PUNICODE_STRING pDeviceString;
    NTSTATUS status;
    PWSTR   pRefString;
    USHORT  count;

    PAGED_CODE();

    //
    // Until PartMgr/Disk stop registering non PDOs allow the system to boot.
    //
    // ASSERT_PDO(PhysicalDeviceObject);
    //

    //
    // Ensure we have a PDO - only PDO's have a device node attached
    //

    pDeviceNode = PP_DO_TO_DN(PhysicalDeviceObject);
    if (pDeviceNode) {

        //
        // Get the instance path string
        //
        pDeviceString = &pDeviceNode->InstancePath;

        if (pDeviceNode->InstancePath.Length == 0) {
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // Make sure the ReferenceString does not contain any path seperator characters
        //
        if (ReferenceString) {
            pRefString = ReferenceString->Buffer;
            count = ReferenceString->Length / sizeof(WCHAR);
            while (count--) {
                if((*pRefString == SEPERATOR_CHAR) || (*pRefString == ALT_SEPERATOR_CHAR)) {
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoRegisterDeviceInterface: Invalid RefString!! failed with status = %8.8X\n", status));
                    return status;
                }
                pRefString++;
            }
        }

        return IopRegisterDeviceInterface(pDeviceString,
                                          InterfaceClassGuid,
                                          ReferenceString,
                                          FALSE,           // kernel-mode format
                                          SymbolicLinkName
                                          );
    } else {

        return STATUS_INVALID_DEVICE_REQUEST;
    }
}

NTSTATUS
IopRegisterDeviceInterface(
    IN PUNICODE_STRING DeviceInstanceName,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    IN BOOLEAN UserModeFormat,
    OUT PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This is the worker routine for IoRegisterDeviceInterface.  It is also
    called by the user-mode ConfigMgr (via an NtPlugPlayControl), which is why it
    must take a device instance name instead of a PDO (since the device instance
    may not currently be 'live'), and also why it must optionally return the user-
    mode form of the interface device name (i.e., "\\?\" instead of "\??\").

Parameters:

    DeviceInstanceName - Supplies the name of the device instance for which a
        device interface is being registered.

    InterfaceClassGuid - Supplies a pointer to the GUID representring the class
        of the device interface being registered.

    ReferenceString - Optionally, supplies an additional context string which is
        appended to the enumeration path of the device

    UserModeFormat - If non-zero, then the symbolic link name returned for the
        interface device is in user-mode form (i.e., "\\?\").  If zero (FALSE),
        it is in kernel-mode form (i.e., "\??\").

    SymbolicLinkName - Supplies a pointer to a string which on success will contain
        either the kernel-mode or user-mode path of the symbolic link used to open
        this device.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING tempString, guidString, otherString;
    PUNICODE_STRING pUserString, pKernelString;
    HANDLE hTemp1, hTemp2, hInterfaceInstanceKey;
    ULONG InterfaceDisposition, InterfaceInstanceDisposition;

    PAGED_CODE();

    //
    // Convert the class guid into string form
    //

    status = RtlStringFromGUID(InterfaceClassGuid, &guidString);
    if( !NT_SUCCESS(status) ){
        goto clean0;
    }

    //
    // Construct both flavors of symbolic link name (go ahead and store the form
    // that the user wants in the SymbolicLinkName parameter they supplied--this
    // saves us from having to copy the appropriate string over to their string
    // later).
    //
    if(UserModeFormat) {
        pUserString = SymbolicLinkName;
        pKernelString = &otherString;
    } else {
        pKernelString = SymbolicLinkName;
        pUserString = &otherString;
    }

    status = IopBuildSymbolicLinkStrings(DeviceInstanceName,
                                         &guidString,
                                         ReferenceString,
                                         pUserString,
                                         pKernelString
                                         );
    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses key into hTemp1
    //

    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopCreateRegistryKeyEx( &hTemp1,
                                     NULL,
                                     &tempString,
                                     KEY_CREATE_SUB_KEY,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if( !NT_SUCCESS(status) ){
        goto clean2;
    }

    //
    // Open/create function class GUID key into hTemp2
    //

    status = IopCreateRegistryKeyEx( &hTemp2,
                                     hTemp1,
                                     &guidString,
                                     KEY_CREATE_SUB_KEY,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );
    ZwClose(hTemp1);

    if( !NT_SUCCESS(status) ){
        goto clean2;
    }

    //
    // Now open/create the two-level device interface hierarchy underneath this
    // interface class key.
    //
    status = IopOpenOrCreateDeviceInterfaceSubKeys(&hTemp1,
                                                   &InterfaceDisposition,
                                                   &hInterfaceInstanceKey,
                                                   &InterfaceInstanceDisposition,
                                                   hTemp2,
                                                   pUserString,
                                                   KEY_WRITE | DELETE,
                                                   TRUE
                                                  );

    ZwClose(hTemp2);

    if(!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Create the device instance value under the device interface key
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_DEVICE_INSTANCE);
    status = IopSetRegistryStringValue(hTemp1,
                                       &tempString,
                                       DeviceInstanceName
                                       );
    if(!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Create symbolic link value under interface instance subkey
    //

    PiWstrToUnicodeString(&tempString, REGSTR_VAL_SYMBOLIC_LINK);
    status = IopSetRegistryStringValue(hInterfaceInstanceKey,
                                       &tempString,
                                       pUserString
                                       );

clean3:
    if (!NT_SUCCESS(status)) {
        //
        // Since we failed to register the device interface, delete any keys
        // that were newly created in the attempt.
        //
        if(InterfaceInstanceDisposition == REG_CREATED_NEW_KEY) {
            ZwDeleteKey(hInterfaceInstanceKey);
        }

        if(InterfaceDisposition == REG_CREATED_NEW_KEY) {
            ZwDeleteKey(hTemp1);
        }
    }

    ZwClose(hInterfaceInstanceKey);
    ZwClose(hTemp1);

clean2:
    PiUnlockPnpRegistry();
    RtlFreeUnicodeString(&otherString);
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(SymbolicLinkName);
    }

clean1:
    RtlFreeUnicodeString(&guidString);
clean0:
    return status;
}

NTSTATUS
IopUnregisterDeviceInterface(
    IN PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine removes the interface instance subkey of
    ReferenceString from the interface for DeviceInstanceName to the
    given InterfaceClassGuid.  If the interface instance specified by
    the Reference String portion of SymbolicLinkName is the only
    instance of the interface, the interface subkey is removed from
    the device class key as well.

Parameters:

    SymbolicLinkName - Supplies a pointer to a unicode string which
        contains the symbolic link name of the device to unregister.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS        status = STATUS_SUCCESS;
    HANDLE          hInterfaceClassKey=NULL, hInterfaceKey=NULL,
                    hInterfaceInstanceKey=NULL, hControl=NULL;
    UNICODE_STRING  tempString, mungedPathString, guidString, refString;
    BOOLEAN         refStringPresent;
    GUID            guid;
    UNICODE_STRING  interfaceKeyName, instanceKeyName;
    ULONG           linked, remainingSubKeys;
    USHORT          length;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PKEY_FULL_INFORMATION keyInformation;

    PAGED_CODE();

    //
    // Check that the supplied symbolic link can be parsed - note that this is
    // also a way of verifying that the SymbolicLinkName string is valid.
    //
    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      &mungedPathString,
                                      &guidString,
                                      &refString,
                                      &refStringPresent,
                                      &guid);
    if (!NT_SUCCESS(status)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Allocate a unicode string for the interface instance key name.
    // (includes the REFSTRING_PREFIX_CHAR, and ReferenceString, if present)
    //
    length = sizeof(WCHAR) + refString.Length;
    status = IopAllocateUnicodeString(&instanceKeyName,
                                      length);
    if(!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Set the MaximumLength of the Buffer, and append the
    // REFSTRING_PREFIX_CHAR to it.
    //
    *instanceKeyName.Buffer = REFSTRING_PREFIX_CHAR;
    instanceKeyName.Length = sizeof(WCHAR);
    instanceKeyName.MaximumLength = length + sizeof(UNICODE_NULL);

    //
    // Append the ReferenceString to the prefix char, if necessary.
    //
    if (refStringPresent) {
        RtlAppendUnicodeStringToString(&instanceKeyName, &refString);
    }

    instanceKeyName.Buffer[instanceKeyName.Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Allocate a unicode string for the interface key name.
    // (includes KEY_STRING_PREFIX, mungedPathString, separating '#'
    //  char, and the guidString)
    //
    length = IopConstStringSize(KEY_STRING_PREFIX) + mungedPathString.Length +
             sizeof(WCHAR) + guidString.Length;

    status = IopAllocateUnicodeString(&interfaceKeyName,
                                      length);
    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    interfaceKeyName.MaximumLength = length + sizeof(UNICODE_NULL);

    //
    // Copy the symbolic link name (without refString) to the interfaceKeyNam
    //
    RtlCopyMemory(interfaceKeyName.Buffer, SymbolicLinkName->Buffer, length);
    interfaceKeyName.Length = length;
    interfaceKeyName.Buffer[interfaceKeyName.Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Replace the "\??\" or "\\?\" symbolic link name prefix with "##?#"
    //
    RtlCopyMemory(interfaceKeyName.Buffer,
                  KEY_STRING_PREFIX,
                  IopConstStringSize(KEY_STRING_PREFIX));

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //
    
    PiLockPnpRegistry(TRUE);

    //
    // Get class, interface, and instance handles
    //
    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_ALL_ACCESS,
                                                    &hInterfaceClassKey,
                                                    &hInterfaceKey,
                                                    &hInterfaceInstanceKey
                                                    );
    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Determine whether this interface is currently "enabled"
    //
    linked = 0;
    PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &hControl,
                                   hInterfaceInstanceKey,
                                   &tempString,
                                   KEY_ALL_ACCESS
                                   );
    if (NT_SUCCESS(status)) {
        //
        // Check the "linked" value under the "Control" subkey of this
        // interface instance
        //
        keyValueInformation=NULL;
        status = IopGetRegistryValue(hControl,
                                     REGSTR_VAL_LINKED,
                                     &keyValueInformation);

        if(NT_SUCCESS(status)) {
            if (keyValueInformation->Type == REG_DWORD &&
                keyValueInformation->DataLength == sizeof(ULONG)) {

                linked = *((PULONG) KEY_VALUE_DATA(keyValueInformation));
                ExFreePool(keyValueInformation);
            }
        }

        ZwClose(hControl);
        hControl = NULL;
    }

    //
    // Ignore any status code returned while attempting to retieve the
    // state of the device.  The value of linked will tell us if we
    // need to disable the interface instance first.
    //
    // If no instance "Control" subkey or "linked" value was present
    //     (status == STATUS_OBJECT_NAME_NOT_FOUND), this interface instance
    //     is not currently enabled -- ok to delete.
    //
    // If the attempt to retrieve these values failed with some other error,
    //     any attempt to disable the interface will also likely fail,
    //     so we'll just have to delete this instance anyways.
    //
    status = STATUS_SUCCESS;

    if (linked) {
        //
        // Disabled the active interface before unregistering it, ignore any
        // status returned, we'll delete this interface instance key anyways.
        //
        IoSetDeviceInterfaceState(SymbolicLinkName, FALSE);
    }

    //
    // Recursively delete the interface instance key, if it exists.
    //
    ZwClose(hInterfaceInstanceKey);
    hInterfaceInstanceKey = NULL;
    IopDeleteKeyRecursive (hInterfaceKey, instanceKeyName.Buffer);

    //
    // Find out how many subkeys to the interface key remain.
    //
    status = IopGetRegistryKeyInformation(hInterfaceKey,
                                          &keyInformation);
    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    remainingSubKeys = keyInformation->SubKeys;

    ExFreePool(keyInformation);

    //
    // See if a volatile "Control" subkey exists under this interface key
    //
    PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &hControl,
                                   hInterfaceKey,
                                   &tempString,
                                   KEY_READ
                                   );
    if (NT_SUCCESS(status)) {
        ZwClose(hControl);
        hControl = NULL;
    }
    if ((remainingSubKeys==0) ||
        ((remainingSubKeys==1) && (NT_SUCCESS(status)))) {
        //
        // If the interface key has no subkeys, or the only the remaining subkey
        // is the volatile interface "Control" subkey, then there are no more
        // instances to this interface.  We should delete the interface key
        // itself also.
        //
        ZwClose(hInterfaceKey);
        hInterfaceKey = NULL;

        IopDeleteKeyRecursive (hInterfaceClassKey, interfaceKeyName.Buffer);
    }

    status = STATUS_SUCCESS;


clean3:
    if (hControl) {
        ZwClose(hControl);
    }
    if (hInterfaceInstanceKey) {
        ZwClose(hInterfaceInstanceKey);
    }
    if (hInterfaceKey) {
        ZwClose(hInterfaceKey);
    }
    if (hInterfaceClassKey) {
        ZwClose(hInterfaceClassKey);
    }

clean2:
    PiUnlockPnpRegistry();

    RtlFreeUnicodeString(&interfaceKeyName);

clean1:
    RtlFreeUnicodeString(&instanceKeyName);

clean0:
    return status;
}

NTSTATUS
IopRemoveDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    )

/*++

Routine Description:

    This routine checks all device class keys under
    HKLM\SYSTEM\CCS\Control\DeviceClasses for interfaces for which the
    DeviceInstance value matches the supplied DeviceInstancePath.  Instances of
    such device interfaces are unregistered, and the device interface subkey
    itself is removed.

    Note that a lock on the registry must have already been acquired,
    by the caller of this routine.

Parameters:

    DeviceInterfacePath - Supplies a pointer to a unicode string which
        contains the DeviceInterface name of the device for which
        interfaces to are to be removed.

Return Value:

    Status code that indicates whether or not the function was
    successful.

--*/

{
    NTSTATUS       status;
    HANDLE         hDeviceClasses=NULL, hClassGUID=NULL, hInterface=NULL;
    UNICODE_STRING tempString, guidString, interfaceString, deviceInstanceString;
    ULONG          resultSize, classIndex, interfaceIndex;
    ULONG          symbolicLinkListSize;
    PWCHAR         symbolicLinkList, symLink;
    BUFFER_INFO    classInfoBuffer, interfaceInfoBuffer;
    PKEY_VALUE_FULL_INFORMATION deviceInstanceInfo;
    BOOLEAN        deletedInterface;
    GUID           classGUID;

    PAGED_CODE();

    //
    // Allocate initial buffers
    //
    status = IopAllocateBuffer(&classInfoBuffer,
                               INITIAL_INFO_BUFFER_SIZE);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    status = IopAllocateBuffer(&interfaceInfoBuffer,
                               INITIAL_INFO_BUFFER_SIZE);
    if (!NT_SUCCESS(status)) {
        IopFreeBuffer(&classInfoBuffer);
        goto clean0;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses
    //
    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopOpenRegistryKeyEx( &hDeviceClasses,
                                   NULL,
                                   &tempString,
                                   KEY_READ
                                   );
    if(!NT_SUCCESS(status)){
        goto clean1;
    }

    //
    // Enumerate all device classes
    //
    classIndex = 0;
    ASSERT(classInfoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
    while((status = ZwEnumerateKey(hDeviceClasses,
                                   classIndex,
                                   KeyBasicInformation,
                                   (PVOID) classInfoBuffer.Buffer,
                                   classInfoBuffer.MaxSize,
                                   &resultSize
                                   )) != STATUS_NO_MORE_ENTRIES) {

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (status == STATUS_BUFFER_OVERFLOW) {
            status = IopResizeBuffer(&classInfoBuffer, resultSize, FALSE);
            continue;
        } else if (!NT_SUCCESS(status)) {
            goto clean1;
        }

        //
        // Get the key name for this device class
        //
        guidString.Length = (USHORT)((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->NameLength;
        guidString.MaximumLength = guidString.Length;
        guidString.Buffer = ((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->Name;

        //
        // Open the key for this device class
        //
        status = IopOpenRegistryKeyEx( &hClassGUID,
                                       hDeviceClasses,
                                       &guidString,
                                       KEY_ALL_ACCESS
                                       );
        if (!NT_SUCCESS(status)) {
            //
            // Couldn't open key for this device class -- skip it and move on.
            //
            goto CloseClassKeyAndContinue;
        }

        //
        // Enumerate all device interfaces for this device class
        //
        interfaceIndex = 0;
        ASSERT(interfaceInfoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
        while((status = ZwEnumerateKey(hClassGUID,
                                       interfaceIndex,
                                       KeyBasicInformation,
                                       (PVOID) interfaceInfoBuffer.Buffer,
                                       interfaceInfoBuffer.MaxSize,
                                       &resultSize
                                       )) != STATUS_NO_MORE_ENTRIES) {

            //
            // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
            // was not enough room for even the fixed portions of the structure.
            //
            ASSERT(status != STATUS_BUFFER_TOO_SMALL);

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = IopResizeBuffer(&interfaceInfoBuffer, resultSize, FALSE);
                continue;
            } else if (!NT_SUCCESS(status)) {
                goto clean1;
            }

            //
            // This interface key has not yet been deleted
            //
            deletedInterface = FALSE;

            //
            // Create a NULL-terminated unicode string for the interface key name
            //
            status = IopAllocateUnicodeString(&interfaceString,
                                              (USHORT)((PKEY_BASIC_INFORMATION)(interfaceInfoBuffer.Buffer))->NameLength);

            if (!NT_SUCCESS(status)) {
                goto clean1;
            }

            interfaceString.Length = (USHORT)((PKEY_BASIC_INFORMATION)(interfaceInfoBuffer.Buffer))->NameLength;
            interfaceString.MaximumLength = interfaceString.Length + sizeof(UNICODE_NULL);
            RtlCopyMemory(interfaceString.Buffer,
                          ((PKEY_BASIC_INFORMATION)(interfaceInfoBuffer.Buffer))->Name,
                          interfaceString.Length);
            interfaceString.Buffer[interfaceString.Length/sizeof(WCHAR)] = UNICODE_NULL;

            //
            // Open the device interface key
            //
            status = IopOpenRegistryKeyEx( &hInterface,
                                           hClassGUID,
                                           &interfaceString,
                                           KEY_ALL_ACCESS
                                           );
            if (!NT_SUCCESS(status)) {
                //
                // Couldn't open the device interface key -- skip it and move on.
                //
                hInterface = NULL;
                goto CloseInterfaceKeyAndContinue;
            }

            //
            // Get the DeviceInstance value for this interface key
            //
            status = IopGetRegistryValue(hInterface,
                                         REGSTR_VAL_DEVICE_INSTANCE,
                                         &deviceInstanceInfo);

            if(!NT_SUCCESS(status)) {
                //
                //  Couldn't get the DeviceInstance for this interface --
                //  skip it and move on.
                //
                goto CloseInterfaceKeyAndContinue;
            }

            if((deviceInstanceInfo->Type == REG_SZ) &&
               (deviceInstanceInfo->DataLength != 0)) {

                IopRegistryDataToUnicodeString(&deviceInstanceString,
                                               (PWSTR)KEY_VALUE_DATA(deviceInstanceInfo),
                                               deviceInstanceInfo->DataLength);

            } else {
                //
                // DeviceInstance value is invalid -- skip it and move on.
                //
                ExFreePool(deviceInstanceInfo);
                goto CloseInterfaceKeyAndContinue;

            }

            //
            // Compare the DeviceInstance of this interface to DeviceInstancePath
            //
            if (RtlEqualUnicodeString(&deviceInstanceString, DeviceInstancePath, TRUE)) {

                ZwClose(hInterface);
                hInterface = NULL;

                //
                // Retrieve all instances of this device interface
                // (active and non-active)
                //
                RtlGUIDFromString(&guidString, &classGUID);

                status = IopGetDeviceInterfaces(&classGUID,
                                                DeviceInstancePath,
                                                DEVICE_INTERFACE_INCLUDE_NONACTIVE,
                                                FALSE,       // kernel-mode format
                                                &symbolicLinkList,
                                                &symbolicLinkListSize);

                if (NT_SUCCESS(status)) {

                    //
                    // Iterate through all instances of the interface
                    //
                    symLink = symbolicLinkList;
                    while(*symLink != UNICODE_NULL) {

                        RtlInitUnicodeString(&tempString, symLink);

                        //
                        // Unregister this instance of the interface.  Since we are
                        // removing the device, ignore any returned status, since
                        // there isn't anything we can do about interfaces which
                        // fail unregistration.
                        //
                        IopUnregisterDeviceInterface(&tempString);

                        symLink += ((tempString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR));
                    }
                    ExFreePool(symbolicLinkList);
                }

                //
                // Recursively delete the interface key, if it still exists.
                // While IopUnregisterDeviceInterface will itself delete the
                // interface key if no interface instance subkeys remain, if any
                // of the above calls to IopUnregisterDeviceInterface failed to
                // delete an interface instance key, subkeys will remain, and
                // the interface key will not have been deleted.  We'll catch
                // that here.
                //
                status = IopOpenRegistryKeyEx( &hInterface,
                                               hClassGUID,
                                               &interfaceString,
                                               KEY_READ
                                               );
                if(NT_SUCCESS(status)){
                    if (NT_SUCCESS(IopDeleteKeyRecursive(hClassGUID,
                                                         interfaceString.Buffer))) {
                        deletedInterface = TRUE;
                    }
                    ZwDeleteKey(hInterface);
                    ZwClose(hInterface);
                    hInterface = NULL;
                } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                    //
                    // Interface was already deleted by IopUnregisterDeviceInterface
                    //
                    deletedInterface = TRUE;
                }
            }

            //
            // Free allocated key info structure
            //
            ExFreePool(deviceInstanceInfo);

CloseInterfaceKeyAndContinue:

            if (hInterface != NULL) {
                ZwClose(hInterface);
                hInterface = NULL;
            }

            RtlFreeUnicodeString(&interfaceString);

            //
            // Only increment the enumeration index for non-deleted keys
            //
            if (!deletedInterface) {
                interfaceIndex++;
            }

        }

CloseClassKeyAndContinue:

        if (hClassGUID != NULL) {
            ZwClose(hClassGUID);
            hClassGUID = NULL;
        }
        classIndex++;
    }

clean1:
    if (hInterface) {
        ZwClose(hInterface);
    }
    if (hClassGUID) {
        ZwClose(hClassGUID);
    }
    if (hDeviceClasses) {
        ZwClose(hDeviceClasses);
    }

    IopFreeBuffer(&interfaceInfoBuffer);
    IopFreeBuffer(&classInfoBuffer);

clean0:
    return status;
}



NTSTATUS
IopDisableDeviceInterfaces(
    IN PUNICODE_STRING DeviceInstancePath
    )
/*++

Routine Description:

    This routine disables all enabled device interfaces for a given device
    instance.  This is typically done after a device has been removed, in case
    the driver did not disable the interfaces for that device, as it should
    have.

    Note that this routine acquires a lock on the registry.

Parameters:

    DeviceInterfacePath - Supplies a pointer to a unicode string which contains
                          the DeviceInterface name of the device for which
                          interfaces to are to be disabled.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING tempString, guidString;
    HANDLE hDeviceClasses = NULL;
    ULONG classIndex, resultSize;
    BUFFER_INFO classInfoBuffer;
    GUID classGuid;
    PWCHAR symbolicLinkList, symLink;
    ULONG symbolicLinkListSize;

    PAGED_CODE();

    //
    // Allocate initial buffer to hold device class GUID subkeys.
    //
    status = IopAllocateBuffer(&classInfoBuffer,
                               sizeof(KEY_BASIC_INFORMATION) +
                               GUID_STRING_SIZE + sizeof(UNICODE_NULL));
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //
    PiLockPnpRegistry(TRUE);

    //
    // Open HKLM\System\CurrentControlSet\Control\DeviceClasses
    //
    PiWstrToUnicodeString(&tempString, REGSTR_FULL_PATH_DEVICE_CLASSES);
    status = IopOpenRegistryKeyEx(&hDeviceClasses,
                                  NULL,
                                  &tempString,
                                  KEY_READ
                                  );
    if (!NT_SUCCESS(status)){
        goto clean0;
    }

    //
    // Enumerate all device classes
    //
    classIndex = 0;
    ASSERT(classInfoBuffer.MaxSize >= sizeof(KEY_BASIC_INFORMATION));
    while((status = ZwEnumerateKey(hDeviceClasses,
                                   classIndex,
                                   KeyBasicInformation,
                                   (PVOID)classInfoBuffer.Buffer,
                                   classInfoBuffer.MaxSize,
                                   &resultSize
                                   )) != STATUS_NO_MORE_ENTRIES) {

        //
        // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
        // was not enough room for even the fixed portions of the structure.
        //
        ASSERT(status != STATUS_BUFFER_TOO_SMALL);

        if (status == STATUS_BUFFER_OVERFLOW) {
            status = IopResizeBuffer(&classInfoBuffer, resultSize, FALSE);
            continue;
        } else if (!NT_SUCCESS(status)) {
            ZwClose(hDeviceClasses);
            goto clean0;
        }

        //
        // Get the key name for this device class
        //
        guidString.Length = (USHORT)((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->NameLength;
        guidString.MaximumLength = guidString.Length;
        guidString.Buffer = ((PKEY_BASIC_INFORMATION)(classInfoBuffer.Buffer))->Name;

        //
        // Retrieve all enabled device interfaces for this device class that are
        // exposed by the given device instance.
        //
        RtlGUIDFromString(&guidString, &classGuid);

        status = IopGetDeviceInterfaces(&classGuid,
                                        DeviceInstancePath,
                                        0,     // active interfaces only
                                        FALSE, // kernel-mode format
                                        &symbolicLinkList,
                                        &symbolicLinkListSize);

        if (NT_SUCCESS(status)) {

            //
            // Iterate through all enabled instances of this device interface
            // members of this device interface class, exposed by the given
            // device instance.
            //
            symLink = symbolicLinkList;
            while(*symLink != UNICODE_NULL) {

                RtlInitUnicodeString(&tempString, symLink);

                IopDbgPrint((IOP_WARNING_LEVEL,
                           "IopDisableDeviceInterfaces: auto-disabling interface %Z for device instance %Z\n",
                           tempString,
                           DeviceInstancePath));

                //
                // Disable this device interface.
                //
                IoSetDeviceInterfaceState(&tempString, FALSE);

                symLink += ((tempString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR));
            }
            ExFreePool(symbolicLinkList);
        }
        classIndex++;
    }

    ZwClose(hDeviceClasses);

 clean0:

    IopFreeBuffer(&classInfoBuffer);

    PiUnlockPnpRegistry();

    return status;
}



NTSTATUS
IopOpenOrCreateDeviceInterfaceSubKeys(
    OUT PHANDLE InterfaceKeyHandle           OPTIONAL,
    OUT PULONG InterfaceKeyDisposition       OPTIONAL,
    OUT PHANDLE InterfaceInstanceKeyHandle   OPTIONAL,
    OUT PULONG InterfaceInstanceDisposition  OPTIONAL,
    IN HANDLE InterfaceClassKeyHandle,
    IN PUNICODE_STRING DeviceInterfaceName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    This API opens or creates a two-level registry hierarchy underneath the
    specified interface class key for a particular device interface.  The first
    level is the (munged) symbolic link name (sans RefString).  The second level
    is the refstring, prepended with a '#' sign (if the device interface has no
    refstring, then this key name is simply '#').

Parameters:

    InterfaceKeyHandle - Optionally, supplies the address of a variable that
        receives a handle to the interface key (1st level in the hierarchy).

    InterfaceKeyDisposition - Optionally, supplies the address of a variable that
        receives either REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY indicating
        whether the interface key was newly-created.

    InterfaceInstanceKeyHandle - Optionally, supplies the address of a variable
        that receives a handle to the interface instance key (2nd level in the
        hierarchy).

    InterfaceInstanceDisposition - Optionally, supplies the address of a variable
        that receives either REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY
        indicating whether the interface instance key was newly-created.

    InterfaceClassKeyHandle - Supplies a handle to the interface class key under
        which the device interface keys are to be opened/created.

    DeviceInterfaceName - Supplies the (user-mode or kernel-mode form) device
        interface name.

    DesiredAccess - Specifies the desired access that the caller needs to the keys.

    Create - Determines if the keys are to be created if they do not exist.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING TempString, RefString;
    WCHAR PoundCharBuffer;
    HANDLE hTempInterface, hTempInterfaceInstance;
    ULONG TempInterfaceDisposition;
    BOOLEAN RefStringPresent=FALSE;

    PAGED_CODE();

    //
    // Make a copy of the device interface name, since we're going to munge it.
    //
    status = IopAllocateUnicodeString(&TempString, DeviceInterfaceName->Length);

    if(!NT_SUCCESS(status)) {
        goto clean0;
    }

    RtlCopyUnicodeString(&TempString, DeviceInterfaceName);

    //
    // Parse the SymbolicLinkName for the refstring component (if there is one).
    // Note that this is also a way of verifying that the string is valid.
    //
    status = IopParseSymbolicLinkName(&TempString,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &RefString,
                                      &RefStringPresent,
                                      NULL);
    ASSERT(NT_SUCCESS(status));

    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    if(RefStringPresent) {
        //
        // Truncate the device interface name before the refstring separator char.
        //
        RefString.Buffer--;
        RefString.Length += sizeof(WCHAR);
        RefString.MaximumLength += sizeof(WCHAR);
        TempString.MaximumLength = TempString.Length = (USHORT)((PUCHAR)RefString.Buffer - (PUCHAR)TempString.Buffer);
    } else {
        //
        // Set up refstring to point to a temporary character buffer that will hold
        // the single '#' used for the key name when no refstring is present.
        //
        RefString.Buffer = &PoundCharBuffer;
        RefString.Length = RefString.MaximumLength = sizeof(PoundCharBuffer);
    }

    //
    // Replace the "\??\" or "\\?\" symbolic link name prefix with ##?#
    //
    RtlCopyMemory(TempString.Buffer, KEY_STRING_PREFIX, IopConstStringSize(KEY_STRING_PREFIX));

    //
    // Munge the string
    //
    IopReplaceSeperatorWithPound(&TempString, &TempString);

    //
    // Now open/create this subkey under the interface class key.
    //

    if (Create) {
        status = IopCreateRegistryKeyEx( &hTempInterface,
                                         InterfaceClassKeyHandle,
                                         &TempString,
                                         DesiredAccess,
                                         REG_OPTION_NON_VOLATILE,
                                         &TempInterfaceDisposition
                                         );
    } else {
        status = IopOpenRegistryKeyEx( &hTempInterface,
                                       InterfaceClassKeyHandle,
                                       &TempString,
                                       DesiredAccess
                                       );

        TempInterfaceDisposition = REG_OPENED_EXISTING_KEY;
    }

    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Store a '#' as the first character of the RefString, and then we're ready to open the
    // refstring subkey.
    //
    *RefString.Buffer = REFSTRING_PREFIX_CHAR;

    //
    // Now open/create the subkey under the interface key representing this interface instance
    // (i.e., differentiated by refstring).
    //

    if (Create) {
        status = IopCreateRegistryKeyEx( &hTempInterfaceInstance,
                                       hTempInterface,
                                       &RefString,
                                       DesiredAccess,
                                       REG_OPTION_NON_VOLATILE,
                                       InterfaceInstanceDisposition
                                       );
    } else {
        status = IopOpenRegistryKeyEx( &hTempInterfaceInstance,
                                       hTempInterface,
                                       &RefString,
                                       DesiredAccess
                                       );
    }

    if (NT_SUCCESS(status)) {
        //
        // Store any requested return values in the caller-supplied buffers.
        //
        if (InterfaceKeyHandle) {
            *InterfaceKeyHandle = hTempInterface;
        } else {
            ZwClose(hTempInterface);
        }
        if (InterfaceKeyDisposition) {
            *InterfaceKeyDisposition = TempInterfaceDisposition;
        }
        if (InterfaceInstanceKeyHandle) {
            *InterfaceInstanceKeyHandle = hTempInterfaceInstance;
        } else {
            ZwClose(hTempInterfaceInstance);
        }
        //
        // (no need to set InterfaceInstanceDisposition--we already set it above)
        //
    } else {
        //
        // If the interface key was newly-created above, then delete it.
        //
        if (TempInterfaceDisposition == REG_CREATED_NEW_KEY) {
            ZwDeleteKey(hTempInterface);
        }
        ZwClose(hTempInterface);
    }

clean1:
    RtlFreeUnicodeString(&TempString);

clean0:
    return status;
}

NTSTATUS
IoGetDeviceInterfaceAlias(
    IN PUNICODE_STRING SymbolicLinkName,
    IN CONST GUID *AliasInterfaceClassGuid,
    OUT PUNICODE_STRING AliasSymbolicLinkName
    )

/*++

Routine Description:

    This API returns a symbolic link name (i.e., device interface) of a
    particular interface class that 'aliases' the specified device interface.
    Two device interfaces are considered aliases of each other if the
    following two criteria are met:

        1.  Both interfaces are exposed by the same PDO (devnode).
        2.  Both interfaces share the same RefString.

Parameters:

    SymbolicLinkName - Supplies the name of the device interface whose alias is
        to be retrieved.

    AliasInterfaceClassGuid - Supplies a pointer to the GUID representing the interface
        class for which an alias is to be retrieved.

    AliasSymbolicLinkName - Supplies a pointer to a string which, upon success,
        will contain the name of the device interface in the specified class that
        aliases the SymbolicLinkName interface.  (This symbolic link name will be
        returned in either kernel-mode or user-mode form, depeding upon the form
        of the SymbolicLinkName path).

        It is the caller's responsibility to free the buffer allocated for this
        string via ExFreePool().

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    HANDLE hKey;
    PKEY_VALUE_FULL_INFORMATION pDeviceInstanceInfo;
    UNICODE_STRING deviceInstanceString, refString, guidString, otherString;
    PUNICODE_STRING pUserString, pKernelString;
    BOOLEAN refStringPresent, userModeFormat;

    PAGED_CODE();

    //
    // Make sure we have a SymbolicLinkName to parse.
    //

    if ((!ARGUMENT_PRESENT(SymbolicLinkName)) ||
        (SymbolicLinkName->Buffer == NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // check that the input buffer really is big enough
    //

    ASSERT(IopConstStringSize(USER_SYMLINK_STRING_PREFIX) == IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX));

    if (SymbolicLinkName->Length < (IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX)+GUID_STRING_SIZE+1)) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Convert the class guid into string form
    //

    status = RtlStringFromGUID(AliasInterfaceClassGuid, &guidString);
    if( !NT_SUCCESS(status) ){
        goto clean0;
    }

    //
    // Enter critical section and acquire a lock on the registry.  Both these
    // mechanisms are required to prevent deadlock in the case where an APC
    // routine calls this routine after the registry resource has been claimed
    // in this case it would wait blocking this thread so the registry would
    // never be released -> deadlock.  Critical sectioning the registry manipulation
    // portion solves this problem
    //

    PiLockPnpRegistry(TRUE);

    //
    // Open the (parent) device interface key--not the refstring-specific one.
    //

    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_READ,
                                                    NULL,
                                                    &hKey,
                                                    NULL
                                                    );
    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Get the name of the device instance that 'owns' this interface.
    //

    status = IopGetRegistryValue(hKey, REGSTR_VAL_DEVICE_INSTANCE, &pDeviceInstanceInfo);

    ZwClose(hKey);

    if(!NT_SUCCESS(status)) {
        goto clean1;
    }

    if(pDeviceInstanceInfo->Type == REG_SZ) {

        IopRegistryDataToUnicodeString(&deviceInstanceString,
                                       (PWSTR)KEY_VALUE_DATA(pDeviceInstanceInfo),
                                       pDeviceInstanceInfo->DataLength
                                      );

    } else {

        status = STATUS_INVALID_PARAMETER_1;
        goto clean2;

    }

    //
    // Now parse out the refstring, so that we can construct the name of the interface device's
    // alias.  (NOTE: we have not yet verified that the alias actually exists, we're only
    // constructing what its name would be, if it did exist.)
    //
    // Don't bother to check the return code.  If this were a bad string, we'd have already
    // failed above when we called IopDeviceInterfaceKeysFromSymbolicLink (since it also
    // calls IopParseSymbolicLinkName internally.)
    //
    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &refString,
                                      &refStringPresent,
                                      NULL);
    ASSERT(NT_SUCCESS(status));

    //
    // Did the caller supply us with a user-mode or kernel-mode format path?
    //
    userModeFormat = (BOOLEAN)(IopConstStringSize(USER_SYMLINK_STRING_PREFIX) ==
                          RtlCompareMemory(SymbolicLinkName->Buffer,
                                           USER_SYMLINK_STRING_PREFIX,
                                           IopConstStringSize(USER_SYMLINK_STRING_PREFIX)
                                          ));

    if(userModeFormat) {
        pUserString = AliasSymbolicLinkName;
        pKernelString = &otherString;
    } else {
        pKernelString = AliasSymbolicLinkName;
        pUserString = &otherString;
    }

    status = IopBuildSymbolicLinkStrings(&deviceInstanceString,
                                         &guidString,
                                         refStringPresent ? &refString : NULL,
                                         pUserString,
                                         pKernelString
                                         );
    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // OK, we now have the symbolic link name of the alias, but we don't yet 
    // know whether it actually exists.  Check this by attempting to open the 
    // associated registry key.
    //
    status = IopDeviceInterfaceKeysFromSymbolicLink(AliasSymbolicLinkName,
                                                    KEY_READ,
                                                    NULL,
                                                    NULL,
                                                    &hKey
                                                    );

    if(NT_SUCCESS(status)) {
        //
        // Alias exists--close the key handle.
        //
        ZwClose(hKey);
    } else {
        RtlFreeUnicodeString(AliasSymbolicLinkName);
    }

    RtlFreeUnicodeString(&otherString);

clean2:
    ExFreePool(pDeviceInstanceInfo);

clean1:
    PiUnlockPnpRegistry();
    RtlFreeUnicodeString(&guidString);

clean0:
    return status;
}

NTSTATUS
IopBuildSymbolicLinkStrings(
    IN PUNICODE_STRING DeviceString,
    IN PUNICODE_STRING GuidString,
    IN PUNICODE_STRING ReferenceString      OPTIONAL,
    OUT PUNICODE_STRING UserString,
    OUT PUNICODE_STRING KernelString
)
/*++

Routine Description:

    This routine will construct various strings used in the registration of
    function device class associations (IoRegisterDeviceClassAssociation).
    The specific strings are detailed below

Parameters:

    DeviceString - Supplies a pointer to the instance path of the device.
        It is of the form <Enumerator>\<Device>\<Instance>.

    GuidString - Supplies a pointer to the string representation of the
        function class guid.

    ReferenceString - Supplies a pointer to the reference string for the given
        device to exhibit the given function.  This is optional

    UserString - Supplies a pointer to an uninitialised string which on success
        will contain the string to be assigned to the "SymbolicLink" value under the
        KeyString.  It is of the format \\?\<MungedDeviceString>\<GuidString>\<Reference>
        When no longer required it should be freed using RtlFreeUnicodeString.

    KernelString - Supplies a pointer to an uninitialised string which on success
        will contain the kernel mode path of the device and is of the format
        \??\<MungedDeviceString>\<GuidString>\<Reference>. When no longer required it
        should be freed using RtlFreeUnicodeString.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    USHORT length;
    UNICODE_STRING mungedDeviceString;

    PAGED_CODE();

    //
    // The code is optimised to use the fact that \\.\ and \??\ are the same size - if
    // these prefixes change then we need to change the code.
    //

    ASSERT(IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) == IopConstStringSize(USER_SYMLINK_STRING_PREFIX));

    //
    // Calculate the lengths of the strings
    //

    length = IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) + DeviceString->Length +
             IopConstStringSize(REPLACED_SEPERATOR_STRING) + GuidString->Length;

    if(ARGUMENT_PRESENT(ReferenceString) && (ReferenceString->Length != 0)) {
        length += IopConstStringSize(SEPERATOR_STRING) + ReferenceString->Length;
    }

    //
    // Allocate space for the strings
    //

    status = IopAllocateUnicodeString(KernelString, length);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    status = IopAllocateUnicodeString(UserString, length);
    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Allocate a temporary string to hold the munged device string
    //

    status = IopAllocateUnicodeString(&mungedDeviceString, DeviceString->Length);
    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Copy and munge the device string
    //

    status = IopReplaceSeperatorWithPound(&mungedDeviceString, DeviceString);
    if (!NT_SUCCESS(status)) {
        goto clean3;
    }

    //
    // Construct the user mode string
    //

    RtlAppendUnicodeToString(UserString, USER_SYMLINK_STRING_PREFIX);
    RtlAppendUnicodeStringToString(UserString, &mungedDeviceString);
    RtlAppendUnicodeToString(UserString, REPLACED_SEPERATOR_STRING);
    RtlAppendUnicodeStringToString(UserString, GuidString);

    if (ARGUMENT_PRESENT(ReferenceString) && (ReferenceString->Length != 0)) {
        RtlAppendUnicodeToString(UserString, SEPERATOR_STRING);
        RtlAppendUnicodeStringToString(UserString, ReferenceString);
    }

    ASSERT( UserString->Length == length );

    //
    // Construct the kernel mode string by replacing the prefix on the value 
    // string.
    //
    RtlCopyUnicodeString(KernelString, UserString);
    RtlCopyMemory(
        KernelString->Buffer,
        KERNEL_SYMLINK_STRING_PREFIX,
        IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX));

clean3:
    RtlFreeUnicodeString(&mungedDeviceString);

clean2:
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(UserString);
    }

clean1:
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(KernelString);
    }

clean0:
    return status;
}

NTSTATUS
IopReplaceSeperatorWithPound(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine will copy a string from InString to OutString replacing any 
    occurence of '\' or '/' with '#' as it goes.

Parameters:

    OutString - Supplies a pointer to a string which has already been 
        initialised to have a buffer large enough to accomodate the string. The 
        contents of this string will be over written

    InString - Supplies a pointer to the string to be munged

Return Value:

    Status code that indicates whether or not the function was successful.

Remarks:

    In place munging can be performed - ie. the In and Out strings can be the 
    same.

--*/

{
    PWSTR pInPosition, pOutPosition;
    USHORT count;

    PAGED_CODE();

    ASSERT(InString);
    ASSERT(OutString);

    //
    // Ensure we have enough space in the output string
    //
    if(InString->Length > OutString->MaximumLength) {

        return STATUS_BUFFER_TOO_SMALL;
    }

    pInPosition = InString->Buffer;
    pOutPosition = OutString->Buffer;
    count = CB_TO_CWC(InString->Length);

    //
    // Traverse the in string copying and replacing all occurences of '\' or '/'
    // with '#'
    //
    while (count--) {

        if( (*pInPosition == SEPERATOR_CHAR) || 
            (*pInPosition == ALT_SEPERATOR_CHAR)) {

            *pOutPosition = REPLACED_SEPERATOR_CHAR;
        } else {

            *pOutPosition = *pInPosition;
        }
        pInPosition++;
        pOutPosition++;
    }

    OutString->Length = InString->Length;

    return STATUS_SUCCESS;
}

NTSTATUS
IopDropReferenceString(
    OUT PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine removes the reference string from a symbolic link name.  No 
    space is allocated for the out string so no attempt should be made to free 
    the buffer of OutString.

Parameters:

    SymbolicLinkName - Supplies a pointer to a symbolic link name string.
        Both the prefixed strings are valid.

    GuidReferenceString - Supplies a pointer to an uninitialised string which on
        success will contain the symbolic link name without the reference string.
        See the note on storage allocation above.

Return Value:

    Status code that indicates whether or not the function was successful.

Remarks:

    The string returned in OutString is dependant on the buffer of
    InString and is only valid as long as InString is valid.

--*/

{
    UNICODE_STRING refString;
    NTSTATUS status;
    BOOLEAN refStringPresent;

    PAGED_CODE();

    ASSERT(InString);
    ASSERT(OutString);

    //
    // Parse the SymbolicLinkName for the refstring component (if there is one).
    // Note that this is also a way of verifying that the string is valid.
    //
    status = IopParseSymbolicLinkName(
                InString,
                NULL,
                NULL,
                NULL,
                &refString,
                &refStringPresent,
                NULL);
    if (NT_SUCCESS(status)) {

        //
        // The refstring is always at the end, so just use the same buffer and
        // set the length of the output string accordingly.
        //
        OutString->Buffer = InString->Buffer;

        //
        // If we have a refstring then subtract it's length
        //
        OutString->Length = InString->Length;
        if (refStringPresent) {

            OutString->Length -= refString.Length + sizeof(WCHAR);
        }
    } else {

        //
        // Invalidate the returned string
        //
        OutString->Buffer = NULL;
        OutString->Length = 0;
    }

    OutString->MaximumLength = OutString->Length;

    return status;
}

NTSTATUS
IopBuildGlobalSymbolicLinkString(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING GlobalString
    )
/*++

Routine Description:

    This routine will construct the global symbolic link name for the given
    kernel-mode or user-mode relative symbolic link name.

Parameters:

    SymbolicLinkName - Supplies a pointer to a symbolic link name string.
        Both the kernel-mode and user-mode prefixed strings are valid.

    GlobalString - Supplies a pointer to an uninitialised string which on
        success will contain the string that represents the symbolic link
        withing the global namespace.  It is of the format
        \GLOBAL??\<MungedDeviceString>\<GuidString>\<Reference>. When no longer
        required it should be freed using RtlFreeUnicodeString.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    USHORT length;
    UNICODE_STRING tempString;

    PAGED_CODE();

    //
    // The code is optimised to use the fact that \\.\ and \??\ are the same
    // size, and that since we are replacing the prefix, the routine can take
    // either one.  If these prefixes change then we need to change the code.
    //

    ASSERT(IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) == IopConstStringSize(USER_SYMLINK_STRING_PREFIX));

    //
    // Make sure the supplied SymbolicLinkName string begins with either the
    // kernel or user symbolic link prefix.  If it does not have a \\?\ or \??\
    // prefix then fail.
    //

    if ((RtlCompareMemory(SymbolicLinkName->Buffer,
                          USER_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(USER_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(USER_SYMLINK_STRING_PREFIX)) &&
        (RtlCompareMemory(SymbolicLinkName->Buffer,
                          KERNEL_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))) {
        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    //
    // Compute the length of the global symbolic link string.
    //

    length = SymbolicLinkName->Length - IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) +
             IopConstStringSize(GLOBAL_SYMLINK_STRING_PREFIX);

    //
    // Allocate space for the strings.
    //

    status = IopAllocateUnicodeString(GlobalString, length);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Copy the \GLOBAL?? symbolic link name prefix to the string.
    //

    status = RtlAppendUnicodeToString(GlobalString,
                                      GLOBAL_SYMLINK_STRING_PREFIX);
    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(GlobalString);
        goto clean0;
    }

    //
    // Append the part of the SymbolicLinkName that follows the prefix.
    //

    tempString.Buffer = SymbolicLinkName->Buffer +
        IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);
    tempString.Length = SymbolicLinkName->Length -
        IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX);
    tempString.MaximumLength = SymbolicLinkName->MaximumLength -
        IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX);

    status = RtlAppendUnicodeStringToString(GlobalString, &tempString);

    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(GlobalString);
        goto clean0;
    }

    ASSERT(GlobalString->Length == length);

clean0:

    return status;
}

NTSTATUS
IopParseSymbolicLinkName(
    IN  PUNICODE_STRING SymbolicLinkName,
    OUT PUNICODE_STRING PrefixString        OPTIONAL,
    OUT PUNICODE_STRING MungedPathString    OPTIONAL,
    OUT PUNICODE_STRING GuidString          OPTIONAL,
    OUT PUNICODE_STRING RefString           OPTIONAL,
    OUT PBOOLEAN        RefStringPresent    OPTIONAL,
    OUT LPGUID Guid                         OPTIONAL
    )

/*++

Routine Description:

    This routine breaks apart a symbolic link name constructed by
    IopBuildSymbolicLinkNames.  Both formats of name are valid - user
    mode \\?\ and kernel mode \??\.

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name to
        be analysed.

    PrefixString - Optionally contains a pointer to a string which will contain
        the prefix of the string.

    MungedPathString - Optionally contains a pointer to a string which will contain
        the enumeration path of the device with all occurences of '\' replaced with '#'.

    GuidString - Optionally contains a pointer to a string which will contain
        the device class guid in string format from the string.

    RefString - Optionally contains a pointer to a string which will contain
        the refstring of the string if one is present, otherwise it is undefined.

    RefStringPresent - Optionally contains a pointer to a boolean value which will
        be set to true if a refstring is present.

    Guid - Optionally contains a pointer to a guid which will contain
        the function class guid of the string.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR pCurrent;
    USHORT current, path, guid, reference = 0;
    UNICODE_STRING tempString;
    GUID tempGuid;
    BOOLEAN haveRefString;

    PAGED_CODE();

    //
    // Make sure we have a SymbolicLinkName to parse.
    //
    if (    !ARGUMENT_PRESENT(SymbolicLinkName) ||
            SymbolicLinkName->Buffer == NULL    ||
            SymbolicLinkName->Length == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // check that the input buffer really is big enough
    //
    ASSERT(IopConstStringSize(USER_SYMLINK_STRING_PREFIX) == IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX));

    if (SymbolicLinkName->Length < (IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX) + GUID_STRING_SIZE + 1)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sanity check on the incoming string - if it does not have a \\?\ or \??\ prefix then fail
    //
    if ((RtlCompareMemory(SymbolicLinkName->Buffer,
                          USER_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(USER_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(USER_SYMLINK_STRING_PREFIX)) &&
        (RtlCompareMemory(SymbolicLinkName->Buffer,
                          KERNEL_SYMLINK_STRING_PREFIX,
                          IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))
         != IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX))) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Break apart the string into it's constituent parts
    //
    path = IopConstStringSize(USER_SYMLINK_STRING_PREFIX) + 1;

    //
    // Find the '\' seperator
    //
    pCurrent = SymbolicLinkName->Buffer + IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);

    for (   current = 0;
            current < (SymbolicLinkName->Length / sizeof(WCHAR)) - IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);
            current++, pCurrent++) {

        if(*pCurrent == SEPERATOR_CHAR) {

            reference = current + 1 + IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);
            break;
        }
    }

    //
    // If we don't have a reference string fake it to where it would have been
    //
    if (reference == 0) {

        haveRefString = FALSE;
        reference = SymbolicLinkName->Length / sizeof(WCHAR) + 1;
    } else {

        haveRefString = TRUE;
    }

    //
    // Check the guid looks plausable
    //
    tempString.Length = GUID_STRING_SIZE;
    tempString.MaximumLength = GUID_STRING_SIZE;
    tempString.Buffer = SymbolicLinkName->Buffer + reference - GUID_STRING_LENGTH - 1;

    if (!NT_SUCCESS(RtlGUIDFromString(&tempString, &tempGuid))) {

        status = STATUS_INVALID_PARAMETER;
        goto clean0;
    }

    guid = reference - GUID_STRING_LENGTH - 1;

    //
    // Setup return strings
    //
    if (ARGUMENT_PRESENT(PrefixString)) {

        PrefixString->Length = IopConstStringSize(KERNEL_SYMLINK_STRING_PREFIX);
        PrefixString->MaximumLength = PrefixString->Length;
        PrefixString->Buffer = SymbolicLinkName->Buffer;
    }

    if (ARGUMENT_PRESENT(MungedPathString)) {

        MungedPathString->Length = (reference - 1 - GUID_STRING_LENGTH - 1 -
                                   IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX)) *
                                   sizeof(WCHAR);
        MungedPathString->MaximumLength = MungedPathString->Length;
        MungedPathString->Buffer = SymbolicLinkName->Buffer +
                                   IopConstStringLength(KERNEL_SYMLINK_STRING_PREFIX);

    }

    if (ARGUMENT_PRESENT(GuidString)) {

        GuidString->Length = GUID_STRING_SIZE;
        GuidString->MaximumLength = GuidString->Length;
        GuidString->Buffer = SymbolicLinkName->Buffer + reference -
                             GUID_STRING_LENGTH - 1;
    }

    if (ARGUMENT_PRESENT(RefString)) {

        //
        // Check if we have a refstring
        //
        if (haveRefString) {

            RefString->Length = SymbolicLinkName->Length - (reference * sizeof(WCHAR));
            RefString->MaximumLength = RefString->Length;
            RefString->Buffer = SymbolicLinkName->Buffer + reference;
        } else {

            RefString->Length = 0;
            RefString->MaximumLength = 0;
            RefString->Buffer = NULL;
        }
    }

    if (ARGUMENT_PRESENT(RefStringPresent)) {

        *RefStringPresent = haveRefString;
    }

    if(ARGUMENT_PRESENT(Guid)) {

        *Guid = tempGuid;
    }

clean0:

    return status;

}

NTSTATUS
IopProcessSetInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable,
    IN BOOLEAN DeferNotStarted
    )
/*++

Routine Description:

    This DDI allows a device class to activate and deactivate an association
    previously registered using IoRegisterDeviceInterface

Parameters:

    SymbolicLinkName - Supplies a pointer to the symbolic link name which was
        returned by IoRegisterDeviceInterface when the interface was registered,
        or as returned by IoGetDeviceInterfaces.

    Enable - If TRUE (non-zero), the interface will be enabled.  If FALSE, it
        will be disabled.

    DeferNotStarted - If TRUE then enables will be queued if the PDO isn't
        started.  It is FALSE when we've started the PDO and are processing the
        queued enables.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    HANDLE hInterfaceClassKey = NULL;
    HANDLE hInterfaceParentKey= NULL, hInterfaceInstanceKey = NULL;
    HANDLE hInterfaceParentControl = NULL, hInterfaceInstanceControl = NULL;
    UNICODE_STRING tempString, deviceNameString;
    UNICODE_STRING actualSymbolicLinkName, globalSymbolicLinkName;
    PKEY_VALUE_FULL_INFORMATION pKeyValueInfo;
    ULONG linked, refcount;
    GUID guid;
    PDEVICE_OBJECT physicalDeviceObject;
    PWCHAR deviceNameBuffer = NULL;
    ULONG deviceNameBufferLength;

    PAGED_CODE();

    //
    // Check that the supplied symbolic link can be parsed to extract the device
    // class guid - note that this is also a way of verifying that the
    // SymbolicLinkName string is valid.
    //

    status = IopParseSymbolicLinkName(SymbolicLinkName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &guid);
    if (!NT_SUCCESS(status)) {
        goto clean0;
    }

    //
    // Get the symbolic link name without the ref string.
    //
    status = IopDropReferenceString(&actualSymbolicLinkName, SymbolicLinkName);
    if (!NT_SUCCESS(status)) {

        goto clean0;
    }

    //
    // Symbolic links created for device interfaces should be visible to all
    // users, in all sessions, so we need to contruct an absolute name for
    // symbolic link in the global DosDevices namespace '\GLOBAL??'.  This
    // ensures that a global symbolic link will always be created or deleted by
    // IoSetDeviceInterfaceState, no matter what context it is called in.
    //
    status = IopBuildGlobalSymbolicLinkString(&actualSymbolicLinkName,
                                              &globalSymbolicLinkName);
    if (!NT_SUCCESS(status)) {

        goto clean0;
    }

    //
    // Get function class instance handle
    //
    status = IopDeviceInterfaceKeysFromSymbolicLink(SymbolicLinkName,
                                                    KEY_READ | KEY_WRITE,
                                                    &hInterfaceClassKey,
                                                    &hInterfaceParentKey,
                                                    &hInterfaceInstanceKey
                                                    );

    if (!NT_SUCCESS(status)) {
        goto clean1;
    }

    //
    // Open the parent interface control subkey
    //
    PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
    status = IopCreateRegistryKeyEx( &hInterfaceParentControl,
                                     hInterfaceParentKey,
                                     &tempString,
                                     KEY_READ,
                                     REG_OPTION_VOLATILE,
                                     NULL
                                     );
    if (!NT_SUCCESS(status)) {
        goto clean1;
    }


    //
    // Find out the name of the device instance that 'owns' this interface.
    //
    status = IopGetRegistryValue(hInterfaceParentKey,
                                 REGSTR_VAL_DEVICE_INSTANCE,
                                 &pKeyValueInfo
                                 );

    if(NT_SUCCESS(status)) {
        //
        // Open the device instance control subkey
        //
        PiWstrToUnicodeString(&tempString, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &hInterfaceInstanceControl,
                                         hInterfaceInstanceKey,
                                         &tempString,
                                         KEY_READ,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        if(!NT_SUCCESS(status)) {
            ExFreePool(pKeyValueInfo);
            hInterfaceInstanceControl = NULL;
        }
    }

    if (!NT_SUCCESS(status)) {
        goto clean2;
    }

    //
    // Find the PDO corresponding to this device instance name.
    //
    if (pKeyValueInfo->Type == REG_SZ) {

        IopRegistryDataToUnicodeString(&tempString,
                                        (PWSTR)KEY_VALUE_DATA(pKeyValueInfo),
                                        pKeyValueInfo->DataLength
                                        );

        physicalDeviceObject = IopDeviceObjectFromDeviceInstance(&tempString);

        if (physicalDeviceObject) {

            //
            // DeferNotStarted is set TRUE if we are being called from
            // IoSetDeviceInterfaceState.  It will be set FALSE if we are
            // processing previously queued operations as we are starting the
            // device.
            //
            if (DeferNotStarted) {

                if (physicalDeviceObject->DeviceObjectExtension->ExtensionFlags & DOE_START_PENDING) {

                    PDEVICE_NODE deviceNode;

                    //
                    // The device hasn't been started yet.  We need to queue
                    // any enables and remove items from the queue on a disable.
                    //
                    deviceNode = PP_DO_TO_DN(physicalDeviceObject);

                    if (Enable) {

                        status = PiDeferSetInterfaceState(deviceNode, 
                                                          SymbolicLinkName
                                                          );
                        if (NT_SUCCESS(status)) {

                            ExFreePool(pKeyValueInfo);

                            ObDereferenceObject(physicalDeviceObject);

                            status = STATUS_SUCCESS;
                            goto clean2;
                        }

                    } else {

                        PiRemoveDeferredSetInterfaceState(deviceNode, 
                                                          SymbolicLinkName
                                                          );

                        ExFreePool(pKeyValueInfo);

                        ObDereferenceObject(physicalDeviceObject);

                        status = STATUS_SUCCESS;
                        goto clean2;
                    }
                }
            }

            if (!Enable || !NT_SUCCESS(status)) {

                ObDereferenceObject(physicalDeviceObject);
            }
        } else {

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

    } else {
        //
        // This will only happen if the registry information is messed up.
        //
        physicalDeviceObject = NULL;
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (!Enable) {
        //
        // In the case of Disable we want to continue even if there was an error
        // finding the PDO.  Prior to adding support for deferring the
        // IoSetDeviceInterfaceState calls, we never looked up the PDO for
        // disables.  This will make sure that we continue to behave the same as
        // we used to in the case where we can't find the PDO.
        //
        status = STATUS_SUCCESS;
    }

    ExFreePool(pKeyValueInfo);

    if (!NT_SUCCESS(status)) {

        goto clean2;
    }

    if (Enable) {
        //
        // Retrieve the PDO's device object name.  (Start out with a reasonably-sized
        // buffer so we hopefully only have to retrieve this once.
        //
        deviceNameBufferLength = 256 * sizeof(WCHAR);

        for ( ; ; ) {

            deviceNameBuffer = ExAllocatePool(PagedPool, deviceNameBufferLength);
            if (!deviceNameBuffer) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = IoGetDeviceProperty( physicalDeviceObject,
                                          DevicePropertyPhysicalDeviceObjectName,
                                          deviceNameBufferLength,
                                          deviceNameBuffer,
                                          &deviceNameBufferLength
                                         );

            if (NT_SUCCESS(status)) {
                break;
            } else {
                //
                // Free the current buffer before we figure out what went wrong.
                //
                ExFreePool(deviceNameBuffer);

                if (status != STATUS_BUFFER_TOO_SMALL) {
                    //
                    // Our failure wasn't because the buffer was too small--bail now.
                    //
                    break;
                }

                //
                // Otherwise, loop back and try again with our new buffer size.
                //
            }
        }

        //
        // OK, we don't need the PDO anymore.
        //
        ObDereferenceObject(physicalDeviceObject);

        if (!NT_SUCCESS(status) || deviceNameBufferLength == 0) {
            goto clean2;
        }

        //
        // Now create a unicode string based on the device object name we just retrieved.
        //

        RtlInitUnicodeString(&deviceNameString, deviceNameBuffer);
    }

    //
    // Retrieve the linked value from the control subkey.
    //
    pKeyValueInfo=NULL;
    status = IopGetRegistryValue(hInterfaceInstanceControl, REGSTR_VAL_LINKED, &pKeyValueInfo);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // The absence of a linked value is taken to mean not linked
        //
        linked = 0;
    } else {

        if (!NT_SUCCESS(status)) {
            //
            // If the call failed, pKeyValueInfo was never allocated
            //
            goto clean3;
        }

        //
        // Check linked is a DWORD
        //
        if(pKeyValueInfo->Type == REG_DWORD && pKeyValueInfo->DataLength == sizeof(ULONG)) {

            linked = *((PULONG) KEY_VALUE_DATA(pKeyValueInfo));
        } else {

            //
            // The registry is messed up - assume linked is 0 and the registry will be fixed when
            // we update linked in a few moments
            //
            linked = 0;
        }
    }
    if (pKeyValueInfo) {

        ExFreePool (pKeyValueInfo);
    }

    //
    // Retrieve the refcount value from the control subkey.
    //
    PiWstrToUnicodeString(&tempString, REGSTR_VAL_REFERENCECOUNT);
    status = IopGetRegistryValue(hInterfaceParentControl,
                                 tempString.Buffer,
                                 &pKeyValueInfo
                                 );
    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // The absence of a refcount value is taken to mean refcount == 0
        //
        refcount = 0;

    } else {

        if (!NT_SUCCESS(status)) {

            goto clean3;
        }

        //
        // Check refcount is a DWORD
        //
        if(pKeyValueInfo->Type == REG_DWORD && pKeyValueInfo->DataLength == sizeof(ULONG)) {

            refcount = *((PULONG) KEY_VALUE_DATA(pKeyValueInfo));

        } else {

            //
            // The registry is messed up - assume refcount is 0 and the registry will be fixed when
            // we update refcount in a few moments
            //
            refcount = 0;

        }

        ExFreePool(pKeyValueInfo);
    }

    if (Enable) {

        if (!linked) {

            //
            // check and update the reference count
            //
            if (refcount > 0) {

                //
                // Another device instance has already referenced this interface;
                // just increment the reference count; don't try create a symbolic link.
                //
                refcount += 1;
            } else {

                //
                // According to the reference count, no other device instances currently
                // reference this interface, and therefore no symbolic links should exist,
                // so we should create one.
                //
                refcount = 1;

                status = IoCreateSymbolicLink(&globalSymbolicLinkName, &deviceNameString);
                if (status == STATUS_OBJECT_NAME_COLLISION) {

                    //
                    // The reference count is messed up.
                    //
                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoSetDeviceInterfaceState: symbolic link for %ws already exists! status = %8.8X\n",
                                    globalSymbolicLinkName.Buffer, status));
                    status = STATUS_SUCCESS;
                }
            }

            linked = 1;

        } else {

            //
            // The association already exists - don't perform the notification
            //
            status = STATUS_OBJECT_NAME_EXISTS; // Informational message not error
            goto clean3;

        }
    } else {

        if (linked) {

            //
            // check and update the reference count
            //
            if (refcount > 1) {

                //
                // Another device instance already references this interface;
                // just decrement the reference count; don't try to remove the symbolic link.
                //
                refcount -= 1;
            } else {

                //
                // According to the reference count, only this device instance currently
                // references this interface, so it is ok to delete this symbolic link
                //
                refcount = 0;
                status = IoDeleteSymbolicLink(&globalSymbolicLinkName);
                if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

                    //
                    // The reference count is messed up.
                    //
                    IopDbgPrint((IOP_ERROR_LEVEL,
                                 "IoSetDeviceInterfaceState: no symbolic link for %ws to delete! status = %8.8X\n",
                                 globalSymbolicLinkName.Buffer, 
                                 status
                                 ));
                    status = STATUS_SUCCESS;
                }
            }

            linked = 0;

        } else {

            //
            // The association does not exists - fail and do not perform 
            // notification
            //
            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (!NT_SUCCESS(status)) {

        goto clean3;
    }

    //
    // Update the value of linked
    //
    PiWstrToUnicodeString(&tempString, REGSTR_VAL_LINKED);
    status = ZwSetValueKey(hInterfaceInstanceControl,
                           &tempString,
                           0,
                           REG_DWORD,
                           &linked,
                           sizeof(linked)
                          );

    //
    // Update the value of refcount
    //
    PiWstrToUnicodeString(&tempString, REGSTR_VAL_REFERENCECOUNT);
    status = ZwSetValueKey(hInterfaceParentControl,
                           &tempString,
                           0,
                           REG_DWORD,
                           &refcount,
                           sizeof(refcount)
                          );

    //
    // Notify anyone that is interested
    //
    if (linked) {

        PpSetDeviceClassChange((LPGUID)&GUID_DEVICE_INTERFACE_ARRIVAL, 
                               &guid, 
                               SymbolicLinkName
                               );
    } else {

        PpSetDeviceClassChange((LPGUID)&GUID_DEVICE_INTERFACE_REMOVAL, 
                               &guid, 
                               SymbolicLinkName
                               );
    }

clean3:
    if (deviceNameBuffer != NULL) {
        ExFreePool(deviceNameBuffer);
    }

clean2:
    if (hInterfaceParentControl) {
        ZwClose(hInterfaceParentControl);
    }
    if (hInterfaceInstanceControl) {
        ZwClose(hInterfaceInstanceControl);
    }

clean1:

    RtlFreeUnicodeString(&globalSymbolicLinkName);

    if (hInterfaceParentKey) {
        ZwClose(hInterfaceParentKey);
    }
    if (hInterfaceInstanceKey) {
        ZwClose(hInterfaceInstanceKey);
    }
    if(hInterfaceClassKey != NULL) {
        ZwClose(hInterfaceClassKey);
    }

clean0:
    if (!NT_SUCCESS(status) && !Enable) {
        //
        // If we failed to disable an interface (most likely because the
        // interface keys have already been deleted) report success.
        //
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PiDeferSetInterfaceState(
    IN PDEVICE_NODE DeviceNode,
    IN PUNICODE_STRING SymbolicLinkName
    )
{
    NTSTATUS status;
    PPENDING_SET_INTERFACE_STATE pendingSetState;

    PAGED_CODE();

    ASSERT(PiIsPnpRegistryLocked(TRUE));

    pendingSetState = ExAllocatePool(PagedPool,
                                     sizeof(PENDING_SET_INTERFACE_STATE)
                                     );
    if (pendingSetState == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IopAllocateUnicodeString(&pendingSetState->LinkName,
                                      SymbolicLinkName->Length
                                      );
    if (!NT_SUCCESS(status)) {

        ExFreePool(pendingSetState);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&pendingSetState->LinkName, SymbolicLinkName);

    InsertTailList(&DeviceNode->PendedSetInterfaceState,
                   &pendingSetState->List
                   );

    return STATUS_SUCCESS;
}

NTSTATUS
PiRemoveDeferredSetInterfaceState(
    IN PDEVICE_NODE DeviceNode,
    IN PUNICODE_STRING SymbolicLinkName
    )
{
    PPENDING_SET_INTERFACE_STATE pendingSetState;
    PLIST_ENTRY entry;

    PAGED_CODE();

    ASSERT(PiIsPnpRegistryLocked(TRUE));
    //
    // Find the deferred entry and remove it.
    //
    for (   entry = DeviceNode->PendedSetInterfaceState.Flink;
            entry != &DeviceNode->PendedSetInterfaceState;
            entry = entry->Flink)  {

        pendingSetState = CONTAINING_RECORD(entry,
                                            PENDING_SET_INTERFACE_STATE,
                                            List
                                            );

        if (RtlEqualUnicodeString(&pendingSetState->LinkName,
                                  SymbolicLinkName,
                                  TRUE
                                  )) {

            //
            // Remove the entry and free associated storage.
            //
            RemoveEntryList(&pendingSetState->List);

            ExFreePool(pendingSetState->LinkName.Buffer);
            ExFreePool(pendingSetState);

            return STATUS_SUCCESS;
        }
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
IopDoDeferredSetInterfaceState(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    Process the queued IoSetDeviceInterfaceState calls.

Parameters:

    DeviceNode - Device node which has just been started.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PPENDING_SET_INTERFACE_STATE entry;

    PAGED_CODE();

    PiLockPnpRegistry(TRUE);

    PpMarkDeviceStackStartPending(DeviceNode->PhysicalDeviceObject, FALSE);

    while (!IsListEmpty(&DeviceNode->PendedSetInterfaceState)) {

        entry = (PPENDING_SET_INTERFACE_STATE)RemoveHeadList(
                    &DeviceNode->PendedSetInterfaceState);

        IopProcessSetInterfaceState(&entry->LinkName, TRUE, FALSE);

        ExFreePool(entry->LinkName.Buffer);
        ExFreePool(entry);
    }

    PiUnlockPnpRegistry();

    return STATUS_SUCCESS;
}

NTSTATUS
IopSetRegistryStringValue(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN PUNICODE_STRING ValueData
    )

/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key.  The 
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING terminatedString, stringCopy;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueName->Buffer);
    ASSERT(ValueData->Buffer);

    PiWstrToUnicodeString(&stringCopy, NULL);

    //
    // Allocate new string if ValueName is not big enough to hold the 
    // terminating NULL.
    //
    if (ValueData->MaximumLength - ValueData->Length < sizeof(UNICODE_NULL)) {

        status = IopAllocateUnicodeString(&stringCopy, ValueData->Length);
        if (!NT_SUCCESS(status)) {

            return status;
        }

        //
        // Copy the input string (it will also NULL terminate).
        //
        RtlCopyUnicodeString(&stringCopy, ValueData);
        terminatedString = stringCopy;
    } else {

        //
        // Null terminate the string
        //
        ValueData->Buffer[CB_TO_CWC(ValueData->Length)] = UNICODE_NULL;
        terminatedString = *ValueData;
    }
    
    //
    // Set the value in the registry.
    //
    status = ZwSetValueKey(
                KeyHandle,
                ValueName,
                0,
                REG_SZ,
                (PVOID)terminatedString.Buffer,
                terminatedString.Length + sizeof(UNICODE_NULL));

    //
    // Free the temporary string (Rtl API will do the right thing for an empty 
    // string).
    //
    RtlFreeUnicodeString(&stringCopy);

    return status;

}

NTSTATUS
IopAllocateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT Length
    )

/*++

Routine Description:

    This routine allocates a buffer for a unicode string of a given length
    and initialises the UNICODE_STRING structure appropriately. When the
    string is no longer required it can be freed using RtlFreeUnicodeString.
    The buffer also be directly deleted by ExFreePool and so can be handed
    back to a caller.

Parameters:

    String - Supplies a pointer to an uninitialised unicode string which will
        be manipulated by the function.

    Length - The number of BYTES long that the string will be.

Return Value:

    Either STATUS_INSUFFICIENT_RESOURCES indicating paged pool is exhausted or
    STATUS_SUCCESS.

Remarks:

    The buffer allocated will be one character (2 bytes) more than length 
    specified. This is to allow for easy null termination of the strings - eg 
    for registry storage.

--*/

{
    PAGED_CODE();

    String->Length = 0;
    String->MaximumLength = Length + sizeof(UNICODE_NULL);

    String->Buffer = ExAllocatePool(PagedPool, String->MaximumLength);
    if (String->Buffer == NULL) {

        String->MaximumLength = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\iofileutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoFileUtil.c

Abstract:

    This module implements various file utility functions for the Io subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#include "pnpmgrp.h"
#include "IopFileUtil.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IopFileUtilWalkDirectoryTreeTopDown)
#pragma alloc_text(INIT, IopFileUtilWalkDirectoryTreeBottomUp)
#pragma alloc_text(INIT, IopFileUtilWalkDirectoryTreeHelper)
#pragma alloc_text(INIT, IopFileUtilClearAttributes)
#pragma alloc_text(INIT, IopFileUtilRename)
#endif

#define POOLTAG_FILEUTIL ('uFoI')

NTSTATUS
IopFileUtilWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *top down*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the  callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk. The directory
                should *not* have a slash '\\'.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                          in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead;

    InitializeListHead(&dirListHead);

    //
    // Walk the first directory.
    //
    status = IopFileUtilWalkDirectoryTreeHelper(
        Directory,
        Flags,
        CallbackFunction,
        Context,
        buffer,
        sizeof(buffer),
        &dirListHead
        );

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveHeadList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = IopFileUtilWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirListHead
            );

        ExFreePool(pDirEntry);
    }

    //
    // If we failed we need to empty out our directory list.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            ExFreePool(pDirEntry);
        }
    }

    return status;
}


NTSTATUS
IopFileUtilWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    )
/*++

Routine Description:

    This funcion walks a directory tree *bottom up*, passing each entry to the
    callback with the below restrictions. Note that the root directory itself
    is not included in the callback!

Arguments:

    Directory - Supplies the NT Path to the directory to walk. The directory
        should *not* have a slash trailing '\\'.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    PDIRWALK_ENTRY pDirEntry;
    PLIST_ENTRY pListEntry;
    NTSTATUS status;
    UCHAR buffer[1024];
    LIST_ENTRY dirListHead, dirNothingHead;

    InitializeListHead(&dirListHead);
    InitializeListHead(&dirNothingHead);

    //
    // Create an entry for the root directory.
    //
    pDirEntry = (PDIRWALK_ENTRY) ExAllocatePoolWithTag(
        PagedPool,
        sizeof(DIRWALK_ENTRY) + Directory->Length - sizeof(WCHAR),
        POOLTAG_FILEUTIL
        );

    if (pDirEntry == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pDirEntry->Directory.Length = 0;
    pDirEntry->Directory.MaximumLength = Directory->Length;
    pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
    RtlCopyUnicodeString(&pDirEntry->Directory, Directory);

    InsertHeadList(&dirListHead, &pDirEntry->Link);

    //
    // Collect the directory trees. When we are done we will walk the list in
    // reverse.
    //
    status = STATUS_SUCCESS;
    if (Flags & DIRWALK_TRAVERSE) {

        for(pListEntry = &dirListHead;
            pListEntry->Flink != &dirListHead;
            pListEntry = pListEntry->Flink) {

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            status = IopFileUtilWalkDirectoryTreeHelper(
                &pDirEntry->Directory,
                DIRWALK_TRAVERSE,
                NULL,
                NULL,
                buffer,
                sizeof(buffer),
                &dirListHead
                );

            if (!NT_SUCCESS(status)) {

                break;
            }
        }
    }

    //
    // Each directory that WalkDirectory finds gets added to the list.
    // process the list until we have no more directories.
    //
    while((!IsListEmpty(&dirListHead)) && NT_SUCCESS(status)) {

        pListEntry = RemoveTailList(&dirListHead);

        pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

        status = IopFileUtilWalkDirectoryTreeHelper(
            &pDirEntry->Directory,
            Flags & ~DIRWALK_TRAVERSE,
            CallbackFunction,
            Context,
            buffer,
            sizeof(buffer),
            &dirNothingHead
            );

        ExFreePool(pDirEntry);

        ASSERT(IsListEmpty(&dirNothingHead));
    }

    //
    // Now do any final cleanup.
    //
    if (!NT_SUCCESS(status)) {

        while (!IsListEmpty(&dirListHead)) {

            pListEntry = RemoveHeadList(&dirListHead);

            pDirEntry = (PDIRWALK_ENTRY) CONTAINING_RECORD(pListEntry, DIRWALK_ENTRY, Link);

            ExFreePool(pDirEntry);
        }
    }

    return status;
}


NTSTATUS
IopFileUtilWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction,
    IN      PVOID            Context,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    )
/*++

Routine Description:

    This is a helper function for the IopFileUtilWalkDirectoryTree* functions.

Arguments:

    Directory - Supplies the NT Path to the directory to walk. The directory
                should *not* have a slash trailing '\\'.

    Flags - Specifies constraints on how the directory tree should be walked:

            DIRWALK_INCLUDE_FILES        - Files should be included in the dump.

            DIRWALK_INCLUDE_DIRECTORIES  - Directories should be included in the
                                           dump.

            DIRWALK_CULL_DOTPATHS        - "." and ".." should *not* be included
                                           in the list of directories passed to
                                           the callback function.

            DIRWALK_TRAVERSE             - Each subdirectory should be traversed
                                           in turn.

            DIRWALK_TRAVERSE_MOUNTPOINTS - Set if mountpoints/symlinks should
                                           be traversed as well.

    DirList - Recieves list of new directories to scan after completion of this
              directory. Each entry is a member of the DIRECTORY_ENTRY
              structure.

    CallbackFunction - Pointer to a function to call for each entry in the
                       directory/subtree.

    Context - Context to pass to the callback function.

    Buffer    - A scratch buffer to use.

    BufferSize - The length of Buffer. Must be greater than sizeof(WCHAR).

Return Value:

    NTSTATUS - status of the operation.

--*/
{
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    BOOLEAN bRestartScan, bIsDotPath;
    WCHAR savedChar;
    PFILE_BOTH_DIR_INFORMATION pFileInfo;
    UNICODE_STRING entryName;
    USHORT newNameLength;
    PDIRWALK_ENTRY pDirEntry;
    ULONG OpenFlags;

    //
    // Setup initial values
    //
    bRestartScan = TRUE;

    //
    //  Open the file for list directory access
    //
    if (Flags & DIRWALK_TRAVERSE_MOUNTPOINTS) {

        OpenFlags = FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;

    } else {

        OpenFlags = FILE_OPEN_REPARSE_POINT |
                    FILE_DIRECTORY_FILE |
                    FILE_OPEN_FOR_BACKUP_INTENT;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        Directory,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
        &fileHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ,
        OpenFlags
        );

    if (!NT_SUCCESS(status)) {

        goto cleanup;
    }

    //
    //  Do the directory loop
    //
    while(1) {

        //
        // We subtract off a WCHAR so that we can append a terminating null as
        // needed.
        //
        ASSERT(BufferSize > sizeof(WCHAR));

        status = ZwQueryDirectoryFile(
            fileHandle,
            (HANDLE)NULL,
            (PIO_APC_ROUTINE)NULL,
            (PVOID)NULL,
            &ioStatus,
            Buffer,
            BufferSize - sizeof(WCHAR),
            FileBothDirectoryInformation,
            FALSE,
            (PUNICODE_STRING)NULL,
            bRestartScan
            );

        if (!NT_SUCCESS(status)) {

            break;
        }

        //
        // We may come back here. Make sure the file scan doesn't start back
        // over.
        //
        bRestartScan = FALSE;

        //
        // Wait for the event to complete if neccessary.
        //
        if (status == STATUS_PENDING) {

            ZwWaitForSingleObject(fileHandle, TRUE, NULL);
            status = ioStatus.Status;

            //
            //  Check the Irp for success
            //
            if (!NT_SUCCESS(status)) {

                break;
            }
        }

        //
        // Walk each returned record. Note that we won't be here if there are
        // no records, as ioStatus will have contains STATUS_NO_MORE_FILES.
        //
        pFileInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;

        while(1) {

            //
            // Temporarily terminate the file. We allocated an extra WCHAR to
            // make sure we could safely do this.
            //
            savedChar = pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)];
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = 0;

            //
            // Build a full unicode path for the file along with a directory
            // entry at the same time.
            //
            RtlInitUnicodeString(&entryName, pFileInfo->FileName);

            newNameLength =
                (Directory->Length + entryName.Length + sizeof(WCHAR));

            pDirEntry = (PDIRWALK_ENTRY) ExAllocatePoolWithTag(
                PagedPool,
                sizeof(DIRWALK_ENTRY) + newNameLength - sizeof(WCHAR),
                POOLTAG_FILEUTIL
                );

            if (pDirEntry == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pDirEntry->Directory.Length = 0;
            pDirEntry->Directory.MaximumLength = newNameLength;
            pDirEntry->Directory.Buffer = &pDirEntry->Name[0];
            RtlCopyUnicodeString(&pDirEntry->Directory, Directory);
            RtlAppendUnicodeToString(&pDirEntry->Directory, L"\\");
            RtlAppendUnicodeStringToString(&pDirEntry->Directory, &entryName);

            if (pFileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // Check for . and ..
                //
                if ((!_wcsicmp(pFileInfo->FileName, L".")) ||
                              (!_wcsicmp(pFileInfo->FileName, L".."))) {
                    bIsDotPath = TRUE;
                }
                else {
                    bIsDotPath = FALSE;
                }

                if ((Flags & DIRWALK_INCLUDE_DIRECTORIES) &&
                    ((!(Flags & DIRWALK_CULL_DOTPATHS)) || (!bIsDotPath))) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                if ((!bIsDotPath) && (Flags & DIRWALK_TRAVERSE)) {

                    InsertTailList(DirList, &pDirEntry->Link);

                } else {

                    ExFreePool(pDirEntry);
                }

            } else {

                if (Flags & DIRWALK_INCLUDE_FILES) {

                    status = CallbackFunction(
                        &pDirEntry->Directory,
                        &entryName,
                        pFileInfo->FileAttributes,
                        Context
                        );
                }

                ExFreePool(pDirEntry);
            }

            if (!NT_SUCCESS(status)) {

                break;
            }

            //
            // Put back the character we wrote down. It might have been part of
            // the next entry.
            //
            pFileInfo->FileName[pFileInfo->FileNameLength/sizeof(WCHAR)] = savedChar;

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //
            if (pFileInfo->NextEntryOffset == 0) {

                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //
            pFileInfo = (PFILE_BOTH_DIR_INFORMATION)
                (((PUCHAR) pFileInfo) + pFileInfo->NextEntryOffset);
        }

        if (!NT_SUCCESS(status)) {

            break;
        }
    }

    ZwClose( fileHandle );

    if (status == STATUS_NO_MORE_FILES) {

        status = STATUS_SUCCESS;
    }

cleanup:
    return status;
}


NTSTATUS
IopFileUtilClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    )
/*++

Routine Description:

    This function clears the passed in attributes off the specified file.

Arguments:

    FullPathName - Full path name of the identified file.

    FileAttributes - Attributes to clear.

Return Value:

    NTSTATUS.

--*/
{
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    FILE_BASIC_INFORMATION fileBasicInformation;
    ULONG newAttributes;
    NTSTATUS status;

    //
    // First we open the file.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        FullPathName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
        &fileHandle,
        FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT | FILE_WRITE_THROUGH
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Then we get the file attributes.
    //
    status = ZwQueryInformationFile(
        fileHandle,
        &ioStatus,
        &fileBasicInformation,
        sizeof(fileBasicInformation),
        FileBasicInformation
        );

    if (!NT_SUCCESS(status)) {

        ZwClose(fileHandle);
        return status;
    }

    //
    // Anything to do?
    //
    if (fileBasicInformation.FileAttributes & FileAttributes) {

        //
        // Clear the specified bits.
        //
        newAttributes = fileBasicInformation.FileAttributes;
        newAttributes &= ~FileAttributes;
        if (newAttributes == 0) {

            newAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        //
        // Zero fields that shouldn't be touched.
        //
        RtlZeroMemory(
            &fileBasicInformation,
            sizeof(FILE_BASIC_INFORMATION)
            );

        fileBasicInformation.FileAttributes = newAttributes;

        //
        // Commit the changes.
        //
        status = ZwSetInformationFile(
            fileHandle,
            &ioStatus,
            &fileBasicInformation,
            sizeof(fileBasicInformation),
            FileBasicInformation
            );
    }

    ZwClose(fileHandle);
    return status;
}


NTSTATUS
IopFileUtilRename(
    IN PUNICODE_STRING  SourcePathName,
    IN PUNICODE_STRING  DestinationPathName,
    IN BOOLEAN          ReplaceIfPresent
    )
/*++

Routine Description:

    This function renames or moves a file or directory.

Arguments:

    SourcePathName - Full path name of the file or directory to rename.

    DestinationPathName - Future full path name of the file or directory.

    ReplaceIfPresent - If true, NewPathName is deleted if already present.

Return Value:

    NTSTATUS.

--*/
{
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PFILE_RENAME_INFORMATION pNewName;
    NTSTATUS status;

    pNewName = ExAllocatePoolWithTag(
        PagedPool,
        sizeof(FILE_RENAME_INFORMATION) + DestinationPathName->Length,
        POOLTAG_FILEUTIL
        );

    if (pNewName == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we may be replacing the file, we first need to clear the read only
    // attributes.
    //
    if (ReplaceIfPresent) {

        //
        // Errors are ignored as the file may not exist.
        //
        IopFileUtilClearAttributes(
            DestinationPathName,
            ( FILE_ATTRIBUTE_READONLY |
              FILE_ATTRIBUTE_HIDDEN |
              FILE_ATTRIBUTE_SYSTEM )
            );
    }

    InitializeObjectAttributes(
        &objectAttributes,
        SourcePathName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
        &fileHandle,
        FILE_READ_ATTRIBUTES | DELETE | SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_FOR_BACKUP_INTENT | FILE_WRITE_THROUGH
        );

    if (!NT_SUCCESS(status)) {

        ExFreePool(pNewName);
        return status;
    }

    //
    // Change \\SystemRoot\LastGood\Blah... to \\SystemRoot\Blah...
    //
    RtlCopyMemory(
        pNewName->FileName,
        DestinationPathName->Buffer,
        DestinationPathName->Length
        );

    pNewName->ReplaceIfExists = ReplaceIfPresent;
    pNewName->RootDirectory = NULL;
    pNewName->FileNameLength = DestinationPathName->Length;

    status = ZwSetInformationFile(
        fileHandle,
        &ioStatus,
        pNewName,
        pNewName->FileNameLength + sizeof(FILE_RENAME_INFORMATION),
        FileRenameInformation
        );

    ExFreePool(pNewName);
    ZwClose(fileHandle);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\iofileutil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    IoFileUtil.h

Abstract:

    This header exposes various file utility functions for the Io subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#define DIRWALK_INCLUDE_FILES           0x00000001
#define DIRWALK_INCLUDE_DIRECTORIES     0x00000002
#define DIRWALK_CULL_DOTPATHS           0x00000004
#define DIRWALK_TRAVERSE                0x00000008
#define DIRWALK_TRAVERSE_MOUNTPOINTS    0x00000010

typedef NTSTATUS (*DIRWALK_CALLBACK)(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );

NTSTATUS
IopFileUtilWalkDirectoryTreeTopDown(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

NTSTATUS
IopFileUtilWalkDirectoryTreeBottomUp(
    IN PUNICODE_STRING  Directory,
    IN ULONG            Flags,
    IN DIRWALK_CALLBACK CallbackFunction,
    IN PVOID            Context
    );

NTSTATUS
IopFileUtilClearAttributes(
    IN PUNICODE_STRING  FullPathName,
    IN ULONG            FileAttributes
    );

NTSTATUS
IopFileUtilRename(
    IN PUNICODE_STRING  SourcePathName,
    IN PUNICODE_STRING  DestinationPathName,
    IN BOOLEAN          ReplaceIfPresent
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\devnode.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devnode.c

Abstract:

    This file contains routines to maintain our private device node list.

Author:

    Forrest Foltz (forrestf) 27-Mar-1996

Revision History:

    Modified for nt kernel.

--*/

#include "pnpmgrp.h"

//
// Internal definitions
//

typedef struct _ENUM_CONTEXT{
    PENUM_CALLBACK CallersCallback;
    PVOID CallersContext;
} ENUM_CONTEXT, *PENUM_CONTEXT;

//
// Internal References
//

NTSTATUS
PipForAllDeviceNodesCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    );

BOOLEAN
PipAreDriversLoadedWorker(
    IN PNP_DEVNODE_STATE    CurrentNodeState,
    IN PNP_DEVNODE_STATE    PreviousNodeState
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PipAreDriversLoaded)
#pragma alloc_text(PAGE, PipAreDriversLoadedWorker)
#pragma alloc_text(PAGE, PipAllocateDeviceNode)
#pragma alloc_text(PAGE, PipForAllDeviceNodes)
#pragma alloc_text(PAGE, PipForDeviceNodeSubtree)
#pragma alloc_text(PAGE, PipForAllChildDeviceNodes)
#pragma alloc_text(PAGE, PipForAllDeviceNodesCallback)
#pragma alloc_text(PAGE, IopDestroyDeviceNode)
#pragma alloc_text(PAGE, PpDevNodeLockTree)
#pragma alloc_text(PAGE, PpDevNodeUnlockTree)
#pragma alloc_text(PAGE, PipIsProblemReadonly)
#pragma alloc_text(PAGE, PipIsDevNodeDNStarted)
#pragma alloc_text(PAGE, PipSetDevNodeProblem)
#pragma alloc_text(PAGE, PipClearDevNodeProblem)
//#pragma alloc_text(NONPAGE, PpDevNodeInsertIntoTree)
//#pragma alloc_text(NONPAGE, PpDevNodeRemoveFromTree)
//#pragma alloc_text(NONPAGE, PipRestoreDevNodeState)
//#pragma alloc_text(NONPAGE, PipSetDevNodeState)
#if DBG
#pragma alloc_text(PAGE, PpDevNodeAssertLockLevel)
#endif // DBG
#endif // ALLOC_PRAGMA


BOOLEAN
PipAreDriversLoaded(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine determines whether a devnode should be treated as if it has
    drivers attached to the PDO's stack (ie it's been added.)

Arguments:

    DeviceNode - Device node to examine.

Return Value:

    TRUE if drivers are loaded, FALSE otherwise.

--*/
{
    PAGED_CODE();

    return PipAreDriversLoadedWorker(
        DeviceNode->State,
        DeviceNode->PreviousState
        );
}

BOOLEAN
PipAreDriversLoadedWorker(
    IN PNP_DEVNODE_STATE    CurrentNodeState,
    IN PNP_DEVNODE_STATE    PreviousNodeState
    )
/*++

Routine Description:

    This routine determines whether a devnode should be treated as if it has
    drivers attached to the PDO's stack (ie it's been added.)

Arguments:

    CurrentNodeState - Current state of device node to examine.

    PreviousNodeState - Previous state of device node to examine.

Return Value:

    TRUE if drivers are loaded, FALSE otherwise.

--*/
{
    PAGED_CODE();

    switch(CurrentNodeState) {

        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
        case DeviceNodeStarted:
        case DeviceNodeQueryStopped:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeAwaitingQueuedRemoval:
            return TRUE;

        case DeviceNodeAwaitingQueuedDeletion:
            return PipAreDriversLoadedWorker(
                PreviousNodeState,
                DeviceNodeUnspecified
                );

        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeRemoved:
            return FALSE;

        case DeviceNodeDeleted:
            //
            // This can be seen by user mode because we defer delinking devices
            // from the tree during removal.
            //
            return FALSE;

        case DeviceNodeStartPending:
        case DeviceNodeEnumeratePending:
        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            return FALSE;
    }
}

BOOLEAN
PipIsDevNodeDNStarted(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine takes a devnode and determines whether the devnode should
    have the user mode DN_STARTED bit set.

Arguments:

    DeviceNode - Device node to examine.

Return Value:

    TRUE if the devnode should be considered started, FALSE otherwise.

--*/
{
    PAGED_CODE();

    switch (DeviceNode->State) {

        case DeviceNodeStartPending:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
        case DeviceNodeStarted:
        case DeviceNodeQueryStopped:
        case DeviceNodeEnumeratePending:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
            return TRUE;

        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeRemoved:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:
            return FALSE;

        case DeviceNodeDeleted:
            //
            // This can be seen by user mode because we defer delinking devices
            // from the tree during removal.
            //
            return FALSE;

        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            return FALSE;
    }
}

VOID
PipClearDevNodeProblem(
    IN PDEVICE_NODE DeviceNode
    )
{
    PAGED_CODE();

    DeviceNode->Flags &= ~DNF_HAS_PROBLEM;
    DeviceNode->Problem = 0;
}

VOID
PipSetDevNodeProblem(
    IN PDEVICE_NODE DeviceNode,
    IN ULONG        Problem
    )
{
    PAGED_CODE();

    ASSERT(DeviceNode->State != DeviceNodeUninitialized || !(DeviceNode->Flags & DNF_ENUMERATED) || Problem == CM_PROB_INVALID_DATA);
    ASSERT(DeviceNode->State != DeviceNodeStarted);
    ASSERT(Problem != 0);
    DeviceNode->Flags |= DNF_HAS_PROBLEM;                        \
    DeviceNode->Problem = Problem;
}

VOID
PipSetDevNodeState(
    IN  PDEVICE_NODE        DeviceNode,
    IN  PNP_DEVNODE_STATE   State,
    OUT PNP_DEVNODE_STATE   *OldState    OPTIONAL
    )
/*++

Routine Description:

    This routine sets a devnodes state and optional returns the prior state.
    The prior state is saved and can be restored via PipRestoreDevNodeState.

Arguments:

    DeviceNode - Device node to update state.

    State - State to place devnode in.

    OldState - Optionally receives prior state of devnode.

Return Value:

    None.

--*/
{
    PNP_DEVNODE_STATE   previousState;
    KIRQL               oldIrql;

    ASSERT(State != DeviceNodeQueryStopped || DeviceNode->State == DeviceNodeStarted);

#if DBG
    if ((State == DeviceNodeDeleted) ||
        (State == DeviceNodeDeletePendingCloses)) {

        ASSERT(!(DeviceNode->Flags & DNF_ENUMERATED));
    }
#endif

    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    previousState = DeviceNode->State;
    if (DeviceNode->State != State) {

        //
        // Update the devnode's current and previous state.
        //
        DeviceNode->State = State;
        DeviceNode->PreviousState = previousState;

        //
        // Push prior state onto the history stack.
        //
        DeviceNode->StateHistory[DeviceNode->StateHistoryEntry] = previousState;
        DeviceNode->StateHistoryEntry++;
        DeviceNode->StateHistoryEntry %= STATE_HISTORY_SIZE;
    }

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    IopDbgPrint((IOP_INFO_LEVEL, 
                 "%wZ: %s => %s\n", 
                 &DeviceNode->InstancePath, 
                 PP_DEVNODESTATE_NAME(previousState), 
                 PP_DEVNODESTATE_NAME(State)));

    if (ARGUMENT_PRESENT(OldState)) {

        *OldState = previousState;
    }
    if (State == DeviceNodeDeleted) {

        PpRemoveDeviceActionRequests(DeviceNode->PhysicalDeviceObject);
    }
}

VOID
PipRestoreDevNodeState(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine restores a devnodes state to the state pushed by the last
    PipSetDevNodeState call. This function can only be called once for each
    call to PipSetDevNodeState.

Arguments:

    DeviceNode - Device node to restore state.

Return Value:

    None.

--*/
{
    PNP_DEVNODE_STATE   previousState, newState;
    KIRQL               oldIrql;

    ASSERT((DeviceNode->State == DeviceNodeQueryRemoved) ||
           (DeviceNode->State == DeviceNodeQueryStopped) ||
           (DeviceNode->State == DeviceNodeAwaitingQueuedRemoval) ||
           (DeviceNode->State == DeviceNodeAwaitingQueuedDeletion));

    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    //
    // Update the devnode's state.
    //
    previousState = DeviceNode->State;
    newState = DeviceNode->State = DeviceNode->PreviousState;

    //
    // Push the old state onto the history stack.
    //
    DeviceNode->StateHistory[DeviceNode->StateHistoryEntry] = previousState;
    DeviceNode->StateHistoryEntry++;
    DeviceNode->StateHistoryEntry %= STATE_HISTORY_SIZE;

#if DBG
    //
    // Put a sentinel on the stack - restoring twice is a bug.
    //
    DeviceNode->PreviousState = DeviceNodeUnspecified;
#endif

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    IopDbgPrint((IOP_INFO_LEVEL, 
                 "%wZ: %s => %s\n", 
                 &DeviceNode->InstancePath, 
                 PP_DEVNODESTATE_NAME(previousState), 
                 PP_DEVNODESTATE_NAME(newState)));
}

BOOLEAN
PipIsProblemReadonly(
    IN  ULONG   Problem
    )
/*++

Routine Description:

    This routine returns TRUE if the specified CM_PROB code cannot be cleared
    by user mode, FALSE otherwise.

Arguments:

    Problem - CM_PROB_...

Return Value:

    TRUE/FALSE.

--*/
{
    PAGED_CODE();

    switch(Problem) {

        case CM_PROB_OUT_OF_MEMORY: // Nonresettable due to IoReportResourceUsage path.
        case CM_PROB_NORMAL_CONFLICT:
        case CM_PROB_PARTIAL_LOG_CONF:
        case CM_PROB_DEVICE_NOT_THERE:
        case CM_PROB_HARDWARE_DISABLED:
        case CM_PROB_DISABLED_SERVICE:
        case CM_PROB_TRANSLATION_FAILED:
        case CM_PROB_NO_SOFTCONFIG:
        case CM_PROB_BIOS_TABLE:
        case CM_PROB_IRQ_TRANSLATION_FAILED:
        case CM_PROB_DUPLICATE_DEVICE:
        case CM_PROB_SYSTEM_SHUTDOWN:
        case CM_PROB_HELD_FOR_EJECT:
        case CM_PROB_REGISTRY_TOO_LARGE:
        case CM_PROB_INVALID_DATA:
        case CM_PROB_SETPROPERTIES_FAILED:

            return TRUE;

        case CM_PROB_FAILED_INSTALL:
        case CM_PROB_FAILED_ADD:
        case CM_PROB_FAILED_START:
        case CM_PROB_NOT_CONFIGURED:
        case CM_PROB_NEED_RESTART:
        case CM_PROB_REINSTALL:
        case CM_PROB_REGISTRY:
        case CM_PROB_DISABLED:
        case CM_PROB_FAILED_DRIVER_ENTRY:
        case CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD:
        case CM_PROB_DRIVER_FAILED_LOAD:
        case CM_PROB_DRIVER_SERVICE_KEY_INVALID:
        case CM_PROB_LEGACY_SERVICE_NO_DEVICES:
        case CM_PROB_HALTED:
        case CM_PROB_FAILED_POST_START:
        case CM_PROB_WILL_BE_REMOVED:
        case CM_PROB_DRIVER_BLOCKED:

            return FALSE;

        case CM_PROB_PHANTOM:

            //
            // Should never see in kernel mode
            //

        case CM_PROB_DEVLOADER_FAILED:
        case CM_PROB_DEVLOADER_NOT_FOUND:
        case CM_PROB_REENUMERATION:
        case CM_PROB_VXDLDR:
        case CM_PROB_NOT_VERIFIED:
        case CM_PROB_LIAR:
        case CM_PROB_FAILED_FILTER:
        case CM_PROB_MOVED:
        case CM_PROB_TOO_EARLY:
        case CM_PROB_NO_VALID_LOG_CONF:
        case CM_PROB_UNKNOWN_RESOURCE:
        case CM_PROB_ENTRY_IS_WRONG_TYPE:
        case CM_PROB_LACKED_ARBITRATOR:
        case CM_PROB_BOOT_CONFIG_CONFLICT:
        case CM_PROB_DEVLOADER_NOT_READY:
        case CM_PROB_CANT_SHARE_IRQ:

            //
            // Win9x specific
            //

        default:
            ASSERT(0);

            //
            // We return TRUE in this path because that prevents these problems
            // from being set on devnodes (SetDeviceProblem won't allow usage
            // of ReadOnly problems)
            //
            return TRUE;
    }
}

NTSTATUS
PipAllocateDeviceNode(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PDEVICE_NODE *DeviceNode
    )
/*++

Routine Description:

    This function allocates a device node from nonpaged pool and initializes
    the fields which do not require to hold lock to do so.  Since adding
    the device node to pnp mgr's device node tree requires acquiring lock,
    this routine does not add the device node to device node tree.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to its corresponding physical device
        object.

Return Value:

    a pointer to the newly created device node. Null is returned if failed.

--*/
{

    PAGED_CODE();

    *DeviceNode = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(DEVICE_NODE),
                    IOP_DNOD_TAG
                    );

    if (*DeviceNode == NULL ){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    InterlockedIncrement((LONG *)&IopNumberDeviceNodes);

    RtlZeroMemory(*DeviceNode, sizeof(DEVICE_NODE));

    (*DeviceNode)->InterfaceType = InterfaceTypeUndefined;
    (*DeviceNode)->BusNumber = (ULONG)-1;
    (*DeviceNode)->ChildInterfaceType = InterfaceTypeUndefined;
    (*DeviceNode)->ChildBusNumber = (ULONG)-1;
    (*DeviceNode)->ChildBusTypeIndex = (USHORT)-1;
    (*DeviceNode)->State = DeviceNodeUninitialized;
    (*DeviceNode)->DisableableDepends = 0;

    PpHotSwapInitRemovalPolicy(*DeviceNode);

    InitializeListHead(&(*DeviceNode)->DeviceArbiterList);
    InitializeListHead(&(*DeviceNode)->DeviceTranslatorList);

    if (PhysicalDeviceObject){

        (*DeviceNode)->PhysicalDeviceObject = PhysicalDeviceObject;
        PhysicalDeviceObject->DeviceObjectExtension->DeviceNode = (PVOID)*DeviceNode;
        PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    InitializeListHead(&(*DeviceNode)->TargetDeviceNotify);
    InitializeListHead(&(*DeviceNode)->DockInfo.ListEntry);
    InitializeListHead(&(*DeviceNode)->PendedSetInterfaceState);
    InitializeListHead(&(*DeviceNode)->LegacyBusListEntry);

    if (PpSystemHiveTooLarge) {

        //
        // FUTURE: Make this an informational status, as that's how it is used.
        //
        return STATUS_SYSTEM_HIVE_TOO_LARGE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipForAllDeviceNodes(
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    )
/*++

Routine Description:

    This function walks the device node tree and invokes the caller specified
    'Callback' function for each device node.

    Note, this routine (or its worker routine) traverses the tree in a top
    down manner.

Arguments:

    Callback - Supplies the call back routine for each device node.

    Context - Supplies a parameter/context for the callback function.

Return Value:

    Status returned from Callback, if not successfull then the tree walking stops.

--*/
{
    PAGED_CODE();

    return PipForDeviceNodeSubtree(IopRootDeviceNode, Callback, Context);
}


NTSTATUS
PipForDeviceNodeSubtree(
    IN PDEVICE_NODE     DeviceNode,
    IN PENUM_CALLBACK   Callback,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function walks the device node tree under but not including the passed
    in device node and perform caller specified 'Callback' function for each
    device node.

    Note, this routine (or its worker routine) traverses the tree in a top
    down manner.

Arguments:

    Callback - Supplies the call back routine for each device node.

    Context - Supplies a parameter/context for the callback function.

Return Value:

    Status returned from Callback, if not successfull then the tree walking stops.

--*/
{
    ENUM_CONTEXT enumContext;
    NTSTATUS status;

    PAGED_CODE();

    enumContext.CallersCallback = Callback;
    enumContext.CallersContext = Context;

    //
    // Start with a pointer to the root device node, recursively examine all the
    // children until we the callback function says stop or we've looked at all
    // of them.
    //
    PpDevNodeLockTree(PPL_SIMPLE_READ);

    status = PipForAllChildDeviceNodes(DeviceNode,
                                       PipForAllDeviceNodesCallback,
                                       (PVOID)&enumContext );


    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    return status;
}


NTSTATUS
PipForAllChildDeviceNodes(
    IN PDEVICE_NODE Parent,
    IN PENUM_CALLBACK Callback,
    IN PVOID Context
    )

/*++

Routine Description:

    This function walks the Parent's device node subtree and perform caller specified
    'Callback' function for each device node under Parent.

    Note, befor calling this rotuine, callers must acquire the enumeration mutex
    of the 'Parent' device node to make sure its children won't go away unless the
    call tells them to.

Arguments:

    Parent - Supplies a pointer to the device node whose subtree is to be walked.

    Callback - Supplies the call back routine for each device node.

    Context - Supplies a parameter/context for the callback function.

Return Value:

    NTSTATUS value.

--*/

{
    PDEVICE_NODE nextChild = Parent->Child;
    PDEVICE_NODE child;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Process siblings until we find the end of the sibling list or
    // the Callback() returns FALSE.  Set result = TRUE at the top of
    // the loop so that if there are no siblings we will return TRUE,
    // e.g. Keep Enumerating.
    //
    // Note, we need to find next child before calling Callback function
    // in case the current child is deleted by the Callback function.
    //

    while (nextChild && NT_SUCCESS(status)) {
        child = nextChild;
        nextChild = child->Sibling;
        status = Callback(child, Context);
    }

    return status;
}

NTSTATUS
PipForAllDeviceNodesCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the worker routine for PipForAllChildDeviceNodes routine.

Arguments:

    DeviceNode - Supplies a pointer to the device node whose subtree is to be walked.

    Context - Supplies a context which contains the caller specified call back
              function and parameter.

Return Value:

    NTSTATUS value.

--*/

{
    PENUM_CONTEXT enumContext;
    NTSTATUS status;

    PAGED_CODE();

    enumContext = (PENUM_CONTEXT)Context;

    //
    // First call the caller's callback for this devnode
    //

    status =
        enumContext->CallersCallback(DeviceNode, enumContext->CallersContext);

    if (NT_SUCCESS(status)) {

        //
        // Now enumerate the children, if any.
        //
        if (DeviceNode->Child) {

            status = PipForAllChildDeviceNodes(
                                        DeviceNode,
                                        PipForAllDeviceNodesCallback,
                                        Context);
        }
    }

    return status;
}
VOID
IopDestroyDeviceNode(
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This function is invoked by IopDeleteDevice to clean up the device object's
    device node structure.

Arguments:

    DeviceNode - Supplies a pointer to the device node whose subtree is to be walked.

    Context - Supplies a context which contains the caller specified call back
              function and parameter.

Return Value:

    NTSTATUS value.

--*/

{
#if DBG
    PDEVICE_OBJECT dbgDeviceObject;
#endif

    PAGED_CODE();

    if (DeviceNode) {

        if ((DeviceNode->PhysicalDeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) &&
            DeviceNode->Parent != NULL)  {

            PP_SAVE_DEVNODE_TO_TRIAGE_DUMP(DeviceNode);
            KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                          PNP_ERR_ACTIVE_PDO_FREED,
                          (ULONG_PTR)DeviceNode->PhysicalDeviceObject,
                          0,
                          0);
        }
        if (DeviceNode->Flags & DNF_LEGACY_RESOURCE_DEVICENODE) {
            //
            // Release the resources this device consumes (the devicenode will
            // get deleted after the release). Basically cleanup after bad
            // (legacy) drivers.
            //
            IopLegacyResourceAllocation(    ArbiterRequestUndefined,
                                            IoPnpDriverObject,
                                            DeviceNode->PhysicalDeviceObject,
                                            NULL,
                                            NULL);
            return;
        }

#if DBG

        //
        // If Only Parent is NOT NULL, most likely the driver forgot to
        // release resources before deleting its FDO.  (The driver previously
        // call legacy assign resource interface.)
        //

        ASSERT(DeviceNode->Child == NULL &&
               DeviceNode->Sibling == NULL &&
               DeviceNode->LastChild == NULL
               );

        ASSERT(DeviceNode->DockInfo.SerialNumber == NULL &&
               IsListEmpty(&DeviceNode->DockInfo.ListEntry));

        if (DeviceNode->PhysicalDeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) {
            ASSERT (DeviceNode->Parent == 0);
        }

        if (DeviceNode->PreviousResourceList) {
            ExFreePool(DeviceNode->PreviousResourceList);
        }
        if (DeviceNode->PreviousResourceRequirements) {
            ExFreePool(DeviceNode->PreviousResourceRequirements);
        }

        //
        // device should not appear to be not-disableable if/when we get here
        // if either of these two lines ASSERT, email: jamiehun
        //

        ASSERT((DeviceNode->UserFlags & DNUF_NOT_DISABLEABLE) == 0);
        ASSERT(DeviceNode->DisableableDepends == 0);

        if (DeviceNode->InstancePath.Length) {

            dbgDeviceObject = IopDeviceObjectFromDeviceInstance(&DeviceNode->InstancePath);

            if (dbgDeviceObject) {

                ASSERT(dbgDeviceObject != DeviceNode->PhysicalDeviceObject);
                ObDereferenceObject(dbgDeviceObject);
            }
        }

#endif
        if (DeviceNode->DuplicatePDO) {
            ObDereferenceObject(DeviceNode->DuplicatePDO);
        }
        if (DeviceNode->ServiceName.Length != 0) {
            ExFreePool(DeviceNode->ServiceName.Buffer);
        }
        if (DeviceNode->InstancePath.Length != 0) {
            ExFreePool(DeviceNode->InstancePath.Buffer);
        }
        if (DeviceNode->ResourceRequirements) {
            ExFreePool(DeviceNode->ResourceRequirements);
        }
        //
        // Dereference all the arbiters and translators on this PDO.
        //
        IopUncacheInterfaceInformation(DeviceNode->PhysicalDeviceObject) ;

        //
        // Release any pended IoSetDeviceInterface structures
        //

        while (!IsListEmpty(&DeviceNode->PendedSetInterfaceState)) {

            PPENDING_SET_INTERFACE_STATE entry;

            entry = (PPENDING_SET_INTERFACE_STATE)RemoveHeadList(&DeviceNode->PendedSetInterfaceState);

            ExFreePool(entry->LinkName.Buffer);

            ExFreePool(entry);
        }

        DeviceNode->PhysicalDeviceObject->DeviceObjectExtension->DeviceNode = NULL;
        ExFreePool(DeviceNode);
        InterlockedDecrement((LONG *)&IopNumberDeviceNodes);
    }
}

VOID
PpDevNodeInsertIntoTree(
    IN PDEVICE_NODE     ParentNode,
    IN PDEVICE_NODE     DeviceNode
    )
/*++

Routine Description:

    This function is called to insert a new devnode into the device tree.

    Note that there are two classes of callers:
        PnP callers
        Legacy callers

    All PnP callers hold the device tree lock. Legacy callers however come in
    with no locks, as they might be brought into being due to a PnP event. To
    deal with the later case, inserts are atomic and legacy callers can never
    remove themselves from the tree.

Arguments:

    ParentNode - Supplies a pointer to the device node's parent

    DeviceNode - Supplies a pointer to the device node which needs to be
                 inserted into the tree.

Return Value:

    None.

--*/
{
    ULONG depth;
    KIRQL oldIrql;

    //
    // Acquire spinlock to deal with legacy/PnP synchronization.
    //
    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    //
    // Determine the depth of the devnode.
    //
    depth = ParentNode->Level + 1;
    DeviceNode->Level = depth;

    //
    // Update the maximum depth of the tree.
    //
    if (depth > IopMaxDeviceNodeLevel) {
        IopMaxDeviceNodeLevel = depth;
    }

    //
    // Put this devnode at the end of the parent's list of children. Note that
    // the Child/Sibling fields are really the last things to be updated. This
    // has to be done as walkers of the tree hold no locks that protect the
    // tree from legacy inserts.
    //
    DeviceNode->Parent = ParentNode;
    KeMemoryBarrier();
    if (ParentNode->LastChild) {
        ASSERT(ParentNode->LastChild->Sibling == NULL);
        ParentNode->LastChild->Sibling = DeviceNode;
        ParentNode->LastChild = DeviceNode;
    } else {
        ASSERT(ParentNode->Child == NULL);
        ParentNode->Child = ParentNode->LastChild = DeviceNode;
    }

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    //
    // Tree has changed
    //
    IoDeviceNodeTreeSequence += 1;
}

VOID
PpDevNodeRemoveFromTree(
    IN PDEVICE_NODE     DeviceNode
    )
/*++

Routine Description:

    This function removes the device node from the device node tree

Arguments:

    DeviceNode      - Device node to remove

Return Value:

--*/
{
    PDEVICE_NODE    *node;
    KIRQL           oldIrql;

    //
    // Acquire spinlock to deal with legacy/PnP synchronization.
    //
    KeAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    //
    // Unlink the pointer to this device node.  (If this is the
    // first entry, unlink it from the parents child pointer, else
    // remove it from the sibling list)
    //

    node = &DeviceNode->Parent->Child;
    while (*node != DeviceNode) {
        node = &(*node)->Sibling;
    }
    *node = DeviceNode->Sibling;

    if (DeviceNode->Parent->Child == NULL) {
        DeviceNode->Parent->LastChild = NULL;
    } else {
        while (*node) {
            node = &(*node)->Sibling;
        }
        DeviceNode->Parent->LastChild = CONTAINING_RECORD(node, DEVICE_NODE, Sibling);
    }

    KeReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    //
    // Remove this device node from Legacy Bus information table.
    //
    IopRemoveLegacyBusDeviceNode(DeviceNode);

    //
    // Orphan any outstanding device change notifications on these nodes.
    //
    IopOrphanNotification(DeviceNode);

    //
    // No longer linked
    //
    DeviceNode->Parent    = NULL;
    DeviceNode->Child     = NULL;
    DeviceNode->Sibling   = NULL;
    DeviceNode->LastChild = NULL;
}

VOID
PpDevNodeLockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    )
/*++

Routine Description:

    This function acquires the tree lock with the appropriate level of
    restrictions.

Arguments:

    LockLevel:
        PPL_SIMPLE_READ         - Allows simple examination of the tree.

        PPL_TREEOP_ALLOW_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads can go through however.

        PPL_TREEOP_BLOCK_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads are also blocked.

        PPL_TREEOP_BLOCK_READS_FROM_ALLOW - Switch to PPL_TREEOP_BLOCK_READS
                                            when already in
                                            PPL_TREEOP_BLOCK_READS. Note that
                                            PpDevNodeUnlockTree must be
                                            subsequently called on both to
                                            release.

Return Value:

    None.

--*/
{
    ULONG refCount, remainingCount;

    PAGED_CODE();

    //
    // Block any attempt to suspend the thread via user mode.
    //
    KeEnterCriticalRegion();

    switch(LockLevel) {

        case PPL_SIMPLE_READ:
            ExAcquireSharedWaitForExclusive(&IopDeviceTreeLock, TRUE);
            break;

        case PPL_TREEOP_ALLOW_READS:
            ExAcquireResourceExclusiveLite(&PiEngineLock, TRUE);
            ExAcquireSharedWaitForExclusive(&IopDeviceTreeLock, TRUE);
            break;

        case PPL_TREEOP_BLOCK_READS:
            ExAcquireResourceExclusiveLite(&PiEngineLock, TRUE);
            ExAcquireResourceExclusiveLite(&IopDeviceTreeLock, TRUE);
            break;

        case PPL_TREEOP_BLOCK_READS_FROM_ALLOW:

            //
            // Drop the tree lock and require exclusive.
            //
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));

            //
            // "Shared" is a subset of exclusive. ExIsResourceAcquiredShared
            // will return nonzero if it's owned exclusive. We flush out that
            // case here.
            //
            ASSERT(ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock) &&
                   (!ExIsResourceAcquiredExclusiveLite(&IopDeviceTreeLock)));

            //
            // Drop the tree lock entirely.
            //
            refCount = ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock);
            for(remainingCount = refCount; remainingCount; remainingCount--) {

                ExReleaseResourceLite(&IopDeviceTreeLock);
            }

            //
            // Grab it exclusively while keeping the original count.
            //
            for(remainingCount = refCount; remainingCount; remainingCount--) {

                ExAcquireResourceExclusiveLite(&IopDeviceTreeLock, TRUE);
            }
            break;

        default:
            ASSERT(0);
            break;
    }
}

VOID
PpDevNodeUnlockTree(
    IN  PNP_LOCK_LEVEL  LockLevel
    )
/*++

Routine Description:

    This function releases the tree lock with the appropriate level of
    restrictions.

Arguments:

    LockLevel:
        PPL_SIMPLE_READ         - Allows simple examination of the tree.

        PPL_TREEOP_ALLOW_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads can go through however.

        PPL_TREEOP_BLOCK_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads are also blocked.

        PPL_TREEOP_BLOCK_READS_FROM_ALLOW - Switch to PPL_TREEOP_BLOCK_READS
                                            when already in
                                            PPL_TREEOP_BLOCK_READS. Note that
                                            PpDevNodeUnlockTree must be
                                            subsequently called on both to
                                            release.
Return Value:

    None.

--*/
{
    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(LockLevel);
    switch(LockLevel) {

        case PPL_SIMPLE_READ:
            ExReleaseResourceLite(&IopDeviceTreeLock);
            break;

        case PPL_TREEOP_ALLOW_READS:
            ExReleaseResourceLite(&IopDeviceTreeLock);
            ExReleaseResourceLite(&PiEngineLock);
            break;

        case PPL_TREEOP_BLOCK_READS:
            ExReleaseResourceLite(&IopDeviceTreeLock);
            ExReleaseResourceLite(&PiEngineLock);
            break;

        case PPL_TREEOP_BLOCK_READS_FROM_ALLOW:
            //
            // The engine lock should still be held here. Now we adjust the
            // tree lock. Go back to allow by converting the exclusive lock to
            // shared. Note that this doesn't chance the acquisition count.
            //
            ASSERT(ExIsResourceAcquiredExclusiveLite(&IopDeviceTreeLock));
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));
            ExConvertExclusiveToSharedLite(&IopDeviceTreeLock);
            break;

        default:
            ASSERT(0);
            break;
    }

    KeLeaveCriticalRegion();
}

#if DBG
VOID
PpDevNodeAssertLockLevel(
    IN  PNP_LOCK_LEVEL  LockLevel,
    IN  PCSTR           File,
    IN  ULONG           Line
    )
/*++

Routine Description:

    This asserts the lock is currently held at the appropriate level.

Arguments:

    LockLevel:
        PPL_SIMPLE_READ         - Allows simple examination of the tree.

        PPL_TREEOP_ALLOW_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads can go through however.

        PPL_TREEOP_BLOCK_READS  - Called as part of a StartEnum/Remove/Power
                                  operation, blocks other such operations.
                                  Simple reads are also blocked.

        PPL_TREEOP_BLOCK_READS_FROM_ALLOW - Switch to PPL_TREEOP_BLOCK_READS
                                            when already in
                                            PPL_TREEOP_BLOCK_READS. Note that
                                            PpDevNodeUnlockTree must be
                                            subsequently called on both to
                                            release.

    File: Name of c-file asserting the lock is held.

    Line: Line number in above c-file.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (File);
    UNREFERENCED_PARAMETER (Line);

    switch(LockLevel) {

        case PPL_SIMPLE_READ:
            ASSERT(ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock));
            break;

        case PPL_TREEOP_ALLOW_READS:
            ASSERT(ExIsResourceAcquiredSharedLite(&IopDeviceTreeLock));
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));
            break;

        case PPL_TREEOP_BLOCK_READS_FROM_ALLOW:
            //
            // This isn't really a lock level, but this assert-o-matic function
            // is called from Unlock, in which case this level means "drop back
            // to PPL_TREEOP_ALLOW_READS *from* PPL_TREEOP_BLOCK_READS." So...
            //
            // Fall through
            //

        case PPL_TREEOP_BLOCK_READS:
            ASSERT(ExIsResourceAcquiredExclusiveLite(&IopDeviceTreeLock));
            ASSERT(ExIsResourceAcquiredExclusiveLite(&PiEngineLock));
            break;

        default:
            ASSERT(0);
            break;
    }
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\mapper.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mapper.c

Abstract:

    This module contains the code that manipulates the ARC firmware
    tree and other elements in the registry.

Author:

    Bob Rinne (BobRi) 15-Oct-1994

Environment:

    Kernel mode

Revision History :

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'rpaM')
#endif


//
// This contains information obtained by checking the firmware
// tree of the registry
//

typedef struct _FIRMWARE_CONFIGURATION {
    struct _FIRMWARE_CONFIGURATION *Next;
    INTERFACE_TYPE     BusType;
    ULONG              BusNumber;
    CONFIGURATION_TYPE ControllerType;
    ULONG              ControllerNumber;
    CONFIGURATION_TYPE PeripheralType;
    ULONG              PeripheralNumber;
    ULONG              NumberBases;
    ULONG              ResourceDescriptorSize;
    PVOID              ResourceDescriptor;
    ULONG              IdentifierLength;
    ULONG              IdentifierType;
    PVOID              Identifier;
    WCHAR const*       PnPId;
    BOOLEAN            NewlyCreated;
} FIRMWARE_CONFIGURATION, *PFIRMWARE_CONFIGURATION;

//
// Device extension information
//

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT     DeviceObject;
    PDRIVER_OBJECT     DriverObject;
    INTERFACE_TYPE     InterfaceType;
    ULONG              BusNumber;
    PFIRMWARE_CONFIGURATION FirmwareList;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
//
// mapping table from firmware to enum
//

typedef struct _FIRMWARE_IDENT_TO_PNP_ID {
    PWCHAR  FirmwareName;
    PWCHAR  PnPId;
} FIRMWARE_IDENT_TO_PNP_ID, *PFIRMWARE_IDENT_TO_PNP_ID;

//
// table to hold seed information for a firmware tree entry.
//

#define OPTIONS_NONE                    0x00000000
#define OPTIONS_INSERT_PNP_ID           0x00000001
#define OPTIONS_INSERT_DEVICEDESC       0x00000002
#define OPTIONS_INSERT_COMPATIBLE_IDS   0x00000004
#define OPTIONS_INSERT_PHANTOM_MARKER   0x00000008
typedef struct _MAPPER_SEED {
    PWCHAR  ValueName;
    ULONG   ValueType;
    ULONG   DwordValueContent;
    ULONG   Options;
} MAPPER_SEED, *PMAPPER_SEED;

//
// table to hold key names and attributes for construction
// in the root enumerator tree
//

#define KEY_SEED_REQUIRED               0x00000000
#define KEY_SEED_DEVICE_PARAMETERS      0x00000001
typedef struct _KEY_SEED {
    PWCHAR  KeyName;
    ULONG   Attribute;
    ULONG   Options;
} KEY_SEED, *PKEY_SEED;


//
// All the data here is INIT only
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#pragma data_seg("INITDATA")
#endif

DEVICE_EXTENSION MapperDeviceExtension;

//
// This table is used to translate the firmware tree information
// to the root enumerator PNP id for keyboard devices.
//

const FIRMWARE_IDENT_TO_PNP_ID KeyboardMap[] = {
    L"XT_83KEY",        L"*PNP0300",
    L"PCAT_86KEY",      L"*PNP0301",
    L"PCXT_84KEY",      L"*PNP0302",
    L"XT_84KEY",        L"*PNP0302",
    L"101-KEY",         L"*PNP0303",
    L"OLI_83KEY",       L"*PNP0304",
    L"ATT_301",         L"*PNP0304",
    L"OLI_102KEY",      L"*PNP0305",
    L"OLI_86KEY",       L"*PNP0306",
    L"OLI_A101_102KEY", L"*PNP0309",
    L"ATT_302",         L"*PNP030a",
    L"PCAT_ENHANCED",   L"*PNP030b",
    L"PC98_106KEY",     L"*nEC1300",
    L"PC98_LaptopKEY",  L"*nEC1300",
    L"PC98_N106KEY",    L"*PNP0303",
    NULL, NULL
};

#define PS2_KEYBOARD_COMPATIBLE_ID  L"PS2_KEYBOARD"
#define PS2_MOUSE_COMPATIBLE_ID     L"PS2_MOUSE"

//
// This table is used to translate the firmware tree information
// to the root enumerator PNP id for pointer devices.
//

const FIRMWARE_IDENT_TO_PNP_ID PointerMap[] = {
    L"PS2 MOUSE",                        L"*PNP0F0E",
    L"SERIAL MOUSE",                     L"*PNP0F0C",
    L"MICROSOFT PS2 MOUSE",              L"*PNP0F03",
    L"LOGITECH PS2 MOUSE",               L"*PNP0F12",
    L"MICROSOFT INPORT MOUSE",           L"*PNP0F02",
    L"MICROSOFT SERIAL MOUSE",           L"*PNP0F01",
    L"MICROSOFT BALLPOINT SERIAL MOUSE", L"*PNP0F09",
    L"LOGITECH SERIAL MOUSE",            L"*PNP0F08",
    L"MICROSOFT BUS MOUSE",              L"*PNP0F00",
    L"NEC PC-9800 BUS MOUSE",            L"*nEC1F00",
    NULL, NULL
};

//
// the MapperValueSeed table is a NULL terminated table (i.e. the name
// pointer is NULL) that contains the list of values and their type
// for insertion in a newly created root enumerator key.
//

const MAPPER_SEED MapperValueSeed[] = {
    REGSTR_VALUE_HARDWAREID,       REG_MULTI_SZ, 0, OPTIONS_INSERT_PNP_ID,
    REGSTR_VALUE_COMPATIBLEIDS,    REG_MULTI_SZ, 0, OPTIONS_INSERT_COMPATIBLE_IDS,
    REGSTR_VAL_FIRMWAREIDENTIFIED, REG_DWORD,    1, OPTIONS_NONE,
    REGSTR_VAL_DEVDESC,            REG_SZ,       0, OPTIONS_INSERT_DEVICEDESC,
    REGSTR_VAL_PHANTOM,            REG_DWORD,    1, OPTIONS_INSERT_PHANTOM_MARKER,
    NULL, 0, 0, 0
};

//
// the MapperKeySeed table is a NULL terminated table (i.e. the name
// pointer is NULL) that contains the list of keys to and their
// attributes (volatile or non-volatile) for keys to be created under
// a newly created root enumerator key.
//
// The preceeding backslash is required on all entries in this table.
//

const KEY_SEED MapperKeySeed[] = {
    L"\\Control",           REG_OPTION_VOLATILE,     KEY_SEED_REQUIRED,
    L"\\LogConf",           REG_OPTION_NON_VOLATILE, KEY_SEED_REQUIRED,
    L"",                    REG_OPTION_NON_VOLATILE, KEY_SEED_DEVICE_PARAMETERS,
    NULL, 0, 0
};

//
// SerialId is used as the PNP id for all serial controllers.
// NOTE: there is no code to detect presense of a 16550.
//

const WCHAR SerialId[] = L"*PNP0501"; // RDR should be two entries.  *PNP0501 is 16550

//
// ParallelId is used as the PNP id for all parallel controllers.
// NOTE: there is no code to detect presense of ECP support.
//

const WCHAR ParallelId[] = L"*PNP0400"; // RDR should be two entries.  *PNP0401 is ECP

//
// FloppyId is used as the PNP id for all floppy peripherals.
//

const WCHAR FloppyId[] = L"*PNP0700";

//
// ATAId is here, but not used - there is nothing in the firmware
// tree for the IDE controller.
//

const WCHAR ATAId[] = L"*PNP0600";

//
// Proto type declarations
//

FIRMWARE_IDENT_TO_PNP_ID const*
MapperFindIdentMatch(
    FIRMWARE_IDENT_TO_PNP_ID const* IdentTable,
    PWCHAR String
    );

WCHAR const*
MapperTranslatePnPId(
    CONFIGURATION_TYPE PeripheralType,
    PKEY_VALUE_FULL_INFORMATION Identifier
    );

NTSTATUS
MapperPeripheralCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
MapperCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

VOID
MapperMarkKey(
    IN HANDLE Handle,
    IN PUNICODE_STRING  PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry
    );

VOID
MapperSeedKey(
    IN HANDLE                  Handle,
    IN PUNICODE_STRING         PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry,
    IN BOOLEAN                 DeviceIsPhantom
    );

PCM_RESOURCE_LIST
MapperAdjustResourceList (
    IN     PCM_RESOURCE_LIST ResourceList,
    IN     WCHAR const*      PnPId,
    IN OUT PULONG            Size
    );

NTSTATUS
ComPortDBAdd(
    IN  HANDLE  DeviceParamKey,
    IN  PWSTR   PortName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, MapperFindIdentMatch)
#pragma alloc_text(INIT, MapperTranslatePnPId)
#pragma alloc_text(INIT, MapperPeripheralCallback)
#pragma alloc_text(INIT, MapperCallback)
#pragma alloc_text(INIT, MapperProcessFirmwareTree)
#pragma alloc_text(INIT, MapperMarkKey)
#pragma alloc_text(INIT, MapperSeedKey)
#pragma alloc_text(INIT, MapperFreeList)
#pragma alloc_text(INIT, MapperConstructRootEnumTree)
#pragma alloc_text(INIT, MapperAdjustResourceList)
#pragma alloc_text(INIT, ComPortDBAdd)
#pragma alloc_text(INIT, MapperPhantomizeDetectedComPorts)
#endif

FIRMWARE_IDENT_TO_PNP_ID const*
MapperFindIdentMatch(
    FIRMWARE_IDENT_TO_PNP_ID const* IdentTable,
    PWCHAR                    String
    )

/*++

Routine Description:

    Given a table of strings to match, find the match for
    the identifier given.

Arguments:

Return Value:

    A pointer to the ident table entry for the match if found
    NULL if not found.

--*/

{
    FIRMWARE_IDENT_TO_PNP_ID const* entry;

    entry = IdentTable;
    while (entry->FirmwareName) {
        if (!wcscmp(String, entry->FirmwareName)) {
            return entry;
        }
        entry++;
    }
    return NULL;
}

WCHAR const*
MapperTranslatePnPId(
    CONFIGURATION_TYPE          PeripheralType,
    PKEY_VALUE_FULL_INFORMATION Identifier
    )

/*++

Routine Description:

    Given the peripheral type and a location in the firmware tree
    this routine will determine the PnP Id to be used when constructing
    the root enumeration portion of the registry.

Arguments:

    PeripheralType - the type of item being translated (keyboard, mouse, etc)
    PathName       - the registry path name into the firmware tree for
                     this device.

Return Value:

    A pointer to the PnP Id string if a map is found.

--*/

{
    FIRMWARE_IDENT_TO_PNP_ID const* identMap;
    PWSTR identifierString = NULL;
    WCHAR const* idStr;

    if (Identifier) {
        identifierString = (PWSTR)((PUCHAR)Identifier + Identifier->DataOffset);
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "Mapper: identifier = %ws\n\tType = ",
                    identifierString));
    }

    idStr = NULL;
    switch (PeripheralType) {
    case DiskController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "DiskController",
                    PeripheralType));
        idStr = FloppyId;
        break;

    case SerialController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "SerialController",
                    PeripheralType));
        idStr = SerialId;
        break;

    case ParallelController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "ParallelController",
                    PeripheralType));
        idStr = ParallelId;
        break;

    case PointerController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "PointerController",
                    PeripheralType));
        idStr = PointerMap[0].PnPId;
        break;

    case KeyboardController:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "KeyboardController",
                    PeripheralType));
        idStr = KeyboardMap[0].PnPId;
        break;

    case DiskPeripheral:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "DiskPeripheral",
                    PeripheralType));
        break;

    case FloppyDiskPeripheral:
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "%s (%d)\n",
                    "FloppyDiskPeripheral",
                    PeripheralType));
        idStr = FloppyId;
        break;

    case PointerPeripheral:
        if (identifierString) {
            identMap = MapperFindIdentMatch(PointerMap, identifierString);
            if (identMap) {
                IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                            "%ws\n",
                            identMap->PnPId));
                idStr = identMap->PnPId;
            } else {
                IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                            "Mapper: No pointer match found for %ws\n", identifierString));
            }
        } else {
            IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                        "Mapper: No identifier specified\n"));
        }
        break;

    case KeyboardPeripheral:
        if (identifierString) {
            identMap = MapperFindIdentMatch(KeyboardMap, identifierString);

            if (identMap) {
                IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                            "%ws\n",
                            identMap->PnPId));
                idStr = identMap->PnPId;
            } else {
                IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                            "Mapper: No keyboard match found for %ws\n", identifierString));
            }
        } else {
            IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                        "Mapper: No identifier specified\n"));
        }
        break;

    default:
        IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                    "Mapper: Unknown device (%d)\n",
                    PeripheralType));
        break;
    }
    return idStr;
}

NTSTATUS
MapperPeripheralCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine is used to acquire firmware tree information about
    pointer devices in the system.

Arguments:

    Context               - Pointer to the device extension.
    PathName              - unicode registry path.
    BusType               - Internal, Isa, ...
    BusNumber             - Which bus if we are on a multibus system.
    BusInformation        - Configuration information about the bus. Not Used.
    ControllerType        - serial or ata disk.
    ControllerNumber      - Which controller if there is more than one
                            controller in the system.
    ControllerInformation - Array of pointers to the three pieces of
                            registry information.
    PeripheralType        - Undefined for this call.
    PeripheralNumber      - Undefined for this call.
    PeripheralInformation - Undefined for this call.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the device object, or
    all of the resource information couldn't be acquired.

--*/

{
    PFIRMWARE_CONFIGURATION     firmwareEntry = Context;
    PKEY_VALUE_FULL_INFORMATION information;
    ULONG                       dataLength;
    PWCHAR                      ptr;
    PVOID                       temp;

    UNREFERENCED_PARAMETER( BusType );
    UNREFERENCED_PARAMETER( BusNumber );
    UNREFERENCED_PARAMETER( PathName );
    UNREFERENCED_PARAMETER( BusInformation );
    UNREFERENCED_PARAMETER( ControllerType );
    UNREFERENCED_PARAMETER( ControllerNumber );

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: peripheral registry location is\n %ws\n",
                PathName->Buffer));

    if (!ControllerInformation) {
        IopDbgPrint((IOP_MAPPER_VERBOSE_LEVEL,
                    "Mapper: No component information\n"));
    }
    if (!PeripheralInformation) {
        IopDbgPrint((IOP_MAPPER_VERBOSE_LEVEL,
                    "Mapper: No peripheral information\n"));
        return STATUS_SUCCESS;
    }

    //
    // Map the PnP Id for this device.
    //

    if (PeripheralInformation[IoQueryDeviceIdentifier]) {
        information = PeripheralInformation[IoQueryDeviceIdentifier];
        firmwareEntry->PnPId = MapperTranslatePnPId(PeripheralType, information);

        if (firmwareEntry->PnPId) {
            //
            // Remember the peripheral's identifier (if it has one, and it's a REG_SZ value)
            // for use as the default PnP device description.
            //

            if (((dataLength = information->DataLength) > sizeof(WCHAR)) &&
                (information->Type == REG_SZ)) {

                ptr = (PWCHAR) ((PUCHAR)information + information->DataOffset);

                if (*ptr) {
                    temp = ExAllocatePool(NonPagedPool, dataLength);
                    if (temp) {

                        //
                        // If there's already an identifier here (from the peripheral's
                        // controller) then wipe it out.
                        //

                        if(firmwareEntry->Identifier) {
                            ExFreePool(firmwareEntry->Identifier);
                        }

                        //
                        // Move the data
                        //

                        firmwareEntry->Identifier = temp;
                        firmwareEntry->IdentifierType = information->Type;
                        firmwareEntry->IdentifierLength = dataLength;
                        RtlCopyMemory(temp, ptr, dataLength);
                    }
                }
            }
        }
    }

    //
    // Save the ordinals for the peripheral type and number
    //

    firmwareEntry->PeripheralType = PeripheralType;
    firmwareEntry->PeripheralNumber = PeripheralNumber;

    return STATUS_SUCCESS;
}

NTSTATUS
MapperCallback(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine is used to acquire firmware tree information about
    pointer devices in the system.

Arguments:

    Context               - Pointer to the device extension.
    PathName              - unicode registry path.
    BusType               - Internal, Isa, ...
    BusNumber             - Which bus if we are on a multibus system.
    BusInformation        - Configuration information about the bus. Not Used.
    ControllerType        - serial or ata disk.
    ControllerNumber      - Which controller if there is more than one
                            controller in the system.
    ControllerInformation - Array of pointers to the three pieces of
                            registry information.
    PeripheralType        - Undefined for this call.
    PeripheralNumber      - Undefined for this call.
    PeripheralInformation - Undefined for this call.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the device object, or
    all of the resource information couldn't be acquired.

--*/

{
    PDEVICE_EXTENSION               deviceExtension = Context;
    PCM_FULL_RESOURCE_DESCRIPTOR    controllerData;
    PKEY_VALUE_FULL_INFORMATION     information;
    PFIRMWARE_CONFIGURATION         firmwareEntry;
    CONFIGURATION_TYPE              peripheralType;
    PUCHAR                          buffer;
    ULONG                           dataLength;

    UNREFERENCED_PARAMETER( PathName );
    UNREFERENCED_PARAMETER( BusInformation );
    UNREFERENCED_PARAMETER( PeripheralType );
    UNREFERENCED_PARAMETER( PeripheralNumber );
    UNREFERENCED_PARAMETER( PeripheralInformation );

    //
    // If entry is found, but there is no information just return
    //

    information = ControllerInformation[IoQueryDeviceConfigurationData];
    if (information == NULL) {

        return STATUS_SUCCESS;
    }

    dataLength = information->DataLength;
    if (dataLength == 0) {

        return STATUS_SUCCESS;
    }

    //
    // Setup to capture the information from the firmware tree
    //

    firmwareEntry = ExAllocatePool(NonPagedPool, sizeof(FIRMWARE_CONFIGURATION));
    if (!firmwareEntry) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(firmwareEntry, sizeof(FIRMWARE_CONFIGURATION));

    //
    // Save information concerning the controller
    //

    firmwareEntry->ControllerType   = ControllerType;
    firmwareEntry->ControllerNumber = ControllerNumber;
    firmwareEntry->BusNumber = BusNumber;
    firmwareEntry->BusType   = BusType;

    //
    // Save the resource descriptor
    //

    buffer = firmwareEntry->ResourceDescriptor = ExAllocatePool(NonPagedPool,
                                                                dataLength);

    if (!buffer) {
        ExFreePool(firmwareEntry);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Save the configuration information on this controller.
    //

    controllerData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        ((PUCHAR)information + information->DataOffset);
    RtlCopyMemory(buffer, controllerData, dataLength);
    firmwareEntry->ResourceDescriptorSize = dataLength;

    //
    // If there is a device identifier save it.
    //

    information = ControllerInformation[IoQueryDeviceIdentifier];
    if (information != NULL) {
        PWCHAR ptr;

        dataLength = information->DataLength;
        if (dataLength != 0) {

            ptr = (PWCHAR) ((PUCHAR)information + information->DataOffset);
            if (ControllerType == ParallelController) {
                PWCHAR tmpChar;

                //
                // Some extra mapping is performed here to
                // translate the firmware names to LPT names.
                //

                *ptr++ = (WCHAR) 'L';
                *ptr++ = (WCHAR) 'P';
                *ptr++ = (WCHAR) 'T';

                //
                // Find the number.
                //

                tmpChar = ptr;
                while (*tmpChar) {
                    if ((*tmpChar >= (WCHAR) '0') &&
                        (*tmpChar <= (WCHAR) '9')) {
                        break;
                    }
                    tmpChar++;
                }

                if (*tmpChar) {
                    while (*tmpChar) {
                        *ptr++ = *tmpChar++;
                    }
                    *ptr = (WCHAR) 0;

                    //
                    // Update the datalength to be 4 wchars and eos and
                    // restore the pointer.
                    //

                    ptr = (PWCHAR) ((PUCHAR)information + information->DataOffset);
                    dataLength = 10;
                } else {
                    dataLength = 0;
                    IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                                "Mapper: no parallel port number!\n"));
                }
            }

            if (dataLength) {
                firmwareEntry->Identifier = ExAllocatePool(NonPagedPool,
                                                           dataLength);
                if (firmwareEntry->Identifier) {

                    //
                    // Move the data
                    //

                    firmwareEntry->IdentifierType = information->Type;
                    firmwareEntry->IdentifierLength = dataLength;
                    RtlCopyMemory(firmwareEntry->Identifier, ptr, dataLength);
                }
            }
        }
    }

    //
    // For some controllers, search the peripheral information
    //

    switch (ControllerType) {
    case SerialController:
    case ParallelController:
        //
        // Don't look for a peripheral.
        //
        peripheralType = (CONFIGURATION_TYPE) 0;
        break;
    case DiskController:
        peripheralType = FloppyDiskPeripheral;
        break;
    case KeyboardController:
        peripheralType = KeyboardPeripheral;
        break;
    case PointerController:
        peripheralType = PointerPeripheral;
        break;
    default:
        peripheralType = (CONFIGURATION_TYPE) 0;
        break;
    }

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: registry location is\n %ws\n",
                PathName->Buffer));

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: ControllerInformation[] -\n\tIdent: %x -\n\tData: %x -\n\tInformation: %x\n",
                ControllerInformation[0],
                ControllerInformation[1],
                ControllerInformation[2]));

    if (peripheralType) {
        IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                    "Mapper: searching for peripheral type %d\n",
                    peripheralType));

        IoQueryDeviceDescription(&BusType,
                                 &BusNumber,
                                 &ControllerType,
                                 &ControllerNumber,
                                 &peripheralType,
                                 NULL,
                                 MapperPeripheralCallback,
                                 firmwareEntry);
    }

    //
    // firmwareEntry->PnPId will be NULL if there are no peripherals of this
    // type in the tree or if the peripheral's description doesn't match one of
    // those in our table.
    //
    // firmwareEntry->PeripheralType will be equal to peripheralType if we found
    // one of the proper type regardless of whether or not it is in the table.
    //
    // So this test just ensures that we fallback to the controller IDs in the
    // case were there is no peripheral entry.  If there is a peripheral entry
    // that we don't understand we will suppress the entire node.
    //
    // This prevents creating devices with hw ids of bogus as we were seeing on
    // the SGI x86 ARC machines.
    //

    if (!firmwareEntry->PnPId && firmwareEntry->PeripheralType == 0) {

        //
        // Attempt to get PnPId from the controller type.
        //

        firmwareEntry->PnPId = MapperTranslatePnPId(ControllerType, NULL);

        if (!firmwareEntry->PnPId) {
            IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                        "Mapper: NO PnP Id for\n ==> %ws\n",
                        PathName->Buffer));
        }
    }

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: constructed name %d_%d_%d_%d_%d_%d\n",
                firmwareEntry->BusType,
                firmwareEntry->BusNumber,
                firmwareEntry->ControllerType,
                firmwareEntry->ControllerNumber,
                firmwareEntry->PeripheralType,
                firmwareEntry->PeripheralNumber));

    if (firmwareEntry->PnPId) {

        //
        // Link into chain of entries.
        //

        firmwareEntry->Next = deviceExtension->FirmwareList;
        deviceExtension->FirmwareList = firmwareEntry;
    } else {

        //
        // No map found - don't remember this entry.
        //

        ExFreePool(buffer);
        if(firmwareEntry->Identifier) {
            ExFreePool(firmwareEntry->Identifier);
        }
        ExFreePool(firmwareEntry);
    }
    return STATUS_SUCCESS;
}

VOID
MapperProcessFirmwareTree(
    IN BOOLEAN OnlyProcessSerialPorts
    )

/*++

Routine Description:

    Query the information in the firmware tree to know what
    system board devices were located.  This will cause a FirmwareList
    to be created on the device extention passed.

Arguments:

    OnlyProcessSerialPorts - if non-zero, then we'll only look at serial ports.
        This is done on ACPI machines where, in general, we don't want to pay
        attention to ntdetect/firmware information (but we have to for serial
        ports so that legacy add-in ISA serial ports and modems are detected
        automatically as in previous versions of NT as well as Win9x).

Return Value:

    None

--*/

{
    INTERFACE_TYPE     interfaceType;
    ULONG              index;
    CONFIGURATION_TYPE sc;
    CONFIGURATION_TYPE controllerTypes[] = { PointerController,
                                             KeyboardController,
                                             ParallelController,
                                             DiskController,
                                             FloppyDiskPeripheral,
                                             SerialController   // must be last
                                           };
#define CONTROLLER_TYPES_COUNT (sizeof(controllerTypes) / sizeof(controllerTypes[0]))

    PAGED_CODE();

    //
    // Locate all firmware controller information and save its resource usage.
    //
    // It's pretty inefficient to be going through all interface types, when we
    // really only care about a very small subset of non-PnP buses (e.g., ISA,
    // EISA, maybe Internal).
    //

    for (interfaceType = 0; interfaceType < MaximumInterfaceType; interfaceType++) {

        IopDbgPrint((IOP_MAPPER_VERBOSE_LEVEL,
                    "Mapper: searching on interface ===> %d\n",
                    interfaceType));

        if(OnlyProcessSerialPorts) {

            //
            // Start out at the last element of the array, so we only process
            // SerialControllers.
            //

            index = CONTROLLER_TYPES_COUNT - 1;
        } else {
            index = 0;
        }

        for ( ; index < CONTROLLER_TYPES_COUNT; index++) {
            sc = controllerTypes[index];

            IoQueryDeviceDescription(&interfaceType,
                                     NULL,
                                     &sc,
                                     NULL,
                                     NULL,
                                     NULL,
                                     MapperCallback,
                                     &MapperDeviceExtension);
        }
    }
}

VOID
MapperMarkKey(
    IN HANDLE           Handle,
    IN PUNICODE_STRING  PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry
    )

/*++

Routine Description:

    Record in the root enum key that the firmware mapper found this entry.
    Migrate configuration information entries.

Arguments:

    Handle   - handle to the key
    PathName - base path name to this key
    FirmwareEntry - information from the firmware tree.

Return Value:

    None

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PCM_RESOURCE_LIST resourceList;
    UNICODE_STRING    unicodeName;
    NTSTATUS          status;
    HANDLE            subKeyHandle;
    PWCHAR            wcptr;
    ULONG             disposition;
    ULONG             buffer;
    USHORT            originalLength;

    //
    // Mark that this entry was in the firmware tree.
    //

    buffer = 1;
    PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_FIRMWAREIDENTIFIED);

    ZwSetValueKey(Handle,
                  &unicodeName,
                  0,
                  REG_DWORD,
                  &buffer,
                  sizeof(ULONG));

    //
    // Create the control subkey
    //

    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                "Mapper: marking existing key\n"));
    originalLength = PathName->Length;
    wcptr = (PWCHAR) ((PUCHAR)PathName->Buffer + PathName->Length);
    wcptr++; // locate eos

    //
    // Build the volatile control key
    //

    InitializeObjectAttributes(&objectAttributes,
                               PathName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);
    RtlAppendUnicodeToString(PathName, L"\\Control");
    status = ZwCreateKey(&subKeyHandle,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {

        //
        // Create the found by firmware volatile.
        //

        buffer = 1;
        PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_FIRMWAREMEMBER);

        ZwSetValueKey(subKeyHandle,
                      &unicodeName,
                      0,
                      REG_DWORD,
                      &buffer,
                      sizeof(ULONG));
        ZwClose(subKeyHandle);

    } else {

        //
        // ignore failures
        //

        IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                    "Mapper: failed to mark control key %x\n",
                    status));
    }

    //
    // if there is a resource descriptor, restore path and open LogConf key.
    //

    if (FirmwareEntry->ResourceDescriptor) {
        PathName->Length = originalLength;
        *wcptr = (WCHAR) 0;

        InitializeObjectAttributes(&objectAttributes,
                                   PathName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);
        RtlAppendUnicodeToString(PathName, L"\\LogConf");
        status = ZwCreateKey(&subKeyHandle,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0,
                             NULL,
                             REG_OPTION_VOLATILE,
                             &disposition);

        if (NT_SUCCESS(status)) {
            ULONG size;

            //
            // two entries need to be made:
            // BootConfig:REG_RESOURCE_LIST
            // BasicConfigVector:REG_RESOURCE_REQUIREMENTS_LIST
            //

            size = sizeof(CM_RESOURCE_LIST) -
                   sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                   FirmwareEntry->ResourceDescriptorSize;

            resourceList = ExAllocatePool(NonPagedPool, size);

            if (resourceList) {

                resourceList->Count = 1;
                RtlCopyMemory(&resourceList->List[0],
                              FirmwareEntry->ResourceDescriptor,
                              FirmwareEntry->ResourceDescriptorSize);

                resourceList = MapperAdjustResourceList (
                                   resourceList,
                                   FirmwareEntry->PnPId,
                                   &size
                                   );

                PiWstrToUnicodeString(&unicodeName,
                                     L"BootConfig");
                ZwSetValueKey(subKeyHandle,
                              &unicodeName,
                              0,
                              REG_RESOURCE_LIST,
                              resourceList,
                              size);
                ExFreePool(resourceList);
            }

            ZwClose(subKeyHandle);

        } else {
            //
            // ignore errors
            //
            IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                        "Mapper: failed to update logconf key %x\n",
                        status));
        }
    }

    //
    // Restore path passed in.
    //

    PathName->Length = originalLength;
    *wcptr = (WCHAR) 0;
}

VOID
MapperSeedKey(
    IN HANDLE                  Handle,
    IN PUNICODE_STRING         PathName,
    IN PFIRMWARE_CONFIGURATION FirmwareEntry,
    IN BOOLEAN                 DeviceIsPhantom
    )

/*++

Routine Description:

    This routine seeds a registry key with enough information
    to get PnP to run the class installer on the devnode.

Arguments:

    Handle          - handle to the key

    PathName        - base path name to this key

    FirmwareEntry   - information from the firmware tree

    DeviceIsPhantom - if non-zero, add "Phantom" value entry so the root
        enumerator will skip this device instance (i.e., not turn it into a
        devnode)

Return Value:

    None

--*/

{
#define SEED_BUFFER_SIZE (512 * sizeof(WCHAR))
    UNICODE_STRING    unicodeName;
    OBJECT_ATTRIBUTES objectAttributes;
    MAPPER_SEED const* valueSeed;
    KEY_SEED const*   keySeed;
    NTSTATUS          status;
    HANDLE            subKeyHandle;
    WCHAR const*      pnpid;
    PWCHAR            buffer;
    PWCHAR            wcptr;
    ULONG             disposition;
    ULONG             size;
    USHORT            originalLength;

    buffer = ExAllocatePool(NonPagedPool, SEED_BUFFER_SIZE);
    if (!buffer) {
        return;
    }
    RtlZeroMemory(buffer, SEED_BUFFER_SIZE);

    //
    // Create subkeys.
    //

    originalLength = PathName->Length;
    wcptr = (PWCHAR) ((PUCHAR)PathName->Buffer + PathName->Length);

    for (keySeed = MapperKeySeed; keySeed->KeyName; keySeed++) {

        //
        // Reset the base path for the next key to seed.
        //

        *wcptr = (WCHAR) 0;
        PathName->Length = originalLength;
        RtlAppendUnicodeToString(PathName, keySeed->KeyName);

        //
        // Only build a device parameters key if there is something
        // to put in the key (i.e., this is a serial or parallel port).
        //

        if (keySeed->Options & KEY_SEED_DEVICE_PARAMETERS) {
            if (((FirmwareEntry->ControllerType != SerialController) && (FirmwareEntry->ControllerType != ParallelController)) ||
                !FirmwareEntry->Identifier) {
                continue;
            }

            status = IopOpenDeviceParametersSubkey( &subKeyHandle,
                                                    NULL,
                                                    PathName,
                                                    KEY_READ | KEY_WRITE
                                                    );
            if (NT_SUCCESS(status)) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
        } else {

            //
            // need to construct this key.
            //

            InitializeObjectAttributes(&objectAttributes,
                                       PathName,
                                       OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                       NULL,
                                       NULL);
            status = ZwCreateKey(&subKeyHandle,
                                 KEY_READ | KEY_WRITE,
                                 &objectAttributes,
                                 0,
                                 NULL,
                                 keySeed->Attribute,
                                 &disposition);
        }

        if (NT_SUCCESS(status)) {

            //
            // Check to see if this is the parameters key and
            // migrate the parameter information.
            //

            if (keySeed->Options & KEY_SEED_DEVICE_PARAMETERS) {

                if (FirmwareEntry->ControllerType == SerialController)  {

                    ComPortDBAdd(subKeyHandle, (PWSTR)FirmwareEntry->Identifier);
                } else {
                    //
                    // to get here there must be identifier information
                    // in the FirmwareEntry, so that check is not performed.
                    //
                    // NOTE: this will only happen once - when the key is
                    // created -- perhaps this needs to happen on every
                    // boot.
                    //

                    PiWstrToUnicodeString(&unicodeName,
                                        L"DosDeviceName");
                    ZwSetValueKey(subKeyHandle,
                                &unicodeName,
                                0,
                                FirmwareEntry->IdentifierType,
                                FirmwareEntry->Identifier,
                                FirmwareEntry->IdentifierLength);
                }
            }
            ZwClose(subKeyHandle);
        } else {

            //
            // ignore failures
            //

            IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                        "Mapper: failed to build control key %x\n",
                        status));
        }
    }

    //
    // Undo the mangling of the path name performed in the loop above.
    //

    *wcptr = (WCHAR) 0;
    PathName->Length = originalLength;

    //
    // Create values.
    //

    pnpid = FirmwareEntry->PnPId;
    for (valueSeed = MapperValueSeed; valueSeed->ValueName; valueSeed++) {

        if (valueSeed->ValueType == REG_DWORD) {

            if ((valueSeed->Options == OPTIONS_INSERT_PHANTOM_MARKER) &&
                !DeviceIsPhantom) {

                //
                // Device isn't a phantom--we don't want to mark it as such.
                //

                continue;
            }

            size = sizeof(ULONG);
            RtlCopyMemory(buffer, &valueSeed->DwordValueContent, size);

        } else if (valueSeed->Options == OPTIONS_INSERT_PNP_ID) {

            size = (ULONG)((wcslen(pnpid) + 2) * sizeof(WCHAR)); // eos multi_sz
            if (FirmwareEntry->BusType == Eisa) {

                //
                // need a mult_sz of EISA\PNPblah *PNPblah
                //

                RtlZeroMemory(buffer, SEED_BUFFER_SIZE);
                wcptr = (PWCHAR)pnpid;
                wcptr++;
                StringCbPrintfW(buffer, SEED_BUFFER_SIZE, L"EISA\\%s", wcptr);

                wcptr = buffer;
                while (*wcptr) {
                    wcptr++;
                }
                wcptr++; // step past eos for 1st string

                RtlCopyMemory(wcptr, pnpid, size);

                size += (ULONG)((PUCHAR)wcptr - (PUCHAR)buffer);
            } else {
                RtlCopyMemory(buffer, pnpid, size - sizeof(WCHAR));
                buffer[size / sizeof(WCHAR) - 1] = L'\0';
            }
        } else if (valueSeed->Options == OPTIONS_INSERT_COMPATIBLE_IDS) {
            if (FirmwareEntry->PeripheralType == KeyboardPeripheral)  {
                size = sizeof(PS2_KEYBOARD_COMPATIBLE_ID);
                RtlCopyMemory(buffer, PS2_KEYBOARD_COMPATIBLE_ID, size);
            } else if (FirmwareEntry->PeripheralType == PointerPeripheral &&
                       (wcscmp(pnpid, L"*PNP0F0E") == 0 ||
                        wcscmp(pnpid, L"*PNP0F03") == 0 ||
                        wcscmp(pnpid, L"*PNP0F12") == 0)) {
                size = sizeof(PS2_MOUSE_COMPATIBLE_ID);
                RtlCopyMemory(buffer, PS2_MOUSE_COMPATIBLE_ID, size);
            } else {
                continue;
            }
            buffer[size / 2] = L'\0';  // 2nd NUL for MULTI_SZ
            size += sizeof(L'\0');
        } else if (valueSeed->Options == OPTIONS_INSERT_DEVICEDESC) {
            size = FirmwareEntry->IdentifierLength;
            RtlCopyMemory(buffer, FirmwareEntry->Identifier, size);
        } else {
            IopDbgPrint((IOP_MAPPER_WARNING_LEVEL, "Mapper: NO VALUE TYPE!\n"));
            ASSERT(FALSE);
            continue;
        }

        RtlInitUnicodeString(&unicodeName,
                             valueSeed->ValueName);
        ZwSetValueKey(Handle,
                      &unicodeName,
                      0,
                      valueSeed->ValueType,
                      buffer,
                      size);
    }
    ExFreePool(buffer);
}


VOID
MapperFreeList(
    VOID
    )

/*++

Routine Description:

    This routine walks through the list of firmware entries
    and frees all allocated memory.

Arguments:

    None

Return Value:

    None

--*/

{
    PDEVICE_EXTENSION       deviceExtension = &MapperDeviceExtension;
    PFIRMWARE_CONFIGURATION tempEntry;
    PFIRMWARE_CONFIGURATION firmwareEntry;

    firmwareEntry = deviceExtension->FirmwareList;
    while (firmwareEntry) {

        //
        // free allocated structures associated with the firmware entry
        //

        if (firmwareEntry->ResourceDescriptor) {
            ExFreePool(firmwareEntry->ResourceDescriptor);
        }
        if (firmwareEntry->Identifier) {
            ExFreePool(firmwareEntry->Identifier);
        }

        //
        // free this entry and move to the next
        //

        tempEntry = firmwareEntry->Next;
        ExFreePool(firmwareEntry);
        firmwareEntry = tempEntry;
    }
}

VOID
MapperConstructRootEnumTree(
    IN BOOLEAN CreatePhantomDevices
    )

/*++

Routine Description:

    This routine walks through the list of firmware entries
    in the device extension and migrates the information into
    the root enumerator's tree in the registry.

Arguments:

    CreatePhantomDevices - If non-zero, then the device instances are created
        as "phantoms" (i.e., they are marked with the "Phantom" value entry so
        that the root enumerator will ignore them).  The only time these device
        instance registry keys will ever turn into real live devnodes is if the
        class installer (in response to DIF_FIRSTTIMESETUP or DIF_DETECT)
        decides that these devices aren't duplicates of any PnP-enumerated
        devnodes, and subsequently registers and installs them.

Return Value:

    None

--*/

{
#define ENUM_KEY_BUFFER_SIZE (1024 * sizeof(WCHAR))
#define INSTANCE_BUFFER_SIZE (256 * sizeof(WCHAR))
    UNICODE_STRING          enumKey;
    PFIRMWARE_CONFIGURATION firmwareEntry;
    OBJECT_ATTRIBUTES       objectAttributes;
    NTSTATUS                status;
    BOOLEAN                 keyPresent;
    PWCHAR                  registryBase;
    PWCHAR                  instanceBuffer;
    HANDLE                  handle;
    ULONG                   disposition;
    PVOID                   buffer;
    PDEVICE_EXTENSION       DeviceExtension = &MapperDeviceExtension;

    PAGED_CODE();

    //
    // allocate space needed for the registry path into the root
    // enumerator tree.  Note, limited size on path length.
    //

    buffer = ExAllocatePool(NonPagedPool, ENUM_KEY_BUFFER_SIZE);

    if (!buffer) {
        MapperFreeList();
        IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                    "Mapper: could not allocate memory for registry update\n"));
        return;
    }

    instanceBuffer = ExAllocatePool(NonPagedPool, INSTANCE_BUFFER_SIZE);
    if (!instanceBuffer) {
        MapperFreeList();
        ExFreePool(buffer);
        IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                    "Mapper: could not allocate memory for instance buffer\n"));
        return;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &enumKey,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

#if UMODETEST
    registryBase = L"\\Registry\\Machine\\System\\TestControlSet\\Enum\\Root\\";
#else
    registryBase = L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root\\";
#endif

    firmwareEntry = DeviceExtension->FirmwareList;
    while (firmwareEntry) {

        //
        // Construct the base for the path for this entry.
        //


        PiWstrToUnicodeString(&enumKey, NULL);
        enumKey.MaximumLength = ENUM_KEY_BUFFER_SIZE;
        enumKey.Buffer = buffer;
        RtlZeroMemory(buffer, ENUM_KEY_BUFFER_SIZE);
        RtlAppendUnicodeToString(&enumKey, registryBase);
        RtlAppendUnicodeToString(&enumKey, firmwareEntry->PnPId);

        //
        // Build the pnp Key.
        //

        status = ZwCreateKey(&handle,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &disposition);

        if (NT_SUCCESS(status)) {

            //
            // Do not need the handle, so close it
            // Remember if the key was present prior to call
            //

            ZwClose(handle);
            keyPresent = (disposition == REG_OPENED_EXISTING_KEY) ? TRUE : FALSE;
            IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                        "Mapper: Key was %s\n",
                        keyPresent ? "Present" : "Created"));

            //
            // Construct the instance name.
            //

            RtlZeroMemory(instanceBuffer, INSTANCE_BUFFER_SIZE);
            StringCbPrintfW(
                instanceBuffer,
                INSTANCE_BUFFER_SIZE,
                L"\\%d_%d_%d_%d_%d_%d",
                firmwareEntry->BusType,
                firmwareEntry->BusNumber,
                firmwareEntry->ControllerType,
                firmwareEntry->ControllerNumber,
                firmwareEntry->PeripheralType,
                firmwareEntry->PeripheralNumber);
            RtlAppendUnicodeToString(&enumKey, instanceBuffer);

            status = ZwCreateKey(&handle,
                                 KEY_READ | KEY_WRITE,
                                 &objectAttributes,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 &disposition);

            if (NT_SUCCESS(status)) {

                if (firmwareEntry->ResourceDescriptor) {
                    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                                "Mapper: firmware entry has resources %x\n",
                                firmwareEntry->ResourceDescriptor));
                }

                if (firmwareEntry->Identifier) {
                    IopDbgPrint((IOP_MAPPER_INFO_LEVEL,
                                "Mapper: firmware entry has identifier %x\n",
                                firmwareEntry->Identifier));
                }

                //
                // If the key already exists because it was explicitly migrated
                // during textmode setup, we should still consider it a "new key".
                //
                if (disposition != REG_CREATED_NEW_KEY) {
                    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
                    UNICODE_STRING unicodeString;

                    status = IopGetRegistryValue(handle,
                                                 REGSTR_VALUE_MIGRATED,
                                                 &keyValueInformation);
                    if (NT_SUCCESS(status)) {

                        if ((keyValueInformation->Type == REG_DWORD) &&
                            (keyValueInformation->DataLength == sizeof(ULONG)) &&
                            ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                            disposition = REG_CREATED_NEW_KEY;
                        }

                        ExFreePool(keyValueInformation);

                        PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                        ZwDeleteValueKey(handle, &unicodeString);
                    }
                }

                //
                // Only if this is a new entry do we see the key.
                //

                if (disposition == REG_CREATED_NEW_KEY) {

                    //
                    // Remember the fact that the key was newly-created for the
                    // PnP BIOS case where we need to come along and "phantomize"
                    // all newly-created ntdetect COM ports.
                    //

                    firmwareEntry->NewlyCreated = TRUE;

                    //
                    // Create enough information to get pnp to
                    // install drivers
                    //

                    MapperSeedKey(handle,
                                  &enumKey,
                                  firmwareEntry,
                                  CreatePhantomDevices
                                 );
                }
                MapperMarkKey(handle,
                              &enumKey,
                              firmwareEntry);
                ZwClose(handle);

            } else {
                IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                            "Mapper: create of instance key failed %x\n",
                            status));
            }

        } else {
            IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                        "Mapper: create pnp key failed %x\n",
                        status));
        }

        firmwareEntry = firmwareEntry->Next;
    }
    ExFreePool(instanceBuffer);
}

PCM_RESOURCE_LIST
MapperAdjustResourceList (
    IN     PCM_RESOURCE_LIST ResourceList,
    IN     WCHAR const*      PnPId,
    IN OUT PULONG            Size
    )
{
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR problemPartialDescriptors;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    PCM_RESOURCE_LIST               newResourceList;
    ULONG                           i;

    newResourceList = ResourceList;

#if _X86_
    if (KeI386MachineType == MACHINE_TYPE_EISA) {

        PCM_FULL_RESOURCE_DESCRIPTOR    fullDescriptor;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
        PUCHAR                          nextDescriptor;
        ULONG                           j;
        ULONG                           lastResourceIndex;

        fullDescriptor = &ResourceList->List[0];

        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &fullDescriptor->PartialResourceList;

            for (j = 0; j < partialResourceList->Count; j++) {
                partialDescriptor = &partialResourceList->PartialDescriptors[j];

                if (partialDescriptor->Type == CmResourceTypePort) {
                    if (partialDescriptor->u.Port.Start.HighPart == 0 &&
                        (partialDescriptor->u.Port.Start.LowPart & 0x00000300) == 0) {
                        partialDescriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
                }
            }

            nextDescriptor = (PUCHAR)fullDescriptor + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

            //
            // account for any resource descriptors in addition to the single
            // imbedded one I've already accounted for (if there aren't any,
            // then I'll end up subtracting off the extra imbedded descriptor
            // from the previous step)
            //
            //
            // finally, account for any extra device specific data at the end of
            // the last partial resource descriptor (if any)
            //
            if (partialResourceList->Count > 0) {

                nextDescriptor += (partialResourceList->Count - 1) *
                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                lastResourceIndex = partialResourceList->Count - 1;

                if (partialResourceList->PartialDescriptors[lastResourceIndex].Type ==
                          CmResourceTypeDeviceSpecific) {

                    nextDescriptor += partialResourceList->PartialDescriptors[lastResourceIndex].
                               u.DeviceSpecificData.DataSize;
                }
            }

            fullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)nextDescriptor;
        }
    }
#endif

    if (wcscmp(PnPId, FloppyId) == 0) {

        if (ResourceList->Count == 1) {

            partialResourceList = &ResourceList->List->PartialResourceList;

            partialDescriptors = partialResourceList->PartialDescriptors;

            //
            // Look for the one and only one 8 byte port resource
            //
            problemPartialDescriptors = NULL;
            for (i=0; i<partialResourceList->Count; i++) {

                if ((partialDescriptors[i].Type == CmResourceTypePort) &&
                    (partialDescriptors[i].u.Port.Length == 8)) {

                    if (problemPartialDescriptors == NULL) {

                        problemPartialDescriptors = partialDescriptors + i;
                    } else {

                        problemPartialDescriptors = NULL;
                        break;
                    }
                }
            }

            if (problemPartialDescriptors) {

                problemPartialDescriptors->u.Port.Length = 6;

                newResourceList = ExAllocatePool (
                                      NonPagedPool,
                                      *Size + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                                      );
                if (newResourceList) {

                    RtlCopyMemory (
                        newResourceList,
                        ResourceList,
                        *Size
                        );

                    //
                    // pick out the new partial resource descriptor
                    //
                    partialDescriptors = newResourceList->List->
                                             PartialResourceList.PartialDescriptors;
                    partialDescriptors += newResourceList->List->PartialResourceList.Count;

                    RtlCopyMemory (
                        partialDescriptors,
                        problemPartialDescriptors,
                        sizeof(*partialDescriptors)
                        );

                    partialDescriptors->u.Port.Start.QuadPart += 7;
                    partialDescriptors->u.Port.Length = 1;

                    //
                    // we got one more now
                    //
                    newResourceList->List->PartialResourceList.Count++;
                    *Size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                    ExFreePool (ResourceList);

                } else {

                    newResourceList = ResourceList;
                }
            }
        }
    }

    return newResourceList;
}

NTSTATUS
ComPortDBAdd(
    IN  HANDLE  DeviceParamKey,
    IN  PWSTR   PortName
    )
{
    UNICODE_STRING                  portNameString;
    UNICODE_STRING                  portPrefixString;
    UNICODE_STRING                  comDBName;
    UNICODE_STRING                  valueName;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;
    HANDLE                          comDBKey;
    ULONG                           portNo;
    NTSTATUS                        status;

    RtlInitUnicodeString(&portNameString, PortName);

    if (portNameString.Length > 3 * sizeof(WCHAR)) {
        portNameString.Length = 3 * sizeof(WCHAR);
    }

    PiWstrToUnicodeString(&portPrefixString, L"COM");

    if (RtlCompareUnicodeString(&portNameString, &portPrefixString, TRUE) == 0) {
        portNo = _wtol(&PortName[3]);

        if (portNo > 0 && portNo <= 256) {

#if UMODETEST
            PiWstrToUnicodeString(&comDBName, L"\\Registry\\Machine\\System\\TestControlSet\\Control\\COM Name Arbiter");
#else
            PiWstrToUnicodeString(&comDBName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter");
#endif

            status = IopCreateRegistryKeyEx( &comDBKey,
                                             NULL,
                                             &comDBName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );

            if (NT_SUCCESS(status)) {

                PiWstrToUnicodeString(&valueName, L"ComDB Merge");

#define COMPORT_DB_MERGE_SIZE    32           //  256 / 8

                valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + COMPORT_DB_MERGE_SIZE;
                valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

                if (valueInfo != NULL) {

                    status = ZwQueryValueKey( comDBKey,
                                              &valueName,
                                              KeyValuePartialInformation,
                                              valueInfo,
                                              valueInfoLength,
                                              &returnedLength);

                    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

                        valueInfo->Type = REG_BINARY;
                        valueInfo->DataLength = COMPORT_DB_MERGE_SIZE;
                        RtlZeroMemory(valueInfo->Data, valueInfo->DataLength);
                        status = STATUS_SUCCESS;
                    }

                    if (NT_SUCCESS(status)) {
                        portNo--;
                        valueInfo->Data[ portNo / 8 ] |= 1 << (portNo % 8);

                        status = ZwSetValueKey( comDBKey,
                                                &valueName,
                                                0,
                                                valueInfo->Type,
                                                valueInfo->Data,
                                                valueInfo->DataLength );

                        ASSERT(NT_SUCCESS(status));
                    }

                    ExFreePool(valueInfo);
                }

                ZwClose(comDBKey);
            }
        }
    }

    PiWstrToUnicodeString( &valueName, L"DosDeviceName" );

    status = ZwSetValueKey( DeviceParamKey,
                            &valueName,
                            0,
                            REG_SZ,
                            PortName,
                            (ULONG)((wcslen(PortName) + 1) * sizeof(WCHAR)) );

    return status;
}

VOID
MapperPhantomizeDetectedComPorts (
    VOID
    )
/*++

Routine Description:

    This routine turns all newly-created firmware/ntdetect COM ports into
    phantoms.

Arguments:

    None

Return Value:

    None

--*/
{
    PFIRMWARE_CONFIGURATION firmwareEntry;
    NTSTATUS                status;
    PWCHAR                  registryBase;
    PWCHAR                  instanceBuffer;
    HANDLE                  handle;
    PWCHAR                  buffer;
    PDEVICE_EXTENSION       DeviceExtension = &MapperDeviceExtension;
    UNICODE_STRING          enumKey;
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          unicodeName;
    ULONG                   regValue;

    //
    // allocate space needed for the registry path into the root
    // enumerator tree.  Note, limited size on path length.
    //

    buffer = ExAllocatePool(NonPagedPool, ENUM_KEY_BUFFER_SIZE);

    if (!buffer) {
        IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                    "Mapper: could not allocate memory for registry update\n"));
        return;
    }

    instanceBuffer = ExAllocatePool(NonPagedPool, INSTANCE_BUFFER_SIZE);
    if (!instanceBuffer) {
        ExFreePool(buffer);
        IopDbgPrint((IOP_MAPPER_WARNING_LEVEL,
                    "Mapper: could not allocate memory for instance buffer\n"));
        return;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &enumKey,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

#if UMODETEST
    registryBase = L"\\Registry\\Machine\\System\\TestControlSet\\Enum\\Root\\";
#else
    registryBase = L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root\\";
#endif

    firmwareEntry = DeviceExtension->FirmwareList;
    while (firmwareEntry) {

        //
        // Construct the base for the path for this entry.
        //


        if ((firmwareEntry->ControllerType == SerialController) &&
            firmwareEntry->NewlyCreated) {

            PiWstrToUnicodeString(&enumKey, NULL);
            enumKey.MaximumLength = ENUM_KEY_BUFFER_SIZE;
            enumKey.Buffer = buffer;
            RtlZeroMemory(buffer, ENUM_KEY_BUFFER_SIZE);
            RtlAppendUnicodeToString(&enumKey, registryBase);
            RtlAppendUnicodeToString(&enumKey, firmwareEntry->PnPId);

            //
            // Construct the instance name.
            //

            RtlZeroMemory(instanceBuffer, INSTANCE_BUFFER_SIZE);
            StringCbPrintfW(
                instanceBuffer,
                INSTANCE_BUFFER_SIZE,
                L"\\%d_%d_%d_%d_%d_%d",
                firmwareEntry->BusType,
                firmwareEntry->BusNumber,
                firmwareEntry->ControllerType,
                firmwareEntry->ControllerNumber,
                firmwareEntry->PeripheralType,
                firmwareEntry->PeripheralNumber);
            RtlAppendUnicodeToString(&enumKey, instanceBuffer);

            status = ZwOpenKey(&handle,
                               KEY_READ | KEY_WRITE,
                               &objectAttributes
                              );

            if (NT_SUCCESS(status)) {

                PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_PHANTOM);
                regValue = 1;
                ZwSetValueKey(handle,
                              &unicodeName,
                              0,
                              REG_DWORD,
                              &regValue,
                              sizeof(regValue)
                             );

                ZwClose(handle);
            }
        }

        firmwareEntry = firmwareEntry->Next;
    }

    ExFreePool (buffer);
    ExFreePool (instanceBuffer);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\iopfileutil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    IopFileUtil.h

Abstract:

    This header contains private information to implement various file utility
    functions for the Io subsystem. This file is mean to be included only by
    IoFileUtil.c.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

typedef struct {

    LIST_ENTRY Link;
    UNICODE_STRING Directory;
    WCHAR Name[1];

} DIRWALK_ENTRY, *PDIRWALK_ENTRY;

NTSTATUS
IopFileUtilWalkDirectoryTreeHelper(
    IN      PUNICODE_STRING  Directory,
    IN      ULONG            Flags,
    IN      DIRWALK_CALLBACK CallbackFunction,
    IN      PVOID            Context,
    IN      PUCHAR           Buffer,
    IN      ULONG            BufferSize,
    IN OUT  PLIST_ENTRY      DirList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pihotswap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PiHotSwap.h

Abstract:

    This header contains private prototypes for managing hotswappable devices.
    This file should be included only by PpHotSwap.c.

Author:

    Adrian J. Oney (AdriaO) 02/10/2001

Revision History:

--*/

VOID
PiHotSwapGetDetachableNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT PDEVICE_NODE   *DetachableNode
    );

VOID
PiHotSwapGetDefaultBusRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pilastgood.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pilastgood.h

Abstract:

    This header contains private information to implement last known good
    support in the IO subsystem. This file is meant to be included only by
    pplastgood.c.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

VOID
PiLastGoodRevertLastKnownDirectory(
    IN PUNICODE_STRING  LastKnownGoodDirectory,
    IN PUNICODE_STRING  LastKnownGoodRegPath
    );

NTSTATUS
PiLastGoodRevertCopyCallback(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    );

NTSTATUS
PiLastGoodCopyKeyContents(
    IN PUNICODE_STRING  SourceRegPath,
    IN PUNICODE_STRING  DestinationRegPath,
    IN BOOLEAN          DeleteSourceKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pihandle.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PiHandle.h

Abstract:

    This header contains private information to implement handle walking
    support in the PNP subsystem. This file is meant to be included only by
    pphandle.c.

Author:

    Adrian J. Oney  - April 4, 2001

Revision History:

--*/

typedef struct {

    PDEVICE_OBJECT                  DeviceObject;
    PEPROCESS                       Process;
    PHANDLE_ENUMERATION_CALLBACK    CallBack;
    PVOID                           Context;

} HANDLE_ENUM_CONTEXT, *PHANDLE_ENUM_CONTEXT;

LOGICAL
PiHandleEnumerateHandlesAgainstDeviceObject(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    );

BOOLEAN
PiHandleProcessWalkWorker(
    IN  PHANDLE_TABLE_ENTRY     ObjectTableEntry,
    IN  HANDLE                  HandleId,
    IN  PHANDLE_ENUM_CONTEXT    EnumContext
    );

//
// This macro uses private information from the ntos\ex module. It should be
// replaced with an inter-module define or function
//
#define OBJECT_FROM_EX_TABLE_ENTRY(x) \
    (POBJECT_HEADER)((ULONG_PTR)(x)->Object & ~7)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\notify.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    notify.c

Abstract:

    This module contains APIs and routines for handling device event
    notifications.

Author:


Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <pnpmgr.h>
#include <pnpsetup.h>

#define PNP_DEVICE_EVENT_ENTRY_TAG 'EEpP'
//
// Locks the list and inserts the entry at the tail.
//
#define PiLockedInsertTailList(list, lock, entry) { \
    IopAcquireNotifyLock((lock));                   \
    InsertTailList((list), (entry));                \
    IopReleaseNotifyLock((lock));                   \
}

#define PiGetSession(c,i)   ((PVOID)(MmIsSessionAddress((PVOID)c)? MmGetSessionById(i) : NULL))

typedef struct _ASYNC_TDC_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_CHANGE_COMPLETE_CALLBACK Callback;
    PVOID Context;
    PTARGET_DEVICE_CUSTOM_NOTIFICATION NotificationStructure;
}   ASYNC_TDC_WORK_ITEM, *PASYNC_TDC_WORK_ITEM;

typedef struct _DEFERRED_REGISTRATION_ENTRY {
    LIST_ENTRY            ListEntry;
    PNOTIFY_ENTRY_HEADER  NotifyEntry;
} DEFERRED_REGISTRATION_ENTRY, *PDEFERRED_REGISTRATION_ENTRY;
//
// Kernel mode notification data
//
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#pragma  const_seg("PAGECONST")
#endif

LIST_ENTRY IopDeviceClassNotifyList[NOTIFY_DEVICE_CLASS_HASH_BUCKETS] = {NULL};
PSETUP_NOTIFY_DATA IopSetupNotifyData = NULL;
LIST_ENTRY IopProfileNotifyList = {NULL};
LIST_ENTRY IopDeferredRegistrationList = {NULL};

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

KGUARDED_MUTEX  IopDeviceClassNotifyLock;
KGUARDED_MUTEX  IopTargetDeviceNotifyLock;
KGUARDED_MUTEX  IopHwProfileNotifyLock;
KGUARDED_MUTEX  IopDeferredRegistrationLock;
BOOLEAN     PiNotificationInProgress;
KGUARDED_MUTEX  PiNotificationInProgressLock;

//
// Prototypes
//

VOID
IopDereferenceNotify(
    PNOTIFY_ENTRY_HEADER Notify
    );

VOID
IopInitializePlugPlayNotification(
    VOID
    );

NTSTATUS
PiNotifyUserMode(
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent
    );

NTSTATUS
PiNotifyDriverCallback(
    IN  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE  CallbackRoutine,
    IN  PVOID   NotificationStructure,
    IN  PVOID   Context,
    IN  ULONG   SessionId,
    IN  PVOID   OpaqueSession,
    OUT PNTSTATUS  CallbackStatus  OPTIONAL
    );

VOID
IopReferenceNotify(
    PNOTIFY_ENTRY_HEADER notify
    );

VOID
IopReportTargetDeviceChangeAsyncWorker(
    PVOID Context
    );

NTSTATUS
PiDeferNotification(
    IN PNOTIFY_ENTRY_HEADER Entry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IopInitializePlugPlayNotification)

#pragma alloc_text(PAGE, IoGetRelatedTargetDevice)
#pragma alloc_text(PAGE, IoNotifyPowerOperationVetoed)
#pragma alloc_text(PAGE, IoPnPDeliverServicePowerNotification)
#pragma alloc_text(PAGE, IoRegisterPlugPlayNotification)
#pragma alloc_text(PAGE, IoReportTargetDeviceChange)
#pragma alloc_text(PAGE, IoUnregisterPlugPlayNotification)
#pragma alloc_text(PAGE, IopDereferenceNotify)
#pragma alloc_text(PAGE, IopGetRelatedTargetDevice)
#pragma alloc_text(PAGE, IopNotifyDeviceClassChange)
#pragma alloc_text(PAGE, IopNotifyHwProfileChange)
#pragma alloc_text(PAGE, IopNotifySetupDeviceArrival)
#pragma alloc_text(PAGE, IopNotifyTargetDeviceChange)
#pragma alloc_text(PAGE, IopOrphanNotification)
#pragma alloc_text(PAGE, IopProcessDeferredRegistrations)
#pragma alloc_text(PAGE, IopReferenceNotify)
#pragma alloc_text(PAGE, IopReportTargetDeviceChangeAsyncWorker)
#pragma alloc_text(PAGE, IopRequestHwProfileChangeNotification)
#pragma alloc_text(PAGE, PiNotifyDriverCallback)
#pragma alloc_text(PAGE, PiDeferNotification)

#endif // ALLOC_PRAGMA


NTSTATUS
IoUnregisterPlugPlayNotification(
    IN PVOID NotificationEntry
    )

/*++

Routine Description:

    This routine unregisters a notification previously registered via
    IoRegisterPlugPlayNotification.  A driver cannot be unloaded until it has
    unregistered all of its notification handles.

Parameters:

    NotificationEntry - This provices the cookie returned by IoRegisterPlugPlayNotification
        which identifies the registration in question.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PNOTIFY_ENTRY_HEADER entry;
    PKGUARDED_MUTEX lock;
    BOOLEAN wasDeferred = FALSE;
    PLIST_ENTRY link;
    PDEFERRED_REGISTRATION_ENTRY deferredNode;

    PAGED_CODE();

    ASSERT(NotificationEntry);

    entry = (PNOTIFY_ENTRY_HEADER)NotificationEntry;

    lock = entry->Lock;

    KeAcquireGuardedMutex(&PiNotificationInProgressLock);

    if (PiNotificationInProgress) {
        //
        // Before unregistering the entry, we need to make sure that it's not sitting
        // around in the deferred registration list.
        //
        IopAcquireNotifyLock(&IopDeferredRegistrationLock);

        link = IopDeferredRegistrationList.Flink;
        while (link != (PLIST_ENTRY)&IopDeferredRegistrationList) {

            deferredNode = (PDEFERRED_REGISTRATION_ENTRY)link;
            ASSERT(deferredNode->NotifyEntry->Unregistered);
            if (deferredNode->NotifyEntry == entry) {

                wasDeferred = TRUE;
                if (lock) {

                    IopAcquireNotifyLock(lock);
                }

                link = link->Flink;

                RemoveEntryList((PLIST_ENTRY)deferredNode);
                IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)deferredNode->NotifyEntry);

                if (lock) {

                    IopReleaseNotifyLock(lock);
                }
                ExFreePool(deferredNode);
            } else {

                link = link->Flink;
            }
        }

        IopReleaseNotifyLock(&IopDeferredRegistrationLock);
    } else {
        //
        // If there is currently no notification in progress, the deferred
        // registration list must be empty.
        //
        ASSERT(IsListEmpty(&IopDeferredRegistrationList));
    }

    KeReleaseGuardedMutex(&PiNotificationInProgressLock);
    //
    // Acquire lock
    //
    if (lock) {

        IopAcquireNotifyLock(lock);
    }

    ASSERT(wasDeferred == entry->Unregistered);

    if (!entry->Unregistered || wasDeferred) {
        //
        // Dereference the entry if it is currently registered, or had its
        // registration pending completion of the notification in progress.
        //
        //
        // Mark the entry as unregistered so we don't notify on it
        //
        entry->Unregistered = TRUE;
        //
        // Dereference it thus deleting if no longer required
        //
        IopDereferenceNotify(entry);
    }
    //
    // Release the lock
    //
    if (lock) {

        IopReleaseNotifyLock(lock);
    }

    return STATUS_SUCCESS;
}

VOID
IopProcessDeferredRegistrations(
    VOID
    )
/*++

Routine Description:

    This routine removes notification entries from the deferred registration
    list, marking them as "registered" so that they can receive notifications.

Parameters:

    None.

Return Value:

    None.

  --*/
{
    PDEFERRED_REGISTRATION_ENTRY deferredNode;
    PKGUARDED_MUTEX lock;

    PAGED_CODE();

    IopAcquireNotifyLock(&IopDeferredRegistrationLock);

    while (!IsListEmpty(&IopDeferredRegistrationList)) {

        deferredNode = (PDEFERRED_REGISTRATION_ENTRY)RemoveHeadList(&IopDeferredRegistrationList);

        //
        // Acquire this entry's list lock.
        //
        lock = deferredNode->NotifyEntry->Lock;
        if (lock) {
            IopAcquireNotifyLock(lock);
        }

        //
        // Mark this entry as registered.
        //
        deferredNode->NotifyEntry->Unregistered = FALSE;

        //
        // Dereference the notification entry when removing it from the deferred
        // list, and free the node.
        //
        IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)deferredNode->NotifyEntry);
        ExFreePool(deferredNode);

        //
        // Release this entry's list lock.
        //
        if (lock) {
            IopReleaseNotifyLock(lock);
            lock = NULL;
        }
    }

    IopReleaseNotifyLock(&IopDeferredRegistrationLock);
}

NTSTATUS
PiDeferNotification(
    IN PNOTIFY_ENTRY_HEADER Entry
    )
/*++

Routine Description:

    If a notification is currently in progress, this routine will insert the 
    notification into the list of deferred notifications.

Parameters:

    Entry - Notification entry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    NTSTATUS status;
    PDEFERRED_REGISTRATION_ENTRY deferredNode;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    KeAcquireGuardedMutex(&PiNotificationInProgressLock);

    if (PiNotificationInProgress) {
        //
        // If a notification is in progress, mark the entry as
        // Unregistered until after the current notification is
        // complete.
        //
        deferredNode = ExAllocatePool(PagedPool, sizeof(DEFERRED_REGISTRATION_ENTRY));
        if (deferredNode) {

            deferredNode->NotifyEntry = Entry;
            //
            // Consider this entry unregistered during the current
            // notification
            //
            Entry->Unregistered = TRUE;
            //
            // Reference the entry so that it doesn't go away until it has
            // been removed from the deferred registration list
            //
            IopReferenceNotify(Entry);
            //
            // Add this entry to the deferred registration list
            //
            IopAcquireNotifyLock(&IopDeferredRegistrationLock);

            InsertTailList(&IopDeferredRegistrationList, &deferredNode->ListEntry);

            IopReleaseNotifyLock(&IopDeferredRegistrationLock);

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        //
        // If there is currently no notification in progress, the deferred
        // registration list must be empty.
        //
        ASSERT(IsListEmpty(&IopDeferredRegistrationList));
    }

    KeReleaseGuardedMutex(&PiNotificationInProgressLock);

    return status;
}

NTSTATUS
IoReportTargetDeviceChange(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    )

/*++

Routine Description:

    This routine may be used to give notification of 3rd-party target device
    change events.  This API will notify every driver that has registered for
    notification on a file object associated with PhysicalDeviceObject about
    the event indicated in the NotificationStructure.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO that the change begin
        reported is associated with.

    NotificationStructure - Provides a pointer to the notification structure to be
        sent to all parties registered for notifications about changes to
        PhysicalDeviceObject.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    This API may only be used to report non-PnP target device changes.  In particular,
    it will fail if it's called with the NotificationStructure->Event field set to
    GUID_TARGET_DEVICE_QUERY_REMOVE, GUID_TARGET_DEVICE_REMOVE_CANCELLED, or
    GUID_TARGET_DEVICE_REMOVE_COMPLETE.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT completionEvent;
    NTSTATUS completionStatus;
    PTARGET_DEVICE_CUSTOM_NOTIFICATION notifyStruct;
    LONG                   dataSize;

    PAGED_CODE();

    notifyStruct = (PTARGET_DEVICE_CUSTOM_NOTIFICATION)NotificationStructure;

    ASSERT(notifyStruct);

    ASSERT_PDO(PhysicalDeviceObject);

    ASSERT(NULL == notifyStruct->FileObject);

    if (IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_QUERY_REMOVE) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_CANCELLED) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {
        //
        //  Passed in an illegal value
        //
        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "IoReportTargetDeviceChange: "
            "Illegal Event type passed as custom notification\n"));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (notifyStruct->Size < FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    dataSize = notifyStruct->Size - FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);

    if (notifyStruct->NameBufferOffset != -1 && notifyStruct->NameBufferOffset > dataSize)  {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);

    status = PpSetCustomTargetEvent( PhysicalDeviceObject,
                                     &completionEvent,
                                     (PULONG)&completionStatus,
                                     NULL,
                                     NULL,
                                     notifyStruct);
    if (NT_SUCCESS(status))  {

        KeWaitForSingleObject(&completionEvent, Executive, KernelMode, FALSE, NULL);
        status = completionStatus;
    }

    return status;
}

NTSTATUS
IoReportTargetDeviceChangeAsynchronous(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure,  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    IN PDEVICE_CHANGE_COMPLETE_CALLBACK Callback        OPTIONAL,
    IN PVOID Context    OPTIONAL
    )

/*++

Routine Description:

    This routine may be used to give notification of 3rd-party target device
    change events.  This API will notify every driver that has registered for
    notification on a file object associated with PhysicalDeviceObject about
    the event indicated in the NotificationStructure.

Parameters:

    PhysicalDeviceObject - Provides a pointer to the PDO that the change begin
        reported is associated with.

    NotificationStructure - Provides a pointer to the notification structure to be
        sent to all parties registered for notifications about changes to
        PhysicalDeviceObject.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    This API may only be used to report non-PnP target device changes.  In particular,
    it will fail if it's called with the NotificationStructure->Event field set to
    GUID_TARGET_DEVICE_QUERY_REMOVE, GUID_TARGET_DEVICE_REMOVE_CANCELLED, or
    GUID_TARGET_DEVICE_REMOVE_COMPLETE.

--*/
{
    PASYNC_TDC_WORK_ITEM    asyncWorkItem;
    PWORK_QUEUE_ITEM        workItem;
    NTSTATUS                status;
    LONG                    dataSize;

    PTARGET_DEVICE_CUSTOM_NOTIFICATION   notifyStruct;

    notifyStruct = (PTARGET_DEVICE_CUSTOM_NOTIFICATION)NotificationStructure;

    ASSERT(notifyStruct);

    ASSERT_PDO(PhysicalDeviceObject);

    ASSERT(NULL == notifyStruct->FileObject);

    if (IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_QUERY_REMOVE) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_CANCELLED) ||
        IopCompareGuid(&notifyStruct->Event, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {
        //
        //  Passed in an illegal value
        //
        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "IoReportTargetDeviceChangeAsynchronous: "
            "Illegal Event type passed as custom notification\n"));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (notifyStruct->Size < FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    dataSize = notifyStruct->Size - FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);

    if (notifyStruct->NameBufferOffset != -1 && notifyStruct->NameBufferOffset > dataSize)  {

        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Since this routine can be called at DPC level we need to queue
    // a work item and process it when the irql drops.
    //
    asyncWorkItem = ExAllocatePool( NonPagedPool,
                                    sizeof(ASYNC_TDC_WORK_ITEM) + notifyStruct->Size);

    if (asyncWorkItem != NULL) {
        //
        // ISSUE-ADRIAO-2000/08/24 - We should use an IO work item here.
        //
        ObReferenceObject(PhysicalDeviceObject);

        asyncWorkItem->DeviceObject = PhysicalDeviceObject;
        asyncWorkItem->NotificationStructure =
            (PTARGET_DEVICE_CUSTOM_NOTIFICATION)((PUCHAR)asyncWorkItem + sizeof(ASYNC_TDC_WORK_ITEM));

        RtlCopyMemory( asyncWorkItem->NotificationStructure,
                       notifyStruct,
                       notifyStruct->Size);

        asyncWorkItem->Callback = Callback;
        asyncWorkItem->Context = Context;
        workItem = &asyncWorkItem->WorkItem;

        ExInitializeWorkItem(workItem, IopReportTargetDeviceChangeAsyncWorker, asyncWorkItem);
        //
        // Queue a work item to do the enumeration
        //
        ExQueueWorkItem(workItem, DelayedWorkQueue);
        status = STATUS_PENDING;
    } else {
        //
        // Failed to allocate memory for work item.  Nothing we can do ...
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

VOID
IopReportTargetDeviceChangeAsyncWorker(
    PVOID Context
    )

/*++

Routine Description:

    This routine is the worker routine of IoInvalidateDeviceState.
    Its main purpose is to invoke IopSynchronousQueryDeviceState and release
    work item space.

Parameters:

    Context - Supplies a pointer to the ASYNC_TDC_WORK_ITEM.

ReturnValue:

    None.

--*/

{
    PASYNC_TDC_WORK_ITEM asyncWorkItem = (PASYNC_TDC_WORK_ITEM)Context;

    PAGED_CODE();

    PpSetCustomTargetEvent( asyncWorkItem->DeviceObject,
                            NULL,
                            NULL,
                            asyncWorkItem->Callback,
                            asyncWorkItem->Context,
                            asyncWorkItem->NotificationStructure);

    ObDereferenceObject(asyncWorkItem->DeviceObject);
    ExFreePool(asyncWorkItem);
}

VOID
IopInitializePlugPlayNotification(
    VOID
    )

/*++

Routine Description:

    This routine performs initialization required before any of the notification
    APIs can be called.

Parameters:

    None

Return Value:

    None

--*/

{
    ULONG count;

    PAGED_CODE();

    //
    // Initialize the notification structures
    //
    for (count = 0; count < NOTIFY_DEVICE_CLASS_HASH_BUCKETS; count++) {

        InitializeListHead(&IopDeviceClassNotifyList[count]);

    }
    //
    // Initialize the profile notification list
    //
    InitializeListHead(&IopProfileNotifyList);

    //
    // Initialize the deferred registration list
    //
    InitializeListHead(&IopDeferredRegistrationList);

    KeInitializeGuardedMutex(&IopDeviceClassNotifyLock);
    KeInitializeGuardedMutex(&IopTargetDeviceNotifyLock);
    KeInitializeGuardedMutex(&IopHwProfileNotifyLock);
    KeInitializeGuardedMutex(&IopDeferredRegistrationLock);
}

VOID
IopReferenceNotify(
    PNOTIFY_ENTRY_HEADER Notify
    )

/*++

Routine Description:

    This routine increments the reference count for a notification entry.

Parameters:

    Notify - Supplies a pointer to the notification entry to be referenced

Return Value:

    None

Note:

    The appropriate synchronization lock must be held on the notification
    list before this routine can be called

--*/

{
    PAGED_CODE();

    ASSERT(Notify);
    ASSERT(Notify->RefCount > 0);

    Notify->RefCount++;

}

VOID
IopDereferenceNotify(
    PNOTIFY_ENTRY_HEADER Notify
    )

/*++

Routine Description:

    This routine decrements the reference count for a notification entry, removing
    the entry from the list and freeing the associated memory if there are no
    outstanding reference counts.

Parameters:

    Notify - Supplies a pointer to the notification entry to be referenced

Return Value:

    None

Note:

    The appropriate synchronization lock must be held on the notification
    list before this routine can be called

--*/

{
    PAGED_CODE();

    ASSERT(Notify);
    ASSERT(Notify->RefCount > 0);

    Notify->RefCount--;

    if (Notify->RefCount == 0) {
        //
        // If the refcount is zero then the node should have been deregisterd
        // and is no longer needs to be in the list so remove and free it
        //
        ASSERT(Notify->Unregistered);
        //
        // Remove the notification entry from its list.
        //
        // Note that this MUST be done first, since the notification list head
        // for a target device notification entry resides in the target device
        // node, which may be freed immediately after the device object is
        // dereferenced.  For notification entry types other than target device
        // change this is not critical, but still a good idea.
        //
        RemoveEntryList((PLIST_ENTRY)Notify);
        //
        // Dereference the driver object that registered for notifications
        //
        ObDereferenceObject(Notify->DriverObject);
        //
        // If this notification entry is for target device change, dereference
        // the PDO upon which this notification entry was hooked.
        //
        if (Notify->EventCategory == EventCategoryTargetDeviceChange) {

            PTARGET_DEVICE_NOTIFY_ENTRY entry = (PTARGET_DEVICE_NOTIFY_ENTRY)Notify;

            if (entry->PhysicalDeviceObject) {

                ObDereferenceObject(entry->PhysicalDeviceObject);
                entry->PhysicalDeviceObject = NULL;
            }
        }
        //
        // Dereference the opaque session object
        //
        if (Notify->OpaqueSession) {

            MmQuitNextSession(Notify->OpaqueSession);
            Notify->OpaqueSession = NULL;
        }
        //
        // Free the notification entry
        //
        ExFreePool(Notify);
    }
}

NTSTATUS
IopRequestHwProfileChangeNotification(
    IN   LPGUID                         EventGuid,
    IN   PROFILE_NOTIFICATION_TIME      NotificationTime,
    OUT  PPNP_VETO_TYPE                 VetoType            OPTIONAL,
    OUT  PUNICODE_STRING                VetoName            OPTIONAL
    )

/*++

Routine Description:

    This routine is used to notify all registered drivers of a hardware profile
    change.  If the operation is a HW provile change query then the operation
    is synchronous and the veto information is propagated.  All other operations
    are asynchronous and veto information is not returned.

Parameters:

    EventTypeGuid       - The event that has occured

    NotificationTime    - This is used to tell if we are already in an event
                          when delivering a synchronous notification (ie,
                          querying profile change to eject). It is one of
                          three values:
                              PROFILE_IN_PNPEVENT
                              PROFILE_NOT_IN_PNPEVENT
                              PROFILE_PERHAPS_IN_PNPEVENT

    VetoType            - Type of vetoer.

    VetoName            - Name of vetoer.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/

{
    NTSTATUS status=STATUS_SUCCESS,completionStatus;
    KEVENT completionEvent;
    ULONG dataSize,totalSize;
    PPNP_DEVICE_EVENT_ENTRY deviceEvent;

    PAGED_CODE();

    if ((!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE)) &&
        (!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_CANCELLED)) &&
        (!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_COMPLETE))) {

        //
        //  Passed in an illegal value
        //

        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "IopRequestHwProfileChangeNotification: "
            "Illegal Event type passed as profile notification\n"));

        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Only the query changes are synchronous, and in that case we must
    // know definitely whether we are nested within a Pnp event or not.
    //
    ASSERT((!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE))||
           (NotificationTime != PROFILE_PERHAPS_IN_PNPEVENT)) ;

    if (!IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE) ) {
        //
        // Asynchronous case. Very easy.
        //
        ASSERT(!ARGUMENT_PRESENT(VetoName));
        ASSERT(!ARGUMENT_PRESENT(VetoType));

        return PpSetHwProfileChangeEvent( EventGuid,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL);
    }
    //
    // Query notifications are synchronous. Determine if we are currently
    // within an event, in which case we must do the notify here instead
    // of queueing it up.
    //
    if (NotificationTime == PROFILE_NOT_IN_PNPEVENT) {
        //
        // Queue up and block on the notification.
        //
        KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);

        status = PpSetHwProfileChangeEvent( EventGuid,
                                            &completionEvent,
                                            &completionStatus,
                                            VetoType,
                                            VetoName);

        if (NT_SUCCESS(status))  {

            KeWaitForSingleObject( &completionEvent, Executive, KernelMode, FALSE, NULL );

            status = completionStatus;
        }

        return status;
    }

    //
    // Synchronous notify inside our Pnp event.
    //

    //
    // ISSUE-ADRIAO-1998/11/12 - We are MANUALLY sending the profile
    // query change notification because we are blocking inside a PnPEvent and
    // thus can't queue/wait on another!
    //
    ASSERT(PiNotificationInProgress == TRUE);

    dataSize =  sizeof(PLUGPLAY_EVENT_BLOCK);

    totalSize = dataSize + FIELD_OFFSET (PNP_DEVICE_EVENT_ENTRY,Data);

    deviceEvent = ExAllocatePoolWithTag (PagedPool,
                                         totalSize,
                                         PNP_DEVICE_EVENT_ENTRY_TAG);
    if (NULL == deviceEvent) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    //Setup the PLUGPLAY_EVENT_BLOCK
    //
    RtlZeroMemory ((PVOID)deviceEvent,totalSize);

    deviceEvent->Data.EventCategory = HardwareProfileChangeEvent;
    RtlCopyMemory(&deviceEvent->Data.EventGuid, EventGuid, sizeof(GUID));
    deviceEvent->Data.TotalSize = dataSize;
    deviceEvent->CallerEvent = &completionEvent;
    deviceEvent->Data.Result = (PULONG)&completionStatus;
    deviceEvent->VetoType = VetoType;
    deviceEvent->VetoName = VetoName;
    //
    // Notify K-Mode
    //
    status = IopNotifyHwProfileChange(&deviceEvent->Data.EventGuid,
                                      VetoType,
                                      VetoName);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Notify user-mode (synchronously).
    //
    status = PiNotifyUserMode(deviceEvent);
    if (!NT_SUCCESS(status)) {
        //
        // Notify K-mode that the query has been cancelled.
        //
        IopNotifyHwProfileChange((LPGUID)&GUID_HWPROFILE_CHANGE_CANCELLED,
                                 NULL,
                                 NULL);
    }
    return status;
}

NTSTATUS
IopNotifyHwProfileChange(
    IN  LPGUID           EventGuid,
    OUT PPNP_VETO_TYPE   VetoType    OPTIONAL,
    OUT PUNICODE_STRING  VetoName    OPTIONAL
    )
/*++

Routine Description:

    This routine is used to deliver the HWProfileNotifications. It is
    called from the worker thread only
    It does not return until all interested parties have been notified.

Parameters:

    EventTypeGuid - The event that has occured

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/
{
    NTSTATUS status = STATUS_SUCCESS, dispatchStatus;
    PHWPROFILE_NOTIFY_ENTRY  pNotifyList, vetoEntry;
    PLIST_ENTRY link;

    PAGED_CODE();

    //Lock the Profile Notification List
    IopAcquireNotifyLock (&IopHwProfileNotifyLock);
    //
    //  Grab the list head (inside the lock)
    //
    link = IopProfileNotifyList.Flink;
    pNotifyList=(PHWPROFILE_NOTIFY_ENTRY)link;
    //
    // Walk the circular list.
    //
    while (link != (PLIST_ENTRY)&IopProfileNotifyList) {

        if (!pNotifyList->Unregistered) {

            HWPROFILE_CHANGE_NOTIFICATION notification;

            //
            // Reference the entry so that no one deletes during the callback
            // and then release the lock
            //
            IopReferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
            IopReleaseNotifyLock(&IopHwProfileNotifyLock);
            //
            // Fill in the notification structure
            //
            notification.Version = PNP_NOTIFICATION_VERSION;
            notification.Size = sizeof(HWPROFILE_CHANGE_NOTIFICATION);
            notification.Event = *EventGuid;
            //
            // Dispatch the notification to the callback routine for the
            // appropriate session.
            //
            dispatchStatus = PiNotifyDriverCallback(pNotifyList->CallbackRoutine,
                                                    &notification,
                                                    pNotifyList->Context,
                                                    pNotifyList->SessionId,
                                                    pNotifyList->OpaqueSession,
                                                    &status);
            ASSERT(NT_SUCCESS(dispatchStatus));

            //
            // Failure to dispatch the notification to the specified callback
            // should not be considered a veto.
            //
            if (!NT_SUCCESS(dispatchStatus)) {

                status = STATUS_SUCCESS;
            }
            //
            // If the caller returned anything other than success and it was a
            // query hardware profile change, we veto the query and send cancels
            // to all callers that already got the query.
            //
            if ((!NT_SUCCESS(status)) &&
                (IopCompareGuid(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE))) {

                if (VetoType) {
                    *VetoType = PNP_VetoDriver;
                }

                if (VetoName) {
                    VetoName->Length = 0;
                    RtlCopyUnicodeString(VetoName, &pNotifyList->DriverObject->DriverName);
                }
                notification.Event = GUID_HWPROFILE_CHANGE_CANCELLED;
                notification.Size = sizeof(GUID_HWPROFILE_CHANGE_CANCELLED);

                //
                // Keep track of the entry that vetoed the query.  We can't
                // dereference it just yet, because we may need to send it a
                // cancel-remove first.  Since it's possible that the entry
                // may have been unregistered when the list was unlocked
                // during the query callback (removing all but the reference
                // we are currently holding), we need to make sure we don't
                // dereference it until we're absolutely done with it.
                //
                vetoEntry = pNotifyList;

                IopAcquireNotifyLock(&IopHwProfileNotifyLock);

                //
                // Make sure we are starting where we left off above, at the
                // vetoing entry.
                //
                ASSERT((PHWPROFILE_NOTIFY_ENTRY)link == vetoEntry);

                do {

                    pNotifyList = (PHWPROFILE_NOTIFY_ENTRY)link;
                    if (!pNotifyList->Unregistered) {

                        IopReferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
                        IopReleaseNotifyLock(&IopHwProfileNotifyLock);

                        dispatchStatus = PiNotifyDriverCallback(pNotifyList->CallbackRoutine,
                                                                &notification,
                                                                pNotifyList->Context,
                                                                pNotifyList->SessionId,
                                                                pNotifyList->OpaqueSession,
                                                                NULL);
                        ASSERT(NT_SUCCESS(dispatchStatus));

                        IopAcquireNotifyLock(&IopHwProfileNotifyLock);

                        link = link->Blink;

                        IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);

                    } else {

                        link = link->Blink;
                    }

                    if (pNotifyList == vetoEntry) {
                        //
                        // Dereference the entry which vetoed the query change.
                        //
                        IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
                    }

                } while (link != (PLIST_ENTRY)&IopProfileNotifyList);

                goto Clean0;
            }
            //
            // Reacquire the lock, walk forward, and dereference
            //
            IopAcquireNotifyLock (&IopHwProfileNotifyLock);

            link = link->Flink;

            IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)pNotifyList);
            pNotifyList=(PHWPROFILE_NOTIFY_ENTRY)link;

        } else {
            //
            //Walk forward if we hit an unregistered node
            //
            if (pNotifyList) {
                //
                //walk forward
                //
                link = link->Flink;
                pNotifyList=(PHWPROFILE_NOTIFY_ENTRY)link;
            }
        }
    }

Clean0:
    //
    // UnLock the Profile Notification List
    //
    IopReleaseNotifyLock(&IopHwProfileNotifyLock);

    return status;
}

NTSTATUS
IopNotifyTargetDeviceChange(
    IN  LPCGUID                             EventGuid,
    IN  PDEVICE_OBJECT                      DeviceObject,
    IN  PTARGET_DEVICE_CUSTOM_NOTIFICATION  NotificationStructure   OPTIONAL,
    OUT PDRIVER_OBJECT                     *VetoingDriver
    )
/*++

Routine Description:

    This routine is used to notify all registered drivers of a change to a
    particular device. It does not return until all interested parties have
    been notified.

Parameters:

    EventGuid - The event guid to send to the drivers.

    DeviceObject - The device object for the affected device.  The devnode for
        this device object contains a list of callback routines that have
        registered for notification of any changes on this device object.

    NotificationStructure - Custom notification structure to send to the
        registrants.

    VetoingDriver - Driver that vetoed the event if
                    (EventGuid == GUID_TARGET_DEVICE_QUERY_REMOVE).

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/
{
    NTSTATUS status, dispatchStatus;
    PLIST_ENTRY link;
    PTARGET_DEVICE_NOTIFY_ENTRY entry, vetoEntry;
    TARGET_DEVICE_REMOVAL_NOTIFICATION targetNotification;
    PVOID notification;
    PDEVICE_NODE deviceNode;
    BOOLEAN reverse;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);
    ASSERT(EventGuid != NULL);

    //
    // Reference the device object so it can't go away while we're doing notification
    //
    ObReferenceObject(DeviceObject);

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    ASSERT(deviceNode != NULL);

    if (ARGUMENT_PRESENT(NotificationStructure)) {
        //
        // We're handling a custom notification
        //
        NotificationStructure->Version = PNP_NOTIFICATION_VERSION;

    } else {
        //
        // Fill in the notification structure
        //
        targetNotification.Version = PNP_NOTIFICATION_VERSION;
        targetNotification.Size = sizeof(TARGET_DEVICE_REMOVAL_NOTIFICATION);
        targetNotification.Event = *EventGuid;
    }
    //
    // Lock the notify list
    //
    IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);
    //
    // Get the first entry
    //
    reverse = (BOOLEAN)IopCompareGuid(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED);
    if (reverse) {

        link = deviceNode->TargetDeviceNotify.Blink;
    } else {

        link = deviceNode->TargetDeviceNotify.Flink;
    }
    //
    // Iterate through the list
    //
    while (link != &deviceNode->TargetDeviceNotify) {

        entry = (PTARGET_DEVICE_NOTIFY_ENTRY)link;
        //
        // Only callback on registered nodes
        //
        if (!entry->Unregistered) {
            //
            // Reference the entry so that no one deletes during the callback
            // and then release the lock
            //
            IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);
            IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);
            //
            // Select the notification structure to deliver and set the file
            // object in the notification structure to that for the current
            // entry
            //
            if (ARGUMENT_PRESENT(NotificationStructure)) {

                NotificationStructure->FileObject = entry->FileObject;
                notification = (PVOID)NotificationStructure;
            } else {

                targetNotification.FileObject = entry->FileObject;
                notification = (PVOID)&targetNotification;
            }
            //
            // Dispatch the notification to the callback routine for the
            // appropriate session.
            //
            dispatchStatus = PiNotifyDriverCallback(entry->CallbackRoutine,
                                                    notification,
                                                    entry->Context,
                                                    entry->SessionId,
                                                    entry->OpaqueSession,
                                                    &status);
            ASSERT(NT_SUCCESS(dispatchStatus));
            //
            // Failure to dispatch the notification to the specified callback
            // should not be considered a veto.
            //
            if (!NT_SUCCESS(dispatchStatus)) {

                status = STATUS_SUCCESS;
            }
            //
            // If the caller returned anything other than success and it was
            // a query remove, we veto the query remove and send cancels to
            // all callers that already got the query remove.
            //
            if (!NT_SUCCESS(status)) {

                if (IopCompareGuid(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_QUERY_REMOVE)) {

                    ASSERT(notification == (PVOID)&targetNotification);

                    if (VetoingDriver != NULL) {
                        *VetoingDriver = entry->DriverObject;
                    }

                    targetNotification.Event = GUID_TARGET_DEVICE_REMOVE_CANCELLED;

                    //
                    // Keep track of the entry that vetoed the query.  We can't
                    // dereference it just yet, because we may need to send it a
                    // cancel-remove first.  Since it's possible that the entry
                    // may have been unregistered when the list was unlocked
                    // during the query callback (removing all but the reference
                    // we are currently holding), we need to make sure we don't
                    // dereference it until we're absolutely done with it.
                    //
                    vetoEntry = entry;

                    IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);

                    //
                    // Make sure we are starting where we left off above, at the
                    // vetoing entry.
                    //
                    ASSERT((PTARGET_DEVICE_NOTIFY_ENTRY)link == vetoEntry);

                    do {
                        entry = (PTARGET_DEVICE_NOTIFY_ENTRY)link;

                        if (!entry->Unregistered) {
                            //
                            // Reference the entry so that no one deletes during
                            // the callback and then release the lock
                            //
                            IopReferenceNotify((PNOTIFY_ENTRY_HEADER)entry);
                            IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);
                            //
                            // Set the file object in the notification structure
                            // to that for the current entry
                            //
                            targetNotification.FileObject = entry->FileObject;
                            //
                            // Dispatch the notification to the callback routine
                            // for the appropriate session.
                            //
                            dispatchStatus = PiNotifyDriverCallback(entry->CallbackRoutine,
                                                                    &targetNotification,
                                                                    entry->Context,
                                                                    entry->SessionId,
                                                                    entry->OpaqueSession,
                                                                    NULL);
                            ASSERT(NT_SUCCESS(dispatchStatus));
                            //
                            // Reacquire the lock and dereference
                            //
                            IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);

                            link = link->Blink;

                            IopDereferenceNotify( (PNOTIFY_ENTRY_HEADER) entry );

                        } else {

                            link = link->Blink;
                        }

                        if (entry == vetoEntry) {
                            //
                            // Dereference the entry which vetoed the query remove.
                            //
                            IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)vetoEntry);
                        }

                    } while (link != &deviceNode->TargetDeviceNotify);

                    goto Clean0;

                } else {

                    ASSERT(notification == (PVOID)NotificationStructure);

                    IopDbgPrint((
                        IOP_IOEVENT_ERROR_LEVEL,
                        "IopNotifyTargetDeviceChange: "
                        "Driver %Z, handler @ 0x%p failed non-failable notification 0x%p with return code %x\n",
                        &entry->DriverObject->DriverName,
                        entry->CallbackRoutine,
                        notification,
                        status));

                    DbgBreakPoint();
                }
            }
            //
            // Reacquire the lock and dereference
            //
            IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);
            if (reverse) {

                link = link->Blink;
            } else {

                link = link->Flink;
            }
            IopDereferenceNotify((PNOTIFY_ENTRY_HEADER)entry);

        } else {
            //
            // Advance down the list
            //
            if (reverse) {

                link = link->Blink;
            } else {

                link = link->Flink;
            }
        }
    }
    //
    // If it's not a query, it can't be failed.
    //
    status = STATUS_SUCCESS;

Clean0:
    //
    // Release the lock and dereference the object
    //
    IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

    ObDereferenceObject(DeviceObject);

    return status;
}

NTSTATUS
IopNotifyDeviceClassChange(
    LPGUID EventGuid,
    LPGUID ClassGuid,
    PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is used to notify all registered drivers of a changes to a
    particular class of device. It does not return until all interested parties have
    been notified.

Parameters:

    EventTypeGuid - The event that has occured

    ClassGuid - The device class this change has occured in

    SymbolicLinkName - The kernel mode symbolic link name of the interface device
        that changed

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/

{
    NTSTATUS status, dispatchStatus;
    PLIST_ENTRY link;
    PDEVICE_CLASS_NOTIFY_ENTRY entry;
    DEVICE_INTERFACE_CHANGE_NOTIFICATION notification;
    ULONG hash;

    PAGED_CODE();

    //
    // Fill in the notification structure
    //
    notification.Version = PNP_NOTIFICATION_VERSION;
    notification.Size = sizeof(DEVICE_INTERFACE_CHANGE_NOTIFICATION);
    notification.Event = *EventGuid;
    notification.InterfaceClassGuid = *ClassGuid;
    notification.SymbolicLinkName = SymbolicLinkName;
    //
    // Lock the notify list
    //
    IopAcquireNotifyLock(&IopDeviceClassNotifyLock);
    //
    // Get the first entry
    //
    hash = IopHashGuid(ClassGuid);
    link = IopDeviceClassNotifyList[hash].Flink;
    //
    // Iterate through the list
    //
    while (link != &IopDeviceClassNotifyList[hash]) {

        entry = (PDEVICE_CLASS_NOTIFY_ENTRY)link;
        //
        // Only callback on registered nodes of the correct device class
        //

        if (!entry->Unregistered && IopCompareGuid(&(entry->ClassGuid), ClassGuid)) {

            //
            // Reference the entry so that no one deletes during the callback
            // and then release the lock
            //
            IopReferenceNotify( (PNOTIFY_ENTRY_HEADER) entry );
            IopReleaseNotifyLock(&IopDeviceClassNotifyLock);

            //
            // Dispatch the notification to the callback routine for the
            // appropriate session.  Ignore the returned result for non-query
            // type events.
            //
            dispatchStatus = PiNotifyDriverCallback(entry->CallbackRoutine,
                                                    &notification,
                                                    entry->Context,
                                                    entry->SessionId,
                                                    entry->OpaqueSession,
                                                    &status);

            ASSERT(NT_SUCCESS(dispatchStatus));

            //
            // ISSUE -2000/11/27 - JAMESCA: Overactive assert
            // This assert is temporarily commented out until mountmgr is fixed.
            //
            // ASSERT(NT_SUCCESS(status));

            //
            // Reacquire the lock and dereference
            //
            IopAcquireNotifyLock(&IopDeviceClassNotifyLock);

            link = link->Flink;

            IopDereferenceNotify( (PNOTIFY_ENTRY_HEADER) entry );

        } else {
            //
            // Advance down the list
            //
            link = link->Flink;
        }
    }
    //
    // Release the lock
    //
    IopReleaseNotifyLock(&IopDeviceClassNotifyLock);

    return STATUS_SUCCESS;
}

NTSTATUS
IoRegisterPlugPlayNotification(
    IN IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    IN ULONG EventCategoryFlags,
    IN PVOID EventCategoryData OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Context,
    OUT PVOID *NotificationEntry
    )
/*++

Routine Description:

    IoRegisterPlugPlayNotification provides a mechanism by which WDM drivers may
    receive notification (via callback) for a variety of Plug&Play events.

Arguments:

    EventCategory - Specifies the event category being registered for.  WDM drivers
        may currently register for hard-ware profile changes, device class changes
        (instance arrivals and removals), and target device changes (query-removal,
        cancel-removal, removal-complete, as well as 3rd-party extensible events).

    EventCategoryFlags - Supplies flags that modify the behavior of event registration.
        There is a separate group of flags defined for each event category.  Presently,
        only the interface device change event category has any flags defined:

            DEVICE_CLASS_NOTIFY_FOR_EXISTING_DEVICES -- Drivers wishing to retrieve a
                complete list of all interface devices presently available, and keep
                the list up-to-date (i.e., receive notification of interface device
                arrivals and removals), may specify this flag.  This will cause the
                PnP manager to immediately notify the driver about every currently-existing
                device of the specified interface class.

    EventCategoryData - Used to  'filter' events of the desired category based on the
        supplied criteria.  Not all event categories will use this parameter.  The
        event categories presently defined use this information as fol-lows:

        EventCategoryHardwareProfileChange -- this parameter is unused, and should be NULL.
        EventCategoryDeviceClassChange -- LPGUID representing the interface class of interest
        EventCategoryTargetDeviceChange -- PFILE_OBJECT of interest

    DriverObject - The caller must supply a reference to its driver object (obtained via
        ObReferenceObject), to prevent the driver from being unloaded while registered for
        notification.  The PnP Manager will dereference the driver object when the driver
        unregisters for notification via IoUnregisterPlugPlayNotification).

    CallbackRoutine - Entry point within the driver that the PnP manager should call
        whenever an applicable PnP event occurs.  The entry point must have the
        following prototype:

            typedef
            NTSTATUS
            (*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
                IN PVOID NotificationStructure,
                IN PVOID Context
                );

        where NotificationStructure contains information about the event.  Each event
        GUID within an event category may potentially have its own notification structure
        format, but the buffer must al-ways begin with a PLUGPLAY_NOTIFICATION_HEADER,
        which indicates the size and ver-sion of the structure, as well as the GUID for
        the event.

        The Context parameter provides the callback with the same context data that the
        caller passed in during registration.

    Context - Points to the context data passed to the callback upon event notification.

    NotificationEntry - Upon success, receives a handle representing the notification
        registration.  This handle may be used to unregister for notification via
        IoUnregisterPlugPlayNotification.

--*/
{

    NTSTATUS status;

    PAGED_CODE();

    ASSERT(NotificationEntry);

    //
    // Initialize out parameters
    //
    *NotificationEntry = NULL;
    //
    // Reference the driver object so it doesn't go away while we still have
    // a pointer outstanding
    //
    status = ObReferenceObjectByPointer(DriverObject,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode);
    if (!NT_SUCCESS(status)) {

        return status;
    }
    switch (EventCategory) {

    case EventCategoryReserved:
        {
            //
            // This is currently supported only for setupdd.sys in textmode setup.
            //
            if (ExpInTextModeSetup) {

                PSETUP_NOTIFY_DATA setupData;

                ASSERT(IopSetupNotifyData == NULL);
                //
                // Note that the only setup notification callback currently supported
                // (setupdd.sys) is never in session space.
                //
                ASSERT(MmIsSessionAddress((PVOID)CallbackRoutine) == FALSE);
                ASSERT(MmGetSessionId(PsGetCurrentProcess()) == 0);
                //
                // Allocate space for the setup data
                //
                setupData = ExAllocatePool(PagedPool, sizeof(SETUP_NOTIFY_DATA));
                if (!setupData) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto clean0;
                }
                //
                // Store the required information
                //
                InitializeListHead(&(setupData->ListEntry));
                setupData->EventCategory = EventCategory;
                setupData->SessionId = MmGetSessionId(PsGetCurrentProcess());
                setupData->CallbackRoutine = CallbackRoutine;
                setupData->Context = Context;
                setupData->RefCount = 1;
                setupData->Unregistered = FALSE;
                setupData->Lock = NULL;
                setupData->DriverObject = DriverObject;
                setupData->OpaqueSession = PiGetSession(CallbackRoutine, setupData->SessionId);
                //
                // Activate the notifications
                //
                IopSetupNotifyData = setupData;
            }
            //
            // Explicitly NULL out the returned entry as you can *NOT* unregister
            // for setup notifications
            //
            *NotificationEntry = NULL;
            break;
        }

    case EventCategoryHardwareProfileChange:
        {
            PHWPROFILE_NOTIFY_ENTRY entry;

            //
            // new entry
            //
            entry =ExAllocatePool (PagedPool,sizeof (HWPROFILE_NOTIFY_ENTRY));
            if (!entry) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }
            //
            // Initialize the entry.
            //
            entry->EventCategory = EventCategory;
            entry->SessionId = MmGetSessionId(PsGetCurrentProcess());
            entry->CallbackRoutine = CallbackRoutine;
            entry->Context = Context;
            entry->RefCount = 1;
            entry->Unregistered = FALSE;
            entry->Lock = &IopHwProfileNotifyLock;
            entry->DriverObject = DriverObject;
            entry->OpaqueSession = PiGetSession(CallbackRoutine, entry->SessionId);
            //
            // Defer notification if neccessary.
            //
            status = PiDeferNotification((PNOTIFY_ENTRY_HEADER)entry);
            if (!NT_SUCCESS(status)) {

                ExFreePool(entry);
                goto clean0;
            }
            //
            // Insert the entry into its list.
            //
            PiLockedInsertTailList(&IopProfileNotifyList, &IopHwProfileNotifyLock, &entry->ListEntry);

            *NotificationEntry = entry;

            break;
        }
    case EventCategoryTargetDeviceChange:
        {
            PTARGET_DEVICE_NOTIFY_ENTRY entry;
            PDEVICE_NODE deviceNode;

            ASSERT(EventCategoryData);

            //
            // Allocate a new list entry
            //
            entry = ExAllocatePool(PagedPool, sizeof(TARGET_DEVICE_NOTIFY_ENTRY));
            if (!entry) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }
            //
            // Retrieve the device object associated with this file handle.
            //
            status = IopGetRelatedTargetDevice((PFILE_OBJECT)EventCategoryData,
                                               &deviceNode);
            if (!NT_SUCCESS(status)) {

                ExFreePool(entry);
                goto clean0;
            }
            //
            // Fill out the entry
            //
            entry->EventCategory = EventCategory;
            entry->SessionId = MmGetSessionId(PsGetCurrentProcess());
            entry->CallbackRoutine = CallbackRoutine;
            entry->Context = Context;
            entry->DriverObject = DriverObject;
            entry->RefCount = 1;
            entry->Unregistered = FALSE;
            entry->Lock = &IopTargetDeviceNotifyLock;
            entry->FileObject = (PFILE_OBJECT)EventCategoryData;
            entry->OpaqueSession = PiGetSession(CallbackRoutine, entry->SessionId);
            //
            // The PDO associated with the devnode we got back from
            // IopGetRelatedTargetDevice has already been referenced by that
            // routine.  Store this reference away in the notification entry,
            // so we can deref it later when the notification entry is unregistered.
            //

            ASSERT(deviceNode->PhysicalDeviceObject);
            entry->PhysicalDeviceObject = deviceNode->PhysicalDeviceObject;

            status = PiDeferNotification((PNOTIFY_ENTRY_HEADER)entry);
            if (!NT_SUCCESS(status)) {

                ExFreePool(entry);
                goto clean0;
            }
            //
            // Insert the entry into its list.
            //
            PiLockedInsertTailList(&deviceNode->TargetDeviceNotify, &IopTargetDeviceNotifyLock, &entry->ListEntry);

            *NotificationEntry = entry;

            break;
        }

    case EventCategoryDeviceInterfaceChange:
        {
            PDEVICE_CLASS_NOTIFY_ENTRY entry;

            ASSERT(EventCategoryData);

            //
            // Allocate a new list entry
            //
            entry = ExAllocatePool(PagedPool, sizeof(DEVICE_CLASS_NOTIFY_ENTRY));
            if (!entry) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean0;
            }
            //
            // Fill out the entry
            //
            entry->EventCategory = EventCategory;
            entry->SessionId = MmGetSessionId(PsGetCurrentProcess());
            entry->CallbackRoutine = CallbackRoutine;
            entry->Context = Context;
            entry->ClassGuid = *((LPGUID) EventCategoryData);
            entry->RefCount = 1;
            entry->Unregistered = FALSE;
            entry->Lock = &IopDeviceClassNotifyLock;
            entry->DriverObject = DriverObject;
            entry->OpaqueSession = PiGetSession(CallbackRoutine, entry->SessionId);
            //
            // Defer notification if needed.
            //
            status = PiDeferNotification((PNOTIFY_ENTRY_HEADER)entry);
            if (!NT_SUCCESS(status)) {

                ExFreePool(entry);
                goto clean0;
            }
            //
            // Insert the entry into its list.
            //
            PiLockedInsertTailList(
                (PLIST_ENTRY)&IopDeviceClassNotifyList[IopHashGuid(&(entry->ClassGuid))], 
                                &IopDeviceClassNotifyLock, 
                                &entry->ListEntry);
            //
            // See if we need to notify for all the device classes already present
            //
            if (EventCategoryFlags & PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES) {

                PWCHAR pSymbolicLinks, pCurrent;
                DEVICE_INTERFACE_CHANGE_NOTIFICATION notification;
                UNICODE_STRING unicodeString;
                //
                // Fill in the notification structure
                //
                notification.Version = PNP_NOTIFICATION_VERSION;
                notification.Size = sizeof(DEVICE_INTERFACE_CHANGE_NOTIFICATION);
                notification.Event = GUID_DEVICE_INTERFACE_ARRIVAL;
                notification.InterfaceClassGuid = entry->ClassGuid;
                //
                // Get the list of all the devices of this function class that are
                // already in the system
                //
                status = IoGetDeviceInterfaces(&(entry->ClassGuid),
                                                NULL,
                                                0,
                                                &pSymbolicLinks);
                if (!NT_SUCCESS(status)) {
                    //
                    // No buffer will have been returned so just return status
                    //
                    goto clean0;
                }
                //
                // Callback for each device currently in the system
                //
                pCurrent = pSymbolicLinks;
                while(*pCurrent != UNICODE_NULL) {

                    NTSTATUS dispatchStatus, tempStatus;

                    RtlInitUnicodeString(&unicodeString, pCurrent);
                    notification.SymbolicLinkName = &unicodeString;
                    //
                    // Dispatch the notification to the callback routine for the
                    // appropriate session.  Ignore the returned result for non-query
                    // type events.
                    //
                    dispatchStatus = PiNotifyDriverCallback(CallbackRoutine,
                                                            &notification,
                                                            Context,
                                                            entry->SessionId,
                                                            entry->OpaqueSession,
                                                            &tempStatus);
                    //
                    // ISSUE -2000/11/27 - JAMESCA: Overactive assert
                    //     ClusDisk failed here. The code in question is being
                    // removed, but we don't we want to make sure we flush
                    // anyone else out before we enable it again.
                    //
                    //ASSERT(NT_SUCCESS(dispatchStatus) && NT_SUCCESS(tempStatus));
                    ASSERT(NT_SUCCESS(dispatchStatus));

                    pCurrent += (unicodeString.Length / sizeof(WCHAR)) + 1;

                }
                ExFreePool(pSymbolicLinks);
            }
            *NotificationEntry = entry;
        }

        break;
    }

clean0:

    if (!NT_SUCCESS(status)) {

        ObDereferenceObject(DriverObject);
    }

    return status;
}

NTSTATUS
IopGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_NODE *DeviceNode
    )

/*++

Routine Description:

    IopGetRelatedTargetDevice retrieves the device object associated with
    the specified file object and then sends a query device relations irp
    to that device object.

    NOTE: The PDO associated with the returned device node has been referenced,
    and must be dereferenced when no longer needed.

Arguments:

    FileObject - Specifies the file object that is associated with the device
                 object that will receive the query device relations irp.

    DeviceNode - Returns the related target device node.

ReturnValue

    Returns an NTSTATUS value.

--*/

{
    NTSTATUS status;
    IO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject, targetDeviceObject;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_NODE targetDeviceNode;

    PAGED_CODE();

    ASSERT(FileObject);

    *DeviceNode = NULL;
    //
    // Retrieve the device object associated with this file handle.
    //
    deviceObject = IoGetRelatedDeviceObject(FileObject);
    if (!deviceObject) {

        return STATUS_NO_SUCH_DEVICE;
    }
    //
    // Query what the "actual" target device node should be for
    // this file object. Initialize the stack location to pass to
    // IopSynchronousCall() and then send the IRP to the device
    // object that's associated with the file handle.
    //
    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp.Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;
    irpSp.DeviceObject = deviceObject;
    irpSp.FileObject = FileObject;

    status = IopSynchronousCall(deviceObject, &irpSp, (PULONG_PTR)&deviceRelations);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    ASSERT(deviceRelations);

    if (deviceRelations) {

        ASSERT(deviceRelations->Count == 1);

        if (deviceRelations->Count == 1) {

            targetDeviceObject = deviceRelations->Objects[0];

        } else {

            targetDeviceObject = NULL;
        }

        ExFreePool(deviceRelations);

        if (targetDeviceObject) {

            targetDeviceNode = (PDEVICE_NODE) targetDeviceObject->DeviceObjectExtension->DeviceNode;
            if (targetDeviceNode) {

                *DeviceNode = targetDeviceNode;
                return status;
            }
        }
    }
    //
    // Definite driver screw up. If the verifier is enabled we will fail the
    // driver. Otherwise, we will ignore this. Note that we would have crashed
    // in Win2K!
    //
    PpvUtilFailDriver(
        PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
        (PVOID) deviceObject->DriverObject->MajorFunction[IRP_MJ_PNP],
        deviceObject,
        NULL);

    return STATUS_NO_SUCH_DEVICE;
}

NTSTATUS
IoGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    IoGetRelatedTargetDevice retrieves the device object associated with
    the specified file object and then sends a query device relations irp
    to that device object.

    NOTE: The PDO associated with the returned device node has been referenced,
    and must be dereferenced when no longer needed.

Arguments:

    FileObject - Specifies the file object that is associated with the device
                 object that will receive the query device relations irp.

    DeviceObject - Returns the related target device object.

ReturnValue

    Returns an NTSTATUS value.

--*/

{
    NTSTATUS status;
    PDEVICE_NODE deviceNode = NULL;

    PAGED_CODE();

    status = IopGetRelatedTargetDevice(FileObject, &deviceNode);
    if (NT_SUCCESS(status) && deviceNode != NULL) {

        *DeviceObject = deviceNode->PhysicalDeviceObject;
    }
    return status;
}

NTSTATUS
IopNotifySetupDeviceArrival(
    PDEVICE_OBJECT PhysicalDeviceObject,    // PDO of the device
    HANDLE EnumEntryKey,                    // Handle into the enum branch of the registry for this device
    BOOLEAN InstallDriver
    )

/*++

Routine Description:

    This routine is used to notify setup (during text-mode setup) of arrivals
    of a particular device. It does not return until all interested parties have
    been notified.

Parameters:

    PhysicalDeviceObject - Supplies a pointer to the PDO of the newly arrived
        device.

    EnumEntryKey - Supplies a handle to the key associated with the devide under
        the Enum\ branch of the registry.  Can be NULL in which case the key
        will be opened here.

    InstallDriver - Indicates whether setup should attempt to install a driver
                    for this object.  Device objects created through
                    IoReportDetectedDevice() already have a driver but we want
                    to indicate them to setup anyway.

Return Value:

    Status code that indicates whether or not the function was successful.

Note:

    The contents of the notification structure *including* all pointers is only
    valid during the callback routine to which it was passed.  If the data is
    required after the duration of the callback then it must be physically copied
    by the callback routine.

--*/

{
    NTSTATUS status, dispatchStatus;
    SETUP_DEVICE_ARRIVAL_NOTIFICATION notification;
    PDEVICE_NODE deviceNode;
    HANDLE enumKey = NULL;

    PAGED_CODE();

    //
    // Only perform notifications if someone has registered
    //

    if (IopSetupNotifyData) {

        if (!EnumEntryKey) {

            status = IopDeviceObjectToDeviceInstance(PhysicalDeviceObject,
                                                     &enumKey,
                                                     KEY_WRITE);
            if (!NT_SUCCESS(status)) {

                return status;
            }
            EnumEntryKey = enumKey;
        }
        //
        // Fill in the notification structure
        //
        notification.Version = PNP_NOTIFICATION_VERSION;
        notification.Size = sizeof(SETUP_DEVICE_ARRIVAL_NOTIFICATION);
        notification.Event = GUID_SETUP_DEVICE_ARRIVAL;
        notification.PhysicalDeviceObject = PhysicalDeviceObject;
        notification.EnumEntryKey = EnumEntryKey;
        deviceNode = (PDEVICE_NODE) PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;
        notification.EnumPath = &deviceNode->InstancePath;
        notification.InstallDriver = InstallDriver;

        //
        // Note that the only setup notification callback currently supported
        // (setupdd.sys) is never in session space.
        //
        ASSERT(MmIsSessionAddress((PVOID)(IopSetupNotifyData->CallbackRoutine)) == FALSE);
        ASSERT(IopSetupNotifyData->SessionId == 0);

        //
        // Dispatch the notification to the callback routine for the
        // appropriate session.
        //
        dispatchStatus = PiNotifyDriverCallback(IopSetupNotifyData->CallbackRoutine,
                                                &notification,
                                                IopSetupNotifyData->Context,
                                                IopSetupNotifyData->SessionId,
                                                IopSetupNotifyData->OpaqueSession,
                                                &status);
        ASSERT(NT_SUCCESS(dispatchStatus));
        //
        // Failure to dispatch setup notification should be reported as if a
        // match was not found, because the device has not been setup.
        //
        if (!NT_SUCCESS(dispatchStatus)) {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        if (enumKey) {

            ZwClose(enumKey);
        }
        return status;

    } else {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
}



NTSTATUS
IoNotifyPowerOperationVetoed(
    IN POWER_ACTION             VetoedPowerOperation,
    IN PDEVICE_OBJECT           TargetedDeviceObject    OPTIONAL,
    IN PDEVICE_OBJECT           VetoingDeviceObject
    )
/*++

Routine Description:

    This routine is called by the power subsystem to initiate user-mode
    notification of vetoed system power events.  The power events are submitted
    into a serialized asynchronous queue.  This queue is processed by a work
    item.  This routine does not wait for the event to be processed.

Parameters:

    VetoedPowerOperation - Specifies the system-wide power action that was
                           vetoed.

    TargetedDeviceObject - Optionally, supplies the device object target of the
                           vetoed operation.

    VetoingDeviceObject  - Specifies the device object responsible for vetoing
                           the power operation.

Return Value:

    Status code that indicates whether or not the event was successfully
    inserted into the asynchronous event queue..

--*/
{
    PDEVICE_NODE deviceNode, vetoingDeviceNode;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // We have two types of power events, system wide (standby) and device
    // targetted (warm eject). Rather than have two different veto mechanisms,
    // we just retarget the operation against the root device if none is
    // specified (hey, someone's gotta represent the system, right?).
    //
    if (TargetedDeviceObject) {

        deviceObject = TargetedDeviceObject;

    } else {

        deviceObject = IopRootDeviceNode->PhysicalDeviceObject;
    }

    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        return STATUS_INVALID_PARAMETER_2;
    }

    vetoingDeviceNode = (PDEVICE_NODE)VetoingDeviceObject->DeviceObjectExtension->DeviceNode;
    if (!vetoingDeviceNode) {
        return STATUS_INVALID_PARAMETER_3;
    }

    return PpSetPowerVetoEvent(
                VetoedPowerOperation,
                NULL,
                NULL,
                deviceObject,
                PNP_VetoDevice,
                &vetoingDeviceNode->InstancePath);
}



ULONG
IoPnPDeliverServicePowerNotification(
    IN   POWER_ACTION           PowerOperation,
    IN   ULONG                  PowerNotificationCode,
    IN   ULONG                  PowerNotificationData,
    IN   BOOLEAN                Synchronous
    )

/*++

Routine Description:

    This routine is called by the win32k driver to notify user-mode services of
    system power events.  The power events are submitted into a serialized
    asynchronous queue.  This queue is processed by a work item.

Parameters:

    PowerOperation - Specifies the system-wide power action that has occured.
        If the Synchronous parameter is TRUE, the event is a query for
        permission to perform the supplied power operation.

    PowerNotificationCode - Supplies the power event code that is to be
        communicated to user-mode components.

        (Specifically, this event code is actually one of the PBT_APM* user-mode
        power event ids, as defined in sdk\inc\winuser.h.  It is typically used
        as the WPARAM data associated with WM_POWERBROADCAST user-mode window
        messages.  It is supplied to kernel-mode PnP, directly from win32k, for
        the explicit purpose of user-mode power event notification.)

    PowerNotificationData - Specifies additional event-specific data for the specified
        power event id.

        (Specifically, this event data is the LPARAM data for the corresponding
        PBT_APM* user-mode power event id, specified above.)

    Synchronous - Specifies whether this is a query operation.  If the event is
        a query, this routine will wait for the result of the query before
        returning.  If the query event is unsuccessful, this routine will
        initiate an appropriate veto event.


Return Value:

    Returns a non-zero value if the event was successful, zero otherwise.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT completionEvent;
    NTSTATUS completionStatus=STATUS_SUCCESS;
    PNP_VETO_TYPE vetoType = PNP_VetoTypeUnknown;
    UNICODE_STRING vetoName;

    PAGED_CODE();

    if (Synchronous) {

        vetoName.Buffer = ExAllocatePool (PagedPool,MAX_VETO_NAME_LENGTH*sizeof (WCHAR));

        if (vetoName.Buffer) {
            vetoName.MaximumLength = MAX_VETO_NAME_LENGTH;
        }else {
            vetoName.MaximumLength = 0;
        }
        vetoName.Length = 0;

        KeInitializeEvent(&completionEvent, NotificationEvent, FALSE);

        status = PpSetPowerEvent(PowerNotificationCode,
                                 PowerNotificationData,
                                 &completionEvent,
                                 &completionStatus,
                                 &vetoType,
                                 &vetoName);
        if (NT_SUCCESS(status))  {
            //
            // PpSetPowerEvent returns success immediately after the event has
            // been successfully inserted into the event queue.  Queued power
            // events are sent to user-mode via PiNotifyUserMode, which waits
            // for the the result.  PiNotifyUserMode signals the completionEvent
            // below when the user response is received.
            //
            KeWaitForSingleObject( &completionEvent, Executive, KernelMode, FALSE, NULL );
            status = completionStatus;

            //
            // We only have power event veto information to report if
            // user-mode responded to the event with failure.
            //
            if (!NT_SUCCESS(completionStatus)) {
                //
                // PpSetPowerVetoEvent requires a device object as the target of
                // the vetoed power operation.  Since this is a system-wide
                // event, we just target the operation against the root device.
                //
                PpSetPowerVetoEvent(PowerOperation,
                                    NULL,
                                    NULL,
                                    IopRootDeviceNode->PhysicalDeviceObject,
                                    vetoType,
                                    &vetoName);
            }
        }

        if (vetoName.Buffer) {
            ExFreePool (vetoName.Buffer);
        }

    } else {
        //
        // No response is required for 'asynchronous' (non-query) events.
        // Just set the event and go.
        //
        status = PpSetPowerEvent(PowerNotificationCode,
                                 PowerNotificationData,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);
    }

    //
    // Since the user-mode power notification routine only returns a BOOLEAN
    // success value, PiNotifyUserMode only returns one of the following status
    // values:
    //
    ASSERT ((completionStatus == STATUS_SUCCESS) ||
            (completionStatus == STATUS_UNSUCCESSFUL));

    //
    // The private code in Win32k that calls this, assumes that 0 is failure, !0 is success
    //
    return (NT_SUCCESS(completionStatus));

}

VOID
IopOrphanNotification(
    IN PDEVICE_NODE TargetNode
    )

/*++

Routine Description:

    This routine releases the references to the device object for all the
    notifications entries of a device object, then fixes up the notification
    node to not point to a physical device object.

Parameters:

    TargetNode - Specifies the device node whose registered target device
                 notification recipients are to be orphaned.

Return Value:

    None.

Notes:

    The notification node will be released when IoUnregisterPlugPlayNotification
    is actually called, but the device object will already be gone.

--*/

{
    PTARGET_DEVICE_NOTIFY_ENTRY entry;

    PAGED_CODE();

    IopAcquireNotifyLock(&IopTargetDeviceNotifyLock);

    while (!IsListEmpty(&TargetNode->TargetDeviceNotify)) {
        //
        // Remove all target device change notification entries for this devnode
        //
        entry = (PTARGET_DEVICE_NOTIFY_ENTRY)
            RemoveHeadList(&TargetNode->TargetDeviceNotify);

        ASSERT(entry->EventCategory == EventCategoryTargetDeviceChange);
        //
        // Re-initialize the orphaned list entry so we don't attempt to remove
        // it from the list again.
        //
        InitializeListHead((PLIST_ENTRY)entry);
        //
        // Dereference the target device object, and NULL it out so we don't
        // attempt to dereference it when the entry is actually unregistered.
        //
        if (entry->PhysicalDeviceObject) {

            ObDereferenceObject(entry->PhysicalDeviceObject);
            entry->PhysicalDeviceObject = NULL;
        }
    }

    IopReleaseNotifyLock(&IopTargetDeviceNotifyLock);

    return;
}



NTSTATUS
PiNotifyDriverCallback(
    IN  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE  CallbackRoutine,
    IN  PVOID   NotificationStructure,
    IN  PVOID   Context,
    IN  ULONG   SessionId,
    IN  PVOID   OpaqueSession      OPTIONAL,
    OUT PNTSTATUS  CallbackStatus  OPTIONAL
    )
/*++

Routine Description:

    This routine dispatches a plug and play notification event to a specified
    callback routine.

    If the callback routine specifies an address outside of session space, or if
    the calling process is already in the context of the specified session, it
    will call the callback routine directly.

    Otherwise, this routine will attempt to attach to the specified session and
    call the callback routine.

Parameters:

    CallbackRoutine - Entry point within the driver that will be called with
                      information about the event that has occured.

    NotificationStructure - Contains information about the event.

    Context         - Points to the context data supplied at registration.

    SessionId       - Specifies the ID of the session in which the specified
                      callback is to be called.

    OpqueSession    - Optionally, specifies the opaque handle to the session that
                      to attach to when the specified callback is called.

    CallbackStatus  - Optionally, supplies the address of a variable to receive
                      the NTSTATUS code returned by the callback routine.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

    Returns STATUS_NOT_FOUND if the specified session was not found.

--*/
{
    NTSTATUS Status, CallStatus;
    KAPC_STATE ApcState;
#if DBG
    KIRQL Irql;
    ULONG CombinedApcDisable;
#endif

    PAGED_CODE();

    //
    // Make sure we have all the information we need to deliver notification.
    //
    if (!ARGUMENT_PRESENT(CallbackRoutine) ||
        !ARGUMENT_PRESENT(NotificationStructure)) {
        return STATUS_INVALID_PARAMETER;
    }

#if DBG
    //
    // Remember the current IRQL and ApcDisable count so we can make sure
    // the callback routine returns with these in tact.
    //
    Irql = KeGetCurrentIrql();
    CombinedApcDisable = KeGetCurrentThread()->CombinedApcDisable;
#endif  // DBG

    if ((OpaqueSession == NULL) ||
        ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
         (SessionId == PsGetCurrentProcessSessionId()))) {
        //
        // No session object was specified, or the current process is already in
        // the specified session, so just call the callback routine directly.
        //
        ASSERT(!MmIsSessionAddress((PVOID)CallbackRoutine) || OpaqueSession);

        IopDbgPrint((
            IOP_IOEVENT_TRACE_LEVEL,
            "PiNotifyDriverCallback: "
            "calling notification callback @ 0x%p directly\n",
            CallbackRoutine));

        CallStatus = (CallbackRoutine)(NotificationStructure,
                                       Context);

        if (ARGUMENT_PRESENT(CallbackStatus)) {
            *CallbackStatus = CallStatus;
        }
        Status = STATUS_SUCCESS;

    } else {
        //
        // Otherwise, call the callback routine in session space.
        //
        ASSERT(MmIsSessionAddress((PVOID)CallbackRoutine));

        //
        // Attach to the specified session.
        //
        Status = MmAttachSession(OpaqueSession, &ApcState);
        ASSERT(NT_SUCCESS(Status));

        if (NT_SUCCESS(Status)) {
            //
            // Dispatch notification to the callback routine.
            //
            IopDbgPrint((
                IOP_IOEVENT_TRACE_LEVEL,
                "PiNotifyDriverCallback: "
                "calling notification callback @ 0x%p for SessionId %d\n",
                CallbackRoutine,
                SessionId));

            CallStatus = (CallbackRoutine)(NotificationStructure,
                                           Context);

            //
            // Return the callback status.
            //
            if (ARGUMENT_PRESENT(CallbackStatus)) {
                *CallbackStatus = CallStatus;
            }

            //
            // Detach from the session.
            //
            Status = MmDetachSession(OpaqueSession, &ApcState);
            ASSERT(NT_SUCCESS(Status));
        }
    }

#if DBG
    //
    // Check the IRQL and ApcDisable count.
    //
    if (Irql != KeGetCurrentIrql()) {
        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "PiNotifyDriverCallback: "
            "notification handler @ 0x%p returned at raised IRQL = %d, original = %d\n",
            CallbackRoutine,
            KeGetCurrentIrql(),
            Irql));
        DbgBreakPoint();
    }
    if (CombinedApcDisable != KeGetCurrentThread()->CombinedApcDisable) {
        IopDbgPrint((
            IOP_IOEVENT_ERROR_LEVEL,
            "PiNotifyDriverCallback: "
            "notification handler @ 0x%p returned with different CombinedApcDisable = %d, original = %d\n",
            CallbackRoutine,
            KeGetCurrentThread()->CombinedApcDisable,
            CombinedApcDisable));
        DbgBreakPoint();
    }
#endif  // DBG

    return Status;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma  const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\picddb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    picddb.h

Abstract:

    This header contains private information to implement the Plug and Play
    Critical Device Database (CDDB).  This file is meant to be included only by
    ppcddb.c.

Author:

    James G. Cavalaris (jamesca) 01-Nov-2001

Environment:

    Kernel mode.

Revision History:

    29-Jul-1997     Jim Cavalaris (t-jcaval)

        Creation and initial implementation.

    01-Nov-2001     Jim Cavalaris (jamesca)

        Added routines for device pre-installation setup.

--*/



//
//  Current PNP_LOCATION_INTERFACE version.
//
#define PNP_LOCATION_INTERFACE_VERSION  0x1


//
// Optional CDDB device location path separator string
//
// i.e. TEXT("#")   --> PCIROOT(0)#PCI(1100)
//      TEXT("")    --> PCIROOT(0)PCI(1100)
//      TEXT("FOO") --> PCIROOT(0)FOOPCI(1100)
//
// NOTE: The resulting path will be used as a single registry key, so NEVER use
// the NT path separator string RtlNtPathSeperatorString (L"\\"), or any string
// that contains a path separator character (verify with RtlIsNtPathSeparator).
//
#define _CRITICAL_DEVICE_LOCATION_PATH_SEPARATOR_STRING    TEXT("#")


//
// Default device pre-install database root registry key path
//
#define _REGSTR_PATH_DEFAULT_PREINSTALL_DATABASE_ROOT      TEXT("System\\CurrentControlSet\\Control\\CriticalPreInstallDatabase")


//
// Location to device path entries, relative to pre-install database root.
//
// i.e. <PreInstallDatabaseRoot>\\<DevicePaths>
//
#define _REGSTR_KEY_DEVICEPATHS          TEXT("DevicePaths")


//
// Location of the hardware and software settings that are to be applied to a
// device.  These locations are relative to the entry in the pre-install
// database matching the device's location path.
//
// i.e. <PreInstallDatabaseRoot>\\<DevicePaths>\\<MatchingDevicePath>\\<HardwareKey>
//      <PreInstallDatabaseRoot>\\<DevicePaths>\\<MatchingDevicePath>\\<SoftwareKey>
//
#define _REGSTR_KEY_PREINSTALL_HARDWARE  TEXT("HardwareKey")
#define _REGSTR_KEY_PREINSTALL_SOFTWARE  TEXT("SoftwareKey")


//
// If present, the following value in the root of a critical device database
// entry key, or in the root of a device path entry key should be copied to the
// corresponding device instance key for devices that we have successfully set a
// service for.
//
// i.e. <CriticalDeviceDatabase>\\<MungedDeviceId>\\
//          PreservePreInstall : REG_DWORD : 0x1
//
//      <CriticalDeviceDatabase>\\<MungedDeviceId>\\<DevicePaths>\\<MatchingDevicePath>\\
//          PreservePreInstall : REG_DWORD : 0x1
//
// When the user-mode plug and play manager has been directed to preserve
// pre-install settings, this value causes it to clear the
// CONFIGFLAG_FINISH_INSTALL ConfigFlag on any such device, and consider
// installation complete (i.e. not attempt re-installation).
//
//
// REGSTR_VAL_PRESERVE_PREINSTALL from \NT\public\internal\base\inc\pnpmgr.h
//


//
// Prototype verification callback routine for PiCriticalOpenFirstMatchingSubKey
//

typedef
BOOLEAN
(*PCRITICAL_MATCH_CALLBACK)(
    IN  HANDLE          MatchingKeyHandle
    );


//
// Internal Critical Device Database function prototypes
//

NTSTATUS
PiCriticalOpenCriticalDeviceKey(
    IN  PDEVICE_NODE    DeviceNode,
    IN  HANDLE          CriticalDeviceDatabaseRootHandle  OPTIONAL,
    OUT PHANDLE         CriticalDeviceEntryHandle
    );

NTSTATUS
PiCriticalCopyCriticalDeviceProperties(
    IN  HANDLE          DeviceInstanceHandle,
    IN  HANDLE          CriticalDeviceEntryHandle
    );

NTSTATUS
PiCriticalOpenFirstMatchingSubKey(
    IN  PWCHAR          MultiSzList,
    IN  HANDLE          RootHandle,
    IN  ACCESS_MASK     DesiredAccess,
    IN  PCRITICAL_MATCH_CALLBACK  MatchingSubkeyCallback  OPTIONAL,
    OUT PHANDLE         MatchingKeyHandle
    );

BOOLEAN
PiCriticalCallbackVerifyCriticalEntry(
    IN  HANDLE          CriticalDeviceEntryHandle
    );


//
// Internal Pre-installation function prototypes
//

NTSTATUS
PiCriticalPreInstallDevice(
    IN  PDEVICE_NODE    DeviceNode,
    IN  HANDLE          PreInstallDatabaseRootHandle  OPTIONAL
    );

NTSTATUS
PiCriticalOpenDevicePreInstallKey(
    IN  PDEVICE_NODE    DeviceNode,
    IN  HANDLE          PreInstallRootHandle  OPTIONAL,
    OUT PHANDLE         PreInstallHandle
    );


//
// General utility routines
//

NTSTATUS
PiQueryInterface(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  CONST GUID *    InterfaceGuid,
    IN  USHORT          InterfaceVersion,
    IN  USHORT          InterfaceSize,
    OUT PINTERFACE      Interface
    );

NTSTATUS
PiCopyKeyRecursive(
    IN  HANDLE          SourceKeyRootHandle,
    IN  HANDLE          TargetKeyRootHandle,
    IN  PWSTR           SourceKeyPath   OPTIONAL,
    IN  PWSTR           TargetKeyPath   OPTIONAL,
    IN  BOOLEAN         CopyAlways,
    IN  BOOLEAN         ApplyACLsAlways
    );

NTSTATUS
PiCriticalQueryRegistryValueCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\piprofile.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PiProfile.h

Abstract:

    This header contains private prototypes for managing docking stations.
    This file should be included only by PpProfile.c.

Author:

    Adrian J. Oney (AdriaO) 07/19/2000

Revision History:

--*/

#if DBG
#define ASSERT_SEMA_NOT_SIGNALLED(SemaphoreObject) \
    ASSERT(KeReadStateSemaphore(SemaphoreObject) == 0)
#else // DBG
#define ASSERT_SEMA_NOT_SIGNALLED(SemaphoreObject)
#endif // DBG

typedef struct {

    ULONG           Depth;
    PDEVICE_OBJECT  PhysicalDeviceObject;

} BEST_DOCK_TO_EJECT, *PBEST_DOCK_TO_EJECT;

VOID
PiProfileSendHardwareProfileCommit(
    VOID
    );

VOID
PiProfileSendHardwareProfileCancel(
    VOID
    );

NTSTATUS
PiProfileUpdateHardwareProfile(
    OUT BOOLEAN     *ProfileChanged
    );

NTSTATUS
PiProfileRetrievePreferredCallback(
    IN PDEVICE_NODE         DeviceNode,
    IN PVOID                Context
    );

PDEVICE_NODE
PiProfileConvertFakeDockToRealDock(
    IN  PDEVICE_NODE    FakeDockDevnode
    );

NTSTATUS
PiProfileUpdateDeviceTree(
    VOID
    );

VOID
PiProfileUpdateDeviceTreeWorker(
    IN PVOID Context
    );

NTSTATUS
PiProfileUpdateDeviceTreeCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    );

//
// Functions not yet ported from dockhwp.c
//

NTSTATUS
IopExecuteHardwareProfileChange(
    IN  HARDWARE_PROFILE_BUS_TYPE   Bus,
    IN  PWCHAR                    * ProfileSerialNumbers,
    IN  ULONG                       SerialNumbersCount,
    OUT PHANDLE                     NewProfile,
    OUT PBOOLEAN                    ProfileChanged
    );

NTSTATUS
IopExecuteHwpDefaultSelect (
    IN  PCM_HARDWARE_PROFILE_LIST ProfileList,
    OUT PULONG ProfileIndexToUse,
    IN  PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pipagepath.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PiPagePath.h

Abstract:

    This header contains private definitions for managing devices on the paging
    path. This file should be including *only* by PiPagePath.c

Author:

    Adrian J. Oney (AdriaO) February 3rd, 2001

Revision History:

    Originally taken from ChuckL's implementation in mm\modwrite.c.

--*/

NTSTATUS
PiPagePathSetState(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN      InPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\picontrol.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    picontrol.h

Abstract:

    This header contains private prototypes for communication between
    kernel-mode and user-mode. This file should be included only by ppcontrol.c.

Author:

    Adrian J. Oney (AdriaO) 07/19/2000

Revision History:

--*/

typedef NTSTATUS (*PLUGPLAY_CONTROL_HANDLER)(
    IN     PLUGPLAY_CONTROL_CLASS   PnPControlClass,
    IN OUT PVOID                    PnPControlData,
    IN     ULONG                    PnPControlDataLength,
    IN     KPROCESSOR_MODE          CallerMode
    );

typedef struct {

    PLUGPLAY_CONTROL_CLASS          ControlCode;
    ULONG                           ControlDataSize;
    PLUGPLAY_CONTROL_HANDLER        ControlFunction;

} PLUGPLAY_CONTROL_HANDLER_DATA, *PPLUGPLAY_CONTROL_HANDLER_DATA;

VOID
PiControlGetUserFlagsFromDeviceNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT ULONG          *StatusFlags
    );

NTSTATUS
PiControlStartDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlResetDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlInitializeDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlDeregisterDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlRegisterNewDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlEnumerateDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlQueryAndRemoveDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA  QueryAndRemoveData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlUserResponse(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_USER_RESPONSE_DATA UserResponseData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    );

NTSTATUS
PiControlGenerateLegacyDevice(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA LegacyDevGenData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    );

NTSTATUS
PiControlGetInterfaceDeviceList(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_LIST_DATA    InterfaceData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetPropertyData(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_PROPERTY_DATA  PropertyData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    );

NTSTATUS
PiControlDeviceClassAssociation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA AssociationData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetRelatedDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RELATED_DEVICE_DATA    RelatedData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetInterfaceDeviceAlias(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA   InterfaceAliasData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlGetSetDeviceStatus(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_STATUS_DATA    StatusData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    );

NTSTATUS
PiControlGetDeviceDepth(
    IN     PLUGPLAY_CONTROL_CLASS       PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEPTH_DATA DepthData,
    IN     ULONG                        PnPControlDataLength,
    IN     KPROCESSOR_MODE              CallerMode
    );

NTSTATUS
PiControlQueryDeviceRelations(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA  RelationsData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlQueryTargetDeviceRelation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_TARGET_RELATION_DATA   TargetData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
PiControlQueryConflictList(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CONFLICT_DATA  ConflictData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    );

NTSTATUS
PiControlRetrieveDockData(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA DockData,
    IN     ULONG                                DockDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    );

NTSTATUS
PiControlGetDevicePowerData(
    IN  PDEVICE_NODE        DeviceNode,
    IN  KPROCESSOR_MODE     CallerMode,
    IN  ULONG               OutputBufferLength,
    IN  PVOID               PowerDataBuffer     OPTIONAL,
    OUT ULONG              *BytesWritten
    );

NTSTATUS
PiControlHaltDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

NTSTATUS
FORCEINLINE
PiControlAllocateBufferForUserModeCaller(
    PVOID           *Dest,
    ULONG           Size,
    KPROCESSOR_MODE CallerMode,
    PVOID           Src
    )
{
    if (Size == 0) {
        
        *Dest = NULL;
        return STATUS_SUCCESS;
    }
    if (CallerMode == KernelMode) {

        *Dest = Src;
        return STATUS_SUCCESS;
    }
    *Dest = ExAllocatePoolWithQuota(
        PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
        Size
        );
    if (*Dest == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(*Dest, Size);

    return STATUS_SUCCESS;
}

VOID
FORCEINLINE
PiControlFreeUserModeCallersBuffer(
    KPROCESSOR_MODE CallerMode,
    PVOID           Buffer
    )
{
    if (CallerMode != KernelMode) {

        if (Buffer != NULL) {

            ExFreePool(Buffer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpcvrt.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpcvrt.c

Abstract:

    This module contains support routines for the translating PnP resources.

Author:

    Robert Nelson (robertn) 13-October-1997


Environment:

    Kernel mode

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// This is a cpp style symbolic link
//
#include "convert.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpdata.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpdata.c

Abstract:

    This module contains the plug-and-play data

Author:

    Shie-Lin Tzong (shielint) 30-Jan-1995

Environment:

    Kernel mode


Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <initguid.h>

//
// INIT data segment
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

PVOID IopPnpScratchBuffer1 = NULL;
PCM_RESOURCE_LIST IopInitHalResources;
PDEVICE_NODE IopInitHalDeviceNode;
PIOP_RESERVED_RESOURCES_RECORD IopInitReservedResourceList;

//
// Regular data segment
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

//
// IopRootDeviceNode - the head of the PnP manager's device node tree.
//

PDEVICE_NODE IopRootDeviceNode;

//
// IoPnPDriverObject - the madeup driver object for pnp manager
//

PDRIVER_OBJECT IoPnpDriverObject;

//
// IopPnPSpinLock - spinlock for Pnp code.
//

KSPIN_LOCK IopPnPSpinLock;

//
// IopDeviceTreeLock - performs synchronization around the whole device node tree.
//

ERESOURCE IopDeviceTreeLock;

//
// IopSurpriseRemoveListLock - synchronizes access to the surprise remove list.
//

ERESOURCE IopSurpriseRemoveListLock;

//
// PiEngineLock - Synchronizes the start/enum and remove engines.
//

ERESOURCE PiEngineLock;

//
// PiEventQueueEmpty - Manual reset event which is set when the queue is empty
//

KEVENT PiEventQueueEmpty;

//
// PiEnumerationLock - to synchronize boot phase device enumeration
//

KEVENT PiEnumerationLock;

//
// IopNumberDeviceNodes - Number of outstanding device nodes in the system.
//

ULONG IopNumberDeviceNodes;

//
// IopPnpEnumerationRequestList - a link list of device enumeration requests to worker thread.
//

LIST_ENTRY IopPnpEnumerationRequestList;

//
// PnPInitComplete - A flag to indicate if PnP initialization is completed.
//

BOOLEAN PnPInitialized;

//
// PnPBootDriverInitialied
//

BOOLEAN PnPBootDriversInitialized;

//
// PnPBootDriverLoaded
//

BOOLEAN PnPBootDriversLoaded;

//
// IopBootConfigsReserved - Indicates whether we have reserved BOOT configs or not.
//

BOOLEAN IopBootConfigsReserved;

//
// Variable to hold boot allocation routine.
//

PIO_ALLOCATE_BOOT_RESOURCES_ROUTINE IopAllocateBootResourcesRoutine;

//
// Device node tree sequence.  Is bumped every time the tree is modified or a warm
// eject is queued.
//

ULONG IoDeviceNodeTreeSequence;

//
// PnpDefaultInterfaceTYpe - Use this if the interface type of resource list is unknown.
//

INTERFACE_TYPE PnpDefaultInterfaceType;

//
// IopMaxDeviceNodeLevel - Level number of the DeviceNode deepest in the tree
//
ULONG IopMaxDeviceNodeLevel;

//
// IopPendingEjects - List of pending eject requests
//
LIST_ENTRY  IopPendingEjects;

//
// IopPendingSurpriseRemovals - List of pending surprise removal requests
//
LIST_ENTRY  IopPendingSurpriseRemovals;

//
// Warm eject lock - only one warm eject is allowed to occur at a time
//
KEVENT IopWarmEjectLock;

//
// This field contains a devobj if a warm eject is in progress.
//
PDEVICE_OBJECT IopWarmEjectPdo;

//
// Arbiter data
//

ARBITER_INSTANCE IopRootPortArbiter;
ARBITER_INSTANCE IopRootMemArbiter;
ARBITER_INSTANCE IopRootDmaArbiter;
ARBITER_INSTANCE IopRootIrqArbiter;
ARBITER_INSTANCE IopRootBusNumberArbiter;

//
// The following resource is used to control access to device-related, Plug and Play-specific
// portions of the registry. These portions are:
//
//   HKLM\System\Enum
//   HKLM\System\CurrentControlSet\Hardware Profiles
//   HKLM\System\CurrentControlSet\Services\<service>\Enum
//
// It allows exclusive access for writing, as well as shared access for reading.
// The resource is initialized by the PnP manager initialization code during phase 0
// initialization.
//

ERESOURCE  PpRegistryDeviceResource;

//
// Table for Legacy Bus information
//
LIST_ENTRY  IopLegacyBusInformationTable[MaximumInterfaceType];

//
// Set to TRUE in the shutdown process.  This prevents us from starting any
// PNP operations once there is no longer a reasonable expectation they will
// succeed.
//
BOOLEAN PpPnpShuttingDown;

//
// The following semaphore is used by the IO system when it reports resource
// usage to the configuration registry on behalf of a driver.  This semaphore
// is initialized by the I/O system initialization code when the system is
// started.
//
KSEMAPHORE PpRegistrySemaphore;

//DEFINE_GUID(REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID, 0x8ECC055D, 0x047F, 0x11D1, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);

SYSTEM_HIVE_LIMITS PpSystemHiveLimits = {0};
BOOLEAN PpSystemHiveTooLarge = FALSE;

//
// This is really gross.
// HACK for MATROX G100 because it was too late to make this change for XP.
//

BOOLEAN PpCallerInitializesRequestTable = FALSE;

#if DBG

char *PpStateToNameTable[] = {
    "DeviceNodeUnspecified",
    "DeviceNodeUninitialized",
    "DeviceNodeInitialized",
    "DeviceNodeDriversAdded",
    "DeviceNodeResourcesAssigned",
    "DeviceNodeStartPending",
    "DeviceNodeStartCompletion",
    "DeviceNodeStartPostWork",
    "DeviceNodeStarted",
    "DeviceNodeQueryStopped",
    "DeviceNodeStopped",
    "DeviceNodeRestartCompletion",
    "DeviceNodeEnumeratePending",
    "DeviceNodeEnumerateCompletion",
    "DeviceNodeAwaitingQueuedDeletion",
    "DeviceNodeAwaitingQueuedRemoval",
    "DeviceNodeQueryRemoved",
    "DeviceNodeRemovePendingCloses",
    "DeviceNodeRemoved",
    "DeviceNodeDeletePendingCloses",
    "DeviceNodeDeleted"
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpdel.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpdel.c

Abstract:

    This module contains routines to perform device removal

Author:

    Robert B. Nelson (RobertN) Jun 1, 1998.

Revision History:

--*/

#include "pnpmgrp.h"
#include "wdmguid.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'edpP')
#endif

//
// Kernel mode PNP specific routines.
//

VOID
IopDelayedRemoveWorker(
    IN PVOID Context
    );

BOOLEAN
IopDeleteLockedDeviceNode(
    IN  PDEVICE_NODE                    DeviceNode,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  PRELATION_LIST                  RelationsList,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType        OPTIONAL,
    OUT PUNICODE_STRING                 VetoName        OPTIONAL
    );

NTSTATUS
IopProcessRelation(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    );

VOID
IopSurpriseRemoveLockedDeviceNode(
    IN      PDEVICE_NODE     DeviceNode,
    IN OUT  PRELATION_LIST   RelationsList
    );

BOOLEAN
IopQueryRemoveLockedDeviceNode(
    IN  PDEVICE_NODE        DeviceNode,
    OUT PNP_VETO_TYPE      *VetoType,
    OUT PUNICODE_STRING     VetoName
    );

VOID
IopCancelRemoveLockedDeviceNode(
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopRemoveLockedDeviceNode(
    IN      PDEVICE_NODE    DeviceNode,
    IN      ULONG           Problem,
    IN OUT  PRELATION_LIST  RelationsList
    );

typedef struct {

    BOOLEAN TreeDeletion;
    BOOLEAN DescendantNode;

} REMOVAL_WALK_CONTEXT, *PREMOVAL_WALK_CONTEXT;

NTSTATUS
PipRequestDeviceRemovalWorker(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID        Context
    );

NTSTATUS
PiProcessBusRelations(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    );

WORK_QUEUE_ITEM IopDeviceRemovalWorkItem;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopChainDereferenceComplete)
#pragma alloc_text(PAGE, IopDelayedRemoveWorker)
#pragma alloc_text(PAGE, IopDeleteLockedDeviceNode)
#pragma alloc_text(PAGE, IopSurpriseRemoveLockedDeviceNode)
#pragma alloc_text(PAGE, IopQueryRemoveLockedDeviceNode)
#pragma alloc_text(PAGE, IopCancelRemoveLockedDeviceNode)
#pragma alloc_text(PAGE, IopDeleteLockedDeviceNodes)
#pragma alloc_text(PAGE, IopInvalidateRelationsInList)
#pragma alloc_text(PAGE, IopBuildRemovalRelationList)
#pragma alloc_text(PAGE, IopProcessCompletedEject)
#pragma alloc_text(PAGE, IopProcessRelation)
#pragma alloc_text(PAGE, IopQueuePendingEject)
#pragma alloc_text(PAGE, IopQueuePendingSurpriseRemoval)
#pragma alloc_text(PAGE, IopUnloadAttachedDriver)
#pragma alloc_text(PAGE, IopUnlinkDeviceRemovalRelations)
#pragma alloc_text(PAGE, PipRequestDeviceRemoval)
#pragma alloc_text(PAGE, PipRequestDeviceRemovalWorker)
#pragma alloc_text(PAGE, PipIsBeingRemovedSafely)
#pragma alloc_text(PAGE, PiProcessBusRelations)
#endif

VOID
IopChainDereferenceComplete(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject,
    IN  BOOLEAN         OnCleanStack
    )

/*++

Routine Description:

    This routine is invoked when the reference count on a PDO and all its
    attached devices transitions to a zero.  It tags the devnode as ready for
    removal.  If all the devnodes are tagged then IopDelayedRemoveWorker is
    called to actually send the remove IRPs.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to the PDO whose references just
        went to zero.

    OnCleanStack - Indicates whether the current thread is in the middle a
                   driver operation.

Return Value:

    None.

--*/

{
    PPENDING_RELATIONS_LIST_ENTRY   entry;
    PLIST_ENTRY                     link;
    ULONG                           count;
    ULONG                           taggedCount;
    NTSTATUS                        status;

    PAGED_CODE();

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&IopSurpriseRemoveListLock, TRUE);

    //
    // Find the relation list this devnode is a member of.
    //
    for (link = IopPendingSurpriseRemovals.Flink;
         link != &IopPendingSurpriseRemovals;
         link = link->Flink) {

        entry = CONTAINING_RECORD(link, PENDING_RELATIONS_LIST_ENTRY, Link);

        //
        // Tag the devnode as ready for remove.  If it isn't in this list
        //
        status = IopSetRelationsTag( entry->RelationsList, PhysicalDeviceObject, TRUE );

        if (NT_SUCCESS(status)) {
            taggedCount = IopGetRelationsTaggedCount( entry->RelationsList );
            count = IopGetRelationsCount( entry->RelationsList );

            if (taggedCount == count) {
                //
                // Remove relations list from list of pending surprise removals.
                //
                RemoveEntryList( link );

                ExReleaseResourceLite(&IopSurpriseRemoveListLock);
                KeLeaveCriticalRegion();

                if ((!OnCleanStack) ||
                    (PsGetCurrentProcess() != PsInitialSystemProcess)) {

                    //
                    // Queue a work item to do the removal so we call the driver
                    // in the system process context rather than the random one
                    // we're in now.
                    //
                    ExInitializeWorkItem( &entry->WorkItem,
                                        IopDelayedRemoveWorker,
                                        entry);

                    ExQueueWorkItem(&entry->WorkItem, DelayedWorkQueue);

                } else {

                    //
                    // We are already in the system process and not in some
                    // random ObDeref call, so call the worker inline.
                    //
                    IopDelayedRemoveWorker( entry );
                }

                return;
            }

            break;
        }
    }

    ASSERT(link != &IopPendingSurpriseRemovals);

    ExReleaseResourceLite(&IopSurpriseRemoveListLock);
    KeLeaveCriticalRegion();
}

VOID
IopDelayedRemoveWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is usually called from a worker thread to actually send the
    remove IRPs once the reference count on a PDO and all its attached devices
    transitions to a zero.

Arguments:

    Context - Supplies a pointer to the pending relations list entry which has
        the relations list of PDOs we need to remove.

Return Value:

    None.

--*/

{
    PPENDING_RELATIONS_LIST_ENTRY entry = (PPENDING_RELATIONS_LIST_ENTRY)Context;

    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    IopDeleteLockedDeviceNodes( entry->DeviceObject,
                                entry->RelationsList,
                                RemoveDevice,           // OperationCode
                                FALSE,                  // ProcessIndirectDescendants
                                entry->Problem,         // Problem
                                NULL,                   // VetoType
                                NULL);                  // VetoName

    //
    // The final reference on DeviceNodes in the DeviceNodeDeletePendingCloses
    // state is dropped here.
    //
    IopFreeRelationList( entry->RelationsList );

    ExFreePool( entry );
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}


BOOLEAN
IopDeleteLockedDeviceNode(
    IN  PDEVICE_NODE                    DeviceNode,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  PRELATION_LIST                  RelationsList,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType        OPTIONAL,
    OUT PUNICODE_STRING                 VetoName        OPTIONAL
    )
/*++

Routine Description:

    This function assumes that the specified device is a bus and will
    recursively remove all its children.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be removed.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    NTSTATUS code.

--*/
{
    BOOLEAN success;

    PAGED_CODE();

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
              "IopDeleteLockedDeviceNode: Entered\n    DeviceNode = 0x%p\n    OperationCode = 0x%08X\n    RelationsList = 0x%p\n    Problem = %d\n",
              DeviceNode,
              OperationCode,
              RelationsList,
              Problem));

    success = TRUE;
    switch(OperationCode) {

        case SurpriseRemoveDevice:

            IopSurpriseRemoveLockedDeviceNode(DeviceNode, RelationsList);
            break;

        case RemoveDevice:

            IopRemoveLockedDeviceNode(DeviceNode, Problem, RelationsList);
            break;

        case QueryRemoveDevice:

            ASSERT(VetoType && VetoName);

            success = IopQueryRemoveLockedDeviceNode(
                DeviceNode,
                VetoType,
                VetoName
                );

            break;

        case CancelRemoveDevice:

            IopCancelRemoveLockedDeviceNode(DeviceNode);
            break;

        default:
            ASSERT(0);
            break;
    }

    return success;
}


VOID
IopSurpriseRemoveLockedDeviceNode(
    IN      PDEVICE_NODE     DeviceNode,
    IN OUT  PRELATION_LIST   RelationsList
    )
/*++

Routine Description:

    This function sends a surprise remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be surprise removed.

Return Value:

    None.

--*/
{
    PNP_DEVNODE_STATE devnodeState, schedulerState;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE child, nextChild;
    NTSTATUS status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (RelationsList);

    schedulerState = DeviceNode->State;

    ASSERT((schedulerState == DeviceNodeAwaitingQueuedDeletion) ||
           (schedulerState == DeviceNodeAwaitingQueuedRemoval));

    //
    // Clear the scheduling state (DeviceNodeAwaitingQueuedDeletion) off
    // the state stack.
    //
    PipRestoreDevNodeState(DeviceNode);

    devnodeState = DeviceNode->State;

    //
    // Do our state updates.
    //
    PpHotSwapInitRemovalPolicy(DeviceNode);

    if (devnodeState == DeviceNodeRemovePendingCloses) {

        //
        // If the state is DeviceNodeRemovePendingCloses, we should have got
        // here via DeviceNodeAwaitingQueuedDeletion. We're probably surprise
        // removing a device that was already surprise failed.
        //
        ASSERT(schedulerState == DeviceNodeAwaitingQueuedDeletion);

        //ASSERT(DeviceNode->Child == NULL);
        PipSetDevNodeState(DeviceNode, DeviceNodeDeletePendingCloses, NULL);
        return;
    }

    //
    // Detach any children from the tree here. If they needed SurpriseRemove
    // IRPs, they already will have received them.
    //
    for(child = DeviceNode->Child; child; child = nextChild) {

        //
        // Grab a copy of the next sibling before we blow away this devnode.
        //
        nextChild = child->Sibling;

        if (child->Flags & DNF_ENUMERATED) {
            child->Flags &= ~DNF_ENUMERATED;
        }

        //
        // If the child has resources and we are wiping out the parent, we need
        // to drop the resources (the parent will lose them when his arbiter is
        // nuked with the upcoming SurpriseRemoveDevice.)
        //
        if (PipDoesDevNodeHaveResources(child)) {

            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "IopSurpriseRemoveLockedDeviceNode: Releasing resources for child device = 0x%p\n",
                       child->PhysicalDeviceObject));

            //
            // ADRIAO N.B. 2000/08/21 -
            //     Note that if the child stack has no drivers then a Remove
            // IRP could be sent here. The stack would be unable to distinguish
            // this from AddDevice cleanup.
            //
/*
            if ((child->State == DeviceNodeUninitialized) ||
                (child->State == DeviceNodeInitialized)) {

                IopRemoveDevice(child->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);
            }
*/
            IopReleaseDeviceResources(child, FALSE);
        }

        //
        // The devnode will be removed from the tree in
        // IopUnlinkDeviceRemovalRelations. We don't remove it here as we want
        // the tree structure in place for the upcoming broadcast down to user
        // mode.
        //
        // Note - Children in the Uninitialized/Initialized states are not
        //        put directly into DeviceNodeDeleted today. This could be
        //        done but we'd have to verify what happens to API calls in
        //        response to SurpriseRemoval notifications. (Actually, those
        //        API's are blocked in ppcontrol.c, hotplug cannot in fact
        //        walk the tree!)
        //
        PipSetDevNodeState(child, DeviceNodeDeletePendingCloses, NULL);
    }

    //
    // Only send surprise removes where neccessary.
    //
    // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
    //                      Win2K erroneously sent SR's to nonstarted nodes.
    //
    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = IopRemoveDevice(deviceObject, IRP_MN_SURPRISE_REMOVAL);

    if ((devnodeState == DeviceNodeStarted) ||
        (devnodeState == DeviceNodeStopped) ||
        (devnodeState == DeviceNodeStartPostWork) ||
        (devnodeState == DeviceNodeRestartCompletion)) {

        //deviceObject = DeviceNode->PhysicalDeviceObject;

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopSurpriseRemoveLockedDeviceNode: Sending surprise remove irp to device = 0x%p\n",
                   deviceObject));

        //status = IopRemoveDevice(deviceObject, IRP_MN_SURPRISE_REMOVAL);

        //
        // Disable any device interfaces that may still be enabled for this
        // device after the removal.
        //
        IopDisableDeviceInterfaces(&DeviceNode->InstancePath);

        if (NT_SUCCESS(status)) {

            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "IopSurpriseRemoveLockedDeviceNode: Releasing devices resources\n"));

            IopReleaseDeviceResources(DeviceNode, FALSE);
        }

        if (DeviceNode->Flags & DNF_ENUMERATED) {

            PipSetDevNodeState(DeviceNode, DeviceNodeRemovePendingCloses, NULL);

        } else {

            ASSERT(schedulerState == DeviceNodeAwaitingQueuedDeletion);
            PipSetDevNodeState(DeviceNode, DeviceNodeDeletePendingCloses, NULL);
        }
    }

    ASSERT(DeviceNode->DockInfo.DockStatus != DOCK_ARRIVING);
}


BOOLEAN
IopQueryRemoveLockedDeviceNode(
    IN  PDEVICE_NODE        DeviceNode,
    OUT PNP_VETO_TYPE      *VetoType,
    OUT PUNICODE_STRING     VetoName
    )
/*++

Routine Description:

    This function sends a query remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be query removed.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    BOOLEAN (success/failure).

--*/
{
    PNP_DEVNODE_STATE devnodeState;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;

    PAGED_CODE();

    devnodeState = DeviceNode->State;

    switch(devnodeState) {
        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeRemoved:
            //
            // Don't send Queries to devices that haven't been started.
            //
            ASSERT(DeviceNode->Child == NULL);
            return TRUE;

        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
            //
            // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
            //                      Win2K erroneously sent QR's to all nodes.
            //
            break;

        case DeviceNodeStarted:
            //
            // This guy needs to be queried
            //
            break;

        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
            //
            // These states should have been culled by IopProcessRelation
            //
            ASSERT(0);
            return TRUE;

        case DeviceNodeQueryStopped:
        case DeviceNodeEnumeratePending:
        case DeviceNodeStartPending:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeQueryRemoved:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            //
            // None of these should be seen here.
            //
            ASSERT(0);
            return TRUE;
    }

    ASSERT(PipAreDriversLoaded(DeviceNode));

    deviceObject = DeviceNode->PhysicalDeviceObject;

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
               "IopQueryRemoveLockedDeviceNode: Sending QueryRemove irp to device = 0x%p\n",
               deviceObject));

    status = IopRemoveDevice(deviceObject, IRP_MN_QUERY_REMOVE_DEVICE);

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopQueryRemoveLockedDeviceNode: QueryRemove vetoed by device = 0x%p, sending CancelRemove\n",
                   deviceObject));

        IopRemoveDevice(deviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);

        *VetoType = PNP_VetoDevice;
        RtlCopyUnicodeString(VetoName, &DeviceNode->InstancePath);
        return FALSE;
    }

    PipSetDevNodeState(DeviceNode, DeviceNodeQueryRemoved, NULL);
    return TRUE;
}


VOID
IopCancelRemoveLockedDeviceNode(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This function sends a cancel remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be cancel removed.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    if (DeviceNode->State != DeviceNodeQueryRemoved) {

        return;
    }

    //
    // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
    //                      Win2K erroneously sent QR's to all nodes.
    //
    //ASSERT(DeviceNode->PreviousState == DeviceNodeStarted);

    deviceObject = DeviceNode->PhysicalDeviceObject;

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
               "IopCancelRemoveLockedDeviceNode: Sending CancelRemove irp to device = 0x%p\n",
               deviceObject));

    IopRemoveDevice(deviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);

    PipRestoreDevNodeState(DeviceNode);
}


VOID
IopRemoveLockedDeviceNode(
    IN      PDEVICE_NODE    DeviceNode,
    IN      ULONG           Problem,
    IN OUT  PRELATION_LIST  RelationsList
    )
/*++

Routine Description:

    This function sends a remove IRP to a devnode and processes the
    results.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be removed.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject = DeviceNode->PhysicalDeviceObject;
    PDEVICE_OBJECT *attachedDevices, device1, *device2;
    PDRIVER_OBJECT *attachedDrivers, *driver;
    ULONG length = 0;
    PDEVICE_NODE child, nextChild;
    BOOLEAN removeIrpNeeded;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (RelationsList);

    //
    // Do our state updates.
    //
    PpHotSwapInitRemovalPolicy(DeviceNode);

    //
    // Make sure we WILL drop our references to its children.
    //
    for(child = DeviceNode->Child; child; child = nextChild) {

        //
        // Grab a copy of the next sibling before we blow away this devnode.
        //
        nextChild = child->Sibling;

        if (child->Flags & DNF_ENUMERATED) {
            child->Flags &= ~DNF_ENUMERATED;
        }

        ASSERT(child->State == DeviceNodeRemoved);
        ASSERT(!PipAreDriversLoaded(child));

        //
        // If the child has resources and we are wiping out the parent, we need
        // to drop the resources (the parent will lose them when his arbiter is
        // nuked with the upcoming RemoveDevice.)
        //
        if (PipDoesDevNodeHaveResources(child)) {

            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "IopRemoveLockedDeviceNode: Releasing resources for child device = 0x%p\n",
                       child->PhysicalDeviceObject));

            //
            // ADRIAO N.B. 2000/08/21 -
            //     Note that the child stack has no drivers and as such a
            // Remove IRP could be sent here. The stack would be unable to
            // distinguish this from AddDevice cleanup.
            //
            IopRemoveDevice(child->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);

            IopReleaseDeviceResources(child, FALSE);
        }

        //
        // The devnode will be removed from the tree in
        // IopUnlinkDeviceRemovalRelations. We don't remove it here as we want
        // the tree structure in place for the upcoming broadcast down to user
        // mode.
        //
        PipSetDevNodeState(child, DeviceNodeDeleted, NULL);
    }

    if ((DeviceNode->State == DeviceNodeAwaitingQueuedDeletion) ||
        (DeviceNode->State == DeviceNodeAwaitingQueuedRemoval)) {

        if (!(DeviceNode->Flags & DNF_ENUMERATED)) {

            ASSERT(DeviceNode->State == DeviceNodeAwaitingQueuedDeletion);
            //
            // This happens when pnpevent shortcircuits the surprise remove path
            // upon discovering a nonstarted device has been removed from the
            // system. This devnode will need a final remove if it alone has been
            // pulled from the tree (we don't here know if the parent is going to
            // get pulled too, which would make this remove IRP unneccessary.)
            //
            //PipRestoreDevNodeState(DeviceNode);
            PipSetDevNodeState(DeviceNode, DeviceNodeDeletePendingCloses, NULL);

        } else {

            ASSERT(DeviceNode->State == DeviceNodeAwaitingQueuedRemoval);
            PipRestoreDevNodeState(DeviceNode);
        }
    }

    //
    // Do the final remove cleanup on the device...
    //
    switch(DeviceNode->State) {

        case DeviceNodeUninitialized:
        case DeviceNodeInitialized:
        case DeviceNodeRemoved:
            //
            // ISSUE - 2000/08/24 - ADRIAO: Maintaining noncorrect Win2K behavior
            //                      Win2K erroneously sent SR's and R's to all
            //                      nodes. Those bugs must be fixed in tandem.
            //
            //removeIrpNeeded = FALSE;
            removeIrpNeeded = TRUE;
            break;

        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
            //
            // Expected.
            //
            removeIrpNeeded = TRUE;
            break;

        case DeviceNodeStarted:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
        case DeviceNodeQueryStopped:
        case DeviceNodeEnumeratePending:
        case DeviceNodeStartPending:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:
        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            //
            // None of these should be seen here.
            //
            ASSERT(0);
            removeIrpNeeded = TRUE;
            break;
    }

    //
    // Add a reference to each FDO attached to the PDO such that the FDOs won't
    // actually go away until the removal operation is completed.
    // Note we need to make a copy of all the attached devices because we won't be
    // able to traverse the attached chain when the removal operation is done.
    //
    // ISSUE - 2000/08/21 - ADRIAO: Low resource path
    //     The allocation failure cases here are quite broken, and now that
    // IofCallDriver and IofCompleteRequest reference things appropriately, all
    // this is strictly unneccessary.
    //
    device1 = deviceObject->AttachedDevice;
    while (device1) {
        length++;
        device1 = device1->AttachedDevice;
    }

    attachedDevices = NULL;
    attachedDrivers = NULL;
    if (length != 0) {

        length = (length + 2) * sizeof(PDEVICE_OBJECT);

        attachedDevices = (PDEVICE_OBJECT *) ExAllocatePool(PagedPool, length);
        if (attachedDevices) {

            attachedDrivers = (PDRIVER_OBJECT *) ExAllocatePool(PagedPool, length);
            if (attachedDrivers) {

                RtlZeroMemory(attachedDevices, length);
                RtlZeroMemory(attachedDrivers, length);
                device1 = deviceObject->AttachedDevice;
                device2 = attachedDevices;
                driver = attachedDrivers;

                while (device1) {
                    ObReferenceObject(device1);
                    *device2++ = device1;
                    *driver++ = device1->DriverObject;
                    device1 = device1->AttachedDevice;
                }

            } else {

                ExFreePool(attachedDevices);
                attachedDevices = NULL;
            }
        }
    }

    if (removeIrpNeeded) {

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopRemoveLockedDeviceNode: Sending remove irp to device = 0x%p\n",
                   deviceObject));

        IopRemoveDevice(deviceObject, IRP_MN_REMOVE_DEVICE);

        if (DeviceNode->State == DeviceNodeQueryRemoved) {
            //
            // Disable any device interfaces that may still be enabled for this
            // device after the removal.
            //
            IopDisableDeviceInterfaces(&DeviceNode->InstancePath);
        }

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopRemoveLockedDeviceNode: Releasing devices resources\n"));

        //
        // ISSUE - 2000/3/8 - RobertN - This doesn't take into account the
        // cleanup of surprise removed devices.  We will query for boot configs
        // unnecessarily.  We should probably also check if the parent is NULL.
        //
        IopReleaseDeviceResources(
            DeviceNode,
            (BOOLEAN) ((DeviceNode->Flags & DNF_ENUMERATED) != 0)
            );
    }

    if (!(DeviceNode->Flags & DNF_ENUMERATED)) {
        //
        // If the device is a dock, remove it from the list of dock devices
        // and change the current Hardware Profile, if necessary.
        //
        ASSERT(DeviceNode->DockInfo.DockStatus != DOCK_ARRIVING) ;
        if ((DeviceNode->DockInfo.DockStatus == DOCK_DEPARTING)||
            (DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED)) {

            PpProfileCommitTransitioningDock(DeviceNode, DOCK_DEPARTING);
        }
    }

    //
    // Remove the reference to the attached FDOs to allow them to be actually
    // deleted.
    //
    device2 = attachedDevices;
    if (device2 != NULL) {
        driver = attachedDrivers;
        while (*device2) {
            (*device2)->DeviceObjectExtension->ExtensionFlags &= ~(DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED);
            (*device2)->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;
            IopUnloadAttachedDriver(*driver);
            ObDereferenceObject(*device2);
            device2++;
            driver++;
        }
        ExFreePool(attachedDevices);
        ExFreePool(attachedDrivers);
    }

    deviceObject->DeviceObjectExtension->ExtensionFlags &= ~(DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED);
    deviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;

    //
    // Now mark this one removed if it's still in the tree.
    //
    if (DeviceNode->Flags & DNF_ENUMERATED) {

        ASSERT(DeviceNode->Parent);
        PipSetDevNodeState(DeviceNode, DeviceNodeRemoved, NULL);

    } else if (DeviceNode->Parent != NULL) {

        //
        // The devnode will be removed from the tree in
        // IopUnlinkDeviceRemovalRelations.
        //
        PipSetDevNodeState(DeviceNode, DeviceNodeDeleted, NULL);

    } else {

        ASSERT(DeviceNode->State == DeviceNodeDeletePendingCloses);
        PipSetDevNodeState(DeviceNode, DeviceNodeDeleted, NULL);
    }

    //
    // Set the problem codes appropriatly. We don't change the problem codes
    // on a devnode unless:
    // a) It disappeared.
    // b) We're disabling it.
    //
    if ((!PipDoesDevNodeHaveProblem(DeviceNode)) ||
        (Problem == CM_PROB_DEVICE_NOT_THERE) ||
        (Problem == CM_PROB_DISABLED)) {

        PipClearDevNodeProblem(DeviceNode);
        PipSetDevNodeProblem(DeviceNode, Problem);
    }
}


NTSTATUS
IopDeleteLockedDeviceNodes(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PRELATION_LIST                  RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN  BOOLEAN                         ProcessIndirectDescendants,
    IN  ULONG                           Problem,
    OUT PNP_VETO_TYPE                  *VetoType                    OPTIONAL,
    OUT PUNICODE_STRING                 VetoName                    OPTIONAL
    )
/*++

Routine Description:

    This routine performs requested operation on the DeviceObject and
    the device objects specified in the DeviceRelations.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    DeviceRelations - supplies a pointer to the device's removal relations.

    OperationCode - Operation code, i.e., QueryRemove, CancelRemove, Remove...

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT relatedDeviceObject;
    ULONG marker;
    BOOLEAN directDescendant;

    PAGED_CODE();

    IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
               "IopDeleteLockedDeviceNodes: Entered\n    DeviceObject = 0x%p\n    RelationsList = 0x%p\n    OperationCode = %d\n",
               DeviceObject,
               RelationsList,
               OperationCode));

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;

    marker = 0;
    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &relatedDeviceObject,
                                  &directDescendant,
                                  NULL,
                                  TRUE)) {

        //
        // Depending on the operation we need to do different things.
        //
        //  QueryRemoveDevice / CancelRemoveDevice
        //      Process both direct and indirect descendants
        //
        //  SurpriseRemoveDevice / RemoveDevice
        //      Ignore indirect descendants
        //
        if (directDescendant || ProcessIndirectDescendants) {

            deviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

            if (!IopDeleteLockedDeviceNode( deviceNode,
                                            OperationCode,
                                            RelationsList,
                                            Problem,
                                            VetoType,
                                            VetoName)) {

                ASSERT(OperationCode == QueryRemoveDevice);

                while (IopEnumerateRelations( RelationsList,
                                              &marker,
                                              &relatedDeviceObject,
                                              NULL,
                                              NULL,
                                              FALSE)) {

                    deviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                    IopDeleteLockedDeviceNode( deviceNode,
                                               CancelRemoveDevice,
                                               RelationsList,
                                               Problem,
                                               VetoType,
                                               VetoName);
                }

                status = STATUS_UNSUCCESSFUL;
                goto exit;
            }
        }
    }

exit:
    return status;
}

NTSTATUS
IopBuildRemovalRelationList(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    OUT PNP_VETO_TYPE                  *VetoType,
    OUT PUNICODE_STRING                 VetoName,
    OUT PRELATION_LIST                 *RelationsList
    )
/*++

Routine Description:

    This routine locks the device subtrees for removal operation and returns
    a list of device objects which need to be removed with the specified
    DeviceObject.

    Caller must hold a reference to the DeviceObject.

Arguments:

    DeviceObject - Supplies a pointer to the device object to be removed.

    OperationCode - Operation code, i.e., QueryEject, CancelEject, Eject...

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

    RelationList - supplies a pointer to a variable to receive the device's
                   relations.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS                status;
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST          newRelationsList;

    PAGED_CODE();

    *RelationsList = NULL;

    deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    //
    // Obviously no one should try to delete the whole device node tree.
    //
    ASSERT(DeviceObject != IopRootDeviceNode->PhysicalDeviceObject);

    if ((newRelationsList = IopAllocateRelationList(OperationCode)) == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // First process the object itself
    //
    status = IopProcessRelation(
        deviceNode,
        OperationCode,
        TRUE,
        VetoType,
        VetoName,
        newRelationsList
        );

    ASSERT(status != STATUS_INVALID_DEVICE_REQUEST);

    if (NT_SUCCESS(status)) {
        IopCompressRelationList(&newRelationsList);
        *RelationsList = newRelationsList;

        //
        // At this point we have a list of all the relations, those that are
        // direct descendants of the original device we are ejecting or
        // removing have the DirectDescendant bit set.
        //
        // Relations which were merged from an existing eject have the tagged
        // bit set.
        //
        // All of the relations and their parents are locked.
        //
        // There is a reference on each device object by virtue of it being in
        // the list.  There is another one on each device object because it is
        // locked and the lock count is >= 1.
        //
        // There is also a reference on each relation's parent and it's lock
        // count is >= 1.
        //
    } else {

        IopFreeRelationList(newRelationsList);
    }

    return status;
}

NTSTATUS
PiProcessBusRelations(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    )
/*++

Routine Description:

    This routine processes the BusRelations for the specified devnode.    
    Caller must hold the device tree lock.

Arguments:

    DeviceNode - Supplies a pointer to the device object to be collected.

    OperationCode - Operation code, i.e., QueryRemove, QueryEject, ...

    IsDirectDescendant - TRUE if the device object is a direct descendant
                         of the node the operation is being performed upon.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

    RelationList - supplies a pointer to a variable to receive the device's
                   removal relations.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_NODE child;
    PDEVICE_OBJECT childDeviceObject;
    NTSTATUS status;

    PAGED_CODE();

    for(child = DeviceNode->Child;
        child != NULL;
        child = child->Sibling) {

        childDeviceObject = child->PhysicalDeviceObject;

        status = IopProcessRelation(
            child,
            OperationCode,
            IsDirectDescendant,
            VetoType,
            VetoName,
            RelationsList
            );

        ASSERT(status == STATUS_SUCCESS || status == STATUS_UNSUCCESSFUL);

        if (!NT_SUCCESS(status)) {

            return status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopProcessRelation(
    IN      PDEVICE_NODE                    DeviceNode,
    IN      PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode,
    IN      BOOLEAN                         IsDirectDescendant,
    OUT     PNP_VETO_TYPE                  *VetoType,
    OUT     PUNICODE_STRING                 VetoName,
    IN OUT  PRELATION_LIST                  RelationsList
    )
/*++

Routine Description:

    This routine builds the list of device objects that need to be removed or
    examined when the passed in device object is torn down.

    Caller must hold the device tree lock.

Arguments:

    DeviceNode - Supplies a pointer to the device object to be collected.

    OperationCode - Operation code, i.e., QueryRemove, QueryEject, ...

    IsDirectDescendant - TRUE if the device object is a direct descendant
                         of the node the operation is being performed upon.

    VetoType - Pointer to address that receives the veto type if the operation
               failed.

    VetoName - Pointer to a unicode string that will receive data appropriate
               to the veto type.

    RelationList - supplies a pointer to a variable to receive the device's
                   removal relations.


Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_NODE                    relatedDeviceNode;
    PDEVICE_OBJECT                  relatedDeviceObject;
    PDEVICE_RELATIONS               deviceRelations;
    PLIST_ENTRY                     ejectLink;
    PPENDING_RELATIONS_LIST_ENTRY   ejectEntry;
    PRELATION_LIST                  pendingRelationList;
    NTSTATUS                        status;
    ULONG                           i;
    PNP_DEVNODE_STATE               devnodeState;

    PAGED_CODE();

    if (OperationCode == QueryRemoveDevice || OperationCode == EjectDevice) {

        if (DeviceNode->State == DeviceNodeDeleted) {

            //
            // The device has already been removed, fail the attempt.
            //
            return STATUS_UNSUCCESSFUL;
        }

        if ((DeviceNode->State == DeviceNodeAwaitingQueuedRemoval) ||
            (DeviceNode->State == DeviceNodeAwaitingQueuedDeletion)) {

            //
            // The device has failed or is going away.  Let the queued
            // remove deal with it.
            //
            return STATUS_UNSUCCESSFUL;
        }

        if ((DeviceNode->State == DeviceNodeRemovePendingCloses) ||
            (DeviceNode->State == DeviceNodeDeletePendingCloses)) {

            //
            // The device is in the process of being surprise removed, let it finish
            //
            *VetoType = PNP_VetoOutstandingOpen;
            RtlCopyUnicodeString(VetoName, &DeviceNode->InstancePath);
            return STATUS_UNSUCCESSFUL;
        }

        if ((DeviceNode->State == DeviceNodeStopped) ||
            (DeviceNode->State == DeviceNodeRestartCompletion)) {

            //
            // We are recovering from a rebalance. This should never happen and
            // this return code will cause us to ASSERT.
            //
            return STATUS_INVALID_DEVICE_REQUEST;
        }

    } else if (DeviceNode->State == DeviceNodeDeleted) {

        //
        // The device has already been removed, ignore it. We should only have
        // seen such a thing if it got handed to us in a Removal or Ejection
        // relation.
        //
        ASSERT(!IsDirectDescendant);
        return STATUS_SUCCESS;
    }

    status = IopAddRelationToList( RelationsList,
                                   DeviceNode->PhysicalDeviceObject,
                                   IsDirectDescendant,
                                   FALSE);

    if (status == STATUS_SUCCESS) {

        if (!(DeviceNode->Flags & DNF_LOCKED_FOR_EJECT)) {

            //
            // Then process the bus relations
            //
            status = PiProcessBusRelations(
                        DeviceNode,
                        OperationCode,
                        IsDirectDescendant,
                        VetoType,
                        VetoName,
                        RelationsList
                        );
            if (!NT_SUCCESS(status)) {

                return status;
            }
            //
            // Retrieve the state of the devnode when it failed.
            //
            devnodeState = DeviceNode->State;
            if ((devnodeState == DeviceNodeAwaitingQueuedRemoval) ||
                (devnodeState == DeviceNodeAwaitingQueuedDeletion)) {

                devnodeState = DeviceNode->PreviousState;
            }

            //
            // Next the removal relations
            //
            if ((devnodeState == DeviceNodeStarted) ||
                (devnodeState == DeviceNodeStopped) ||
                (devnodeState == DeviceNodeStartPostWork) ||
                (devnodeState == DeviceNodeRestartCompletion)) {

                status = IopQueryDeviceRelations( RemovalRelations,
                                                  DeviceNode->PhysicalDeviceObject,
                                                  TRUE,
                                                  &deviceRelations);

                if (NT_SUCCESS(status) && deviceRelations) {

                    for (i = 0; i < deviceRelations->Count; i++) {

                        relatedDeviceObject = deviceRelations->Objects[i];

                        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                        ASSERT(relatedDeviceNode);

                        if (relatedDeviceNode) {

                            status = IopProcessRelation(
                                relatedDeviceNode,
                                OperationCode,
                                FALSE,
                                VetoType,
                                VetoName,
                                RelationsList
                                );
                        }

                        ObDereferenceObject( relatedDeviceObject );

                        ASSERT(status == STATUS_SUCCESS ||
                               status == STATUS_UNSUCCESSFUL);

                        if (!NT_SUCCESS(status)) {

                            ExFreePool(deviceRelations);

                            return status;
                        }
                    }

                    ExFreePool(deviceRelations);
                } else {
                    if (status != STATUS_NOT_SUPPORTED) {
                        IopDbgPrint((IOP_LOADUNLOAD_WARNING_LEVEL,
                                   "IopProcessRelation: IopQueryDeviceRelations failed, DeviceObject = 0x%p, status = 0x%08X\n",
                                   DeviceNode->PhysicalDeviceObject, status));
                    }
                }
            }

            //
            // Finally the eject relations if we are doing an eject operation
            //
            if (OperationCode != QueryRemoveDevice &&
                OperationCode != RemoveFailedDevice &&
                OperationCode != RemoveUnstartedFailedDevice) {
                status = IopQueryDeviceRelations( EjectionRelations,
                                                  DeviceNode->PhysicalDeviceObject,
                                                  TRUE,
                                                  &deviceRelations);

                if (NT_SUCCESS(status) && deviceRelations) {

                    for (i = 0; i < deviceRelations->Count; i++) {

                        relatedDeviceObject = deviceRelations->Objects[i];

                        relatedDeviceNode = (PDEVICE_NODE)relatedDeviceObject->DeviceObjectExtension->DeviceNode;

                        ASSERT(relatedDeviceNode);

                        if (relatedDeviceNode) {

                            status = IopProcessRelation(
                                relatedDeviceNode,
                                OperationCode,
                                FALSE,
                                VetoType,
                                VetoName,
                                RelationsList
                                );
                        }

                        ObDereferenceObject( relatedDeviceObject );

                        ASSERT(status == STATUS_SUCCESS ||
                               status == STATUS_UNSUCCESSFUL);

                        if (!NT_SUCCESS(status)) {

                            ExFreePool(deviceRelations);

                            return status;
                        }
                    }

                    ExFreePool(deviceRelations);
                } else {
                    if (status != STATUS_NOT_SUPPORTED) {
                        IopDbgPrint((IOP_LOADUNLOAD_WARNING_LEVEL,
                                   "IopProcessRelation: IopQueryDeviceRelations failed, DeviceObject = 0x%p, status = 0x%08X\n",
                                   DeviceNode->PhysicalDeviceObject,
                                   status));
                    }
                }
            }

            status = STATUS_SUCCESS;

        } else {

            //
            // Look to see if this device is already part of a pending ejection.
            // If it is and we are doing an ejection then we will subsume it
            // within the larger ejection.  If we aren't doing an ejection then
            // we better be processing the removal of one of the ejected devices.
            //
            for(ejectLink = IopPendingEjects.Flink;
                ejectLink != &IopPendingEjects;
                ejectLink = ejectLink->Flink) {

                ejectEntry = CONTAINING_RECORD( ejectLink,
                                                PENDING_RELATIONS_LIST_ENTRY,
                                                Link);

                if (ejectEntry->RelationsList != NULL &&
                    IopIsRelationInList(ejectEntry->RelationsList, DeviceNode->PhysicalDeviceObject)) {


                    if (OperationCode == EjectDevice) {

                        status = IopRemoveRelationFromList(RelationsList, DeviceNode->PhysicalDeviceObject);

                        ASSERT(NT_SUCCESS(status));

                        IopCancelPendingEject(ejectEntry);
                        pendingRelationList = ejectEntry->RelationsList;
                        ejectEntry->RelationsList = NULL;

                        //
                        //     If a parent fails eject and it has a child that is
                        // infinitely pending an eject, this means the child now
                        // wakes up. One suggestion brought up that does not involve
                        // a code change is to amend the WDM spec to say if driver
                        // gets a start IRP for a device pending eject, it should
                        // cancel the eject IRP automatically.
                        //
                        IopMergeRelationLists(RelationsList, pendingRelationList, FALSE);

                        IopFreeRelationList(pendingRelationList);

                        if (IsDirectDescendant) {
                            //
                            // If IsDirectDescendant is specified then we need to
                            // get that bit set on the relation that caused us to
                            // do the merge.  IopAddRelationToList will fail with
                            // STATUS_OBJECT_NAME_COLLISION but the bit will still
                            // be set as a side effect.
                            //
                            IopAddRelationToList( RelationsList,
                                                  DeviceNode->PhysicalDeviceObject,
                                                  TRUE,
                                                  FALSE);
                        }
                    } else if (OperationCode != QueryRemoveDevice) {

                        //
                        // Either the device itself disappeared or an ancestor
                        // of this device failed in some way. In both cases this
                        // happened before we completed the eject IRP. We'll
                        // remove it from the list in the pending ejection and
                        // return it.
                        //

                        status = IopRemoveRelationFromList( ejectEntry->RelationsList,
                                                            DeviceNode->PhysicalDeviceObject);

                        DeviceNode->Flags &= ~DNF_LOCKED_FOR_EJECT;

                        ASSERT(NT_SUCCESS(status));

                    } else {

                        //
                        // Someone is trying to take offline a supertree of this
                        // device which happens to be prepared for ejection.
                        // Whistler like Win2K won't let this happen (doing so
                        // isn't too hard, it involves writing code to cancel
                        // the outstanding eject and free the relation list.)
                        //
                        ASSERT(0);
                        return STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;
                }
            }

            ASSERT(ejectLink != &IopPendingEjects);

            if (ejectLink == &IopPendingEjects) {

                PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceNode->PhysicalDeviceObject);
                KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                              PNP_ERR_DEVICE_MISSING_FROM_EJECT_LIST,
                              (ULONG_PTR)DeviceNode->PhysicalDeviceObject,
                              0,
                              0);
            }
        }
    } else if (status == STATUS_OBJECT_NAME_COLLISION) {

        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "IopProcessRelation: Duplicate relation, DeviceObject = 0x%p\n",
                   DeviceNode->PhysicalDeviceObject));

        status = PiProcessBusRelations(
            DeviceNode,
            OperationCode,
            IsDirectDescendant,
            VetoType,
            VetoName,
            RelationsList
            );

    } else if (status != STATUS_INSUFFICIENT_RESOURCES) {

        PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceNode->PhysicalDeviceObject);
        KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                      PNP_ERR_UNEXPECTED_ADD_RELATION_ERR,
                      (ULONG_PTR)DeviceNode->PhysicalDeviceObject,
                      (ULONG_PTR)RelationsList,
                      status);
    }

    return status;
}

BOOLEAN
IopQueuePendingEject(
    PPENDING_RELATIONS_LIST_ENTRY Entry
    )
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    InsertTailList(&IopPendingEjects, &Entry->Link);

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    return TRUE;
}

NTSTATUS
IopInvalidateRelationsInList(
    IN  PRELATION_LIST              RelationsList,
    IN  PLUGPLAY_DEVICE_DELETE_TYPE OperationCode,
    IN  BOOLEAN                     OnlyIndirectDescendants,
    IN  BOOLEAN                     RestartDevNode
    )
/*++

Routine Description:

    Iterate over the relations in the list creating a second list containing the
    parent of each entry skipping parents which are also in the list.  In other
    words, if the list contains node P and node C where node C is a child of node
    P then the parent of node P would be added but not node P itself.


Arguments:

    RelationsList           - List of relations

    OperationCode           - Type of operation the invalidation is associated
                              with.

    OnlyIndirectDescendants - Indirect relations are those which aren't direct
                              descendants (bus relations) of the PDO originally
                              targetted for the operation or its direct
                              descendants.  This would include Removal or
                              Eject relations.

    RestartDevNode          - If true then any node who's parent was invalidated
                              is restarted.  This flag requires that all the
                              relations in the list have been previously
                              sent a remove IRP.


Return Value:

    NTSTATUS code.

--*/
{
    PRELATION_LIST                  parentsList;
    PDEVICE_OBJECT                  deviceObject, parentObject;
    PDEVICE_NODE                    deviceNode;
    ULONG                           marker;
    BOOLEAN                         directDescendant, tagged;

    PAGED_CODE();

    parentsList = IopAllocateRelationList(OperationCode);

    if (parentsList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IopSetAllRelationsTags( RelationsList, FALSE );

    //
    // Traverse the list creating a new list with the topmost parents of
    // each sublist contained in RelationsList.
    //

    marker = 0;

    while (IopEnumerateRelations( RelationsList,
                                  &marker,
                                  &deviceObject,
                                  &directDescendant,
                                  &tagged,
                                  TRUE)) {

        if (!OnlyIndirectDescendants || !directDescendant) {

            if (!tagged) {

                parentObject = deviceObject;

                while (IopSetRelationsTag( RelationsList, parentObject, TRUE ) == STATUS_SUCCESS) {

                    deviceNode = parentObject->DeviceObjectExtension->DeviceNode;

                    if (RestartDevNode)  {

                        deviceNode->Flags &= ~DNF_LOCKED_FOR_EJECT;

                        //
                        // Bring the devnode back online if it:
                        // a) It is still physically present
                        // b) It was held for an eject
                        //
                        if ((deviceNode->Flags & DNF_ENUMERATED) &&
                            PipIsDevNodeProblem(deviceNode, CM_PROB_HELD_FOR_EJECT)) {

                            ASSERT(deviceNode->Child == NULL);
                            ASSERT(!PipAreDriversLoaded(deviceNode));

                            //
                            // This operation is a reorder barrier. This keeps
                            // our subsequent enumeration from draining prior
                            // to our problem clearing.
                            //
                            PipRequestDeviceAction( parentObject,
                                                    ClearEjectProblem,
                                                    TRUE,
                                                    0,
                                                    NULL,
                                                    NULL );
                        }
                    }

                    if (deviceNode->Parent != NULL) {

                        parentObject = deviceNode->Parent->PhysicalDeviceObject;

                    } else {
                        parentObject = NULL;
                        break;
                    }
                }

                if (parentObject != NULL)  {
                    IopAddRelationToList( parentsList, parentObject, FALSE, FALSE );
                }
            }

        }
    }

    //
    // Reenumerate each of the parents
    //

    marker = 0;

    while (IopEnumerateRelations( parentsList,
                                  &marker,
                                  &deviceObject,
                                  NULL,
                                  NULL,
                                  FALSE)) {

        PipRequestDeviceAction( deviceObject,
                                ReenumerateDeviceTree,
                                FALSE,
                                0,
                                NULL,
                                NULL );
    }

    //
    // Free the parents list
    //

    IopFreeRelationList( parentsList );

    return STATUS_SUCCESS;
}

VOID
IopProcessCompletedEject(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called at passive level from a worker thread that was queued
    either when an eject IRP completed (see io\pnpirp.c - IopDeviceEjectComplete
    or io\pnpirp.c - IopEjectDevice), or when a warm eject needs to be performed.
    We also may need to fire off any enumerations of parents of ejected devices
    to verify they have indeed left.

Arguments:

    Context - Pointer to the pending relations list which contains the device
              to eject (warm) and the list of parents to reenumerate.

Return Value:

    None.

--*/
{
    PPENDING_RELATIONS_LIST_ENTRY entry = (PPENDING_RELATIONS_LIST_ENTRY)Context;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if ((entry->LightestSleepState != PowerSystemWorking) &&
        (entry->LightestSleepState != PowerSystemUnspecified)) {

        //
        // For docks, WinLogon gets to do the honors. For other devices, the
        // user must infer when it's safe to remove the device (if we've powered
        // up, it may not be safe now!)
        //
        entry->DisplaySafeRemovalDialog = FALSE;

        //
        // This is a warm eject request, initiate it here.
        //
        status = IopWarmEjectDevice(entry->DeviceObject, entry->LightestSleepState);

        //
        // We're back and we either succeeded or failed. Either way...
        //
    }

    if (entry->DockInterface) {

        entry->DockInterface->ProfileDepartureSetMode(
            entry->DockInterface->Context,
            PDS_UPDATE_DEFAULT
            );

        entry->DockInterface->InterfaceDereference(
            entry->DockInterface->Context
            );
    }

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    RemoveEntryList( &entry->Link );

    //
    // Check if the RelationsList pointer in the context structure is NULL.  If
    // so, this means we were cancelled because this eject is part of a new
    // larger eject.  In that case all we want to do is unlink and free the
    // context structure.
    //

    //
    // Two interesting points about such code.
    //
    // 1) If you wait forever to complete an eject of a dock, we *wait* forever
    //    in the Query profile change state. No sneaky adding another dock. You
    //    must finish what you started...
    // 2) Let's say you are ejecting a dock, and it is taking a long time. If
    //    you try to eject the parent, that eject will *not* grab this lower
    //    eject as we will block on the profile change semaphore. Again, finish
    //    what you started...
    //

    if (entry->RelationsList != NULL)  {

        if (entry->ProfileChangingEject) {

            PpProfileMarkAllTransitioningDocksEjected();
        }

        IopInvalidateRelationsInList(
            entry->RelationsList,
            EjectDevice,
            FALSE,
            TRUE
            );

        //
        // Free the relations list
        //

        IopFreeRelationList( entry->RelationsList );

    } else {

        entry->DisplaySafeRemovalDialog = FALSE;
    }

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Complete the event
    //
    if (entry->DeviceEvent != NULL ) {

        PpCompleteDeviceEvent( entry->DeviceEvent, status );
    }

    if (entry->DisplaySafeRemovalDialog) {

        PpSetDeviceRemovalSafe(entry->DeviceObject, NULL, NULL);
    }

    ObDereferenceObject(entry->DeviceObject);
    ExFreePool( entry );
}

VOID
IopQueuePendingSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRELATION_LIST List,
    IN ULONG Problem
    )
{
    PPENDING_RELATIONS_LIST_ENTRY   entry;

    PAGED_CODE();

    entry = (PPENDING_RELATIONS_LIST_ENTRY) PiAllocateCriticalMemory(
        SurpriseRemoveDevice,
        NonPagedPool,
        sizeof(PENDING_RELATIONS_LIST_ENTRY),
        'rcpP'
        );

    ASSERT(entry != NULL);

    entry->DeviceObject = DeviceObject;
    entry->RelationsList = List;
    entry->Problem = Problem;
    entry->ProfileChangingEject = FALSE ;

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&IopSurpriseRemoveListLock, TRUE);

    InsertTailList(&IopPendingSurpriseRemovals, &entry->Link);

    ExReleaseResourceLite(&IopSurpriseRemoveListLock);
    KeLeaveCriticalRegion();
}

VOID
IopUnlinkDeviceRemovalRelations(
    IN      PDEVICE_OBJECT          RemovedDeviceObject,
    IN OUT  PRELATION_LIST          RelationsList,
    IN      UNLOCK_UNLINK_ACTION    UnlinkAction
    )
/*++

Routine Description:

    This routine unlocks the device tree deletion operation.
    If there is any pending kernel deletion, this routine initiates
    a worker thread to perform the work.

Arguments:

    RemovedDeviceObject - Supplies a pointer to the device object to which the
        remove was originally targetted (as opposed to one of the relations).

    DeviceRelations - supplies a pointer to the device's removal relations.

    UnlinkAction - Specifies which devnodes will be unlinked from the devnode
        tree.

        UnLinkRemovedDeviceNodes - Devnodes which are no longer enumerated and
            have been sent a REMOVE_DEVICE IRP are unlinked.

        UnlinkAllDeviceNodesPendingClose - This is used when a device is
            surprise removed.  Devnodes in RelationsList are unlinked from the
            tree if they don't have children and aren't consuming any resources.

        UnlinkOnlyChildDeviceNodesPendingClose - This is used when a device fails
            while started.  We unlink any child devnodes of the device which
            failed but not the failed device's devnode.

Return Value:

    NTSTATUS code.

--*/
{

    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT deviceObject;
    ULONG marker;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (RemovedDeviceObject);

    PpDevNodeLockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);

    if (ARGUMENT_PRESENT(RelationsList)) {
        marker = 0;
        while (IopEnumerateRelations( RelationsList,
                                      &marker,
                                      &deviceObject,
                                      NULL,
                                      NULL,
                                      TRUE)) {

            deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;

            //
            // There are three different scenarios in which we want to unlink a
            // devnode from the tree.
            //
            // 1) A devnode is no longer enumerated and has been sent a
            //    remove IRP.
            //
            // 2) A devnode has been surprise removed, has no children, has
            //    no resources or they've been freed.  UnlinkAction will be
            //    UnlinkAllDeviceNodesPendingClose.
            //
            // 3) A devnode has failed and a surprise remove IRP has been sent.
            //    Then we want to remove children without resources but not the
            //    failed devnode itself.  UnlinkAction will be
            //    UnlinkOnlyChildDeviceNodesPendingClose.
            //
            switch(UnlinkAction) {

                case UnlinkRemovedDeviceNodes:

                    //
                    // Removes have been sent to every devnode in this relation
                    // list. Deconstruct the tree appropriately.
                    //
                    ASSERT(deviceNode->State != DeviceNodeDeletePendingCloses);
                    break;

                case UnlinkAllDeviceNodesPendingClose:

                    ASSERT((deviceNode->State == DeviceNodeDeletePendingCloses) ||
                           (deviceNode->State == DeviceNodeDeleted));
                    break;

                case UnlinkOnlyChildDeviceNodesPendingClose:

#if DBG
                    if (RemovedDeviceObject != deviceObject) {

                        ASSERT((deviceNode->State == DeviceNodeDeletePendingCloses) ||
                               (deviceNode->State == DeviceNodeDeleted));
                    } else {

                        ASSERT(deviceNode->State == DeviceNodeRemovePendingCloses);
                    }
#endif
                    break;

                default:
                    ASSERT(0);
                    break;
            }

            //
            // Deconstruct the tree appropriately.
            //
            if ((deviceNode->State == DeviceNodeDeletePendingCloses) ||
                (deviceNode->State == DeviceNodeDeleted)) {

                ASSERT(!(deviceNode->Flags & DNF_ENUMERATED));

                //
                // Remove the devnode from the tree.
                //
                IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                           "IopUnlinkDeviceRemovalRelations: Cleaning up registry values, instance = %wZ\n",
                           &deviceNode->InstancePath));

                PiLockPnpRegistry(TRUE);

                IopCleanupDeviceRegistryValues(&deviceNode->InstancePath);

                IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                           "IopUnlinkDeviceRemovalRelations: Removing DevNode tree, DevNode = 0x%p\n",
                           deviceNode));

                PpDevNodeRemoveFromTree(deviceNode);

                PiUnlockPnpRegistry();

                if (deviceNode->State == DeviceNodeDeleted) {

                    ASSERT(PipDoesDevNodeHaveProblem(deviceNode));
                    IopRemoveRelationFromList(RelationsList, deviceObject);

                    //
                    //     Ashes to ashes
                    //     Memory to freelist
                    //
                    ObDereferenceObject(deviceObject); // Added during Enum
                } else {

                    //
                    // There is still one more ref on the device object, one
                    // holding it to the relation list. Once the final removes
                    // are sent the relationlist will be freed and then the
                    // final ref will be dropped.
                    //
                    ObDereferenceObject(deviceObject); // Added during Enum
                }

            } else {

                ASSERT(deviceNode->Flags & DNF_ENUMERATED);
            }
        }
    }

    PpDevNodeUnlockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);
}

//
// The routines below are specific to kernel mode PnP configMgr.
//
NTSTATUS
IopUnloadAttachedDriver(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This function unloads the driver for the specified device object if it does not
    control any other device object.

Arguments:

    DeviceObject - Supplies a pointer to a device object

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PWCHAR buffer;
    UNICODE_STRING unicodeName;
    ULONG bufferSize;
    PUNICODE_STRING serviceName = &DriverObject->DriverExtension->ServiceKeyName;

    PAGED_CODE();

    if (DriverObject->DriverSection != NULL) {

        if (DriverObject->DeviceObject == NULL) {

            bufferSize = CmRegistryMachineSystemCurrentControlSetServices.Length +
                                     serviceName->Length + sizeof(WCHAR) +
                                     sizeof(L"\\");
            buffer = (PWCHAR) ExAllocatePool(
                                 PagedPool,
                                 bufferSize);
            if (!buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            StringCbPrintfW( 
                buffer,
                bufferSize,
                L"%s\\%s",
                CmRegistryMachineSystemCurrentControlSetServices.Buffer,
                serviceName->Buffer);
            RtlInitUnicodeString(&unicodeName, buffer);
            status = IopUnloadDriver(&unicodeName, TRUE);
            if (NT_SUCCESS(status)) {
                IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                           "****** Unloaded driver (%wZ)\n",
                           serviceName));

            } else {
                IopDbgPrint((IOP_LOADUNLOAD_WARNING_LEVEL,
                           "****** Error unloading driver (%wZ), status = 0x%08X\n",
                           serviceName,
                           status));

            }
            ExFreePool(unicodeName.Buffer);
        }
        else {
            IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                       "****** Skipping unload of driver (%wZ), DriverObject->DeviceObject != NULL\n",
                       serviceName));
        }
    }
    else {
        //
        // This is a boot driver, can't be unloaded just return SUCCESS
        //
        IopDbgPrint((IOP_LOADUNLOAD_INFO_LEVEL,
                   "****** Skipping unload of boot driver (%wZ)\n",
                   serviceName));
    }
    return STATUS_SUCCESS;
}

VOID
PipRequestDeviceRemoval(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN      TreeDeletion,
    IN ULONG        Problem
    )
/*++

Routine Description:

    This routine queues a work item to remove or delete a device.

Arguments:

    DeviceNode - Supplies a pointer to the device object to be cleaned up.

    TreeDeletion - If TRUE, the devnode is physically missing and should
                   eventually end up in the deleted state. If FALSE, the
                   stack just needs to be torn down.

    Problem - Problem code to assign to the removed stack.

Return Value:

    None.

--*/
{
    REMOVAL_WALK_CONTEXT removalWalkContext;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(DeviceNode != NULL);

    if (DeviceNode) {

        if (DeviceNode->InstancePath.Length == 0) {

            IopDbgPrint((IOP_ERROR_LEVEL, "Driver %wZ reported child %p missing right after enumerating it!\n", &DeviceNode->Parent->ServiceName, DeviceNode));
            ASSERT(DeviceNode->InstancePath.Length != 0);
        }

        PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

        removalWalkContext.TreeDeletion = TreeDeletion;
        removalWalkContext.DescendantNode = FALSE;

        status = PipRequestDeviceRemovalWorker(
            DeviceNode,
            (PVOID) &removalWalkContext
            );

        ASSERT(NT_SUCCESS(status));

        //
        // Queue the event, we'll return immediately after it's queued.
        //
        PpSetTargetDeviceRemove(
            DeviceNode->PhysicalDeviceObject,
            TRUE,
            TRUE,
            FALSE,
            FALSE,
            Problem,
            NULL,
            NULL,
            NULL,
            NULL
            );
    }
}

NTSTATUS
PipRequestDeviceRemovalWorker(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID        Context
    )
/*++

Routine Description:

    This function is a worker routine for PipRequestDeviceRemoval routine. It
    is used to mark an entire subtree for removal.

Arguments:

    DeviceNode - Supplies a pointer to the device node to mark.

    Context - Points to a boolean that indicates whether the removal is
              physical or stack specific.

Return Value:

    NTSTATUS value.

--*/
{
    PREMOVAL_WALK_CONTEXT removalWalkContext;
    PNP_DEVNODE_STATE     sentinelState;

    PAGED_CODE();

    removalWalkContext = (PREMOVAL_WALK_CONTEXT) Context;

    switch(DeviceNode->State) {

        case DeviceNodeUninitialized:
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeInitialized:
            //
            // This can happen on a non-descendant node if it fails AddDevice.
            //
            break;

        case DeviceNodeDriversAdded:
            //
            // Happens when a parent stops enumerating a kid who had a
            // resource conflict. This can also happen if AddDevice fails when
            // a lower filter is attached but the service fails.
            //
            break;

        case DeviceNodeResourcesAssigned:
            //
            // Happens when a parent stops enumerating a kid who has been
            // assigned resources but hadn't yet been started.
            //
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeStartPending:
            //
            // Not implemented yet.
            //
            ASSERT(0);
            break;

        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
            //
            // These are operational states for taking Added to Started. No
            // descendant should be in this state as the engine currently
            // finishes these before progressing to the next node.
            //
            // Note that DeviceNodeStartPostWork can occur on a legacy added
            // root enumerated devnode. Since the root itself cannot disappear
            // or be removed the below asserts still hold true.
            //
            // ISSUE - 2000/08/12 - ADRIAO: IoReportResourceUsage sync problems
            //
            ASSERT(!removalWalkContext->DescendantNode);
            ASSERT(!removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeStarted:
            break;

        case DeviceNodeQueryStopped:
            //
            // Internal rebalance engine state, should never be seen.
            //
            ASSERT(0);
            break;

        case DeviceNodeStopped:
            ASSERT(removalWalkContext->DescendantNode);
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeRestartCompletion:
            //
            // This is an operational state for taking Stopped to Started. No
            // descendant should be in this state as the engine currently
            // finishes these before progressing to the next node.
            //
            ASSERT(!removalWalkContext->DescendantNode);
            ASSERT(!removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeEnumeratePending:
            //
            // Not implemented yet.
            //
            ASSERT(0);
            break;

        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeAwaitingQueuedDeletion:

            //
            // ISSUE - 2000/08/30 - ADRIAO: Excessive reenum race
            //     Here we hit a case where we didn't flush the removes in the
            // queue due to excessive enumeration. Flushing the last removes
            // is problematic as they themselves will queue up enums! Until a
            // better solution is found, we convert the state here. Bleargh!!!
            //     Note that this can also happen because PipDeviceActionWorker
            // doesn't flush enums in the case of failed
            // PipProcessQueryDeviceState or PipCallDriverAddDevice!
            //
            ASSERT(removalWalkContext->TreeDeletion);
            //ASSERT(0);
            PipRestoreDevNodeState(DeviceNode);
            PipSetDevNodeState(DeviceNode, DeviceNodeAwaitingQueuedDeletion, NULL);
            return STATUS_SUCCESS;

        case DeviceNodeRemovePendingCloses:
        case DeviceNodeRemoved:
            ASSERT(removalWalkContext->TreeDeletion);
            break;

        case DeviceNodeEnumerateCompletion:
        case DeviceNodeQueryRemoved:
        case DeviceNodeDeletePendingCloses:
        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            break;
    }

    //
    // Give the devnode a sentinel state that will keep the start/enum engine
    // at bay until the removal engine processes the tree.
    //
    sentinelState = (removalWalkContext->TreeDeletion) ?
        DeviceNodeAwaitingQueuedDeletion :
        DeviceNodeAwaitingQueuedRemoval;

    PipSetDevNodeState(DeviceNode, sentinelState, NULL);

    //
    // All subsequent nodes are descendants, and all subsequent removals are
    // deletions.
    //
    removalWalkContext->DescendantNode = TRUE;
    removalWalkContext->TreeDeletion = TRUE;

    return PipForAllChildDeviceNodes(
        DeviceNode,
        PipRequestDeviceRemovalWorker,
        (PVOID) removalWalkContext
        );
}


BOOLEAN
PipIsBeingRemovedSafely(
    IN  PDEVICE_NODE    DeviceNode
    )
/*++

Routine Description:

    This function looks at a device with a physical remove queued against it
    and indicates whether it is safe to remove.

Arguments:

    DeviceNode - Supplies a pointer to the device node to examine. The devnode
                 should be in the DeviceNodeAwaitingQueuedDeletion state.

Return Value:

    BOOLEAN - TRUE iff the devnode is safe to be removed.

--*/
{
    PAGED_CODE();

    ASSERT(DeviceNode->State == DeviceNodeAwaitingQueuedDeletion);

    if (IopDeviceNodeFlagsToCapabilities(DeviceNode)->SurpriseRemovalOK) {

        return TRUE;
    }

    if ((DeviceNode->PreviousState != DeviceNodeStarted) &&
        (DeviceNode->PreviousState != DeviceNodeStopped) &&
        (DeviceNode->PreviousState != DeviceNodeStartPostWork) &&
        (DeviceNode->PreviousState != DeviceNodeRestartCompletion)) {

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpbusno.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpbusno.c

Abstract:

    Root Bus Number arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Constants
//


#define MAX_ULONGLONG           ((ULONGLONG) -1)

//
// Prototypes
//

NTSTATUS
IopBusNumberInitialize(
    VOID
    );

NTSTATUS
IopBusNumberUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopBusNumberPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopBusNumberScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopBusNumberUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );


//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopBusNumberInitialize)
#pragma alloc_text(PAGE, IopBusNumberUnpackRequirement)
#pragma alloc_text(PAGE, IopBusNumberPackResource)
#pragma alloc_text(PAGE, IopBusNumberScoreRequirement)
#pragma alloc_text(PAGE, IopBusNumberUnpackResource)

#endif // ALLOC_PRAGMA

//
// Implementation
//

NTSTATUS
IopBusNumberInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{
    NTSTATUS    status;

    IopRootBusNumberArbiter.UnpackRequirement = IopBusNumberUnpackRequirement;
    IopRootBusNumberArbiter.PackResource = IopBusNumberPackResource;
    IopRootBusNumberArbiter.UnpackResource = IopBusNumberUnpackResource;
    IopRootBusNumberArbiter.ScoreRequirement = IopBusNumberScoreRequirement;

    status = ArbInitializeArbiterInstance(&IopRootBusNumberArbiter,
                                          NULL,  // Indicates a root arbiter
                                          CmResourceTypeBusNumber,
                                          L"RootBusNumber",
                                          L"Root",
                                          NULL    // no translation of BusNumber
                                          );
    if (NT_SUCCESS(status)) {

        //
        // Add the invalid range 100 - ffffffff ffffffff
        //
        RtlAddRange( IopRootBusNumberArbiter.Allocation,
                     (ULONGLONG) 0x100,
                     (ULONGLONG) -1,
                     0, // UserFlags
                     0, // Flag
                     NULL,
                     NULL
                   );

    }

    return status;
}

//
// Arbiter callbacks
//

NTSTATUS
IopBusNumberUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    ARB_PRINT(2,
                ("Unpacking BusNumber requirement %p => 0x%I64x-0x%I64x\n",
                Descriptor,
                (ULONGLONG) Descriptor->u.BusNumber.MinBusNumber,
                (ULONGLONG) Descriptor->u.BusNumber.MaxBusNumber
                ));

    *Minimum = (ULONGLONG) Descriptor->u.BusNumber.MinBusNumber;
    *Maximum = (ULONGLONG) Descriptor->u.BusNumber.MaxBusNumber;
    *Length = Descriptor->u.BusNumber.Length;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
IopBusNumberScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    score = (Descriptor->u.BusNumber.MaxBusNumber -
                Descriptor->u.BusNumber.MinBusNumber) /
                Descriptor->u.BusNumber.Length;

    ARB_PRINT(2,
                ("Scoring BusNumber resource %p => %i\n",
                Descriptor,
                score
                ));

    return score;
}

NTSTATUS
IopBusNumberPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeBusNumber);

    ARB_PRINT(2,
                ("Packing BusNumber resource %p => 0x%I64x\n",
                Descriptor,
                Start
                ));

    Descriptor->Type = CmResourceTypeBusNumber;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->u.BusNumber.Start = (ULONG) Start;
    Descriptor->u.BusNumber.Length = Requirement->u.BusNumber.Length;

    return STATUS_SUCCESS;
}

NTSTATUS
IopBusNumberUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start);
    ASSERT(Length);
    ASSERT(Descriptor->Type == CmResourceTypeBusNumber);

    *Start = (ULONGLONG) Descriptor->u.BusNumber.Start;
    *Length = Descriptor->u.BusNumber.Length;

    ARB_PRINT(2,
                ("Unpacking BusNumber resource %p => 0x%I64x\n",
                Descriptor,
                *Start
                ));

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpdd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

All rights reserved

Module Name:

    pnpdd.c

Abstract:

    This module implements new Plug-And-Play driver entries and IRPs.

Author:

    Shie-Lin Tzong (shielint) June-16-1995

Environment:

    Kernel mode only.

Revision History:

*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ddpP')
#endif

//
// Internal definitions and references
//

typedef struct _ROOT_ENUMERATOR_CONTEXT {
    NTSTATUS Status;
    PUNICODE_STRING KeyName;
    ULONG MaxDeviceCount;
    ULONG DeviceCount;
    PDEVICE_OBJECT *DeviceList;
} ROOT_ENUMERATOR_CONTEXT, *PROOT_ENUMERATOR_CONTEXT;

NTSTATUS
IopGetServiceType(
    IN PUNICODE_STRING KeyName,
    IN PULONG ServiceType
    );

BOOLEAN
IopInitializeDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    );

BOOLEAN
IopInitializeDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    );

BOOLEAN
IopIsFirmwareDisabled (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopPnPCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

NTSTATUS
IopTranslatorHandlerCm (
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT DeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );
NTSTATUS
IopTranslatorHandlerIo (
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
IopGetRootDevices (
    PDEVICE_RELATIONS *DeviceRelations
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopGetRootDevices)
#pragma alloc_text(PAGE, IopGetServiceType)
#pragma alloc_text(PAGE, IopInitializeDeviceKey)
#pragma alloc_text(PAGE, IopInitializeDeviceInstanceKey)
#pragma alloc_text(PAGE, IopIsFirmwareDisabled)
#pragma alloc_text(PAGE, PipIsFirmwareMapperDevicePresent)
#pragma alloc_text(PAGE, IopPnPAddDevice)
#pragma alloc_text(PAGE, IopPnPDispatch)
#pragma alloc_text(PAGE, IopTranslatorHandlerCm)
#pragma alloc_text(PAGE, IopTranslatorHandlerIo)
#pragma alloc_text(PAGE, IopSystemControlDispatch)
#endif // ALLOC_PRAGMA

NTSTATUS
IopPnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    UNREFERENCED_PARAMETER( DriverObject );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

#if DBG

    //
    // We should never get an AddDevice request.
    //

    DbgBreakPoint();

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
IopTranslatorHandlerCm (
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT DeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
{
    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( Direction );
    UNREFERENCED_PARAMETER( AlternativesCount );
    UNREFERENCED_PARAMETER( Alternatives );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    *Target = *Source;

    return STATUS_SUCCESS;
}
NTSTATUS
IopTranslatorHandlerIo (
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
{
    PIO_RESOURCE_DESCRIPTOR newDesc;

    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    newDesc = (PIO_RESOURCE_DESCRIPTOR) ExAllocatePool(PagedPool, sizeof(IO_RESOURCE_DESCRIPTOR));
    if (newDesc == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    *TargetCount = 1;
    *newDesc = *Source;
    *Target = newDesc;

    return STATUS_SUCCESS;
}

NTSTATUS
IopPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION      IrpSp;
    PPOWER_SEQUENCE         PowerSequence;
    NTSTATUS                Status;


    UNREFERENCED_PARAMETER( DeviceObject );

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    Status = Irp->IoStatus.Status;

    switch (IrpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            Status = STATUS_NOT_SUPPORTED;
            break;

        case IRP_MN_POWER_SEQUENCE:
            PowerSequence = IrpSp->Parameters.PowerSequence.PowerSequence;
            PowerSequence->SequenceD1 = PoPowerSequence;
            PowerSequence->SequenceD2 = PoPowerSequence;
            PowerSequence->SequenceD3 = PoPowerSequence;
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_POWER:
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SET_POWER:
            switch (IrpSp->Parameters.Power.Type) {
                case SystemPowerState:
                    Status = STATUS_SUCCESS;
                    break;

                case DevicePowerState:
                    //
                    // To be here the FDO must have passed the IRP on.
                    // We do not know how to turn the device off, but the
                    // FDO is prepaired for it work
                    //

                    Status = STATUS_SUCCESS;
                    break;

                default:
                    //
                    // Unkown power type
                    //
                    Status = STATUS_NOT_SUPPORTED;
                    break;
            }
            break;

        default:
            // Unkown power minor code
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    //
    // For lagecy devices that do not have drivers loaded, complete
    // power irps with success.
    //

    PoStartNextPowerIrp(Irp);
    if (Status != STATUS_NOT_SUPPORTED) {
       Irp->IoStatus.Status = Status;
    } else {
       Status = Irp->IoStatus.Status;
    }
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}

NTSTATUS
IopPnPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIOPNP_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PVOID information = NULL;
    ULONG length, uiNumber;
    PWCHAR id, wp;
    PDEVICE_NODE deviceNode;
    PARBITER_INTERFACE arbiterInterface;  // PNPRES test
    PTRANSLATOR_INTERFACE translatorInterface;  // PNPRES test

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch (irpSp->MinorFunction){

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
    case IRP_MN_START_DEVICE:

        //
        // If we get a start device request for a PDO, we simply
        // return success.
        //

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        //
        // As we fail all STOP's, this cancel is always successful, and we have
        // no work to do.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_STOP_DEVICE:

        //
        // We can not success the query stop.  We don't handle it.  because
        // we don't know how to stop a root enumerated device.
        //
        status = STATUS_UNSUCCESSFUL ;
        break;

    case IRP_MN_QUERY_RESOURCES:

        status = IopGetDeviceResourcesFromRegistry(
                         DeviceObject,
                         QUERY_RESOURCE_LIST,
                         REGISTRY_BOOT_CONFIG,
                         &information,
                         &length);
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
            information = NULL;
        }
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        status = IopGetDeviceResourcesFromRegistry(
                         DeviceObject,
                         QUERY_RESOURCE_REQUIREMENTS,
                         REGISTRY_BASIC_CONFIGVECTOR,
                         &information,
                         &length);
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
            information = NULL;
        }
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // For root enumerated devices we let the device objects stay.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (DeviceObject == IopRootDeviceNode->PhysicalDeviceObject &&
            irpSp->Parameters.QueryDeviceRelations.Type == BusRelations) {
            status = IopGetRootDevices((PDEVICE_RELATIONS *)&information);
        } else {
            if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {
                PDEVICE_RELATIONS deviceRelations;

                deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
                if (deviceRelations == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    deviceRelations->Count = 1;
                    deviceRelations->Objects[0] = DeviceObject;
                    ObReferenceObject(DeviceObject);
                    information = (PVOID)deviceRelations;
                    status = STATUS_SUCCESS;
                }
            } else {
                information = (PVOID)Irp->IoStatus.Information;
                status = Irp->IoStatus.Status;
            }
        }
        break;

    case IRP_MN_QUERY_INTERFACE:
        status = Irp->IoStatus.Status;
        deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode == IopRootDeviceNode) {
            if ( IopCompareGuid((PVOID)irpSp->Parameters.QueryInterface.InterfaceType, (PVOID)&GUID_ARBITER_INTERFACE_STANDARD)) {
                status = STATUS_SUCCESS;
                arbiterInterface = (PARBITER_INTERFACE) irpSp->Parameters.QueryInterface.Interface;
                arbiterInterface->ArbiterHandler = ArbArbiterHandler;
                switch ((UCHAR)((ULONG_PTR)irpSp->Parameters.QueryInterface.InterfaceSpecificData)) {
                case CmResourceTypePort:
                    arbiterInterface->Context = (PVOID) &IopRootPortArbiter;
                    break;
                case CmResourceTypeMemory:
                    arbiterInterface->Context = (PVOID) &IopRootMemArbiter;
                    break;
                case CmResourceTypeInterrupt:
                    arbiterInterface->Context = (PVOID) &IopRootIrqArbiter;
                    break;
                case CmResourceTypeDma:
                    arbiterInterface->Context = (PVOID) &IopRootDmaArbiter;
                    break;
                case CmResourceTypeBusNumber:
                    arbiterInterface->Context = (PVOID) &IopRootBusNumberArbiter;
                    break;
                default:
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
            } else if ( IopCompareGuid((PVOID)irpSp->Parameters.QueryInterface.InterfaceType, (PVOID)&GUID_TRANSLATOR_INTERFACE_STANDARD)) {
                translatorInterface = (PTRANSLATOR_INTERFACE) irpSp->Parameters.QueryInterface.Interface;
                translatorInterface->TranslateResources = IopTranslatorHandlerCm;
                translatorInterface->TranslateResourceRequirements = IopTranslatorHandlerIo;
                status = STATUS_SUCCESS;
            }
        }
        break;

    case IRP_MN_QUERY_CAPABILITIES:

        {
            ULONG i;
            PDEVICE_POWER_STATE state;
            PDEVICE_CAPABILITIES deviceCapabilities;

            deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

            deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
            deviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
            deviceCapabilities->Version = 1;

            deviceCapabilities->DeviceState[PowerSystemUnspecified]=PowerDeviceUnspecified;
            deviceCapabilities->DeviceState[PowerSystemWorking]=PowerDeviceD0;

            state = &deviceCapabilities->DeviceState[PowerSystemSleeping1];

            for (i = PowerSystemSleeping1; i < PowerSystemMaximum; i++) {

                //
                // Only supported state, currently, is off.
                //

                *state++ = PowerDeviceD3;
            }

            if(IopIsFirmwareDisabled(deviceNode)) {
                //
                // this device has been disabled by BIOS
                //
                deviceCapabilities->HardwareDisabled = TRUE;
            }
            if (deviceCapabilities->UINumber == (ULONG)-1) {
                //
                // Get the UI number from the registry.
                //
                length = sizeof(uiNumber);
                status = PiGetDeviceRegistryProperty(
                    DeviceObject,
                    REG_DWORD,
                    REGSTR_VALUE_UI_NUMBER,
                    NULL,
                    &uiNumber,
                    &length);
                if (NT_SUCCESS(status)) {

                    deviceCapabilities->UINumber = uiNumber;
                }
            }

            status = STATUS_SUCCESS;
        }
        break;

    case IRP_MN_QUERY_ID:
        if (DeviceObject != IopRootDeviceNode->PhysicalDeviceObject &&
            (!NT_SUCCESS(Irp->IoStatus.Status) || !Irp->IoStatus.Information)) {

            deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
            switch (irpSp->Parameters.QueryId.IdType) {

            case BusQueryInstanceID:
            case BusQueryDeviceID:

                id = (PWCHAR)ExAllocatePool(PagedPool, deviceNode->InstancePath.Length);
                if (id) {
                    ULONG separatorCount = 0;

                    RtlZeroMemory(id, deviceNode->InstancePath.Length);
                    information = id;
                    status = STATUS_SUCCESS;
                    wp = deviceNode->InstancePath.Buffer;
                    if (irpSp->Parameters.QueryId.IdType == BusQueryDeviceID) {
                        while(*wp) {
                            if (*wp == OBJ_NAME_PATH_SEPARATOR) {
                                separatorCount++;
                                if (separatorCount == 2) {
                                    break;
                                }
                            }
                            *id = *wp;
                            id++;
                            wp++;
                        }
                    } else {
                        while(*wp) {
                            if (*wp == OBJ_NAME_PATH_SEPARATOR) {
                                separatorCount++;
                                if (separatorCount == 2) {
                                    wp++;
                                    break;
                                }
                            }
                            wp++;
                        }
                        while (*wp) {
                            *id = *wp;
                            id++;
                            wp++;
                        }
                    }
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;

            case BusQueryCompatibleIDs:

                if((Irp->IoStatus.Status != STATUS_NOT_SUPPORTED) ||
                   (deviceExtension == NULL))  {

                    //
                    // Upper driver has given some sort of reply or this device
                    // object wasn't allocated to handle these requests.
                    //

                    status = Irp->IoStatus.Status;
                    break;
                }

                if(deviceExtension->CompatibleIdListSize != 0) {

                    id = ExAllocatePool(PagedPool,
                                        deviceExtension->CompatibleIdListSize);

                    if(id == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    RtlCopyMemory(id,
                                  deviceExtension->CompatibleIdList,
                                  deviceExtension->CompatibleIdListSize);

                    information = id;
                    status = STATUS_SUCCESS;
                    break;
                }

            default:

                information = (PVOID)Irp->IoStatus.Information;
                status = Irp->IoStatus.Status;
            }
        } else {
            information = (PVOID)Irp->IoStatus.Information;
            status = Irp->IoStatus.Status;
        }

        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        if (    irpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation &&
                !Irp->IoStatus.Information) {
            //
            // Read and return the location in the registry.
            //
            length = 0;
            PiGetDeviceRegistryProperty(
                DeviceObject,
                REG_SZ,
                REGSTR_VALUE_LOCATION_INFORMATION,
                NULL,
                NULL,
                &length);
            if (length) {

                information = ExAllocatePool(PagedPool, length);
                if (information) {

                    status = PiGetDeviceRegistryProperty(
                        DeviceObject,
                        REG_SZ,
                        REGSTR_VALUE_LOCATION_INFORMATION,
                        NULL,
                        information,
                        &length);
                    if (!NT_SUCCESS(status)) {

                        ExFreePool(information);
                        information = NULL;
                    }
                } else {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        } else {

            information = (PVOID)Irp->IoStatus.Information;
            status = Irp->IoStatus.Status;
        }
        break;

    default:

        information = (PVOID)Irp->IoStatus.Information;
        status = Irp->IoStatus.Status;
        break;
    }

    //
    // Complete the Irp and return.
    //

    IopPnPCompleteRequest(Irp, status, (ULONG_PTR)information);
    return status;
}

VOID
IopPnPCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )

/*++

Routine Description:

    This routine completes PnP irps for our pseudo driver.

Arguments:

    Irp - Supplies a pointer to the irp to be completed.

    Status - completion status.

    Information - completion information to be passed back.

Return Value:

    None.

--*/

{

    //
    // Complete the IRP.  First update the status...
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = Information;

    //
    // ... and complete it.
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

BOOLEAN
IopIsFirmwareDisabled (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine determines if the devicenode has been disabled by firmware.

Arguments:

    DeviceNode - Supplies a pointer to the device node structure of the device.

Return Value:

    TRUE if disabled, otherwise FALSE

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject = DeviceNode->PhysicalDeviceObject;
    HANDLE handle, handlex;
    UNICODE_STRING unicodeName;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    ULONG buflen;
    BOOLEAN FirmwareDisabled = FALSE;

    PiLockPnpRegistry(FALSE);

    status = IopDeviceObjectToDeviceInstance(
                                    deviceObject,
                                    &handlex,
                                    KEY_ALL_ACCESS);
    if (NT_SUCCESS(status)) {

        //
        // Open the LogConfig key of the device instance.
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &handle,
                                         handlex,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        ZwClose(handlex);
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_FIRMWAREDISABLED);
            value = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
            buflen = sizeof(buffer);
            status = ZwQueryValueKey(handle,
                                     &unicodeName,
                                     KeyValuePartialInformation,
                                     value,
                                     sizeof(buffer),
                                     &buflen
                                     );

            ZwClose(handle);

            //
            // We don't need to check the buffer was big enough because it starts
            // off that way and doesn't get any smaller!
            //

            if (NT_SUCCESS(status)
                && value->Type == REG_DWORD
                && value->DataLength == sizeof(ULONG)
                && (*(PULONG)(value->Data))!=0) {

                //
                // firmware disabled
                //
                FirmwareDisabled = TRUE;
            }
        }
    }
    PiUnlockPnpRegistry();
    return FirmwareDisabled;
}


NTSTATUS
IopGetRootDevices (
    PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine scans through System\Enum\Root subtree to build a device node for
    each root device.

Arguments:

    DeviceRelations - supplies a variable to receive the returned DEVICE_RELATIONS structure.

Return Value:

    A NTSTATUS code.

--*/

{
    NTSTATUS status;
    HANDLE baseHandle;
    UNICODE_STRING workName, tmpName;
    PVOID buffer;
    ROOT_ENUMERATOR_CONTEXT context;
    ULONG i;
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();

    *DeviceRelations = NULL;
    buffer = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate a buffer to store the PDOs enumerated.
    // Note, the the buffer turns out to be not big enough, it will be reallocated dynamically.
    //

    context.DeviceList = (PDEVICE_OBJECT *) ExAllocatePool(PagedPool, PNP_SCRATCH_BUFFER_SIZE * 2);
    if (context.DeviceList) {
        context.MaxDeviceCount = (PNP_SCRATCH_BUFFER_SIZE * 2) / sizeof(PDEVICE_OBJECT);
        context.DeviceCount = 0;
    } else {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PiLockPnpRegistry(TRUE);

    //
    // Open System\CurrentControlSet\Enum\Root key and call worker routine to recursively
    // scan through the subkeys.
    //

    status = IopCreateRegistryKeyEx( &baseHandle,
                                     NULL,
                                     &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                     KEY_READ,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {

        workName.Buffer = (PWSTR)buffer;
        RtlFillMemory(buffer, PNP_LARGE_SCRATCH_BUFFER_SIZE, 0);
        workName.MaximumLength = PNP_LARGE_SCRATCH_BUFFER_SIZE;
        workName.Length = 0;

        //
        // only look at ROOT key
        //

        PiWstrToUnicodeString(&tmpName, REGSTR_KEY_ROOTENUM);
        RtlAppendStringToString((PSTRING)&workName, (PSTRING)&tmpName);

        //
        // Enumerate all subkeys under the System\CCS\Enum\Root.
        //

        context.Status = STATUS_SUCCESS;
        context.KeyName = &workName;

        status = PipApplyFunctionToSubKeys(baseHandle,
                                           NULL,
                                           KEY_ALL_ACCESS,
                                           FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                           IopInitializeDeviceKey,
                                           &context
                                           );
        ZwClose(baseHandle);

        //
        // Build returned information from ROOT_ENUMERATOR_CONTEXT.
        //


        status = context.Status;
        if (NT_SUCCESS(status) && context.DeviceCount != 0) {
            deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                PagedPool,
                sizeof (DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT) * context.DeviceCount
                );
            if (deviceRelations == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                deviceRelations->Count = context.DeviceCount;
                RtlCopyMemory(deviceRelations->Objects,
                              context.DeviceList,
                              sizeof (PDEVICE_OBJECT) * context.DeviceCount);
                *DeviceRelations = deviceRelations;
            }
        } else if (context.DeviceCount == 0) {

            status = STATUS_UNSUCCESSFUL;
        }
        if (!NT_SUCCESS(status)) {

            //
            // If somehow the enumeration failed, we need to derefernece all the
            // device objects.
            //

            for (i = 0; i < context.DeviceCount; i++) {
                ObDereferenceObject(context.DeviceList[i]);
            }
        }
    }
    PiUnlockPnpRegistry();
    ExFreePool(buffer);
    ExFreePool(context.DeviceList);
    return status;
}

BOOLEAN
IopInitializeDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\CCS\Enum\BusKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    USHORT length;
    PWSTR p;
    PUNICODE_STRING unicodeName = ((PROOT_ENUMERATOR_CONTEXT)Context)->KeyName;
    NTSTATUS status;

    length = unicodeName->Length;

    p = unicodeName->Buffer;
    if ( unicodeName->Length / sizeof(WCHAR) != 0) {
        p += unicodeName->Length / sizeof(WCHAR);
        *p = OBJ_NAME_PATH_SEPARATOR;
        unicodeName->Length += sizeof (WCHAR);
    }

    RtlAppendStringToString((PSTRING)unicodeName, (PSTRING)KeyName);

    //
    // Enumerate all subkeys under the current device key.
    //

    status = PipApplyFunctionToSubKeys(
        KeyHandle,
        NULL,
        KEY_ALL_ACCESS,
        FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
        IopInitializeDeviceInstanceKey,
        Context
        );
    unicodeName->Length = length;

    if (!NT_SUCCESS(status)) {

        ((PROOT_ENUMERATOR_CONTEXT)Context)->Status = status;
    }

    return (BOOLEAN)NT_SUCCESS(((PROOT_ENUMERATOR_CONTEXT)Context)->Status);
}

BOOLEAN
IopInitializeDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\Enum\Root\DeviceKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    UNICODE_STRING unicodeName, serviceName;
    PKEY_VALUE_FULL_INFORMATION serviceKeyValueInfo;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    NTSTATUS status;
    BOOLEAN isDuplicate = FALSE;
    BOOLEAN configuredBySetup;
    ULONG deviceFlags, tmpValue1;
    ULONG legacy;
    USHORT savedLength;
    PUNICODE_STRING pUnicode;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode = NULL;
    PROOT_ENUMERATOR_CONTEXT enumContext = (PROOT_ENUMERATOR_CONTEXT)Context;

    PAGED_CODE();

    //
    // First off, check to see if this is a phantom device instance (i.e.,
    // registry key only).  If so, we want to totally ignore this key and
    // move on to the next one.
    //
    status = IopGetRegistryValue(KeyHandle,
                                 REGSTR_VAL_PHANTOM,
                                 &keyValueInformation);

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {
            tmpValue1 = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        } else {
            tmpValue1 = 0;
        }

        ExFreePool(keyValueInformation);

        if (tmpValue1) {
            return TRUE;
        }
    }

    //
    // Since it is highly likely we are going to report another PDO make sure
    // there will be room in the buffer.
    //

    if (enumContext->DeviceCount == enumContext->MaxDeviceCount) {

        PDEVICE_OBJECT *tmpDeviceObjectList;
        ULONG tmpDeviceObjectListSize;

        //
        // We need to grow our PDO list buffer.
        //

        tmpDeviceObjectListSize = (enumContext->MaxDeviceCount * sizeof(PDEVICE_OBJECT))
                                        + (PNP_SCRATCH_BUFFER_SIZE * 2);

        tmpDeviceObjectList = ExAllocatePool(PagedPool, tmpDeviceObjectListSize);

        if (tmpDeviceObjectList) {

            RtlCopyMemory( tmpDeviceObjectList,
                           enumContext->DeviceList,
                           enumContext->DeviceCount * sizeof(PDEVICE_OBJECT)
                           );
            ExFreePool(enumContext->DeviceList);
            enumContext->DeviceList = tmpDeviceObjectList;
            enumContext->MaxDeviceCount = tmpDeviceObjectListSize / sizeof(PDEVICE_OBJECT);

        } else {

            //
            // We are out of memory.  There is no point going any further
            // since we don't have any place to report the PDOs anyways.
            //

            enumContext->Status = STATUS_INSUFFICIENT_RESOURCES;

            return FALSE;
        }
    }

    //
    // Combine Context->KeyName, i.e. the device name and KeyName (device instance name)
    // to form device instance path.
    //

    pUnicode = ((PROOT_ENUMERATOR_CONTEXT)Context)->KeyName;
    savedLength = pUnicode->Length;                  // Save WorkName
    if (pUnicode->Buffer[pUnicode->Length / sizeof(WCHAR) - 1] != OBJ_NAME_PATH_SEPARATOR) {
        pUnicode->Buffer[pUnicode->Length / sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
        pUnicode->Length += 2;
    }

    RtlAppendStringToString((PSTRING)pUnicode, (PSTRING)KeyName);

    //
    // Check if the PDO for the device instance key exists already.  If no,
    // see if we need to create it.
    //

    deviceObject = IopDeviceObjectFromDeviceInstance(pUnicode);

    if (deviceObject != NULL) {

        enumContext->DeviceList[enumContext->DeviceCount] = deviceObject;
        enumContext->DeviceCount++;
        pUnicode->Length = savedLength;         // Restore WorkName
        return TRUE;
    }

    //
    // We don't have device object for it.
    // First check if this key was created by firmware mapper.  If yes, make sure
    // the device is still present.
    //

    if (!PipIsFirmwareMapperDevicePresent(KeyHandle)) {
        pUnicode->Length = savedLength;         // Restore WorkName
        return TRUE;
    }

    //
    // Get the "DuplicateOf" value entry to determine if the device instance
    // should be registered.  If the device instance is duplicate, We don't
    // add it to its service key's enum branch.
    //

    status = IopGetRegistryValue( KeyHandle,
                                  REGSTR_VALUE_DUPLICATEOF,
                                  &keyValueInformation
                                  );
    if (NT_SUCCESS(status)) {
        if (keyValueInformation->Type == REG_SZ &&
            keyValueInformation->DataLength > 0) {
            isDuplicate = TRUE;
        }

        ExFreePool(keyValueInformation);
    }

    //
    // Get the "Service=" value entry from KeyHandle
    //

    serviceKeyValueInfo = NULL;

    PiWstrToUnicodeString(&serviceName, NULL);

    status = IopGetRegistryValue ( KeyHandle,
                                   REGSTR_VALUE_SERVICE,
                                   &serviceKeyValueInfo
                                   );
    if (NT_SUCCESS(status)) {

        //
        // Append the new instance to its corresponding
        // Service\Name\Enum.
        //

        if (serviceKeyValueInfo->Type == REG_SZ &&
            serviceKeyValueInfo->DataLength != 0) {

            //
            // Set up ServiceKeyName unicode string
            //

            IopRegistryDataToUnicodeString(
                                &serviceName,
                                (PWSTR)KEY_VALUE_DATA(serviceKeyValueInfo),
                                serviceKeyValueInfo->DataLength
                                );
        }

        //
        // Do not Free serviceKeyValueInfo.  It contains Service Name.
        //

    }

    //
    // Register this device instance by constructing new value entry for
    // ServiceKeyName\Enum key.i.e., <Number> = <PathToSystemEnumBranch>
    // For the stuff under Root, we need to expose devnodes for everything
    // except those devices whose CsConfigFlags are set to CSCONFIGFLAG_DO_NOT_CREATE.
    //

    status = IopGetDeviceInstanceCsConfigFlags( pUnicode, &deviceFlags );

    if (NT_SUCCESS(status) && (deviceFlags & CSCONFIGFLAG_DO_NOT_CREATE)) {
        ExFreePool(serviceKeyValueInfo);
        pUnicode->Length = savedLength;         // Restore WorkName
        return TRUE;
    }

    //
    // Make sure this device instance is really a "device" by checking
    // the "Legacy" value name.
    //

    legacy = 0;
    status = IopGetRegistryValue( KeyHandle,
                                  REGSTR_VALUE_LEGACY,
                                  &keyValueInformation
                                  );
    if (NT_SUCCESS(status)) {

        //
        // If "Legacy=" exists ...
        //

        if (keyValueInformation->Type == REG_DWORD) {
            if (keyValueInformation->DataLength >= sizeof(ULONG)) {
                legacy = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
        }
        ExFreePool(keyValueInformation);
    }

    if (legacy) {
        BOOLEAN doCreate = FALSE;

        //
        // Check if the the service for the device instance is a kernel mode
        // driver (even though it is a legacy device instance.) If yes, we will
        // create a PDO for it.
        //

        if (serviceName.Length) {
            status = IopGetServiceType(&serviceName, &tmpValue1);
            if (NT_SUCCESS(status) && tmpValue1 == SERVICE_KERNEL_DRIVER) {
                doCreate = TRUE;
            }
        }

        if (!doCreate)  {

            //
            // We are not creating PDO for the device instance.  In this case we
            // need to register the device ourself for legacy compatibility.
            //
            // Note we will register this device to its driver even it is a
            // duplicate.  It will be deregistered when the real enumerated
            // device shows up.  We need to do this because the driver which
            // controls the device may be a boot driver.
            //

            PpDeviceRegistration( pUnicode, TRUE, NULL );

            //
            // We did not create a PDO.  Release the service and ordinal names.
            //

            if (serviceKeyValueInfo) {
                ExFreePool(serviceKeyValueInfo);
            }

            pUnicode->Length = savedLength;         // Restore WorkName

            return TRUE;
        }
    }

    if (serviceKeyValueInfo) {
        ExFreePool(serviceKeyValueInfo);
    }

    //
    // Create madeup PDO and device node to represent the root device.
    //

    //
    // Madeup a name for the device object.
    //

    //
    // Create madeup PDO and device node to represent the root device.
    //

    status = IoCreateDevice( IoPnpDriverObject,
                             sizeof(IOPNP_DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_CONTROLLER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &deviceObject );

    if (NT_SUCCESS(status)) {

        deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;
        deviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;

        status = PipAllocateDeviceNode(deviceObject, &deviceNode);
        if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

            //
            // Make a copy of the device instance path and save it in
            // device node.
            //
            status = PipConcatenateUnicodeStrings(  &deviceNode->InstancePath,
                                                    pUnicode,
                                                    NULL);
            if (NT_SUCCESS(status)) {

                PCM_RESOURCE_LIST cmResource;

                deviceNode->Flags = DNF_MADEUP | DNF_ENUMERATED;

                PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                PpDevNodeInsertIntoTree(IopRootDeviceNode, deviceNode);

                if (legacy) {

                    deviceNode->Flags |= DNF_LEGACY_DRIVER | DNF_NO_RESOURCE_REQUIRED;

                    PipSetDevNodeState( deviceNode, DeviceNodeStarted, NULL );

                } else {

                    //
                    // The device instance key exists.  We need to propagate the ConfigFlag
                    // to problem and StatusFlags
                    //

                    deviceFlags = 0;
                    status = IopGetRegistryValue(KeyHandle,
                                                    REGSTR_VALUE_CONFIG_FLAGS,
                                                    &keyValueInformation);
                    if (NT_SUCCESS(status)) {
                        if ((keyValueInformation->Type == REG_DWORD) &&
                            (keyValueInformation->DataLength >= sizeof(ULONG))) {
                            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                        }
                        ExFreePool(keyValueInformation);
                        if (deviceFlags & CONFIGFLAG_REINSTALL) {
                            PipSetDevNodeProblem(deviceNode, CM_PROB_REINSTALL);
                        } else if (deviceFlags & CONFIGFLAG_PARTIAL_LOG_CONF) {
                            PipSetDevNodeProblem(deviceNode, CM_PROB_PARTIAL_LOG_CONF);
                        } else if (deviceFlags & CONFIGFLAG_FAILEDINSTALL) {
                            PipSetDevNodeProblem(deviceNode, CM_PROB_FAILED_INSTALL);
                        }

                    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {
                        PipSetDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED);
                    }
                }

                if (isDuplicate) {
                    deviceNode->Flags |= DNF_DUPLICATE;
                }

                //
                // If the key say don't assign any resource, honor it...
                //

                PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_NO_RESOURCE_AT_INIT);
                status = IopGetRegistryValue( KeyHandle,
                                              unicodeName.Buffer,
                                              &keyValueInformation
                                              );

                if (NT_SUCCESS(status)) {
                    if (keyValueInformation->Type == REG_DWORD) {
                        if (keyValueInformation->DataLength >= sizeof(ULONG)) {
                            tmpValue1 = *(PULONG)KEY_VALUE_DATA(keyValueInformation);

                            if (tmpValue1 != 0) {
                                deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED;
                            }
                        }
                    }
                    ExFreePool(keyValueInformation);
                }

                //
                // we need to set initial capabilities, like any other device
                // this will also handle hardware-disabled case
                //
                IopQueryAndSaveDeviceNodeCapabilities(deviceNode);

                if (IopDeviceNodeFlagsToCapabilities(deviceNode)->HardwareDisabled &&
                    !PipIsDevNodeProblem(deviceNode,CM_PROB_NOT_CONFIGURED)) {
                    //
                    // mark the node as hardware disabled, if no other problems
                    //

                    PipClearDevNodeProblem(deviceNode);
                    PipSetDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED);
                    //
                    // Issue a PNP REMOVE_DEVICE Irp so when we query resources
                    // we have those required after boot
                    //
                    //status = IopRemoveDevice (deviceNode->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);
                    //ASSERT(NT_SUCCESS(status));
                }

                //
                // Install service for critical devices.
                // however don't do it if we found HardwareDisabled to be set
                //
                if (PipDoesDevNodeHaveProblem(deviceNode) &&
                    !IopDeviceNodeFlagsToCapabilities(deviceNode)->HardwareDisabled) {
                    PpCriticalProcessCriticalDevice(deviceNode);
                }

                //
                // Set DNF_DISABLED flag if the device instance is disabled.
                //

                ASSERT(!PipDoesDevNodeHaveProblem(deviceNode) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_REINSTALL) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_FAILED_INSTALL) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED) ||
                        PipIsDevNodeProblem(deviceNode, CM_PROB_PARTIAL_LOG_CONF));

                if (!PipIsDevNodeProblem(deviceNode, CM_PROB_DISABLED) &&
                    !PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED) &&
                    !IopIsDeviceInstanceEnabled(KeyHandle, &deviceNode->InstancePath, TRUE)) {

                    //
                    // Normally IopIsDeviceInstanceEnabled would set
                    // CM_PROB_DISABLED as a side effect (if necessary).  But it
                    // relies on the DeviceReference already being in the registry.
                    // We don't write it out till later so just set the problem
                    // now.

                    PipClearDevNodeProblem( deviceNode );
                    PipSetDevNodeProblem( deviceNode, CM_PROB_DISABLED );
                }

                status = IopNotifySetupDeviceArrival( deviceNode->PhysicalDeviceObject,
                                                      KeyHandle,
                                                      TRUE);

                configuredBySetup = (BOOLEAN)NT_SUCCESS(status);

                status = PpDeviceRegistration( &deviceNode->InstancePath,
                                               TRUE,
                                               &deviceNode->ServiceName
                                               );

                if (NT_SUCCESS(status) && configuredBySetup &&
                    PipIsDevNodeProblem(deviceNode, CM_PROB_NOT_CONFIGURED)) {

                    PipClearDevNodeProblem(deviceNode);
                }

                //
                // Add an entry into the table to set up a mapping between the DO
                // and the instance path.
                //

                status = IopMapDeviceObjectToDeviceInstance(deviceNode->PhysicalDeviceObject, &deviceNode->InstancePath);
                ASSERT(NT_SUCCESS(status));

                //
                // Add a reference for config magr
                //

                ObReferenceObject(deviceObject);

                //
                // Check if this device has BOOT config.  If yes, reserve them
                //

                cmResource = NULL;
                status = IopGetDeviceResourcesFromRegistry (
                                    deviceObject,
                                    QUERY_RESOURCE_LIST,
                                    REGISTRY_BOOT_CONFIG,
                                    &cmResource,
                                    &tmpValue1
                                    );

                if (NT_SUCCESS(status) && cmResource) {

                    //
                    // Still reserve boot config, even though the device is
                    // disabled.
                    //

                    status = (*IopAllocateBootResourcesRoutine)(
                                            ArbiterRequestPnpEnumerated,
                                            deviceNode->PhysicalDeviceObject,
                                            cmResource);
                    if (NT_SUCCESS(status)) {
                        deviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
                    }
                    ExFreePool(cmResource);
                }

                status = STATUS_SUCCESS;

                //
                // Add a reference for query device relations
                //

                ObReferenceObject(deviceObject);
            } else {
                IoDeleteDevice(deviceObject);
                deviceObject = NULL;
            }
        } else {

            IoDeleteDevice(deviceObject);
            deviceObject = NULL;
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    pUnicode->Length = savedLength;                  // Restore WorkName

    //
    // If we enumerated a root device, add it to the device list
    //

    if (NT_SUCCESS(status)) {
        ASSERT(deviceObject != NULL);

        enumContext->DeviceList[enumContext->DeviceCount] = deviceObject;
        enumContext->DeviceCount++;

        return TRUE;
    } else {
        enumContext->Status = status;
        return FALSE;
    }
}

NTSTATUS
IopGetServiceType(
    IN PUNICODE_STRING KeyName,
    IN PULONG ServiceType
    )

/*++

Routine Description:

    This routine returns the controlling service's service type of the specified
    Device instance.

Arguments:

    KeyName - supplies a unicode string to specify the device instance.

    ServiceType - supplies a pointer to a variable to receive the service type.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;


    PAGED_CODE();

    *ServiceType = ~0ul;
    status = PipOpenServiceEnumKeys (
                             KeyName,
                             KEY_READ,
                             &handle,
                             NULL,
                             FALSE
                             );
    if (NT_SUCCESS(status)) {
        status = IopGetRegistryValue(handle, L"Type", &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if (keyValueInformation->Type == REG_DWORD) {
                if (keyValueInformation->DataLength >= sizeof(ULONG)) {
                    *ServiceType = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                }
            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

BOOLEAN
PipIsFirmwareMapperDevicePresent (
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This routine checks if the registry key is created by FirmwareMapper.
    If Yes, it further checks if the device for the key is present in this
    boot.

Parameters:

    KeyHandle - Specifies a handle to the registry key to be checked.

Return Value:

    A BOOLEAN vaStatus code that indicates whether or not the function was successful.

--*/
{
    NTSTATUS status;
    HANDLE handle;
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG tmp = 0;

    PAGED_CODE();

    //
    // First check to see if this device instance key is a firmware-created one
    //

    status = IopGetRegistryValue (KeyHandle,
                                  REGSTR_VAL_FIRMWAREIDENTIFIED,
                                  &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength == sizeof(ULONG))) {

            tmp = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (tmp == 0) {
        return TRUE;
    }

    //
    // Make sure the device is present.
    //

    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &handle,
                                   KeyHandle,
                                   &unicodeName,
                                   KEY_READ
                                   );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = IopGetRegistryValue (handle,
                                  REGSTR_VAL_FIRMWAREMEMBER,
                                  &keyValueInformation);
    ZwClose(handle);
    tmp = 0;

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength == sizeof(ULONG))) {

            tmp = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (!tmp) {
        return FALSE;
    } else {
        return TRUE;
    }
}


NTSTATUS
IopSystemControlDispatch(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )
{
    NTSTATUS status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (DeviceObject);

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpdma.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pnpdma.c

Abstract:

    Root DMA arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Constants
//


#define MAX_ULONGLONG           ((ULONGLONG) -1)

//
// Prototypes
//

NTSTATUS
IopDmaInitialize(
    VOID
    );

NTSTATUS
IopDmaUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopDmaPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopDmaScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopDmaUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );


BOOLEAN
IopDmaOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopDmaInitialize)
#pragma alloc_text(PAGE, IopDmaUnpackRequirement)
#pragma alloc_text(PAGE, IopDmaPackResource)
#pragma alloc_text(PAGE, IopDmaScoreRequirement)
#pragma alloc_text(PAGE, IopDmaUnpackResource)
#pragma alloc_text(PAGE, IopDmaOverrideConflict)
#endif // ALLOC_PRAGMA

//
// Implementation
//

NTSTATUS
IopDmaInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{

    IopRootDmaArbiter.UnpackRequirement = IopDmaUnpackRequirement;
    IopRootDmaArbiter.PackResource = IopDmaPackResource;
    IopRootDmaArbiter.UnpackResource = IopDmaUnpackResource;
    IopRootDmaArbiter.ScoreRequirement = IopDmaScoreRequirement;
    IopRootDmaArbiter.OverrideConflict = IopDmaOverrideConflict;

    return ArbInitializeArbiterInstance(&IopRootDmaArbiter,
                                        NULL,
                                        CmResourceTypeDma,
                                        L"RootDMA",
                                        L"Root",
                                        NULL    // no translation of DMA
                                       );
}

//
// Arbiter callbacks
//

NTSTATUS
IopDmaUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeDma);

    ARB_PRINT(2,
                ("Unpacking DMA requirement %p => 0x%I64x-0x%I64x\n",
                Descriptor,
                (ULONGLONG) Descriptor->u.Dma.MinimumChannel,
                (ULONGLONG) Descriptor->u.Dma.MaximumChannel
                ));

    *Minimum = (ULONGLONG) Descriptor->u.Dma.MinimumChannel;
    *Maximum = (ULONGLONG) Descriptor->u.Dma.MaximumChannel;
    *Length = 1;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
IopDmaScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeDma);

    score = Descriptor->u.Dma.MaximumChannel - Descriptor->u.Dma.MinimumChannel;

    ARB_PRINT(2,
                ("Scoring DMA resource %p => %i\n",
                Descriptor,
                score
                ));

    return score;
}

NTSTATUS
IopDmaPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeDma);

    ARB_PRINT(2,
                ("Packing DMA resource %p => 0x%I64x\n",
                Descriptor,
                Start
                ));

    Descriptor->Type = CmResourceTypeDma;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->u.Dma.Channel = (ULONG) Start;
    Descriptor->u.Dma.Port = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
IopDmaUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    Length - Pointer to where the length value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{

    *Start = Descriptor->u.Dma.Channel;
    *Length = 1;

    ARB_PRINT(2,
                ("Unpacking DMA resource %p => 0x%I64x\n",
                Descriptor,
                *Start
                ));

    return STATUS_SUCCESS;

}


BOOLEAN
IopDmaOverrideConflict(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    Just say no.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the conflict is allowable, false otherwise

--*/

{
    UNREFERENCED_PARAMETER( Arbiter );
    UNREFERENCED_PARAMETER( State );

    PAGED_CODE();

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpeisa.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PnpEisa.c

Abstract:

    This file implements Eisa related code.

Author:

    Shie-Lin Tzong (shielint)

Environment:

    Kernel Mode.

Notes:

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'iepP')
#endif

#define EISA_DEVICE_NODE_NAME L"EisaResources"
#define BUFFER_LENGTH 50

NTSTATUS
EisaGetEisaDevicesResources (
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceLength
    );

NTSTATUS
EisaBuildSlotsResources (
    IN ULONG SlotMasks,
    IN ULONG NumberMasks,
    OUT PCM_RESOURCE_LIST *Resource,
    OUT ULONG *Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, EisaBuildEisaDeviceNode)
#pragma alloc_text(INIT, EisaGetEisaDevicesResources)
#pragma alloc_text(INIT, EisaBuildSlotsResources)
#endif

NTSTATUS
EisaBuildEisaDeviceNode (
    VOID
    )

/*++

Routine Description:

    This routine build an registry key to report eisa resources to arbiters.

Arguments:

    None.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS            status;
    ULONG               disposition, tmpValue;
    WCHAR               buffer[BUFFER_LENGTH];

    UNICODE_STRING      unicodeString;
    HANDLE              rootHandle, deviceHandle, instanceHandle, logConfHandle;

    PCM_RESOURCE_LIST   resourceList;
    ULONG               resourceLength;

    status = EisaGetEisaDevicesResources(&resourceList, &resourceLength);
    if (!NT_SUCCESS(status) || resourceList == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    PiWstrToUnicodeString(&unicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root");
    status = IopOpenRegistryKeyEx( &rootHandle,
                                   NULL,
                                   &unicodeString,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        if (resourceList) {
            ExFreePool (resourceList);
        }
        return status;
    }

    PiWstrToUnicodeString(&unicodeString, EISA_DEVICE_NODE_NAME);
    status = IopCreateRegistryKeyEx( &deviceHandle,
                                     rootHandle,
                                     &unicodeString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    ZwClose(rootHandle);
    if (!NT_SUCCESS(status)) {
        if (resourceList) {
            ExFreePool (resourceList);
        }
        return status;
    }

    PiWstrToUnicodeString( &unicodeString, L"0000" );
    status = IopCreateRegistryKeyEx( &instanceHandle,
                                     deviceHandle,
                                     &unicodeString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     &disposition );
    ZwClose(deviceHandle);
    if (NT_SUCCESS(status))  {

        //
        // If the key already exists because it was explicitly migrated
        // during textmode setup, we should still consider it a "new key".
        //
        if (disposition != REG_CREATED_NEW_KEY) {
            PKEY_VALUE_FULL_INFORMATION keyValueInformation;

            status = IopGetRegistryValue(instanceHandle,
                                         REGSTR_VALUE_MIGRATED,
                                         &keyValueInformation);
            if (NT_SUCCESS(status)) {

                if ((keyValueInformation->Type == REG_DWORD) &&
                    (keyValueInformation->DataLength == sizeof(ULONG)) &&
                    ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                    disposition = REG_CREATED_NEW_KEY;
                }

                ExFreePool(keyValueInformation);

                PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                ZwDeleteValueKey(instanceHandle, &unicodeString);
            }
        }

        if (disposition == REG_CREATED_NEW_KEY) {

            PiWstrToUnicodeString( &unicodeString, L"DeviceDesc" );
            wcsncpy(buffer, L"Device to report Eisa Slot Resources", sizeof(buffer) / sizeof(WCHAR));
            buffer[(sizeof(buffer) / sizeof(WCHAR)) - 1] = UNICODE_NULL;

            ZwSetValueKey(instanceHandle,
                          &unicodeString,
                          0,
                          REG_SZ,
                          buffer,
                          (ULONG)((wcslen(buffer) + 1) * sizeof(WCHAR))
                          );

            PiWstrToUnicodeString( &unicodeString, L"HardwareID" );
            RtlZeroMemory(buffer, BUFFER_LENGTH * sizeof(WCHAR));
            wcsncpy(buffer, L"*Eisa_Resource_Device", sizeof(buffer) / sizeof(WCHAR));
            buffer[(sizeof(buffer) / sizeof(WCHAR)) - 1] = UNICODE_NULL;

            ZwSetValueKey(instanceHandle,
                          &unicodeString,
                          0,
                          REG_MULTI_SZ,
                          buffer,
                          (ULONG)((wcslen(buffer) + 2) * sizeof(WCHAR))
                          );

            PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_CONFIG_FLAGS);
            tmpValue = 0;
            ZwSetValueKey(instanceHandle,
                         &unicodeString,
                         TITLE_INDEX_VALUE,
                         REG_DWORD,
                         &tmpValue,
                         sizeof(tmpValue)
                         );

        }

        PiWstrToUnicodeString( &unicodeString, REGSTR_KEY_LOGCONF );
        status = IopCreateRegistryKeyEx( &logConfHandle,
                                         instanceHandle,
                                         &unicodeString,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        ZwClose(instanceHandle);
        if (NT_SUCCESS(status))  {
            PiWstrToUnicodeString( &unicodeString, REGSTR_VAL_BOOTCONFIG );

            status = ZwSetValueKey(logConfHandle,
                                   &unicodeString,
                                   0,
                                   REG_RESOURCE_LIST,
                                   resourceList,
                                   resourceLength
                                   );
            ZwClose(logConfHandle);
        }
    }
    if (resourceList) {
        ExFreePool (resourceList);
    }
    return status;
}

NTSTATUS
EisaGetEisaDevicesResources (
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceLength
    )

/*++

Routine Description:

    This routine builds a cm resource list for all the eisa slots.

Arguments:

    None.

Return Value:

    A CmResourceList.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeString;
    ULONG slotMasks = 0, numberMasks = 0, i;

    *ResourceList = NULL;
    *ResourceLength = 0;

    //
    // Open LocalMachine\Hardware\Description
    //

    //PiWstrToUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\EisaAdapter\\0");
    PiWstrToUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\EisaAdapter");
    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &unicodeString,
                                   KEY_READ
                                   );
    if (NT_SUCCESS(status)) {
        status = IopGetRegistryValue(handle,
                                     L"Configuration Data",
                                     &keyValueInformation
                                     );
        if (NT_SUCCESS(status)) {
            PCM_FULL_RESOURCE_DESCRIPTOR resourceDescriptor;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDescriptor;

            resourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
                ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);

            if ((keyValueInformation->DataLength >= sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) &&
                (resourceDescriptor->PartialResourceList.Count > 0) ) {
                LONG eisaInfoLength;
                PCM_EISA_SLOT_INFORMATION eisaInfo;

                partialResourceDescriptor = resourceDescriptor->PartialResourceList.PartialDescriptors;
                if (partialResourceDescriptor->Type == CmResourceTypeDeviceSpecific) {
                    eisaInfo = (PCM_EISA_SLOT_INFORMATION)
                        ((PUCHAR)partialResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
                    eisaInfoLength = (LONG)partialResourceDescriptor->u.DeviceSpecificData.DataSize;

                    //
                    // Parse the eisa slot info to find the eisa slots with device installed.
                    //

                    for (i = 0; i < 0x10 && eisaInfoLength > 0; i++) {
                        if (eisaInfo->ReturnCode == EISA_INVALID_SLOT) {
                            break;
                        }
                        if (eisaInfo->ReturnCode != EISA_EMPTY_SLOT && (i != 0)) {
                            slotMasks |= (1 << i);
                            numberMasks++;
                        }
                        if (eisaInfo->ReturnCode == EISA_EMPTY_SLOT) {
                            eisaInfoLength -= sizeof(CM_EISA_SLOT_INFORMATION);
                            eisaInfo++;
                        } else {
                            eisaInfoLength -= sizeof(CM_EISA_SLOT_INFORMATION) + eisaInfo->NumberFunctions * sizeof(CM_EISA_FUNCTION_INFORMATION);
                            eisaInfo = (PCM_EISA_SLOT_INFORMATION)
                                       ((PUCHAR)eisaInfo + eisaInfo->NumberFunctions * sizeof(CM_EISA_FUNCTION_INFORMATION) +
                                           sizeof(CM_EISA_SLOT_INFORMATION));
                        }
                    }

                    if (slotMasks) {
                        status = EisaBuildSlotsResources(slotMasks, numberMasks, ResourceList, ResourceLength);
                    }
                }

            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

NTSTATUS
EisaBuildSlotsResources (
    IN ULONG SlotMasks,
    IN ULONG NumberMasks,
    OUT PCM_RESOURCE_LIST *Resources,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine build a cm resource list for all the io resources used
    by the eisa devices.

Arguments:

    SlotMask - a mask to indicate the valid eisa slot.

Return Value:

    A pointer to a CM_RESOURCE_LIST.

--*/

{
    PCM_RESOURCE_LIST resources = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDesc;
    ULONG slot;

    *Length = sizeof(CM_RESOURCE_LIST) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (NumberMasks - 1);
    resources = ExAllocatePool(PagedPool, *Length);
    if (resources) {
        resources->Count = 1;
        resources->List[0].InterfaceType = Eisa;
        resources->List[0].BusNumber = 0;
        resources->List[0].PartialResourceList.Version = 0;
        resources->List[0].PartialResourceList.Revision = 0;
        resources->List[0].PartialResourceList.Count = NumberMasks;
        partialDesc = resources->List[0].PartialResourceList.PartialDescriptors;
        slot = 0; // ignore slot 0
        while (SlotMasks) {
            SlotMasks >>= 1;
            slot++;
            if (SlotMasks & 1) {
                partialDesc->Type = CmResourceTypePort;
                partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                partialDesc->Flags = CM_RESOURCE_PORT_16_BIT_DECODE + CM_RESOURCE_PORT_IO;
                partialDesc->u.Port.Start.LowPart = slot << 12;
                partialDesc->u.Port.Start.HighPart = 0;
                partialDesc->u.Port.Length = 0x1000;
                partialDesc++;
            }
        }
        *Resources = resources;
        return STATUS_SUCCESS;
    } else {
        return STATUS_NO_MEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the kernel-mode Plug and Play manager.

Author:

    Lonny McMichael (lonnym) 02/08/1995


Revision History:


--*/

#ifndef _KERNEL_PNPI_
#define _KERNEL_PNPI_

#include <wdmguid.h>
#include "regstrp.h"

#define MIN_CONFLICT_LIST_SIZE  (sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST) - sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY) + sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS))

typedef struct _DEVICE_NODE DEVICE_NODE, *PDEVICE_NODE;
//
// Extract DeviceNode from DeviceObject.
//
#define PP_DO_TO_DN(DO)                \
    ((PDEVICE_NODE)((DO)? (DO)->DeviceObjectExtension->DeviceNode : NULL))
//
// Macros to save useful information into memory dumps.
//

#define PP_SAVE_DEVNODE_TO_TRIAGE_DUMP(dn) {                                                                        \
    if((dn)) {                                                                                                      \
        IoAddTriageDumpDataBlock(dn, sizeof(DEVICE_NODE));                                                          \
        if ((dn)->InstancePath.Length != 0) {                                                                       \
            IoAddTriageDumpDataBlock(&(dn)->InstancePath.Length, sizeof((dn)->InstancePath.Length));                \
            IoAddTriageDumpDataBlock((dn)->InstancePath.Buffer, (dn)->InstancePath.Length);                         \
        }                                                                                                           \
        if ((dn)->ServiceName.Length != 0) {                                                                        \
            IoAddTriageDumpDataBlock(&(dn)->ServiceName.Length, sizeof((dn)->ServiceName.Length));                  \
            IoAddTriageDumpDataBlock((dn)->ServiceName.Buffer, (dn)->ServiceName.Length);                           \
        }                                                                                                           \
        if ((dn)->Parent && (dn)->Parent->ServiceName.Length != 0) {                                                \
            IoAddTriageDumpDataBlock(&(dn)->Parent->ServiceName.Length, sizeof((dn)->Parent->ServiceName.Length));  \
            IoAddTriageDumpDataBlock((dn)->Parent->ServiceName.Buffer, (dn)->Parent->ServiceName.Length);           \
        }                                                                                                           \
    }                                                                                                               \
}

#define PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(drvo) {                                                                 \
    if(drvo) {                                                                                                      \
        IoAddTriageDumpDataBlock(drvo, (drvo)->Size);                                                               \
        if((drvo)->DriverName.Length != 0) {                                                                        \
            IoAddTriageDumpDataBlock(&(drvo)->DriverName.Length, sizeof((drvo)->DriverName.Length));                \
            IoAddTriageDumpDataBlock((drvo)->DriverName.Buffer, (drvo)->DriverName.Length);                         \
        }                                                                                                           \
    }                                                                                                               \
}

#define PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(do) {                                                                   \
    if((do)) {                                                                                                      \
        IoAddTriageDumpDataBlock(do, (do)->Size);                                                                   \
        PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP((do)->DriverObject);                                                    \
        PP_SAVE_DEVNODE_TO_TRIAGE_DUMP(PP_DO_TO_DN(do));                                                            \
    }                                                                                                               \
}    

#define GUID_STRING_LEN         39
#define MAX_DEVICE_ID_LEN       200     // size in chars
#define MAX_SERVICE_NAME_LEN    256     // in characters
//
// PNP_EVENT_LIST
//
//  This is the head of the master device event list for both user-mode and
//  kernel-mode.
//

typedef struct _PNP_DEVICE_EVENT_LIST {
    NTSTATUS    Status;
    KMUTEX      EventQueueMutex;
    KGUARDED_MUTEX Lock;
    LIST_ENTRY  List;
} PNP_DEVICE_EVENT_LIST, *PPNP_DEVICE_EVENT_LIST;

//
// PNP_DEVICE_EVENT_ENTRY
//
// One of these structures is allocated for each dynamic device event and
// is removed after the event has been posted to all waiting recipients.
// The notify block contains a pointer to this list.
//

typedef struct _PNP_DEVICE_EVENT_ENTRY {
    LIST_ENTRY                          ListEntry;
    ULONG                               Argument;
    PKEVENT                             CallerEvent;
    PDEVICE_CHANGE_COMPLETE_CALLBACK    Callback;
    PVOID                               Context;
    PPNP_VETO_TYPE                      VetoType;
    PUNICODE_STRING                     VetoName;
    PLUGPLAY_EVENT_BLOCK                Data;
} PNP_DEVICE_EVENT_ENTRY, *PPNP_DEVICE_EVENT_ENTRY;

//
// Defines the enum type to distinguish between REMOVE device
// and EJECT device.
//

typedef enum _PLUGPLAY_DEVICE_DELETE_TYPE {
    QueryRemoveDevice,
    CancelRemoveDevice,
    RemoveDevice,
    SurpriseRemoveDevice,
    EjectDevice,
    RemoveFailedDevice,
    RemoveUnstartedFailedDevice,
    MaxDeviceDeleteType
} PLUGPLAY_DEVICE_DELETE_TYPE, *PPLUGPLAY_DEVICE_DELETE_TYPE;


//++
//
// VOID
// PiWstrToUnicodeString(
//     OUT PUNICODE_STRING u,
//     IN  PCWSTR p
//     )
//
//--
#define PiWstrToUnicodeString(u, p) {                                       \
    if (p) {                                                                \
        (u)->Length = ((u)->MaximumLength = sizeof((p))) - sizeof(WCHAR);   \
    } else {                                                                \
        (u)->Length = (u)->MaximumLength = 0;                               \
    }                                                                       \
    (u)->Buffer = (p);                                                      \
}

//++
//
// VOID
// PiUlongToUnicodeString(
//     OUT    PUNICODE_STRING u,
//     IN OUT PWCHAR ub,
//     IN     ULONG ubl,
//     IN     ULONG i
//     )
//
//--
#define PiUlongToUnicodeString(u, ub, ubl, i)                                                                               \
    {                                                                                                                       \
        PWCHAR end;                                                                                                         \
        LONG len;                                                                                                           \
                                                                                                                            \
        StringCchPrintfExW((PWCHAR)(ub), (ubl) / sizeof(WCHAR), &end, NULL, 0, REGSTR_VALUE_STANDARD_ULONG_FORMAT, (i));    \
        len = (LONG)(end - (PWCHAR)(ub));                                                                                   \
        (u)->MaximumLength = (USHORT)(ubl);                                                                                 \
        (u)->Length = (len == -1) ? (USHORT)(ubl) : (USHORT)len * sizeof(WCHAR);                                            \
        (u)->Buffer = (PWSTR)(ub);                                                                                          \
    }

//++
//
// VOID
// PiUlongToInstanceKeyUnicodeString(
//     OUT    PUNICODE_STRING u,
//     IN OUT PWCHAR ub,
//     IN     ULONG ubl,
//     IN     ULONG i
//     )
//
//--
#define PiUlongToInstanceKeyUnicodeString(u, ub, ubl, i)                                                                \
    {                                                                                                                   \
        PWCHAR end;                                                                                                     \
        LONG len;                                                                                                       \
                                                                                                                        \
        StringCchPrintfExW((PWCHAR)(ub), (ubl) / sizeof(WCHAR), &end, NULL, 0, REGSTR_KEY_INSTANCE_KEY_FORMAT, (i));    \
        len = (LONG)(end - (PWCHAR)(ub));                                                                               \
        (u)->MaximumLength = (USHORT)(ubl);                                                                             \
        (u)->Length = (len == -1) ? (USHORT)(ubl) : (USHORT)len * sizeof(WCHAR);                                        \
        (u)->Buffer = (PWSTR)(ub);                                                                                      \
    }

//
// The following macros convert between a Count of Wide Characters (CWC) and a Count
// of Bytes (CB).
//
#define CWC_TO_CB(c)    ((c) * sizeof(WCHAR))
#define CB_TO_CWC(c)    ((c) / sizeof(WCHAR))

//
// Macro to determine the number of elements in a statically
// initialized array.
//
#define ELEMENT_COUNT(x) (sizeof(x)/sizeof((x)[0]))

//
// Enter critical section and acquire a lock on the registry.  Both these
// mechanisms are required to prevent deadlock in the case where an APC
// routine calls this routine after the registry resource has been claimed
// in this case it would wait blocking this thread so the registry would
// never be released -> deadlock.  Critical sectioning the registry manipulation
// portion solves this problem
//
#define PiLockPnpRegistry(Exclusive) {  \
    KeEnterCriticalRegion();            \
    if (Exclusive) {                    \
        ExAcquireResourceExclusiveLite(     \
            &PpRegistryDeviceResource,  \
            TRUE);                      \
    } else {                            \
        ExAcquireResourceSharedLite(        \
            &PpRegistryDeviceResource,  \
            TRUE);                      \
    }                                   \
}

//
// Unblock write access to Pnp portion of registry.
//
#define PiUnlockPnpRegistry() {                     \
    ExReleaseResourceLite(&PpRegistryDeviceResource);   \
    KeLeaveCriticalRegion();                        \
}

#define PiIsPnpRegistryLocked(Exclusive)    \
    ((Exclusive) ? ExIsResourceAcquiredExclusiveLite(&PpRegistryDeviceResource) : \
                    ((ExIsResourceAcquiredSharedLite(&PpRegistryDeviceResource) > 0) ? TRUE : FALSE))

//
// Function to complete an event asynchronously.
//
VOID
PpCompleteDeviceEvent(
    IN OUT PPNP_DEVICE_EVENT_ENTRY  DeviceEvent,
    IN     NTSTATUS                 FinalStatus
    );

//
// Global PnP Manager initialization data.
//

extern PVOID PiScratchBuffer;

//
// Private Entry Points
//
BOOLEAN
PiRegSzToString(
    IN  PWCHAR RegSzData,
    IN  ULONG  RegSzLength,
    OUT PULONG StringLength  OPTIONAL,
    OUT PWSTR  *CopiedString OPTIONAL
    );

VOID
PiUserResponse(
    IN ULONG            Response,
    IN PNP_VETO_TYPE    VetoType,
    IN LPWSTR           VetoName,
    IN ULONG            VetoNameLength
    );

NTSTATUS
PiDeviceRegistration(
    IN PUNICODE_STRING DeviceInstancePath,
    IN BOOLEAN Add,
    IN PUNICODE_STRING ServiceKeyName OPTIONAL
    );

BOOLEAN
PiCompareGuid(
    CONST GUID *Guid1,
    CONST GUID *Guid2
    );

NTSTATUS
PiGetDeviceRegistryProperty(
    IN      PDEVICE_OBJECT   DeviceObject,
    IN      ULONG            ValueType,
    IN      PWSTR            ValueName,
    IN      PWSTR            KeyName,
    OUT     PVOID            Buffer,
    IN OUT  PULONG           BufferLength
    );

VOID
PpInitializeDeviceReferenceTable(
    VOID
    );

PVOID
NTAPI
PiAllocateGenericTableEntry (
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

VOID
NTAPI
PiFreeGenericTableEntry (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

VOID
PpRemoveDeviceActionRequests(
    IN PDEVICE_OBJECT DeviceObject
    );

typedef struct _SYSTEM_HIVE_LIMITS {
    ULONG Low;
    ULONG High;
} SYSTEM_HIVE_LIMITS, *PSYSTEM_HIVE_LIMITS;

VOID
PpSystemHiveLimitCallback(
    PSYSTEM_HIVE_LIMITS HiveLimits,
    ULONG Level
    );

extern SYSTEM_HIVE_LIMITS PpSystemHiveLimits;
extern BOOLEAN PpSystemHiveTooLarge;

extern BOOLEAN PpCallerInitializesRequestTable;

VOID
PpLogEvent(
    IN PUNICODE_STRING InsertionString1,
    IN PUNICODE_STRING InsertionString2,
    IN NTSTATUS Status,
    IN PVOID DumpData,
    IN ULONG DumpDataSize
    );

NTSTATUS
PpIrpQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_TEXT_TYPE DeviceTextType,
    IN LCID POINTER_ALIGNMENT LocaleId,
    OUT PWCHAR *Description
   );

#define PpQueryDeviceDescription(dn, desc)          PpIrpQueryDeviceText((dn)->PhysicalDeviceObject, DeviceTextDescription, PsDefaultSystemLocaleId, desc)
#define PpQueryDeviceLocationInformation(dn, loc)   PpIrpQueryDeviceText((dn)->PhysicalDeviceObject, DeviceTextLocationInformation, PsDefaultSystemLocaleId, loc)

NTSTATUS
PpIrpQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
PpIrpQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
   );

NTSTATUS
PpIrpQueryID(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID
    );

NTSTATUS
PpQueryID(
    IN PDEVICE_NODE DeviceNode,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID,
    OUT PULONG IDLength
    );

NTSTATUS
PpQueryDeviceID(
    IN PDEVICE_NODE DeviceNode,
    OUT PWCHAR *BusID,
    OUT PWCHAR *DeviceID
    );

#define PpQueryInstanceID(dn, id, l)    PpQueryID(dn, BusQueryInstanceID, id, l)
#define PpQueryHardwareIDs(dn, id, l)   PpQueryID(dn, BusQueryHardwareIDs, id, l)
#define PpQueryCompatibleIDs(dn, id, l) PpQueryID(dn, BusQueryCompatibleIDs, id, l)
#define PpQuerySerialNumber(dn, id)     PpIrpQueryID((dn)->PhysicalDeviceObject, BusQueryDeviceSerialNumber, id)

NTSTATUS
PpIrpQueryBusInformation(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PPNP_BUS_INFORMATION *BusInfo
    );

NTSTATUS
PpQueryBusInformation(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
PpSaveDeviceCapabilities (
    IN PDEVICE_NODE DeviceNode,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
PpBusTypeGuidInitialize(
    VOID
    );

USHORT
PpBusTypeGuidGetIndex(
    IN LPGUID BusTypeGuid
    );

NTSTATUS
PpBusTypeGuidGet(
    IN USHORT Index,
    IN OUT LPGUID BusTypeGuid
    );

extern BOOLEAN PpDisableFirmwareMapper;

#if defined(_X86_)

NTSTATUS
PnPBiosMapper(
    VOID
    );

NTSTATUS
PnPBiosGetBiosInfo(
    OUT PVOID *BiosInfo,
    OUT ULONG *BiosInfoLength
    );

VOID
PnPBiosShutdownSystem(
    IN ULONG Phase,
    IN OUT PVOID *Context
    );

NTSTATUS
PnPBiosInitializePnPBios(
    VOID
    );

#endif

//
// Firmware mapper external declarations.
//

BOOLEAN
PipIsFirmwareMapperDevicePresent(
    IN HANDLE KeyHandle
    );

VOID
MapperProcessFirmwareTree(
    IN BOOLEAN OnlyProcessSerialPorts
    );

VOID
MapperConstructRootEnumTree(
    IN BOOLEAN CreatePhantomDevices
    );

VOID
MapperFreeList(
    VOID
    );

VOID
MapperPhantomizeDetectedComPorts(
    VOID
    );

//
// True iff textmode setup.
//
extern BOOLEAN ExpInTextModeSetup;

VOID
PpMarkDeviceStackStartPending(
    IN PDEVICE_OBJECT   DeviceObject,
    IN BOOLEAN          Set
    );

NTSTATUS
PiControlMakeUserModeCallersCopy(
    PVOID           *Destination,
    PVOID           Src,
    ULONG           Length,
    ULONG           Alignment,
    KPROCESSOR_MODE CallerMode,
    BOOLEAN         AllocateDestination
    );

#if DBG

LONG
PiControlExceptionFilter(
    IN  PEXCEPTION_POINTERS ExceptionPointers
    );

#else

#define PiControlExceptionFilter(a)  EXCEPTION_EXECUTE_HANDLER

#endif


#endif // _KERNEL_PNPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\io\pnpmgr\pnpenum.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpenum.c

Abstract:

    This module contains routines to perform device enumeration

Author:

    Shie-Lin Tzong (shielint) Sept. 5, 1996.

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include <setupblk.h>

#pragma warning(disable:4221)   // initialization using address of automatic 
                                // variable
#pragma warning(disable:4204)   // non-constant aggregate initializer

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nepP')
#endif

#define FAULT_INJECT_SETPROPERTIES  DBG

#define MAX_REENUMERATION_ATTEMPTS  32

typedef struct _DRIVER_LIST_ENTRY DRIVER_LIST_ENTRY, *PDRIVER_LIST_ENTRY;

typedef struct _PI_DEVICE_REQUEST {
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
    DEVICE_REQUEST_TYPE RequestType;
    BOOLEAN ReorderingBarrier;
    ULONG_PTR RequestArgument;
    PKEVENT CompletionEvent;
    PNTSTATUS CompletionStatus;
} PI_DEVICE_REQUEST, *PPI_DEVICE_REQUEST;

struct _DRIVER_LIST_ENTRY {
    PDRIVER_OBJECT DriverObject;
    PDRIVER_LIST_ENTRY NextEntry;
};

typedef enum _ADD_DRIVER_STAGE {
    LowerDeviceFilters = 0,
    LowerClassFilters,
    DeviceService,
    UpperDeviceFilters,
    UpperClassFilters,
    MaximumAddStage
} ADD_DRIVER_STAGE;

typedef enum _ENUM_TYPE {
    EnumTypeNone,
    EnumTypeShallow,
    EnumTypeDeep
} ENUM_TYPE;

#define VerifierTypeFromServiceType(service) \
    (VF_DEVOBJ_TYPE) (service + 2)

typedef struct {
    PDEVICE_NODE DeviceNode;

    BOOLEAN LoadDriver;

    PADD_CONTEXT AddContext;

    PDRIVER_LIST_ENTRY DriverLists[MaximumAddStage];
} QUERY_CONTEXT, *PQUERY_CONTEXT;

//
// Hash routine from CNTFS (see cntfs\prefxsup.c)
// (used here in the construction of unique ids)
//

#define HASH_UNICODE_STRING( _pustr, _phash ) {                             \
    PWCHAR _p = (_pustr)->Buffer;                                           \
    PWCHAR _ep = _p + ((_pustr)->Length/sizeof(WCHAR));                     \
    ULONG _chHolder =0;                                                     \
                                                                            \
    while( _p < _ep ) {                                                     \
        _chHolder = 37 * _chHolder + (unsigned int) (*_p++);                \
    }                                                                       \
                                                                            \
    *(_phash) = abs(314159269 * _chHolder) % 1000000007;                    \
}

// Parent prefixes are of the form %x&%x&%x
#define MAX_PARENT_PREFIX (8 + 8 + 8 + 2)

#if DBG

#define ASSERT_INITED(x) \
        if (((x)->Flags & DO_DEVICE_INITIALIZING) != 0)    \
            DbgPrint("DO_DEVICE_INITIALIZING flag not cleared on DO %#08lx\n", \
                    x);
#else

#define ASSERT_INITED(x) /* nothing */

#endif

#define PiSetDeviceInstanceSzValue(k, n, v) {               \
    if (k && *(v)) {                                        \
        UNICODE_STRING u;                                   \
        PiWstrToUnicodeString(&u, n);                       \
        ZwSetValueKey(                                      \
            k,                                              \
            &u,                                             \
            TITLE_INDEX_VALUE,                              \
            REG_SZ,                                         \
            *(v),                                           \
            (ULONG)((wcslen(*(v))+1) * sizeof(WCHAR)));     \
    }                                                       \
    if (*v) {                                               \
        ExFreePool(*v);                                     \
        *(v) = NULL;                                        \
    }                                                       \
}

#define PiSetDeviceInstanceMultiSzValue(k, n, v, s) {       \
    if (k && *(v)) {                                        \
        UNICODE_STRING u;                                   \
        PiWstrToUnicodeString(&u, n);                       \
        ZwSetValueKey(                                      \
            k,                                              \
            &u,                                             \
            TITLE_INDEX_VALUE,                              \
            REG_MULTI_SZ,                                   \
            *(v),                                           \
            s);                                             \
    }                                                       \
    if (*(v)) {                                             \
        ExFreePool(*v);                                     \
        *(v) = NULL;                                        \
    }                                                       \
}

#if DBG
VOID
PipAssertDevnodesInConsistentState(
    VOID
    );
#else
#define PipAssertDevnodesInConsistentState()
#endif

NTSTATUS
PipCallDriverAddDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN LoadDriver,
    IN PADD_CONTEXT AddContext
    );

NTSTATUS
PipCallDriverAddDeviceQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PWCHAR ValueData,
    IN ULONG ValueLength,
    IN PQUERY_CONTEXT Context,
    IN ULONG ServiceType
    );

NTSTATUS
PipChangeDeviceObjectFromRegistryProperties(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN HANDLE DeviceClassPropKey,
    IN HANDLE DeviceInstanceKey,
    IN BOOLEAN UsePdoCharacteristics
    );

VOID
PipDeviceActionWorker(
    IN  PVOID   Context
    );

NTSTATUS
PipEnumerateDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    );

BOOLEAN
PipGetRegistryDwordWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey,
    IN OUT PULONG Value
    );

PSECURITY_DESCRIPTOR
PipGetRegistrySecurityWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey
    );

NTSTATUS
PipMakeGloballyUniqueId(
    IN PDEVICE_OBJECT DeviceObject,
    IN PWCHAR         UniqueId,
    OUT PWCHAR       *GloballyUniqueId
    );

NTSTATUS
PipProcessDevNodeTree(
    IN  PDEVICE_NODE        SubtreeRootDeviceNode,
    IN  BOOLEAN             LoadDriver,
    IN  BOOLEAN             ReallocateResources,
    IN  ENUM_TYPE           EnumType,
    IN  BOOLEAN             Synchronous,
    IN  BOOLEAN             ProcessOnlyIntermediateStates,
    IN  PADD_CONTEXT        AddContext,
    IN PPI_DEVICE_REQUEST   Request
    );

NTSTATUS
PiProcessNewDeviceNode(
    IN OUT PDEVICE_NODE DeviceNode
    );

NTSTATUS
PiProcessQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PipProcessRestartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    );

NTSTATUS
PipProcessRestartPhase2(
    IN PDEVICE_NODE     DeviceNode
    );

NTSTATUS
PipProcessStartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    );

NTSTATUS
PipProcessStartPhase2(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
PipProcessStartPhase3(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
PiRestartDevice(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessHaltDevice(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiResetProblemDevicesWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    );

VOID
PiMarkDeviceTreeForReenumeration(
    IN  PDEVICE_NODE DeviceNode,
    IN  BOOLEAN Subtree
    );

NTSTATUS
PiMarkDeviceTreeForReenumerationWorker(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PVOID           Context
    );

BOOLEAN
PiCollapseEnumRequests(
    PLIST_ENTRY ListHead
    );

NTSTATUS
PiProcessAddBootDevices(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessClearDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessRequeryDeviceState(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessResourceRequirementsChanged(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessReenumeration(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessSetDeviceProblem(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PiProcessShutdownPnpDevices(
    IN PDEVICE_NODE        DeviceNode
    );

NTSTATUS
PiProcessStartSystemDevices(
    IN PPI_DEVICE_REQUEST  Request
    );

NTSTATUS
PipEnumerateCompleted(
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
PiBuildDeviceNodeInstancePath(
    IN PDEVICE_NODE DeviceNode,
    IN PWCHAR BusID,
    IN PWCHAR DeviceID,
    IN PWCHAR InstanceID
    );

NTSTATUS
PiCreateDeviceInstanceKey(
    IN PDEVICE_NODE DeviceNode,
    OUT PHANDLE InstanceHandle,
    OUT PULONG Disposition
    );

NTSTATUS
PiQueryAndAllocateBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    );

NTSTATUS
PiQueryResourceRequirements(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoShutdownPnpDevices)

#pragma alloc_text(PAGE, PipCallDriverAddDevice)
#pragma alloc_text(PAGE, PipCallDriverAddDeviceQueryRoutine)
#pragma alloc_text(PAGE, PipChangeDeviceObjectFromRegistryProperties)
#pragma alloc_text(PAGE, PipEnumerateDevice)
#pragma alloc_text(PAGE, PipGetRegistryDwordWithFallback)
#pragma alloc_text(PAGE, PipGetRegistrySecurityWithFallback)
#pragma alloc_text(PAGE, PipMakeGloballyUniqueId)
#pragma alloc_text(PAGE, PipProcessDevNodeTree)
#pragma alloc_text(PAGE, PiProcessNewDeviceNode)
#pragma alloc_text(PAGE, PiProcessQueryDeviceState)
#pragma alloc_text(PAGE, PiProcessHaltDevice)
#pragma alloc_text(PAGE, PpResetProblemDevices)
#pragma alloc_text(PAGE, PiResetProblemDevicesWorker)
#pragma alloc_text(PAGE, PiMarkDeviceTreeForReenumeration)
#pragma alloc_text(PAGE, PiMarkDeviceTreeForReenumerationWorker)
#pragma alloc_text(PAGE, PiProcessAddBootDevices)
#pragma alloc_text(PAGE, PiProcessClearDeviceProblem)
#pragma alloc_text(PAGE, PiProcessRequeryDeviceState)
#pragma alloc_text(PAGE, PiRestartDevice)
#pragma alloc_text(PAGE, PiProcessResourceRequirementsChanged)
#pragma alloc_text(PAGE, PiProcessReenumeration)
#pragma alloc_text(PAGE, PiProcessSetDeviceProblem)
#pragma alloc_text(PAGE, PiProcessShutdownPnpDevices)
#pragma alloc_text(PAGE, PiProcessStartSystemDevices)
#pragma alloc_text(PAGE, PipProcessStartPhase1)
#pragma alloc_text(PAGE, PipProcessStartPhase2)
#pragma alloc_text(PAGE, PipProcessStartPhase3)
#pragma alloc_text(PAGE, PipProcessRestartPhase1)
#pragma alloc_text(PAGE, PipProcessRestartPhase2)
#pragma alloc_text(PAGE, PipEnumerateCompleted)
#pragma alloc_text(PAGE, PiBuildDeviceNodeInstancePath)
#pragma alloc_text(PAGE, PiCreateDeviceInstanceKey)
#pragma alloc_text(PAGE, PiQueryAndAllocateBootResources)
#pragma alloc_text(PAGE, PiQueryResourceRequirements)

//#pragma alloc_text(NONPAGE, PiLockDeviceActionQueue)
//#pragma alloc_text(NONPAGE, PiUnlockDeviceActionQueue)
//#pragma alloc_text(NONPAGE, PiCollapseEnumRequests)
//#pragma alloc_text(NONPAGE, PpRemoveDeviceActionRequests)
//#pragma alloc_text(NONPAGE, PpMarkDeviceStackStartPending)
#endif

//
// This flag indicates if the device's InvalidateDeviceRelation is in progress.
// To read or write this flag, callers must get IopPnpSpinlock.
//

BOOLEAN PipEnumerationInProgress;
BOOLEAN PipTearDownPnpStacksOnShutdown;
WORK_QUEUE_ITEM PipDeviceEnumerationWorkItem;
PETHREAD PpDeviceActionThread = NULL;

//
// Internal constant strings
//

#define DEVICE_PREFIX_STRING                TEXT("\\Device\\")
#define DOSDEVICES_PREFIX_STRING            TEXT("\\DosDevices\\")

VOID
PiLockDeviceActionQueue(
    VOID
    )
{
    KIRQL oldIrql;

    for (;;) {
        //
        // Lock the device tree so that power operations dont overlap PnP
        // operations like rebalance.
        //
        PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

        ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

        if (!PipEnumerationInProgress) {
            //
            // Device action worker queue is empty. Make it so that new requests
            // get queued but new device action worker item does not get kicked
            // off.
            //
            PipEnumerationInProgress = TRUE;
            KeClearEvent(&PiEnumerationLock);
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
            break;
        }

        ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
        //
        // Unlock the tree so device action worker can finish current processing.
        //
        PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
        //
        // Wait for current device action worker item to complete.
        //
        KeWaitForSingleObject(
            &PiEnumerationLock,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }
}

VOID
PiUnlockDeviceActionQueue(
    VOID
    )
{
    KIRQL oldIrql;
    //
    // Check if we need to kick off the enumeration worker here.
    //
    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    if (!IsListEmpty(&IopPnpEnumerationRequestList)) {

        ExInitializeWorkItem(&PipDeviceEnumerationWorkItem, 
                             PipDeviceActionWorker, 
                             NULL
                             );
        ExQueueWorkItem(&PipDeviceEnumerationWorkItem, DelayedWorkQueue);
    } else {

        PipEnumerationInProgress = FALSE;
        KeSetEvent(&PiEnumerationLock, 0, FALSE);
    }

    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}

NTSTATUS
PipRequestDeviceAction(
    IN PDEVICE_OBJECT       DeviceObject        OPTIONAL,
    IN DEVICE_REQUEST_TYPE  RequestType,
    IN BOOLEAN              ReorderingBarrier,
    IN ULONG_PTR            RequestArgument,
    IN PKEVENT              CompletionEvent     OPTIONAL,
    IN PNTSTATUS            CompletionStatus    OPTIONAL
    )

/*++

Routine Description:

    This routine queues a work item to enumerate a device. This is for IO
    internal use only.

Arguments:

    DeviceObject - Supplies a pointer to the device object to be enumerated.
                   if NULL, this is a request to retry resources allocation
                   failed devices.

    Request - the reason for the enumeration.

Return Value:

    NTSTATUS code.

--*/

{
    PPI_DEVICE_REQUEST  request;
    KIRQL               oldIrql;

    if (PpPnpShuttingDown) {
        return STATUS_TOO_LATE;
    }

    //
    // If this node is ready for enumeration, enqueue it
    //

    request = ExAllocatePool(NonPagedPool, sizeof(PI_DEVICE_REQUEST));

    if (request) {
        //
        // Put this request onto the pending list
        //

        if (DeviceObject == NULL) {

            DeviceObject = IopRootDeviceNode->PhysicalDeviceObject;
        }

        ObReferenceObject(DeviceObject);

        request->DeviceObject = DeviceObject;
        request->RequestType = RequestType;
        request->ReorderingBarrier = ReorderingBarrier;
        request->RequestArgument = RequestArgument;
        request->CompletionEvent = CompletionEvent;
        request->CompletionStatus = CompletionStatus;

        InitializeListHead(&request->ListEntry);

        //
        // Insert the  request to the request queue.  If the request queue is
        // not currently being worked on, request a worker thread to start it.
        //

        ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

        InsertTailList(&IopPnpEnumerationRequestList, &request->ListEntry);

        if (RequestType == AddBootDevices ||
            RequestType == ReenumerateBootDevices ||
            RequestType == ReenumerateRootDevices) {

            ASSERT(!PipEnumerationInProgress);
            //
            // This is a special request used when booting the system.  Instead
            // of queuing a work item it synchronously calls the worker routine.
            //

            PipEnumerationInProgress = TRUE;
            KeClearEvent(&PiEnumerationLock);
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

            PipDeviceActionWorker(NULL);

        } else if (PnPBootDriversLoaded && !PipEnumerationInProgress) {

            PipEnumerationInProgress = TRUE;
            KeClearEvent(&PiEnumerationLock);
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

            //
            // Queue a work item to do the enumeration
            //

            ExInitializeWorkItem(&PipDeviceEnumerationWorkItem, 
                                 PipDeviceActionWorker, 
                                 NULL
                                 );
            ExQueueWorkItem(&PipDeviceEnumerationWorkItem, DelayedWorkQueue);
        } else {
            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
        }
    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

VOID
PipDeviceActionWorker(
    IN  PVOID   Context
    )
/*++

Routine Description:

    This function drains items from the "PnP Action queue". The action queue
    contains a list of operations that must be synchronized wrt to Start & Enum.

Parameters:

    Context - Not used.

ReturnValue:

    None.

--*/
{
    PPI_DEVICE_REQUEST  request;
    PPI_DEVICE_REQUEST  collapsedRequest;
    PLIST_ENTRY         entry;
    BOOLEAN             assignResources;
    BOOLEAN             bootProcess;
    ADD_CONTEXT         addContext;
    KIRQL               oldIrql;
    NTSTATUS            status;
    BOOLEAN             dereferenceDevice;

    UNREFERENCED_PARAMETER(Context);

    PpDeviceActionThread = PsGetCurrentThread();
    assignResources = FALSE;
    bootProcess = FALSE;
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    for ( ; ; ) {

        status = STATUS_SUCCESS;
        //
        // PipProcessDevNodeTree always dereferences passed in device. Set this
        // to false if PipProcessDevNodeTree is called with the device in the
        // original request.
        //
        dereferenceDevice = TRUE;

        ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

        entry = RemoveHeadList(&IopPnpEnumerationRequestList);
        if (entry == &IopPnpEnumerationRequestList) {

            if (assignResources == FALSE && bootProcess == FALSE) {
                //
                // No more processing.
                //
                break;
            }
            entry = NULL;
        }

        ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

        if (entry == NULL) {

            ASSERT(assignResources || bootProcess);

            if (assignResources || bootProcess) {

                addContext.DriverStartType = SERVICE_DEMAND_START;

                ObReferenceObject(IopRootDeviceNode->PhysicalDeviceObject);
                status = PipProcessDevNodeTree( IopRootDeviceNode,
                                                PnPBootDriversInitialized,
                                                assignResources,            
                                                EnumTypeNone,
                                                FALSE,
                                                FALSE,
                                                &addContext,
                                                NULL);
                if (!NT_SUCCESS(status)) {

                    status = STATUS_SUCCESS;
                }
                assignResources = FALSE;
                bootProcess = FALSE;
            }

            continue;
        }
        //
        // We have a list of requests to process. Processing depends on the type
        // of the first one in the list.
        //
        ASSERT(entry);
        request = CONTAINING_RECORD(entry, PI_DEVICE_REQUEST, ListEntry);
        InitializeListHead(&request->ListEntry);

        if (PpPnpShuttingDown) {

            status = STATUS_TOO_LATE;
        } else if (PP_DO_TO_DN(request->DeviceObject)->State == DeviceNodeDeleted) {

            status = STATUS_UNSUCCESSFUL;
        } else {

            switch (request->RequestType) {

            case AddBootDevices:
                //
                // Boot driver initialization.
                //
                status = PiProcessAddBootDevices(request);
                break;

            case AssignResources:
                //
                // Resources were freed, we want to try to satisfy any
                // DNF_INSUFFICIENT_RESOURCES devices.
                //
                assignResources = TRUE;
                break;

            case ClearDeviceProblem:
            case ClearEjectProblem:

                status = PiProcessClearDeviceProblem(request);
                break;

            case HaltDevice:

                status = PiProcessHaltDevice(request);
                break;

            case RequeryDeviceState:

                status = PiProcessRequeryDeviceState(request);
                break;

            case ResetDevice:

                status = PiRestartDevice(request);
                break;

            case ResourceRequirementsChanged:

                status = PiProcessResourceRequirementsChanged(request);
                if (!NT_SUCCESS(status)) {
                    //
                    // The device wasn't started when 
                    // IopResourceRequirementsChanged was called.
                    //
                    assignResources = TRUE;
                    status = STATUS_SUCCESS;
                }
                break;

            case ReenumerateBootDevices:

                //
                // This is during boot driver initialization phase.
                //
                bootProcess = TRUE;
                break;

            case RestartEnumeration:    // Used after completion of async I/O
            case ReenumerateRootDevices:
            case ReenumerateDeviceTree:
                //
                // FALL THROUGH...
                //
            case ReenumerateDeviceOnly:

                status = PiProcessReenumeration(request);
                dereferenceDevice = FALSE;
                break;

            case SetDeviceProblem:

                status = PiProcessSetDeviceProblem(request);
                break;

            case ShutdownPnpDevices:

                status = PiProcessShutdownPnpDevices(IopRootDeviceNode);
                break;

            case StartDevice:

                status = PiRestartDevice(request);
                break;

            case StartSystemDevices:

                status = PiProcessStartSystemDevices(request);
                dereferenceDevice = FALSE;
                break;
            }
        }
        //
        // Free the list.
        //
        do {

            entry = RemoveHeadList(&request->ListEntry);
            collapsedRequest = CONTAINING_RECORD(entry, 
                                                 PI_DEVICE_REQUEST, 
                                                 ListEntry
                                                 );
            //
            // Done with this enumeration request
            //
            if (collapsedRequest->CompletionStatus) {

                *collapsedRequest->CompletionStatus = status;
            }
            if (collapsedRequest->CompletionEvent) {

                KeSetEvent(collapsedRequest->CompletionEvent, 0, FALSE);
            }
            //
            // Only dereference the original request, the rest get dereferenced
            // when we collapse.
            //
            if ((collapsedRequest == request && dereferenceDevice)) {

                ObDereferenceObject(collapsedRequest->DeviceObject);
            }
            ExFreePool(collapsedRequest);

        } while (collapsedRequest != request);
    }

    PipEnumerationInProgress = FALSE;

    KeSetEvent(&PiEnumerationLock, 0, FALSE);
    ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

    PpDeviceActionThread = NULL;

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
}

NTSTATUS
IoShutdownPnpDevices(
    VOID
    )

/*++

Routine Description:

    This function is called by the IO system driver verifier during shutdown.
    It queues a work item to Query/Remove all the devices in the tree.  All
    the ones supporting removal will be removed and their drivers unloaded if
    all instances of their devices are removed.

    This API should only be called once during shutdown, it has no effect on the
    second and subsequent calls.

Parameters:

    NONE.

Return Value:

    STATUS_SUCCESS if the process was successfully completed.  Doesn't mean
    any devices were actually removed.  Otherwise an error code indicating the
    error.  There is no guarantee that no devices have been removed if an error
    occurs however in the current implementation the only time an error will
    be reported is if the operation couldn't be queued.

--*/

{
    KEVENT          actionEvent;
    NTSTATUS        actionStatus;
    NTSTATUS        status;

    PAGED_CODE();

    KeInitializeEvent(&actionEvent, NotificationEvent, FALSE);

    status = PipRequestDeviceAction( NULL,
                                     ShutdownPnpDevices,
                                     FALSE,
                                     0,
                                     &actionEvent,
                                     &actionStatus);

    if (NT_SUCCESS(status)) {

        //
        // Wait for the event we just queued to finish since synchronous
        // operation was requested (non alertable wait).
        //
        // FUTURE ITEM - Use a timeout here?
        //

        status = KeWaitForSingleObject( &actionEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        if (NT_SUCCESS(status)) {
            status = actionStatus;
        }
    }

    return status;

}

NTSTATUS
PipEnumerateDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN Synchronous
    )

/*++

Routine Description:

    This function assumes that the specified physical device object is
    a bus and will enumerate all of the children PDOs on the bus.

Arguments:

    DeviceObject - Supplies a pointer to the physical device object to be
                   enumerated.

    StartContext - supplies a pointer to the START_CONTEXT to control how to
                   add/start new devices.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Clear the flag before the query so we dont lose an enum request.
    // 
    DeviceNode->Flags &= ~DNF_REENUMERATE;
    status = IopQueryDeviceRelations(BusRelations,
                                     DeviceNode->PhysicalDeviceObject,
                                     Synchronous,
                                     &DeviceNode->OverUsed1.PendingDeviceRelations
                                     );

    return status;
}

NTSTATUS
PipEnumerateCompleted(
    IN PDEVICE_NODE DeviceNode
    )
{
    PDEVICE_NODE    childDeviceNode, nextChildDeviceNode;
    PDEVICE_OBJECT  childDeviceObject;
    BOOLEAN         childRemoved;
    NTSTATUS        status, allocationStatus;
    ULONG           i;

    PAGED_CODE();

    if (DeviceNode->OverUsed1.PendingDeviceRelations == NULL) {

        PipSetDevNodeState(DeviceNode, DeviceNodeStarted, NULL);

        return STATUS_SUCCESS;
    }

    //
    // Walk all the child device nodes and mark them as not present
    //

    childDeviceNode = DeviceNode->Child;
    while (childDeviceNode) {
        childDeviceNode->Flags &= ~DNF_ENUMERATED;
        childDeviceNode = childDeviceNode->Sibling;
    }

    //
    // Check all the PDOs returned see if any new one or any one disappeared.
    //

    for (i = 0; i < DeviceNode->OverUsed1.PendingDeviceRelations->Count; i++) {

        childDeviceObject = DeviceNode->OverUsed1.PendingDeviceRelations->Objects[i];

        ASSERT_INITED(childDeviceObject);

        if (childDeviceObject->DeviceObjectExtension->ExtensionFlags & DOE_DELETE_PENDING) {

            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(childDeviceObject);
            KeBugCheckEx( PNP_DETECTED_FATAL_ERROR,
                          PNP_ERR_PDO_ENUMERATED_AFTER_DELETION,
                          (ULONG_PTR)childDeviceObject,
                          0,
                          0);
        }

        //
        // We've found another physical device, see if there is
        // already a devnode for it.
        //

        childDeviceNode = (PDEVICE_NODE)childDeviceObject->DeviceObjectExtension->DeviceNode;
        if (childDeviceNode == NULL) {

            //
            // Device node doesn't exist, create one.
            //

            allocationStatus = PipAllocateDeviceNode(
                childDeviceObject,
                &childDeviceNode);

            if (childDeviceNode) {

                //
                // We've found or created a devnode for the PDO that the
                // bus driver just enumerated.
                //
                childDeviceNode->Flags |= DNF_ENUMERATED;

                //
                // Mark the device object a bus enumerated device
                //
                childDeviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;

                //
                // Put this new device node at the head of the parent's list
                // of children.
                //
                PpDevNodeInsertIntoTree(DeviceNode, childDeviceNode);
                if (allocationStatus == STATUS_SYSTEM_HIVE_TOO_LARGE) {

                    PipSetDevNodeProblem(childDeviceNode, CM_PROB_REGISTRY_TOO_LARGE);
                }

            } else {

                //
                // Had a problem creating a devnode.  Pretend we've never
                // seen it.
                //
                IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                             "PipEnumerateDevice: Failed to allocate device node\n"));

                ObDereferenceObject(childDeviceObject);
            }
        } else {

            //
            // The device is alreay enumerated.  Remark it and release the
            // device object reference.
            //
            childDeviceNode->Flags |= DNF_ENUMERATED;

            if (childDeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED) {

                //
                // A dock that was listed as departing in an eject relation
                // didn't actually leave. Remove it from the profile transition
                // list...
                //
                PpProfileCancelTransitioningDock(childDeviceNode, DOCK_DEPARTING);
            }

            ASSERT(!(childDeviceNode->Flags & DNF_DEVICE_GONE));

            ObDereferenceObject(childDeviceObject);
        }
    }

    ExFreePool(DeviceNode->OverUsed1.PendingDeviceRelations);
    DeviceNode->OverUsed1.PendingDeviceRelations = NULL;

    //
    // If we get here, the enumeration was successful.  Process any missing
    // devnodes.
    //

    childRemoved = FALSE;

    for (childDeviceNode = DeviceNode->Child;
         childDeviceNode != NULL;
         childDeviceNode = nextChildDeviceNode) {

        //
        // First, we need to remember the 'next child' because the 'child' will be
        // removed and we won't be able to find the 'next child.'
        //

        nextChildDeviceNode = childDeviceNode->Sibling;

        if (!(childDeviceNode->Flags & DNF_ENUMERATED)) {

            if (!(childDeviceNode->Flags & DNF_DEVICE_GONE)) {

                childDeviceNode->Flags |= DNF_DEVICE_GONE;

                PipRequestDeviceRemoval(
                    childDeviceNode,
                    TRUE,
                    CM_PROB_DEVICE_NOT_THERE
                    );

                childRemoved = TRUE;
            }
        }
    }

    ASSERT(DeviceNode->State == DeviceNodeEnumerateCompletion);
    PipSetDevNodeState(DeviceNode, DeviceNodeStarted, NULL);

    //
    // The root enumerator gets confused if we reenumerate it before we process
    // newly reported PDOs.  Since it can't possibly create the scenario we are
    // trying to fix, we won't bother waiting for the removes to complete before
    // processing the new devnodes.
    //

    if (childRemoved && DeviceNode != IopRootDeviceNode) {

        status = STATUS_PNP_RESTART_ENUMERATION;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;
}

VOID
PpMarkDeviceStackStartPending(
    IN PDEVICE_OBJECT   DeviceObject,
    IN BOOLEAN          Set
    )

/*++

Routine Description:

    This function marks the entire device stack with DOE_START_PENDING.

Arguments:

    DeviceObject - PDO for the device stack.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT attachedDevice;
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (attachedDevice = DeviceObject;
         attachedDevice != NULL;
         attachedDevice = attachedDevice->AttachedDevice) {

        if (Set) {

            attachedDevice->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;
        } else {

            attachedDevice->DeviceObjectExtension->ExtensionFlags &= ~DOE_START_PENDING;
        }
    }

    KeReleaseQueuedSpinLock(LockQueueIoDatabaseLock, irql);
}

NTSTATUS
PiBuildDeviceNodeInstancePath(
    IN PDEVICE_NODE DeviceNode,
    IN PWCHAR BusID,
    IN PWCHAR DeviceID,
    IN PWCHAR InstanceID
    )

/*++

Routine Description:

    This function builds the instance path (BusID\DeviceID\InstanceID). If 
    successful, it will free the storage for any existing instance path and 
    replace with the new one.

Arguments:

    DeviceNode - DeviceNode for which the instance path will be built.
    
    BusID - Bus ID.
    
    DeviceID - Device ID.
    
    InstanceID - Instance ID.

Return Value:

    NTSTATUS.

--*/

{
    ULONG length;
    PWCHAR instancePath;

    PAGED_CODE();

    if (BusID == NULL || DeviceID == NULL || InstanceID == NULL) {

        ASSERT( PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) ||
              PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) ||
              PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY));

        return STATUS_UNSUCCESSFUL;
    }

    length = (ULONG)((wcslen(BusID) + wcslen(DeviceID) + wcslen(InstanceID) + 2) * sizeof(WCHAR) + sizeof(UNICODE_NULL));
    instancePath = (PWCHAR)ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, length);
    if (!instancePath) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Construct the instance path as <BUS>\<DEVICE>\<INSTANCE>. This should always be NULL terminated 
    // since we have precomputed the length that we pass into this counted routine.
    //
    StringCbPrintfW(instancePath, length, L"%s\\%s\\%s", BusID, DeviceID, InstanceID);
    //
    // Free old instance path.
    //
    if (DeviceNode->InstancePath.Buffer != NULL) {

        IopCleanupDeviceRegistryValues(&DeviceNode->InstancePath);
        ExFreePool(DeviceNode->InstancePath.Buffer);
    }

    RtlInitUnicodeString(&DeviceNode->InstancePath, instancePath);

    return STATUS_SUCCESS;
}

NTSTATUS
PiCreateDeviceInstanceKey(
    IN PDEVICE_NODE DeviceNode,
    OUT PHANDLE InstanceKey,
    OUT PULONG Disposition
    )

/*++

Routine Description:

    This function will create the device instance key.
    
Arguments:

    DeviceNode - DeviceNode for which the instance path will be built.
    
    InstanceKey - Will recieve the instance key handle.
    
    Disposition - Will recieve the disposition whether the key existed or was newly created.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    HANDLE enumHandle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    *InstanceKey = NULL;
    *Disposition = 0;

    PiLockPnpRegistry(FALSE);

    status = IopOpenRegistryKeyEx( 
                &enumHandle,
                NULL,
                &CmRegistryMachineSystemCurrentControlSetEnumName,
                KEY_ALL_ACCESS
                );
    if (NT_SUCCESS(status)) {

        status = IopCreateRegistryKeyEx( 
                    InstanceKey,
                    enumHandle,
                    &DeviceNode->InstancePath,
                    KEY_ALL_ACCESS,
                    REG_OPTION_NON_VOLATILE,
                    Disposition
                    );
        if (NT_SUCCESS(status)) {
            //
            // Keys migrated by textmode setup should be treated as "new".
            // Migrated keys are identified by the presence of non-zero 
            // REG_DWORD value "Migrated" under the device instance key.
            //
            if (*Disposition != REG_CREATED_NEW_KEY) {

                keyValueInformation = NULL;
                IopGetRegistryValue(
                    *InstanceKey,
                    REGSTR_VALUE_MIGRATED,
                    &keyValueInformation);
                if (keyValueInformation) {

                    if (    keyValueInformation->Type == REG_DWORD &&
                            keyValueInformation->DataLength == sizeof(ULONG) &&
                            *(PULONG)KEY_VALUE_DATA(keyValueInformation) != 0) {

                        *Disposition = REG_CREATED_NEW_KEY;
                    }

                    PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                    ZwDeleteValueKey(*InstanceKey, &unicodeString);

                    ExFreePool(keyValueInformation);
                }
            }

        } else {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PpCreateDeviceInstanceKey: Unable to create %wZ\n", 
                         &DeviceNode->InstancePath));
            ASSERT(*InstanceKey != NULL);
        }

        ZwClose(enumHandle);
    } else {
        //
        // This would be very bad.
        //
        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PpCreateDeviceInstanceKey: Unable to open %wZ\n", 
                     &CmRegistryMachineSystemCurrentControlSetEnumName));
        ASSERT(enumHandle != NULL);
    }

    PiUnlockPnpRegistry();

    return status;
}

NTSTATUS
PiQueryAndAllocateBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    )

/*++

Routine Description:

    This function will query the BOOT resources for the device and reserve them from the arbiter.
    
Arguments:

    DeviceNode - DeviceNode for which the BOOT resources need to be queried.
    
    LogConfKey - Handle to the LogConf key under the device instance key.
        
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PCM_RESOURCE_LIST cmResource;
    ULONG cmLength;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    cmResource = NULL;
    cmLength = 0;
    if (DeviceNode->BootResources == NULL) {

        status = IopQueryDeviceResources( 
                    DeviceNode->PhysicalDeviceObject,
                    QUERY_RESOURCE_LIST,
                    &cmResource,
                    &cmLength);
        if (!NT_SUCCESS(status)) {

            ASSERT(cmResource == NULL && cmLength == 0);
            cmResource = NULL;
            cmLength = 0;
        }
    } else {

        IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                        "PNPENUM: %ws already has BOOT config in PiQueryAndAllocateBootResources!\n",
                        DeviceNode->InstancePath.Buffer));
    }
    //
    // Write boot resources to registry
    //
    if (LogConfKey && DeviceNode->BootResources == NULL) {

        PiWstrToUnicodeString(&unicodeString, REGSTR_VAL_BOOTCONFIG);

        PiLockPnpRegistry(FALSE);

        if (cmResource) {

            ZwSetValueKey(
                LogConfKey,
                &unicodeString,
                TITLE_INDEX_VALUE,
                REG_RESOURCE_LIST,
                cmResource,
                cmLength);
        } else {

            ZwDeleteValueKey(LogConfKey, &unicodeString);
        }

        PiUnlockPnpRegistry();

        if (cmResource) {
            //
            // This device consumes BOOT resources.  Reserve its boot resources
            //
            status = (*IopAllocateBootResourcesRoutine)(    
                        ArbiterRequestPnpEnumerated,
                        DeviceNode->PhysicalDeviceObject,
                        cmResource);
            if (NT_SUCCESS(status)) {

                DeviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
            }
        }
    }
    if (cmResource) {

        ExFreePool(cmResource);
    }

    return status;
}

NTSTATUS
PiQueryResourceRequirements(
    IN PDEVICE_NODE DeviceNode,
    IN HANDLE LogConfKey
    )

/*++

Routine Description:

    This function will query the resource requirements for the device.
    
Arguments:

    DeviceNode - DeviceNode for which the resource requirements need to be queried.
    
    LogConfKey - Handle to the LogConf key under the device instance key.
        
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResource;
    ULONG ioLength;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Query the device's basic config vector. 
    //
    status = PpIrpQueryResourceRequirements(
                DeviceNode->PhysicalDeviceObject, 
                &ioResource);
    if (!NT_SUCCESS(status)) {

        ASSERT(ioResource == NULL);
        ioResource = NULL;
    }
    if (ioResource) {

        ioLength = ioResource->ListSize;
    } else {

        ioLength = 0;
    }
    //
    // Write resource requirements to registry
    //
    if (LogConfKey) {

        PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_BASIC_CONFIG_VECTOR);

        PiLockPnpRegistry(FALSE);

        if (ioResource) {

            ZwSetValueKey(
                LogConfKey,
                &unicodeString,
                TITLE_INDEX_VALUE,
                REG_RESOURCE_REQUIREMENTS_LIST,
                ioResource,
                ioLength);
            DeviceNode->ResourceRequirements = ioResource;
            DeviceNode->Flags |= DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
            ioResource = NULL;
        } else {

            ZwDeleteValueKey(LogConfKey, &unicodeString);
        }
        PiUnlockPnpRegistry();
    }
    if (ioResource) {

        ExFreePool(ioResource);
    }

    return status;
}

NTSTATUS
PiProcessNewDeviceNode(
    IN PDEVICE_NODE DeviceNode

/*++

Routine Description:

    This function will process a new device.
    
Arguments:

    DeviceNode - New DeviceNode.
            
Return Value:

    NTSTATUS.

--*/

    )
{
    NTSTATUS status, finalStatus;
    PDEVICE_OBJECT deviceObject, dupeDeviceObject;
    PWCHAR busID, deviceID, instanceID, description, location, uniqueInstanceID, hwIDs, compatibleIDs;
    DEVICE_CAPABILITIES capabilities;
    BOOLEAN globallyUnique, criticalDevice, configuredBySetup, isRemoteBootCard;
    ULONG instanceIDLength, disposition, configFlags, problem, hwIDLength, compatibleIDLength;
    HANDLE instanceKey, logConfKey;
    PDEVICE_NODE dupeDeviceNode;
    UNICODE_STRING unicodeString;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();

    finalStatus = STATUS_SUCCESS;

    criticalDevice = FALSE;
    isRemoteBootCard = FALSE;
    logConfKey = NULL;
    instanceKey = NULL;
    disposition = 0;

    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = PpQueryDeviceID(DeviceNode, &busID, &deviceID);
    if (!NT_SUCCESS(status)) {

        if (status == STATUS_PNP_INVALID_ID) {

            finalStatus = STATUS_UNSUCCESSFUL;
        } else {

            finalStatus = status;
        }
    }
    //
    // Query the device's capabilities.
    //
    status = PpIrpQueryCapabilities(deviceObject, &capabilities);
    //
    // Process the capabilities before saving them.
    //
    DeviceNode->UserFlags &= ~DNUF_DONT_SHOW_IN_UI;
    globallyUnique = FALSE;
    if (NT_SUCCESS(status)) {

        if (capabilities.NoDisplayInUI) {

            DeviceNode->UserFlags |= DNUF_DONT_SHOW_IN_UI;
        }
        if (capabilities.UniqueID) {

            globallyUnique = TRUE;
        }
    }
    PpProfileProcessDockDeviceCapability(DeviceNode, &capabilities);
    //
    // Query the new devnode's description and location.
    //
    PpQueryDeviceDescription(DeviceNode, &description);

    PpQueryDeviceLocationInformation(DeviceNode, &location);
    //
    // Query the instance ID for the new devnode.
    //
    status = PpQueryInstanceID(DeviceNode, &instanceID, &instanceIDLength);
    if (!globallyUnique) {

        if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) && 
                DeviceNode->Parent != IopRootDeviceNode) {

            uniqueInstanceID = NULL;

            status = PipMakeGloballyUniqueId(deviceObject, instanceID, &uniqueInstanceID);

            if (instanceID != NULL) {

                ExFreePool(instanceID);
            }
            instanceID = uniqueInstanceID;
            if (instanceID) {

                instanceIDLength = ((ULONG)wcslen(instanceID) + 1) * sizeof(WCHAR);
            } else {
                
                instanceIDLength = 0;
                ASSERT(!NT_SUCCESS(status));
            }

        }
    } else if (status == STATUS_NOT_SUPPORTED) {

        PipSetDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA);
        DeviceNode->Parent->Flags |= DNF_CHILD_WITH_INVALID_ID;
        PpSetInvalidIDEvent(&DeviceNode->Parent->InstancePath);

        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PpQueryID: Bogus ID returned by %wZ\n",
                     &DeviceNode->Parent->ServiceName));
        ASSERT(status != STATUS_NOT_SUPPORTED || !globallyUnique);
    }

RetryDuplicateId:

    if (!NT_SUCCESS(status)) {
         
        finalStatus = status;
        if (!PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA)) {

            if (status == STATUS_INSUFFICIENT_RESOURCES) {
    
                PipSetDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY);
            } else {
                //
                // Perhaps some other problem code?
                //
                PipSetDevNodeProblem(DeviceNode, CM_PROB_REGISTRY);
            }
        }
    }
    //
    // Build the device instance path and create the instance key.
    //
    status = PiBuildDeviceNodeInstancePath(DeviceNode, busID, deviceID, instanceID);
    if (NT_SUCCESS(status)) {

        status = PiCreateDeviceInstanceKey(DeviceNode, &instanceKey, &disposition);
    }

    if (!NT_SUCCESS(status)) {

        finalStatus = status;
    }
    //
    // Mark the devnode as initialized.
    //
    PpMarkDeviceStackStartPending(deviceObject, TRUE);

    //
    // ISSUE: Should not mark the state if the IDs were invalid.
    //
    PipSetDevNodeState(DeviceNode, DeviceNodeInitialized, NULL);

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {
        //
        // Check if we are encountering this device for the very first time.
        //
        if (disposition == REG_CREATED_NEW_KEY) {
            //
            // Save the description only for new devices so we dont clobber 
            // the inf written description for already installed devices.
            //
            PiLockPnpRegistry(FALSE);

            PiSetDeviceInstanceSzValue(instanceKey, REGSTR_VAL_DEVDESC, &description);

            PiUnlockPnpRegistry();
        } else {
            //
            // Check if there is another device with the same name.
            //
            dupeDeviceObject = IopDeviceObjectFromDeviceInstance(&DeviceNode->InstancePath);
            if (dupeDeviceObject) {

                if (dupeDeviceObject != deviceObject) {

                    if (globallyUnique) {

                        globallyUnique = FALSE;
                        PipSetDevNodeProblem(DeviceNode, CM_PROB_DUPLICATE_DEVICE);

                        dupeDeviceNode = dupeDeviceObject->DeviceObjectExtension->DeviceNode;
                        ASSERT(dupeDeviceNode);

                        if (dupeDeviceNode->Parent == DeviceNode->Parent) {
                            //
                            // Definite driver screw up. If the verifier is enabled
                            // we will fail the driver. Otherwise, we will attempt
                            // to uniquify the second device to keep the system
                            // alive.
                            //
                            PpvUtilFailDriver(
                                PPVERROR_DUPLICATE_PDO_ENUMERATED,
                                (PVOID) deviceObject->DriverObject->MajorFunction[IRP_MJ_PNP],
                                deviceObject,
                                (PVOID)dupeDeviceObject);
                        }

                        ObDereferenceObject(dupeDeviceObject);

                        status = PipMakeGloballyUniqueId(deviceObject, instanceID, &uniqueInstanceID);

                        if (instanceID != NULL) {

                            ExFreePool(instanceID);
                        }
                        instanceID = uniqueInstanceID;
                        if (instanceID) {

                            instanceIDLength = ((ULONG)wcslen(instanceID) + 1) * sizeof(WCHAR);
                        } else {

                            instanceIDLength = 0;
                            ASSERT(!NT_SUCCESS(status));
                        }
                        //
                        // Cleanup and retry.
                        //
                        goto RetryDuplicateId;
                    }
                    //
                    // No need to clean up the ref as we're going to crash the
                    // system.
                    //
                    //ObDereferenceObject(dupCheckDeviceObject);

                    PpvUtilFailDriver(
                        PPVERROR_DUPLICATE_PDO_ENUMERATED,
                        (PVOID) deviceObject->DriverObject->MajorFunction[IRP_MJ_PNP],
                        deviceObject,
                        (PVOID)dupeDeviceObject);

                    PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(deviceObject);
                    PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(dupeDeviceObject);
                    KeBugCheckEx( 
                        PNP_DETECTED_FATAL_ERROR,
                        PNP_ERR_DUPLICATE_PDO,
                        (ULONG_PTR)deviceObject,
                        (ULONG_PTR)dupeDeviceObject,
                        0);
                }
                ObDereferenceObject(dupeDeviceObject);
            }
        }
    }

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

        PiLockPnpRegistry(FALSE);
        //
        // Save device location.
        //
        PiSetDeviceInstanceSzValue(instanceKey, REGSTR_VALUE_LOCATION_INFORMATION, &location);

        PpSaveDeviceCapabilities(DeviceNode, &capabilities);
        //
        // ADRIAO N.B. 2001/05/29 - Raw device issue
        //     processCriticalDevice has no effect on raw devnodes. A raw
        // devnode with CONFIGFLAG_FAILED_INSTALL or CONFIGFLAG_REINSTALL
        // should be started anyway if it's in the CDDB (not that NULL CDDB
        // entries are supported yet), but that doesn't happen today. This
        // means that boot volumes with CONFIGFLAG_REINSTALL will lead to a
        // definite 7B.
        //
        problem = 0;
        criticalDevice = (disposition == REG_CREATED_NEW_KEY)? TRUE : FALSE;
        status = IopGetRegistryValue(instanceKey, REGSTR_VALUE_CONFIG_FLAGS, &keyValueInformation);
        if (NT_SUCCESS(status)) {

            configFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            if (configFlags & CONFIGFLAG_REINSTALL) {

                problem = CM_PROB_REINSTALL;
                criticalDevice = TRUE;
            } else if (configFlags & CONFIGFLAG_FAILEDINSTALL) {

                problem = CM_PROB_FAILED_INSTALL;
                criticalDevice = TRUE;
            }

            ExFreePool(keyValueInformation);
        } else {

            configFlags = 0;
            problem = CM_PROB_NOT_CONFIGURED;
            criticalDevice = TRUE;
        }
        if (problem) {

            if (capabilities.RawDeviceOK) {

                configFlags |= CONFIGFLAG_FINISH_INSTALL;
                PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_CONFIG_FLAGS);
                ZwSetValueKey(
                    instanceKey,
                    &unicodeString,
                    TITLE_INDEX_VALUE,
                    REG_DWORD,
                    &configFlags,
                    sizeof(configFlags));
            } else {

                PipSetDevNodeProblem(DeviceNode, problem);
            }
        }
        status = IopMapDeviceObjectToDeviceInstance(DeviceNode->PhysicalDeviceObject, &DeviceNode->InstancePath);
        ASSERT(NT_SUCCESS(status));
        if (!NT_SUCCESS(status)) {

            finalStatus = status;
        }

        PiUnlockPnpRegistry();
    }

    PpQueryHardwareIDs( 
        DeviceNode,
        &hwIDs,
        &hwIDLength);

    PpQueryCompatibleIDs(  
        DeviceNode,
        &compatibleIDs,
        &compatibleIDLength);

    PiLockPnpRegistry(FALSE);

    DeviceNode->Flags |= DNF_IDS_QUERIED;

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

        PiWstrToUnicodeString(&unicodeString, REGSTR_KEY_LOG_CONF);
        IopCreateRegistryKeyEx( 
            &logConfKey,
            instanceKey,
            &unicodeString,
            KEY_ALL_ACCESS,
            REG_OPTION_NON_VOLATILE,
            NULL);
    }

    PiUnlockPnpRegistry();

    PiQueryResourceRequirements(DeviceNode, logConfKey);

    PiLockPnpRegistry(FALSE);

    if (IoRemoteBootClient && (IopLoaderBlock != NULL)) {

        if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
                !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
                !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {
        
            if (hwIDs) {
    
                isRemoteBootCard = IopIsRemoteBootCard(
                                        DeviceNode->ResourceRequirements,
                                        (PLOADER_PARAMETER_BLOCK)IopLoaderBlock,
                                        hwIDs);
            }
            if (!isRemoteBootCard && compatibleIDs) {
    
                isRemoteBootCard = IopIsRemoteBootCard(
                                        DeviceNode->ResourceRequirements,
                                        (PLOADER_PARAMETER_BLOCK)IopLoaderBlock,
                                        compatibleIDs);
            }
        }
    }

    PiSetDeviceInstanceMultiSzValue(instanceKey, REGSTR_VALUE_HARDWAREID, &hwIDs, hwIDLength);

    PiSetDeviceInstanceMultiSzValue(instanceKey, REGSTR_VALUE_COMPATIBLEIDS, &compatibleIDs, compatibleIDLength);

    status = STATUS_SUCCESS;
    if (isRemoteBootCard) {

        status = IopSetupRemoteBootCard(
                        (PLOADER_PARAMETER_BLOCK)IopLoaderBlock,
                        instanceKey,
                        &DeviceNode->InstancePath);
        if (!NT_SUCCESS(status)) {

            finalStatus = status;
        }
    }

    PiUnlockPnpRegistry();

    PpQueryBusInformation(DeviceNode);

    if (NT_SUCCESS(status)) {

        if (criticalDevice) {
            //
            // Process the device as a critical device.
            //
            // This will attempt to locate a match for the device in the
            // CriticalDeviceDatabase using the device's hardware and compatible
            // ids.  If a match is found, critical device settings such as Service,
            // ClassGUID (to determine Class filters), and device LowerFilters and
            // UpperFilters will be applied to the device.
            //
            // If DevicePath location information matching this device is present
            // critical device database entry, this routine will also pre-install
            // the new device with those settings.
            //
            if (!capabilities.HardwareDisabled && !PipIsDevNodeProblem(DeviceNode, CM_PROB_NEED_RESTART)) {

                PpCriticalProcessCriticalDevice(DeviceNode);
            }
        }

        ASSERT(!PipDoesDevNodeHaveProblem(DeviceNode) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REINSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_FAILED_INSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_PARTIAL_LOG_CONF) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_HARDWARE_DISABLED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_NEED_RESTART) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_DUPLICATE_DEVICE) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY));

        if (!PipIsDevNodeProblem(DeviceNode, CM_PROB_DISABLED) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_HARDWARE_DISABLED) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_NEED_RESTART) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

            IopIsDeviceInstanceEnabled(instanceKey, &DeviceNode->InstancePath, TRUE);
        }
    }

    PiQueryAndAllocateBootResources(DeviceNode, logConfKey);

    if (    !PipIsDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_OUT_OF_MEMORY) &&
            !PipIsDevNodeProblem(DeviceNode, CM_PROB_REGISTRY)) {

        PiLockPnpRegistry(FALSE);

        PpSaveDeviceCapabilities(DeviceNode, &capabilities);

        PiUnlockPnpRegistry();

        PpHotSwapUpdateRemovalPolicy(DeviceNode);
        //
        // Create new value entry under ServiceKeyName\Enum to reflect the newly
        // added made-up device instance node.
        //
        status = IopNotifySetupDeviceArrival( deviceObject,
                                              instanceKey,
                                              TRUE);

        configuredBySetup = NT_SUCCESS(status) ? TRUE : FALSE;

        status = PpDeviceRegistration(
                     &DeviceNode->InstancePath,
                     TRUE,
                     &DeviceNode->ServiceName
                     );
        if (NT_SUCCESS(status)) {

            if (    (configuredBySetup || isRemoteBootCard) &&
                    PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED)) {

                PipClearDevNodeProblem(DeviceNode);
            }
        }
        //
        // Add an event so user-mode will attempt to install this device later.
        //
        PpSetPlugPlayEvent(&GUID_DEVICE_ENUMERATED, deviceObject);
    }
    //
    // Cleanup.
    //
    if (hwIDs) {

        ExFreePool(hwIDs);        
    }
    if (compatibleIDs) {

        ExFreePool(compatibleIDs);
    }
    if (logConfKey) {

        ZwClose(logConfKey);
    }
    if (instanceKey) {

        ZwClose(instanceKey);
    }
    if (instanceID) {

        ExFreePool(instanceID);
    }
    if (location) {

        ExFreePool(location);
    }
    if (description) {

        ExFreePool(description);
    }
    if (busID) {

        ExFreePool(busID);
    }

    return finalStatus;
}

NTSTATUS
PipCallDriverAddDevice(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN LoadDriver,
    IN PADD_CONTEXT Context
    )

/*++

Routine Description:

    This function checks if the driver for the DeviceNode is present and loads
    the driver if necessary.

Arguments:

    DeviceNode - Supplies a pointer to the device node to be enumerated.

    LoadDriver - Supplies a BOOLEAN value to indicate should a driver be loaded
                 to complete enumeration.

    Context - Supplies a pointer to ADD_CONTEXT to control how the device be added.

Return Value:

    NTSTATUS code.

--*/

{
    HANDLE enumKey, instanceKey, controlKey, classKey = NULL, classPropsKey = NULL;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation = NULL;
    RTL_QUERY_REGISTRY_TABLE queryTable[3];
    QUERY_CONTEXT queryContext;
    BOOLEAN rawStack;
    BOOLEAN deviceRaw = FALSE;
    BOOLEAN usePdoCharacteristics = TRUE;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT fdoDeviceObject, topOfPdoStack, topOfLowerFilterStack;
    UNICODE_STRING unicodeClassGuid;

    PAGED_CODE();

    IopDbgPrint((   IOP_ENUMERATION_TRACE_LEVEL,
                    "PipCallDriverAddDevice: Processing devnode %#08lx\n",
                   DeviceNode));
    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipCallDriverAddDevice: DevNode flags going in = %#08lx\n",
                   DeviceNode->Flags));

    //
    // The device node may have been started at this point.  This is because
    // some ill-behaved miniport drivers call IopReportedDetectedDevice at
    // DriverEntry for the devices which we already know about.
    //

    ASSERT_INITED(DeviceNode->PhysicalDeviceObject);

    IopDbgPrint((   IOP_ENUMERATION_TRACE_LEVEL,
                    "PipCallDriverAddDevice:\t%s load driver\n",
                    LoadDriver? "Will" : "Won't"));

    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipCallDriverAddDevice:\tOpening registry key %wZ\n",
                    &DeviceNode->InstancePath));

    //
    // Open the HKLM\System\CCS\Enum key.
    //

    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice:\tUnable to open HKLM\\SYSTEM\\CCS\\ENUM\n"));
        return status;
    }

    //
    // Open the instance key for this devnode
    //

    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   &DeviceNode->InstancePath,
                                   KEY_READ
                                   );

    ZwClose(enumKey);

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice:\t\tError %#08lx opening %wZ enum key\n",
                        status, &DeviceNode->InstancePath));
        return status;
    }
    //
    // Get the class value to locate the class key for this devnode
    //
    status = IopGetRegistryValue(instanceKey,
                                 REGSTR_VALUE_CLASSGUID,
                                 &keyValueInformation);
    if(NT_SUCCESS(status)) {

        if (    keyValueInformation->Type == REG_SZ &&
                keyValueInformation->DataLength) {

            IopRegistryDataToUnicodeString(
                &unicodeClassGuid,
                (PWSTR) KEY_VALUE_DATA(keyValueInformation),
                keyValueInformation->DataLength);
            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipCallDriverAddDevice:\t\tClass GUID is %wZ\n",
                            &unicodeClassGuid));
            if (InitSafeBootMode) {

                if (!IopSafebootDriverLoad(&unicodeClassGuid)) {

                    PKEY_VALUE_FULL_INFORMATION ClassValueInformation = NULL;
                    NTSTATUS s;
                    //
                    // don't load the driver
                    //
                    IopDbgPrint((IOP_ENUMERATION_WARNING_LEVEL,
                                 "SAFEBOOT: skipping device = %wZ\n", &unicodeClassGuid));

                    s = IopGetRegistryValue(instanceKey,
                                            REGSTR_VAL_DEVDESC,
                                            &ClassValueInformation);
                    if (NT_SUCCESS(s)) {

                        UNICODE_STRING ClassString;

                        RtlInitUnicodeString(&ClassString, (PCWSTR) KEY_VALUE_DATA(ClassValueInformation));
                        IopBootLog(&ClassString, FALSE);
                    } else {

                        IopBootLog(&unicodeClassGuid, FALSE);
                    }
                    ZwClose(instanceKey);
                    return STATUS_UNSUCCESSFUL;
                }
            }
            //
            // Open the class key
            //
            status = IopOpenRegistryKeyEx( &controlKey,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetControlClass,
                                           KEY_READ
                                           );
            if (NT_SUCCESS(status)) {

                status = IopOpenRegistryKeyEx( &classKey,
                                               controlKey,
                                               &unicodeClassGuid,
                                               KEY_READ
                                               );
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                    "PipCallDriverAddDevice:\tUnable to open GUID key "
                                    "%wZ - %#08lx\n",
                                    &unicodeClassGuid,status));
                }
                ZwClose(controlKey);
            } else {

                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipCallDriverAddDevice:\tUnable to open "
                                "HKLM\\SYSTEM\\CCS\\CONTROL\\CLASS - %#08lx\n",
                                status));
            }
            if (classKey != NULL) {

                UNICODE_STRING unicodeProperties;

                PiWstrToUnicodeString(&unicodeProperties, REGSTR_KEY_DEVICE_PROPERTIES );
                status = IopOpenRegistryKeyEx( &classPropsKey,
                                               classKey,
                                               &unicodeProperties,
                                               KEY_READ
                                               );
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                    "PipCallDriverAddDevice:\tUnable to open GUID\\Properties key "
                                    "%wZ - %#08lx\n",
                                    &unicodeClassGuid,status));
                }
            }
        }
        ExFreePool(keyValueInformation);
        keyValueInformation = NULL;
    }
    //
    // Check to see if there's a service assigned to this device node.  If
    // there's not then we can bail out without wasting too much time.
    //
    RtlZeroMemory(&queryContext, sizeof(queryContext));

    queryContext.DeviceNode = DeviceNode;
    queryContext.LoadDriver = LoadDriver;

    queryContext.AddContext = Context;

    RtlZeroMemory(queryTable, sizeof(queryTable));

    queryTable[0].QueryRoutine =
        (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
    queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
    queryTable[0].EntryContext = (PVOID) UIntToPtr(LowerDeviceFilters);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR) instanceKey,
                                    queryTable,
                                    &queryContext,
                                    NULL);
    if (NT_SUCCESS(status)) {

        if (classKey != NULL) {

            queryTable[0].QueryRoutine =
                (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
            queryTable[0].Name = REGSTR_VAL_LOWERFILTERS;
            queryTable[0].EntryContext = (PVOID) UIntToPtr(LowerClassFilters);
            status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                            (PWSTR) classKey,
                                            queryTable,
                                            &queryContext,
                                            NULL);
            if (!NT_SUCCESS(status)) {

                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipCallDriverAddDevice\t\tError %#08lx reading LowerClassFilters "
                                "value for %wZ\n", status, &DeviceNode->InstancePath));

            }
        }

        if (NT_SUCCESS(status)) {
            queryTable[0].QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
            queryTable[0].Name = REGSTR_VALUE_SERVICE;
            queryTable[0].EntryContext = (PVOID) UIntToPtr(DeviceService);
            queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;

            status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                            (PWSTR) instanceKey,
                                            queryTable,
                                            &queryContext,
                                            NULL);
            if (!NT_SUCCESS(status)) {

                IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                "PipCallDriverAddDevice\t\tError %#08lx reading service "
                                "value for %wZ\n", status, &DeviceNode->InstancePath));

            }
        }
    } else {

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice\t\tError %#08lx reading LowerDeviceFilters "
                        "value for %wZ\n", status, &DeviceNode->InstancePath));
    }

    if (DeviceNode->Flags & DNF_LEGACY_DRIVER) {

        //
        // One of the services for this device is a legacy driver.  Don't try
        // to add any filters since we'll just mess up the device stack.
        //

        status = STATUS_SUCCESS;
        goto Cleanup;

    } else if (NT_SUCCESS(status)) {

        //
        // Call was successful so we must have been able to reference the
        // driver object.
        //

        ASSERT(queryContext.DriverLists[DeviceService] != NULL);

        if (queryContext.DriverLists[DeviceService]->NextEntry != NULL) {

            //
            // There's more than one service assigned to this device.  Configuration
            // error
            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipCallDriverAddDevice: Configuration Error - more "
                            "than one service in driver list\n"));

            PipSetDevNodeProblem(DeviceNode, CM_PROB_REGISTRY);

            status = STATUS_UNSUCCESSFUL;

            goto Cleanup;
        }
        //
        // this is the only case (FDO specified) where we can ignore PDO's characteristics
        //
        usePdoCharacteristics = FALSE;

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        if (!IopDeviceNodeFlagsToCapabilities(DeviceNode)->RawDeviceOK) {

            //
            // The device cannot be used raw.  Bail out now.
            //

            status = STATUS_UNSUCCESSFUL;
            goto Cleanup;

        } else {

            //
            // Raw device access is okay.
            //

            PipClearDevNodeProblem(DeviceNode);

            usePdoCharacteristics = TRUE; // shouldn't need to do this, but better be safe than sorry
            deviceRaw = TRUE;
            status = STATUS_SUCCESS;

        }

    } else {

        //
        // something else went wrong while parsing the service key.  The
        // query routine will have set the flags appropriately so we can
        // just bail out.
        //

        goto Cleanup;

    }

    //
    // For each type of filter driver we want to build a list of the driver
    // objects to be loaded.  We'll build all the driver lists if we can
    // and deal with error conditions afterwards.
    //

     //
     // First get all the information we have to out of the instance key and
     // the device node.
     //

     RtlZeroMemory(queryTable, sizeof(queryTable));

     queryTable[0].QueryRoutine =
         (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
     queryTable[0].Name = REGSTR_VAL_UPPERFILTERS;
     queryTable[0].EntryContext = (PVOID) UIntToPtr(UpperDeviceFilters);
     status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                     (PWSTR) instanceKey,
                                     queryTable,
                                     &queryContext,
                                     NULL);

     if (NT_SUCCESS(status) && classKey) {
         queryTable[0].QueryRoutine =
             (PRTL_QUERY_REGISTRY_ROUTINE) PipCallDriverAddDeviceQueryRoutine;
         queryTable[0].Name = REGSTR_VAL_UPPERFILTERS;
         queryTable[0].EntryContext = (PVOID) UIntToPtr(UpperClassFilters);

         status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                         (PWSTR) classKey,
                                         queryTable,
                                         &queryContext,
                                         NULL);
    }

    if (NT_SUCCESS(status)) {

        UCHAR serviceType = 0;
        PDRIVER_LIST_ENTRY listEntry = queryContext.DriverLists[serviceType];

        //
        // Make sure there's no more than one device service.  Anything else is
        // a configuration error.
        //

        ASSERT(!(DeviceNode->Flags & DNF_LEGACY_DRIVER));

        ASSERTMSG(
            "Error - Device has no service but cannot be run RAW\n",
            ((queryContext.DriverLists[DeviceService] != NULL) || (deviceRaw)));

        //
        // Do preinit work.
        //
        fdoDeviceObject = NULL;
        topOfLowerFilterStack = NULL;
        topOfPdoStack = IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject);

        //
        // It's okay to try adding all the drivers.
        //
        for (serviceType = 0; serviceType < MaximumAddStage; serviceType++) {

            IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                            "PipCallDriverAddDevice: Adding Services (type %d)\n",
                            serviceType));

            if (serviceType == DeviceService) {

                topOfLowerFilterStack = IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject);

                if (deviceRaw && (queryContext.DriverLists[serviceType] == NULL)) {

                    //
                    // Mark the devnode as added, as it has no service.
                    //

                    ASSERT(queryContext.DriverLists[serviceType] == NULL);
                    PipSetDevNodeState(DeviceNode, DeviceNodeDriversAdded, NULL);

                } else {

                    //
                    // Since we are going to see a service, grab a pointer to
                    // the current top of the stack. While here, assert there
                    // is exactly one service driver to load...
                    //
                    ASSERT(queryContext.DriverLists[serviceType]);
                    ASSERT(!queryContext.DriverLists[serviceType]->NextEntry);
                }
            }

            for (listEntry = queryContext.DriverLists[serviceType];
                listEntry != NULL;
                listEntry = listEntry->NextEntry) {

                PDRIVER_ADD_DEVICE addDeviceRoutine;

                IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                "PipCallDriverAddDevice:\tAdding driver %#08lx\n",
                                listEntry->DriverObject));

                ASSERT(listEntry->DriverObject);
                ASSERT(listEntry->DriverObject->DriverExtension);
                ASSERT(listEntry->DriverObject->DriverExtension->AddDevice);

                //
                // Invoke the driver's AddDevice() entry point.
                //
                addDeviceRoutine =
                    listEntry->DriverObject->DriverExtension->AddDevice;

                status = PpvUtilCallAddDevice(
                    DeviceNode->PhysicalDeviceObject,
                    listEntry->DriverObject,
                    addDeviceRoutine,
                    VerifierTypeFromServiceType(serviceType)
                    );

                IopDbgPrint((   IOP_ENUMERATION_TRACE_LEVEL,
                                "PipCallDriverAddDevice:\t\tRoutine returned "
                                "%#08lx\n", status));

                if (NT_SUCCESS(status)) {

                   //
                   // If this is a service, mark the  it is legal for a filter to succeed AddDevice
                   // but fail to attach anything to the top of the stack.
                   //
                   if (serviceType == DeviceService) {

                       fdoDeviceObject = topOfLowerFilterStack->AttachedDevice;
                       ASSERT(fdoDeviceObject);
                   }

                   PipSetDevNodeState(DeviceNode, DeviceNodeDriversAdded, NULL);

                } else if (serviceType == DeviceService) {

                    //
                    // Mark the stack appropriately.
                    //
                    IovUtilMarkStack(
                        DeviceNode->PhysicalDeviceObject,
                        topOfPdoStack->AttachedDevice,
                        fdoDeviceObject,
                        FALSE
                        );

                    //
                    // If service fails, then add failed. (Alternately, if
                    // filter drivers return failure, we keep going.)
                    //
                    PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_FAILED_ADD);
                    status = STATUS_PNP_RESTART_ENUMERATION;
                    goto Cleanup;
                }

                if (IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject)->Flags & DO_DEVICE_INITIALIZING) {
                    IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                                    "***************** DO_DEVICE_INITIALIZING not cleared on %#08lx\n",
                                    IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject)));
                }

                ASSERT_INITED(IoGetAttachedDevice(DeviceNode->PhysicalDeviceObject));
            }
        }

        //
        // Mark the stack appropriately. We tell the verifier the stack is raw
        // if the fdo is NULL and we made it this far.
        //
        if ((fdoDeviceObject == NULL) || deviceRaw) {
            rawStack = TRUE;
        }
        else {
            rawStack = FALSE;
        }

        IovUtilMarkStack(
            DeviceNode->PhysicalDeviceObject,
            topOfPdoStack->AttachedDevice,
            fdoDeviceObject,
            rawStack
            );

        //
        // change PDO and all attached objects
        // to have properties specified in the registry
        //
        status = PipChangeDeviceObjectFromRegistryProperties(
                    DeviceNode->PhysicalDeviceObject, 
                    classPropsKey, 
                    instanceKey, 
                    usePdoCharacteristics
                    );
        if (!NT_SUCCESS(status)) {

            //
            // The registry properties are critical and we will assign a problem
            // to the device if there was some failure in applying those.
            //
            PipRequestDeviceRemoval(DeviceNode, 
                                    FALSE, 
                                    CM_PROB_SETPROPERTIES_FAILED
                                    );
            status = STATUS_PNP_RESTART_ENUMERATION;
            goto Cleanup;
        }
    } else {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipCallDriverAddDevice: Error %#08lx while building "
                        "driver load list\n", status));

        goto Cleanup;
    }

    deviceObject = DeviceNode->PhysicalDeviceObject;

    status = IopQueryLegacyBusInformation(
                 deviceObject,
                 NULL,
                 &DeviceNode->InterfaceType,
                 &DeviceNode->BusNumber
             );

    if (NT_SUCCESS(status)) {

        IopInsertLegacyBusDeviceNode(DeviceNode, 
                                     DeviceNode->InterfaceType, 
                                     DeviceNode->BusNumber
                                     );

    } else {

        DeviceNode->InterfaceType = InterfaceTypeUndefined;
        DeviceNode->BusNumber = 0xfffffff0;
    }

    status = STATUS_SUCCESS;

    ASSERT(DeviceNode->State == DeviceNodeDriversAdded);

Cleanup:
    {

        UCHAR i;

        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipCallDriverAddDevice: DevNode flags leaving = %#08lx\n",
                        DeviceNode->Flags));

        IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                        "PipCallDriverAddDevice: Cleaning up\n"));

        //
        // Free the entries in the driver load list & release the references on
        // their driver objects.
        //

        for (i = 0; i < MaximumAddStage; i++) {

            PDRIVER_LIST_ENTRY listHead = queryContext.DriverLists[i];

            while(listHead != NULL) {

                PDRIVER_LIST_ENTRY tmp = listHead;

                listHead = listHead->NextEntry;

                ASSERT(tmp->DriverObject != NULL);

                //
                // Let the driver unload if it hasn't created any device
                // objects. We only do this if the paging stack is already
                // online (the same filter may be needed by more than one card).
                // IopInitializeBootDrivers will take care of cleaning up any
                // leftover drivers after boot.
                //
                if (PnPBootDriversInitialized) {

                    IopUnloadAttachedDriver(tmp->DriverObject);
                }

                ObDereferenceObject(tmp->DriverObject);

                ExFreePool(tmp);
            }
        }
    }

    ZwClose(instanceKey);

    if (classKey != NULL) {
        ZwClose(classKey);
    }

    if (classPropsKey != NULL) {
        ZwClose(classPropsKey);
    }

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice: Returning status %#08lx\n", status));

    return status;
}

NTSTATUS
PipCallDriverAddDeviceQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PWCHAR ValueData,
    IN ULONG ValueLength,
    IN PQUERY_CONTEXT Context,
    IN ULONG ServiceType
    )

/*++

Routine Description:

    This routine is called to build a list of driver objects which need to
    be Added to a physical device object.  Each time it is called with a
    service name it will locate a driver object for that device and append
    it to the proper driver list for the device node.

    In the event a driver object cannot be located or that it cannot be loaded
    at this time, this routine will return an error and will set the flags
    in the device node in the context appropriately.

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - a structure which contains the device node, the context passed
              to PipCallDriverAddDevice and the driver lists for the device
              node.

    EntryContext - the index of the driver list the routine should append
                   nodes to.

Return Value:

    STATUS_SUCCESS if the driver was located and added to the list
    successfully or if there was a non-fatal error while handling the
    driver.

    an error value indicating why the driver could not be added to the list.

--*/

{
    UNICODE_STRING unicodeServiceName;
    UNICODE_STRING unicodeDriverName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG i;
    ULONG loadType;
    PWSTR prefixString = L"\\Driver\\";
    BOOLEAN madeupService;
    USHORT groupIndex;
    PDRIVER_OBJECT driverObject = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS driverEntryStatus;
    BOOLEAN freeDriverName = FALSE;
    HANDLE handle, serviceKey;
#if DBG
    PDRIVER_OBJECT tempDrvObj;
#endif

    UNREFERENCED_PARAMETER (ValueName);

    //
    // Preinit
    //
    serviceKey = NULL;

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice:\t\tValue %ws [Type %d, Len %d] @ "
                    "%#08lx\n",
                    ValueName, ValueType, ValueLength, ValueData));

    //
    // First check and make sure that the value type is okay.  An invalid type
    // is not a fatal error.
    //

    if (ValueType != REG_SZ) {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipCallDriverAddDevice:\t\tValueType %d invalid for "
                        "ServiceType %d\n",
                        ValueType,ServiceType));

        return STATUS_SUCCESS;
    }

    //
    // Make sure the string is a reasonable length.
    //

    if (ValueLength <= sizeof(WCHAR)) {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipCallDriverAddDevice:\t\tValueLength %d is too short\n",
                        ValueLength));

        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString(&unicodeServiceName, ValueData);

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice:\t\t\tService Name %wZ\n",
                    &unicodeServiceName));

    //
    // Check the service name to see if it should be used directly to reference
    // the driver object.  If the string begins with "\Driver", make sure the
    // madeupService flag is set.
    //

    madeupService = TRUE;
    i = 0;

    while(*prefixString != L'\0') {

        if (unicodeServiceName.Buffer[i] != *prefixString) {

            madeupService = FALSE;
            break;
        }

        i++;
        prefixString++;
    }

    //
    // Get the driver name from the service key. We need this to figure out
    // if the driver is already in memory.
    //
    if (madeupService) {

        RtlInitUnicodeString(&unicodeDriverName, unicodeServiceName.Buffer);

    } else {

        //
        // BUGBUG - (RBN) Hack to set the service name in the devnode if it
        //      isn't already set.
        //
        //      This probably should be done earlier somewhere else after the
        //      INF is run, but if we don't do it now we'll blow up when we
        //      call IopGetDriverLoadType below.
        //

        if (Context->DeviceNode->ServiceName.Length == 0) {

            Context->DeviceNode->ServiceName = unicodeServiceName;
            Context->DeviceNode->ServiceName.Buffer = ExAllocatePool( NonPagedPool,
                                                                      unicodeServiceName.MaximumLength );

            if (Context->DeviceNode->ServiceName.Buffer != NULL) {
                RtlCopyMemory( Context->DeviceNode->ServiceName.Buffer,
                               unicodeServiceName.Buffer,
                               unicodeServiceName.MaximumLength );
            } else {
                PiWstrToUnicodeString( &Context->DeviceNode->ServiceName, NULL );

                IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tCannot allocate memory for service name in devnode\n"));

                status = STATUS_UNSUCCESSFUL;

                goto Cleanup;
            }
        }

        //
        // Check in the registry to find the name of the driver object
        // for this device.
        //
        status = PipOpenServiceEnumKeys(&unicodeServiceName,
                                        KEY_READ,
                                        &serviceKey,
                                        NULL,
                                        FALSE);

        if (!NT_SUCCESS(status)) {

            //
            // Cannot open the service key for this driver.  This is a
            // fatal error.
            //

            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tStatus %#08lx "
                            "opening service key\n",
                            status));

            PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_REGISTRY);

            goto Cleanup;
        }

        status = IopGetDriverNameFromKeyNode(serviceKey, &unicodeDriverName);

        if (!NT_SUCCESS(status)) {

            //
            // Can't get the driver name from the service key.  This is a
            // fatal error.
            //

            IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tStatus %#08lx "
                            "getting driver name\n",
                            status));

            PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_REGISTRY);
            goto Cleanup;

        } else {

            freeDriverName = TRUE;
        }

        //
        // Note that we don't close the service key here. We may need it later.
        //
    }

    IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                    "PipCallDriverAddDevice:\t\t\tDriverName is %wZ\n",
                    &unicodeDriverName));

    driverObject = IopReferenceDriverObjectByName(&unicodeDriverName);

    if (driverObject == NULL) {

        //
        // We couldn't find a driver object.  It's possible the driver isn't
        // loaded & initialized so check to see if we can try to load it
        // now.
        //
        if (madeupService) {

            //
            // The madeup service's driver doesn't seem to exist yet.
            // We will fail the request without setting a problem code so
            // we will try it again later.  (Root Enumerated devices...)
            //
            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tCannot find driver "
                            "object for madeup service\n"));

            status = STATUS_UNSUCCESSFUL;

            goto Cleanup;
        }

        //
        // Get the start type. We always need this in case the service is
        // disabled. Default to SERVICE_DISABLED if the service's start type
        // is missing or corrupted.
        //
        loadType = SERVICE_DISABLED;

        status = IopGetRegistryValue(serviceKey, L"Start", &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if (keyValueInformation->Type == REG_DWORD) {
                if (keyValueInformation->DataLength == sizeof(ULONG)) {
                    loadType = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                }
            }
            ExFreePool(keyValueInformation);
        }

        if (ServiceType != DeviceService && !PnPBootDriversInitialized) {

            //
            // Get the group index. We need this because PipLoadBootFilterDriver
            // uses the group index as an index into it's internally sorted
            // list of loaded boot drivers.
            //
            groupIndex = PpInitGetGroupOrderIndex(serviceKey);

            //
            // If we are in BootDriverInitialization phase and trying to load a
            // filter driver
            //
            status = PipLoadBootFilterDriver(
                &unicodeDriverName,
                groupIndex,
                &driverObject
                );

            if (NT_SUCCESS(status)) {

                ASSERT(driverObject);
#if DBG
                tempDrvObj = IopReferenceDriverObjectByName(&unicodeDriverName);
                ASSERT(tempDrvObj == driverObject);
#else
                ObReferenceObject(driverObject);
#endif
            } else if (status != STATUS_DRIVER_BLOCKED &&
                       status != STATUS_DRIVER_BLOCKED_CRITICAL) {

                goto Cleanup;
            }

        } else {

            if (!Context->LoadDriver) {

                //
                // We're not supposed to try and load a driver - most likely our
                // disk drivers aren't initialized yet.  We need to stop the add
                // process but we can't mark the devnode as failed or we won't
                // be called again when we can load the drivers.
                //

                IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tNot allowed to load "
                                "drivers yet\n"));

                status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }

            if (loadType > Context->AddContext->DriverStartType) {

                if (loadType == SERVICE_DISABLED &&
                    !PipDoesDevNodeHaveProblem(Context->DeviceNode)) {
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DISABLED_SERVICE);
                }

                //
                // The service is either disabled or we are not at the right
                // time to load it.  Don't load it, but make sure we can get
                // called again.  If a service is marked as demand start, we
                // always load it.
                //

                IopDbgPrint((   IOP_ENUMERATION_INFO_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tService is disabled or not at right time to load it\n"));
                status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }

            //
            // Check in the registry to find the name of the driver object
            // for this device.
            //
            status = PipOpenServiceEnumKeys(&unicodeServiceName,
                                            KEY_READ,
                                            &handle,
                                            NULL,
                                            FALSE);

            if (!NT_SUCCESS(status)) {

                //
                // Cannot open the service key for this driver.  This is a
                // fatal error.
                //
                IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                                "PipCallDriverAddDevice:\t\t\tStatus %#08lx "
                                "opening service key\n",
                                status));

                //
                // Convert the status values into something more definite.
                //
                if (status != STATUS_INSUFFICIENT_RESOURCES) {

                    status = STATUS_ILL_FORMED_SERVICE_ENTRY;
                }

            } else {

                //
                // The handle we pass in here will be closed by IopLoadDriver.
                // Note that IopLoadDriver return success without actually
                // loading the driver. This happens in the safe mode boot case.
                //
                status = IopLoadDriver(
                    handle,
                    FALSE,
                    (ServiceType != DeviceService)? TRUE : FALSE,
                    &driverEntryStatus);

                //
                // Convert the status values into something more definite.
                //
                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_FAILED_DRIVER_ENTRY) {

                        //
                        // Preserve insufficient resources return by the driver
                        //
                        if (driverEntryStatus == STATUS_INSUFFICIENT_RESOURCES) {

                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }

                    } else if ((status != STATUS_INSUFFICIENT_RESOURCES) &&
                               (status != STATUS_PLUGPLAY_NO_DEVICE) &&
                               (status != STATUS_DRIVER_FAILED_PRIOR_UNLOAD) &&
                               (status != STATUS_DRIVER_BLOCKED) &&
                               (status != STATUS_DRIVER_BLOCKED_CRITICAL)) {

                        //
                        // Assume this happened because the driver could not be
                        // loaded.
                        //
                        //ASSERT(0);
                        status = STATUS_DRIVER_UNABLE_TO_LOAD;
                    }
                }

                if (PnPInitialized) {

                    IopCallDriverReinitializationRoutines();
                }
            }
            //
            // Try and get a pointer to the driver object for the service.
            //
            driverObject = IopReferenceDriverObjectByName(&unicodeDriverName);
            if (driverObject) {

                if (!NT_SUCCESS(status)) {
                    //
                    // The driver should not be in memory upon failure.
                    //
                    ASSERT(!driverObject);
                    ObDereferenceObject(driverObject);
                    driverObject = NULL;
                }
            } else {

                if (NT_SUCCESS(status)) {
                    //
                    // Driver was probably not loaded because of safe mode.
                    //
                    ASSERT(InitSafeBootMode);
                    status = STATUS_NOT_SAFE_MODE_DRIVER;
                }
            }
        }
    }
    //
    // If we still dont have a driver object, then something failed.
    //
    if (driverObject == NULL) {
        //
        // Apparently the load didn't work out very well.
        //
        ASSERT(!NT_SUCCESS(status));
        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PipCallDriverAddDevice:\t\t\tUnable to reference "
                     "driver %wZ (%x)\n", &unicodeDriverName, status));
        if (!PipDoesDevNodeHaveProblem(Context->DeviceNode)) {

            switch(status) {

                case STATUS_ILL_FORMED_SERVICE_ENTRY:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_SERVICE_KEY_INVALID);
                    break;

                case STATUS_INSUFFICIENT_RESOURCES:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_OUT_OF_MEMORY);
                    break;

                case STATUS_PLUGPLAY_NO_DEVICE:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_LEGACY_SERVICE_NO_DEVICES);
                    break;

                case STATUS_DRIVER_FAILED_PRIOR_UNLOAD:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD);
                    break;

                case STATUS_DRIVER_UNABLE_TO_LOAD:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_FAILED_LOAD);
                    break;

                case STATUS_FAILED_DRIVER_ENTRY:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_FAILED_DRIVER_ENTRY);
                    break;

                case STATUS_DRIVER_BLOCKED_CRITICAL:
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_DRIVER_BLOCKED);
                    Context->DeviceNode->Flags |= DNF_DRIVER_BLOCKED;
                    break;

                case STATUS_DRIVER_BLOCKED:
                    Context->DeviceNode->Flags |= DNF_DRIVER_BLOCKED;
                    status = STATUS_SUCCESS;
                    break;

                default:
                case STATUS_NOT_SAFE_MODE_DRIVER:
                    ASSERT(0);
                    PipSetDevNodeProblem(Context->DeviceNode, CM_PROB_FAILED_ADD);
                    break;
            }

            SAVE_FAILURE_INFO(Context->DeviceNode, status);

        } else {

            //
            // We're very curious - when does this happen?
            //
            ASSERT(0);
        }
        goto Cleanup;
    }

    if (!(driverObject->Flags & DRVO_INITIALIZED)) {
        ObDereferenceObject(driverObject);
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    IopDbgPrint((   IOP_ENUMERATION_VERBOSE_LEVEL,
                    "PipCallDriverAddDevice:\t\t\tDriver Reference %#08lx\n",
                    driverObject));

    //
    // Check to see if the driver is a legacy driver rather than a Pnp one.
    //
    if (IopIsLegacyDriver(driverObject)) {

        //
        // It is.  Since the legacy driver may have already obtained a
        // handle to the device object, we need to assume this device
        // has been added and started.
        //

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice:\t\t\tDriver is a legacy "
                        "driver\n"));

        if (ServiceType == DeviceService) {
            Context->DeviceNode->Flags |= DNF_LEGACY_DRIVER;

            PipSetDevNodeState(Context->DeviceNode, DeviceNodeStarted, NULL);

            status = STATUS_UNSUCCESSFUL;
        } else {

            //
            // We allow someone to plug in a legacy driver as a filter driver.
            // In this case, the legacy driver will be loaded but will not be part
            // of our pnp driver stack.
            //

            status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // There's a chance the driver detected this PDO during it's driver entry
    // routine.  If it did then just bail out.
    //
    if (Context->DeviceNode->State != DeviceNodeInitialized &&
        Context->DeviceNode->State != DeviceNodeDriversAdded) {

        IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                        "PipCallDriverAddDevice\t\t\tDevNode was reported "
                        "as detected during driver entry\n"));
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Add the driver to the list.
    //

    {
        PDRIVER_LIST_ENTRY listEntry;
        PDRIVER_LIST_ENTRY *runner = &(Context->DriverLists[ServiceType]);

        status = STATUS_SUCCESS;

        //
        // Allocate a new list entry to queue this driver object for the caller
        //

        listEntry = ExAllocatePool(PagedPool, sizeof(DRIVER_LIST_ENTRY));

        if (listEntry == NULL) {

            IopDbgPrint((   IOP_ENUMERATION_WARNING_LEVEL,
                            "PipCallDriverAddDevice:\t\t\tUnable to allocate list "
                            "entry\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        listEntry->DriverObject = driverObject;
        listEntry->NextEntry = NULL;

        while(*runner != NULL) {
            runner = &((*runner)->NextEntry);
        }

        *runner = listEntry;
    }

Cleanup:

    if (serviceKey) {

        ZwClose(serviceKey);
    }

    if (freeDriverName) {
        RtlFreeUnicodeString(&unicodeDriverName);
    }
    return status;
}

NTSTATUS
PiRestartDevice(
    IN PPI_DEVICE_REQUEST  Request
    )
{
    ADD_CONTEXT addContext;
    NTSTATUS status;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(Request->DeviceObject != NULL);
    deviceNode = (PDEVICE_NODE)Request->DeviceObject->DeviceObjectExtension->DeviceNode;
    if (PipIsDevNodeDeleted(deviceNode)) {

        return STATUS_DELETE_PENDING;

    } else if (PipDoesDevNodeHaveProblem(deviceNode)) {

        return STATUS_UNSUCCESSFUL;
    }

    switch(deviceNode->State) {

        case DeviceNodeStartPending:
            //
            // Not wired up today, but if the device is starting then we should
            // in theory defer completing this request until the IRP is
            // completed.
            //
            ASSERT(0);

            //
            // Fall through
            //

        case DeviceNodeStarted:
        case DeviceNodeQueryStopped:
        case DeviceNodeStopped:
        case DeviceNodeRestartCompletion:
        case DeviceNodeEnumeratePending:
            return STATUS_SUCCESS;

        case DeviceNodeInitialized:

            //
            // ISSUE - 2000/08/23 - AdriaO: Question,
            //     When this happens, isn't it a bug in user mode?
            //
            // Anyway, fall on through...
            //
            //ASSERT(0);

        case DeviceNodeRemoved:
            ASSERT(!(deviceNode->UserFlags & DNUF_WILL_BE_REMOVED));
            IopRestartDeviceNode(deviceNode);
            break;

        case DeviceNodeUninitialized:
        case DeviceNodeDriversAdded:
        case DeviceNodeResourcesAssigned:
        case DeviceNodeEnumerateCompletion:
        case DeviceNodeStartCompletion:
        case DeviceNodeStartPostWork:
            //
            // ISSUE - 2000/08/23 - AdriaO: Question,
            //     When this happens, isn't it a bug in user mode?
            //
            //ASSERT(0);
            break;

        case DeviceNodeAwaitingQueuedDeletion:
        case DeviceNodeAwaitingQueuedRemoval:
        case DeviceNodeQueryRemoved:
        case DeviceNodeRemovePendingCloses:
        case DeviceNodeDeletePendingCloses:
            return STATUS_UNSUCCESSFUL;

        case DeviceNodeDeleted:
        case DeviceNodeUnspecified:
        default:
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
    }

    if (Request->RequestType == StartDevice) {

        addContext.DriverStartType = SERVICE_DEMAND_START;

        ObReferenceObject(deviceNode->PhysicalDeviceObject);
        status = PipProcessDevNodeTree(
            deviceNode,
            PnPBootDriversInitialized,          // LoadDriver
            FALSE,                              // ReallocateResources
            EnumTypeNone,
            Request->CompletionEvent != NULL ? TRUE : FALSE,   // Synchronous
            FALSE,
            &addContext,
            Request);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipMakeGloballyUniqueId(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PWCHAR           UniqueId,
    OUT PWCHAR         *GloballyUniqueId
    )
{
    NTSTATUS status;
    ULONG length;
    PWSTR id, Prefix, end;
    HANDLE enumKey;
    HANDLE instanceKey;
    UCHAR keyBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION keyValue, stringValueBuffer;
    UNICODE_STRING valueName;
    ULONG uniqueIdValue, Hash, hashInstance, prefixSize;
    PDEVICE_NODE parentNode;

    PAGED_CODE();

    id = NULL;
    Prefix = NULL;
    stringValueBuffer = NULL;
    //
    // We need to build an instance id to uniquely identify this
    // device.  We will accomplish this by producing a prefix that will be
    // prepended to the non-unique device id supplied.
    //

    //
    // To 'unique-ify' the child's instance ID, we will retrieve
    // the unique "UniqueParentID" number that has been assigned
    // to the parent and use it to construct a prefix.  This is
    // the legacy mechanism supported here so that existing device
    // settings are not lost on upgrade.
    //

    PiLockPnpRegistry(FALSE);

    parentNode = ((PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode)->Parent;

    status = IopOpenRegistryKeyEx( &enumKey,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ | KEY_WRITE
                                   );

    if (!NT_SUCCESS(status)) {
        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipMakeGloballyUniqueId:\tUnable to open HKLM\\SYSTEM\\CCS\\ENUM (status %08lx)\n",
                        status));
        goto clean0;
    }

    //
    // Open the instance key for this devnode
    //
    status = IopOpenRegistryKeyEx( &instanceKey,
                                   enumKey,
                                   &parentNode->InstancePath,
                                   KEY_READ | KEY_WRITE
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((   IOP_ENUMERATION_ERROR_LEVEL,
                        "PipMakeGloballyUniqueId:\tUnable to open registry key for %wZ (status %08lx)\n",
                        &parentNode->InstancePath,
                        status));
        goto clean1;
    }

    //
    // Attempt to retrieve the "UniqueParentID" value from the device
    // instance key.
    //
    keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)keyBuffer;
    PiWstrToUnicodeString(&valueName, REGSTR_VALUE_UNIQUE_PARENT_ID);

    status = ZwQueryValueKey(instanceKey,
                             &valueName,
                             KeyValuePartialInformation,
                             keyValue,
                             sizeof(keyBuffer),
                             &length
                             );

    if (NT_SUCCESS(status)) {

        ASSERT(keyValue->Type == REG_DWORD);
        ASSERT(keyValue->DataLength == sizeof(ULONG));

        if ((keyValue->Type != REG_DWORD) ||
            (keyValue->DataLength != sizeof(ULONG))) {

            status = STATUS_INVALID_PARAMETER;
            goto clean2;
        }

        uniqueIdValue = *(PULONG)(keyValue->Data);
        //
        // OK, we have a unique parent ID number to prefix to the
        // instance ID.
        //
        prefixSize = 9 * sizeof(WCHAR);
        Prefix = (PWSTR)ExAllocatePool(PagedPool, prefixSize);
        if (!Prefix) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto clean2;
        }
        StringCbPrintfW(Prefix, prefixSize, L"%x", uniqueIdValue);
    } else {
        //
        // This is the current mechanism for finding existing
        // device instance prefixes and calculating new ones if
        // required.
        //
        //
        // Attempt to retrieve the "ParentIdPrefix" value from the device
        // instance key.
        //
        PiWstrToUnicodeString(&valueName, REGSTR_VALUE_PARENT_ID_PREFIX);
        length = (MAX_PARENT_PREFIX + 1) * sizeof(WCHAR) +
            FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
        stringValueBuffer = ExAllocatePool(PagedPool,
                                           length);
        if (stringValueBuffer) {

            status = ZwQueryValueKey(instanceKey,
                                     &valueName,
                                     KeyValuePartialInformation,
                                     stringValueBuffer,
                                     length,
                                     &length);
        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto clean2;
        }

        if (NT_SUCCESS(status)) {

            ASSERT(stringValueBuffer->Type == REG_SZ);

            if (stringValueBuffer->Type != REG_SZ) {

                status = STATUS_INVALID_PARAMETER;
                goto clean2;
            }
            //
            // Parent has already been assigned a "ParentIdPrefix".
            //
            prefixSize = stringValueBuffer->DataLength;
            Prefix = (PWSTR) ExAllocatePool(PagedPool,
                                            prefixSize);
            if (!Prefix) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean2;
            }
            StringCbCopyW(Prefix, prefixSize, (PWSTR)stringValueBuffer->Data);

        } else {
            //
            // Parent has not been assigned a "ParentIdPrefix".
            // Compute the prefix:
            //    * Compute Hash
            //    * Look for value of the form:
            //        NextParentId.<level>.<hash>:REG_DWORD: <NextInstance>
            //      under CCS\Enum.  If not present, create it.
            //    * Assign the new "ParentIdPrefix" which will be of
            //      of the form:
            //        <level>&<hash>&<instance>
            //

            // Allocate a buffer once for the NextParentId... value
            // and for the prefix.
            length = (ULONG)wcslen(REGSTR_VALUE_NEXT_PARENT_ID) + 2 + 8 + 8 + 1;
            if (length < MAX_PARENT_PREFIX + 1) {

                length = MAX_PARENT_PREFIX + 1;
            }
            //
            // Device instances are case in-sensitive.  Upcase before
            // performing hash to ensure that the hash is case-insensitve.
            //
            status = RtlUpcaseUnicodeString(&valueName,
                                            &parentNode->InstancePath,
                                            TRUE);
            if (!NT_SUCCESS(status)) {

                goto clean2;
            }
            HASH_UNICODE_STRING(&valueName, &Hash);
            RtlFreeUnicodeString(&valueName);

            prefixSize = length * sizeof(WCHAR);
            Prefix = (PWSTR) ExAllocatePool(PagedPool,
                                            prefixSize);
            if (!Prefix) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto clean2;
            }

            // Check for existence of "NextParentId...." value and update.
            StringCbPrintfW(Prefix, prefixSize, L"%s.%x.%x", REGSTR_VALUE_NEXT_PARENT_ID,
                     Hash, parentNode->Level);
            RtlInitUnicodeString(&valueName, Prefix);
            keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)keyBuffer;
            status = ZwQueryValueKey(enumKey,
                                     &valueName,
                                     KeyValuePartialInformation,
                                     keyValue,
                                     sizeof(keyBuffer),
                                     &length
                                     );
            if (NT_SUCCESS(status) && (keyValue->Type == REG_DWORD) &&
                (keyValue->DataLength == sizeof(ULONG))) {

                hashInstance = *(PULONG)(keyValue->Data);
            } else {

                hashInstance = 0;
            }

            hashInstance++;

            status = ZwSetValueKey(enumKey,
                                   &valueName,
                                   TITLE_INDEX_VALUE,
                                   REG_DWORD,
                                   &hashInstance,
                                   sizeof(hashInstance)
                                   );
            if (!NT_SUCCESS(status)) {

                goto clean2;
            }

            hashInstance--;
            //
            // Create actual ParentIdPrefix string
            //
            PiWstrToUnicodeString(&valueName, REGSTR_VALUE_PARENT_ID_PREFIX);
            StringCchPrintfExW(
                Prefix, 
                prefixSize / sizeof(WCHAR), 
                &end, 
                NULL, 
                0, 
                L"%x&%x&%x", 
                parentNode->Level,
                Hash, 
                hashInstance);
            length = (ULONG)(end - Prefix) + 1;
            status = ZwSetValueKey(instanceKey,
                                   &valueName,
                                   TITLE_INDEX_VALUE,
                                   REG_SZ,
                                   Prefix,
                                   length * sizeof(WCHAR)
                                   );
            if (!NT_SUCCESS(status)) {

                goto clean2;
            }
        }
    }
    //
    // Construct the instance id from the non-unique id (if any)
    // provided by the child and the prefix we've constructed.
    //
    length = (ULONG)(wcslen(Prefix) + (UniqueId ? wcslen(UniqueId) : 0) + 2);
    id = (PWSTR)ExAllocatePool(PagedPool, length * sizeof(WCHAR));
    if (!id) {

        status = STATUS_INSUFFICIENT_RESOURCES;
    } else if (UniqueId) {

        StringCchPrintfW(id, length, L"%s&%s", Prefix, UniqueId);
    } else {

        StringCchCopyW(id, length, Prefix);
    }

clean2:
    ZwClose(instanceKey);

clean1:
    ZwClose(enumKey);

clean0:
    PiUnlockPnpRegistry();

    if (stringValueBuffer) {

        ExFreePool(stringValueBuffer);
    }

    if (Prefix) {

        ExFreePool(Prefix);
    }

    *GloballyUniqueId = id;

    return status;
}

BOOLEAN
PipGetRegistryDwordWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey,
    IN OUT PULONG Value
    )
/*++

Routine Description:

    If
        (1) Primary key has a value named "ValueName" that is REG_DWORD, return it
    Else If
        (2) Secondary key has a value named "ValueName" that is REG_DWORD, return it
    Else
        (3) Leave Value untouched and return error

Arguments:

    ValueName          - Unicode name of value to query
    PrimaryKey         - If non-null, check this first
    SecondaryKey       - If non-null, check this second
    Value              - IN = default value, OUT = actual value

Return Value:

    TRUE if value found

--*/
{
    PKEY_VALUE_FULL_INFORMATION info;
    PUCHAR data;
    NTSTATUS status;
    HANDLE Keys[3];
    int count = 0;
    int index;
    BOOLEAN set = FALSE;

    if (PrimaryKey != NULL) {
        Keys[count++] = PrimaryKey;
    }
    if (SecondaryKey != NULL) {
        Keys[count++] = SecondaryKey;
    }
    Keys[count] = NULL;

    for (index = 0; index < count && !set; index ++) {
        info = NULL;
        try {
            status = IopGetRegistryValue(Keys[index],
                                         valueName->Buffer,
                                         &info);
            if (NT_SUCCESS(status) && info->Type == REG_DWORD) {
                data = ((PUCHAR) info) + info->DataOffset;
                *Value = *((PULONG) data);
                set = TRUE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // do nothing
            //
        }
        if (info) {
            ExFreePool(info);
        }
    }
    return set;
}

PSECURITY_DESCRIPTOR
PipGetRegistrySecurityWithFallback(
    IN     PUNICODE_STRING valueName,
    IN     HANDLE PrimaryKey,
    IN     HANDLE SecondaryKey
    )
/*++

Routine Description:

    If
        (1) Primary key has a binary value named "ValueName" that is
        REG_BINARY and appears to be a valid security descriptor, return it
    Else
        (2) do same for Secondary key
    Else
        (3) Return NULL

Arguments:

    ValueName          - Unicode name of value to query
    PrimaryKey         - If non-null, check this first
    SecondaryKey       - If non-null, check this second

Return Value:

    Security Descriptor if found, else NULL

--*/
{
    PKEY_VALUE_FULL_INFORMATION info;
    PUCHAR data;
    NTSTATUS status;
    HANDLE Keys[3];
    int count = 0;
    int index;
    BOOLEAN set = FALSE;
    PSECURITY_DESCRIPTOR secDesc = NULL;
    PSECURITY_DESCRIPTOR allocDesc = NULL;

    if (PrimaryKey != NULL) {
        Keys[count++] = PrimaryKey;
    }
    if (SecondaryKey != NULL) {
        Keys[count++] = SecondaryKey;
    }
    Keys[count] = NULL;

    for (index = 0; index < count && !set; index ++) {
        info = NULL;
        try {
            status = IopGetRegistryValue(Keys[index],
                                         valueName->Buffer,
                                         &info);
            if (NT_SUCCESS(status) && info->Type == REG_BINARY) {
                data = ((PUCHAR) info) + info->DataOffset;
                secDesc = (PSECURITY_DESCRIPTOR)data;
                status = SeCaptureSecurityDescriptor(secDesc,
                                             KernelMode,
                                             PagedPool,
                                             TRUE,
                                             &allocDesc);
                if (NT_SUCCESS(status)) {
                    set = TRUE;
                }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // do nothing
            //
        }
        if (info) {
            ExFreePool(info);
        }
    }
    if (set) {
        return allocDesc;
    }
    return NULL;
}

#if FAULT_INJECT_SETPROPERTIES
//
// Fault injection for invalid IDs
//
ULONG PiFailSetProperties = 0;
#endif

NTSTATUS
PipChangeDeviceObjectFromRegistryProperties(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN HANDLE DeviceClassPropKey,
    IN HANDLE DeviceInstanceKey,
    IN BOOLEAN UsePdoCharacteristics
    )
/*++

Routine Description:

    This routine will obtain settings from either
    (1) DevNode settings (via DeviceInstanceKey) or
    (2) Class settings (via DeviceClassPropKey)
    applying to PDO and all attached device objects

    Properties set/ changed are:

        * DeviceType - the I/O system type for the device object
        * DeviceCharacteristics - the I/O system characteristic flags to be
                                  set for the device object
        * Exclusive - the device can only be accessed exclusively
        * Security - security for the device

    The routine will then use the DeviceType and DeviceCharacteristics specified
    to determine whether a VPB should be allocated as well as to set default
    security if none is specified in the registry.

Arguments:

    PhysicalDeviceObject - the PDO we are to configure

    DeviceClassPropKey - a handle to Control\<Class>\Properties protected key
    DeviceInstanceKey      - a handle to Enum\<Instance>  protected key

Return Value:

    status

--*/
{
    UNICODE_STRING valueName;
    NTSTATUS status;
    BOOLEAN deviceTypeSpec;
    BOOLEAN characteristicsSpec;
    BOOLEAN exclusiveSpec;
    BOOLEAN defaultSecurity;
    UCHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    SECURITY_INFORMATION securityInformation;
    PSECURITY_DESCRIPTOR securityDescriptor;
    PACL allocatedAcl;
    ULONG deviceType;
    ULONG characteristics;
    ULONG exclusive;
    ULONG prevCharacteristics;
    PDEVICE_OBJECT StackIterator;
    PDEVICE_NODE deviceNode;
    PSID sid;
    PACL acl;
    BOOLEAN present, tmp, hasName;

    PAGED_CODE();

    //
    // Sanity check inputs.
    //
    ASSERT(PhysicalDeviceObject);
    
    deviceNode = PP_DO_TO_DN(PhysicalDeviceObject);
    ASSERT(deviceNode);

    IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                 "PipChangeDeviceObjectFromRegistryProperties: Modifying device stack for PDO: %wZ\n", 
                 &deviceNode->InstancePath
                 ));

    //
    // Initialize locals so we can cleanup properly on exit.
    //
    securityDescriptor = NULL;
    defaultSecurity = FALSE;
    allocatedAcl = NULL;

    //
    // Get the device type, characteristics and exclusive properties specified 
    // in the registry (typically installed via an INF). DeviceInstanceKey is 
    // preferred over DeviceClassPropKey.
    //
    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_TYPE);
    deviceTypeSpec = PipGetRegistryDwordWithFallback(&valueName,
                                                     DeviceInstanceKey, 
                                                     DeviceClassPropKey, 
                                                     &deviceType
                                                     );
    if (!deviceTypeSpec) {

        deviceType = 0;
    }

    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_EXCLUSIVE);
    exclusiveSpec = PipGetRegistryDwordWithFallback(&valueName, 
                                                    DeviceInstanceKey, 
                                                    DeviceClassPropKey, 
                                                    &exclusive
                                                    );
    if (!exclusiveSpec) {

        exclusive = 0;
    }

    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_CHARACTERISTICS);
    characteristicsSpec = PipGetRegistryDwordWithFallback(&valueName, 
                                                          DeviceInstanceKey, 
                                                          DeviceClassPropKey, 
                                                          &characteristics
                                                          );
    if (!characteristicsSpec) {

        characteristics = 0;
    }

    //
    // Build the characteristics for the entire stack. Unless specified or RAW, 
    // PDO characteristics are ignored.
    //
    if (UsePdoCharacteristics || PhysicalDeviceObject->AttachedDevice == NULL) {

        //
        // Use the PDO.
        //
        StackIterator = PhysicalDeviceObject;
        IopDbgPrint((IOP_ENUMERATION_WARNING_LEVEL,
                     "PipChangeDeviceObjectFromRegistryProperties: Assuming PDO is being used RAW\n"
                     ));
    } else {

        //
        // Skip the PDO.
        //
        StackIterator = PhysicalDeviceObject->AttachedDevice;
        IopDbgPrint((IOP_ENUMERATION_VERBOSE_LEVEL,
                     "PipChangeDeviceObjectFromRegistryProperties: Ignoring PDO's settings\n"
                     ));
    }

    //
    // Build the mask of device stack characteristics.
    //
    prevCharacteristics = 0;
    for (; 
         StackIterator != NULL; 
         StackIterator = StackIterator->AttachedDevice) {

        prevCharacteristics |= StackIterator->Characteristics;
    }

    //
    // Build the new characteristics mask.
    //
    characteristics |= prevCharacteristics;
    characteristics &= FILE_CHARACTERISTICS_PROPAGATED;

    //
    // Get the security descriptor specified in the registry (typically 
    // installed via an INF). DeviceInstanceKey is preferred over DeviceClassPropKey.
    //
    securityInformation = 0;
    PiWstrToUnicodeString(&valueName, REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR);
    securityDescriptor = PipGetRegistrySecurityWithFallback(&valueName, 
                                                            DeviceInstanceKey, 
                                                            DeviceClassPropKey
                                                            );
    if (securityDescriptor == NULL) {

        //
        // If the registry specifies a device type but no security descriptor, 
        // we will create a default one for the specified device type.
        //
        if (deviceTypeSpec) {

            if (PhysicalDeviceObject->Flags & DO_DEVICE_HAS_NAME) {

                hasName = TRUE;
            } else {

                hasName = FALSE;
            }
            securityDescriptor = IopCreateDefaultDeviceSecurityDescriptor(
                                    (DEVICE_TYPE)deviceType,
                                    characteristics,
                                    hasName,
                                    &buffer[0],
                                    &allocatedAcl,
                                    &securityInformation
                                    );
            if (securityDescriptor) {

                defaultSecurity = TRUE; // forced default security descriptor
            } else {

                IopDbgPrint((IOP_ENUMERATION_WARNING_LEVEL,
                             "PipChangeDeviceObjectFromRegistryProperties: Was not able to get default security descriptor\n"
                             ));

                status = STATUS_UNSUCCESSFUL;
                goto cleanup;
            }
        }
    } else {

        //
        // See what information is in the captured descriptor so we can build
        // up a securityInformation block to go with it.
        //
        status = RtlGetOwnerSecurityDescriptor(securityDescriptor, &sid, &tmp);
        if (!NT_SUCCESS(status)) {

            goto cleanup;
        }

        if (sid) {

            securityInformation |= OWNER_SECURITY_INFORMATION;
        }

        status = RtlGetGroupSecurityDescriptor(securityDescriptor, &sid, &tmp);
        if (!NT_SUCCESS(status)) {

            goto cleanup;
        }

        if (sid) {

            securityInformation |= GROUP_SECURITY_INFORMATION;
        }

        status = RtlGetSaclSecurityDescriptor(securityDescriptor,
                                              &present,
                                              &acl,
                                              &tmp
                                              );
        if (!NT_SUCCESS(status)) {

            goto cleanup;
        }
        if (present) {

            securityInformation |= SACL_SECURITY_INFORMATION;
        }

        status = RtlGetDaclSecurityDescriptor(securityDescriptor,
                                              &present,
                                              &acl,
                                              &tmp
                                              );
        if (!NT_SUCCESS(status)) {

            goto cleanup;
        }
        if (present) {

            securityInformation |= DACL_SECURITY_INFORMATION;
        }
    }

#if DBG
    if (    deviceTypeSpec == FALSE && 
            characteristicsSpec == FALSE && 
            exclusiveSpec == FALSE && 
            securityDescriptor == NULL) {

        IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                    "PipChangeDeviceObjectFromRegistryProperties: No property changes\n"
                     ));
    } else {

        if (deviceTypeSpec) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PipChangeDeviceObjectFromRegistryProperties: Overide DeviceType=%08x\n",
                         deviceType
                         ));
        }

        if (characteristicsSpec) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PipChangeDeviceObjectFromRegistryProperties: Overide DeviceCharacteristics=%08x\n",
                         characteristics
                         ));
        }

        if (exclusiveSpec) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PipChangeDeviceObjectFromRegistryProperties: Overide Exclusive=%d\n",
                         (exclusive ? 1 : 0)
                         ));
        }

        if (defaultSecurity) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PipChangeDeviceObjectFromRegistryProperties: Overide Security based on DeviceType & DeviceCharacteristics\n"
                         ));
        }

        if (securityDescriptor == NULL) {

            IopDbgPrint((IOP_ENUMERATION_INFO_LEVEL,
                         "PipChangeDeviceObjectFromRegistryProperties: Overide Security\n"
                         ));
        }
    }
#endif

    //
    // Modify PDO properties.
    //
    if (deviceTypeSpec) {

        PhysicalDeviceObject->DeviceType = deviceType;
    }

    if (exclusiveSpec) {

        if (exclusive) {
            //
            // Exclusivity flag applies only to the PDO.
            // If any other object in the stack is named, then this flag should 
            // not be relied upon.
            //
            PhysicalDeviceObject->Flags |= DO_EXCLUSIVE;
        }
    }

    //
    // PDO may lose some characteristics (and get some new) based on what the 
    // rest of the stack specify. 
    //
    PhysicalDeviceObject->Characteristics &= ~FILE_CHARACTERISTICS_PROPAGATED;
    PhysicalDeviceObject->Characteristics |= characteristics;

    //
    // Apply the same characteristics to the entire stack. This will always add 
    // characteristics since the mask is a superset of characteristics of each 
    // object in the stack.
    //
    for (   StackIterator = PhysicalDeviceObject->AttachedDevice;
            StackIterator != NULL;
            StackIterator = StackIterator->AttachedDevice) {

        StackIterator->Characteristics |= characteristics;
    }

    //
    // Apply the security descriptor, if any, to the whole stack.
    //
    status = STATUS_SUCCESS;
    if (securityDescriptor != NULL) {

        status = ObSetSecurityObjectByPointer(PhysicalDeviceObject,
                                              securityInformation,
                                              securityDescriptor);
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PipChangeDeviceObjectFromRegistryProperties: Set security failed (%08x)\n",
                         status
                         ));
        }
    }

cleanup:

    //
    // Cleanup.
    //
    if ((securityDescriptor != NULL) && !defaultSecurity) {

        ExFreePool(securityDescriptor);
    }

    if (allocatedAcl) {

        ExFreePool(allocatedAcl);
    }

#if FAULT_INJECT_SETPROPERTIES

    if (NT_SUCCESS(status)) {

        static LARGE_INTEGER seed = {0};

        if(seed.LowPart == 0) {

            KeQuerySystemTime(&seed);
        }

        if(PnPBootDriversInitialized && 
           PiFailSetProperties && 
           RtlRandom(&seed.LowPart) % 10 > 5) {

            status = STATUS_UNSUCCESSFUL;
        }
    }

#endif


    return status;
}

NTSTATUS
PipProcessDevNodeTree(
    IN  PDEVICE_NODE        SubtreeRootDeviceNode,
    IN  BOOLEAN             LoadDriver,
    IN  BOOLEAN             ReallocateResources,
    IN  ENUM_TYPE           EnumType,
    IN  BOOLEAN             Synchronous,
    IN  BOOLEAN             ProcessOnlyIntermediateStates,
    IN  PADD_CONTEXT        AddContext,
    IN PPI_DEVICE_REQUEST   Request
    )
/*--

Routine Description:

    This function is called to handle state transitions related to starting
    Devnodes.  The basic sequence of operations is inheritted from the previous
    implementation.

    Resources freed
        1)  Allocate resources to all candidates in the tree.
        2)  Traverse the tree searching for a Devnodes ready to be started.
        3)  Start the Devnode.
        4)  Enumerate its children.
        5)  Initialize all the children up to the point of resource allocation.
        6)  Continue searching for DevNodes to start, if one is found return to
            step 3.
        7)  Once the entire tree is processed start over at step 1 until either
            no children are enumerated or no resources are allocated.

    A Devnode's resource requirements change
        If the Devnode wasn't started then treat it the same as the Resources
        freed case.  If it was started then it would have been handled directly
        by our caller.


    Start Devnodes during boot
        1)  Allocate resources to all candidates in the tree (based on
            IopBootConfigsReserved).
        2)  Traverse the tree searching for Devnodes ready to be started.
        3)  Start the Devnode.
        4)  Enumerate its children.
        5)  Initialize all the children up to the point of resource allocation.
        6)  Continue searching for DevNodes to start, if one is found return to
            step 3.

    Devnode newly created by user-mode.
        1)  Reset Devnode to uninitialized state.
        2)  Process Devnode to DeviceNodeDriversAdded state.
        3)  Allocate resources to this Devnode.
        4)  Start the Devnode.
        5)  Enumerate its children.
        6)  Initialize any children up to the point of resource allocation.
        7)  Allocate resources to all candidates in the tree below the initial
            Devnode.
        8)  Traverse the tree starting at the initial Devnode searching for
            a Devnode ready to be started.
        9)  Start the Devnode.
        10) Enumerate its children.
        11) Initialize all the children up to the point of resource allocation.
        12) Start over at step 7 until either no children are enumerated or no
            resources are allocated.

    Device node newly created by IoReportDetectedDevice.
        1)  Do post start IRP processing
        2)  Continue from step 5 of the process for Devnodes newly created by
            user-mode.

    Reenumeration of a single Devnode (and processing of changes resulting from
    that enumeration)

        1)  Enumerate Devnode's children
        2)  Initialize any children up to the point of resource allocation.
        3)  Allocate resources to all candidates in the tree below the initial
            Devnode.
        4)  Traverse the tree starting at the initial Devnode searching for
            a Devnode ready to be started.
        5)  Start the Devnode.
        6)  Enumerate its children.
        7)  Initialize all the children up to the point of resource allocation.
        8)  Start over at step 3 until either no children are enumerated or no
            resources are allocated.

    Reenumeration of a subtree.




Parameters:

    SubtreeRootDeviceNode - Root of this tree walk. Depending on the
                            ProcessOnlyIntermediaryStates parameter, the
                            PDO for this devnode may need to be referenced.

    LoadDriver - Indicates whether drivers should be loaded on this pass
                 (typically TRUE unless boot drivers aren't yet ready)

    ReallocateResources - TRUE iff resource reallocation should be attempted.

    EnumType - Specifies type of enumeration.

    Synchronous - TRUE iff the operation should be performed synchronously
                  (always TRUE currently)

    ProcessOnlyIntermediateStates - TRUE if only intermediary states should be
                                    processed. If FALSE, the caller places
                                    a reference on the PDO that this routine
                                    will drop.

    AddContext - Constraints for AddDevice

    Request - Device action worker that triggered this processing.

Return Value:

    NTSTATUS - Note: Always successful if ProcessOnlyIntermediaryStates is TRUE.

++*/
{
    PDEVICE_NODE    currentNode;
    PDEVICE_NODE    startRoot;
    PDEVICE_NODE    enumeratedBus;
    PDEVICE_NODE    originalSubtree;
    BOOLEAN         processComplete;
    BOOLEAN         newDevice;
    BOOLEAN         rebalancePerformed;
    NTSTATUS        status;
    ULONG           reenumAttempts;

    enum {
        SameNode,
        SiblingNode,
        ChildNode
    } nextNode;

    PAGED_CODE();

    originalSubtree     = SubtreeRootDeviceNode;
    //
    // Collapse enum requests if appropriate.
    //
    if (Request && !Request->ReorderingBarrier &&
        EnumType != EnumTypeShallow && !ProcessOnlyIntermediateStates) {

        if (PiCollapseEnumRequests(&Request->ListEntry)) {

            SubtreeRootDeviceNode = IopRootDeviceNode;
        }
    }

    reenumAttempts      = 0;
    startRoot           = NULL;
    enumeratedBus       = NULL;
    processComplete     = FALSE;
    newDevice           = TRUE;

    while (newDevice) {

        newDevice = FALSE;
        if (!ProcessOnlyIntermediateStates) {

            //
            // Process the whole device tree to assign resources to those devices
            // who have been successfully added to their drivers.
            //

            rebalancePerformed = FALSE;
            newDevice = IopProcessAssignResources( SubtreeRootDeviceNode,
                                                   ReallocateResources,
                                                   &rebalancePerformed);
            if (rebalancePerformed == TRUE) {

                //
                // Before we do any other processing, we need to restart
                // all rebalance participants.
                //

                status = PipProcessDevNodeTree(  IopRootDeviceNode,
                                                 LoadDriver,
                                                 FALSE,
                                                 EnumType,
                                                 Synchronous,
                                                 TRUE,
                                                 AddContext,
                                                 Request);

                ASSERT(NT_SUCCESS(status));
            }
        }

        if (processComplete && !newDevice) {

            break;
        }

        //
        // Process the entire subtree.
        //

        currentNode = SubtreeRootDeviceNode;
        processComplete = FALSE;
        while (!processComplete) {

            //
            // Dont process devnodes with problem.
            //

            status      = STATUS_SUCCESS;
            nextNode    = SiblingNode;
            if (!PipDoesDevNodeHaveProblem(currentNode)) {

                switch (currentNode->State) {

                case DeviceNodeUninitialized:

                    if (!ProcessOnlyIntermediateStates) {

                        if (currentNode->Parent == enumeratedBus && startRoot == NULL) {

                            startRoot = currentNode;
                        }
                        if((!ReallocateResources && EnumType == EnumTypeNone) || startRoot) {

                            status = PiProcessNewDeviceNode(currentNode);
                            if (NT_SUCCESS(status)) {

                                nextNode = SameNode;
                            }
                        }
                    }
                    break;

                case DeviceNodeInitialized:

                    if (!ProcessOnlyIntermediateStates) {

                        if (!ReallocateResources || startRoot) {

                            status = PipCallDriverAddDevice( currentNode,
                                                             LoadDriver,
                                                             AddContext);
                            if (NT_SUCCESS(status)) {

                                nextNode = SameNode;
                                newDevice = TRUE;
                            }
                        }
                    }
                    break;

                case DeviceNodeResourcesAssigned:

                    if (!ProcessOnlyIntermediateStates) {

                        if (ReallocateResources && startRoot == NULL) {

                            //
                            // If we assigned resources to this previously
                            // conflicting devnode, remember him so that we will
                            // initial processing on devices in that subtree.
                            //

                            startRoot = currentNode;
                        }

                        status = PipProcessStartPhase1(currentNode, Synchronous);

                        if (NT_SUCCESS(status)) {
                            nextNode = SameNode;
                        } else {

                            //
                            // Cleanup is currently handled in the
                            // DeviceNodeStartCompletion phase, thus
                            // PipProcessStartPhase1 should always succeed.
                            //
                            ASSERT(0);
                            nextNode = SiblingNode;
                        }

                    } else {
                        nextNode = SiblingNode;
                    }
                    break;

                case DeviceNodeStartCompletion:

                    status = PipProcessStartPhase2(currentNode);

                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        status = STATUS_PNP_RESTART_ENUMERATION;
                        ASSERT(currentNode->State != DeviceNodeStartCompletion);
                    }
                    break;

                case DeviceNodeStartPostWork:

                    status = PipProcessStartPhase3(currentNode);

                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        status = STATUS_PNP_RESTART_ENUMERATION;
                        ASSERT(!ProcessOnlyIntermediateStates);
                    }
                    break;

                case DeviceNodeStarted:

                    nextNode = ChildNode;
                    if (!ProcessOnlyIntermediateStates) {

                        if ((currentNode->Flags & DNF_REENUMERATE)) {

                            status = PipEnumerateDevice(currentNode, Synchronous);
                            if (NT_SUCCESS(status)) {

                                //
                                // Remember the bus we just enumerated.
                                //

                                enumeratedBus = currentNode;
                                nextNode = SameNode;

                            } else if (status == STATUS_PENDING) {

                                nextNode = SiblingNode;
                            }
                        }
                    }
                    break;

                case DeviceNodeEnumerateCompletion:

                    status = PipEnumerateCompleted(currentNode);
                    nextNode = ChildNode;
                    break;

                case DeviceNodeStopped:
                    status = PipProcessRestartPhase1(currentNode, Synchronous);
                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        //
                        // Cleanup is currently handled in the
                        // DeviceNodeStartCompletion phase, thus
                        // PipProcessRestartPhase1 should always succeed.
                        //
                        ASSERT(0);
                        nextNode = SiblingNode;
                    }
                    break;

                case DeviceNodeRestartCompletion:

                    status = PipProcessRestartPhase2(currentNode);
                    if (NT_SUCCESS(status)) {
                        nextNode = SameNode;
                    } else {
                        status = STATUS_PNP_RESTART_ENUMERATION;
                        ASSERT(currentNode->State != DeviceNodeRestartCompletion);
                    }
                    break;

                case DeviceNodeDriversAdded:
                case DeviceNodeAwaitingQueuedDeletion:
                case DeviceNodeAwaitingQueuedRemoval:
                case DeviceNodeRemovePendingCloses:
                case DeviceNodeRemoved:
                    nextNode = SiblingNode;
                    break;

                case DeviceNodeStartPending:
                case DeviceNodeEnumeratePending:
                case DeviceNodeQueryStopped:
                case DeviceNodeQueryRemoved:
                case DeviceNodeDeletePendingCloses:
                case DeviceNodeDeleted:
                case DeviceNodeUnspecified:
                default:
                    ASSERT(0);
                    nextNode = SiblingNode;
                    break;
                }
            }

            //
            // If we need to wait for the queued removals to complete before
            // we progress,we need to do the following:
            // 1. capture the instance paths for all the parents of the current
            // node upto the subtree root where we started
            // 2. drop the reference to the subtree root allowing it to be
            // deleted (if required)
            // 3. drop the tree lock
            // 4. wait for the removal queue to empty
            // 5. re-acquire the tree lock
            // 6. resume processing
            //

            if (status == STATUS_PNP_RESTART_ENUMERATION &&
                !ProcessOnlyIntermediateStates) {

                PDEVICE_OBJECT  entryDeviceObject;
                UNICODE_STRING  unicodeName;
                PWCHAR          devnodeList;
                PWCHAR          currentEntry;
                PWCHAR          rootEntry;
                WCHAR           buffer[MAX_INSTANCE_PATH_LENGTH];

                status = PipProcessDevNodeTree( IopRootDeviceNode,
                                                LoadDriver,
                                                ReallocateResources,
                                                EnumType,
                                                Synchronous,
                                                TRUE,
                                                AddContext,
                                                Request);

                ASSERT(NT_SUCCESS(status));

                PipAssertDevnodesInConsistentState();

                if (++reenumAttempts < MAX_REENUMERATION_ATTEMPTS) {

                    devnodeList = ExAllocatePool( PagedPool,
                                                  (currentNode->Level + 1) * MAX_INSTANCE_PATH_LENGTH * sizeof(WCHAR));
                    if (devnodeList) {

                        currentEntry = devnodeList;

                        for ( ; ; ) {

                            rootEntry = currentEntry;

                            ASSERT(currentNode->InstancePath.Length < MAX_INSTANCE_PATH_LENGTH);

                            RtlCopyMemory( currentEntry,
                                    currentNode->InstancePath.Buffer,
                                    currentNode->InstancePath.Length );

                            currentEntry += currentNode->InstancePath.Length / sizeof(WCHAR);
                            *currentEntry++ = UNICODE_NULL;

                            if (currentNode == SubtreeRootDeviceNode) {
                                break;
                            }

                            currentNode = currentNode->Parent;
                        }
                    } else {

                        ASSERT(SubtreeRootDeviceNode->InstancePath.Length < MAX_INSTANCE_PATH_LENGTH);
                        RtlCopyMemory( buffer,
                                SubtreeRootDeviceNode->InstancePath.Buffer,
                                SubtreeRootDeviceNode->InstancePath.Length );
                        rootEntry = buffer;
                    }
                }
                else {
                    rootEntry = NULL;
                    devnodeList = NULL;
                }
                ObDereferenceObject(originalSubtree->PhysicalDeviceObject);

                PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);
                PpSynchronizeDeviceEventQueue();
                PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

                if (reenumAttempts >= MAX_REENUMERATION_ATTEMPTS) {

                    IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                                 "Restarted reenumeration %d times, giving up!\n", reenumAttempts));
                    ASSERT(reenumAttempts < MAX_REENUMERATION_ATTEMPTS);
                    return STATUS_UNSUCCESSFUL;
                }
                RtlInitUnicodeString(&unicodeName, rootEntry);
                entryDeviceObject = IopDeviceObjectFromDeviceInstance(&unicodeName);
                if (entryDeviceObject == NULL) {

                    if (devnodeList) {

                        ExFreePool(devnodeList);
                    }
                    return STATUS_UNSUCCESSFUL;
                }

                SubtreeRootDeviceNode = entryDeviceObject->DeviceObjectExtension->DeviceNode;
                originalSubtree = currentNode = SubtreeRootDeviceNode;

                //
                // Try to start processing where we left off.
                //
                if (devnodeList) {

                    for(currentEntry = devnodeList;
                        currentEntry != rootEntry;
                        currentEntry += ((unicodeName.Length / sizeof(WCHAR))+1)) {

                        RtlInitUnicodeString(&unicodeName, currentEntry);

                        entryDeviceObject = IopDeviceObjectFromDeviceInstance(&unicodeName);

                        if (entryDeviceObject != NULL) {

                            currentNode = entryDeviceObject->DeviceObjectExtension->DeviceNode;
                            ObDereferenceObject(entryDeviceObject);
                            break;
                        }
                    }

                    ExFreePool(devnodeList);

                }
                nextNode = SameNode;
            }

            //
            // This code advances the current node based on nextNode.
            //

            switch (nextNode) {
            case SameNode:
                break;

            case ChildNode:

                if (currentNode->Child != NULL) {

                    currentNode = currentNode->Child;
                    break;
                }
                // FALLTHRU - No more children so advance to sibling

            case SiblingNode:

                while (currentNode != SubtreeRootDeviceNode) {

                    if (currentNode == startRoot) {

                        //
                        // We completed processing of the new subtree.
                        //

                        if (EnumType != EnumTypeNone) {

                            enumeratedBus   = startRoot->Parent;
                        }
                        startRoot       = NULL;
                    } else if (currentNode == enumeratedBus) {

                        enumeratedBus   = enumeratedBus->Parent;
                    }

                    if (currentNode->Sibling != NULL) {
                        currentNode = currentNode->Sibling;
                        break;
                    }

                    if (currentNode->Parent != NULL) {
                        currentNode = currentNode->Parent;
                    }
                }

                if (currentNode == SubtreeRootDeviceNode) {

                    processComplete = TRUE;
                }
                break;
            }
        }
    }

    if (!ProcessOnlyIntermediateStates) {

         PipAssertDevnodesInConsistentState();
         ObDereferenceObject(originalSubtree->PhysicalDeviceObject);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PipProcessStartPhase1(
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN      Synchronous
    )
{
    PDEVICE_OBJECT  deviceObject;
    NTSTATUS        status = STATUS_SUCCESS;
    PNP_VETO_TYPE   vetoType;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Synchronous);

    ASSERT(DeviceNode->State == DeviceNodeResourcesAssigned);

    deviceObject = DeviceNode->PhysicalDeviceObject;

    IopUncacheInterfaceInformation(deviceObject);

    if (DeviceNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE) {

        //
        // This is 