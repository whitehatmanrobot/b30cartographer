nsions
#define ID_SPRING_2D		(BE_SPRING_2D 		+ (EF_BEHAVIOR<<16))
#define ID_DAMPER_2D		(BE_DAMPER_2D 		+ (EF_BEHAVIOR<<16))
#define ID_INERTIA_2D		(BE_INERTIA_2D 		+ (EF_BEHAVIOR<<16))
#define ID_FRICTION_2D		(BE_FRICTION_2D 	+ (EF_BEHAVIOR<<16))
#define ID_WALL				(BE_WALL 			+ (EF_BEHAVIOR<<16))
#define ID_DELAY			(BE_DELAY 			+ (EF_BEHAVIOR<<16))

//
// --- Subtypes for EF_SYNTHESIZE
//								
#define SE_CONSTANT_FORCE	101L
#define SE_SINE				102L
#define SE_COSINE			103L
#define	SE_SQUARELOW		104L
#define	SE_SQUAREHIGH		105L
#define	SE_RAMPUP  			106L
#define	SE_RAMPDOWN			107L
#define	SE_TRIANGLEUP		108L
#define	SE_TRIANGLEDOWN		109L
#define	SE_SAWTOOTHUP		110L
#define	SE_SAWTOOTHDOWN		111L
//
// --- DXFF map
//
#define ID_CONSTANTFORCE	(SE_CONSTANTFORCE 	+ (EF_SYNTHESIZED<<16))
#define ID_RAMPFORCE		(SE_RAMPUP  	  	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARE			(SE_SQUARELOW	  	+ (EF_SYNTHESIZED<<16))
#define ID_SINE				(SE_SINE		  	+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLE			(SE_TRIANGLEUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHUP		(SE_SAWTOOTHUP	 	+ (EF_SYNTHESIZED<<16))
#define ID_SAWTOOTHDOWN		(SE_SAWTOOTHDOWN	+ (EF_SYNTHESIZED<<16))
#define ID_RAMP				(SE_RAMPUP		  	+ (EF_SYNTHESIZED<<16))
//
// --- SWForce extensions
//
#define ID_COSINE			(SE_COSINE		 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUAREHIGH		(SE_SQUAREHIGH	 	+ (EF_SYNTHESIZED<<16))
#define ID_SQUARELOW		(SE_SQUARELOW		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPUP  			(SE_RAMPUP  		+ (EF_SYNTHESIZED<<16))
#define ID_RAMPDOWN			(SE_RAMPDOWN		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEUP		(SE_TRIANGLEUP		+ (EF_SYNTHESIZED<<16))
#define ID_TRIANGLEDOWN		(SE_TRIANGLEDOWN	+ (EF_SYNTHESIZED<<16))

//
// --- Subtypes for EF_USER_DEFINED
//
#define UD_WAVEFORM			201L
#define PL_CONCATENATE		202L
#define PL_SUPERIMPOSE		203L
//
// --- DXFF map
//
#define ID_CUSTOMFORCE		(UD_WAVEFORM	 	+ (EF_USER_DEFINED<<16))
//
// --- SWForce extensions
//
#define ID_PL_CONCATENATE	(PL_CONCATENATE 	+ (EF_USER_DEFINED<<16))
#define ID_PL_SUPERIMPOSE	(PL_SUPERIMPOSE 	+ (EF_USER_DEFINED<<16))

//
// --- Subtypes for EF_ROM_EFFECT
// starts at 0x12D
#define RE_ROMID_START	301L
#define	RE_ROMID1		(RE_ROMID_START     )	
#define	RE_ROMID2		(RE_ROMID_START +  1)		
#define	RE_ROMID3		(RE_ROMID_START +  2)			
#define	RE_ROMID4		(RE_ROMID_START +  3)		
#define	RE_ROMID5		(RE_ROMID_START +  4)		
#define	RE_ROMID6		(RE_ROMID_START +  5)	
#define RE_ROMID7		(RE_ROMID_START +  6)
#define	RE_ROMID8		(RE_ROMID_START +  7)	
#define	RE_ROMID9		(RE_ROMID_START +  8)		
#define	RE_ROMID10		(RE_ROMID_START +  9)			
#define	RE_ROMID11		(RE_ROMID_START + 10)		
#define	RE_ROMID12		(RE_ROMID_START + 11)		
#define	RE_ROMID13		(RE_ROMID_START + 12)	
#define RE_ROMID14		(RE_ROMID_START + 13)
#define	RE_ROMID15		(RE_ROMID_START + 14)		
#define	RE_ROMID16		(RE_ROMID_START + 15)	
#define RE_ROMID17		(RE_ROMID_START + 16)
#define	RE_ROMID18		(RE_ROMID_START + 17)	
#define	RE_ROMID19		(RE_ROMID_START + 18)
#define	RE_ROMID20		(RE_ROMID_START + 19)			
#define	RE_ROMID21		(RE_ROMID_START + 20)		
#define	RE_ROMID22		(RE_ROMID_START + 21)		
#define	RE_ROMID23		(RE_ROMID_START + 22)	
#define RE_ROMID24		(RE_ROMID_START + 23)
#define	RE_ROMID25		(RE_ROMID_START + 24)		
#define	RE_ROMID26		(RE_ROMID_START + 25)	
#define RE_ROMID27		(RE_ROMID_START + 26)
#define	RE_ROMID28		(RE_ROMID_START + 27)
#define	RE_ROMID29		(RE_ROMID_START + 28)
#define	RE_ROMID30		(RE_ROMID_START + 29)
#define RE_ROMID31		(RE_ROMID_START + 30)
#define RE_ROMID32		(RE_ROMID_START + 31)
#if 0
#define	RE_ROMID33		(RE_ROMID_START + 32)	
#define RE_ROMID34		(RE_ROMID_START + 33)
#define	RE_ROMID35		(RE_ROMID_START + 34)		
#define	RE_ROMID36		(RE_ROMID_START + 35)	
#define RE_ROMID37		(RE_ROMID_START + 36)
#define	RE_ROMID38		(RE_ROMID_START + 37)	
#define	RE_ROMID39		(RE_ROMID_START + 38)
#define	RE_ROMID40		(RE_ROMID_START + 39)			
#define	RE_ROMID41		(RE_ROMID_START + 40)		
#define	RE_ROMID42		(RE_ROMID_START + 41)		
#define	RE_ROMID43		(RE_ROMID_START + 42)	
#define RE_ROMID44		(RE_ROMID_START + 43)
#define	RE_ROMID45		(RE_ROMID_START + 44)		
#define	RE_ROMID46		(RE_ROMID_START + 45)	
#define RE_ROMID47		(RE_ROMID_START + 46)
#define	RE_ROMID48		(RE_ROMID_START + 47)
#define	RE_ROMID49		(RE_ROMID_START + 48)
#define	RE_ROMID50		(RE_ROMID_START + 49)
#define RE_ROMID51		(RE_ROMID_START + 50)
#define RE_ROMID52		(RE_ROMID_START + 51)
#define	RE_ROMID53		(RE_ROMID_START + 52)	
#define RE_ROMID54		(RE_ROMID_START + 53)
#define	RE_ROMID55		(RE_ROMID_START + 54)		
#define	RE_ROMID56		(RE_ROMID_START + 55)	
#define RE_ROMID57		(RE_ROMID_START + 56)
#define	RE_ROMID58		(RE_ROMID_START + 57)	
#define	RE_ROMID59		(RE_ROMID_START + 58)
#define	RE_ROMID60		(RE_ROMID_START + 59)			
#define	RE_ROMID61		(RE_ROMID_START + 60)		
#define	RE_ROMID62		(RE_ROMID_START + 61)		
#define	RE_ROMID63		(RE_ROMID_START + 62)	
#define RE_ROMID64		(RE_ROMID_START + 63)
#endif
#define MAX_ROM_EFFECTS (RE_ROMID32 - RE_ROMID_START + 1)

//
// --- DXFF map
//
#define ID_RANDOM_NOISE				(RE_ROMID1  + (EF_ROM_EFFECT<<16))
#define ID_AIRCRAFT_CARRIER_TAKEOFF	(RE_ROMID2	+ (EF_ROM_EFFECT<<16))
#define ID_BASKETBALL_DRIBBLE		(RE_ROMID3	+ (EF_ROM_EFFECT<<16))
#define ID_CAR_ENGINE_IDLE			(RE_ROMID4	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IDLE			(RE_ROMID5	+ (EF_ROM_EFFECT<<16))
#define ID_CHAINSAW_IN_ACTION		(RE_ROMID6	+ (EF_ROM_EFFECT<<16))
#define ID_DIESEL_ENGINE_IDLE		(RE_ROMID7	+ (EF_ROM_EFFECT<<16))
#define ID_JUMP						(RE_ROMID8	+ (EF_ROM_EFFECT<<16))
#define ID_LAND						(RE_ROMID9	+ (EF_ROM_EFFECT<<16))
#define ID_MACHINEGUN				(RE_ROMID10 + (EF_ROM_EFFECT<<16))
#define ID_PUNCHED					(RE_ROMID11 + (EF_ROM_EFFECT<<16))
#define ID_ROCKET_LAUNCH			(RE_ROMID12 + (EF_ROM_EFFECT<<16))
#define ID_SECRET_DOOR				(RE_ROMID13 + (EF_ROM_EFFECT<<16))
#define ID_SWITCH_CLICK				(RE_ROMID14 + (EF_ROM_EFFECT<<16))
#define ID_WIND_GUST				(RE_ROMID15 + (EF_ROM_EFFECT<<16))
#define ID_WIND_SHEAR				(RE_ROMID16 + (EF_ROM_EFFECT<<16))
#define ID_PISTOL					(RE_ROMID17 + (EF_ROM_EFFECT<<16))
#define ID_SHOTGUN					(RE_ROMID18 + (EF_ROM_EFFECT<<16))
#define ID_LASER1					(RE_ROMID19 + (EF_ROM_EFFECT<<16))
#define ID_LASER2					(RE_ROMID20 + (EF_ROM_EFFECT<<16))
#define ID_LASER3					(RE_ROMID21 + (EF_ROM_EFFECT<<16))
#define ID_LASER4					(RE_ROMID22 + (EF_ROM_EFFECT<<16))
#define ID_LASER5					(RE_ROMID23 + (EF_ROM_EFFECT<<16))
#define ID_LASER6					(RE_ROMID24 + (EF_ROM_EFFECT<<16))
#define ID_OUT_OF_AMMO				(RE_ROMID25 + (EF_ROM_EFFECT<<16))
#define ID_LIGHTNING_GUN			(RE_ROMID26 + (EF_ROM_EFFECT<<16))
#define ID_MISSILE					(RE_ROMID27 + (EF_ROM_EFFECT<<16))
#define ID_GATLING_GUN				(RE_ROMID28 + (EF_ROM_EFFECT<<16))
#define ID_SHORT_PLASMA				(RE_ROMID29 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON1			(RE_ROMID30 + (EF_ROM_EFFECT<<16))
#define ID_PLASMA_CANNON2			(RE_ROMID31 + (EF_ROM_EFFECT<<16))
#define ID_CANNON					(RE_ROMID32 + (EF_ROM_EFFECT<<16))
//#define ID_FLAME_THROWER			(RE_ROMID33 + (EF_ROM_EFFECT<<16))
//#define ID_BOLT_ACTION_RIFLE		(RE_ROMID34 + (EF_ROM_EFFECT<<16))
//#define ID_CROSSBOW					(RE_ROMID35 + (EF_ROM_EFFECT<<16))



#endif // of ifdef _DX_MAP_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffeature.h ===
#ifndef __ForceFeatures_h__
#define __ForceFeatures_h__

#define MSGAME_FEATURE_GETID		2
#define MSGAME_FEATURE_GETSTATUS	3
#define MSGAME_FEATURE_GETACKNAK	4
#define MSGAME_FEATURE_GETNAKACK	5
#define MSGAME_FEATURE_GETSYNC		6
#define MSGAME_FEATURE_DORESET		7

/*
#define	MSGAME_INPUT_JOYINFOEX		0x01
#define	MSGAME_FEATURE_GETID			0x02
#define	MSGAME_FEATURE_GETSTATUS	0x03
#define	MSGAME_FEATURE_GETACKNAK	0x04
#define	MSGAME_FEATURE_GETNAKACK	0x05
#define	MSGAME_FEATURE_GETSYNC		0x06
#define	MSGAME_FEATURE_RESET			0x07
#define	MSGAME_FEATURE_GETVERSION	0x08
*/		

typedef struct
{
	ULONG	cBytes;
	ULONG	dwProductID;
	ULONG	dwFWVersion;
} PRODUCT_ID;

typedef	struct
{
	ULONG	cBytes;
	LONG		dwXVel;
	LONG		dwYVel;
	LONG		dwXAccel;
	LONG		dwYAccel;
	ULONG	dwEffect;
	ULONG	dwDeviceStatus;
} JOYCHANNELSTATUS;

//
//	HID prepends exactly, one byte so we need to
//	be careful about packing
//
#pragma pack(push, OLD_CONTEXT_1)
#pragma pack(1)
typedef struct
{
	BYTE		bReportId;
	PRODUCT_ID	ProductId;
} PRODUCT_ID_REPORT;
typedef struct
{
	BYTE				bReportId;
	JOYCHANNELSTATUS	JoyChannelStatus;
} JOYCHANNELSTATUS_REPORT;

typedef struct
{
	BYTE	bReportId;
	ULONG	uLong;
} ULONG_REPORT;
#pragma pack(pop, OLD_CONTEXT_1)
//
//	End packing of 1
//


class CForceFeatures
{
	public:
		CForceFeatures();
		~CForceFeatures();

		HRESULT Initialize(UINT uJoystickId, HINSTANCE hinstModule);
		ULONG GetVersion(){ return (4 << 16 | 0 ); } //returns version 4.0
		HRESULT GetId(PRODUCT_ID_REPORT& rProductId);
		HRESULT GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus);
		HRESULT GetAckNak(ULONG_REPORT& rulAckNak);
		HRESULT GetNakAck(ULONG_REPORT& rulNakAck);
		HRESULT GetSync(ULONG_REPORT& rulGameport);
		HRESULT DoReset();
	private:
		HANDLE	m_hDevice;
		UINT m_uiMaxFeatureLength;
};

#endif // __ForceFeatures_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\effect.cpp ===
//@doc
/******************************************************
**
** @module EFFECT.CPP | InternalEffect implementation file
**
** Description:
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
**		23-Mar-99	waltw	IsReallyPlaying  now uses data returned by
**							Transmit instead of obsolete GetStatusGateData
**
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Effect.h"
#include "DPack.h"
#include "DTrans.h"
#include "FFDevice.h"
#include "joyregst.hpp"
#include "Registry.h"
#include "CritSec.h"
#include "Midi_Obj.hpp"
#include <math.h>

DWORD g_TotalModifiable =	DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON |
							DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE |
							DIEP_TYPESPECIFICPARAMS;

//#define ZEP_PRODUCT_ID			0x7F
#define ZEP_PRODUCT_ID			0x15

#define DOWNLOAD_OP_200			0x02
#define STORE_ACTION_200		0x00
#define PLAYSUPER_ACTION_200	0x01
#define PLAYSOLO_ACTION_200		0x02
#define AXIS_ANGLE_200			0x00
#define AXIS_X_200				0x01
#define AXIS_Y_200				0x02

// VFX Default items
#define DEFAULT_VFX_SAMPLEPERIOD 2000
#define DEFAULT_VFX_EFFECT_DIRECTION	0
#define DEFAULT_VFX_EFFECT_GAIN	10000
#define DEFAULT_VFX_EFFECT_DURATION 1000

// Max DIDistance = 10,000 so 10,000/100(percent) = 100
#define DIDISTANCE_TO_PERCENT	100

#define COEFFICIENT_SCALE_1XX	100
#define DURATION_SCALE_1XX		1000
#define GAIN_PERCENTAGE_SCALE	100
#define FREQUENCY_SCALE_1XX		1000000
#define TIME_SCALE_1XX			1000
#define ENVELOPE_TIME_TICKS_1XX	2

#define DURATION_SCALE_200		2000
#define ANGLE_SCALE_200			281.25
#define POSITIVE_PERCENT_SCALE	1.588
#define FRICTION_SCALE_200		157.5
#define GAIN_SCALE_200			78.7
#define PHASE_SCALE_200			2.197
#define WAVELET_SCALE_200		39.215
//#define WAVELET_DISTANCE_200	1215
#define WAVELET_DISTANCE_200	2440
//#define WAVELET_DISTANCE_SCALE_200 39.193
#define WAVELET_DISTANCE_SCALE_200 78.74
#define BEHAVIOUR_CENTER_SCALE_200	158
#define BEHAVIOUR_CENTER_200		63
#define MAX_TIME_200	32766000

// Mofidify index for version 200
#define INDEX_BE_DURATION_200		0
#define INDEX_DELAY_200				1
#define INDEX_DIRECTIONANGLE_200	2
#define INDEX_D1F1_200				(BYTE)3
#define INDEX_D2F2_200				4
#define INDEX_D3F3_200				5
#define INDEX_D4F4_200				6
#define INDEX_BE_BUTTONMAP_200		7
#define INDEX_BE_BUTTONREPEAT_200	8
#define INDEX_BE_GAIN_200			9
#define INDEX_BE_CENTER_200			10
#define INDEX_BE_REPEAT_200			11

// Friction Modify Indecies
#define INDEX_FE_DURATION_200		0
#define INDEX_FE_DELAY_200			1
#define INDEX_FE_DIRECTIONANGLE_200	2
#define INDEX_FE_COEEFICIENT_200	3
#define INDEX_FE_BUTTONMAP_200		4
#define INDEX_FE_BUTTONREPEAT_200	5
#define INDEX_FE_GAIN_200			6
#define INDEX_FE_REPEAT_200			7

// CustomForce Modify Indecies
#define INDEX_CF_DURATION_200		0
#define INDEX_CF_DELAY_200			1
#define INDEX_CF_DIRECTIONANGLE_200	2
#define INDEX_CF_GAIN_200			3
#define INDEX_CF_STARTPERCENT_200	4
#define INDEX_CF_ATTTACK_TIME_200	5
#define INDEX_CF_SUSTAINPERCENT_200 6
#define INDEX_CF_FADESTART_200		7
#define INDEX_CF_ENDPERCENT_200		8
#define INDEX_CF_OFFSET_200			9
#define INDEX_CF_FORCESAMPLE_200	10
#define INDEX_CF_SAMPLE_PERIOD_200	11
#define INDEX_CF_BUTTONMAP_200		12
#define INDEX_CF_BUTTONREPEAT_200	13
#define INDEX_CF_REPEAT_200			14

// Periodic Effect Modify Indecies
#define INDEX_PE_DURATION_200		0
#define INDEX_PE_DIRECTIONANGLE_200 2
#define INDEX_PE_GAIN_200			3
#define INDEX_PE_PHASE_200			4
#define INDEX_PE_STARTPERCENT_200	5
#define INDEX_PE_ATTTACK_TIME_200	6
#define INDEX_PE_SUSTAINPERCENT_200 7
#define INDEX_PE_FADESTART_200		8
#define INDEX_PE_ENDPERCENT_200		9
#define INDEX_PE_PERIOD_200			10
#define INDEX_PE_OFFSET_200			11
#define INDEX_PE_SAMPLE_PERIOD_200	12
#define INDEX_PE_BUTTONMAP_200		13
#define INDEX_PE_BUTTONREPEAT_200	14
#define INDEX_PE_REPEAT_200			15

// ConstantForce Effect Modify Indecies
#define INDEX_CE_DURATION_200		0
#define INDEX_CE_GAIN_200			3
#define INDEX_CE_STARTPERCENT_200	4
#define INDEX_CE_ATTTACK_TIME_200	5
#define INDEX_CE_SUSTAINPERCENT_200 6
#define INDEX_CE_FADESTART_200		7
#define INDEX_CE_ENDPERCENT_200		8
#define INDEX_CE_MAGNITUDE_200		9
#define INDEX_CE_BUTTONMAP_200		11
#define INDEX_CE_BUTTONREPEAT_200	12
#define INDEX_CE_REPEAT_200			13

// Default system param defines (for 1XX)
#define DEF_XY_CONST		22500
#define DEF_ROT_CONST		17272
#define DEF_SLDR_CONST		126
#define DEF_AJ_POS			4
#define DEF_AJ_ROT			2
#define DEF_AJ_SLDR			2
#define DEF_SPR_SCL			((DWORD)-256)
#define DEF_BMP_SCL			60
#define DEF_DMP_SCL			((DWORD)-3436)
#define DEF_INERT_SCL		((DWORD)-2562)
#define DEF_VEL_OFFSET_SCL	54
#define DEF_ACC_OFFSET_SCL	40
#define DEF_Y_MOT_BOOST		19661
#define DEF_X_MOT_SATURATION	254

BYTE g_TriggerMap1XX[] = { 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80 };
BYTE g_TriggerMap200[] = { 0x00, 0x01, 0x02, 0x04, 0x10, 0x20, 0x40, 0x80, 0x08, 0x08, 0x08 };

/******************* Envelope1XX class *******************/
Envelope1XX::Envelope1XX(DIENVELOPE* pDIEnvelope, DWORD baseLine, DWORD duration)
{
	// Zero out this monster
	::memset(this, 0, sizeof(Envelope1XX));

	if (pDIEnvelope == NULL) {
		m_SustainTime = duration;
		m_SustainPercent = 100;
		return;
	}

	// Attack/sustain/decay sum to duration
	m_AttackTime = pDIEnvelope->dwAttackTime/ENVELOPE_TIME_TICKS_1XX;
	if (duration != INFINITE) {	// Inifinite duration has only attack
		m_SustainTime = (duration- pDIEnvelope->dwFadeTime)/ENVELOPE_TIME_TICKS_1XX;
	}

	// What is the real maximum
	DWORD maxAmp = baseLine;
	if (maxAmp < pDIEnvelope->dwAttackLevel) {
		maxAmp = pDIEnvelope->dwAttackLevel;
	}
	if (maxAmp < pDIEnvelope->dwFadeLevel) {
		maxAmp = pDIEnvelope->dwFadeLevel;
	}

	maxAmp /= 100; // For percentage conversion
	if (maxAmp == 0) { 	// Avoid a nasty division error
		m_SustainPercent = 100;	// Sustain is full (others are 0)
	} else {
		m_StartPercent = pDIEnvelope->dwAttackLevel/maxAmp;
		m_SustainPercent = baseLine/maxAmp;
		m_EndPercent = pDIEnvelope->dwFadeLevel/maxAmp;
	}
}


/******************* Envelope200 class *******************/
Envelope200::Envelope200(DIENVELOPE* pDIEnvelope, DWORD sustain, DWORD duration, HRESULT& hr)
{
	// Zero out this monster
	::memset(this, 0, sizeof(Envelope200));
	m_FadeStart = WORD(duration/DURATION_SCALE_200);

	DWORD calc = sustain;		// -- Modifcation above, now done on gain

	// DI Doesn't specify an envelope
	if (pDIEnvelope == NULL) {
		m_SustainPercent = BYTE(calc/GAIN_SCALE_200);	// Base sustain of magnitude
		return;
	}

	// The sun of attack and fade must be less than MAX_TIME
	if ((pDIEnvelope->dwAttackTime + pDIEnvelope->dwFadeTime) > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		if (pDIEnvelope->dwAttackTime > MAX_TIME_200) {
			pDIEnvelope->dwAttackTime = MAX_TIME_200;
		}
		pDIEnvelope->dwFadeTime = MAX_TIME_200 - pDIEnvelope->dwAttackTime;
	}

	// Attack/sustain/decay sum to duration
	m_AttackTime = WORD(pDIEnvelope->dwAttackTime/DURATION_SCALE_200);
	if (duration != INFINITE) {	// Inifinite duration has only attack (fade-time == DURATION)
		m_FadeStart = WORD((duration - pDIEnvelope->dwFadeTime)/DURATION_SCALE_200);
		if (m_FadeStart < m_AttackTime) {	// We don't want to fade before the end of the attack!
			m_FadeStart = m_AttackTime;
		}
	}

	m_SustainPercent = BYTE(float(calc)/GAIN_SCALE_200);
	calc = pDIEnvelope->dwAttackLevel;
	if (calc > 10000) {
		calc = 10000;
		hr = DI_TRUNCATED;
	}
	m_StartPercent = BYTE(float(calc)/GAIN_SCALE_200);
	calc = (pDIEnvelope->dwFadeLevel);
	if (calc > 10000) {
		calc = 10000;
		hr = DI_TRUNCATED;
	}
	m_EndPercent = BYTE(float(calc)/GAIN_SCALE_200);
}


/******************* InternalEffect class ******************/
InternalEffect::InternalEffect() :
	m_EffectID(0),
	m_DeviceEffectID(0),
	m_Duration(0),
	m_Gain(0),
	m_TriggerPlayButton(0),
	m_AxisMask(0),
	m_EffectAngle(0),
	m_PercentX(0),
	m_PercentY(0),
	m_PercentAdjustment(0),
	m_AxesReversed(FALSE),
	m_IsPossiblyPlaying(FALSE)
{
}

InternalEffect::~InternalEffect()
{
}


// Static Creation Functions
InternalEffect* InternalEffect::CreateSpring()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new BehaviouralEffect1XX(ET_BE_SPRING);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect200(ET_SPRING_200);
	}
}

InternalEffect* InternalEffect::CreateDamper()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new BehaviouralEffect1XX(ET_BE_DAMPER);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect200(ET_DAMPER_200);
	}
}

InternalEffect* InternalEffect::CreateInertia()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new BehaviouralEffect1XX(ET_BE_INERTIA);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect200(ET_INERTIA_200);
	}
}

InternalEffect* InternalEffect::CreateFriction()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new FrictionEffect1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new FrictionEffect200();
	}
}

InternalEffect* InternalEffect::CreateRTCSpring()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new RTCSpring1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new RTCSpring200();
	}
}

InternalEffect* InternalEffect::CreateSystemEffect()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new SystemEffect1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return NULL;	// NYI
	}
}

InternalEffect* InternalEffect::CreateSine()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_SINE);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new PeriodicEffect200(ET_SINE_200);
	}
}

InternalEffect* InternalEffect::CreateSquare()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_SQUAREHIGH);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new PeriodicEffect200(ET_SQUARE_200);
	}
}

InternalEffect* InternalEffect::CreateTriangle()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_TRIANGLEUP);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new PeriodicEffect200(ET_TRIANGLE_200);
	}
}

InternalEffect* InternalEffect::CreateSawtoothUp()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new SawtoothEffect200(TRUE);
	}
}

InternalEffect* InternalEffect::CreateSawtoothDown()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new SawtoothEffect200(FALSE);
	}
}

InternalEffect* InternalEffect::CreateCustomForce()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new CustomForceEffect200();
	}
}

InternalEffect* InternalEffect::CreateConstantForce()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_CONSTANT_FORCE);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new ConstantForceEffect200();
	}
}

InternalEffect* InternalEffect::CreateRamp()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new PeriodicEffect1XX(ET_SE_RAMPUP);
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new RampEffect200();
	}
}


InternalEffect* InternalEffect::CreateWall()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new WallEffect200();
	}
}

/*
InternalEffect* InternalEffect::CreateDelay()
{
	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return new DelayEffect1XX();
	} else {	// Assume newer firmware versions will come with an update, or work with this
		return new BehaviouralEffect1XX(ET_DELAY_200);
	}
}
*/

InternalEffect* InternalEffect::CreateFromVFX(const DIEFFECT& diOriginal, EFFECT effect, ENVELOPE envelope, BYTE* pEffectParms, DWORD paramSize, HRESULT& hr)
{
	InternalEffect* pReturnEffect = NULL;

	if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
		return NULL;
	}

	// Fill in the DIEFFECT structure
	DIEFFECT diEffect;
	diEffect.dwSize = sizeof(DIEFFECT);
	diEffect.dwFlags = DIEFF_POLAR | DIEFF_OBJECTOFFSETS;

	// Only set from file, if default is asked for
	if (diOriginal.dwDuration == DEFAULT_VFX_EFFECT_DURATION) {
		diEffect.dwDuration = effect.m_Duration * 1000;	// Zero will work as infinite just fine
	} else {
		diEffect.dwDuration = diOriginal.dwDuration;
	}

	// If zero is sent use the one from the file else use the one sent
	if (diOriginal.dwSamplePeriod == 0) {
		diEffect.dwSamplePeriod = 1000000/effect.m_ForceOutputRate;
	} else {
		diEffect.dwSamplePeriod = diOriginal.dwSamplePeriod;
	}

	// Only set from file if default is sent
	if (diOriginal.dwGain == DEFAULT_VFX_EFFECT_GAIN) {
		diEffect.dwGain = effect.m_Gain * 100;
	} else {
		diEffect.dwGain = diOriginal.dwGain;
	}

	// Need to find which bit is set
	if (diOriginal.dwTriggerButton == DIEB_NOTRIGGER) {
		if (effect.m_ButtonPlayMask == 0) {
			diEffect.dwTriggerButton = DIEB_NOTRIGGER;
		} else {
			DWORD butt = effect.m_ButtonPlayMask;
			short int buttNum = 0;
			while ((butt & 1) == 0) {
				butt >>= 1;
				buttNum++;
				ASSUME(buttNum >= 32);
			}
			diEffect.dwTriggerButton = DIDFT_MAKEINSTANCE(buttNum);
		}
		diEffect.dwTriggerRepeatInterval = 0;
	} else {
		diEffect.dwTriggerButton = diOriginal.dwTriggerButton;
		diEffect.dwTriggerRepeatInterval = diOriginal.dwTriggerRepeatInterval;
	}

	diEffect.cbTypeSpecificParams = 0;
	diEffect.lpvTypeSpecificParams = NULL;

	diEffect.cAxes = 2;
	diEffect.rgdwAxes = new DWORD[2];
	if (diEffect.rgdwAxes == NULL)
	{
		goto do_dealloc;
	}
	diEffect.rgdwAxes[0] = DIJOFS_X;
	diEffect.rgdwAxes[1] = DIJOFS_Y;

	diEffect.rglDirection = new LONG[2];
	if (diEffect.rglDirection == NULL)
	{
		goto do_dealloc;
	}
	if (diOriginal.rglDirection[0] == DEFAULT_VFX_EFFECT_DIRECTION) {
		diEffect.rglDirection[0] = effect.m_DirectionAngle2D * 100;
	} else {
		diEffect.rglDirection[0] = diOriginal.rglDirection[0];
	}
	diEffect.rglDirection[1] = 0;

	// Envelope
	diEffect.lpEnvelope = new DIENVELOPE;
	if (diEffect.lpEnvelope == NULL)
	{
		goto do_dealloc;
	}
	if (diOriginal.lpEnvelope != NULL) {
		::memcpy(diEffect.lpEnvelope, diOriginal.lpEnvelope, sizeof(DIENVELOPE));
	} else {
		diEffect.lpEnvelope->dwSize = sizeof(DIENVELOPE);
		diEffect.lpEnvelope->dwAttackLevel = envelope.m_StartAmp * (diEffect.dwGain/100);
		diEffect.lpEnvelope->dwFadeLevel = envelope.m_EndAmp * (diEffect.dwGain/100);
		diEffect.dwGain = diEffect.dwGain/100 * envelope.m_SustainAmp;
		if (envelope.m_Type == TIME) { // time is in MSECs
			diEffect.lpEnvelope->dwAttackTime = envelope.m_Attack * 1000;
			diEffect.lpEnvelope->dwFadeTime = envelope.m_Decay * 1000;
		} else {	// Percentage of total time
			diEffect.lpEnvelope->dwAttackTime = envelope.m_Attack * (diEffect.dwDuration/100);
			diEffect.lpEnvelope->dwFadeTime = envelope.m_Decay * (diEffect.dwDuration/100);
		}
	}

	switch(effect.m_Type) {
		case EF_BEHAVIOR: {
			DICONDITION* pDICondition = new DICONDITION[2];
			if (pDICondition == NULL)
			{
				goto do_dealloc;
			}
			::memset(pDICondition, 0, sizeof(DICONDITION) * 2);
			diEffect.cbTypeSpecificParams = sizeof(DICONDITION)*2;
			diEffect.lpvTypeSpecificParams = pDICondition;

			switch (effect.m_SubType) {	// Switch for parameter filling
				case BE_SPRING_2D:
				case BE_DAMPER_2D:
				case BE_INERTIA_2D: {
					BE_SPRING_2D_PARAM* pParams = (BE_SPRING_2D_PARAM*)pEffectParms;
					pDICondition[1].lOffset = pParams->m_YAxisCenter * 100;
					pDICondition[1].lPositiveCoefficient = pParams->m_YKconstant * 100;
					pDICondition[1].lNegativeCoefficient = pDICondition[1].lPositiveCoefficient;
					pDICondition[1].dwPositiveSaturation = 10000;
					pDICondition[1].dwNegativeSaturation = 10000;
					// purposely fall through for first axis
				}
				case BE_SPRING:
				case BE_DAMPER:
				case BE_INERTIA: {
					BE_SPRING_PARAM* pParams = (BE_SPRING_PARAM*)pEffectParms;
					pDICondition[0].lOffset = pParams->m_AxisCenter * 100;
					pDICondition[0].lPositiveCoefficient = pParams->m_Kconstant * 100;
					pDICondition[0].lNegativeCoefficient = pDICondition[0].lPositiveCoefficient;
					pDICondition[0].dwPositiveSaturation = 10000;
					pDICondition[0].dwNegativeSaturation = 10000;
					break;
				}
				case BE_FRICTION_2D: {
					BE_FRICTION_2D_PARAM* pParams = (BE_FRICTION_2D_PARAM*)pEffectParms;
					pDICondition[1].lPositiveCoefficient = pParams->m_YFconstant * 100;
					pDICondition[1].lNegativeCoefficient = pDICondition[1].lPositiveCoefficient;
					pDICondition[1].dwPositiveSaturation = 10000;
					pDICondition[1].dwNegativeSaturation = 10000;
					// purposely fall through for first axis
				}
				case BE_FRICTION: {
					BE_FRICTION_PARAM* pParams = (BE_FRICTION_PARAM*)pEffectParms;
					pDICondition[0].lPositiveCoefficient = pParams->m_Fconstant * 100;
					pDICondition[0].lNegativeCoefficient = pDICondition[0].lPositiveCoefficient;
					pDICondition[0].dwPositiveSaturation = 10000;
					pDICondition[0].dwNegativeSaturation = 10000;
					break;
				}
				case BE_WALL: {	// This one is strangly simple
					delete pDICondition;
					diEffect.cbTypeSpecificParams = sizeof(BE_WALL_PARAM);
					diEffect.lpvTypeSpecificParams = new BE_WALL_PARAM;
					if (diEffect.lpvTypeSpecificParams != NULL) {
						::memcpy(diEffect.lpvTypeSpecificParams, pEffectParms, sizeof(BE_WALL_PARAM));
						// need to convert to DI values
						BE_WALL_PARAM* pWallParms = (BE_WALL_PARAM*)(diEffect.lpvTypeSpecificParams);
						pWallParms->m_WallConstant = pWallParms->m_WallConstant * 100;
						pWallParms->m_WallAngle = pWallParms->m_WallAngle * 100;
						pWallParms->m_WallDistance = pWallParms->m_WallDistance * 100;
					}
					break;
				}
			}
			switch (effect.m_SubType) {	// Switch for Creation
				case BE_SPRING:
				case BE_SPRING_2D: {
					pReturnEffect = CreateSpring();
					break;
				}
				case BE_DAMPER:
				case BE_DAMPER_2D: {
					pReturnEffect = CreateDamper();
					break;
				}
				case BE_INERTIA:
				case BE_INERTIA_2D: {
					pReturnEffect = CreateInertia();
					break;
				}
				case BE_FRICTION:
				case BE_FRICTION_2D: {
					pReturnEffect = CreateFriction();
					break;
				}
				case BE_WALL: {
					pReturnEffect = CreateWall();
					break;
				}
			}
			pDICondition = NULL;
			break;
		}
		case EF_USER_DEFINED: {
			UD_PARAM* pParams = (UD_PARAM*)pEffectParms;
			DICUSTOMFORCE* pUserDefined = new DICUSTOMFORCE;
			if (pUserDefined != NULL) {
				diEffect.cbTypeSpecificParams = sizeof(DICUSTOMFORCE);
				diEffect.lpvTypeSpecificParams = pUserDefined;
				pUserDefined->cChannels = 1;
				pUserDefined->dwSamplePeriod = diEffect.dwSamplePeriod;
				pUserDefined->cSamples = pParams->m_NumVectors;
				pUserDefined->rglForceData = pParams->m_pForceData;	// Don't copy the data here, just push the pointer
				for (UINT nextSample = 0; nextSample < pUserDefined->cSamples; nextSample++) {
					ASSUME(pUserDefined->rglForceData[nextSample] <= 100 && pUserDefined->rglForceData[nextSample] >= -100);		// Assume it is in the SWForce range (-100..100)
					pUserDefined->rglForceData[nextSample] *= 100;
				}

				pReturnEffect = CreateCustomForce();
			}
			
			pUserDefined = NULL;
			break;
		}
		case EF_SYNTHESIZED: {	// Fill in the periodic structure
			SE_PARAM* pParams = (SE_PARAM*)pEffectParms;
			if (effect.m_SubType == SE_CONSTANT_FORCE) {	// Special case
				DICONSTANTFORCE* pCForce= new DICONSTANTFORCE;
				if (pCForce != NULL) {
					diEffect.cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
					diEffect.lpvTypeSpecificParams = pCForce;
					pCForce->lMagnitude = pParams->m_MaxAmp * 100;
					pCForce = NULL;
					pReturnEffect = CreateConstantForce();
				}
				break;
			}
			if (effect.m_SubType == SE_RAMPUP || effect.m_SubType == SE_RAMPDOWN) {	// Yet another special case
				DIRAMPFORCE* pRForce = new DIRAMPFORCE;
				if (pRForce != NULL) {
					diEffect.cbTypeSpecificParams = sizeof(DIRAMPFORCE);
					diEffect.lpvTypeSpecificParams = pRForce;
					if (effect.m_SubType == SE_RAMPUP) {
						pRForce->lStart = pParams->m_MinAmp  * 100;
						pRForce->lEnd = pParams->m_MaxAmp * 100;
					} else {	// RampDown (special case of a special case)
						pRForce->lStart = pParams->m_MaxAmp  * 100;
						pRForce->lEnd = pParams->m_MinAmp * 100;
					}
					pRForce = NULL;
					pReturnEffect = CreateRamp();
				}
				break;
			}


			if (pParams->m_SampleRate == 0) {
				pParams->m_SampleRate = DEFAULT_JOLT_FORCE_RATE;
			}
			if (effect.m_ForceOutputRate == 0) {
				effect.m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;
			}

			DIPERIODIC* pPeriodic = new DIPERIODIC;
			if (pPeriodic == NULL) {
				break;
			}
			diEffect.cbTypeSpecificParams = sizeof(DIPERIODIC);
			diEffect.lpvTypeSpecificParams = pPeriodic;
			pPeriodic->dwMagnitude = (pParams->m_MaxAmp - pParams->m_MinAmp)/2 * 100;
			pPeriodic->lOffset = (pParams->m_MaxAmp + pParams->m_MinAmp)/2 * 100;
			pPeriodic->dwPhase = 0;
			if (pParams->m_Freq == 0) {	// Avoid division by 0
				pPeriodic->dwPeriod = 0;
			} else {
				pPeriodic->dwPeriod = 1000000 / pParams->m_Freq;
			}

			switch (effect.m_SubType) {
				case SE_SINE: {
					pReturnEffect = CreateSine();
					break;
				}
				case SE_COSINE: {
					pPeriodic->dwPhase = 9000;
					pReturnEffect = CreateSine();
					break;
				}
				case SE_SQUAREHIGH: {
					pReturnEffect = CreateSquare();
					break;
				}
				case SE_SQUARELOW: {
					pPeriodic->dwPhase = 18000;
					pReturnEffect = CreateSquare();
					break;
				}
				case SE_TRIANGLEUP: {
					pReturnEffect = CreateTriangle();
					break;
				}
				case SE_TRIANGLEDOWN: {
					pPeriodic->dwPhase = 18000;
					pReturnEffect = CreateTriangle();
					break;
				}

				case SE_SAWTOOTHUP: {
					pReturnEffect = CreateSawtoothUp();
					break;
				}
				case SE_SAWTOOTHDOWN: {
					pReturnEffect = CreateSawtoothDown();
					break;
				}
			}
			pPeriodic = NULL;
			break;
		}
		case EF_RTC_SPRING: {
			diEffect.cbTypeSpecificParams = sizeof(RTCSPRING_PARAM);
			diEffect.lpvTypeSpecificParams = new RTCSPRING_PARAM;
			if (diEffect.lpvTypeSpecificParams != NULL) {
				::memcpy(diEffect.lpvTypeSpecificParams, pEffectParms, sizeof(RTCSPRING_PARAM));
				pReturnEffect = CreateRTCSpring();
			}
			break;
		}
	}

	if (pReturnEffect != NULL) {
		hr = pReturnEffect->Create(diEffect);
		if (FAILED(hr)) {
			delete pReturnEffect;
			pReturnEffect = NULL;
		}
	}

do_dealloc:
	// Deallocate allocated DIEFFECT stuff
	if (diEffect.lpvTypeSpecificParams != NULL) {
		delete diEffect.lpvTypeSpecificParams;
	}
	if (diEffect.rglDirection != NULL) {
		delete diEffect.rglDirection;
	}
	if (diEffect.rgdwAxes != NULL) {
		delete diEffect.rgdwAxes;
	}
	if (diEffect.lpEnvelope != NULL) {
		delete diEffect.lpEnvelope;
	}

	return pReturnEffect;
}

HRESULT InternalEffect::Create(const DIEFFECT& diEffect)
{
	// We don't support more than 2 axes, and 0 is probably an error
	if ((diEffect.cAxes > 2) || (diEffect.cAxes == 0)) {
		return SFERR_NO_SUPPORT;
	}

	HRESULT hr = SUCCESS;

	// Set up the axis mask
	m_AxisMask = 0;
	for (unsigned int axisIndex = 0; axisIndex < diEffect.cAxes; axisIndex++) {
		DWORD axisNumber = DIDFT_GETINSTANCE(diEffect.rgdwAxes[axisIndex]);
		m_AxisMask |= 1 << axisNumber;
	}
	m_AxesReversed = (DIDFT_GETINSTANCE(diEffect.rgdwAxes[0]) == 1);

	// Set the trigger play button
	if (diEffect.dwTriggerButton != DIEB_NOTRIGGER) {
		m_TriggerPlayButton = DIDFT_GETINSTANCE(diEffect.dwTriggerButton) + 1;
		if (m_TriggerPlayButton == 9) { // We don't support button 9 playback (start button?)
			return SFERR_NO_SUPPORT;
		}
		if (m_TriggerPlayButton > 10) {	// We don't support mapping above 10
			return SFERR_NO_SUPPORT;
		}
	} else {
		m_TriggerPlayButton = 0;
	}

	m_TriggerRepeat = diEffect.dwTriggerRepeatInterval;
	if (m_TriggerRepeat > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		m_TriggerRepeat = MAX_TIME_200;
	}

	// Check coordinate sytems and change to polar
	if (diEffect.dwFlags & DIEFF_SPHERICAL) {	// We don't support sperical (3 axis force)
		return SFERR_NO_SUPPORT;				// .. since got by axis check, programmer goofed up
	}
	if (diEffect.dwFlags & DIEFF_POLAR) {
		if (diEffect.cAxes != 2) { // Polar coordinate must have two axes of data (because DX says so)
			return SFERR_INVALID_PARAM;
		}
		m_EffectAngle = diEffect.rglDirection[0];	// in [0] even if reversed
		if (m_AxesReversed) {		// Indicates (-1, 0) as origin instead of (0, -1)
			m_EffectAngle += 27000;
		}
		m_EffectAngle %= 36000;
	} else if (diEffect.dwFlags & DIEFF_CARTESIAN) { // Convert to polar
		if (diEffect.cAxes == 1) {	// Fairly easy conversion
			if (X_AXIS & m_AxisMask) {
				m_EffectAngle = 9000;
			} else {
				m_EffectAngle = 0;
			}
		} else { // Multiple axis cartiesian
			int xDirection = diEffect.rglDirection[0];
			int yDirection = diEffect.rglDirection[1];
			if (m_AxesReversed == TRUE) {
				yDirection = xDirection;
				xDirection = diEffect.rglDirection[1];
			}
			double angle = atan2(double(yDirection), double(xDirection)) * 180.0/3.14159;
			// Switch it to a proper quadrant integer
			int nAngle = 90;
			if (angle >= 0.0) {
				nAngle -= int(angle + 0.5);
			} else {
				nAngle -= int(angle - 0.5);
			}
			if (nAngle < 0) {
				nAngle += 360;
			} else if (nAngle >= 360) {
				nAngle -= 360;
			}
			m_EffectAngle = nAngle * 100;
		}
	} else {	// What, is there some other format?
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;	// Untill someone says otherwise there was an error
	}

	// Find the percent for each axis (for axis mapping)
	double projectionAngle = double(m_EffectAngle)/18000.0 * 3.14159;	// Convert to radians
	// Sin^2(a) + Cos^2(a) = 1
	double xProj = ::sin(projectionAngle);	// DI has 0 degs at (1, 0) not (0, 1)
	double yProj = ::cos(projectionAngle);
	xProj *= xProj;
	yProj *= yProj;
	m_PercentX = DWORD(xProj * 100.0 + 0.05);
	m_PercentY = DWORD(yProj * 100.0 + 0.05);

	// Duration and gain
	m_Duration = diEffect.dwDuration;
	if (m_Duration == INFINITE) {
		m_Duration = 0;		// 0 represents infinite
	} else if (m_Duration > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		m_Duration = MAX_TIME_200;
	}
	m_Gain = diEffect.dwGain;
	if (m_Gain > 10000) {
		hr = DI_TRUNCATED;
		m_Gain = 10000;
	}

	// Sample period
	m_SamplePeriod = diEffect.dwSamplePeriod;
	if (m_SamplePeriod > MAX_TIME_200) {
		hr = DI_TRUNCATED;
		m_SamplePeriod = MAX_TIME_200;
	} else if (m_SamplePeriod == 0) {	// Indicates a default should be used
		m_SamplePeriod = 2000;	// 500htz is the default (2000 micro-secs period)
	}

	return hr;
}

HRESULT InternalEffect::Modify(InternalEffect& diEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	return SFERR_NO_SUPPORT;
}


BYTE InternalEffect::ComputeChecksum(const DataPacket& packet, short int numFields)
{
	if (packet.m_pData == NULL) {
		ASSUME_NOT_REACHED();
		return 0;
	}

	BYTE checkSum = 0;
	for (short int index = 5; index < numFields; index++) {	// Skip header
		checkSum += packet.m_pData[index];
	}
	return ((-checkSum) & 0x7f);
}

void InternalEffect::FillSysExHeader(DataPacket& packet) const
{
	// SysEx Header
	packet.m_pData[0] = SYS_EX_CMD;							// SysEX CMD
	packet.m_pData[1] = 0;									// Escape to Manufacturer ID
	packet.m_pData[2] = MS_MANUFACTURER_ID & 0x7f;			// Manufacturer High Byte
	packet.m_pData[3] = (MS_MANUFACTURER_ID >> 8) & 0x7f;	// Manufacturer Low Byte (note shifted 8!)
}

void InternalEffect::FillHeader1XX(DataPacket& packet, BYTE effectType, BYTE effectID) const
{
	FillSysExHeader(packet);
	packet.m_pData[4] = JOLT_PRODUCT_ID;					// Product ID

	// What to do params
	packet.m_pData[5] = DNLOAD_DATA | DL_PLAY_STORE | X_AXIS | Y_AXIS;	// OpCode
	packet.m_pData[6] = effectType;		// Effect Type
	packet.m_pData[7] = effectID;		// Effect or NEW_EFFECT_ID

	// Effect parms
	int duration = m_Duration/DURATION_SCALE_1XX;
	packet.m_pData[8] = BYTE(duration & 0x7F);					// Duration Low MidiByte
	packet.m_pData[9] = BYTE(duration >> 7) & 0x7F;				// Duration High MidiByte
}

void InternalEffect::FillHeader200(DataPacket& packet, BYTE effectType, BYTE effectID) const
{
	FillSysExHeader(packet);
	packet.m_pData[4] = ZEP_PRODUCT_ID;					// Product ID

	// What to do params
//	packet.m_pData[5] = DOWNLOAD_OP_200 | STORE_ACTION_200 | X_AXIS_200 | Y_AXIS_200;		// OpCode
	packet.m_pData[5] = (DOWNLOAD_OP_200 << 4) | (STORE_ACTION_200 << 2) | AXIS_ANGLE_200;	// OpCode
	packet.m_pData[6] = effectType;		// Effect Type
	packet.m_pData[7] = effectID;		// Effect or NEW_EFFECT_ID

	// Effect parms
	unsigned short int duration = 0;
	if (m_Duration != 0) {
		duration = unsigned short(m_Duration/DURATION_SCALE_200);
		if (duration == 0) {
			duration = 1;		// We don't want to round down to 0 (infinite)
		}
	}
	packet.m_pData[8] = BYTE(duration & 0x7F);				// Duration Low MidiByte
	packet.m_pData[9] = BYTE(duration >> 7) & 0x7F;			// Duration High MidiByte
}

HRESULT InternalEffect::FillModifyPacket1XX(BYTE packetIndex, BYTE paramIndex, DWORD value) const
{
	DataPacket* setIndexPacket = g_pDataPackager->GetPacket(packetIndex);
	if ((setIndexPacket == NULL) || (!setIndexPacket->AllocateBytes(3))) {
		g_pDataPackager->ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	setIndexPacket->m_pData[0] = EFFECT_CMD | DEFAULT_MIDI_CHANNEL;
	setIndexPacket->m_pData[1] = SET_INDEX | BYTE(paramIndex << 2);
	setIndexPacket->m_pData[2] = m_DeviceEffectID & 0x7F;
	setIndexPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_SETINDEX);
	setIndexPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	// Packet to set modify data[index] of current effect
	DataPacket* modifyParamPacket = g_pDataPackager->GetPacket(packetIndex+1);
	if ((modifyParamPacket == NULL) || (!modifyParamPacket->AllocateBytes(3))) {
		g_pDataPackager->ClearPackets();
		return SFERR_DRIVER_ERROR;
	}

	modifyParamPacket->m_pData[0] = MODIFY_CMD | DEFAULT_MIDI_CHANNEL;
	modifyParamPacket->m_pData[1] = BYTE(value & 0x7f);
	modifyParamPacket->m_pData[2] = BYTE(value >> 7) & 0x7f;
	modifyParamPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyParamPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

HRESULT InternalEffect::FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, DWORD value) const
{
	BYTE low = BYTE(value & 0x7F);
	BYTE high = BYTE(value >> 7) & 0x7F;
	return FillModifyPacket200(packetIndex, paramIndex, low, high);
}

HRESULT InternalEffect::FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, BYTE low, BYTE high) const
{
	DataPacket* modifyPacket = g_pDataPackager->GetPacket(packetIndex);
	if ((modifyPacket == NULL) || (!modifyPacket->AllocateBytes(6))) {
		g_pDataPackager->ClearPackets();
		return SFERR_DRIVER_ERROR;
	}
	BYTE id = m_DeviceEffectID;
	if (id == 0) {
		id = m_EffectID;
	}
	modifyPacket->m_pData[0] = MODIFY_CMD_200;
	modifyPacket->m_pData[1] = 0;	// Temporary for checksum calc.
	modifyPacket->m_pData[2] = paramIndex & 0x3F;
	modifyPacket->m_pData[3] = id & 0x7F;
	modifyPacket->m_pData[4] = low & 0x7F;
	modifyPacket->m_pData[5] = high & 0x7F;

	// New checksum method just to be annoying
	BYTE checksum = 0;
	for (int i = 0; i < 6; i++) {
		checksum += modifyPacket->m_pData[i];
	}
	checksum = 0 - checksum;
	checksum &= 0xFF;
	modifyPacket->m_pData[1] = BYTE(checksum & 0x7F);
	modifyPacket->m_pData[2] |= BYTE(checksum >> 1) & 0x40;

	modifyPacket->m_AckNackMethod = g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM);
	modifyPacket->m_NumberOfRetries = MAX_RETRY_COUNT;	// Probably differentiate this

	return SUCCESS;
}

BOOL InternalEffect::IsReallyPlaying(BOOL& multiCheckStop)
{
	if (multiCheckStop == TRUE) {
		return m_IsPossiblyPlaying;
	}
	multiCheckStop = TRUE;

	if (m_IsPossiblyPlaying == FALSE) {
		return FALSE;
	}

	// Do actual check
	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->GetEffectStatus(m_DeviceEffectID);
	if (hr != SUCCESS) {
		return TRUE;
	}
	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr != SUCCESS) {
		return TRUE;
	}

	// Use result returned by GetAckNackData in Transmit
	DWORD dwIn = ackNack.dwEffectStatus;

	// Interpret result (cooked RUNNING_MASK_200 becomes SWDEV_STS_EFFECT_RUNNING)
	m_IsPossiblyPlaying = ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & SWDEV_STS_EFFECT_RUNNING));

	return m_IsPossiblyPlaying;
}

/******************* BehviouralEffect class ******************/
HRESULT BehaviouralEffect::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	ASSUME_NOT_NULL(diEffect.lpvTypeSpecificParams);
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// What axis is where
	short int xIndex = 0;
	short int yIndex = 1;
	if (m_AxesReversed) {	// Reverse the index
		xIndex = 1;
		yIndex = 0;
	}

	if (diEffect.cAxes == 2) {
		if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION)) {	// Angled condition
			m_AxisMask &= ~Y_AXIS;	// Pretend there is only one axis
			xIndex = 0;	// Doesn't matter if reversed
		} else if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION) * 2) { // Two axis effect does no axis mapping
			m_PercentX = 100;
			m_PercentY = 0;
		} else {
			return SFERR_INVALID_PARAM;
		}
	}

	// Fill the type specific (reverses array if needed)
	BYTE* pTypeSpecificArray = (BYTE*)m_ConditionData;
	BYTE* pDITypeSpecific = (BYTE*)(diEffect.lpvTypeSpecificParams);

	if ((m_AxisMask & X_AXIS) != 0) {
		::memcpy(pTypeSpecificArray, pDITypeSpecific + xIndex, sizeof(DICONDITION));
	} else {
		::memset(pTypeSpecificArray, 0, sizeof(DICONDITION));	// No X zero it out
	}
	if ((m_AxisMask & Y_AXIS) != 0) {
		::memcpy(pTypeSpecificArray + sizeof(DICONDITION), pDITypeSpecific + yIndex, sizeof(DICONDITION));
	} else {
		::memset(pTypeSpecificArray + sizeof(DICONDITION), 0, sizeof(DICONDITION));	// No Y zero it out
	}

	// Fix for Andretti, it thinks 0 is default
	if (m_ConditionData[0].dwPositiveSaturation == 0) {
		m_ConditionData[0].dwPositiveSaturation = 10000;
	}
	if (m_ConditionData[0].dwNegativeSaturation == 0) {
		m_ConditionData[0].dwNegativeSaturation = 10000;
	}

	// Check for overzealous numbers
	for (UINT i = 0; i < diEffect.cAxes; i++) {
		if (m_ConditionData[0].lOffset > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lOffset = 10000;
		} else if (m_ConditionData[0].lOffset < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lOffset = 10000;
		}
		if (m_ConditionData[0].lPositiveCoefficient > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lPositiveCoefficient = 10000;
		} else if (m_ConditionData[0].lPositiveCoefficient < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lPositiveCoefficient = -10000;
		}
		if (m_ConditionData[0].lNegativeCoefficient > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lNegativeCoefficient = 10000;
		} else if (m_ConditionData[0].lNegativeCoefficient < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lNegativeCoefficient = -10000;
		}
		if (m_ConditionData[0].dwPositiveSaturation > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].dwPositiveSaturation = 10000;
		}
		if (m_ConditionData[0].dwNegativeSaturation > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].dwNegativeSaturation = 10000;
		}
		if (m_ConditionData[0].lDeadBand > 10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lDeadBand = 10000;
		} else if (m_ConditionData[0].lDeadBand < -10000) {
			hr = DI_TRUNCATED;
			m_ConditionData[0].lDeadBand = -10000;
		}
	}
	
	return hr;
}

/******************* BehaviouralEffect1XX class ******************/
HRESULT BehaviouralEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(22)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader1XX(packet, m_TypeID, NEW_EFFECT_ID);

	packet.m_pData[10]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] & 0x7F);		// Button play mask Low MidiByte
	packet.m_pData[11]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] >> 7) & 0x7F;	// Button play mask High MidiByte

	// Behavioural Specific Parms
	int twoByte = ((ConstantX()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[12]= twoByte & 0x7F;				// Spring/Damper/... Constant X Low
	packet.m_pData[13]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant X High
	twoByte = ((ConstantY()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[14]= twoByte & 0x7F;				// Spring/Damper/... Constant Y Low
	packet.m_pData[15]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant Y High
	twoByte = CenterX()/COEFFICIENT_SCALE_1XX;
	packet.m_pData[16]= twoByte & 0x7F;				// Spring/Damper/... Center X Low
	packet.m_pData[17]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Center X High
	twoByte = CenterY()/COEFFICIENT_SCALE_1XX;
	packet.m_pData[18]= twoByte & 0x7F;				// Spring/Damper/... Center Y Low
	packet.m_pData[19]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Center Y High
	packet.m_pData[20]= ComputeChecksum(packet, 20);	// Checksum

	// End of packet
	packet.m_pData[21]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT BehaviouralEffect1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	AdjustModifyParams(newEffect, modFlags);

	HRESULT hr = SUCCESS;
	BehaviouralEffect1XX* pEffect = (BehaviouralEffect1XX*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_DURATION, pEffect->m_Duration/DURATION_SCALE_1XX);
		nextPacket += 2;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_TRIGGERBUTTONMASK, g_TriggerMap1XX[pEffect->m_TriggerPlayButton]);
		nextPacket += 2;
	}

	BOOL gainChanged = modFlags & DIEP_GAIN;
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Find which ones
		if (ConstantX() != pEffect->ConstantX() || gainChanged) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_COEEFICIENT,
				((pEffect->ConstantX()/COEFFICIENT_SCALE_1XX) * pEffect->m_Gain) / GAIN_PERCENTAGE_SCALE);
			nextPacket += 2;
		}
		if (ConstantY() != pEffect->ConstantY() || gainChanged) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_Y_COEEFICIENT,
				((pEffect->ConstantY()/COEFFICIENT_SCALE_1XX) * pEffect->m_Gain) / GAIN_PERCENTAGE_SCALE);
			nextPacket += 2;
		}
		if (m_HasCenter == TRUE) {
			if (CenterX() != pEffect->CenterX()) {
				hr = FillModifyPacket1XX(nextPacket, INDEX_X_CENTER, pEffect->CenterX()/COEFFICIENT_SCALE_1XX);
				nextPacket += 2;
			}
			if (CenterY() != pEffect->CenterY()) {
				hr = FillModifyPacket1XX(nextPacket, INDEX_Y_CENTER, pEffect->CenterY()/COEFFICIENT_SCALE_1XX);
			}
		}
	}

	return hr;
}

void BehaviouralEffect1XX::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return;
	}

	BehaviouralEffect1XX* pEffect = (BehaviouralEffect1XX*)(&newEffect);
	unsigned short numPackets = 0;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			numPackets += 2;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets += 2;
		}
	}

	int numTypeSpecificChanged = 0;
	if (modFlags & DIEP_GAIN) {	// Did gain really change
		numTypeSpecificChanged = 4;
	} else {
		modFlags &= ~DIEP_GAIN;
	}

	// If type specific or gain
	if ((modFlags & DIEP_TYPESPECIFICPARAMS) || (numTypeSpecificChanged == 0)) { // Find which ones
		if (numTypeSpecificChanged == 0) {	// Kx, Ky not already taken care of by gain?
			if (ConstantX() != pEffect->ConstantX()) {
				numTypeSpecificChanged = 2;
			}
			if (ConstantY() != pEffect->ConstantY()) {
				numTypeSpecificChanged += 2;
			}
		}
		if ((m_HasCenter == TRUE) && (modFlags & DIEP_TYPESPECIFICPARAMS)) { // Don't check these if gain only
			if (CenterX() != pEffect->CenterX()) {
				numTypeSpecificChanged += 2;
			}
			if (CenterY() != pEffect->CenterY()) {
				numTypeSpecificChanged += 2;
			}

		}
	}
	if (numTypeSpecificChanged == 0) {
		modFlags &= ~DIEP_TYPESPECIFICPARAMS; // No type specific changed
	} else {
		numPackets += (unsigned short)numTypeSpecificChanged;
	}

	if (numPackets == 0) {	// That was easy nothing changed
		return;
	}

	g_pDataPackager->AllocateDataPackets(numPackets);
}

/******************* RTCSpring1XX class ******************/
RTCSpring1XX::RTCSpring1XX() : BehaviouralEffect()
{
	m_EffectID = SYSTEM_RTCSPRING_ID;

	// Set defaults
	m_ConditionData[0].lPositiveCoefficient = DEFAULT_RTC_KX;
	m_ConditionData[1].lPositiveCoefficient = DEFAULT_RTC_KY;
	m_ConditionData[0].lOffset = DEFAULT_RTC_X0;
	m_ConditionData[1].lOffset = DEFAULT_RTC_Y0;
	m_ConditionData[0].dwPositiveSaturation = DEFAULT_RTC_XSAT;
	m_ConditionData[1].dwPositiveSaturation = DEFAULT_RTC_YSAT;
	m_ConditionData[0].lDeadBand = DEFAULT_RTC_XDBAND;
	m_ConditionData[1].lDeadBand = DEFAULT_RTC_YDBAND;
}

HRESULT RTCSpring1XX::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	if (diEffect.cbTypeSpecificParams != sizeof(DICONDITION) * 2) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Get the data
	DICONDITION* condition = (DICONDITION*)(diEffect.lpvTypeSpecificParams);
	m_ConditionData[0].lPositiveCoefficient = condition[0].lPositiveCoefficient;
	m_ConditionData[1].lPositiveCoefficient = condition[1].lPositiveCoefficient;
	m_ConditionData[0].lOffset = condition[0].lOffset;
	m_ConditionData[1].lOffset = condition[1].lOffset;
	m_ConditionData[0].dwPositiveSaturation = condition[0].dwPositiveSaturation;
	m_ConditionData[1].dwPositiveSaturation = condition[1].dwPositiveSaturation;
	m_ConditionData[0].lDeadBand = condition[0].lDeadBand;
	m_ConditionData[1].lDeadBand = condition[1].lDeadBand;

	return SUCCESS;
}

HRESULT RTCSpring1XX::FillCreatePacket(DataPacket& packet) const
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

HRESULT RTCSpring1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	// Sanity Check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}
	g_pDataPackager->ClearPackets();

	RTCSpring1XX* pNewRTCSpring = (RTCSpring1XX*)(&newEffect);

	// Find number of packets needed
	unsigned short numPackets = 0;
	if (ConstantX() != pNewRTCSpring->ConstantX()) {
		numPackets += 2;
	}
	if (ConstantY() != pNewRTCSpring->ConstantY()) {
		numPackets += 2;
	}
	if (CenterX() != pNewRTCSpring->CenterX()) {
		numPackets += 2;
	}
	if (CenterY() != pNewRTCSpring->CenterY()) {
		numPackets += 2;
	}
	if (SaturationX() != pNewRTCSpring->SaturationX()) {
		numPackets += 2;
	}
	if (SaturationY() != pNewRTCSpring->SaturationY()) {
		numPackets += 2;
	}
	if (DeadBandX() != pNewRTCSpring->DeadBandX()) {
		numPackets += 2;
	}
	if (DeadBandY() != pNewRTCSpring->DeadBandY()) {
		numPackets += 2;
	}

	if (numPackets == 0) {
		return SUCCESS;
	}

	// Allocate a packets for sending modify command
	if (!g_pDataPackager->AllocateDataPackets(numPackets)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill the packets
	BYTE nextPacket = 0;
	if (ConstantX() != pNewRTCSpring->ConstantX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_COEEFICIENT_X, pNewRTCSpring->ConstantX());
		nextPacket += 2;
	}
	if (ConstantY() != pNewRTCSpring->ConstantY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_COEEFICIENT_Y, pNewRTCSpring->ConstantY());
		nextPacket += 2;
	}
	if (CenterX() != pNewRTCSpring->CenterX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_CENTER_X, pNewRTCSpring->CenterX());
		nextPacket += 2;
	}
	if (CenterY() != pNewRTCSpring->CenterY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_CENTER_Y, pNewRTCSpring->CenterY());
		nextPacket += 2;
	}
	if (SaturationX() != pNewRTCSpring->SaturationX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_SATURATION_X, pNewRTCSpring->SaturationX());
		nextPacket += 2;
	}
	if (SaturationY() != pNewRTCSpring->SaturationY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_SATURATION_Y, pNewRTCSpring->SaturationY());
		nextPacket += 2;
	}
	if (DeadBandX() != pNewRTCSpring->DeadBandX()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_DEADBAND_X, pNewRTCSpring->DeadBandX());
		nextPacket += 2;
	}
	if (DeadBandY() != pNewRTCSpring->DeadBandY()) {
		FillModifyPacket1XX(nextPacket, INDEX_RTC_DEADBAND_Y, pNewRTCSpring->DeadBandY());
	}
	
	return SUCCESS;
}

/******************* BehaviouralEffect200 class ******************/
BYTE BehaviouralEffect200::GetRepeatIndex() const
{
	return INDEX_BE_REPEAT_200;
}

void BehaviouralEffect200::ComputeDsAndFs()
{
	// Assume single axis for now (X) - Will have to add second axis mapping

	// Figure out distances
//	long int d2 = m_ConditionData[0].lOffset - m_ConditionData[0].lDeadBand;
//	long int d3 = m_ConditionData[0].lOffset + m_ConditionData[0].lDeadBand;
	long int d2 = - m_ConditionData[0].lDeadBand;
	long int d3 = m_ConditionData[0].lDeadBand;
	long int d1 = -10000;
	long int d4 = 10000;

	// Compute force at -100 percent position
	float negCoeff = float(m_ConditionData[0].lNegativeCoefficient)/float(10000.0);
	long int f100Neg = long int((10000 + d2) * negCoeff);
	// Check vs proper saturation
	if (negCoeff > 0) {
		if (unsigned long(f100Neg) > m_ConditionData[0].dwNegativeSaturation) {
			f100Neg = m_ConditionData[0].dwNegativeSaturation;
			d1 = long int (-1 * f100Neg/negCoeff) - d2;	// Refigure D1
		}
	} else if (negCoeff < 0) {
		if (unsigned long(-f100Neg) > m_ConditionData[0].dwNegativeSaturation) {
			f100Neg = -1 * m_ConditionData[0].dwNegativeSaturation;
			d1 = long int (-1 * f100Neg/negCoeff) - d2;	// Refigure D1
		}
	}
	// Compute Force include axis-mapping
	f100Neg = long int(f100Neg/100 * (m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(m_TypeID))/100));
	m_Fs[0] = BYTE(float(f100Neg/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;

	// Compute force at +100 percent position
	float posCoeff = float(-m_ConditionData[0].lPositiveCoefficient)/float(10000.0);
	long int f100Pos = long int((10000 - d3) * posCoeff);
	// Check vs proper saturation
	if (posCoeff > 0) {
		if (unsigned long(f100Pos) > m_ConditionData[0].dwPositiveSaturation) {
			f100Pos = m_ConditionData[0].dwPositiveSaturation;
			d4 = long int (f100Pos/posCoeff) + d3;	// Refigure D4
		}
	} else if (posCoeff < 0) {
		if (unsigned long(-f100Pos) > m_ConditionData[0].dwPositiveSaturation) {
			f100Pos = -1 * m_ConditionData[0].dwPositiveSaturation;
			d4 = long int(f100Pos/posCoeff) + d3;	// Refigure D4
		}
	}
	// Compute Force include axis-mapping
	f100Pos = long int(f100Pos/100 * (m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(m_TypeID))/100));
	m_Fs[3] = BYTE(float(f100Pos/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;


	// Convert to device percentages (0 to +126 --- +63 = 0 percent)
	m_Ds[0] = BYTE(float(d1/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
	m_Ds[1] = BYTE(float(d2/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
	m_Ds[2] = BYTE(float(d3/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
	m_Ds[3] = BYTE(float(d4/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;

	if (m_TypeID == ET_SPRING_200) {	// Add proper offsets (squished by max percent)
		// Convert forces to device percentages (0 to +126 --- +63 = 0 percent)
		// m_Fs[0] - Done above
		LONG offset = LONG(float(float(g_ForceFeedbackDevice.GetSpringOffset())/10000.0) * float(f100Neg));
		m_Fs[1] = BYTE(float(offset/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		offset = LONG(float(float(g_ForceFeedbackDevice.GetSpringOffset())/10000.0) * float(f100Pos));
		m_Fs[2] = BYTE(float(offset/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		// m_Fs[3] - Done above
	} else {
		// Convert forces to device percentages (0 to +126 --- +63 = 0 percent)
		// m_Fs[0] - Done above
		m_Fs[1] = 63;	// 0
		m_Fs[2] = 63;	// 0
		// m_Fs[3] - Done above
	}
}

HRESULT BehaviouralEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = BehaviouralEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Compute behavioural params
	ComputeDsAndFs();
	return hr;
}

UINT BehaviouralEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}
	if (m_Gain != 10000) { // Gain
		retCount++;
	}
	if (m_ConditionData[0].lOffset != 0) {	// Center of behaviour
		retCount++;
	}

	return retCount;
}

HRESULT BehaviouralEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (m_Gain != 10000) { // Gain
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}
	if (m_ConditionData[0].lOffset != 0) { // Center of behaviour
		long int deviceUnits = m_ConditionData[0].lOffset/BEHAVIOUR_CENTER_SCALE_200 + BEHAVIOUR_CENTER_200;
		BYTE lowByte = BYTE(deviceUnits & 0x7F);
		BYTE highByte = BYTE(deviceUnits >> 7) & 0x7F;
		hr = FillModifyPacket200(nextPacket, INDEX_BE_CENTER_200, lowByte, highByte);
		nextPacket++;
	}

	return hr;
}

HRESULT BehaviouralEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(21)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, m_TypeID, NEW_EFFECT_ID);

	// All of the below items fit in one MidiByte (0..126/127) after conversion
	unsigned short effectAngle = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(effectAngle & 0x7F);		// Effect Angle

	// Computed in create
	packet.m_pData[11]= m_Ds[0];
	packet.m_pData[12]= m_Fs[0];
	packet.m_pData[13]= m_Ds[1];
	packet.m_pData[14]= m_Fs[1];
	packet.m_pData[15]= m_Ds[2];
	packet.m_pData[16]= m_Fs[2];
	packet.m_pData[17]= m_Ds[3];
	packet.m_pData[18]= m_Fs[3];

	// End this puppy
	packet.m_pData[19]= ComputeChecksum(packet, 19);	// Checksum
	packet.m_pData[20]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}


HRESULT BehaviouralEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	HRESULT hr = SUCCESS;
	BehaviouralEffect200* pEffect = (BehaviouralEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	if (modFlags & DIEP_GAIN) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}

	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		for (int i = 0; i < 4; i++) {
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				hr = FillModifyPacket200(nextPacket, INDEX_D1F1_200 + i, pEffect->m_Ds[i], pEffect->m_Fs[i]);
				nextPacket++;
			}
		}
		if (m_ConditionData[0].lOffset != pEffect->m_ConditionData[0].lOffset) { // Center of behaviour
			long int deviceUnits = pEffect->m_ConditionData[0].lOffset/BEHAVIOUR_CENTER_SCALE_200 + BEHAVIOUR_CENTER_200;
			BYTE lowByte = BYTE(deviceUnits & 0x7F);
			BYTE highByte = BYTE(deviceUnits >> 7) & 0x7F;
			hr = FillModifyPacket200(nextPacket, INDEX_BE_CENTER_200, lowByte, highByte);
			nextPacket++;
		}
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}

	return hr;
}

HRESULT BehaviouralEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_DIRECTION;
/*	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}
*/
	BehaviouralEffect200* pEffect = (BehaviouralEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	HRESULT hr = SUCCESS;;

	if ((modFlags & (~possMod & DIEP_ALLPARAMS)) != 0) {
		modFlags &= possMod;
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {	// Did gain really change
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags |= DIEP_TYPESPECIFICPARAMS;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) { // Find which ones (if any)
		int numTypeSpecificChanged = 0;
		for (int i = 0; i < 4; i++) {
			// Ds and Fs are changed togeather
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				numTypeSpecificChanged++;
			}
		}
		if (m_ConditionData[0].lOffset != pEffect->m_ConditionData[0].lOffset) { // Center of behaviour
			numTypeSpecificChanged++;
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS; // No type specific changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}

	if (numPackets != 0) {	// Was anything really changed
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* RTCSpring200 class ******************/
RTCSpring200::RTCSpring200() : BehaviouralEffect200(ET_SPRING_200)
{
	m_EffectID = ID_RTCSPRING_200;

	// Set defaults
	m_ConditionData[0].lPositiveCoefficient = DEFAULT_RTC_KX;
	m_ConditionData[1].lPositiveCoefficient = DEFAULT_RTC_KY;
	m_ConditionData[0].lNegativeCoefficient = DEFAULT_RTC_KX;
	m_ConditionData[1].lNegativeCoefficient = DEFAULT_RTC_KY;
	m_ConditionData[0].lOffset = DEFAULT_RTC_X0;
	m_ConditionData[1].lOffset = DEFAULT_RTC_Y0;
	m_ConditionData[0].dwPositiveSaturation = DEFAULT_RTC_XSAT;
	m_ConditionData[1].dwPositiveSaturation = DEFAULT_RTC_YSAT;
	m_ConditionData[0].dwNegativeSaturation = DEFAULT_RTC_XSAT;
	m_ConditionData[1].dwNegativeSaturation = DEFAULT_RTC_YSAT;
	m_ConditionData[0].lDeadBand = DEFAULT_RTC_XDBAND;
	m_ConditionData[1].lDeadBand = DEFAULT_RTC_YDBAND;
}

HRESULT RTCSpring200::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	ASSUME_NOT_NULL(diEffect.lpvTypeSpecificParams);
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION)*2) {
		::memcpy(m_ConditionData, diEffect.lpvTypeSpecificParams, sizeof(DICONDITION)*2);
	} else if (diEffect.cbTypeSpecificParams == sizeof(DICONDITION)) {
		::memcpy(m_ConditionData, diEffect.lpvTypeSpecificParams, sizeof(DICONDITION));
		::memset(m_ConditionData + 1, 0, sizeof(DICONDITION));
	} else if (diEffect.cbTypeSpecificParams == sizeof(RTCSPRING_PARAM)) {
		::memset(m_ConditionData, 0, sizeof(DICONDITION)*2);

		RTCSPRING_PARAM* pOldRTCParam = (RTCSPRING_PARAM*)(diEffect.lpvTypeSpecificParams);
		m_ConditionData[0].lPositiveCoefficient = pOldRTCParam->m_XKConstant;
		m_ConditionData[1].lPositiveCoefficient = pOldRTCParam->m_YKConstant;
		m_ConditionData[0].lNegativeCoefficient = pOldRTCParam->m_XKConstant;
		m_ConditionData[1].lNegativeCoefficient = pOldRTCParam->m_YKConstant;
		m_ConditionData[0].lOffset = pOldRTCParam->m_XAxisCenter;
		m_ConditionData[1].lOffset = pOldRTCParam->m_YAxisCenter;
		m_ConditionData[0].dwPositiveSaturation = DWORD(pOldRTCParam->m_XSaturation);
		m_ConditionData[1].dwPositiveSaturation = DWORD(pOldRTCParam->m_YSaturation);
		m_ConditionData[0].dwNegativeSaturation = DWORD(pOldRTCParam->m_XSaturation);
		m_ConditionData[1].dwNegativeSaturation = DWORD(pOldRTCParam->m_YSaturation);
		m_ConditionData[0].lDeadBand = pOldRTCParam->m_XDeadBand;
		m_ConditionData[1].lDeadBand = pOldRTCParam->m_YDeadBand;
	} else {
		return SFERR_INVALID_PARAM;
	}

	// Check parameters for truncation
	BOOL truncated = FALSE;
	if (m_ConditionData[0].lPositiveCoefficient > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lPositiveCoefficient = 10000;
	} else 	if (m_ConditionData[0].lPositiveCoefficient < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lPositiveCoefficient = -10000;
	}
	if (m_ConditionData[0].lNegativeCoefficient > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lNegativeCoefficient = 10000;
	} else 	if (m_ConditionData[0].lNegativeCoefficient < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lNegativeCoefficient = -10000;
	}
	if (m_ConditionData[0].lOffset > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lOffset = 10000;
	} else 	if (m_ConditionData[0].lOffset < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lOffset = -10000;
	}
	if (m_ConditionData[0].dwPositiveSaturation > 10000) {
		truncated = TRUE;
		m_ConditionData[0].dwPositiveSaturation  = 10000;
	}
	if (m_ConditionData[0].dwNegativeSaturation > 10000) {
		truncated = TRUE;
		m_ConditionData[0].dwNegativeSaturation = 10000;
	}
	if (m_ConditionData[0].lDeadBand > 10000) {
		truncated = TRUE;
		m_ConditionData[0].lDeadBand = 10000;
	} else 	if (m_ConditionData[0].lDeadBand < -10000) {
		truncated = TRUE;
		m_ConditionData[0].lDeadBand = -10000;
	}

	m_PercentX = 100;
	m_PercentY = 0;

	// Compute behavioural params
	ComputeDsAndFs();
	if (truncated == TRUE) {
		return DI_TRUNCATED;
	}
	return SUCCESS;
}

HRESULT RTCSpring200::FillCreatePacket(DataPacket& packet) const
{
	return SUCCESS;
}

UINT RTCSpring200::GetModifyOnlyNeeded() const
{
	return 3;	// One is added for create. There is no Create, so we return 1 less than needed
}

HRESULT RTCSpring200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	for (BYTE i = 0; i < 4; i++) {
		FillModifyPacket200(i, INDEX_D1F1_200 + i, m_Ds[i], m_Fs[i]);
	}

	return SUCCESS;
}


HRESULT RTCSpring200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	// Sanity Check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}
	g_pDataPackager->AllocateDataPackets(4);
	RTCSpring200* pNewRTCSpring = (RTCSpring200*)(&newEffect);
	for (BYTE i = 0; i < 4; i++) {
		FillModifyPacket200(i, INDEX_D1F1_200 + i, pNewRTCSpring->m_Ds[i], pNewRTCSpring->m_Fs[i]);
	}

	return SUCCESS;
}


/************** FictionEffect1XX class **********************/
override HRESULT FrictionEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(22)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader1XX(packet, m_TypeID, NEW_EFFECT_ID);

	packet.m_pData[10]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] & 0x7F);		// Button play mask Low MidiByte
	packet.m_pData[11]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] >> 7) & 0x7F;	// Button play mask High MidiByte

	// Friction Specific Parms
	int twoByte = ((ConstantX()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[12]= twoByte & 0x7F;				// Spring/Damper/... Constant X Low
	packet.m_pData[13]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant X High
	twoByte = ((ConstantY()/COEFFICIENT_SCALE_1XX) * m_Gain) / GAIN_PERCENTAGE_SCALE;
	packet.m_pData[14]= twoByte & 0x7F;				// Spring/Damper/... Constant Y Low
	packet.m_pData[15]= (twoByte >> 7) & 0x7F;		// Spring/Damper/... Constant Y High

	packet.m_pData[20]= ComputeChecksum(packet, 20);	// Checksum

	// End of packet
	packet.m_pData[21]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

/******************* FrictionEffect200 class *********************/
BYTE FrictionEffect200::GetRepeatIndex() const
{
	return INDEX_FE_REPEAT_200;
}

UINT FrictionEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}
	if (m_Gain != 10000) {	// Gain
		retCount++;
	}

	return retCount;
}

HRESULT FrictionEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (m_Gain != 10000) {	// Gain
		hr = FillModifyPacket200(nextPacket, INDEX_FE_GAIN_200, DWORD(float(m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}

	return hr;
}

HRESULT FrictionEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(14)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, m_TypeID, NEW_EFFECT_ID);

	// All of the below items fit in one MidiByte (0..126/127) after conversion
	unsigned short effectAngle = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(effectAngle & 0x7F);		// Effect Angle

	// Computed in create
	packet.m_pData[11]= BYTE(float(ConstantX() + 10000)/FRICTION_SCALE_200) & 0x7F;

	// End this puppy
	packet.m_pData[12]= ComputeChecksum(packet, 12);	// Checksum
	packet.m_pData[13]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT FrictionEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();

	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	FrictionEffect200* pEffect = (FrictionEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	DWORD calc_byte;

	HRESULT hr = SUCCESS;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_FE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}

	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_FE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		calc_byte = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_FE_GAIN_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		calc_byte = DWORD(pEffect->m_SamplePeriod/DURATION_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_PE_SAMPLE_PERIOD_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		if (ConstantX() != pEffect->ConstantX()) {
			calc_byte = DWORD(float(pEffect->ConstantX() + 10000)/FRICTION_SCALE_200) & 0x7F;
			hr = FillModifyPacket200(nextPacket, INDEX_FE_COEEFICIENT_200, calc_byte);
			nextPacket++;
		}
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT FrictionEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_DIRECTION;
/*	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}
*/

	FrictionEffect200* pEffect = (FrictionEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	BOOL playingChecked = FALSE;
	HRESULT hr = SUCCESS;

	if ((modFlags & (~possMod & DIEP_ALLPARAMS)) != 0) {
		modFlags &= possMod;
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger reapeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		if (m_SamplePeriod == pEffect->m_SamplePeriod) {
			modFlags &= ~DIEP_SAMPLEPERIOD; // Remove sample period flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags |= DIEP_TYPESPECIFICPARAMS;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) { 	// Type specific change flagged
		// Computed in create
		if (ConstantX() == pEffect->ConstantX()) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing really changed
		} else {
			numPackets++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* PeriodicEffect class *********************/
PeriodicEffect::PeriodicEffect() : InternalEffect(),
	m_pEnvelope(NULL)
{
	::memset(&m_PeriodicData, 0, sizeof(m_PeriodicData));
}

PeriodicEffect::~PeriodicEffect()
{
	if (m_pEnvelope != NULL) {
		delete m_pEnvelope;
		m_pEnvelope = NULL;
	}
}

HRESULT PeriodicEffect::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	ASSUME_NOT_NULL(diEffect.lpvTypeSpecificParams);
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(m_PeriodicData)) {
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Fill the type specific
	::memcpy(&m_PeriodicData, diEffect.lpvTypeSpecificParams, sizeof(m_PeriodicData));
	if (m_PeriodicData.dwMagnitude > 10000) {
		m_PeriodicData.dwMagnitude = 10000;
		hr = DI_TRUNCATED;
	}
	if (m_PeriodicData.lOffset > 10000) {
		m_PeriodicData.lOffset = 10000;
		hr = DI_TRUNCATED;
	} else if (m_PeriodicData.lOffset < -10000) {
		m_PeriodicData.lOffset = -10000;
		hr = DI_TRUNCATED;
	}
	if (m_PeriodicData.dwPeriod > MAX_TIME_200) {
		m_PeriodicData.dwPeriod = MAX_TIME_200;
		hr = DI_TRUNCATED;
	}

	return hr;
}

/******************* PeriodicEffect1XX class ******************/
HRESULT PeriodicEffect1XX::Create(const DIEFFECT& diEffect)
{
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();	// DI is flaking
		return SFERR_INVALID_PARAM;
	}

	HRESULT hr;
	if (diEffect.cbTypeSpecificParams == sizeof(DICONSTANTFORCE)) {	// Special case Constant Force
		if (m_TypeID != ET_SE_CONSTANT_FORCE) {
			ASSUME_NOT_REACHED();	// DI is flaking
			return SFERR_INVALID_PARAM;
		}
		DIPERIODIC periodic;
		DICONSTANTFORCE* pConstantForce = (DICONSTANTFORCE*)(diEffect.lpvTypeSpecificParams);
		if (pConstantForce->lMagnitude < 0) {
			periodic.lOffset = -1;	// We use offset to indicate sign
			periodic.dwMagnitude = DWORD(0 - pConstantForce->lMagnitude);
		} else {
			periodic.lOffset = 1;
			periodic.dwMagnitude = DWORD(pConstantForce->lMagnitude);
		}
		periodic.dwPhase = 0;
		periodic.dwPeriod = 0;	// Conversion will make a freq of 1
		DIEFFECT* pDIEffect = (DIEFFECT*)(&diEffect);	// Hack to temp remove constness
		pDIEffect->cbTypeSpecificParams = sizeof(DIPERIODIC);
		pDIEffect->lpvTypeSpecificParams = &periodic;	// Replace Constant Force Parms with periodic
		hr = PeriodicEffect::Create(diEffect);
		pDIEffect->cbTypeSpecificParams = sizeof(DICONSTANTFORCE);
		pDIEffect->lpvTypeSpecificParams = pConstantForce;	// Return parms back
	} else if (diEffect.cbTypeSpecificParams == sizeof(DIRAMPFORCE)) {	// Special case RampForce
		if (m_TypeID != ET_SE_RAMPUP) {
			ASSUME_NOT_REACHED();	// DI is flaking
			return SFERR_INVALID_PARAM;
		}
		DIPERIODIC periodic;
		DIRAMPFORCE* pRampForce = (DIRAMPFORCE*)(diEffect.lpvTypeSpecificParams);
		if (pRampForce->lStart < pRampForce->lEnd) {
			m_TypeID = ET_SE_RAMPDOWN;
			periodic.dwMagnitude = DWORD(pRampForce->lEnd - pRampForce->lStart)/2;
		} else {
			periodic.dwMagnitude = DWORD(pRampForce->lStart - pRampForce->lEnd)/2;
		}
		periodic.lOffset = (pRampForce->lStart + pRampForce->lEnd)/2;
		periodic.dwPeriod = 0;	// Conversion will make a freq of 1
		DIEFFECT* pDIEffect = (DIEFFECT*)(&diEffect);	// Hack to temp remove constness
		pDIEffect->cbTypeSpecificParams = sizeof(DIPERIODIC);
		pDIEffect->lpvTypeSpecificParams = &periodic;	// Replace Constant Force Parms with periodic
		hr = PeriodicEffect::Create(diEffect);
		pDIEffect->cbTypeSpecificParams = sizeof(DIRAMPFORCE);
		pDIEffect->lpvTypeSpecificParams = pRampForce;	// Return parms back
	} else {
		hr = PeriodicEffect::Create(diEffect);
	}

	// How did creation go?
	if (hr != SUCCESS) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_pEnvelope = new Envelope1XX(diEffect.lpEnvelope, Offset(), m_Duration);

	// Is it closer to sine or cosine
	if (m_TypeID == ET_SE_SINE) {
		if (((Phase() >= 4500) && (Phase() < 13500)) || ((Phase() >= 22500) && (Phase() < 31500))) {
			m_TypeID = ET_SE_COSINE;
		}
	} else if ((Phase() >= 9000) && (Phase() < 27000)) {
		if (m_TypeID == SE_SQUAREHIGH) {
			m_TypeID = SE_SQUARELOW;
		} else if (m_TypeID == SE_TRIANGLEUP) {
			m_TypeID = SE_TRIANGLEDOWN;
		}
	}
	return SUCCESS;
}

void PeriodicEffect1XX::DIToJolt(DWORD mag, DWORD off, DWORD gain, DWORD& max, DWORD& min) const
{
	if (m_TypeID == ET_SE_CONSTANT_FORCE) {
		ASSUME(off == -1 || off == 1);	// Indicates sign for ConstantForce
		min = 0;
		max = off * (mag/GAIN_PERCENTAGE_SCALE) * gain;
	} else {
		DWORD half = ((mag/GAIN_PERCENTAGE_SCALE) * gain)/2;
		min = off - half;
		max = off + half;
	}
}

DWORD PeriodicEffect1XX::DIPeriodToJoltFreq(DWORD period)
{
	if (period == 0) {
		return 1;
	}
	DWORD freq = FREQUENCY_SCALE_1XX/period;
	if (freq == 0) {
		freq = 1;
	} else if (freq > 500) {
		freq = 500;
	}
	return freq;
}


HRESULT PeriodicEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	// Sanity check
	if (m_pEnvelope == NULL) {
		ASSUME_NOT_REACHED();	// Should never happen
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(34)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader1XX(packet, m_TypeID, NEW_EFFECT_ID);

	// Periodic Specific Parms (Freq, Max, Min)
	packet.m_pData[10]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] & 0x7F);		// Button play mask Low MidiByte
	packet.m_pData[11]= BYTE(g_TriggerMap1XX[m_TriggerPlayButton] >> 7) & 0x7F;	// Button play mask High MidiByte
	packet.m_pData[12] = BYTE(m_EffectAngle & 0x7F);			// DirectionAngle Low
	packet.m_pData[13] = BYTE(m_EffectAngle >> 7) & 0x7F;	// DirectionAngle High
	packet.m_pData[14] = 100;							// Gain (encoded in coeficents)
	packet.m_pData[15]= BYTE(500 & 0x7F);					// ForceOutput Rate LowByte
	packet.m_pData[16]= BYTE(500 >> 7) & 0x7F;			// ForceOutput Rate HighByte
	packet.m_pData[17]= 0x7F;						// Percent LowByte
	packet.m_pData[18]= 0;							// Percent HighByte

	// Envelope
//	Envelope1XX* pEnvelope = dynamic_cast<Envelope1XX*>(m_pEnvelope);
	Envelope1XX* pEnvelope = (Envelope1XX*)(m_pEnvelope);
	packet.m_pData[19] = BYTE(pEnvelope->m_StartPercent & 0x7F);		// Initial attack level
	packet.m_pData[20] = BYTE(pEnvelope->m_AttackTime& 0x7F);			// AttackTime Low
	packet.m_pData[21] = BYTE(pEnvelope->m_AttackTime>> 7) & 0x7F;		// AttackTime High
	packet.m_pData[22] = BYTE(pEnvelope->m_SustainPercent & 0x7F);		// Sustain level
	packet.m_pData[23] = BYTE(pEnvelope->m_SustainTime & 0x7F);			// SustainTime Low
	packet.m_pData[24] = BYTE(pEnvelope->m_SustainTime >> 7) & 0x7F;	// SustainTime High
	packet.m_pData[25] = BYTE(pEnvelope->m_EndPercent & 0x7F);			// What to decay to
	// --  Duration of decay is ficugred from total duration

	DWORD freq = DIPeriodToJoltFreq(Period());
	packet.m_pData[26]= BYTE(freq & 0x7F);				// Frequency LowByte
	packet.m_pData[27]= BYTE(freq >> 7) & 0x7F;			// Frequency HighByte
	DWORD max, min;
	DIToJolt(Magnitude(), Offset(), m_Gain, max, min);
	min /= COEFFICIENT_SCALE_1XX;
	max /= COEFFICIENT_SCALE_1XX;
	packet.m_pData[28]= BYTE(max & 0x7F);			// Max LowByte
	packet.m_pData[29]= BYTE(max >> 7) & 0x7F;		// Max HighByte
	packet.m_pData[30]= BYTE(min & 0x7F);			// Min LowByte
	packet.m_pData[31]= BYTE(min >> 7) & 0x7F;		// Min HighByte

	packet.m_pData[32]= ComputeChecksum(packet, 32);	// Checksum

	// End of packet
	packet.m_pData[33]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT PeriodicEffect1XX::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TYPESPECIFICPARAMS;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}

	PeriodicEffect1XX* pEffect = (PeriodicEffect1XX*)(&newEffect);
	unsigned short numPackets = 0;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			numPackets += 2;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets += 2;
		}
	}

	// Either gain or type specific changed
	if (modFlags & (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS)) {
		DWORD oldMax, oldMin, newMax, newMin;
		DIToJolt(Magnitude(), Offset(), m_Gain, oldMax, oldMin);
		DIToJolt(pEffect->Magnitude(), pEffect->Offset(), pEffect->m_Gain, newMax, newMin);

		int numTypeSpecificChanged = 0;
		// Max changed?
		if (oldMax != newMax) {
			numTypeSpecificChanged = 2;
		}
		// Min changed?
		if (oldMin != newMin) {
			numTypeSpecificChanged += 2;
		}
		if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Don't check these if gain only
			// Phase (1XX cannot change)
			if (Phase() != pEffect->Phase()) {
				return SFERR_NO_SUPPORT;
			}
			// Period
			if (Period() != pEffect->Period()) {
				numTypeSpecificChanged += 2;
			}
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~(DIEP_TYPESPECIFICPARAMS | DIEP_GAIN); // Nothing really changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return SUCCESS;
}

HRESULT PeriodicEffect1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT hr = AdjustModifyParams(newEffect, modFlags);
	if (hr != SUCCESS) {
		return hr;
	}

	PeriodicEffect1XX* pEffect = (PeriodicEffect1XX*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_DURATION, pEffect->m_Duration/DURATION_SCALE_1XX);
		nextPacket += 2;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket1XX(nextPacket, INDEX_TRIGGERBUTTONMASK, g_TriggerMap1XX[pEffect->m_TriggerPlayButton]);
		nextPacket += 2;
	}

	if (modFlags & (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS)) {
		DWORD oldMax, oldMin, newMax, newMin;
		DIToJolt(Magnitude(), Offset(), m_Gain, oldMax, oldMin);
		DIToJolt(pEffect->Magnitude(), pEffect->Offset(), pEffect->m_Gain, newMax, newMin);

		if (oldMax != newMax) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_COEEFICIENT, (newMax/COEFFICIENT_SCALE_1XX));
			nextPacket += 2;
		}
		if (oldMin != newMin) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_COEEFICIENT, (newMin/COEFFICIENT_SCALE_1XX));
			nextPacket += 2;
		}
		if (Period() != pEffect->Period()) {
			hr = FillModifyPacket1XX(nextPacket, INDEX_X_CENTER, pEffect->Period()/COEFFICIENT_SCALE_1XX);
			nextPacket += 2;
		}
	}
	return hr;
}

/******************* PeriodicEffect200 class ******************/
BYTE PeriodicEffect200::GetRepeatIndex() const
{
	return INDEX_PE_REPEAT_200;
}

long int PeriodicEffect200::Phase() const
{
	long int phase = m_PeriodicData.dwPhase;
	if (m_EffectAngle <= 18000) {
		phase += 18000;
		phase %= 36000;
	}
	return phase;
}


HRESULT PeriodicEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = PeriodicEffect::Create(diEffect);

	// How did creation go?
	if (FAILED(hr)) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_PercentAdjustment = m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(m_TypeID))/100;
	m_Gain = m_Gain/100 * m_PercentAdjustment;
	m_pEnvelope = new Envelope200(diEffect.lpEnvelope, Magnitude(), m_Duration, hr);

	return hr;
}

UINT PeriodicEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if ((m_SamplePeriod/DURATION_SCALE_200) != 1) {
		retCount++;
	}
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}

	return retCount;
}

HRESULT PeriodicEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;

	DWORD calc_byte = DWORD(m_SamplePeriod/DURATION_SCALE_200);
	if (calc_byte != 1) {	// Sample period
		hr = FillModifyPacket200(nextPacket, INDEX_PE_SAMPLE_PERIOD_200, calc_byte);
		nextPacket++;
	}
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	return hr;
}

HRESULT PeriodicEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Sanity check
	if (m_pEnvelope == NULL) {
		ASSUME_NOT_REACHED();	// Should never happen
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(26)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, m_TypeID, NEW_EFFECT_ID);

	unsigned short calc_byte = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(calc_byte & 0x7F);			// Effect Angle
	calc_byte = unsigned short(float(m_Gain)/GAIN_SCALE_200);
	packet.m_pData[11]= BYTE(calc_byte & 0x7F);			// Gain
	calc_byte = unsigned short(float(Phase())/PHASE_SCALE_200);
	packet.m_pData[12]= BYTE(calc_byte & 0x7F);			// Phase Low
	packet.m_pData[13]= BYTE(calc_byte >> 7) & 0x7F;	// Phase High

	// Envelope
	Envelope200* pEnvelope = (Envelope200*)(m_pEnvelope);
	packet.m_pData[14] = BYTE(pEnvelope->m_StartPercent & 0x7F);	// Initial attack level
	packet.m_pData[15] = BYTE(pEnvelope->m_AttackTime& 0x7F);		// AttackTime Low
	packet.m_pData[16] = BYTE(pEnvelope->m_AttackTime>> 7) & 0x7F;	// AttackTime High
	packet.m_pData[17] = BYTE(pEnvelope->m_SustainPercent & 0x7F);	// Sustain level
	packet.m_pData[18] = BYTE(pEnvelope->m_FadeStart & 0x7F);		// SustainTime Low
	packet.m_pData[19] = BYTE(pEnvelope->m_FadeStart >> 7) & 0x7F;	// SustainTime High
	packet.m_pData[20] = BYTE(pEnvelope->m_EndPercent & 0x7F);		// What to decay to
	// --  Duration of decay is figured by the firmware from total duration

	calc_byte = unsigned short(Period()/DURATION_SCALE_200);
	if (calc_byte == 0) {
		calc_byte = 1;
	}
	packet.m_pData[21] = BYTE(calc_byte & 0x7F);		// Period Low MidiByte
	packet.m_pData[22] = BYTE(calc_byte >> 7) & 0x7F;	// Period High MidiByte

	// Convert offset to device percentage (0 to +126 --- +63 = 0 percent)
	calc_byte = unsigned short(float(Offset()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
	packet.m_pData[23] = BYTE(calc_byte & 0x7F);		// Offset

	packet.m_pData[24]= ComputeChecksum(packet, 24);	// Checksum

	// End of packet
	packet.m_pData[25]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT PeriodicEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_SAMPLEPERIOD | DIEP_ENVELOPE | DIEP_DIRECTION;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}

	PeriodicEffect200* pEffect = (PeriodicEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	HRESULT hr = SUCCESS;

	if ((modFlags & (DIEP_AXES)) != 0) {
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				modFlags |= DIEP_ENVELOPE;	// Duration change forces envelope change
				numPackets++;
			}
		}
	}

	if (modFlags & DIEP_DIRECTION) {
		modFlags |= (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS);
		if (m_EffectAngle != pEffect->m_EffectAngle) {
			numPackets++;
		} else {
			modFlags &= ~DIEP_DIRECTION;
		}
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Check type specific
		int numTypeSpecificChanged = 0;
		if (Phase() != pEffect->Phase()) {
			numTypeSpecificChanged++;
		}
		if (Period() != pEffect->Period()) {
			numTypeSpecificChanged++;
		}
		if (Offset() != pEffect->Offset()) {
			numTypeSpecificChanged++;
		}
		if (Magnitude() != pEffect->Magnitude()) {
			modFlags |= DIEP_ENVELOPE;	// This effects the envelope
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing really changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}
	if (modFlags & DIEP_ENVELOPE) {
		int numEnvelopeChanged = 0;

		if (m_pEnvelope == NULL || pEffect->m_pEnvelope == NULL) {
			ASSUME_NOT_REACHED();	// Envelope should always be created!
		} else {
			Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
			Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
			if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
				numEnvelopeChanged++;
			}
		}

		if (numEnvelopeChanged == 0) {
			modFlags &= ~DIEP_ENVELOPE; // Remove envelope flag, unchanged
		} else {
			numPackets += (USHORT)numEnvelopeChanged;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger reapeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		if (m_SamplePeriod == pEffect->m_SamplePeriod) {
			modFlags &= ~DIEP_SAMPLEPERIOD; // Remove sample period flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

HRESULT PeriodicEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustReturned = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustReturned)) {
		return adjustReturned;
	}

	HRESULT hr = SUCCESS;
	PeriodicEffect200* pEffect = (PeriodicEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	DWORD calc_byte;

	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}

	if (modFlags & DIEP_DIRECTION) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_DIRECTIONANGLE_200, unsigned short(float(pEffect->m_EffectAngle)/ANGLE_SCALE_200));
		nextPacket++;
	}

	if (modFlags & DIEP_ENVELOPE) {
		Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
		Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
		if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_STARTPERCENT_200, pNewEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_ATTTACK_TIME_200, pNewEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_SUSTAINPERCENT_200, pNewEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_FADESTART_200, pNewEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_ENDPERCENT_200, pNewEnvelope->m_EndPercent);
			nextPacket++;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_PE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		calc_byte = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_PE_GAIN_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_SAMPLEPERIOD) {
		calc_byte = DWORD(pEffect->m_SamplePeriod/DURATION_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_PE_SAMPLE_PERIOD_200, calc_byte);
		nextPacket++;
	}

	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		if (Phase() != pEffect->Phase()) {
			calc_byte = DWORD(float(pEffect->Phase())/PHASE_SCALE_200);
			hr = FillModifyPacket200(nextPacket, INDEX_PE_PHASE_200, calc_byte);
			nextPacket++;
		}
		if (Period() != pEffect->Period()) {
			hr = FillModifyPacket200(nextPacket, INDEX_PE_PERIOD_200, pEffect->Period()/DURATION_SCALE_200);
			nextPacket++;
		}
		if (Offset() != pEffect->Offset()) {
			calc_byte = DWORD(float(pEffect->Offset()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
			hr = FillModifyPacket200(nextPacket, INDEX_PE_OFFSET_200, calc_byte);
			nextPacket++;
		}
	}

	if (hr == SUCCESS) {
		return adjustReturned;
	}
	return hr;
}

/******************* SawtoothEffect200 class ******************/
HRESULT SawtoothEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT retVal = PeriodicEffect200::Create(diEffect);

	if ((m_IsUp && (m_EffectAngle < 18000)) || (!m_IsUp && (m_EffectAngle > 18000))) {			// SawtoothUp use 0 degrees
		m_EffectAngle = 18000;
	} else {				// SawtoothDown use 180 degress
		m_EffectAngle = 0;
	}

	return retVal;
}

long int SawtoothEffect200::Phase() const
{
	return m_PeriodicData.dwPhase;
}

/******************* RampEffect200 class ******************/
HRESULT RampEffect200::Create(const DIEFFECT& diEffect)
{
	// Sanity checks
	if (diEffect.cbTypeSpecificParams != sizeof(DIRAMPFORCE)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Ramps cannot have infinite duration
	if (diEffect.dwDuration == INFINITE) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Create periodic structure and put in the correct values
	DIPERIODIC periodic;
	DIRAMPFORCE* pRampForce = (DIRAMPFORCE*)(diEffect.lpvTypeSpecificParams);
	periodic.dwPhase = 0;
	periodic.dwPeriod = diEffect.dwDuration;
	periodic.lOffset = -(pRampForce->lStart + pRampForce->lEnd)/2;
	if (pRampForce->lStart < pRampForce->lEnd) {	// What direction are we
		m_IsUp = TRUE;
		periodic.dwMagnitude = DWORD(pRampForce->lEnd - pRampForce->lStart)/2;
	} else {
		m_IsUp = FALSE;
		periodic.dwMagnitude = DWORD(pRampForce->lStart - pRampForce->lEnd)/2;
	}

	// Replace the periodic structure (ignorning constness), call sawtooth create, then put the old back
	DIEFFECT* pDIEffect = (DIEFFECT*)(&diEffect);	// Hack to temp remove constness
	pDIEffect->cbTypeSpecificParams = sizeof(DIPERIODIC);
	pDIEffect->lpvTypeSpecificParams = &periodic;	// Replace Ramp Parms with periodic
	HRESULT retVal = SawtoothEffect200::Create(diEffect);
	pDIEffect->cbTypeSpecificParams = sizeof(DIRAMPFORCE);
	pDIEffect->lpvTypeSpecificParams = pRampForce;	// Return parms back

	// We are done
	return retVal;
}

override HRESULT RampEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	if (modFlags & DIEP_DURATION) {
		modFlags |= DIEP_TYPESPECIFICPARAMS;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {
		RampEffect200* pEffect = (RampEffect200*)(&newEffect);
		if (m_IsUp != pEffect->m_IsUp) {
			modFlags |= DIEP_DIRECTION;
		}
	}

	return SawtoothEffect200::Modify(newEffect, modFlags);
}


/******************* ConstantForceEffect class ******************/
ConstantForceEffect::ConstantForceEffect() : InternalEffect(),
	m_pEnvelope(NULL)
{
}

ConstantForceEffect::~ConstantForceEffect()
{
	if (m_pEnvelope != NULL) {
		delete m_pEnvelope;
		m_pEnvelope = NULL;
	}
}

HRESULT ConstantForceEffect::Create(const DIEFFECT& diEffect)
{
	// Zero out old struct
	::memset(&m_ConstantForceData, 0, sizeof(m_ConstantForceData));

	// Validation Check
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(m_ConstantForceData)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Copy data to local store
	::memcpy(&m_ConstantForceData, diEffect.lpvTypeSpecificParams, sizeof(m_ConstantForceData));

	// Check the data for truncation
	if (m_ConstantForceData.lMagnitude > 10000) {
		m_ConstantForceData.lMagnitude = 10000;
		hr = DI_TRUNCATED;
	} else if (m_ConstantForceData.lMagnitude < -10000) {
		m_ConstantForceData.lMagnitude = -10000;
		hr = DI_TRUNCATED;
	}

	return hr;
}


/******************* ConstantForceEffect200 class ******************/
BYTE ConstantForceEffect200::GetRepeatIndex() const
{
	return INDEX_CE_REPEAT_200;
}

HRESULT ConstantForceEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = ConstantForceEffect::Create(diEffect);

	// How did creation go?
	if (FAILED(hr)) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_PercentAdjustment = m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(ET_CONSTANTFORCE_200))/100;
	m_Gain = m_Gain/100 * m_PercentAdjustment;
	if (m_ConstantForceData.lMagnitude < 0) {
		m_pEnvelope = new Envelope200(diEffect.lpEnvelope, -Magnitude(), m_Duration, hr);
		m_ConstantForceData.lMagnitude = -10000;
	} else {
		m_pEnvelope = new Envelope200(diEffect.lpEnvelope, Magnitude(), m_Duration, hr);
		m_ConstantForceData.lMagnitude = 10000;
	}

	if (m_EffectAngle <= 18000) {
		m_ConstantForceData.lMagnitude *= -1;
	}

	return hr;
}

UINT ConstantForceEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}

	return retCount;
}

HRESULT ConstantForceEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	return hr;
}

HRESULT ConstantForceEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Sanity check
	if (m_pEnvelope == NULL) {
		ASSUME_NOT_REACHED();	// Should never happen
		return SFERR_DRIVER_ERROR;
	}

	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(22)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, ET_CONSTANTFORCE_200, NEW_EFFECT_ID);

	unsigned short calc_byte = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
	packet.m_pData[10]= BYTE(calc_byte & 0x7F);			// Effect Angle
	calc_byte = unsigned short(float(m_Gain)/GAIN_SCALE_200);
	packet.m_pData[11]= BYTE(calc_byte & 0x7F);			// Gain

	// Envelope
	Envelope200* pEnvelope = (Envelope200*)(m_pEnvelope);
	packet.m_pData[12] = BYTE(pEnvelope->m_StartPercent & 0x7F);	// Initial attack level
	packet.m_pData[13] = BYTE(pEnvelope->m_AttackTime& 0x7F);		// AttackTime Low
	packet.m_pData[14] = BYTE(pEnvelope->m_AttackTime>> 7) & 0x7F;	// AttackTime High
	packet.m_pData[15] = BYTE(pEnvelope->m_SustainPercent & 0x7F);	// Sustain level
	packet.m_pData[16] = BYTE(pEnvelope->m_FadeStart & 0x7F);		// SustainTime Low
	packet.m_pData[17] = BYTE(pEnvelope->m_FadeStart >> 7) & 0x7F;	// SustainTime High
	packet.m_pData[18] = BYTE(pEnvelope->m_EndPercent & 0x7F);		// What to decay to
	// --  Duration of decay is figured by the firmware from total duration

/*	short directionHack = 1;
	if (m_EffectAngle <= 18000) {
		directionHack = -1;
	}
*/
	// Convert magnitude to device percentage (0 to +126 --- +63 = 0 percent)
//	calc_byte = unsigned short(float(directionHack * Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
	calc_byte = unsigned short(float(Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
	packet.m_pData[19] = BYTE(calc_byte & 0x7F);		// Offset

	packet.m_pData[20]= ComputeChecksum(packet, 20);	// Checksum

	// End of packet
	packet.m_pData[21]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT ConstantForceEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	HRESULT hr = SUCCESS;
	ConstantForceEffect200* pEffect = (ConstantForceEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_CE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_ENVELOPE) {
		Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
		Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
		if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_STARTPERCENT_200, pNewEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_ATTTACK_TIME_200, pNewEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_SUSTAINPERCENT_200, pNewEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_FADESTART_200, pNewEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CE_ENDPERCENT_200, pNewEnvelope->m_EndPercent);
			nextPacket++;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_CE_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		DWORD calc = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_CE_GAIN_200, calc);
		nextPacket++;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		if (Magnitude() != pEffect->Magnitude()) {
/*			short directionHack = 1;
			if (pEffect->m_EffectAngle <= 18000) {
				directionHack = -1;
			}
			DWORD calc = DWORD(float(directionHack * pEffect->Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
*/			DWORD calc = DWORD(float(pEffect->Magnitude()/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE);
			hr = FillModifyPacket200(nextPacket, INDEX_CE_MAGNITUDE_200, calc);
			nextPacket++;
		}
	}

	// Did adjust have anything bad to say?
	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT ConstantForceEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_ENVELOPE | DIEP_DIRECTION;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return S_FALSE;
	}

	BOOL playingChecked = FALSE;
	HRESULT hr = SUCCESS;

	if ((modFlags & (DIEP_SAMPLEPERIOD | DIEP_AXES)) != 0) {
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	ConstantForceEffect200* pEffect = (ConstantForceEffect200*)(&newEffect);
	unsigned short numPackets = 0;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == TRUE) {
				return DIERR_EFFECTPLAYING;
			} else {
				modFlags |= DIEP_ENVELOPE;	// Duration change forces envelope change
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags |= (DIEP_GAIN | DIEP_TYPESPECIFICPARAMS);	// If angle is greater than 180 magnitude is inverted
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {
		if (Magnitude() == pEffect->Magnitude()) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing typespecific really changed
		} else {
			numPackets++;
		}
		modFlags |= DIEP_ENVELOPE;
	}
	if (modFlags & DIEP_ENVELOPE) {
		int numEnvelopeChanged = 0;

		if (m_pEnvelope == NULL || pEffect->m_pEnvelope == NULL) {
			ASSUME_NOT_REACHED();	// Envelope should always be created!
		} else {
			Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
			Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
			if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
				numEnvelopeChanged++;
			}
		}

		if (numEnvelopeChanged == 0) {
			modFlags &= ~DIEP_ENVELOPE; // Remove envelope flag, unchanged
		} else {
			numPackets += (USHORT)numEnvelopeChanged;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* class CustomForceEffect ***********************/
CustomForceEffect::CustomForceEffect() : InternalEffect()
{
	m_CustomForceData.rglForceData = NULL;
}

CustomForceEffect::~CustomForceEffect()
{
	if (m_CustomForceData.rglForceData != NULL) {
		delete[] (m_CustomForceData.rglForceData);
		m_CustomForceData.rglForceData = NULL;
	}
}

HRESULT CustomForceEffect::Create(const DIEFFECT& diEffect)
{
	// Zero out old struct
	::memset(&m_CustomForceData, 0, sizeof(m_CustomForceData));

	// Validation Check
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(m_CustomForceData)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	DICUSTOMFORCE* pDICustom = (DICUSTOMFORCE*)(diEffect.lpvTypeSpecificParams);
	if (pDICustom->cChannels == 0) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// We are a little different from every one else (instead of 0 beiing devcie default, it is custom sample period)
	BOOL useCustomForceSamplePeriod = (diEffect.dwSamplePeriod == 0);

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Copy data to local store
	m_CustomForceData.cChannels = pDICustom->cChannels;
	m_CustomForceData.dwSamplePeriod = pDICustom->dwSamplePeriod;
	if (m_CustomForceData.dwSamplePeriod > MAX_TIME_200) {
		m_CustomForceData.dwSamplePeriod = MAX_TIME_200;
		hr = DI_TRUNCATED;
	}
	if (useCustomForceSamplePeriod) {
		if (m_CustomForceData.dwSamplePeriod == 0) {	// These both can't be zero
			return SFERR_NO_SUPPORT;
		}
		m_SamplePeriod = m_CustomForceData.dwSamplePeriod;
	}
	m_CustomForceData.cSamples = pDICustom->cSamples;

	long int* pForceData = NULL;
	try { // They could probably ask for anything
		pForceData = new long int[m_CustomForceData.cSamples];
	} catch (...) {
		return SFERR_DRIVER_ERROR;
	}
	if (pForceData == NULL)
	{
		return SFERR_DRIVER_ERROR;
	}
	::memcpy(pForceData, pDICustom->rglForceData, sizeof(long int) * m_CustomForceData.cSamples);
	m_CustomForceData.rglForceData = pForceData;
	pForceData = NULL;

	return hr;
}

/******************* class CustomForceEffect200 ***********************/
CustomForceEffect200::CustomForceEffect200() : CustomForceEffect(),
	m_pEnvelope(NULL)
{
}

CustomForceEffect200::~CustomForceEffect200()
{
	if (m_pEnvelope != NULL) {
		delete m_pEnvelope;
		m_pEnvelope = NULL;
	}
}

BYTE CustomForceEffect200::GetRepeatIndex() const
{
	return INDEX_CF_REPEAT_200;
}

HRESULT CustomForceEffect200::Create(const DIEFFECT& diEffect)
{
	HRESULT hr = CustomForceEffect::Create(diEffect);

	// How did creation go?
	if (FAILED(hr)) {
		return hr;	// Not so good
	}

	ASSUME(m_pEnvelope == NULL);
	m_PercentAdjustment = m_PercentX + (m_PercentY * g_ForceFeedbackDevice.GetYMappingPercent(ET_CUSTOMFORCE_200))/100;
	m_Gain = m_Gain/100 * m_PercentAdjustment;
	m_pEnvelope = new Envelope200(diEffect.lpEnvelope, 10000, m_Duration, hr);	// Sustain Mag is 100 percent

	return hr;
}

UINT CustomForceEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}

	// Envelope parms
	ASSUME_NOT_NULL(m_pEnvelope);
	if (m_pEnvelope != NULL) {	// Already converted to device units
		if (m_pEnvelope->m_StartPercent != 127) {
			retCount++;
		}
		if (m_pEnvelope->m_AttackTime != 0) {
			retCount++;
		}
		if (m_pEnvelope->m_SustainPercent != 127) {
			retCount++;
		}
		if (m_pEnvelope->m_FadeStart != 0) {
			retCount++;
		}
		if (m_pEnvelope->m_EndPercent != 127) {
			retCount++;
		}
	}

	return retCount;
}

HRESULT CustomForceEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}

	// Envelope parms
	ASSUME_NOT_NULL(m_pEnvelope);
	if (m_pEnvelope != NULL) {	// Already converted to device units
		if (m_pEnvelope->m_StartPercent != 127) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_STARTPERCENT_200, m_pEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (m_pEnvelope->m_AttackTime != 0) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ATTTACK_TIME_200, m_pEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (m_pEnvelope->m_SustainPercent != 127) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_SUSTAINPERCENT_200, m_pEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (m_pEnvelope->m_FadeStart != 0) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_FADESTART_200, m_pEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (m_pEnvelope->m_EndPercent != 127) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ENDPERCENT_200, m_pEnvelope->m_EndPercent);
			nextPacket++;
		}
	}

	return hr;
}

HRESULT CustomForceEffect200::FillCreatePacket(DataPacket& packet) const
{
	if (m_CustomForceData.cChannels == 0) {
		ASSUME_NOT_REACHED();	// Already checked this
		return SFERR_INVALID_PARAM;
	}

	// Create waveform packet
	BYTE* pWaveForm = NULL;
	try {	// Who knows how much we are being asked to allocate
		pWaveForm = new BYTE[m_CustomForceData.cSamples / m_CustomForceData.cChannels * 2];	// This is the max possible
	} catch(...) {
		return SFERR_DRIVER_ERROR;
	}
	if (pWaveForm == NULL)
	{
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;

	// Fill wavelet packet
	if (m_CustomForceData.rglForceData[0] > 10000) {
		m_CustomForceData.rglForceData[0] = 10000;
		hr = DI_TRUNCATED;
	} else if (m_CustomForceData.rglForceData[0] < -10000) {
		m_CustomForceData.rglForceData[0] = -10000;
		hr = DI_TRUNCATED;
	}
	unsigned short wave_byte = unsigned short(float(m_CustomForceData.rglForceData[0] + 10000)/WAVELET_SCALE_200);
	pWaveForm[0] = BYTE(wave_byte & 0x3F);
	pWaveForm[1] = BYTE(wave_byte >> 6) & 0x07;
	UINT waveletCount = 2;
	UINT iPrev = 0;
	for (UINT i = (0 + m_CustomForceData.cChannels); i < m_CustomForceData.cSamples; i += m_CustomForceData.cChannels) {
		if (m_CustomForceData.rglForceData[i] > 10000) {
			m_CustomForceData.rglForceData[i] = 10000;
			hr = DI_TRUNCATED;
		} else if (m_CustomForceData.rglForceData[i] < -10000) {
			m_CustomForceData.rglForceData[i] = -10000;
			hr = DI_TRUNCATED;
		}
		LONG distance = m_CustomForceData.rglForceData[i] - m_CustomForceData.rglForceData[iPrev];
		if ((distance >= 0) && (distance <= WAVELET_DISTANCE_200) ||
				(distance < 0) && (-distance <= WAVELET_DISTANCE_200)) {	// Relative (single byte)
			wave_byte = unsigned short((float(distance + WAVELET_DISTANCE_200)/WAVELET_DISTANCE_SCALE_200) + 0.5f);
			ASSUME(wave_byte <= 62);
			pWaveForm[waveletCount++] = (BYTE(wave_byte) & 0x3F) | 0x40;
		} else { // Non relative (double byte)
			wave_byte = unsigned short(float(m_CustomForceData.rglForceData[i] + 10000)/WAVELET_SCALE_200);
			pWaveForm[waveletCount++] = BYTE(wave_byte & 0x3F);
			pWaveForm[waveletCount++] = BYTE(wave_byte >> 6) & 0x07;
		}
		iPrev = i;
	}


	// Packet to set modify data[index] of current effect
	UINT totalBytes = 19 + waveletCount;	// Header (10) + Fixed (7) + Footer(2) + waveBytes
	if (!packet.AllocateBytes(totalBytes)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, ET_CUSTOMFORCE_200, NEW_EFFECT_ID);

//	unsigned short calc_byte = unsigned short(float(m_EffectAngle)/ANGLE_SCALE_200);
//	packet.m_pData[10]= BYTE(calc_byte & 0x7F);			// Effect Angle
	if (m_EffectAngle <= 18000) {	// Custom for device units
		packet.m_pData[10]= BYTE(64);
	} else {
		packet.m_pData[10]= BYTE(0);
	}

	unsigned short calc_byte = unsigned short(float(m_Gain)/GAIN_SCALE_200);
	packet.m_pData[11]= BYTE(calc_byte & 0x7F);			// Gain

	calc_byte = unsigned short(m_CustomForceData.dwSamplePeriod/DURATION_SCALE_200);
	packet.m_pData[12] = BYTE(calc_byte & 0x7F);			// Force Sample Interval Low
	packet.m_pData[13] = BYTE(calc_byte >> 7) & 0x7F;		// Force Sample Interval High

	calc_byte = unsigned short(m_SamplePeriod/DURATION_SCALE_200);
	packet.m_pData[14] = BYTE(calc_byte & 0x7F);			// Force Output Interval Low
	packet.m_pData[15] = BYTE(calc_byte >> 7) & 0x7F;		// Force Output Interval High

	packet.m_pData[16] = 63;			// Constant force offset (0 - DI Doesn't support)

	// Fill in the wavelet info (already converted to device units
	for (UINT nextWaveIndex = 0; nextWaveIndex < waveletCount; nextWaveIndex++) {
		packet.m_pData[17 + nextWaveIndex] = pWaveForm[nextWaveIndex];
	}

	packet.m_pData[totalBytes-2]= ComputeChecksum(packet, totalBytes-2);	// Checksum

	// End of packet
	packet.m_pData[totalBytes-1]= MIDI_EOX;						// End of SysEX packet

	// Clean up
	delete[] pWaveForm;	// can't modify it, no need to save it
	pWaveForm = NULL;

	return hr;
}

HRESULT CustomForceEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();

	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}
	HRESULT hr = SUCCESS;

	CustomForceEffect200* pEffect = (CustomForceEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_ENVELOPE) {
		Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
		Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
		if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_STARTPERCENT_200, pNewEnvelope->m_StartPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ATTTACK_TIME_200, pNewEnvelope->m_AttackTime);
			nextPacket++;
		}
		if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_SUSTAINPERCENT_200, pNewEnvelope->m_SustainPercent);
			nextPacket++;
		}
		if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_FADESTART_200, pNewEnvelope->m_FadeStart);
			nextPacket++;
		}
		if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_ENDPERCENT_200, pNewEnvelope->m_EndPercent);
			nextPacket++;
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		if (pEffect->m_EffectAngle > 18000) {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_DIRECTIONANGLE_200, 0, 0);
		} else {
			hr = FillModifyPacket200(nextPacket, INDEX_CF_DIRECTIONANGLE_200, BYTE(64), 0);
		}
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_BUTTONREPEAT_200, pEffect->m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		DWORD calc = DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200);
		hr = FillModifyPacket200(nextPacket, INDEX_CF_GAIN_200, calc);
		nextPacket++;
	}
	if (modFlags & DIEP_SAMPLEPERIOD) {
		hr = FillModifyPacket200(nextPacket, INDEX_CF_SAMPLE_PERIOD_200, DWORD(pEffect->m_SamplePeriod/DURATION_SCALE_200));
		nextPacket++;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		hr = FillModifyPacket200(nextPacket, INDEX_CF_FORCESAMPLE_200, DWORD(pEffect->m_CustomForceData.dwSamplePeriod)/DURATION_SCALE_200);
		nextPacket++;
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT CustomForceEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_ENVELOPE | DIEP_SAMPLEPERIOD | DIEP_DIRECTION;
	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}

	CustomForceEffect200* pEffect = (CustomForceEffect200*)(&newEffect);
	unsigned short numPackets = 0;
	HRESULT hr = SUCCESS;

	if ((modFlags & (DIEP_AXES)) != 0) {
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == FALSE) {
				modFlags |= DIEP_ENVELOPE;	// Duration change forces envelope change
				numPackets++;
			} else {
				return DIERR_EFFECTPLAYING;
			}
		}
	}
	if (modFlags & DIEP_DIRECTION) {
		modFlags &= ~DIEP_DIRECTION;
		if (m_EffectAngle != pEffect->m_EffectAngle) {
			modFlags |= DIEP_GAIN;
			if (int(m_EffectAngle / 18000) != int(pEffect->m_EffectAngle / 18000)) {
				modFlags |= DIEP_DIRECTION;
				numPackets++;
			}
		}
	}
	if (modFlags & DIEP_ENVELOPE) {
		int numEnvelopeChanged = 0;

		if (m_pEnvelope == NULL || pEffect->m_pEnvelope == NULL) {
			ASSUME_NOT_REACHED();	// Envelope should always be created!
		} else {
			Envelope200* pOldEnvelope = (Envelope200*)(m_pEnvelope);
			Envelope200* pNewEnvelope = (Envelope200*)(pEffect->m_pEnvelope);
			if (pOldEnvelope->m_AttackTime != pNewEnvelope->m_AttackTime) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_FadeStart != pNewEnvelope->m_FadeStart) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_StartPercent != pNewEnvelope->m_StartPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_SustainPercent != pNewEnvelope->m_SustainPercent) {
				numEnvelopeChanged++;
			}
			if (pOldEnvelope->m_EndPercent != pNewEnvelope->m_EndPercent) {
				numEnvelopeChanged++;
			}
		}

		if (numEnvelopeChanged == 0) {
			modFlags &= ~DIEP_ENVELOPE; // Remove envelope flag, unchanged
		} else {
			numPackets += (USHORT)numEnvelopeChanged;
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove gain flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_SAMPLEPERIOD) {
		if (m_SamplePeriod == pEffect->m_SamplePeriod) {
			modFlags &= ~DIEP_SAMPLEPERIOD; // Remove sample period flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {
		if (m_CustomForceData.dwSamplePeriod == pEffect->m_CustomForceData.dwSamplePeriod) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS;	// Nothing typespecific really changed
		} else {
			numPackets ++;
		}
	}

	if (numPackets != 0) {
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}


/******************* class WallEffect ***********************/
HRESULT WallEffect::Create(const DIEFFECT& diEffect)
{
	// Zero out old struct
	::memset(&m_WallData, 0, sizeof(BE_WALL_PARAM));

	// Validation Check
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(BE_WALL_PARAM)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Let the base class do its magic
	HRESULT hr = InternalEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	// Copy data to local store
	::memcpy(&m_WallData, diEffect.lpvTypeSpecificParams, sizeof(BE_WALL_PARAM));
	m_WallData.m_WallAngle %= 36000;	// No telling what we might have been sent

	if (m_WallData.m_WallDistance > 10000) {
		m_WallData.m_WallDistance = 10000;
		hr = DI_TRUNCATED;
	}
	if (m_WallData.m_WallConstant > 10000) {
		m_WallData.m_WallConstant = 10000;
		hr = DI_TRUNCATED;
	} else if (m_WallData.m_WallConstant < -10000) {
		m_WallData.m_WallConstant = -10000;
		hr = DI_TRUNCATED;
	}

	return hr;
}

/******************* class WallEffect200 ***********************/
BYTE WallEffect200::GetRepeatIndex() const
{
	return INDEX_BE_REPEAT_200;
}

HRESULT WallEffect200::Create(const DIEFFECT& diEffect)
{
	::memset(m_Ds, 0, 4);
	::memset(m_Fs, 0, 4);

	HRESULT hr = WallEffect::Create(diEffect);
	if (FAILED(hr)) {
		return hr;
	}

	ComputeDsAndFs();
	return hr;
}

void WallEffect200::ComputeDsAndFs()
{
	// Projection method - not so smart
	double xProjection = m_WallData.m_WallDistance;

	// With angles greater than 180 Wall flips across X axis
	BOOL wallInner = (m_WallData.m_WallType == WALL_INNER);
	if (m_WallData.m_WallAngle > 18000) {
		xProjection = -xProjection;
	} else if (xProjection == 0) {
		wallInner = !wallInner;
	}

	BYTE xProjectionScaled = BYTE((xProjection/double(DIDISTANCE_TO_PERCENT) + 100.0)/POSITIVE_PERCENT_SCALE) & 0x7F;
	if (((xProjection <= 0) && (wallInner)) || ((xProjection > 0) && (!wallInner))) {
		m_Fs[0] = BYTE(float(-m_WallData.m_WallConstant/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		m_Ds[0] = xProjectionScaled;
		m_Ds[2] = 127;	// Positive Max
	} else {
		m_Fs[0] = BYTE(float(m_WallData.m_WallConstant/DIDISTANCE_TO_PERCENT + 100)/POSITIVE_PERCENT_SCALE) & 0x7F;
		m_Ds[0] = 0;	// Negative Max
		m_Ds[2] = xProjectionScaled;
	}

	// Simplistic mapping: if there is no mapping value is nothing for Y walls
	if (g_ForceFeedbackDevice.GetYMappingPercent(ET_WALL_200) == 0) {
		if (m_WallData.m_WallAngle == 0000 || m_WallData.m_WallAngle == 18000) { // Y axis walls
			m_Fs[0] = 63;	// 0
		}
	}

	m_Ds[1] = m_Ds[0];
	m_Ds[3] = m_Ds[2];
	m_Fs[1] = m_Fs[0];
	m_Fs[2] = m_Fs[0];
	m_Fs[3] = m_Fs[0];
}

UINT WallEffect200::GetModifyOnlyNeeded() const
{
	UINT retCount = 0;

	if (m_TriggerPlayButton != 0) {	// Trigger Button
		retCount++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		retCount++;
	}
	if (m_Gain != 10000) { // Gain
		retCount++;
	}

	return retCount;
}

HRESULT WallEffect200::FillModifyOnlyParms() const
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();	// This is only called from DataPackager::Create()
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SUCCESS;
	BYTE nextPacket = 1;
	if (m_TriggerPlayButton != 0) {	// Trigger Button
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[m_TriggerPlayButton]);
		nextPacket++;
	}
	if (m_TriggerRepeat != 0) {	// Trigger repeat
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, m_TriggerRepeat/DURATION_SCALE_200);
		nextPacket++;
	}
	if (m_Gain != 10000) { // Gain
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}

	return hr;
}

HRESULT WallEffect200::FillCreatePacket(DataPacket& packet) const
{
	// Packet to set modify data[index] of current effect
	if (!packet.AllocateBytes(21)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill in the Generic Effect Information
	FillHeader200(packet, ET_WALL_200, NEW_EFFECT_ID);

	// All of the below items fit in one MidiByte (0..126/127) after conversion
	packet.m_pData[10]= 0;		// Effect Angle is along positive x.

	// Computed in create
	packet.m_pData[11]= m_Ds[0];
	packet.m_pData[12]= m_Fs[0];
	packet.m_pData[13]= m_Ds[1];
	packet.m_pData[14]= m_Fs[1];
	packet.m_pData[15]= m_Ds[2];
	packet.m_pData[16]= m_Fs[2];
	packet.m_pData[17]= m_Ds[3];
	packet.m_pData[18]= m_Fs[3];

	// End this puppy
	packet.m_pData[19]= ComputeChecksum(packet, 19);	// Checksum
	packet.m_pData[20]= MIDI_EOX;						// End of SysEX packet

	return SUCCESS;
}

HRESULT WallEffect200::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	g_pDataPackager->ClearPackets();
	HRESULT adjustResult = AdjustModifyParams(newEffect, modFlags);
	if (FAILED(adjustResult)) {
		return adjustResult;
	}

	HRESULT hr = SUCCESS;
	WallEffect200* pEffect = (WallEffect200*)(&newEffect);
	BYTE nextPacket = 0;
	if (modFlags & DIEP_DURATION) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_DURATION_200, pEffect->m_Duration/DURATION_SCALE_200);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONMAP_200, g_TriggerMap200[pEffect->m_TriggerPlayButton]);
		nextPacket++;
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_BUTTONREPEAT_200, DWORD(float(pEffect->m_TriggerRepeat)/DURATION_SCALE_200));
		nextPacket++;
	}
	if (modFlags & DIEP_GAIN) {
		hr = FillModifyPacket200(nextPacket, INDEX_BE_GAIN_200, DWORD(float(pEffect->m_Gain)/GAIN_SCALE_200));
		nextPacket++;
	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) {	// Send changed items
		for (int i = 0; i < 4; i++) {
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				hr = FillModifyPacket200(nextPacket, INDEX_D1F1_200 + i, pEffect->m_Ds[i], pEffect->m_Fs[i]);
				nextPacket++;
			}
		}
	}

	if (hr == SUCCESS) {
		return adjustResult;
	}
	return hr;
}

HRESULT WallEffect200::AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags)
{
	// Check to see if values being modified are acceptable
	DWORD possMod = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS;
/*	if ((g_TotalModifiable & modFlags & possMod) == 0) {	// Nothing to modify?
		modFlags = 0;
		return SFERR_NO_SUPPORT;
	}
*/

	WallEffect200* pEffect = (WallEffect200*)(&newEffect);
	unsigned short numPackets = 0;

	HRESULT hr = SUCCESS;
	if ((modFlags & (~possMod & DIEP_ALLPARAMS)) != 0) {
		modFlags &= possMod;
		hr = S_FALSE;		// Cannot modify all they asked for
	}

	BOOL playingChecked = FALSE;
	if (modFlags & DIEP_DURATION) {
		if (m_Duration == pEffect->m_Duration) {
			modFlags &= ~DIEP_DURATION; // Remove duration flag, unchanged
		} else {
			if (IsReallyPlaying(playingChecked) == FALSE) {
				numPackets++;
			} else {
				return DIERR_EFFECTPLAYING;
			}
		}
	}
	if (modFlags & DIEP_TRIGGERBUTTON) {
		if (m_TriggerPlayButton == pEffect->m_TriggerPlayButton) {
			modFlags &= ~DIEP_TRIGGERBUTTON; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_TRIGGERREPEATINTERVAL) {
		if (m_TriggerRepeat == pEffect->m_TriggerRepeat) {
			modFlags &= ~DIEP_TRIGGERREPEATINTERVAL; // Remove trigger repeat flag, unchanged
		} else {
			numPackets++;
		}
	}
	if (modFlags & DIEP_GAIN) {	// Did gain really change
		if (m_Gain == pEffect->m_Gain) {
			modFlags &= ~DIEP_GAIN; // Remove trigger flag, unchanged
		} else {
			numPackets++;
		}
	}
//	if (modFlags & DIEP_DIRECTION) {
//		modFlags |= DIEP_TYPESPECIFICPARAMS;
//	}
	if (modFlags & DIEP_TYPESPECIFICPARAMS) { // Find which ones (if any)
		int numTypeSpecificChanged = 0;
		for (int i = 0; i < 4; i++) {
			// Ds and Fs are changed togeather
			if ((m_Ds[i] != pEffect->m_Ds[i]) || (m_Fs[i] != pEffect->m_Fs[i])) {
				numTypeSpecificChanged++;
			}
		}
		if (numTypeSpecificChanged == 0) {
			modFlags &= ~DIEP_TYPESPECIFICPARAMS; // No type specific changed
		} else {
			numPackets += (USHORT)numTypeSpecificChanged;
		}
	}

	if (numPackets != 0) {	// That was easy nothing changed
		g_pDataPackager->AllocateDataPackets(numPackets);
	}

	return hr;
}

/******************* class SystemEffect1XX ***********************/
SystemEffect1XX::SystemEffect1XX() : SystemEffect(),
	m_SystemStickData()
{
}

HRESULT SystemEffect1XX::Create(const DIEFFECT& diEffect)
{
	// Validation Check
	if (diEffect.cbTypeSpecificParams != sizeof(SystemStickData1XX)) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.lpvTypeSpecificParams == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Get the data from the DIEFFECT
	::memcpy(&m_SystemStickData, diEffect.lpvTypeSpecificParams, sizeof(SystemStickData1XX));

	return SUCCESS;
}

HRESULT SystemEffect1XX::FillCreatePacket(DataPacket& packet) const
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

HRESULT SystemEffect1XX::Modify(InternalEffect& newEffect, DWORD modFlags)
{
	// Sanity Check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}

	SystemEffect1XX* pNewSystemEffect = (SystemEffect1XX*)(&newEffect);

	// Find number of packets needed
	unsigned short numPackets = 28;	// Always need to send system commands when asked (have no idea what is on the stick

	// Allocate a packets for sending modify command
	if (!g_pDataPackager->AllocateDataPackets(numPackets)) {
		return SFERR_DRIVER_ERROR;
	}

	// Fill the packets
	BYTE nextPacket = 0;
	FillModifyPacket1XX(nextPacket, INDEX0, pNewSystemEffect->m_SystemStickData.dwXYConst/2);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX1, pNewSystemEffect->m_SystemStickData.dwRotConst/2);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX2, pNewSystemEffect->m_SystemStickData.dwSldrConst);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX3, pNewSystemEffect->m_SystemStickData.dwAJRot);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX4, pNewSystemEffect->m_SystemStickData.dwAJRot);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX5, pNewSystemEffect->m_SystemStickData.dwAJSldr);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX6, pNewSystemEffect->m_SystemStickData.dwSprScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX7, pNewSystemEffect->m_SystemStickData.dwBmpScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX8, pNewSystemEffect->m_SystemStickData.dwDmpScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX9, pNewSystemEffect->m_SystemStickData.dwInertScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX10, pNewSystemEffect->m_SystemStickData.dwVelOffScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX11, pNewSystemEffect->m_SystemStickData.dwAccOffScl);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX12, pNewSystemEffect->m_SystemStickData.dwYMotBoost/2);
	nextPacket += 2;
	FillModifyPacket1XX(nextPacket, INDEX13, pNewSystemEffect->m_SystemStickData.dwXMotSat);
	
	return SUCCESS;
}

/******************* class SystemStickData1XX ***********************/
SystemStickData1XX::SystemStickData1XX()
{
	dwXYConst		= DEF_XY_CONST;
	dwRotConst		= DEF_ROT_CONST;
	dwSldrConst		= DEF_SLDR_CONST;
	dwAJPos			= DEF_AJ_POS;
	dwAJRot			= DEF_AJ_ROT;
	dwAJSldr		= DEF_AJ_SLDR;
	dwSprScl		= DEF_SPR_SCL;
	dwBmpScl		= DEF_BMP_SCL;
	dwDmpScl		= DEF_DMP_SCL;
	dwInertScl		= DEF_INERT_SCL;
	dwVelOffScl		= DEF_VEL_OFFSET_SCL;
	dwAccOffScl		= DEF_ACC_OFFSET_SCL;
	dwYMotBoost		= DEF_Y_MOT_BOOST;
	dwXMotSat		= DEF_X_MOT_SATURATION;
	dwReserved		= 0;
	dwMasterGain	= 0;
}

#define REGSTR_VAL_JOYSTICK_PARAMS	"JoystickParams"
void SystemStickData1XX::SetFromRegistry(DWORD dwDeviceID)
{
	// try to open the registry key
	HKEY hkey = joyOpenOEMForceFeedbackKey(dwDeviceID);
	if (hkey != NULL) {
		RegistryKey ffKey(hkey);
		ffKey.ShouldClose(TRUE);
		DWORD numBytes = sizeof(SystemStickData1XX);
		if (ffKey.QueryValue(REGSTR_VAL_JOYSTICK_PARAMS, (BYTE*)this, numBytes) == SUCCESS) {
			return;
		}
	}

	// We were either not able to open the key or get the value (Use defaults)
	dwXYConst		= DEF_XY_CONST;
	dwRotConst		= DEF_ROT_CONST;
	dwSldrConst		= DEF_SLDR_CONST;
	dwAJPos			= DEF_AJ_POS;
	dwAJRot			= DEF_AJ_ROT;
	dwAJSldr		= DEF_AJ_SLDR;
	dwSprScl		= DEF_SPR_SCL;
	dwBmpScl		= DEF_BMP_SCL;
	dwDmpScl		= DEF_DMP_SCL;
	dwInertScl		= DEF_INERT_SCL;
	dwVelOffScl		= DEF_VEL_OFFSET_SCL;
	dwAccOffScl		= DEF_ACC_OFFSET_SCL;
	dwYMotBoost		= DEF_Y_MOT_BOOST;
	dwXMotSat		= DEF_X_MOT_SATURATION;
	dwReserved		= 0;
	dwMasterGain	= 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffdevice.cpp ===
//@doc
/******************************************************
**
** @module FFDEVICE.CPP | Implementation file for FFDevice class
**
** Description:
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
**			21-Mar-99	waltw	Added dwDeviceID to SetFirmwareVersion,
**								InitJoystickParams, StateChange, InitRTCSpring,
**								InitRTCSpring200
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#include "FFDevice.h"
#include "Midi_obj.hpp"
#include "DTrans.h"
#include "DPack.h"
#include "joyregst.hpp"
#include "CritSec.h"
#include <crt/io.h>			// For file routines
#include <FCNTL.h>		// File _open flags
#include <math.h>		// for sin and cos

extern CJoltMidi* g_pJoltMidi;

//
// --- VFX Force File defines
//
#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')
#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')
#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')
#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')
#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')

ForceFeedbackDevice g_ForceFeedbackDevice;

#include <errno.h>		// For open file errors
HRESULT LoadBufferFromFile(const char* fileName, PBYTE& pBufferBytes, ULONG& numFileBytes)
{
	if (pBufferBytes != NULL) {
		ASSUME_NOT_REACHED();
		numFileBytes = 0;
		return VFX_ERR_FILE_OUT_OF_MEMORY;
	}

	int fHandle = ::_open(fileName, _O_RDONLY | _O_BINARY);
	if (fHandle == -1) {
		numFileBytes = 0;
		switch (errno) {
			case EACCES : return VFX_ERR_FILE_ACCESS_DENIED;
			case EMFILE : return VFX_ERR_FILE_TOO_MANY_OPEN_FILES;
			case ENOENT : return VFX_ERR_FILE_NOT_FOUND;
		}
		return VFX_ERR_FILE_CANNOT_OPEN;		// Who knows what went wrong
	}
	
	HRESULT hr = S_OK;
	numFileBytes = ::_lseek(fHandle, 0, SEEK_END);
	if (numFileBytes == -1) {		// Seek failed
		hr = VFX_ERR_FILE_CANNOT_SEEK;
	} else if (numFileBytes == 0) {	// Empty file
		hr = VFX_ERR_FILE_BAD_FORMAT;
	} else {
		pBufferBytes = new BYTE[numFileBytes];
		if (pBufferBytes == NULL) {	// Could not allocate memory
			hr = VFX_ERR_FILE_OUT_OF_MEMORY;
		} else {
			if (::_lseek(fHandle, 0, SEEK_SET) == -1) {	// Failed seek to begining
				hr = VFX_ERR_FILE_CANNOT_SEEK;
			} else if (::_read(fHandle, pBufferBytes, numFileBytes) == -1) {	// Failed to read
				hr = VFX_ERR_FILE_CANNOT_READ;
			}
			if (hr != S_OK) {	// Things didn't go well
				delete[] pBufferBytes;
				pBufferBytes = NULL;
			}
		}
	}

	::_close(fHandle);
	return hr;
}

/******************************************************
**
** ForceFeedbackDevice::ForceFeedbackDevice()
**
** @mfunc Constructor.
**
******************************************************/
ForceFeedbackDevice::ForceFeedbackDevice() :
	m_FirmwareAckNackValues(0),
	m_FirmwareVersionMajor(0),
	m_FirmwareVersionMinor(0),
	m_DriverVersionMajor(0),
	m_DriverVersionMinor(0),
	m_SpringOffset(0),
	m_Mapping(0),
	m_DIStateFlags(0),
	m_RawForceX(0),
	m_RawForceY(0)
{
	m_OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&m_OSVersion);

	for (int index = 0; index < 14; index++) {
		m_PercentMappings[index] = 100;	// Default is 100 percent till I'm told otherwise
	}
	for (index = 0; index < MAX_EFFECT_IDS; index++) {
		m_EffectList[index] = NULL;
	}
	m_SystemEffect = NULL;

	::memset(&m_Version200State, 0, sizeof(m_Version200State));
	::memset(&m_LastStatusPacket, 0, sizeof(m_LastStatusPacket));	
}

/******************************************************
**
** ForceFeedbackDevice::~ForceFeedbackDevice()
**
** @mfunc Destructor.
**
******************************************************/
ForceFeedbackDevice::~ForceFeedbackDevice()
{
	BOOL lingerer = FALSE;

	// Destroy the RTCSpring and SystemEffect if still hanging aroung
	if (m_EffectList[0] != NULL) {
		delete m_EffectList[0];
		m_EffectList[0] = NULL;
	}
	if (m_SystemEffect != NULL) {
		delete m_SystemEffect;
		m_SystemEffect = NULL;
	}

	// Destroy any lingering effects (of which there should be none)
	for (int index = 0; index < MAX_EFFECT_IDS; index++) {
		if (m_EffectList[index] != NULL) {
			lingerer = TRUE;
			delete m_EffectList[index];
			m_EffectList[index] = NULL;
		}
	}

	ASSUME(lingerer == FALSE);	// Assuming programmer cleaned up thier own mess
}


/******************************************************
**
** ForceFeedbackDevice::DetectHardware()
**
** @mfunc DetectHardware.
**
******************************************************/
BOOL ForceFeedbackDevice::DetectHardware()
{
	if (NULL == g_pJoltMidi)
		return (FALSE);
	else
		return g_pJoltMidi->QueryForJolt();
}

/******************************************************
**
** ForceFeedbackDevice::SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor)
**
** @mfunc SetFirmwareVersion.
**
******************************************************/
void ForceFeedbackDevice::SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor)
{
	m_FirmwareVersionMajor = major;
	m_FirmwareVersionMinor = minor;

	if (g_pDataPackager != NULL) {
		delete g_pDataPackager;
		g_pDataPackager = NULL;
	}

	if (m_FirmwareVersionMajor == 1) {
		ASSUME_NOT_REACHED();	// Currently this code only supports wheel - this is a Jolt version
//		g_pDataPackager = new DataPackager100();
	} else {	// Till version number is locked down
		g_pDataPackager = new DataPackager200();
	}

	ASSUME_NOT_NULL(g_pDataPackager);

	m_FirmwareAckNackValues = GetAckNackMethodFromRegistry(dwDeviceID);
	m_SpringOffset = GetSpringOffsetFromRegistry(dwDeviceID);
}

/******************************************************
**
** ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
**
** @mfunc SetDriverVersion.
**
******************************************************/
void ForceFeedbackDevice::SetDriverVersion(DWORD major, DWORD minor)
{
	if ((major == 0xFFFFFFFF) && (minor == 0xFFFFFFFF)) {	// Check for version 1.0 driver version error
		m_DriverVersionMajor = 1;
		m_DriverVersionMinor = 0;
	} else {
		m_DriverVersionMajor = major;
		m_DriverVersionMinor = minor;
	}
}

/******************************************************
**
** ForceFeedbackDevice::GetYMappingPercent(UINT index)
**
** @mfunc GetYMappingPercent.
**
******************************************************/
short ForceFeedbackDevice::GetYMappingPercent(UINT index) const
{
	if (m_Mapping & Y_AXIS) {
		if (index < 14) {
			return m_PercentMappings[index];
		}
	}
	return 0;
}

/******************************************************
**
** ForceFeedbackDevice::GetEffect(DWORD effectID) const
**
** @mfunc GetEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::GetEffect(DWORD effectID) const
{
	if (effectID == SYSTEM_EFFECT_ID) { // SystemEffect not stored in array
		return m_SystemEffect;
	}

	if (effectID == SYSTEM_RTCSPRING_ALIAS_ID) { // Remapping of RTC spring
		return m_EffectList[0];
	}

	if (effectID == RAW_FORCE_ALIAS) {
		return NULL;
	}

	// Parameter check
	if (effectID >= MAX_EFFECT_IDS) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	return m_EffectList[effectID];
}

/******************************************************
**
** ForceFeedbackDevice::RemoveEffect(DWORD effectID) const
**
** @mfunc GetEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::RemoveEffect(DWORD effectID)
{
	// There really is no raw force effect
	if (effectID == RAW_FORCE_ALIAS) {
		return NULL;
	}

	// Cannot remove system effects
	if ((effectID == SYSTEM_EFFECT_ID) || (effectID == 0) || (effectID == SYSTEM_RTCSPRING_ALIAS_ID)) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	// Parameter check
	if (effectID >= MAX_EFFECT_IDS) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	InternalEffect* pEffect = m_EffectList[effectID];
	m_EffectList[effectID] = NULL;
	return pEffect;
}

/******************************************************
**
** ForceFeedbackDevice::InitRTCSpring()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitRTCSpring(DWORD dwDeviceID)
{
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data packager
	}
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data transmitter
	}

	if (GetFirmwareVersionMajor() == 1) {
		return InitRTCSpring1XX(dwDeviceID);
	}
	return InitRTCSpring200(dwDeviceID);
}

/******************************************************
**
** ForceFeedbackDevice::InitRTCSpring1XX()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitRTCSpring1XX(DWORD dwDeviceID)
{
	// Sanity Checks
	if (GetEffect(SYSTEM_RTCSPRING_ID) != NULL) {
		ASSUME_NOT_REACHED();
		return SUCCESS;	// Already initialized
	}

	// DIEFFECT structure to fill
	DICONDITION cond[2];
	DIEFFECT rtc;
	rtc.dwSize = sizeof(DIEFFECT);
	rtc.cbTypeSpecificParams = sizeof(DICONDITION) * 2;
	rtc.lpvTypeSpecificParams = cond;

	// The default RTCSpring (the one on the stick)
	RTCSpring1XX rtcSpring1XX;	// Def Parms filled by constructor

	// Default RTCSpring from the registry
	RTCSPRING_PARAM parms;
	GetSystemParams(dwDeviceID, (SYSTEM_PARAMS*)(&parms));
	cond[0].lPositiveCoefficient = parms.m_XKConstant;
	cond[1].lPositiveCoefficient = parms.m_YKConstant;
	cond[0].lOffset = parms.m_XAxisCenter;
	cond[1].lOffset = parms.m_YAxisCenter;
	cond[0].dwPositiveSaturation = parms.m_XSaturation;
	cond[1].dwPositiveSaturation = parms.m_YSaturation;
	cond[0].lDeadBand = parms.m_XDeadBand;
	cond[1].lDeadBand = parms.m_YDeadBand;

	// Allocate and create the RTCSpring
	InternalEffect* pNewRTCSpring = InternalEffect::CreateRTCSpring();
	if (pNewRTCSpring == NULL) {
		return SFERR_DRIVER_ERROR;
	}
	if (pNewRTCSpring->Create(rtc) != SUCCESS) {
		delete pNewRTCSpring;	// Could not create system RTC Spring
		return SFERR_DRIVER_ERROR;
	}

	// Replace the stick default with the registry default
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, &rtcSpring1XX);				// Temporary pointer needed (but we only store temporarily)
	g_pDataPackager->ModifyEffect(rtcSpring1XX, *pNewRTCSpring, 0);		// Package relative changes
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, pNewRTCSpring);				// Replace the old with the new

	pNewRTCSpring = NULL; // Forgotten, but not gone

	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}

/******************************************************
**
** ForceFeedbackDevice::InitRTCSpring200()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitRTCSpring200(DWORD dwDeviceID)
{
	// Sanity Checks
	if (GetEffect(ID_RTCSPRING_200) != NULL) {
		ASSUME_NOT_REACHED();
		return SUCCESS;	// Already initialized
	}

	// The temporary spring and the allocated one
	InternalEffect* pNewRTCSpring = NULL;

	// DIEFFECT structure to fill
	DICONDITION cond[2];
	DIEFFECT rtc;
	rtc.dwSize = sizeof(DIEFFECT);
	rtc.cbTypeSpecificParams = sizeof(DICONDITION) * 2;
	rtc.lpvTypeSpecificParams = cond;


	// The default RTCSpring (the one on the stick)
	RTCSpring200 rtcSpring200;	// Default values filled in by constructor

	// Default RTCSpring from the registry
	GetRTCSpringData(dwDeviceID, cond);

	// Allocate and create the RTCSpring
	pNewRTCSpring = InternalEffect::CreateRTCSpring();
	if (pNewRTCSpring == NULL) {
		return SFERR_DRIVER_ERROR;
	}
	HRESULT createResult = pNewRTCSpring->Create(rtc);
	if (FAILED(createResult)) {
		delete pNewRTCSpring;	// Could not create system RTC Spring
		return SFERR_DRIVER_ERROR;
	}

	// Replace the stick default with the registry default
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, &rtcSpring200);				// Temporary pointer needed (but we only store temporarily)
	g_pDataPackager->ModifyEffect(rtcSpring200, *pNewRTCSpring, 0);		// Package relative changes
	SetEffect(SYSTEM_RTCSPRING_ALIAS_ID, pNewRTCSpring);				// Replace the old with the new

	pNewRTCSpring = NULL; // Forgotten, but not gone
	ACKNACK ackNack;
	HRESULT transmitResult = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (transmitResult != S_OK) {
		return transmitResult;
	}
	return createResult;
}

/******************************************************
**
** ForceFeedbackDevice::InitJoystickParams()
**
** @mfunc InitRTCSpring.
**
******************************************************/
HRESULT ForceFeedbackDevice::InitJoystickParams(DWORD dwDeviceID)
{
	// Sanity Checks
	if (GetEffect(SYSTEM_EFFECT_ID) != NULL) {
		ASSUME_NOT_REACHED();
		return SUCCESS;	// Already initialized
	}
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data packager
	}
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;	// No global data transmitter
	}

	// Force Mapping
	m_Mapping = ::GetMapping(dwDeviceID);
	::GetMappingPercents(dwDeviceID, m_PercentMappings, 14);


	if (GetFirmwareVersionMajor() == 1) {
		// The default System Effect (the one on the stick)
		SystemEffect1XX systemEffect;

		// Default System Effect from the registry
		SystemStickData1XX sysData;
		sysData.SetFromRegistry(dwDeviceID);

		// Put the registry system values into a DIEFFECT
		DIEFFECT systemDIEffect;
		systemDIEffect.dwSize = sizeof(DIEFFECT);
		systemDIEffect.cbTypeSpecificParams = sizeof(SystemStickData1XX);
		systemDIEffect.lpvTypeSpecificParams = &sysData;

		// Get a system effect (and fill it with our local DIEffect information
		SystemEffect1XX* pSystemEffect = (SystemEffect1XX*)(InternalEffect::CreateSystemEffect());
		if (pSystemEffect == NULL) {
			return SFERR_DRIVER_ERROR;
		}
		if (pSystemEffect->Create(systemDIEffect) != SUCCESS) {
			delete pSystemEffect;	// Couldnot create SystemEffect
			return SFERR_DRIVER_ERROR;
		}

		// Replace the stick default with the registry default
		SetEffect(SYSTEM_EFFECT_ID, &systemEffect);						// Temporary pointer (but we only store temporarily)
		g_pDataPackager->ModifyEffect(systemEffect, *pSystemEffect, 0);	// Package relative changes
		SetEffect(SYSTEM_EFFECT_ID, pSystemEffect);						// Replace the old with the new
		pSystemEffect = NULL; // Forgotten, but not gone
		ACKNACK ackNack;
		return g_pDataTransmitter->Transmit(ackNack);	// Send it off
	}

	return SUCCESS;
}

/******************************************************
**
** ForceFeedbackDevice::StateChange(DWORD newStateFlags)
**
** @mfunc StateChange.
**
******************************************************/
void ForceFeedbackDevice::StateChange(DWORD dwDeviceID, DWORD newStateFlag)
{
	if (newStateFlag == DISFFC_RESET) {		// Stick is reset need to remove local copies of user commands
		// Remove all effect from our list
		for (int index = 2; index < MAX_EFFECT_IDS; index++) {
			if (m_EffectList[index] != NULL) {
				delete m_EffectList[index];
				m_EffectList[index] = NULL;
			}
		}

		// Remove individual axis raw effects
		m_RawForceX = 0;
		m_RawForceY = 0;

		// Look at the Y mapping, perhaps it changed
		m_Mapping = ::GetMapping(dwDeviceID);
		::GetMappingPercents(dwDeviceID, m_PercentMappings, 14);
	} else if (newStateFlag == DISFFC_STOPALL) {
		m_RawForceX = 0;
		m_RawForceY = 0;
	}

	m_DIStateFlags = newStateFlag;
}

/******************************************************
**
** ForceFeedbackDevice::CreateConditionEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateConditionEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateConditionEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pReturnEffect = NULL;
	switch (minorType) {
		case BE_SPRING:
		case BE_SPRING_2D: {
			pReturnEffect = InternalEffect::CreateSpring();
			break;
		}
		case BE_DAMPER:
		case BE_DAMPER_2D: {
			pReturnEffect = InternalEffect::CreateDamper();
			break;
		}
		case BE_INERTIA:
		case BE_INERTIA_2D: {
			pReturnEffect = InternalEffect::CreateInertia();
			break;
		}
		case BE_FRICTION:
		case BE_FRICTION_2D: {
			pReturnEffect = InternalEffect::CreateFriction();
			break;
		}
		case BE_WALL: {
			pReturnEffect = InternalEffect::CreateWall();
			break;
		}
	}

	if (pReturnEffect != NULL) {
		hr = pReturnEffect->Create(diEffect);
		if (FAILED(hr)) {
			delete pReturnEffect;
		}
	}
	return pReturnEffect;
}

/******************************************************
**
** ForceFeedbackDevice::CreateRTCSpringEffect(DWORD subType, const DIEFFECT& diEffect)
**
** @mfunc CreateRTCSpringEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateRTCSpringEffect(DWORD minorType, const DIEFFECT& diEffect)
{
	InternalEffect* pEffect = InternalEffect::CreateRTCSpring();
	if (pEffect != NULL) {
		if (pEffect->Create(diEffect) == SUCCESS) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreateCustomForceEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateCustomForceEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateCustomForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pEffect = InternalEffect::CreateCustomForce();
	if (pEffect != NULL) {
		hr = pEffect->Create(diEffect);
		if (SUCCEEDED(hr)) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreatePeriodicEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreatePeriodicEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreatePeriodicEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pReturnEffect = NULL;
	switch (minorType) {
		case SE_SINE: {
			pReturnEffect = InternalEffect::CreateSine();
			break;
		}
		case SE_SQUAREHIGH: {
			pReturnEffect = InternalEffect::CreateSquare();
			break;
		}
		case SE_TRIANGLEUP: {
			pReturnEffect = InternalEffect::CreateTriangle();
			break;
		}
		case SE_SAWTOOTHUP: {
			pReturnEffect = InternalEffect::CreateSawtoothUp();
			break;
		}
		case SE_SAWTOOTHDOWN: {
			pReturnEffect = InternalEffect::CreateSawtoothDown();
			break;
		}
		case SE_CONSTANT_FORCE: {
			return CreateConstantForceEffect(minorType, diEffect, hr);
		}
		case SE_RAMPUP: {
			return CreateRampForceEffect(minorType, diEffect, hr);
		}
	}
	if (pReturnEffect != NULL) {
		hr = pReturnEffect->Create(diEffect);
		if (FAILED(hr) == FALSE) {
			return pReturnEffect;
		}
		delete pReturnEffect;
	}

	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreateConstantForceEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateConstantForceEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateConstantForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pEffect = InternalEffect::CreateConstantForce();
	if (pEffect != NULL) {
		hr = pEffect->Create(diEffect);
		if (FAILED(hr) == FALSE) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::CreateRampForceEffect(DWORD subType, const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateRampForceEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateRampForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr)
{
	InternalEffect* pEffect = InternalEffect::CreateRamp();
	if (pEffect != NULL) {
		hr = pEffect->Create(diEffect);
		if (SUCCEEDED(hr)) {
			return pEffect;
		}
		delete pEffect;
	}
	return NULL;
}

/******************************************************
**
** ForceFeedbackDevice::SendRawForce(const DIEFFECT& diEffect)
**
** @mfunc SendRawForce.
**
******************************************************/
HRESULT ForceFeedbackDevice::SendRawForce(const DIEFFECT& diEffect, BOOL paramCheck)
{
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return SFERR_INVALID_PARAM;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(DICONSTANTFORCE)) {
		return SFERR_INVALID_PARAM;
	}

	// We don't support more than 2 axes, and 0 is probably an error
	if ((diEffect.cAxes > 2) || (diEffect.cAxes == 0)) {
		return SFERR_NO_SUPPORT;
	}

	// Set up the axis mask
	DWORD axisMask = 0;
	for (unsigned int axisIndex = 0; axisIndex < diEffect.cAxes; axisIndex++) {
		DWORD axisNumber = DIDFT_GETINSTANCE(diEffect.rgdwAxes[axisIndex]);
		axisMask |= 1 << axisNumber;
	}
	BOOL axesReversed = (DIDFT_GETINSTANCE(diEffect.rgdwAxes[0]) == 1);

	double angle = 0.0;
	// Check coordinate sytems and change to rectangular
	if (diEffect.dwFlags & DIEFF_SPHERICAL) {	// We don't support sperical (3 axis force)
		return SFERR_NO_SUPPORT;				// .. since got by axis check, programmer goofed up
	}
	if (diEffect.dwFlags & DIEFF_POLAR) {
		if (diEffect.cAxes != 2) { // Polar coordinate must have two axes of data (because DX says so)
			return SFERR_INVALID_PARAM;
		}
		DWORD effectAngle = diEffect.rglDirection[0];	// in [0] even if reversed
		if (axesReversed) {		// Indicates (-1, 0) as origin instead of (0, -1)
			effectAngle += 27000;
		}
		effectAngle %= 36000;

		angle = double(effectAngle)/18000 * 3.14159;	// Convert to radians
		m_RawForceX = 0;
		m_RawForceY = 0;
	} else if (diEffect.dwFlags & DIEFF_CARTESIAN) { // Convert to polar (so we can convert to cartesian)
		if (diEffect.cAxes == 1) {	// Fairly easy conversion
			if (X_AXIS & axisMask) {
				angle = 3.14159/2;		// PI/2
			} else {
				angle = 0.0;
			}
		} else { // Multiple axis cartiesian
			m_RawForceX = 0;
			m_RawForceY = 0;

			int xDirection = DIDFT_GETINSTANCE(diEffect.rglDirection[0]);
			int yDirection = DIDFT_GETINSTANCE(diEffect.rglDirection[1]);
			if (axesReversed == TRUE) {
				yDirection = xDirection;
				xDirection = DIDFT_GETINSTANCE(diEffect.rglDirection[1]);
			}
			angle = atan2(double(yDirection), double(xDirection));
		}
	} else {	// What, is there some other format?
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;	// Untill someone says otherwise there was an error
	}

	// Sin^2(a) + Cos^2(a) = 1
	double xProj = ::sin(angle);	// DI has 0 degs at (1, 0) not (0, 1)
	double yProj = ::cos(angle);
	xProj *= xProj;
	yProj *= yProj;
	DWORD percentX = DWORD(xProj * 100.0 + 0.05);
	DWORD percentY = DWORD(yProj * 100.0 + 0.05);

	BOOL truncated = FALSE;
	if (percentX != 0) {
		m_RawForceX = LONG(percentX * (((DICONSTANTFORCE*)(diEffect.lpvTypeSpecificParams))->lMagnitude/100));
		if (m_RawForceX > 10000) {
			m_RawForceX  = 10000;
			truncated = TRUE;
		} else if (m_RawForceX < -10000) {
			m_RawForceX  = -10000;
			truncated = TRUE;
		}
	}
	if (percentY != 0) {
		m_RawForceY = LONG(percentY * (((DICONSTANTFORCE*)(diEffect.lpvTypeSpecificParams))->lMagnitude/100));
		if (m_RawForceY > 10000) {
			m_RawForceY = 10000;
			truncated = TRUE;
		} else if (m_RawForceY < -10000) {
			m_RawForceY = -10000;
			truncated = TRUE;
		}
	}
	long int mag = m_RawForceX + m_RawForceY * GetYMappingPercent(ET_RAWFORCE_200)/100;
	if (mag > 10000) {	// Check for overrun but don't return indication of truncation
		mag = 10000;
	} else if (mag < -10000) {
		mag = -10000;
	}
	if (angle > 3.14159) {	// PI
		mag *= -1;
	}
	HRESULT hr = g_pDataPackager->ForceOut(mag, X_AXIS);
	if ((hr != SUCCESS) || (paramCheck == TRUE)) {
		return hr;
	}

	ACKNACK ackNack;
	g_pDataTransmitter->Transmit(ackNack);

	if (truncated == TRUE) {
		return DI_TRUNCATED;
	}
	return SUCCESS;
}

/******************************************************
**
** ForceFeedbackDevice::CreateVFXEffect(const DIEFFECT& diEffect, HRESULT& hr)
**
** @mfunc CreateVFXEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateVFXEffect(const DIEFFECT& diEffect, HRESULT& hr)
{
/*	ULONG	m_Bytes;				// Size of this structure
	ULONG	m_PointerType;			// VFX_FILENAME or VFX_BUFFER
	ULONG	m_BufferSize;			// number of bytes in buffer (if VFX_BUFFER)
	PVOID	m_pFileNameOrBuffer;	// file name to open
*/
	if (diEffect.lpvTypeSpecificParams == NULL) {
		return NULL;
	}
	if (diEffect.cbTypeSpecificParams != sizeof(VFX_PARAM)) {
		return NULL;
	}

	VFX_PARAM* pVFXParms = (VFX_PARAM*)diEffect.lpvTypeSpecificParams;
	BYTE* pEffectBuffer = NULL;
	ULONG numBufferBytes = 0;
	if (pVFXParms->m_PointerType == VFX_FILENAME) {		// Create memory buffer from file
		hr = LoadBufferFromFile((const char*)(pVFXParms->m_pFileNameOrBuffer), pEffectBuffer, numBufferBytes);
	} else {
		pEffectBuffer = (BYTE*)(pVFXParms->m_pFileNameOrBuffer);
		numBufferBytes = pVFXParms->m_BufferSize;
	}

	if ((pEffectBuffer == NULL) || (numBufferBytes == 0)) {
		return NULL;
	}

	return CreateVFXEffectFromBuffer(diEffect, pEffectBuffer, numBufferBytes, hr);
}

/******************************************************
**
** ForceFeedbackDevice::CreateVFXEffectFromBuffer(const DIEFFECT& diEffect, BYTE* pEffectBuffer, ULONG numBufferBytes, HRESULT& hr)
**
** @mfunc CreateVFXEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateVFXEffectFromBuffer(const DIEFFECT& diEffect, BYTE* pEffectBuffer, ULONG numBufferBytes, HRESULT& hr)
{
	if ((pEffectBuffer == NULL) || (numBufferBytes == 0)) {
		ASSUME_NOT_REACHED();
		return NULL;
	}

	MMIOINFO mmioInfo;
	::memset(&mmioInfo, 0, sizeof(MMIOINFO));
	mmioInfo.fccIOProc = FOURCC_MEM;
	mmioInfo.cchBuffer = numBufferBytes;
	mmioInfo.pchBuffer = (char*)pEffectBuffer;

	HMMIO hmmio = ::mmioOpen(NULL, &mmioInfo, MMIO_READ);
	if (hmmio == NULL) {
		return NULL;
	}

	BYTE* pEffectParms = NULL;
	DWORD paramSize;
	EFFECT effect;		// SW EFFECT structure
	ENVELOPE envelope;	// SW ENVELOPE structure

	try {	// Try parsing the RIFF file
		MMRESULT mmResult;

		// Descend into FORC list
		MMCKINFO forceEffectRiffInfo;
		forceEffectRiffInfo.fccType = FCC_FORCE_EFFECT_RIFF;
		if ((mmResult = ::mmioDescend(hmmio, &forceEffectRiffInfo, NULL, MMIO_FINDRIFF)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}

		// Descend into TRAK list
		MMCKINFO trakListInfo;
		trakListInfo.fccType = FCC_TRACK_LIST;
		if ((mmResult = ::mmioDescend(hmmio, &trakListInfo, &forceEffectRiffInfo, MMIO_FINDLIST)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}

		// Descend into first EFCT list
		MMCKINFO effectListInfo;
		effectListInfo.fccType = FCC_EFFECT_LIST;
		if ((mmResult = ::mmioDescend(hmmio, &effectListInfo, &trakListInfo, MMIO_FINDLIST)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}

		// Descend into the ID chunk (maybe someone has a clue what is in here)
		MMCKINFO idInfo;
		idInfo.ckid = FCC_ID_CHUNK;
		if ((mmResult = ::mmioDescend(hmmio, &idInfo, &effectListInfo, MMIO_FINDCHUNK)) != MMSYSERR_NOERROR) {
			throw mmResult;
		}
		// Find the number of IDs in here (should indicate the number of effect)
		DWORD numEffects = idInfo.cksize/sizeof(DWORD);
		if (numEffects != 1) {
			throw SFERR_NO_SUPPORT;
		}
		// Read the ID chunk
		DWORD id;
		DWORD bytesRead = ::mmioRead(hmmio, (char*)&id, sizeof(DWORD));
		if (bytesRead != sizeof(DWORD)) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// Back out of the ID chunk
		if ((mmResult = ::mmioAscend(hmmio, &idInfo, 0)) != MMSYSERR_NOERROR) {
			throw HRESULT_FROM_WIN32(mmResult);
		}

		// Descend into the DATA chunk
		MMCKINFO dataInfo;
		dataInfo.ckid = FCC_DATA_CHUNK;
		if ((mmResult = ::mmioDescend(hmmio, &dataInfo, &effectListInfo, MMIO_FINDCHUNK)) != MMSYSERR_NOERROR) {
			throw HRESULT_FROM_WIN32(mmResult);
		}
		// Read the effect structure from this chunk
		bytesRead = ::mmioRead(hmmio, (char*)&effect, sizeof(EFFECT));
		if (bytesRead != sizeof(EFFECT)) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// Read the envelope structure from this chunk
		bytesRead = ::mmioRead(hmmio, (char*)&envelope, sizeof(ENVELOPE));
		if (bytesRead != sizeof(ENVELOPE)) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// Read the parameters in:
		//	-- Figure out the paramter size
		DWORD currentFilePos = ::mmioSeek(hmmio, 0, SEEK_CUR);
		if (currentFilePos == -1) {
			throw VFX_ERR_FILE_CANNOT_SEEK;
		}
		paramSize = dataInfo.dwDataOffset + dataInfo.cksize - currentFilePos;
		// -- Allocate space for the parameter
		pEffectParms = new BYTE[paramSize];
		if (pEffectParms == NULL) {
			throw VFX_ERR_FILE_OUT_OF_MEMORY;
		}
		// -- Do the actual reading
		bytesRead = ::mmioRead(hmmio, (char*)pEffectParms, paramSize);
		if (bytesRead != paramSize) {
			throw (bytesRead == 0) ? VFX_ERR_FILE_END_OF_FILE : VFX_ERR_FILE_CANNOT_READ;
		}
		// -- The pointer must be fixed if this is User Defined
		if (effect.m_Type == EF_USER_DEFINED) {
			BYTE* pForceData = pEffectParms + sizeof(UD_PARAM);
			UD_PARAM* pUDParam = (UD_PARAM*)pEffectParms;
			pUDParam->m_pForceData = (LONG*)pForceData;
		}
	} catch (HRESULT thrownError) {
		hr = thrownError;
		::mmioClose(hmmio, 0);
		if (pEffectParms == NULL) {	// Did we get an effect?
			return NULL;
		}
	}

	::mmioClose(hmmio, 0);	// Close the file
	if (pEffectParms == NULL) {
		ASSUME_NOT_REACHED();	//Exception should have been thrown
		return NULL;
	}

	InternalEffect* pReturnEffect = InternalEffect::CreateFromVFX(diEffect, effect, envelope, pEffectParms, paramSize, hr);

	// Cleanup
	delete pEffectParms;
	pEffectParms = NULL;

	return pReturnEffect;
}

/******************************************************
**
** ForceFeedbackDevice::CreateEffect(DWORD& effectID, const DIEFFECT& diEffect)
**
** @mfunc CreateEffect.
**
******************************************************/
InternalEffect* ForceFeedbackDevice::CreateEffect(DWORD effectType, const DIEFFECT& diEffect, DWORD& dnloadID, HRESULT& hr, BOOL paramCheck)
{
	WORD majorType = WORD((effectType >> 16) & 0x0000FFFF);
	WORD minorType = WORD(effectType & 0x0000FFFF);

	if (majorType == EF_RAW_FORCE) {
		hr = SendRawForce(diEffect, paramCheck);
		if (SUCCEEDED(hr)) {
			dnloadID = RAW_FORCE_ALIAS;
		}
		return NULL;
	}

	InternalEffect* pEffect = NULL;
	BOOL isNewEffect = (dnloadID == 0);
	if (isNewEffect) {
		dnloadID = g_ForceFeedbackDevice.GetNextCreationID();
		if (dnloadID == 0) {
			hr = SFERR_OUT_OF_FF_MEMORY;
			return NULL;
		}
	}

	hr = SUCCESS;

	switch (majorType) {
		case EF_BEHAVIOR: {
			pEffect = CreateConditionEffect(minorType, diEffect, hr);
			break;
		}
		case EF_USER_DEFINED: {
			pEffect = CreateCustomForceEffect(minorType, diEffect, hr);
			break;
		}
		case EF_SYNTHESIZED: {
			pEffect = CreatePeriodicEffect(minorType, diEffect, hr);
			break;
		}
		case EF_RTC_SPRING: {
			dnloadID = SYSTEM_RTCSPRING_ALIAS_ID;
			pEffect = CreateRTCSpringEffect(minorType, diEffect);
			break;
		}
		case EF_VFX_EFFECT: {	// Visual force VFX Effect!!! Danger Will Robinson!
			pEffect = CreateVFXEffect(diEffect, hr);
			break;
		}
	}
	if (((pEffect == NULL) || (paramCheck == TRUE)) && (isNewEffect == TRUE)) {
		dnloadID = 0;
	}

	if (pEffect != NULL) {
		if ((isNewEffect == TRUE) && (paramCheck == FALSE)) {
			g_ForceFeedbackDevice.SetEffect(BYTE(dnloadID), pEffect);
		}
	} else if (!FAILED(hr)) {
		hr = SFERR_DRIVER_ERROR;
	}
	return pEffect;
}

/******************************************************
**
** ForceFeedbackDevice::GetNextCreationID() const
**
** @mfunc GetNextCreationID.
**
******************************************************/
BYTE ForceFeedbackDevice::GetNextCreationID() const
{
	// Must search straight through (start at 2, 0 is spring, 1 is friction
	for (BYTE emptyID = 2; emptyID < MAX_EFFECT_IDS; emptyID++) {
		if (m_EffectList[emptyID] == NULL) {
			break;
		}
	}
	if (emptyID == MAX_EFFECT_IDS) {
		return 0;
	}
	return emptyID;
}

/******************************************************
**
** ForceFeedbackDevice::SetEffect(BYTE globalID, BYTE deviceID, InternalEffect* pEffect)
**
** @mfunc SetEffect.
**
******************************************************/
void ForceFeedbackDevice::SetEffect(BYTE globalID, InternalEffect* pEffect)
{
	if (pEffect == NULL) {
		ASSUME_NOT_REACHED();
		return;
	}

	if (globalID == SYSTEM_EFFECT_ID) {
		m_SystemEffect = pEffect;
	} else if (globalID == SYSTEM_RTCSPRING_ALIAS_ID) {
		m_EffectList[0] = pEffect;
		if (GetFirmwareVersionMajor() == 1) {
			pEffect->SetGlobalID(SYSTEM_RTCSPRING_ID);
			pEffect->SetDeviceID(SYSTEM_RTCSPRING_ID);
		} else {
			pEffect->SetGlobalID(ID_RTCSPRING_200);
			pEffect->SetDeviceID(ID_RTCSPRING_200);
		}
		return;
	} else if (globalID < MAX_EFFECT_IDS) {
		m_EffectList[globalID] = pEffect;
	} else {
		ASSUME_NOT_REACHED();	// Out of range
	}

	pEffect->SetGlobalID(globalID);
}

/******************************************************
**
** ForceFeedbackDevice::SetDeviceIDFromStatusPacket(DWORD globalID)
**
** @mfunc SetDeviceIDFromStatusPacket.
**
******************************************************/
void ForceFeedbackDevice::SetDeviceIDFromStatusPacket(DWORD globalID)
{
	if (globalID == SYSTEM_EFFECT_ID) {
		return;
	}
	if (globalID == SYSTEM_RTCSPRING_ALIAS_ID) {
		return;
	}
	if (globalID < MAX_EFFECT_IDS) {
		InternalEffect* pEffect = m_EffectList[globalID];
		if (pEffect == NULL) {
			ASSUME_NOT_REACHED();		// There should be an effect here
			return;
		}
		pEffect->SetDeviceID(BYTE(m_LastStatusPacket.dwEffect));
#ifdef _DEBUG		// Check to see if they coincide
		if (pEffect->GetGlobalID() != pEffect->GetDeviceID()) {
			TCHAR buff[256];
			::wsprintf(buff, TEXT("SW_WHEEL.DLL: Global ID (%d) != Download ID (%d)\r\n"), pEffect->GetGlobalID(), pEffect->GetDeviceID());
			_RPT0(_CRT_WARN, buff);
		}
#endif _DEBUG
	} else {
		ASSUME_NOT_REACHED();	// Out of range
	}
}	


/******************************************************
**
** ForceFeedbackDevice::QueryStatus()
**
** @mfunc QueryStatus.
**
******************************************************/
HRESULT ForceFeedbackDevice::QueryStatus()
{
	CriticalLock cl;	// This is a critical section
	
	// Use Digital Overdrive to get the status packet
	JOYCHANNELSTATUS statusPacket = {sizeof(JOYCHANNELSTATUS)};
	
	HRESULT hRet = g_pDriverCommunicator->GetStatus(statusPacket);
	if (hRet == SUCCESS) {
		if (GetFirmwareVersionMajor() == 1) {
			// This is irrelevant till we support jolt
		} else {
			if (sizeof(statusPacket.dwDeviceStatus) == sizeof(m_Version200State)) {
				::memcpy(&m_Version200State, &(statusPacket.dwDeviceStatus), sizeof(statusPacket.dwDeviceStatus));
			} else {
				ASSUME_NOT_REACHED();
			}
		}
	}

	return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\effect.h ===
//@doc
/******************************************************
**
** @module EFFECT.H | Definition file for InternalEffect structure
**
** Description:
**		The Data Packager allows virtualization of the
**	commands into the different firmware versions packet format
**		DataPackager - Base class that defines the functionality of all DataPackagers
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**
** Classes:
**		DataPackager
**		DataPackager100 - DataPackager for Firmware 1.**
**		DataPackager200 - DataPackager for Firmware 2.**
**		DataPacket
**
** History:
**	Created 1/05/98 Matthew L. Coill (mlc)
**
** (c) 1986-1998 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__EFFECT_H__
#define	__EFFECT_H__

#include "SW_Error.hpp"
#include "Hau_Midi.hpp"
#include "DX_Map.hpp"
#include "DPack.h" // For ASSUME Macros

#ifndef override
#define override
#endif

#define ET_CUSTOMFORCE_200 0x01
#define ET_SINE_200 0x02
#define ET_SQUARE_200 0x03
#define ET_TRIANGLE_200 0x04
#define ET_SAWTOOTH_200 0x05
#define ET_CONSTANTFORCE_200 0x06

#define ET_DELAY_200 0x08	// - Not defined

#define ET_SPRING_200 0x08
#define ET_DAMPER_200 0x09
#define ET_INERTIA_200 0x0A
#define ET_FRICTION_200 0x0B
#define ET_WALL_200 0x0C
#define ET_RAWFORCE_200 0x0D	// Needed for mapping

#define ID_RTCSPRING_200 1

class DataPacket;

class Envelope
{
	protected:	// Cannot create the generic envelope
		Envelope() {};
};

class Envelope1XX : public Envelope
{
	public:
		Envelope1XX(DIENVELOPE* pDIEnvelope, DWORD baseLine, DWORD duration);

		DWORD m_AttackTime;			// Time from attack to sustain
		DWORD m_SustainTime;		// Time from sustain to fade
		DWORD m_FadeTime;			// Time from fade to end
		DWORD m_StartPercent;		// Percentage of max that is start
		DWORD m_SustainPercent;		// Percentage of max that is sustained
		DWORD m_EndPercent;			// Percentage of max during fade
};

class Envelope200 : public Envelope
{
	public:
		Envelope200(DIENVELOPE* pDIEnvelope, DWORD sustain, DWORD duration, HRESULT& hr);

		WORD	m_AttackTime;		// Time from attack to sustain
		WORD	m_FadeStart;		// Time from start to fade (attack + sustain)
		BYTE	m_StartPercent;		// Percentage of max that is start
		BYTE	m_SustainPercent;	// Percentage of max that is sustained
		BYTE	m_EndPercent;		// Percentage of max at end of fade
};

//
// @class InternalEffect class
//
class InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		InternalEffect();
		virtual ~InternalEffect();

		// Ugly! but quick and simple
		static InternalEffect* CreateSpring();
		static InternalEffect* CreateDamper();
		static InternalEffect* CreateInertia();
		static InternalEffect* CreateFriction();

		static InternalEffect* CreateRTCSpring();
		static InternalEffect* CreateSystemEffect();

		static InternalEffect* CreateCustomForce();

		static InternalEffect* CreateSine();
		static InternalEffect* CreateSquare();
		static InternalEffect* CreateTriangle();
		static InternalEffect* CreateSawtoothUp();
		static InternalEffect* CreateSawtoothDown();

		static InternalEffect* CreateConstantForce();

		static InternalEffect* CreateRamp();

		static InternalEffect* CreateWall();
		static InternalEffect* CreateDelay() { return NULL; }

		static InternalEffect* CreateFromVFX(const DIEFFECT& diOringinal, EFFECT effect, ENVELOPE envelope, BYTE* pEffectParms, DWORD paramSize, HRESULT& hr);

		virtual HRESULT Create(const DIEFFECT& diEffect);
		virtual HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		virtual UINT GetModifyOnlyNeeded() const { return 0; }
		virtual HRESULT FillModifyOnlyParms() const { return SUCCESS; }
		virtual HRESULT FillCreatePacket(DataPacket& packet) const { return SFERR_NO_SUPPORT; }

		static BYTE ComputeChecksum(const DataPacket& packet, short int numFields);
		void FillSysExHeader(DataPacket& packet) const;
		void FillHeader1XX(DataPacket& packet, BYTE effectType, BYTE effectID) const;
		void FillHeader200(DataPacket& packet, BYTE effectType, BYTE effectID) const;

		BYTE GetGlobalID() const { return m_EffectID; }
		BYTE GetDeviceID() const { return m_DeviceEffectID; }
		void SetGlobalID(BYTE id) { m_EffectID = id; }
		void SetDeviceID(BYTE id) { m_DeviceEffectID = id; }

		// For special modfication of play reapeat
		HRESULT FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, DWORD value) const;
		virtual BYTE GetRepeatIndex() const { return 0xFF; }

		void SetPlaying(BOOL playState) { m_IsPossiblyPlaying = playState; }
		BOOL IsPossiblyPlaying() const { return m_IsPossiblyPlaying; }
		BOOL IsReallyPlaying(BOOL& multiCheckStop);
	protected:
		HRESULT FillModifyPacket1XX(BYTE packetIndex, BYTE paramIndex, DWORD value) const;
		HRESULT FillModifyPacket200(BYTE packetIndex, BYTE paramIndex, BYTE low, BYTE high) const;

		BYTE m_EffectID;
		BYTE m_DeviceEffectID;
		DWORD m_Duration;
		DWORD m_Gain;
		DWORD m_SamplePeriod;
		DWORD m_TriggerPlayButton;
		DWORD m_TriggerRepeat;
		DWORD m_AxisMask;
		DWORD m_EffectAngle;
		DWORD m_PercentX;			// Percent force X
		DWORD m_PercentY;			// Percent force Y
		DWORD m_PercentAdjustment;	// Y-Force mapping combination of above
		BOOL m_AxesReversed;
		BOOL m_IsPossiblyPlaying;
};

// ********************** Behavioural Based Effects *****************************/

//
// @class BehaviouralEffect class
// Spring, Damper, Intertia, Friction, and Wall (till wall gets its own type)
//
class BehaviouralEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		BehaviouralEffect() : InternalEffect() {};

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int ConstantX() const { return m_ConditionData[0].lPositiveCoefficient; }
		long int ConstantY() const { return m_ConditionData[1].lPositiveCoefficient; }
		long int CenterX() const { return m_ConditionData[0].lOffset; }
		long int CenterY() const { return m_ConditionData[1].lOffset; }

	protected:
		DICONDITION m_ConditionData[2];		// We are just dealing with two axis currently
		BYTE m_TypeID;
};

//
// @class BehaviouralEffect1XX class
// Spring, Damper, and Inertia
//
class BehaviouralEffect1XX : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		BehaviouralEffect1XX(BYTE typeID) : BehaviouralEffect() { m_TypeID = typeID; m_HasCenter = TRUE; }

		virtual override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;

		BOOL m_HasCenter;	// Friction has no center
};

//
// @class RTCSpring1XX class
//
class RTCSpring1XX : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		RTCSpring1XX();

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		long int SaturationX() const { return m_ConditionData[0].dwPositiveSaturation; }
		long int SaturationY() const { return m_ConditionData[1].dwPositiveSaturation; }
		long int DeadBandX() const { return m_ConditionData[0].lDeadBand; }
		long int DeadBandY() const { return m_ConditionData[1].lDeadBand; }
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};

//
// @class BehaviouralEffect200 class
// Spring, Damper, and Inertia
//
class BehaviouralEffect200 : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		BehaviouralEffect200(BYTE typeID) : BehaviouralEffect() { m_TypeID = typeID; }

		override HRESULT Create(const DIEFFECT& diEffect);

		virtual override UINT GetModifyOnlyNeeded() const;
		virtual override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);

		// Distances and Forces spec'd for the firmware
		void ComputeDsAndFs();
		BYTE m_Ds[4];
		BYTE m_Fs[4];
};

//
// @class RTCSpring200 class
//
class RTCSpring200 : public BehaviouralEffect200
{
	//@access Constructor
	public:
		//@cmember constructor
		RTCSpring200();

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;

		long int SaturationX() const { return m_ConditionData[0].dwPositiveSaturation; }
		long int SaturationY() const { return m_ConditionData[1].dwPositiveSaturation; }
		long int DeadBandX() const { return m_ConditionData[0].lDeadBand; }
		long int DeadBandY() const { return m_ConditionData[1].lDeadBand; }
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};

//
// @class FrictionEffect1XX class
//
class FrictionEffect1XX : public BehaviouralEffect1XX
{
	//@access Constructor
	public:
		//@cmember constructor
		FrictionEffect1XX() : BehaviouralEffect1XX(ET_BE_FRICTION) { m_HasCenter = FALSE; }

		override HRESULT FillCreatePacket(DataPacket& packet) const;
};


//
// @class FrictionEffect200 class
//
class FrictionEffect200 : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		FrictionEffect200() : BehaviouralEffect() { m_TypeID = ET_FRICTION_200; }

		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);
};

/*
//
// @class WallEffect1XX class
//
class WallEffect1XX : public BehaviouralEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		WallEffect1XX() : BehaviouralEffect() {};

		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags) const;
	protected:
		void AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};
*/

// ********************* Periodic based Effects *****************************/

//
// @class PeriodicEffect class
// Sine, Square, Triangle
//
class PeriodicEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		PeriodicEffect();
		override ~PeriodicEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int Magnitude() const { return m_PeriodicData.dwMagnitude; }
		long int Offset() const { return m_PeriodicData.lOffset; }
		virtual long int Phase() const { return m_PeriodicData.dwPhase; }
		long int Period() const { return m_PeriodicData.dwPeriod; }
	protected:
		DIPERIODIC m_PeriodicData;		// We are just dealing with two axis currently
		Envelope* m_pEnvelope;
		BYTE m_TypeID;
};

//
// @class PeriodicEffect1XX class
//
class PeriodicEffect1XX : public PeriodicEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		PeriodicEffect1XX(BYTE typeID) : PeriodicEffect() { m_TypeID = typeID; }


		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
	protected:
		void DIToJolt(DWORD mag, DWORD off, DWORD gain, DWORD& max, DWORD& min) const;
		static DWORD DIPeriodToJoltFreq(DWORD period);

		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags) const;
};


//
// @class PeriodicEffect200 class
//
class PeriodicEffect200 : public PeriodicEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		PeriodicEffect200(BYTE typeID) : PeriodicEffect() { m_TypeID = typeID; }


		virtual override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		virtual override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
		virtual override long int Phase() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);
};

//
// @class SawtoothEffect200 class
//
class SawtoothEffect200 : public PeriodicEffect200
{
	//@access Constructor
	public:
		//@cmember constructor
		SawtoothEffect200(BOOL isUp) : PeriodicEffect200(ET_SAWTOOTH_200), m_IsUp(isUp) {};

		virtual override HRESULT Create(const DIEFFECT& diEffect);
		override long int Phase() const;
	protected:
		BOOL m_IsUp;
};

//
// @class RampEffect200 class
//
class RampEffect200 : public SawtoothEffect200
{
	//@access Constructor
	public:
		//@cmember constructor
		RampEffect200() : SawtoothEffect200(TRUE) {};

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
};


// ************************ Miscellaneuous (CustomForce, RampForce, ConstantForce, SystemEffect) *********************//

//
// @class CustomForceEffect class
//
class CustomForceEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		CustomForceEffect();
		virtual override ~CustomForceEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

	protected:
		DICUSTOMFORCE m_CustomForceData;
};

//
// @class CustomForceEffect200 class
//
class CustomForceEffect200 : public CustomForceEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		CustomForceEffect200();
		~CustomForceEffect200();

		override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	private:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);

		Envelope200* m_pEnvelope;
};


/*
//
// @class RampForceEffect class
//
class RampForceEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		RampForceEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int StartForce() const { return m_RampForceData.lStart; }
		long int EndForce() const { return m_RampForceData.lEnd; }
	protected:
		DIRAMPFORCE m_RampForceData;
};
*/

//
// @class ConstantForceEffect class
//
class ConstantForceEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		ConstantForceEffect();
		override ~ConstantForceEffect();

		virtual override HRESULT Create(const DIEFFECT& diEffect);

		// Accessors
		long int Magnitude() const { return m_ConstantForceData.lMagnitude; }
	protected:
		DICONSTANTFORCE m_ConstantForceData;
		Envelope* m_pEnvelope;
};

//
// @class ConstantForceEffect200 class
//
class ConstantForceEffect200 : public ConstantForceEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		ConstantForceEffect200() : ConstantForceEffect() {};

		override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	protected:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);
};

//
// @class WallEffect class
//
class WallEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		WallEffect() : InternalEffect() {};

		virtual override HRESULT Create(const DIEFFECT& diEffect);
	protected:
		BE_WALL_PARAM m_WallData;
};

//
// @class WallEffect200 class
//
class WallEffect200 : public WallEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		WallEffect200() : WallEffect() {};

		override HRESULT Create(const DIEFFECT& diEffect);
		override UINT GetModifyOnlyNeeded() const;
		override HRESULT FillModifyOnlyParms() const;
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);

		override BYTE GetRepeatIndex() const;
	private:
		HRESULT AdjustModifyParams(InternalEffect& newEffect, DWORD& modFlags);

		// Distances and Forces spec'd for the firmware
		void ComputeDsAndFs();
		BYTE m_Ds[4];
		BYTE m_Fs[4];
};

//
// @class SystemEffect class
//
class SystemEffect : public InternalEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		SystemEffect() {};
};

class SystemStickData1XX
{
	public:
		SystemStickData1XX();

		void SetFromRegistry(DWORD dwDeviceID);

		DWORD dwXYConst;
		DWORD dwRotConst;
		DWORD dwSldrConst;
		DWORD dwAJPos;
		DWORD dwAJRot;
		DWORD dwAJSldr;
		DWORD dwSprScl;
		DWORD dwBmpScl;
		DWORD dwDmpScl;
		DWORD dwInertScl;
		DWORD dwVelOffScl;
		DWORD dwAccOffScl;
		DWORD dwYMotBoost;
		DWORD dwXMotSat;
		DWORD dwReserved;
		DWORD dwMasterGain;
};

class SystemEffect1XX : public SystemEffect
{
	//@access Constructor
	public:
		//@cmember constructor
		SystemEffect1XX();

		override HRESULT Create(const DIEFFECT& diEffect);
		override HRESULT FillCreatePacket(DataPacket& packet) const;
		override HRESULT Modify(InternalEffect& newEffect, DWORD modFlags);
	protected:
		SystemStickData1XX m_SystemStickData;
};

#endif	__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffd_swff.cpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.CPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	FFD (SWForce HAL) API
    
    FUNCTIONS:		Function prototypes for Force Feedback Joystick interface
    				between the SWForce and the device

		FFD_GetDeviceState
		FFD_PutRawForce
		FFD_DownloadEffect
	  	FFD_DestroyEffect
	

		VFX functions:
			Download_VFX
			CreateEffectFromFile
			CreateEffectFromBuffer

	These functionality are not necessarily supported by all Force Feedback 
	devices.  For example, if a device does not support built-in synthesis 
	capability, then the entry point DownloadEffect, will return an error
	code ERROR_NO_SUPPORT.

	COMMENTS:
	This module of functions are encapsulated in SW_WHEEL.dll the DirectInput 
	DDI driver

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	21-Mar-97       MEA     original from SWForce code
			21-Mar-99		waltw	Removed unreferenced FFD_xxx functions
	              
****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "midi.hpp"
#include "hau_midi.hpp"
#include "math.h"
#include "FFD_SWFF.hpp"
#include "midi_obj.hpp"

#include "DPack.h"
#include "DTrans.h"
#include "FFDevice.h"
#include "CritSec.h"

static ACKNACK g_AckNack;

// Force Output range values
#define MAX_AMP	2047
#define MIN_AMP	-2048
#define FORCE_RANGE ((MAX_AMP - MIN_AMP)/2)

extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;
#ifdef _DEBUG
extern char g_cMsg[160];
#endif

static HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY);


// ----------------------------------------------------------------------------
// Function:    FFD_Download
//
// Purpose:     Downloads the specified Effect object UD/BE/SE to the FF device.
// Parameters:
//				IN OUT PDNHANDLE pDnloadD   - Ptr to DNHANDLE to store EffectID
//				IN PEFFECT 		 pEffect	- Ptr Common attributes for Effects
//				IN PENVELOPE	 pEnvelope	- Ptr to an ENVELOPE
// 				IN PVOID		 pTypeParam	- Ptr to a Type specific parameter
// 				IN ULONG		 ulAction	- Type of action desired
//
// Returns:
//		SUCCESS - if successful
//		SFERR_FFDEVICE_MEMORY - no more download RAM available
//		SFERR_INVALID_PARAM - Invalid parameters
//		SFERR_NO_SUPPORT - if function is unsupported.
// Algorithm:
//
// Comments:
//
//  ulAction: Type of action desired after downloading
//      PLAY_STORE   - stores in Device only
//      || the following options:
//      PLAY_STORE   - stores in Device only
//      || the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
//          PLAY_LOOP       - Loops for Count times, where count value is in
//                            HIWORD 
//          PLAY_FOREVER    - Play forever until told to stop: PLAY_LOOP with 0 
//							  value in HIWORD
// ----------------------------------------------------------------------------
HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DownloadEffect. DnloadID= %ld, Type=%ld, SubType=%ld\r\n",
   					*pDnloadID,
   					pEffect->m_Type, pEffect->m_SubType);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	return SFERR_DRIVER_ERROR;
#if 0
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

//REVIEW: Still need to do boundary Assertions, structure size check etc...
	assert(pDnloadID && pEffect);
	if (!pDnloadID || !pEffect) return (SFERR_INVALID_PARAM);	

// If the Effect type is not a BE_DELAY or EF_ROM_EFFECT,
// make sure there is a pTypeParam
	if ((BE_DELAY != pEffect->m_SubType) && (EF_ROM_EFFECT != pEffect->m_Type))
	{
		assert(pTypeParam);
		if (NULL == pTypeParam) return (SFERR_INVALID_PARAM);
	}

	// Don't support PLAY_LOOP for this version
	if ((ulAction & PLAY_LOOP) || (ulAction & 0xffff0000))
		return (SFERR_NO_SUPPORT);

// REVIEW:  TO increase performance, we should do a parameter mod check
// For now, we'll assume all parameters are changed, for dwFlags
// otherwise, we should check for:
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Figure out the Common members
	BYTE bAxisMask = (BYTE) pEffect->m_AxisMask;
	ULONG ulDuration = pEffect->m_Duration;
	if (PLAY_FOREVER == (ulAction & PLAY_FOREVER)) 	ulDuration  = 0;

	// map button 10 to button 9
	if(pEffect->m_ButtonPlayMask == 0x0200)
		pEffect->m_ButtonPlayMask = 0x0100;
	else if(pEffect->m_ButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;

	DWORD dwFlags = DIEP_ALLPARAMS;
	SE_PARAM seParam = { sizeof(SE_PARAM)};

	PBE_SPRING_PARAM pBE_xxx1D;
	PBE_SPRING_2D_PARAM pBE_xxx2D;
	BE_XXX BE_xxx;
	PBE_WALL_PARAM pBE_Wall;

	// Decode the type of Download to use
	HRESULT hRet = SFERR_INVALID_PARAM;
	ULONG ulSubType = pEffect->m_SubType;
	switch (pEffect->m_Type)
	{
		case EF_BEHAVIOR:
			switch (ulSubType)
			{
				case BE_SPRING:		// 1D Spring
				case BE_DAMPER:		// 1D Damper
				case BE_INERTIA:	// 1D Inertia
				case BE_FRICTION:	// 1D Friction
					pBE_xxx1D = (PBE_SPRING_PARAM) pTypeParam;
					if (X_AXIS == bAxisMask)
					{
						BE_xxx.m_XConstant = pBE_xxx1D->m_Kconstant;
						BE_xxx.m_YConstant = 0;
						if (ulSubType != BE_FRICTION)
							BE_xxx.m_Param3 = pBE_xxx1D->m_AxisCenter;
						BE_xxx.m_Param4= 0;
					}
					else
					{
						if (Y_AXIS != bAxisMask)
							break;
						else
						{
							BE_xxx.m_YConstant = pBE_xxx1D->m_Kconstant;
							BE_xxx.m_XConstant = 0;
							if (ulSubType != BE_FRICTION)
								BE_xxx.m_Param4 = pBE_xxx1D->m_AxisCenter;
							BE_xxx.m_Param3= 0;
						}
					}
					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
   					break;

				case BE_SPRING_2D:		// 2D Spring
				case BE_DAMPER_2D:		// 2D Damperfs
 				case BE_INERTIA_2D:		// 2D Inertia
				case BE_FRICTION_2D:	// 2D Friction
					// Validate AxisMask is for 2D
					if ( (X_AXIS|Y_AXIS) != bAxisMask)
						break;
					pBE_xxx2D = (PBE_SPRING_2D_PARAM) pTypeParam;
					BE_xxx.m_XConstant = pBE_xxx2D->m_XKconstant;
					if (ulSubType != BE_FRICTION_2D)
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_YKconstant;
						BE_xxx.m_Param3 = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param4 = pBE_xxx2D->m_YAxisCenter;
					}
					else
					{
						BE_xxx.m_YConstant = pBE_xxx2D->m_XAxisCenter;
						BE_xxx.m_Param3 = 0;
						BE_xxx.m_Param4 = 0;
					}

					hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					break;

				case BE_WALL:
					pBE_Wall = (PBE_WALL_PARAM) pTypeParam;
					if (   (pBE_Wall->m_WallAngle == 0)
						|| (pBE_Wall->m_WallAngle == 90)
						|| (pBE_Wall->m_WallAngle == 180)
						|| (pBE_Wall->m_WallAngle == 270) )
					{
						BE_xxx.m_XConstant = pBE_Wall->m_WallType;
						BE_xxx.m_YConstant = pBE_Wall->m_WallConstant;
						BE_xxx.m_Param3    = pBE_Wall->m_WallAngle;
						BE_xxx.m_Param4    = pBE_Wall->m_WallDistance;
						hRet = CMD_Download_BE_XXX(pEffect, NULL, &BE_xxx, (PDNHANDLE) pDnloadID, dwFlags);
					}
					else
						hRet = SFERR_NO_SUPPORT;
					break;

				case BE_DELAY:
					if (0 == ulDuration) return (SFERR_INVALID_PARAM);
//					hRet = CMD_Download_NOP_DELAY(ulDuration, pEffect, (PDNHANDLE) pDnloadID);
					break;

				default:
					hRet = SFERR_NO_SUPPORT;
					break;
			}
			break;

		case EF_USER_DEFINED:
			break;

		case EF_ROM_EFFECT:
			// Setup the default parameters for the Effect
			if (SUCCESS != g_pJoltMidi->SetupROM_Fx(pEffect))
			{
				hRet = SFERR_INVALID_OBJECT;
				break;
			}
			
			// Map the SE_PARAM
			// set the frequency
			seParam.m_Freq = 0;				// unused by ROM Effect
			seParam.m_SampleRate = pEffect->m_ForceOutputRate;
			seParam.m_MinAmp = -100;
			seParam.m_MaxAmp = 100;
			
			break;
			
		case EF_SYNTHESIZED:
			if (0 == ((PSE_PARAM)pTypeParam)->m_SampleRate)
				((PSE_PARAM)pTypeParam)->m_SampleRate = DEFAULT_JOLT_FORCE_RATE;
			if (0 == pEffect->m_ForceOutputRate)
				pEffect->m_ForceOutputRate = DEFAULT_JOLT_FORCE_RATE;

			break;

		default:
			hRet = SFERR_INVALID_PARAM;
	}
	
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Exit: FFD_DownloadEffect. DnloadID = %lx, hRet=%lx\r\n", 
				*pDnloadID, hRet);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	return (hRet);
#endif //0
}

// *** ---------------------------------------------------------------------***
// Function:   	FFD_DestroyEffect
// Purpose:    	Destroys the Effect from download RAM storage area.
// Parameters: 
//				IN EFHANDLE EffectID		// an Effect ID
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_ID
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//				The Device's Effect ID and memory is returned to free pool.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "Enter: FFD_DestroyEffect. DnloadID:%ld\r\n",
   			  DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->DestroyEffect(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	hr = g_pDataTransmitter->Transmit(g_AckNack);	// Send it off
	return hr;
}


// *** ---------------------------------------------------------------------***
// Function:   	FFD_VFXProcessEffect
// Purpose:    	Commands FF device to process downloaded Effects
//
// Parameters: 
//				IN OUT PDNHANDLE pDnloadID	// Storage for new Download ID
//				IN int 	nNumEffects			// Number of Effect IDs in the array
//				IN ULONG 	ulProcessMode	// Processing mode
//				IN PDNHANDLE pPListArray// Pointer to an array of Effect IDs
//
// Returns:    	SUCCESS - if successful, else
//				SFERR_INVALID_PARAM
//				SFERR_NO_SUPPORT
//
// Algorithm:
//
// Comments:   	
//		The following processing is available:
//		  CONCATENATE: Enew = E1 followed by E2
//		  SUPERIMPOSE: Enew = E1 (t1) +  E2 (t1)  +  E1 (t2) 
//						   +  E2 (t2) + . . . E1 (tn) +  E2 (tn)
//
//	ulProcessMode:
//		Processing mode:
//		CONCATENATE	- CONCATENATE
//		SUPERIMPOSE	- Mix or overlay
//
//	pEFHandle:
//		The array of Effect IDs must be one more than the actual number
//		of Effect IDs to use.  The first entry pEFHandle[0] will be
//		used to store the new Effect ID created for the CONCATENATE
//		and SUPERIMPOSE process choice.
//
// *** ---------------------------------------------------------------------***
HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "FFD_ProcessEffect, DnloadID=%ld\r\n",
					*pDnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	assert(pDnloadID && pPListArray);
	if ((NULL == pDnloadID) || (NULL == pPListArray)) return (SFERR_INVALID_PARAM);

	assert(nNumEffects > 0 && nNumEffects <= MAX_PLIST_EFFECT_SIZE);
	if ((nNumEffects > MAX_PLIST_EFFECT_SIZE) || (nNumEffects <= 0))
		return (SFERR_INVALID_PARAM);

	// map button 10 to button 9
	if(ulButtonPlayMask == 0x0200)
		ulButtonPlayMask = 0x0100;
	else if(ulButtonPlayMask == 0x0100)
		return SFERR_NO_SUPPORT;   

	return S_OK;
}


// *** ---------------------------------------------------------------------***
// Function:   	AngleToXY
// Purpose:    	Computes XY from Angle
// Parameters: 
//				IN LONG lDirectionAngle2D	- Angle in Degrees
//				IN LONG lForceValue			- Resultant Force
//				IN ULONG ulAxisMask			- Axis to Affect
//				IN OUT PLONG pX				- X-Axis store
//				IN OUT PLONG pY				- Y-Axis store
// Returns:    	pX, pY with valid angle components
//
// *** ---------------------------------------------------------------------***
HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lValueData,
	IN ULONG ulAxisMask,
	IN OUT PLONG pX,
	IN OUT PLONG pY)
{
// If single Axis only, then use the force on that axis.
// If X and Y-axis, then use 2D angle
// If X, Y, and Z-axis, then use 3D angle
// If axis is other than X,Y,Z then no support
	double Radian;

	switch (ulAxisMask)
	{
		case (X_AXIS|Y_AXIS):	// use 2D
			Radian = xDegrees2Radians(lDirectionAngle2D % 360);
#ifdef ORIENTATION_MODE1
			*pX = - (long) (lValueData * cos(Radian));
			*pY = (long) (lValueData * sin(Radian));
#else
			*pX = - (long) (lValueData * sin(Radian));
			*pY = (long) (lValueData * cos(Radian));
#endif
			break;

		case X_AXIS:
			*pX = lValueData;
			*pY = 0;
			break;

		case Y_AXIS:
			*pX = 0;
			*pY = lValueData;
			break;
		
		case (X_AXIS|Y_AXIS|Z_AXIS):	// use 3D
		default:
			return (SFERR_NO_SUPPORT);	
			break;
	}
	return SUCCESS;
}

//
// ---  VFX SUPPORT FUNCTIONS
//


// *** ---------------------------------------------------------------------***
// Function:   	CreateEffectFromBuffer
// Purpose:    	Creates an Effect from a buffer
// Parameters: 	PSWFORCE pISWForce		- Ptr to a SWForce
//				PPSWEFFECT ppISWEffect	- Ptr to a SWEffect 
//				PVOID pBuffer					- Ptr to a buffer block 
//				DWORD dwByteCount				- Bytes in block 
//				LPGUID lpGUID					- Joystick GUID
//				
//
// Returns:    	SUCCESS - if successful, else
//				error code
//
// Algorithm:
//
// Comments:
//   	
// *** ---------------------------------------------------------------------***

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwByteCount,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags)
{
#ifdef _DEBUG
   	_RPT0(_CRT_WARN, "CImpIVFX::CreateEffectFromBuffer\n");
#endif
	// parameter checking
	if ( !(pBuffer && pDnloadID) ) 
			return SFERR_INVALID_PARAM;

	// variables used in this function
	#define ID_TABLE_SIZE	50
	MMRESULT mmresult;
	DWORD dwMaxID = 0;		// maximum id of effects entered into the following table
	DNHANDLE rgdwDnloadIDTable[ID_TABLE_SIZE];
	DNHANDLE dwCurrentDnloadID = 0;
	int nNextID = 0;
	HRESULT hResult = SUCCESS;
	DWORD dwBytesRead;
	DWORD dwBytesToRead;
	BYTE* pParam = NULL;
	BOOL bDone = FALSE;
	BOOL bSubEffects = FALSE;
	DWORD dwID;
	DWORD c;	// cleanup counter variable

	// debugging variables (to make sure we destroy all but one
	// created effect on success, and that we destory every
	// created effect on failure)...
#ifdef _DEBUG
	int nEffectsCreated = 0;
	int nEffectsDestroyed = 0;
	BOOL bFunctionSuccessful = FALSE;
#endif //_DEBUG

	// clear effect table (we check it during cleanup...  anything
	// that isn't NULL gets destroyed.)
	memset(rgdwDnloadIDTable,NULL,sizeof(rgdwDnloadIDTable));

	// open a RIFF memory file using the buffer
	MMIOINFO mmioinfo;
	mmioinfo.dwFlags		= 0;
	mmioinfo.fccIOProc		= FOURCC_MEM;
	mmioinfo.pIOProc		= NULL;
	mmioinfo.wErrorRet		= 0;
	mmioinfo.htask			= NULL;
	mmioinfo.cchBuffer		= dwByteCount;
	mmioinfo.pchBuffer		= (char*)pBuffer;
	mmioinfo.pchNext		= 0;
	mmioinfo.pchEndRead		= 0;
	mmioinfo.lBufOffset		= 0;
	mmioinfo.adwInfo[0]		= 0;
	mmioinfo.adwInfo[1]		= 0;
	mmioinfo.adwInfo[2]		= 0;
	mmioinfo.dwReserved1	= 0;
	mmioinfo.dwReserved2	= 0;
	mmioinfo.hmmio			= NULL;
	
	HMMIO hmmio;
	hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);
	if(hmmio == NULL)
	{
		hResult = MMIOErrorToSFERRor(mmioinfo.wErrorRet);
		goto cleanup;
	}

	// descend into FORC RIFF
	MMCKINFO mmckinfoForceEffectRIFF;
	mmckinfoForceEffectRIFF.fccType = FCC_FORCE_EFFECT_RIFF;
	mmresult = mmioDescend(hmmio, &mmckinfoForceEffectRIFF, NULL, MMIO_FINDRIFF);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	//! handle loading of GUID chunk when its implemented/testable

	// descend into trak list
	MMCKINFO mmckinfoTrackLIST;
	mmckinfoTrackLIST.fccType = FCC_TRACK_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoTrackLIST, &mmckinfoForceEffectRIFF,
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// descend into the first efct list (there has to be at least one effect)
	MMCKINFO mmckinfoEffectLIST;
	mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
	mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
						   MMIO_FINDLIST);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	bDone = FALSE;
	do
	{
		// descend into id chunk
		MMCKINFO mmckinfoIDCHUNK;
		mmckinfoIDCHUNK.ckid = FCC_ID_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoIDCHUNK, &mmckinfoEffectLIST, 
							   MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the id
		//DWORD dwID;  moved to being function global so we can use it near the end
		dwBytesToRead = sizeof(DWORD);
		dwBytesRead = mmioRead(hmmio, (char*)&dwID, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}
		if(dwID >= ID_TABLE_SIZE)
		{
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			goto cleanup;
		}

		// ascend from id chunk
		mmresult = mmioAscend(hmmio, &mmckinfoIDCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// descend into data chunk
		MMCKINFO mmckinfoDataCHUNK;
		mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
		mmresult = mmioDescend(hmmio, &mmckinfoDataCHUNK, &mmckinfoEffectLIST, 
								MMIO_FINDCHUNK);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// read the effect structure
		EFFECT effect;
		dwBytesToRead = sizeof(EFFECT);
		dwBytesRead = mmioRead(hmmio, (char*)&effect, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// get the envelope structure
		ENVELOPE envelope;
		dwBytesToRead = sizeof(ENVELOPE);
		dwBytesRead = mmioRead(hmmio, (char*)&envelope, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// calculate the size of and allocate a param structure
		if(pParam != NULL)
		{
			delete [] pParam;
			pParam = NULL;
		}
		// find cur pos w/o changing it
		DWORD dwCurrentFilePos = mmioSeek(hmmio, 0, SEEK_CUR);
		if(dwCurrentFilePos == -1)
		{
			hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTSEEK);
			goto cleanup;
		}
		DWORD dwEndOfChunk = mmckinfoDataCHUNK.dwDataOffset
							 + mmckinfoDataCHUNK.cksize;
		dwBytesToRead = dwEndOfChunk - dwCurrentFilePos;
		pParam = new BYTE[dwBytesToRead];
		if(pParam == NULL)
		{
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			goto cleanup;
		}

		// get the param structure
		dwBytesRead = mmioRead(hmmio, (char*)pParam, dwBytesToRead);
		if(dwBytesRead != dwBytesToRead)
		{
			if(dwBytesRead == 0)
				hResult = VFX_ERR_FILE_END_OF_FILE;
			else
				hResult = MMIOErrorToSFERRor(MMIOERR_CANNOTREAD);
			goto cleanup;
		}

		// ascend the data chunk
		mmresult = mmioAscend(hmmio, &mmckinfoDataCHUNK, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// ascend from the efct list
		mmresult = mmioAscend(hmmio, &mmckinfoEffectLIST, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}

		// reset subeffects flag
		bSubEffects = FALSE;

		// special fix-ups for user-defined
		if(effect.m_Type == EF_USER_DEFINED && 
				(effect.m_SubType == PL_CONCATENATE 
				|| effect.m_SubType == PL_SUPERIMPOSE
				|| effect.m_SubType == UD_WAVEFORM))
		{
			if(effect.m_SubType == UD_WAVEFORM)
			{
				// fix the pointer to the force data in the UD_PARAM
				BYTE* pForceData = pParam + sizeof(UD_PARAM); // - sizeof(LONG*);
				UD_PARAM* pUDParam =  (UD_PARAM*)pParam;
				pUDParam->m_pForceData = (LONG*)pForceData;

				// do a sanity check
				if(pUDParam->m_NumVectors > MAX_UD_PARAM_FORCE_DATA_COUNT)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}
			}
			else if(effect.m_SubType == PL_CONCATENATE 
									|| effect.m_SubType == PL_SUPERIMPOSE)
			{
				// fix the pointer to the PSWEFFECT list in the PL_PARAM
				BYTE* pProcessList = pParam + sizeof(PL_PARAM);
				PL_PARAM* pPLParam = (PL_PARAM*)pParam;
				pPLParam->m_pProcessList = (PPSWEFFECT)pProcessList;
				
				// do a sanity check
				if(pPLParam->m_NumEffects > MAX_PL_PARAM_NUM_EFFECTS)
				{
					hResult = VFX_ERR_FILE_BAD_FORMAT;
					goto cleanup;
				}

				// make sure all entries in this process list are valid
				ULONG i;
				for (i = 0; i < pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];
					if(nThisID >= ID_TABLE_SIZE)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];
					if(dwThisDnloadID == 0)
					{
						hResult = VFX_ERR_FILE_BAD_FORMAT;
						goto cleanup;
					}
				}
				
				// use the ID table to insert the download ID's
				for(i=0; i<pPLParam->m_NumEffects; i++)
				{
					UINT nThisID = (UINT)pPLParam->m_pProcessList[i];

					DNHANDLE dwThisDnloadID=rgdwDnloadIDTable[nThisID];

					pPLParam->m_pProcessList[i] = (IDirectInputEffect*)dwThisDnloadID;

					// since this effect has been used in a process list,
					// and it will be destroyed after being used in CreateEffect,
					// null it's entry in the table so it doesn't get erroneously
					// redestroyed during cleanup of an error.
					rgdwDnloadIDTable[nThisID] = NULL;
				}

				// we have a process list with sub effects, so set the flag
				bSubEffects = TRUE;
			}
			else
			{
				// there are no other UD sub-types
				hResult = VFX_ERR_FILE_BAD_FORMAT;
				goto cleanup;
			}
		}

		// download the effect

		// create the effect
		//hResult = pISWForce->CreateEffect(&pISWEffect, &effect, 
		//				&envelope, pParam);


		if(effect.m_SubType != PL_CONCATENATE && effect.m_SubType != PL_SUPERIMPOSE)
		{
			EFFECT SmallEffect;
			SmallEffect.m_Bytes = sizeof(EFFECT);
			SmallEffect.m_Type = effect.m_Type;
			SmallEffect.m_SubType = effect.m_SubType;
			SmallEffect.m_AxisMask = effect.m_AxisMask;
			SmallEffect.m_DirectionAngle2D = effect.m_DirectionAngle2D;
			SmallEffect.m_DirectionAngle3D = effect.m_DirectionAngle3D;
			SmallEffect.m_Duration = effect.m_Duration;
			SmallEffect.m_ForceOutputRate = effect.m_ForceOutputRate;
			SmallEffect.m_Gain = effect.m_Gain;
			SmallEffect.m_ButtonPlayMask = effect.m_ButtonPlayMask;
			*pDnloadID = 0;

			hResult = FFD_DownloadEffect(pDnloadID, &SmallEffect, &envelope, pParam, ulAction);
		}
		else
		{
			ULONG ulButtonPlayMask = effect.m_ButtonPlayMask;
			int nNumEffects = ((PL_PARAM*)pParam)->m_NumEffects;
			ULONG ulProcessMode = effect.m_SubType;
			PDNHANDLE pPListArray = new DNHANDLE[ID_TABLE_SIZE];
			for(int i=0; i<nNumEffects; i++)
				pPListArray[i] = (DNHANDLE)(((PL_PARAM*)pParam)->m_pProcessList[i]);
			*pDnloadID = 0;

			hResult = FFD_VFXProcessEffect(ulButtonPlayMask, pDnloadID, nNumEffects,
				ulProcessMode,pPListArray);
		}

		// moved check for success below...

#ifdef _DEBUG
		if (!FAILED(hResult))
			nEffectsCreated++;
#endif //_DEBUG

		// if there were sub effects we need to destroy them, making
		// their ref counts become 1, so the entire effect can be destroyed
		// by destroying the root effect.
#if 0
		if (bSubEffects)
		{
			PL_PARAM* pPLParam = (PL_PARAM*)pParam;

			for (ULONG i = 0; i < pPLParam->m_NumEffects; i++)
			{
				ASSERT(pPLParam->m_pProcessList[i] != NULL);
				pISWForce->DestroyEffect(pPLParam->m_pProcessList[i]);
#ifdef _DEBUG
				nEffectsDestroyed++;
#endif //_DEBUG
			}
		}
#endif

		// now check for success of CreateEffect, because regardless of
		// whether or not it succeeded, we -must- have destroyed the subeffects
		// before continuing, or cleanup will not work properly...
		if (SUCCESS != hResult)
		{
			goto cleanup;
		}

		// put the id/DnloadID pair into the map
		rgdwDnloadIDTable[dwID] = *pDnloadID; //pISWEffect;
		
		// keep track of the highest ID in the effect table
		if (dwID > dwMaxID)
			dwMaxID = dwID;

		// try to descend the next efct
		mmresult = mmioDescend(hmmio, &mmckinfoEffectLIST, &mmckinfoTrackLIST, 
							   MMIO_FINDLIST);
		if(mmresult == MMIOERR_CHUNKNOTFOUND)
		{
			// we are at the end of the list
			bDone = TRUE;
		}
		else if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
			goto cleanup;
		}
	}
	while(!bDone);

	// ascend from trak list
	mmresult = mmioAscend(hmmio, &mmckinfoTrackLIST, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// ascend from FORCE RIFF
	mmresult = mmioAscend(hmmio, &mmckinfoForceEffectRIFF, 0);
	if(mmresult != MMSYSERR_NOERROR)
	{
		hResult = MMIOErrorToSFERRor(mmresult);
		goto cleanup;
	}

	// get the return value
	//*pDnloadID = dwCurrentDnloadID;

	// clear the final effect's entry in the table so we don't destroy it during cleanup
	rgdwDnloadIDTable[dwID] = 0;

	// at this point the entire table should be NULL... make sure of it
	for (c = 0; c <= dwMaxID; c++)
		;

#ifdef _DEBUG
	bFunctionSuccessful = TRUE;
#endif //_DEBUG

	cleanup:

	// destroy everything in the effect table that isn't NULL 
	for (c = 0; c <= dwMaxID; c++)
		if (NULL != rgdwDnloadIDTable[c])
		{
			FFD_DestroyEffect(rgdwDnloadIDTable[c]);
			rgdwDnloadIDTable[c] = 0;
#ifdef _DEBUG
			nEffectsDestroyed++;
#endif //_DEBUG
		}

#ifdef _DEBUG
	// make sure we destroy all but one created effect on success,
	// and that we destory -every- created effect on failure.
	if (bFunctionSuccessful)
	{
		;//ASSERT(nEffectsCreated - 1 == nEffectsDestroyed);
	}
	else
	{
		;//ASSERT(nEffectsCreated == nEffectsDestroyed);
	}
#endif //_DEBUG

	// close the memory RIFF file
	if(hmmio != NULL)
	{
		mmresult = mmioClose(hmmio, 0);
		if(mmresult != MMSYSERR_NOERROR)
		{
			hResult = MMIOErrorToSFERRor(mmresult);
		}
	}

	// de-allocate any allocated memory
	if(pParam != NULL)
		delete [] pParam;

	// return the error code, which is SUCCESS, unless there was an error
	return hResult;

}

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult)
{
	HRESULT hResult;

	switch(mmresult)
	{
		case MMIOERR_FILENOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_OUTOFMEMORY:
			hResult = VFX_ERR_FILE_OUT_OF_MEMORY;
			break;
		case MMIOERR_CANNOTOPEN:
			hResult = VFX_ERR_FILE_CANNOT_OPEN;
			break;
		case MMIOERR_CANNOTCLOSE:
			hResult = VFX_ERR_FILE_CANNOT_CLOSE;
			break;
		case MMIOERR_CANNOTREAD:
			hResult = VFX_ERR_FILE_CANNOT_READ;
			break;
		case MMIOERR_CANNOTWRITE:
			hResult = VFX_ERR_FILE_CANNOT_WRITE;
			break;
		case MMIOERR_CANNOTSEEK:
			hResult = VFX_ERR_FILE_CANNOT_SEEK;
			break;
		case MMIOERR_CANNOTEXPAND:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_CHUNKNOTFOUND:
			hResult = VFX_ERR_FILE_BAD_FORMAT;
			break;
		case MMIOERR_UNBUFFERED:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
		case MMIOERR_PATHNOTFOUND:
			hResult = VFX_ERR_FILE_NOT_FOUND;
			break;
		case MMIOERR_ACCESSDENIED:
			hResult = VFX_ERR_FILE_ACCESS_DENIED;
			break;
		case MMIOERR_SHARINGVIOLATION:
			hResult = VFX_ERR_FILE_SHARING_VIOLATION;
			break;
		case MMIOERR_NETWORKERROR:
			hResult = VFX_ERR_FILE_NETWORK_ERROR;
			break;
		case MMIOERR_TOOMANYOPENFILES:
			hResult = VFX_ERR_FILE_TOO_MANY_OPEN_FILES;
			break;
		case MMIOERR_INVALIDFILE:
			hResult = VFX_ERR_FILE_INVALID;
			break;
		default:
			hResult = VFX_ERR_FILE_UNKNOWN_ERROR;
			break;
	}

	return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffd_swff.hpp ===
/****************************************************************************

    MODULE:     	FFD_SWFF.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header to define FFD (Swforce) Force Feedback Driver API
    
    FUNCTIONS:		


	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	22-Jan-96       MEA     original
	1.1		21-Mar-97		MEA		from SWForce
			21-Mar-99		waltw	Removed unreferenced FFD_xxx functions,
									CreateEffectFromFile
		        
****************************************************************************/
#ifndef FFD_SWFF_SEEN
#define FFD_SWFF_SEEN
#include "DX_Map.hpp"
#include "hau_midi.hpp"

#define	TWOPI	(3.14159265358979323846 * 2)
#define	PI		(3.14159265358979323846)
#define	PI2		(1.57079632679489661923)
#define	PI4		(0.78539816339744830966)
#define RADIAN 	(57.29577951)

#define xDegrees2Radians(rAngle) 		((rAngle) * PI / 180.0)
#define xRadians2Degrees(rAngle) 		((rAngle) * 180.0 / PI)

//
// --- Force File defines
//
#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')


#define MAX_UD_PARAM_FORCE_DATA_COUNT	1000
#define MAX_PL_PARAM_NUM_EFFECTS		50


//---------------------------------------------------------------------------
// Function prototype declarations
//---------------------------------------------------------------------------
#ifdef _cplusplus
extern "C" {
#endif

HRESULT CreateEffectFromBuffer(
			IN PVOID pBuffer,
			IN DWORD dwFileSize,
			IN ULONG ulAction,
			IN OUT PDNHANDLE pDnloadID,
			IN DWORD dwFlags);

HRESULT MMIOErrorToSFERRor(MMRESULT mmresult);

HRESULT AngleToXY(
	IN LONG lDirectionAngle2D,
	IN LONG lForceValue,
	IN ULONG ulAxisMask,
	IN OUT PSHORT pX,
	IN OUT PSHORT pY);

HRESULT WINAPI  FFD_DownloadEffect( 
	IN OUT PDNHANDLE pDnloadID, 
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
	IN PVOID pTypeParam, 
	IN ULONG ulAction);

HRESULT WINAPI  FFD_DestroyEffect( 
	IN DNHANDLE EffectID);

HRESULT WINAPI FFD_VFXProcessEffect(
	IN ULONG ulButtonPlayMask,
	IN OUT PDNHANDLE pDnloadID,
	IN int nNumEffects, 
	IN ULONG ulProcessMode,
	IN PDNHANDLE pPListArray);

#ifdef _cplusplus
}
#endif


#endif // of ifndef FFD_SWFF_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffdevice.h ===
//@doc
/******************************************************
**
** @module FFDEVICE.H | Definition file for FFDevice class
**
** Description:
**		This is the generic FF device. Independant of
**	Firmawate and how data reaches the device
**	This first implementation uses the old CJoltMidi to
**	minimize new code.
**
** History:
**	Created 11/17/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__FFDEVICE_H__
#define	__FFDEVICE_H__

#include <dinput.h>
#include "vxdioctl.hpp"		// Joychannel status def
#include "Effect.h"
#include "Hau_Midi.hpp" // For definition of MAX_EFFECT_IDS

#define RAW_FORCE_ALIAS 0xFF

// Currently there is some extra stuff in here, that should be part of other objects

struct DEVICESTATE200	// sizeof DWORD
{
#pragma pack(1)
	unsigned short m_ErrorStatus : 3;
	unsigned short m_HardwareReset : 1;
	unsigned short m_Uncalibrated : 1;
	unsigned short m_HostDisable : 1;
	unsigned short m_HostPause : 1;
	unsigned short m_UserDisable : 1;
	unsigned short m_RS232Mode : 1;
	unsigned short m_BandwidthExceeded : 1;
	unsigned short m_HostReset : 1;
	unsigned short m_NoPedals : 1;
	unsigned short m_Fluff : 4;
	unsigned short m_Fluff2 : 16;
#pragma pack()
};


//
// @class ForceFeedbackDevice class
//
class ForceFeedbackDevice
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		ForceFeedbackDevice();
		//@cmember destructor
		~ForceFeedbackDevice();

		BOOL DetectHardware();

		// Effect related functions
		InternalEffect* GetEffect(DWORD effectID) const;
		InternalEffect* RemoveEffect(DWORD effectID);
		InternalEffect* CreateEffect(DWORD effectType, const DIEFFECT& diEffect, DWORD& dnloadID, HRESULT& hr, BOOL paramCheck);
		void SetEffect(BYTE globalID, InternalEffect* pEffect);
		BYTE GetNextCreationID() const;

		HRESULT InitRTCSpring(DWORD dwDeviceID);
		HRESULT InitJoystickParams(DWORD dwDeviceID);

		void StateChange(DWORD dwDeviceID, DWORD newStateFlags);	// Called after new state sent to the stick
		DWORD GetDIState() const { return m_DIStateFlags; }

		// OS Version functions
		DWORD GetPlatform() const { return m_OSVersion.dwPlatformId; }
		DWORD GetPlatformMajorVersion() const { return m_OSVersion.dwMajorVersion; }
		DWORD GetPlatformMinorVersion() const { return m_OSVersion.dwMinorVersion; }
		DWORD GetOSBuildNumber() const { return m_OSVersion.dwBuildNumber; }
		BOOL IsOSNT5() const { return ((m_OSVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) && (m_OSVersion.dwMajorVersion == 5)); }

		// Firmware version functions
		void SetFirmwareVersion(DWORD dwDeviceID, DWORD major, DWORD minor);
		DWORD GetFirmwareVersionMajor() const { return m_FirmwareVersionMajor; }
		DWORD GetFirmwareVersionMinor() const { return m_FirmwareVersionMinor; }

		USHORT GetAckNackMethod(USHORT methodIndex) const { return USHORT((m_FirmwareAckNackValues >> methodIndex) & 0x00000003); }
		short GetYMappingPercent(UINT index) const;
		DWORD GetSpringOffset() const { return m_SpringOffset; }

		// Driver version functions
		DWORD GetDriverVersionMajor() const { return m_DriverVersionMajor; }
		DWORD GetDriverVersionMinor() const { return m_DriverVersionMinor; }
		void SetDriverVersion(DWORD major, DWORD minor);

		// Status update and retreival
		HRESULT QueryStatus();
		DEVICESTATE200 GetState200() const { return m_Version200State; }
		SWDEVICESTATE GetState1XX() const { return m_Version1XXState; }

		// If we were supporting jolt switch off firmware version
		BOOL IsHardwareReset() const { return (m_Version200State.m_HardwareReset != 0); }
		BOOL IsSerial() const { return (m_Version200State.m_RS232Mode != 0); }
		BOOL IsHostReset() const { return (m_Version200State.m_HostReset != 0); }
		BOOL IsShutdown() const { return IsHostReset(); }
		BOOL IsHostPause() const { return (m_Version200State.m_HostPause != 0); }
		BOOL IsUserDisable() const { return (m_Version200State.m_UserDisable != 0); }
		BOOL IsHostDisable() const { return (m_Version200State.m_HostDisable != 0); }
		unsigned short ErrorStatus() const { return m_Version200State.m_ErrorStatus; } 

		// Status packet ptr
		JOYCHANNELSTATUS* GetLastStatusPacket() { return &m_LastStatusPacket; }
		void SetDeviceIDFromStatusPacket(DWORD globalID);

		//@access private data members
	private:
		HRESULT InitRTCSpring1XX(DWORD dwDeviceID);
		HRESULT InitRTCSpring200(DWORD dwDeviceID);

		InternalEffect* CreateConditionEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateCustomForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreatePeriodicEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateConstantForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateRampForceEffect(DWORD minorType, const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateRTCSpringEffect(DWORD minorType, const DIEFFECT& diEffect);
		InternalEffect* CreateVFXEffect(const DIEFFECT& diEffect, HRESULT& hr);
		InternalEffect* CreateVFXEffectFromBuffer(const DIEFFECT& diEffect, BYTE* pEffectBuffer, ULONG numBufferBytes, HRESULT& hr);

		HRESULT SendRawForce(const DIEFFECT& diEffect, BOOL paramCheck);

		InternalEffect* m_EffectList[MAX_EFFECT_IDS];
		InternalEffect* m_SystemEffect;

		// Device state
		SWDEVICESTATE	m_Version1XXState;
		DEVICESTATE200	m_Version200State;
		DWORD m_DIStateFlags;
		JOYCHANNELSTATUS m_LastStatusPacket;

		// Version crap
		OSVERSIONINFO m_OSVersion;
		DWORD m_FirmwareVersionMajor;
		DWORD m_FirmwareVersionMinor;
		DWORD m_FirmwareAckNackValues;
		DWORD m_DriverVersionMajor;
		DWORD m_DriverVersionMinor;

		DWORD m_SpringOffset;
		DWORD m_Mapping;
		long int m_RawForceX;
		long int m_RawForceY;
		short m_PercentMappings[14];
};


extern ForceFeedbackDevice g_ForceFeedbackDevice;

#endif	__FFDEVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\hau_midi.cpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for Jolt Midi device command Protocol
    
    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			02-Apr-96	MEA   	Original
				19-Sep-96	MEA		Removed ES1.0 specific code
				05-Dec-96	MEA		Removed ALLACK debug switch
	1.1			17-Mar-97	MEA		DX-FF mode
				14-Apr-97	MEA		Added support for RTC spring
				21-Mar-99	waltw	Removed unreferenced ModifyEnvelopeParams,
									ModifyEffectParams, MapEnvelope, CMD_ModifyParamByIndex,
									CMD_Download_RTCSpring

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "midi_obj.hpp"
#include "dx_map.hpp"
#include "sw_objec.hpp"
#include "ffd_swff.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"
#include "CritSec.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/

/****************************************************************************

   Declaration of variables

****************************************************************************/
//
// Globals specific to hau_midi
//
#ifdef _DEBUG
extern char g_cMsg[160];
#endif

//
// --- EFFECT_CMDs
//

// *** ---------------------------------------------------------------------***
// Function:   	CMD_SetIndex
// Purpose:    	Sets the autoincrementing Index for MODIFY_CMD
// Parameters: 
//				IN int nIndex			- Index value 0 - 15
//				IN DNHANDLE DnloadID	- Effect ID in stick
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= EFFECT_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= SET_INDEX+index	 	0   1   i   i   i   i   0   0
//  Byte 2	= EffectID (7 bits)		0   E   E   E   E   E   E   E
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_SetIndex( 
	IN int nIndex,
	IN DNHANDLE DnloadID)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

// *** ---------------------------------------------------------------------***
// Function:   	CMD_ModifyParam
// Purpose:    	Modifies an Effect parameter
// Parameters: 
//				IN WORD dwNewParam		- 14 bit (signed) parameter value
//
// Returns:    	SUCCESS if successful command sent, else
//				SFERR_INVALID_OBJECT
//				SFERR_NO_SUPPORT
//				SFERR_INVALID_PARAM
// Algorithm:
//
// Comments:   	
//  Byte 0	= MODIFY_CMD + Channel #
//									D7  D6  D5  D4  D3  D2  D1  D0
//									--  --  --  --  --  --  --  --
//  Byte 1	= Low 7 bits data	 	0   v   v   v   v   v   v   v
//  Byte 2	= High 7 bits data		0   v   v   v   v   v   v   v
//
// *** ---------------------------------------------------------------------***
HRESULT CMD_ModifyParam( 
	IN WORD wNewParam)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
/*
	HRESULT hRet;
	BYTE cByte1, cByte2;
	cByte1 = wNewParam & 0x7f;
	cByte2 = (BYTE) ((wNewParam >> 7) & 0x7f);
	hRet = g_pJoltMidi->MidiSendShortMsg(MODIFY_CMD, cByte1, cByte2);
	
	if (SUCCESS != hRet) 
		return (g_pJoltMidi->LogError(SFERR_DRIVER_ERROR,
					DRIVER_ERROR_MIDI_OUTPUT));

	// Note: ModifyParam used to not require an ACK/NACK
	ACKNACK AckNack = {sizeof(ACKNACK)};
//	hRet = g_pJoltMidi->GetAckNackData(SHORT_MSG_TIMEOUT, &AckNack);
	hRet = g_pJoltMidi->GetAckNackData(FALSE, &AckNack, g_ForceFeedbackDevice.GetAckNackMethod(REGBITS_MODIFYPARAM));
	// :
	if (SUCCESS != hRet) return (SFERR_DRIVER_ERROR);
	if (ACK != AckNack.dwAckNack)
		return (g_pJoltMidi->LogError(SFERR_DEVICE_NACK, AckNack.dwErrorCode));
	return (hRet);
*/
}



//
// --- SYSTEM_CMDs
//

//
// --- System Exclusive Commands
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\ffeature.cpp ===
//	@doc
/**********************************************************************
*
*	@module	ForceFeatures.cpp	|
*
*	Implements CForceFeatures to use msgame's HID features.
*
*	History
*	----------------------------------------------------------
*	Mitchell Dernis	Original
*
*	(c) 1986-1998 Microsoft Corporation. All right reserved.
*
*	@topic	ForceFeatures	|
*	CForceFeatures opens a handle to msgame in the context of
*	a particular device on construction.
*	The public members expose the feature interface for msgame.
*
*	Will work with NT5 as is.  For Win98 we need a different
*	scheme for getting HID path.  DI promises to fix somehow.
**********************************************************************///

#include <windows.h>
#define DIRECTINPUT_VERSION 0x050a
#include <dinput.h>
#include <dinputd.h>
extern "C" {
	#include <hidsdi.h>
}
#include "FFeature.h"

/***********************************************************************************
**
**	CForceFeatures::CForceFeatures(UINT uJoystickId)
**
**	@mfunc	C'tor gets Hid Path from Joystick and opens path to driver
**
**	@rdesc	None since this is c'tor.  However at the end of this routine
**			m_hDevice will contain a handle for the driver on success, or
**			will contain NULL on failure.  All routines will check the
**			value of m_hDevice before proceeding.
**
*************************************************************************************/
CForceFeatures::CForceFeatures() :
	m_hDevice(NULL)
{
}


/***********************************************************************************
**
**	CForceFeatures::~CForceFeatures()
**
**	@mfunc	D'tor closes handle to driver, if it was open
**
*************************************************************************************/
CForceFeatures::~CForceFeatures()
{
	if(m_hDevice)
	{
		CloseHandle(m_hDevice);
	}
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::Initialize(UINT uJoystickId, HINSTANCE hinstModule)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::Initialize
(
	UINT uJoystickId,		//@parm Joystick Id as used by winmm
	HINSTANCE hinstModule	//@parm Instance of the DLL for Creating DirectInput
)
{
	if (m_hDevice != NULL) {
		return S_OK;	// No need to reinitialize
	}

	HRESULT hr;
	
	//**
	//** Get HidPath
	//**  
	//**

	//
	//	Get IDirectInput interface	
	//
	IDirectInput *pDirectInput = NULL;
	IDirectInputJoyConfig *pDirectInputJoyConfig = NULL; 
	hr = DirectInputCreate(
			hinstModule,
			DIRECTINPUT_VERSION,
			&pDirectInput,
			NULL
			);
	if( FAILED(hr) ) return hr;

	//
	//	Get IDirectInputJoyConfig
	//
	hr=pDirectInput->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID *)&pDirectInputJoyConfig);
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}
	
	//
	//	GetConfig for JoyId
	//
	DIJOYCONFIG DiJoyConfig;
	DiJoyConfig.dwSize=sizeof(DIJOYCONFIG);
	hr = pDirectInputJoyConfig->GetConfig(
									uJoystickId,
									&DiJoyConfig,
									DIJC_GUIDINSTANCE
									);
	//
	//	Done with pDirectInputJoyConfig
	//
	pDirectInputJoyConfig->Release();
	pDirectInputJoyConfig = NULL;
	if( FAILED(hr) )
	{
		pDirectInput->Release();
		return hr;
	}

	//
	//  Get IDirectInputDevice interface
	//
	IDirectInputDevice *pDirectInputDevice;
	hr = pDirectInput->CreateDevice(DiJoyConfig.guidInstance, &pDirectInputDevice, NULL);
	//
	//	Done pDirectInput
	//
	pDirectInput->Release();
	pDirectInput = NULL;
	if( FAILED(hr) ) return hr;
	
	//
	//	Get HidPath
	//
	DIPROPGUIDANDPATH DiPropGuidAndPath;
	DiPropGuidAndPath.diph.dwSize = sizeof(DIPROPGUIDANDPATH);
	DiPropGuidAndPath.diph.dwHeaderSize = sizeof(DIPROPHEADER);
	DiPropGuidAndPath.diph.dwObj = 0;
	DiPropGuidAndPath.diph.dwHow = DIPH_DEVICE;
	hr=pDirectInputDevice->GetProperty( DIPROP_GUIDANDPATH, &DiPropGuidAndPath.diph);

	//
	//	Done with pDirectInputDevice
	//
	pDirectInputDevice->Release();
	pDirectInputDevice = NULL;
	if( FAILED(hr) ) return hr;

	//**
	//**	Open Path to Driver
	//**
	m_hDevice = CreateFileW(
		DiPropGuidAndPath.wszPath,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL
	);

	if (m_hDevice == INVALID_HANDLE_VALUE)
	{
		m_hDevice = NULL;
	}
	if (m_hDevice == NULL)
	{
		DWORD err = ::GetLastError();
		return E_FAIL;
	}

	PHIDP_PREPARSED_DATA pHidPreparsedData;
	if (HidD_GetPreparsedData(m_hDevice, &pHidPreparsedData) == FALSE)
	{
		::CloseHandle(m_hDevice);
		m_hDevice = NULL;
		return E_FAIL;
	}
	HIDP_CAPS hidpCaps;
	HidP_GetCaps(pHidPreparsedData, &hidpCaps);
	m_uiMaxFeatureLength = hidpCaps.FeatureReportByteLength;
	HidD_FreePreparsedData(pHidPreparsedData);
	
	//
	//	On success, m_hDevice now contains a handle to the device
	//
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetId(PRODUCT_ID_REPORT& rProductId)
**
**	@mfunc	Calls to MsGame to GetId using MSGAME_FEATURE_GETID
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetId
(
	PRODUCT_ID_REPORT& rProductId	// @parm Reference to PRODUCT_ID_REPORT to get from driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}

	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rProductId.bReportId = MSGAME_FEATURE_GETID;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rProductId), m_uiMaxFeatureLength);

//	 -- HIDPI.H
//	 HIDP_GetData(Report Type, Data, Lenght, Preparse Data, Report, ReportLength);

	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}


/***********************************************************************************
**
**	HRESULT CForceFeatures::GetStatus(JOYCHANNELSTATUS_REPORT& rJoyChannelStatus)
**
**	@mfunc	Get the JoyChannel Status from msgame's MSGAME_FEATURE_GETSTATUS
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetStatus
(
	JOYCHANNELSTATUS_REPORT& rJoyChannelStatus	// @parm Reference to JOYCHANNELSTATUS_REPORT to be filled by driver
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rJoyChannelStatus.bReportId = MSGAME_FEATURE_GETSTATUS;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rJoyChannelStatus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
		DWORD err = GetLastError();
		return HRESULT_FROM_WIN32(err);
//	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetAckNak(ULONG_REPORT& rulAckNak)
**
**	@mfunc	Returns an AckNak by using msgame's GetAckNak Featue
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetAckNak
(
	ULONG_REPORT& rulAckNak	// @parm REFERENCE to ULONG_REPORT to be filled by driver with AckNak
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulAckNak.bReportId = MSGAME_FEATURE_GETACKNAK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulAckNak), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::GetNackAck(ULONG_REPORT& rulNakAck)
**
**	@mfunc	Returns an AckNak by using msgame's MSGAME_FEATURE_NAKACK
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetNakAck(
	ULONG_REPORT& rulNakAck	// @parm REFERENCE to ULONG_REPORT to be filled by driver with NakAck
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulNakAck.bReportId = MSGAME_FEATURE_GETNAKACK;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulNakAck), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
/***********************************************************************************
**
**	HRESULT CForceFeatures::GetSync(ULONG_REPORT& rulGameport)
**
**	@mfunc	Get Sync information from MSGAME's MSGAME_FEATURE_GETSYNC
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::GetSync
(
	ULONG_REPORT& rulGameport	// @parm REFERENCE to ULONG_REPORT to be filled by driver with Gameport
)
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	rulGameport.bReportId = MSGAME_FEATURE_GETSYNC;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&rulGameport), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return HRESULT_FROM_WIN32(GetLastError());
	}
	return S_OK;
}

/***********************************************************************************
**
**	HRESULT CForceFeatures::DoReset()
**
**	@mfunc	Does Reset via MSGAME's MSGAME_FEATURE_DORESET
**
**	@rdesc	S_OK on success 
**			ERROR_OPEN_FAILED if no drive connection
**			E_FAIL for other problems
**
*************************************************************************************/
HRESULT CForceFeatures::DoReset()
{
	if(!m_hDevice)
	{
		return HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
	}
	
	BOOLEAN fSuccess;
	//
	//	Fill in ReportID for feature
	//
	ULONG_REPORT ulBogus;
	ulBogus.bReportId = MSGAME_FEATURE_DORESET;
		
	//
	//	Call Get Feature on driver
	//
	fSuccess = HidD_GetFeature(m_hDevice, reinterpret_cast<PVOID>(&ulBogus), m_uiMaxFeatureLength);
	
	//
	// Return proper error code
	//
	if( !fSuccess )
	{
	 return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\joyregst.cpp ===
/****************************************************************************

    MODULE:     	joyregst.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for VJOYD Registry entries
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	0.1			20-Jun-96	MEA     original
				21-Mar-99	waltw	Removed unreferenced joyGetOEMProductName,
									joyGetOEMForceFeedbackDriverDLLName,
									GetRing0DriverName

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>
#include <stdio.h>
#include <TCHAR.h>
#include "joyregst.hpp"
#include "sw_error.hpp"
#include "Registry.h"
#include "FFDevice.h"

#ifdef _DEBUG
extern char g_cMsg[160];
#endif

//#define ACKNACK_1_16_DEFAULT 0x0000949A
#define ACKNACK_1_16_DEFAULT 0x0000955A
#define ACKNACK_1_20_DEFAULT 0x0000955A
#define ACKNACK_2_00_DEFAULT 0x0000955A

// Default RTC Spring values
#define RTC_DEF_OFFSET 0
#define RTC_DEF_POS_K 10000
#define RTC_DEF_NEG_K 10000
#define RTC_DEF_POS_SAT 10000
#define RTC_DEF_NEG_SAT 10000
#define RTC_DEF_DEADBAND 0



MMRESULT joyGetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN OUT ULONG *pCOMMInterface,
			IN OUT ULONG *pCOMMPort)
{

	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);

	DWORD dataSize = sizeof(DWORD);
	RegistryKey oemFFKey(hOEMForceFeedbackKey);
	oemFFKey.ShouldClose(TRUE);		// Close Key on destruction
	oemFFKey.QueryValue(REGSTR_VAL_COMM_INTERFACE, (BYTE*)(pCOMMInterface), dataSize);
	MMRESULT lr = oemFFKey.QueryValue(REGSTR_VAL_COMM_PORT, (BYTE*)(pCOMMPort), dataSize);

	return lr;
}

MMRESULT joySetForceFeedbackCOMMInterface(
			IN UINT id, 
			IN ULONG ulCOMMInterface,
			IN ULONG ulCOMMPort)
{
	HKEY hOEMForceFeedbackKey = joyOpenOEMForceFeedbackKey(id);

	RegistryKey oemFFKey(hOEMForceFeedbackKey);
	oemFFKey.ShouldClose(TRUE);		// Close Key on destruction
	oemFFKey.SetValue(REGSTR_VAL_COMM_INTERFACE, (BYTE*)(&ulCOMMInterface), sizeof(DWORD), REG_DWORD);
	MMRESULT lr = oemFFKey.SetValue(REGSTR_VAL_COMM_PORT, (BYTE*)(&ulCOMMPort), sizeof(DWORD), REG_DWORD);

	return lr;
}


HKEY joyOpenOEMForceFeedbackKey(UINT id)
{
	JOYCAPS JoyCaps;
	TCHAR szKey[256];
	TCHAR szValue[256];
	UCHAR szOEMKey[256];

	HKEY hKey;
	DWORD dwcb;
	LONG lr;

// Note: JOYSTICKID1-16 is zero-based, Registry entries for VJOYD is 1-based.
	id++;		
	if (id > joyGetNumDevs() ) return 0;

// open .. MediaResources\CurentJoystickSettings
	joyGetDevCaps((id-1), &JoyCaps, sizeof(JoyCaps));
//
#ifdef _NOJOY
	strcpy(JoyCaps.szRegKey,"msjstick.drv<0004>");
#endif
//
//
	sprintf(szKey,
			"%s\\%s\\%s",
			REGSTR_PATH_JOYCONFIG,
			JoyCaps.szRegKey,
			REGSTR_KEY_JOYCURR);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPTSTR) &szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) return 0;

// Get OEM Key name
	dwcb = sizeof(szOEMKey);
 	sprintf(szValue, "Joystick%d%s", id, REGSTR_VAL_JOYOEMNAME);
	lr = RegQueryValueEx(hKey, szValue, 0, 0, (LPBYTE) &szOEMKey, (LPDWORD) &dwcb);
	RegCloseKey(hKey);
	if (lr != ERROR_SUCCESS) return 0;

// open OEM\name\OEMForceFeedback	from ...MediaProperties
	sprintf(szKey, "%s\\%s\\%s", REGSTR_PATH_JOYOEM, szOEMKey, 
			REGSTR_OEMFORCEFEEDBACK);
	lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), &hKey);
	if (lr != ERROR_SUCCESS) 
		return 0;
	else
		return hKey;
}


/******************************************************
**
** GetRTCSpringData(UINT id, DICONDITION diCondition[2])
**
** @funct GetRTCSpringData.
**
******************************************************/
MMRESULT GetRTCSpringData(UINT id, DICONDITION diCondition[2])
{
	::memset(diCondition, 0, sizeof(DICONDITION) * 2);

	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}
	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);
	DWORD diCondSize = sizeof(DICONDITION);
	HRESULT queryResult = ffRegKey.QueryValue(REGSTR_VAL_RTCSPRING_X, (BYTE*)diCondition, diCondSize);
	if (queryResult != ERROR_SUCCESS) {			// Must at least have RTC-X
		diCondition[0].lOffset = RTC_DEF_OFFSET;
		diCondition[0].lPositiveCoefficient = RTC_DEF_POS_K;
		diCondition[0].lNegativeCoefficient = RTC_DEF_NEG_K;
		diCondition[0].dwPositiveSaturation = RTC_DEF_POS_SAT;
		diCondition[0].dwNegativeSaturation = RTC_DEF_NEG_SAT;
		diCondition[0].lDeadBand = RTC_DEF_DEADBAND;
		ffRegKey.SetValue(REGSTR_VAL_RTCSPRING_X, (BYTE*)diCondition, sizeof(DICONDITION), REG_BINARY);
	}
	diCondSize = sizeof(DICONDITION);
	ffRegKey.QueryValue(REGSTR_VAL_RTCSPRING_Y, (BYTE*)(diCondition+1), diCondSize);
	// If there is no Y, then there is no Y, live with it (zep doesn't need y)

	return ERROR_SUCCESS;
}

/******************************************************
**
** GetMapping(UINT id)
**
** @funct GetMapping.
**
******************************************************/
DWORD GetMapping(UINT id)
{
	DWORD retVal = 0;
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return retVal;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);
	DWORD dataSize = DWORD(sizeof(DWORD));
	if (ffRegKey.QueryValue(REGSTR_VAL_MAPPING, (BYTE*)&retVal, dataSize) != ERROR_SUCCESS) {
		retVal = 0;
		if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() > 1) {	// Don't add key for old devices
			ffRegKey.SetValue(REGSTR_VAL_MAPPING, (BYTE*)&retVal, sizeof(DWORD), REG_DWORD);
		}
	}
	return retVal;
}

/******************************************************
**
** GetMappingPercents(UINT id, short mapPercents[], UINT numPercents)
**
** @funct GetMappingPercents.
**
******************************************************/
MMRESULT GetMappingPercents(UINT id, short mapPercents[], UINT numPercents)
{
	DWORD retVal = 0;
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return retVal;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);
	DWORD dataSize = DWORD(sizeof(short) * numPercents);
	return ffRegKey.QueryValue(REGSTR_VAL_MAPPERCENTS, (BYTE*)mapPercents, dataSize);
}

/******************************************************
**
** GetAckNackMethodFromRegistry(UINT id)
**
** @mfunct GetAckNackMethodFromRegistry.
**
******************************************************/
DWORD GetAckNackMethodFromRegistry(UINT id)
{
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);

	DWORD ackNackInfo = 0;
	TCHAR firmwareString[32] = "";
	::wsprintf(firmwareString, TEXT("%d.%d-AckNack"), g_ForceFeedbackDevice.GetFirmwareVersionMajor(), g_ForceFeedbackDevice.GetFirmwareVersionMinor());
	DWORD querySize = sizeof(DWORD);
	HRESULT queryResult = ffRegKey.QueryValue(firmwareString, (BYTE*)&ackNackInfo, querySize);
	if ((queryResult != ERROR_SUCCESS)) {
		if (g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) {
			if (g_ForceFeedbackDevice.GetFirmwareVersionMinor() < 20) {
				ackNackInfo = ACKNACK_1_16_DEFAULT;
			} else {	// 1.20 and greater
				ackNackInfo = ACKNACK_1_20_DEFAULT;
			}
		} else {	// Firmware greater than 1.0
			ackNackInfo = ACKNACK_2_00_DEFAULT;	// Use the latest I know of
		}
		ffRegKey.SetValue(firmwareString, (BYTE*)&ackNackInfo, sizeof(DWORD), REG_DWORD);
	}

	return ackNackInfo;
}

/******************************************************
**
** GetSpringOffsetFromRegistry(UINT id)
**
** @mfunct GetSpringOffsetFromRegistry.
**
******************************************************/
DWORD GetSpringOffsetFromRegistry(UINT id)
{
	HKEY forceFeedbackKey = joyOpenOEMForceFeedbackKey(id);
	if (forceFeedbackKey == 0) {
		return JOYERR_NOCANDO;
	}

	RegistryKey ffRegKey(forceFeedbackKey);
	ffRegKey.ShouldClose(TRUE);

	DWORD offset = 2500;
	DWORD querySize = sizeof(DWORD);
	HRESULT queryResult = ffRegKey.QueryValue(REGSTR_VAL_SPRING_OFFSET, (BYTE*)&offset, querySize);
	if ((queryResult != ERROR_SUCCESS)) {
		offset = 2500;
		ffRegKey.SetValue(REGSTR_VAL_SPRING_OFFSET, (BYTE*)&offset, sizeof(DWORD), REG_DWORD);
	}

	return offset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\joyregst.hpp ===
/****************************************************************************

    MODULE:     	joyregst.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for VJOYD Registry functions
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original
			21-Mar-99		waltw	Removed unreferenced joyGetOEMProductName,
									joyGetOEMForceFeedbackDriverDLLName,
									GetRing0DriverName

****************************************************************************/
#ifndef joyregst_SEEN
#define joyregst_SEEN

#include <dinput.h>

#define REGSTR_OEMFORCEFEEDBACK 		        "OEMForceFeedback"
#define REGSTR_VAL_SFORCE_DRIVERDLL		        "Driver DLL"
#define REGSTR_VAL_SFORCE_PRODUCTNAME		    "ProductName"
#define REGSTR_VAL_SFORCE_MANUFACTURERNAME	    "Manufacturer"
#define REGSTR_VAL_SFORCE_PRODUCTVERSION	    "ProductVersion"
#define REGSTR_VAL_SFORCE_DEVICEDRIVERVERSION	"DeviceDriverVersion"
#define REGSTR_VAL_SFORCE_DEVICEFIRMWAREVERSION "DeviceFirmwareVersion"
#define REGSTR_VAL_SFORCE_INTERFACE		        "Interface"
#define REGSTR_VAL_SFORCE_MAXSAMPLERATE	        "MaxSampleRate"
#define REGSTR_VAL_SFORCE_MAXMEMORY		        "MaxMemory"
#define REGSTR_VAL_SFORCE_NUMBEROFSENSORS       "NumberOfSensors"
#define REGSTR_VAL_SFORCE_NUMBEROFAXES          "NumberOfAxes"
#define REGSTR_VAL_SFORCE_EFFECTSCAPS		    "EffectsCaps"
#define REGSTR_VAL_SFORCE_EXTRAINFO		        "ExtraInfo"
#define REGSTR_VAL_COMM_INTERFACE		        "COMMInterface"
#define REGSTR_VAL_COMM_PORT		        	"COMMPort"
#define REGSTR_VAL_RING0_DRIVER					"RING0 Driver"
#define REGSTR_VAL_RTCSPRING_X					"RTCSpringX"
#define REGSTR_VAL_RTCSPRING_Y					"RTCSpringY"
#define REGSTR_VAL_MAPPING						"Mapping"
#define REGSTR_VAL_MAPPERCENTS					"Mapping Percents"
#define REGSTR_VAL_SPRING_OFFSET				"Spring Offset"

HKEY		joyOpenOEMForceFeedbackKey(UINT id);
MMRESULT	joyGetForceFeedbackCOMMInterface(UINT id, ULONG* ulArg1, ULONG* ulArg2);
MMRESULT	joySetForceFeedbackCOMMInterface(UINT id, ULONG ulCOMMInterface, ULONG ulCOMMPort);
MMRESULT	GetRTCSpringData(UINT id, DICONDITION diCondition[2]);
DWORD		GetMapping(UINT id);
UINT		GetMappingPercents(UINT id, short mapPercents[], UINT numPercents);
DWORD		GetAckNackMethodFromRegistry(UINT id);
DWORD		GetSpringOffsetFromRegistry(UINT id);


#define REGBITS_DESTROYEFFECT	14
#define REGBITS_PLAYEFFECT		12
#define REGBITS_STOPEFFECT		10
#define REGBITS_SETINDEX		8
#define REGBITS_MODIFYPARAM		6
#define REGBITS_SETDEVICESTATE	4
#define REGBITS_DOWNLOADEFFECT	2
#define REGBITS_DEVICEINIT		0

#define ACKNACK_NOTHING			0x00
#define ACKNACK_BUTTONSTATUS	0x01
#define ACKNACK_STATUSPACKET	0x02

#endif // of if joyregst_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\hau_midi.hpp ===
/****************************************************************************

    MODULE:     	HAU_MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for HAU_MIDI.CPP


	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
			21-Mar-99		waltw	Removed unreferenced ModifyEnvelopeParams,
									ModifyEffectParams, MapEnvelope, CMD_ModifyParamByIndex,
									CMD_Download_RTCSpring

****************************************************************************/
#ifndef _HAU_MIDI_SEEN
#define _HAU_MIDI_SEEN
#include "DX_MAP.hpp"

#define MAX_EFFECT_IDS				32
#define	NEW_EFFECT_ID				0x7f
#define SYSTEM_EFFECT_ID			0x7f
#define SYSTEM_RTCSPRING_ID			0
#define SYSTEM_FRICTIONCANCEL_ID	1
#define SYSTEM_RTCSPRING_ALIAS_ID	0x7e	// Due to internal ID=0 means create new

#define MAX_MIDI_CHANNEL		16
#define DEFAULT_MIDI_CHANNEL	5
#define DEFAULT_MIDI_PORTIO		0x330

#define COMM_WINMM					0x01
#define COMM_MIDI_BACKDOOR			0x02
#define COMM_SERIAL_BACKDOOR		0x03
#define COMM_SERIAL_FILE			0x04
#define MASK_OVERRIDE_MIDI_PATH		0x80000000
#define MASK_SERIAL_BACKDOOR		0x40000000
#define COMM_SERIAL1			1			// COMM Port 1
#define MIN_COMMSERIAL			1
#define MAX_COMMSERIAL			4

#define DEFAULT_JOLT_FORCE_RATE	100
#define DEFAULT_PERCENT			10000

#define MAX_SYS_EX_BUFFER_SIZE	1024		// Maximum Primary buffer size
#define DIFFERENCE_THRESHOLD	32			// Threshold to using absolute data
#define DIFFERENCE_BIT			0x40		// Bit to set for Difference data
#define MAX_MIDI_WAVEFORM_PACKET_SIZE	(256-20)	// Midi SYS_EX packet size
#define MAX_MIDI_WAVEFORM_DATA_SIZE	100		// Midi SYS_EX Data sample window size
#define	MAX_PLIST_EFFECT_SIZE	8			// 8 effects in a PList
#define MAX_PLIST_EFFECT		8			// 8 PLists allowed

#define MAX_INDEX				15
#define MAX_SIZE_SNAME			64								

#define MS_MANUFACTURER_ID		0x0a01
#define JOLT_PRODUCT_ID			0x01         // REVIEW: Is this correct?

#define DRIVER_ERROR_NO_MIDI_INPUT	0x100	// No open Midi input device
#define DRIVER_ERROR_MIDI_OUTPUT	0x101	// Error outputing to Midi output


//
// --- RTC Spring defaults
//
#define	DEFAULT_RTC_KX		80
#define	DEFAULT_RTC_KY		80
#define	DEFAULT_RTC_X0		0
#define	DEFAULT_RTC_Y0		0
#define	DEFAULT_RTC_XSAT	96
#define	DEFAULT_RTC_YSAT	96
#define	DEFAULT_RTC_XDBAND	16
#define	DEFAULT_RTC_YDBAND	16

//
// --- Effect status code from Device
//
#define SWDEV_STS_EFFECT_STOPPED	0x01
#define SWDEV_STS_EFFECT_RUNNING	0x02

//
// --- Bitmasks for Device Status
//
#define BANDWIDTH_MASK			0x200		// Bandwidth bit
#define COMM_MODE_MASK			0x100		// 0 = MIDI, 1 = Serial
#define AC_FAULT_MASK			0x80		// 1= AC brick fault
#define HOTS_MASK				0x20		// Hands on Throttle Sensor
#define RESET_MASK				0x10		// 1 = Power On Reset detected
#define SHUTDOWN_MASK			0x08		// 0 = normal Shutdown, else 1 = Soft Reset

#define MINIMUM_BANDWIDTH		1
#define MAXIMUM_BANDWIDTH		100			// in %

//
// --- ERROR CODES from Device
//
#define DEV_ERR_SUCCESS			0x00	// Success
#define DEV_ERR_INVALID_ID		0x01	// Effect ID is invalid or not found
#define DEV_ERR_INVALID_PARAM	0x02	// Invalid parameter in data structure
#define DEV_ERR_CHECKSUM		0x03	// Invalid checksum
#define DEV_ERR_TYPE_FULL		0x04	// No more room for specified Effect
#define DEV_ERR_UNKNOWN_CMD		0x05	// Unrecognized command
#define DEV_ERR_PLAYLIST_FULL	0x06	// Play List is full, cannot play any
										// more effects
#define DEV_ERR_PROCESS_LIST_FULL 0x07	// Process List is full


//
// --- MIDI Command codes
//
#define MODIFY_CMD			0xA0
#define EFFECT_CMD	        0xB0
#define SYSTEM_CMD	        0xC0
#define STATUS_CMD			0xD0
#define RESPONSE_CMD	    0xE0		// Device to Host
#define SYS_EX_CMD			0xF0
#define ASSIGN_CMD	        0xF0
#define DNLOAD_CMD	        0xF0
#define UPLOAD_CMD	        0xF0
#define PROCESS_CMD	        0xF0
#define MIDI_EOX			0xF7

//
// --- Second byte sub-commands
//
// --- MIDI_CMD_EFFECT second byte sub-command
#define	NO_OVERRIDE         	0x00
#define DESTINATION_X			0x01
#define DESTINATION_Y			0x02
#define DESTINATION_XY			0x03
#define	PUT_FORCE_X				0x01
#define	PUT_FORCE_Y				0x02
#define	PUT_FORCE_XY			0x03
#define PLAY_EFFECT_SOLO		0x00
#define DESTROY_EFFECT			0x10	
#define	PLAY_EFFECT_SUPERIMPOSE	0x20
#define	STOP_EFFECT				0x30
#define SET_INDEX				0x40


// --- MIDI_CMD_SYSTEM second byte sub-command
#define SWDEV_SHUTDOWN	1L		// All Effects destroyed, Motors disabled
#define SWDEV_FORCE_ON	2L		// Motors enabled.  "Un-Mute"
#define SWDEV_FORCE_OFF	3L		// Motors disabled.	"Mute"
#define SWDEV_CONTINUE	4L		// All "Paused" Effects are allow to continue
#define SWDEV_PAUSE		5L		// All Effects are "Paused"
#define SWDEV_STOP_ALL	6L		// Stops all Effects.
#define SWDEV_KILL_MIDI	7L		// Kills (tri-states) MIDI

// Remap for dinput modes
#define DEV_RESET       SWDEV_SHUTDOWN
#define DEV_FORCE_ON    SWDEV_FORCE_ON
#define DEV_FORCE_OFF   SWDEV_FORCE_OFF
#define DEV_CONTINUE    SWDEV_CONTINUE
#define DEV_PAUSE       SWDEV_PAUSE
#define DEV_STOP_ALL    SWDEV_STOP_ALL

//
// --- ACK and NACK 2nd byte from RESPONSE_CMD
//
#define ACK                 0x00
#define NACK                0x7f
#define ACKNACK_TIMEOUT		50			// 50*1msec timeout = 50msecs
#define ACKNACK_EFFECT_STATUS_TIMEOUT 1	// 1ms Timeout
#define MAX_RETRY_COUNT		10			// Retry count for comm NACKS
//#define MAX_GET_STATUS_PACKET_RETRY_COUNT 30
#define MAX_GET_STATUS_PACKET_RETRY_COUNT 10
#define SHORT_MSG_TIMEOUT	1
#define LONG_MSG_TIMEOUT	2
#define POWER_ON_MSG		0x007F00E5UL
#define RESPONSE_NACK		0x007FE0UL	// Example for MIDI channel 0.
#define RESPONSE_ACK		0x0000E0UL	// " "

// timing delays, in mS
/*
#define DEFAULT_SHORT_MSG_DELAY				1
#define DEFAULT_LONG_MSG_DELAY				1
#define DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY	1
#define DEFAULT_SHUTDOWN_DELAY				10
#define DEFAULT_HWRESET_DELAY				20		
#define DEFAULT_POST_SET_DEVICE_STATE_DELAY	1
#define DEFAULT_GET_EFFECT_STATUS_DELAY		1
#define DEFAULT_GET_DATA_PACKET_DELAY		1
#define DEFAULT_GET_STATUS_PACKET_DELAY		0
#define DEFAULT_GET_ID_PACKET_DELAY			1
#define DEFAULT_GET_STATUS_GATE_DATA_DELAY	0
#define DEFAULT_SET_INDEX_DELAY				0
#define DEFAULT_MODIFY_PARAM_DELAY			0
#define DEFAULT_FORCE_OUT_DELAY				1
#define DEFAULT_DESTROY_EFFECT_DELAY		1
#define DEFAULT_FORCE_OUT_MOD				1
*/
// Changes of above for Zep
#define DEFAULT_SHORT_MSG_DELAY	0
#define DEFAULT_LONG_MSG_DELAY	0
#define DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY	0
#define DEFAULT_SHUTDOWN_DELAY	0
#define DEFAULT_HWRESET_DELAY 0
#define DEFAULT_POST_SET_DEVICE_STATE_DELAY	0
#define DEFAULT_GET_EFFECT_STATUS_DELAY		0
#define DEFAULT_GET_DATA_PACKET_DELAY		0
#define DEFAULT_GET_STATUS_PACKET_DELAY		0
#define DEFAULT_GET_ID_PACKET_DELAY			0
#define DEFAULT_GET_STATUS_GATE_DATA_DELAY	0
#define DEFAULT_SET_INDEX_DELAY				0
#define DEFAULT_MODIFY_PARAM_DELAY		0
#define DEFAULT_FORCE_OUT_DELAY		0
#define DEFAULT_DESTROY_EFFECT_DELAY	0
#define DEFAULT_FORCE_OUT_MOD	0

typedef struct _DELAY_PARAMS
{
	DWORD	dwBytes;
	DWORD	dwDigitalOverdrivePrechargeCmdDelay;
	DWORD	dwShutdownDelay;
	DWORD	dwHWResetDelay;
	DWORD	dwPostSetDeviceStateDelay;
	DWORD	dwGetEffectStatusDelay;
	DWORD	dwGetDataPacketDelay;
	DWORD	dwGetStatusPacketDelay;
	DWORD	dwGetIDPacketDelay;
	DWORD	dwGetStatusGateDataDelay;
	DWORD	dwSetIndexDelay;
	DWORD	dwModifyParamDelay;
	DWORD	dwForceOutDelay;
	DWORD	dwShortMsgDelay;
	DWORD	dwLongMsgDelay;
	DWORD	dwDestroyEffectDelay;
	DWORD	dwForceOutMod;
} DELAY_PARAMS, *PDELAY_PARAMS;

void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams);

//
// --- Format of Download command
//     Bytes in SYS EX body (starting from Byte 5 to (n-1)
//
// Byte     Contents
// -----    ---------
//  0       bOpCode			- see detail on OPCODE below
//  1       bSubType		- e.g. ET_UD_WAVEFORM, etc.
//	2		bEffectID		- Effect ID, 0x7f = Create New
//  3       bDurationL		- Low 7 bits duration in 2ms ticks, 0=Forever
//  4       bDurationH		- High 7 bits

//  5       bAngleL			- Low 7 bits Direction Angle
//  7	    bAngleH			- High 2 bits Direction Angle
//	8		bGain			- 7 bits Gain 1 - 100%
//	9		bButtonPlayL	- Low 7 bits button mask
//	10		bButtonPlayH	- High 2 bits button mask
//	11		bForceOutRateL	- Low 7 bits, 1 to 500 Hz
//	12		bForceOutRateH	- High 2 bits
//	13		bLoopCountL		- Low 7 bits Loop Count, Normally 1
//  14      bLoopCountH		- High 7 bits Loop count
//  		
//
//  The next block is optional and starts at Byte 15
//	15		bAttack			- %tage
//	16		bSustain;		- %tage
//  17 		bDecay;			- %tage
//
//  Otherwise, Type specific Parameters start at either Byte 15 or 18
//	18		Type specific parameter bytes here
//	
//
//  ...
//  n       7 bits Checksum of bytes 0 to n
//
//
//
// --- MIDI_CMD_ASSIGN, MIDI_CMD_DNLOAD, MIDI_CMD_PROCESS
//     second byte sub-command
// Opcode is defined as follows:
// 7  6  5  4  3  2  1  0
// -  -  -  -  -  -  -  -
// 0  c  c  c  a  a  d  d
//
// where:
//    c  c  c
//    -  -  -
//    0  0  0	- EXTEND_ESCAPE
//	  0  0  1	- MIDI_ASSIGN
//	  0  1  0	- DNLOAD_DATA
//	  0  1  1	- UPLOAD_DATA
//	  1  0  0	- PROCESS_DATA
//	  1  0  1	- reserved
//	  1  1  0	- reserved
//	  1  1  1	- reserved
//
// and:
//             a  a
//             -  -
//             0  0 - DL_PLAY_STORE only after download
//             0  1 - DL_PLAY_SUPERIMPOSE right after download
//             1  0 - DL_PLAY_SOLO right after download
//			   1  1 - reserved
// and:
//		             d  d
//					 -  -
//					 0  0	- reserved
//					 0  1	- X-Axis
//					 1  0	- Y-Axis
//					 1  1	- X and Y-Axis
//

#define EXTEND_ESCAPE		0x00
#define MIDI_ASSIGN			0x10
#define DNLOAD_DATA			0x20
#define UPLOAD_DATA			0x30
#define PROCESS_DATA		0x40
#define GET_FORCE_EFFECT_VALUE	0x50

// --- Download sub-commands
//
#define DL_PLAY_STORE       0x00
#define DL_PLAY_SUPERIMPOSE 0x04
#define DL_PLAY_SOLO        0x08

//
// --- Process List sub-commands
//
#define PLIST_CONCATENATE      0x01 //0x11	// Temp. s/b 0x01
#define PLIST_SUPERIMPOSE      0x02 //0x12 // Temp. s/b 0x02


//
// --- Special UD_EFFECT parameters
//
#define UD_DIFFERENCE_DATA  0x40


//
// --- Bitmap Indexes into Parameter storage array
//
#define	INDEX0_MASK	 0x00000001L
#define INDEX1_MASK	 0x00000002L
#define INDEX2_MASK	 0x00000004L
#define INDEX3_MASK	 0x00000008L
#define INDEX4_MASK	 0x00000010L
#define INDEX5_MASK	 0x00000020L
#define	INDEX6_MASK	 0x00000040L
#define INDEX7_MASK	 0x00000080L
#define INDEX8_MASK	 0x00000100L
#define INDEX9_MASK	 0x00000200L
#define INDEX10_MASK 0x00000400L
#define INDEX11_MASK 0x00000800L
#define INDEX12_MASK 0x00001000L
#define INDEX13_MASK 0x00002000L
#define INDEX14_MASK 0x00004000L
#define INDEX15_MASK 0x00008000L

#define INDEX_DURATION 0
#define INDEX_TRIGGERBUTTONMASK 1
#define INDEX_X_COEEFICIENT 2
#define INDEX_Y_COEEFICIENT 3
#define INDEX_X_CENTER 4
#define INDEX_Y_CENTER 5

// Indexes for 1XX RTCSpring Parms
#define INDEX_RTC_COEEFICIENT_X (BYTE)0
#define INDEX_RTC_COEEFICIENT_Y (BYTE)1
#define INDEX_RTC_CENTER_X		(BYTE)2
#define INDEX_RTC_CENTER_Y		(BYTE)3
#define INDEX_RTC_SATURATION_X	(BYTE)4
#define INDEX_RTC_SATURATION_Y	(BYTE)5
#define INDEX_RTC_DEADBAND_X	(BYTE)6
#define INDEX_RTC_DEADBAND_Y	(BYTE)7

#define	INDEX0	(BYTE)0
#define INDEX1	(BYTE)1
#define INDEX2	(BYTE)2
#define INDEX3	(BYTE)3
#define INDEX4	(BYTE)4
#define INDEX5	(BYTE)5
#define	INDEX6	(BYTE)6
#define INDEX7	(BYTE)7
#define INDEX8	(BYTE)8
#define INDEX9	(BYTE)9
#define INDEX10 (BYTE)10
#define INDEX11 (BYTE)11
#define INDEX12 (BYTE)12
#define INDEX13 (BYTE)13
#define INDEX14 (BYTE)14
#define INDEX15 (BYTE)15

	
//
// --- Effect types
//

#define ET_UD_WAVEFORM      	1   // User Defined Waveform

#define ET_SE_SINE				2	// Sinusoidal
#define ET_SE_COSINE			3	// Cosine
#define ET_SE_SQUARELOW			4	// Square starting Low	
#define ET_SE_SQUAREHIGH		5	// Square starting High	
#define ET_SE_RAMPUP        	6   // Ramp UP			
#define ET_SE_RAMPDOWN      	7   // Ramp Down		
#define	ET_SE_TRIANGLEUP    	8	// Triangle rising	
#define ET_SE_TRIANGLEDOWN		9	// Triangle falling
#define ET_SE_SAWTOOTHUP		10	// Sawtooth rising
#define ET_SE_SAWTOOTHDOWN		11	// Sawtooth falling

#define ET_BE_DELAY				12  // NOP delay
#define ET_BE_SPRING        	13  // Springs
#define ET_BE_DAMPER        	14  // Dampers
#define ET_BE_INERTIA       	15  // Gravity
#define ET_BE_FRICTION      	16  // Friction
#define ET_BE_WALL 				17 	// Wall (bumper)
#define ET_SE_CONSTANT_FORCE	18	// Constant Force

#define ET_PL_CONCATENATE		19	// Concatenate process list
#define ET_PL_SUPERIMPOSE		20	// Superimpose process list

// ROM Effect IDS
#define ET_RE_ROMID1			32
#define ET_RE_ROMID2			33
#define ET_RE_ROMID3			34
#define ET_RE_ROMID4			35
#define ET_RE_ROMID5			36
#define ET_RE_ROMID6			37
#define ET_RE_ROMID7			38
#define ET_RE_ROMID8			39
#define ET_RE_ROMID9			40
#define ET_RE_ROMID10			41
#define ET_RE_ROMID11			42
#define ET_RE_ROMID12			43
#define ET_RE_ROMID13			44
#define ET_RE_ROMID14			45
#define ET_RE_ROMID15			46
#define ET_RE_ROMID16			47
#define ET_RE_ROMID17			48
#define ET_RE_ROMID18			49
#define ET_RE_ROMID19			50
#define ET_RE_ROMID20			51
#define ET_RE_ROMID21			52
#define ET_RE_ROMID22			53
#define ET_RE_ROMID23			54
#define ET_RE_ROMID24			55
#define ET_RE_ROMID25			56
#define ET_RE_ROMID26			57
#define ET_RE_ROMID27			58
#define ET_RE_ROMID28			59
#define ET_RE_ROMID29			60
#define ET_RE_ROMID30			61
#define ET_RE_ROMID31			62
#define ET_RE_ROMID32			63
#define ET_RE_ROMID33			64
#define ET_RE_ROMID34			65
#define ET_RE_ROMID35			66
#define ET_RE_ROMID36			67
#define ET_RE_ROMID37			68

 								
// more to be defined....		

//
// Effect IDs as defined in Jolt device
//
#define	EFFECT_ID_RTC_SPRING		0	// Built-in Return To Center Virtual Spring
#define	EFFECT_ID_FRICTIONCANCEL	1	// Friction cancellation


//
// --- Process List Structure
//
typedef struct _PLIST {
	ULONG	ulNumEffects;
	ULONG	ulProcessMode;	// PLIST_SUPERIMPOSE or PLIST_CONCATENATE
	PDNHANDLE pEffectArray;	// Effect ID[0} . . .
	ULONG	ulAction;
	ULONG	ulDuration;
} PLIST, *PPLIST;

//
// --- Behavioral Effects Structure
//
typedef struct _BE_XXX {
	LONG	m_XConstant;	//(KX/BX/MX/FX/Wall type)	
	LONG	m_YConstant;	//(KY/BY/MY/FY/KWall)
	LONG	m_Param3;		//(CX/VX/AX/Wall angle)
	LONG	m_Param4;		//(CY/VYO/AY/Wall distance)
} BE_XXX, *PBE_XXX;

//
// --- SysEx Messages
//
typedef struct _SYS_EX_HDR {
	BYTE		m_bSysExCmd;	// SysEx Fx command
	BYTE		m_bEscManufID;	// Escape to long Manufac. ID, s/b 0
	BYTE		m_bManufIDL;	// Low byte
	BYTE		m_bManufIDH;	// High byte
	BYTE		m_bProdID;		// Product ID
} SYS_EX_HDR, *PSYS_EX_HDR;

// --- Common Effect parameters
typedef struct _MIDI_EFFECT {
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bAngleL;		// Low 7 bits Direction Angle
	BYTE		bAngleH;		// High 2 bits Direction Angle
	BYTE		bGain;			// 7 bits Gain 1 - 100%
	BYTE		bForceOutRateL;	// Low 7 bits, 1 to 500 Hz
	BYTE		bForceOutRateH;	// High 2 bits
	BYTE		bPercentL;		// Low 7 bits Percent of waveform 1 to 10000
	BYTE		bPercentH;		// High 7 bits Loop Count
} MIDI_EFFECT, *PMIDI_EFFECT;

// --- Envelope
typedef struct MIDI_ENVELOPE {
	BYTE		bAttackLevel;	// Initial Attack amplitude 0 to +127
	BYTE		bSustainL;		// time to Sustain in 2ms ticks
	BYTE		bSustainH;		//
	BYTE		bSustainLevel;	// Amplitude level to sustain
	BYTE		bDecayL;		// time to Decay in 2ms ticks
	BYTE		bDecayH;
	BYTE		bDecayLevel;	// Amplitude level to decay
} MIDI_ENVELOPE, *PMIDI_ENVELOPE;

// --- Midi Assign
typedef struct _MIDI_ASSIGN_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: MIDI_ASSIGN
	BYTE		bChannel;		// Midi channel 1-16
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_ASSIGN_SYS_EX, *PMIDI_ASSIGN_SYS_EX;

// --- Get Effect Force Value at a tick sample time
typedef struct _MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX  {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: GET_EFFECT_FORCE_VALUE
	BYTE		bEffectID;		// Effect ID
	BYTE		bSampleTimeL;	// Low 7 bits in 2ms ticks
	BYTE		bSampleTimeH;	// High 7 bits in 2ms ticks
	BYTE		bChecksum;
	BYTE		bEOX;
} MIDI_GET_EFFECT_FORCE_VALUE_SYS_EX, *PMIDI_GET_EFFECT_FORCE_VALUE_SYS_EX;


// --- Note: For the following, if bEffectID = 0x7f, then New, else Modify
// --- Download Data - Synthesized Waveform
typedef struct _SE_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// ex: ET_SE_SINE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
// SE Parameters
	BYTE		bFreqL;			// Low 7 bits Frequency 1-2048Hz
	BYTE		bFreqH;			// High 4 bits	
	BYTE		bMaxAmpL;		// Low 7 bits Maximum Amplitude	+/- 100%
	BYTE		bMaxAmpH;		// High 1 bit
	BYTE		bMinAmpL;		// Low 7 bits Minimum Amplitude	+/- 100%
	BYTE		bMinAmpH;		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} SE_WAVEFORM_SYS_EX, *PSE_WAVEFORM_SYS_EX;

// --- Download Data - NOP Delay
typedef struct _NOP_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID, 0x7F = Create NEw
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bChecksum;
	BYTE		bEOX;
} NOP_SYS_EX, *PNOP_SYS_EX;

// --- Download Data - Behavioral SysEx
typedef struct _BEHAVIORAL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_SPRING
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_XXX Parameters
	BYTE		bXConstantL;	// Low 7 bits K	(in +/- 100%) X-Axis
	BYTE		bXConstantH;	// High 1 bit K
	BYTE		bYConstantL;	// Low 7 bits K	(in +/- 100%) Y-Axis
	BYTE		bYConstantH;	// High 1 bit K
	BYTE		bParam3L;   	// Low 7 bits Axis center (in +/- 100%)	X-Axis
	BYTE		bParam3H;  		// High 1 bit
	BYTE		bParam4L;   	// Low 7 bits Axis center (in +/- 100%)	Y-Axis
	BYTE		bParam4H;  		// High 1 bit
	BYTE		bChecksum;
	BYTE		bEOX;
} BEHAVIORAL_SYS_EX, *PBEHAVIORAL_SYS_EX;


// --- Download Data - Friction SysEx
typedef struct _FRICTION_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: BE_FRICTION
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_FRICTION Parameters
	BYTE		bXFConstantL;	// Low 7 bits F	(in +/- 100%) X-Axis
	BYTE		bXFConstantH;	// High 1 bit F
	BYTE		bYFConstantL;	// Low 7 bits F	(in +/- 100%) Y-Axis
	BYTE		bYFConstantH;	// High 1 bit F
	BYTE		bChecksum;
	BYTE		bEOX;
} FRICTION_SYS_EX, *PFRICTION_SYS_EX;


// --- Download Data - WALL SysEx
#define INNER_WALL				0	// Wall face to center
#define	OUTER_WALL				1	// Wall face away from center

typedef struct _WALL_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: DNLOAD_DATA
	BYTE		bSubType;		// Behavioral Effect Type: e.g. EF_BE_WALL
	BYTE		bEffectID;		// Downloaded Effect ID
// Effects params
	BYTE		bDurationL;		// Low 7 bits duration in 2ms ticks, 0=Forever
	BYTE		bDurationH;		// High 7 bits
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
// BE_SPRING Parameters
	BYTE		bWallType;		// INNER_WALL or OUTER_WALL
	BYTE		bWallConstantL;	// Low 7 bits: Similar to Spring Constant.
								//   Value is from +/- 100%.
	BYTE		bWallConstantH;	// High 1 bit
	BYTE		bWallAngleL;	// Low 7 bits: 0 to 359 degrees
								//   For simple vertical and horizontal walls,
								//   this value should be set to 0, 90,  180, 270
	BYTE		bWallAngleH;	// Low 2 bit
	BYTE		bWallDistance;  // 7 bits: Distance from Center of stick 0 to 100
	BYTE		bChecksum;
	BYTE		bEOX;
} WALL_SYS_EX, *PWALL_SYS_EX;

// --- Download Data - User Defined Waveform SysEx
typedef struct _UD_WAVEFORM_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	MIDI_EFFECT	Effect;
//	BYTE		bWaveformArray;	// Force Data . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} UD_WAVEFORM_SYS_EX, *PUD_WAVEFORM_SYS_EX;
#define UD_WAVEFORM_START_OFFSET (sizeof(UD_WAVEFORM_SYS_EX))


// --- Download Data - Process List SysEx
typedef struct _PROCESS_LIST_SYS_EX {
	SYS_EX_HDR	SysExHdr;
	BYTE		bOpCode;		// Sub-command opcode: PROCESS_DATA
	BYTE		bSubType;		// Process List: PL_SUPERIMPOSE/PL_CONCATENATE
	BYTE		bEffectID;		// Downloaded Effect ID
	BYTE		bButtonPlayL;	// Low 7 bits button mask
	BYTE		bButtonPlayH;	// High 2 bits button mask
	BYTE		bEffectArrayID;	// Effect ID[0] . . .
//	BYTE		bChecksum;
//	BYTE		bEOX;
} PROCESS_LIST_SYS_EX, *PPROCESS_LIST_SYS_EX;
#define PROCESS_LIST_EFFECT_START_OFFSET (sizeof(PROCESS_LIST_SYS_EX))


//
// --- Function Prototypes
//
BOOL DetectMidiDevice(
	IN OUT UINT *pDeviceOutID);

HRESULT CMD_SetIndex(
	IN int nIndex,
	IN DNHANDLE DnloadID);

HRESULT CMD_ModifyParam(
	IN WORD wNewParam);

HRESULT CMD_Download_VFX(
 	IN PEFFECT pEffect,
 	IN PENVELOPE pEnvelope,
 	IN PVFX_PARAM pVFX_Param,
 	IN ULONG ulAction,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

HRESULT CMD_Download_BE_XXX(
 	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope,
 	IN PBE_XXX pBE_XXX,
	IN OUT PDNHANDLE pDnloadID,
	IN DWORD dwFlags);

class CMidiSynthesized;


#endif // of ifdef _HAU_MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi.hpp ===
/****************************************************************************

    MODULE:     	MIDI.HPP
	Tab settings: 	5 9

	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for MIDI.CPP
    

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
   	1.0  	03-Apr-96       MEA     original
        
****************************************************************************/
#ifndef _MIDI_SEEN
#define _MIDI_SEEN

#define MMNODRV
#define MMNOSOUND
#define MMNOWAVE
// #define MMNOMIDI  // we need the MIDI definitions
#define MMNOAUX
#define MMNOTIMER
#define MMNOJOY
#define MMNOMMIO
#define MMNOMCI
#include <winuser.h>
#include <mmsystem.h>

//////////////////////////////////////////////////////////////////////////////
//
// manifest constants and macros for MIDI message protocol
//
//////////////////////////////////////////////////////////////////////////////

// MIDI Status Bytes for Channel Voice Messages
#define MIDI_NOTE_OFF           0x80
#define MIDI_NOTE_ON            0x90
#define MIDI_POLY_PRESSURE      0xA0
#define MIDI_CONTROL_CHANGE     0xB0
#define MIDI_PROGRAM_CHANGE     0xC0
#define MIDI_CHANNEL_PRESSURE   0xD0
#define MIDI_AFTERTOUCH         0xD0  // synonym for channel pressure
#define MIDI_PITCH_WHEEL        0xE0

// MIDI Status Bytes for System Common Messages
#define MIDI_SYSEX              0xF0  // beginning of system exclusive message
#define MIDI_MTC_QTR_FRAME      0xF1
#define MIDI_SONG_POSITION_PTR  0xF2
#define MIDI_SONG_SELECT        0xF3
#define MIDI_TUNE_REQUEST       0xF6
#define MIDI_EOX                0xF7  // marks end of system exclusive message

// MIDI Status Bytes for System Real-Time Messages
#define MIDI_TIMING_CLOCK       0xF8
#define MIDI_START              0xFA
#define MIDI_CONTINUE           0xFB
#define MIDI_STOP               0xFC
#define MIDI_ACTIVE_SENSING     0xFE
#define MIDI_SYSTEM_RESET       0xFF

// control numbers for MIDI_CONTROL_CHANGE (MIDI status byte 0xB0)
// note: not a complete list
#define MIDI_MOD_WHEEL              0x01
#define MIDI_BREATH_CONTROL         0x02
#define MIDI_FOOT_CONTROL           0x04
#define MIDI_PORTAMENTO_TIME        0x05
#define MIDI_DATA_ENTRY_SLIDER      0x06
#define MIDI_VOLUME                 0x07
#define MIDI_BALANCE                0x08
#define MIDI_PAN                    0x0A
#define MIDI_EXPRESSION             0x0B
#define MIDI_GENERAL_PURPOSE_1      0x10   
#define MIDI_GENERAL_PURPOSE_2      0x11
#define MIDI_GENERAL_PURPOSE_3      0x12
#define MIDI_GENERAL_PURPOSE_4      0x13
#define MIDI_SUSTAIN                0x40
#define MIDI_PORTAMENTO             0x41
#define MIDI_SOSTENUTO              0x42
#define MIDI_SOFT                   0x43
#define MIDI_HOLD_2                 0x45
#define MIDI_GENERAL_PURPOSE_5      0x50
#define MIDI_GENERAL_PURPOSE_6      0x51
#define MIDI_GENERAL_PURPOSE_7      0x52
#define MIDI_GENERAL_PURPOSE_8      0x53
#define MIDI_EXTERNAL_EFFECTS_DEPTH 0x5B
#define MIDI_TREMELO_DEPTH          0x5C
#define MIDI_CHORUS_DEPTH           0x5D
#define MIDI_CELESTE_DEPTH          0x5E
#define MIDI_PHASER_DEPTH           0x5F
#define MIDI_DATA_INCREMENT         0x60
#define MIDI_DATA_DECREMENT         0x61
#define MIDI_NONREG_PARAM_NUM_MSB   0x62
#define MIDI_NONREG_PARAM_NUM_LSB   0x63
#define MIDI_REG_PARAM_NUM_MSB      0x64
#define MIDI_REG_PARAM_NUM_LSB      0x65
#define MIDI_RESET_ALL_CONTROLLERS  0x79
#define MIDI_LOCAL_CONTROL          0x7A
#define MIDI_ALL_NOTES_OFF          0x7B
#define MIDI_OMNI_MODE_OFF          0x7C
#define MIDI_OMNI_MODE_ON           0x7D
#define MIDI_MONO_MODE_ON           0x7E
#define MIDI_POLY_MODE_ON           0x7F      

// macro to pack a MIDI short message                                                
#define MAKEMIDISHORTMSG(cStatus, cChannel, cData1, cData2)            \
    cStatus | cChannel | (((UINT)cData1) << 8) | (((DWORD)cData2) << 16)
    
// macros to unpack a MIDI short message    
#define MIDI_STATUS(dwMsg)  ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0xF0 : LOBYTE(LOWORD(dwMsg)))
#define MIDI_CHANNEL(dwMsg) ((LOBYTE(LOWORD(dwMsg)) < MIDI_SYSEX) ? \
                              LOWORD(dwMsg) & 0x0F : 0)
#define MIDI_DATA1(dwMsg)   (HIBYTE(LOWORD(dwMsg)))
#define MIDI_DATA2(dwMsg)   (LOBYTE(HIWORD(dwMsg))) 

//////////////////////////////////////////////////////////////////////////////
//
// declarations for MIDI wrapper functions
//
//////////////////////////////////////////////////////////////////////////////

#define MIDI_IN      0x0001  // specifies MIDI input device
#define MIDI_OUT     0x0002  // specifies MIDI output device
#define NO_MIDI      0xFF00  // MIDI device unavaible or not selected 

#define MIDI_OPEN    0x0001  // uActivateMode parameter for MidiActivate
#define MIDI_CLOSE   0x0010  // uActivateMode parameter for MidiActivate
#define MIDI_ABANDON 0x0011  // uActivateMode parameter for MidiActivate
#define MIDI_BUSY    0xFF01  // possible MidiActivate return value

#define MIDI_ERRMSG_SIZE 128 // for MidiShowError string buffer

typedef struct _MIDIINFO     // MIDI device information block
{                           
    UINT uDeviceType;        // either MIDI_IN, MIDI_OUT or NO_MIDI
    UINT uDeviceID;          // ID of device chosen by user or NO_MIDI 
    union
    { 
        HMIDIIN  hMidiIn;    // input device handle used if MIDI_IN device
        HMIDIOUT hMidiOut;   // output device handle used if MIDI_OUT device
    };
    MIDIHDR MidiHdr;         // required for system exclusive   
    BOOL fAlwaysKeepOpen;    // access level requested by application
    UINT uDeviceStatus;      // current status of device
} MIDIINFO, *LPMIDIINFO;

// defines for MIDIINFO uDeviceStatus member
#define MIDI_DEVICE_IDLE        0x0000  // device is not in use
#define MIDI_DEVICE_BUSY        0x0001  // device is busy
#define MIDI_DEVICE_ABANDONED   0x0002  // device was reset while busy

    
BOOL MidiInit(LPMIDIINFO, LPMIDIINFO);
MMRESULT MidiGetDeviceName(UINT, UINT, LPWORD, LPWORD, LPSTR);
UINT MidiActivateDevice(LPMIDIINFO, UINT);
UINT MidiSendShortMsg(LPMIDIINFO, BYTE, BYTE, BYTE, BYTE); 
UINT MidiSendLongMsg(LPMIDIINFO, BOOL);
UINT MidiRecord(LPMIDIINFO, BOOL);
BOOL MidiExit(LPMIDIINFO, LPMIDIINFO);

#endif // of ifdef _MIDI_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\registry.h ===
//@doc
/******************************************************
**
** @module REGISTRY.H | Definition of RegistryKey class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/
#ifndef	__REGISTRY_H__
#define	__REGISTRY_H__

#include <windows.h>

#ifndef override
#define override
#endif


//
// @class RegistryKey class
//
class RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		RegistryKey(HKEY osKey) : m_OSRegistryKey(osKey), m_ShouldClose(FALSE), m_pReferenceCount(NULL) {};
		RegistryKey(RegistryKey& rkey);

		//@cmember destructor
		~RegistryKey();

		RegistryKey CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName = TEXT("REG_SZ"));
		RegistryKey OpenSubkey(const TCHAR* subkeyName, REGSAM access = KEY_READ);
		RegistryKey OpenCreateSubkey(const TCHAR* subkeyName);
		HRESULT RemoveSubkey(const TCHAR* subkeyName);

		HRESULT QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize);
		HRESULT SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType);
		DWORD GetNumSubkeys() const;

		virtual RegistryKey& operator=(RegistryKey& rhs);
		BOOL operator==(const RegistryKey& comparee);
		BOOL operator!=(const RegistryKey& comparee);

		void ShouldClose(BOOL closeable) { m_ShouldClose = closeable; }
	//@access private data members
	private:
		HKEY m_OSRegistryKey;
		BOOL m_ShouldClose;			// Should only close keys we create
		UINT* m_pReferenceCount;
};

//
// @class UnassignableRegistryKey class
//
class UnassignableRegistryKey : public RegistryKey
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		UnassignableRegistryKey(HKEY osKey) : RegistryKey(osKey) {};

	//@access private data members
	private:
		UnassignableRegistryKey(RegistryKey& rkey);
		override RegistryKey& operator=(RegistryKey& rhs) { return *this; }	// vtable requires definition?
};

extern UnassignableRegistryKey c_InvalidKey;	/* const unassignable, but not const immutable */


#endif	__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi_obj.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.CPP
	Tab stops 5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for SWFF MIDI device object

    FUNCTIONS: 		Classes methods

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -----------------------------------------
	0.1			10-Sep-96	MEA     original
	1.1			20-May-97	MEA		Added Mutex and Thread safe code
				17-Jun-97	MEA		Fixed bug Midi Handle lost if 1st process
									terminated.
				21-Mar-99	waltw	Removed unreferenced UpdateJoystickParams,
									GetJoystickParams
				21-Mar-99	waltw	Add dwDeviceID param: CJoltMidi::Initialize
									and pass down food chain
				21-Mar-99	waltw	Added dwDeviceID param to DetectMidiDevice,
									InitDigitalOverDrive,

****************************************************************************/
#include <assert.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <mmsystem.h>
#include "SW_Error.hpp"
#include "midi_obj.hpp"
#include "vxdioctl.hpp"
#include "joyregst.hpp"
#include "FFDevice.h"
#include "DPack.h"
#include "CritSec.h"

#include "DTrans.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/
extern void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);
extern TCHAR szDeviceName[MAX_SIZE_SNAME];
extern CJoltMidi *g_pJoltMidi;

/****************************************************************************

   Declaration of variables

****************************************************************************/


/****************************************************************************

   Macros etc

****************************************************************************/

#ifdef _DEBUG
extern char g_cMsg[160];
void DebugOut(LPCTSTR szDebug)
{
	g_CriticalSection.Enter();
	_RPT0(_CRT_WARN, szDebug);
	g_CriticalSection.Leave();

#ifdef _LOG_DEBUG
#pragma message("Compiling with Debug Log to SW_WHEEL.txt")
	FILE *pf = fopen("SW_WHEEL.txt", "a");
	if (pf != NULL)
	{
		fputs(szDebug, pf);
		fclose(pf);
	}
#endif // _LOG_DEBUG
}
#else !_DEBUG
#define DebugOut(x)
#endif // _DEBUG


// ****************************************************************************
// *** --- Member functions for base CJoltMidi
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::CJoltMidi
// Purpose:		Constructor(s)/Destructor for CJoltMidi Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CJoltMidi::CJoltMidi(void)
{
	CriticalLock cl;

	static char cWaterMark[MAX_SIZE_SNAME] = {"SWFF_SHAREDMEMORY MEA"};
	BOOL bAlreadyMapped = FALSE;
#ifdef _DEBUG
	DebugOut("SWFF_PRO(DX):CJoltMidi::CJoltMidi\n");
#endif
	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;

// Create an in-memory memory-mapped file
	m_hSharedMemoryFile = CreateFileMapping((HANDLE) 0xFFFFFFFF,
							NULL, PAGE_READWRITE, 0, SIZE_SHARED_MEMORY,
    							__TEXT(SWFF_SHAREDMEM_FILE));

	if (m_hSharedMemoryFile == NULL)
	{
#ifdef _DEBUG
	    DebugOut("SW_WHEEL(DX):ERROR! Failed to create Memory mapped file\n");
#endif
	}
	else
	{
	    if (GetLastError() == ERROR_ALREADY_EXISTS)
	    {
			bAlreadyMapped = TRUE;
	    }
		// File mapping created successfully.
		// Map a view of the file into the address space.
		m_pSharedMemory = (PSHARED_MEMORY) MapViewOfFile(m_hSharedMemoryFile,
			              FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
		if ((BYTE *) m_pSharedMemory == NULL)
		{
#ifdef _DEBUG
		    DebugOut("SW_WHEEL(DX):ERROR! Failed to Map view of shared memory\n");
#endif
		}

// ***** Shared Memory Access *****
		LockSharedMemory();
		if (!bAlreadyMapped)
		{
			// Set watermark and initialize, Bump Ref Count
			memcpy(&m_pSharedMemory->m_cWaterMark[0], &cWaterMark[0], MAX_SIZE_SNAME);
			m_pSharedMemory->m_RefCnt = 0;
		}
		m_pSharedMemory->m_RefCnt++;
	}
#ifdef _DEBUG
		wsprintf(g_cMsg, "SW_WHEEL(DX): Shared Memory:%lx, m_RefCnt:%d\n",m_pSharedMemory,
				m_pSharedMemory->m_RefCnt);
		DebugOut(g_cMsg);
#endif
		UnlockSharedMemory();
// ***** End of Shared Memory Access *****

}

// --- Destructor
CJoltMidi::~CJoltMidi()
{
	CriticalLock cl;

	DebugOut("SW_WHEEL(DX):CJoltMidi::~CJoltMidi()\n");
	// Normal CJoltMidi Destructor

// Free the Primary SYS_EX locked memory
	if (m_hPrimaryBuffer) {
	    GlobalUnlock(m_hPrimaryBuffer);
    	GlobalFree(m_hPrimaryBuffer);
	}

// ***** Shared Memory Access *****
	LockSharedMemory();
	// Decrement Ref Count and clean up if equal to zero.
	m_pSharedMemory->m_RefCnt--;
#ifdef _DEBUG
	wsprintf(g_cMsg,"CJoltMidi::~CJoltMidi. RefCnt = %d\n",m_pSharedMemory->m_RefCnt);
	DebugOut(g_cMsg);
#endif

	if (0 == m_pSharedMemory->m_RefCnt)	
	{
		if ((g_pDataTransmitter != NULL) && (g_pDataPackager != NULL)) {
			// Tri-state Midi lines
			if (g_pDataPackager->SendForceFeedbackCommand(SWDEV_KILL_MIDI) == SUCCESS) {
				ACKNACK ackNack;
				g_pDataTransmitter->Transmit(ackNack);	// Send it off
			}
		}
	}

	// Kill Data Packager
	delete g_pDataPackager;
	g_pDataPackager = NULL;

	// Kill Data Transmitter
	delete g_pDataTransmitter;
	g_pDataTransmitter = NULL;

	// This gets closed in UnlockSharedMemory call below. 22-Mar-99 waltw
//	if (m_hSWFFDataMutex) CloseHandle(m_hSWFFDataMutex);

	// Release the Midi Output Event handles
	if (m_hMidiOutputEvent)	 {
		CloseHandle (m_hMidiOutputEvent);
		m_hMidiOutputEvent = NULL;
	}

// ***** End of Shared Memory Access *****

	// Release Memory Mapped file handles
	if (m_hSharedMemoryFile != NULL) {
		UnmapViewOfFile((LPCVOID) m_pSharedMemory);
		CloseHandle(m_hSharedMemoryFile);
	}

	// Release Mutex handle after releasing Mem Mapped file
	UnlockSharedMemory();

	// Close VxD handles
	if (g_pDriverCommunicator != NULL)
	{
		delete g_pDriverCommunicator;
		g_pDriverCommunicator = NULL;
	}

	memset(this, 0, sizeof(CJoltMidi));
	m_hVxD = INVALID_HANDLE_VALUE;
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::Initialize
// Purpose:		Initializer
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::Initialize(DWORD dwDeviceID)
{
	CriticalLock cl;

	HRESULT hRet = SUCCESS;

	// initialize the MIDI output information block
	m_MidiOutInfo.uDeviceType     = MIDI_OUT;
	m_MidiOutInfo.hMidiOut        = NULL;
    m_MidiOutInfo.fAlwaysKeepOpen = TRUE;
    m_MidiOutInfo.uDeviceStatus   = MIDI_DEVICE_IDLE;
	m_MidiOutInfo.MidiHdr.dwBytesRecorded = 0;
	m_MidiOutInfo.MidiHdr.dwUser = 0;
	m_MidiOutInfo.MidiHdr.dwOffset = 0;
	m_MidiOutInfo.MidiHdr.dwFlags = 0;
	
    // Allocate and lock global memory for SysEx messages
    m_hPrimaryBuffer = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, MAX_SYS_EX_BUFFER_SIZE);
	assert(m_hPrimaryBuffer);
	if (m_hPrimaryBuffer == NULL)
	{
		return E_OUTOFMEMORY;
	}

    m_pPrimaryBuffer = (LPBYTE) GlobalLock(m_hPrimaryBuffer);
	assert(m_pPrimaryBuffer);
    if(NULL == m_pPrimaryBuffer)
	{
	   	GlobalFree(m_hPrimaryBuffer);
		return (SFERR_DRIVER_ERROR);
	}

	// Initialize the IOCTL interface to VjoyD mini-driver
	hRet = InitDigitalOverDrive(dwDeviceID);
	if (SUCCESS != hRet)
	{
		DebugOut("Warning! Could not Initialize Digital OverDrive\n");
		return (hRet);
	}
	else
		DebugOut("InitDigitalOverDrive - Success\n");

	// Create a Callback Event
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SWFF_MIDIEVENT);
	if (NULL == hEvent)
	{
		// Create an Event for notification when Midi Output has completed
		m_hMidiOutputEvent = CreateEvent(NULL,  // No security
                          TRUE,			// Manual reset
                          FALSE,		// Initial event is non-signaled
                          SWFF_MIDIEVENT );		// Named
		assert(m_hMidiOutputEvent);
	}
	else
		m_hMidiOutputEvent = hEvent;

	// This function is only called after g_pJoltMidi created
	assert(g_pJoltMidi);
	
	PDELAY_PARAMS pDelayParams = g_pJoltMidi->DelayParamsPtrOf();
	GetDelayParams(dwDeviceID, pDelayParams);

	// Reset HW first
	g_pDriverCommunicator->ResetDevice();
	Sleep(DelayParamsPtrOf()->dwHWResetDelay);

	// Set MIDI channel to default then Detect a Midi Device
	if (!DetectMidiDevice(dwDeviceID, &m_COMMPort)) {		// Port address
		DebugOut("Warning! No Midi Device detected\n");
		return (SFERR_DRIVER_ERROR);
	} else {
#ifdef _DEBUG
		wsprintf(g_cMsg,"DetectMidiDevice returned: DeviceID=%d, COMMInterface=%x, COMMPort=%x\n",
			m_MidiOutInfo.uDeviceID, m_COMMInterface, m_COMMPort);
		DebugOut(g_cMsg);
#endif
	}

	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}

	// Set the status byte properly
	ULONG portByte = 0;
	g_pDriverCommunicator->GetPortByte(portByte);	// don't care about success, always fails on old driver
	if (portByte & STATUS_GATE_200) {
		g_pDataTransmitter->SetNextNack(1);
	} else {
		g_pDataTransmitter->SetNextNack(0);
	}

	// Send Initialization packet(s) to Jolt
	hRet = g_pDataPackager->SetMidiChannel(DEFAULT_MIDI_CHANNEL);
	if (hRet == SUCCESS) {
		ACKNACK ackNack;
		hRet = g_pDataTransmitter->Transmit(ackNack);
	}
	if (hRet != SUCCESS) {
		DebugOut("Warning! Could not Initialize Jolt\n");
		return (hRet);
	} else {
		DebugOut("JOLT SetMidiChannel - Success\n");
	}

	// At this point, we have a valid MIDI path...
	// Continue by setting up the ROM Effects default table entries
							 // ID  , OutputRate, Gain, Duration
	static	ROM_FX_PARAM RomFxTable [] = {{ RE_ROMID1 , 100, 100, 12289 }, // Random Noise
								  { RE_ROMID2 , 100, 100,  2625 }, // AircraftCarrierTakeOff
								  { RE_ROMID3 , 100,  50,   166 }, // BasketballDribble
								  { RE_ROMID4 , 100,  14, 10000 }, // CarEngineIdling
								  { RE_ROMID5 , 100,  30,  1000 }, // Chainsaw
								  { RE_ROMID6 , 100, 100,  1000 }, // ChainsawingThings
								  { RE_ROMID7 , 100,  40, 10000 }, // DieselEngineIdling
								  { RE_ROMID8 , 100, 100,   348 }, // Jump
								  { RE_ROMID9 , 100, 100,   250 }, // Land
								  { RE_ROMID10, 200, 100,  1000 }, // MachineGun
								  { RE_ROMID11, 100, 100,    83 }, // Punched
								  { RE_ROMID12, 100, 100,  1000 }, // RocketLauncher
								  { RE_ROMID13, 100,  98,   500 }, // SecretDoor
								  { RE_ROMID14, 100,  66,    25 }, // SwitchClick
								  { RE_ROMID15, 100,  75,   500 }, // WindGust
								  { RE_ROMID16, 100, 100,  2500 }, // WindShear
								  { RE_ROMID17, 100, 100,    50 }, // Pistol
								  { RE_ROMID18, 100, 100,   295 }, // Shotgun
								  { RE_ROMID19, 500,  95,  1000 }, // Laser1
								  { RE_ROMID20, 500,  96,  1000 }, // Laser2
								  { RE_ROMID21, 500, 100,  1000 }, // Laser3
								  { RE_ROMID22, 500, 100,  1000 }, // Laser4
								  { RE_ROMID23, 500, 100,  1000 }, // Laser5
								  { RE_ROMID24, 500,  70,  1000 }, // Laser6
								  { RE_ROMID25, 100, 100,    25 }, // OutOfAmmo
								  { RE_ROMID26, 100,  71,  1000 }, // LigntningGun
								  { RE_ROMID27, 100, 100,   250 }, // Missile
								  { RE_ROMID28, 100, 100,  1000 }, // GatlingGun
								  { RE_ROMID29, 500,  97,   250 }, // ShortPlasma
								  { RE_ROMID30, 500, 100,   500 }, // PlasmaCannon1
								  { RE_ROMID31, 500,  99,   625 }, // PlasmaCannon2
								  { RE_ROMID32, 100, 100,   440 }}; // Cannon
//								  { RE_ROMID33, 100,  68,  1000 }, // FlameThrower
//								  { RE_ROMID34, 100, 100,    75 }, // BoltActionRifle
//								  { RE_ROMID35, 500, 100,   300 }, // Crossbow
//								  { RE_ROMID36, 100, 100,  1000 }, // Sine
//								  { RE_ROMID37, 100, 100,  1000 }}; // Cosine
	m_pRomFxTable = &RomFxTable[0];

// ***** Shared Memory Access *****
	LockSharedMemory();
	LONG lRefCnt = m_pSharedMemory->m_RefCnt;
	UnlockSharedMemory();
// ***** End of Shared Memory Access *****
		
	// Initialize the RTC_Spring object
	g_ForceFeedbackDevice.InitRTCSpring(dwDeviceID);

	// initialize the joystick params
	g_ForceFeedbackDevice.InitJoystickParams(dwDeviceID);

	// initialize the firmware params fudge factors (for the first time)
	// in the case of the FFD interface, this will be the only time they
	// are initialized, which may cause a problem because joystick is assumed
	// to be ID1
	PFIRMWARE_PARAMS pFirmwareParams = g_pJoltMidi->FirmwareParamsPtrOf();
	GetFirmwareParams(dwDeviceID, pFirmwareParams);

	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::LockSharedMemory
// Purpose:     Creates a Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     TRUE if Mutex available else FALSE

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::LockSharedMemory(void)
{
	DWORD dwRet;
	{
		CriticalLock cl;

	// Create the SWFF mutex
		HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, SWFF_SHAREDMEM_MUTEX);
		if (NULL == hMutex)
		{
			// Doesn't exist yet, so create it
			hMutex = CreateMutex(NULL, TRUE, SWFF_SHAREDMEM_MUTEX);
			if (NULL == hMutex)
			{
	#ifdef _DEBUG
				DebugOut("Error! Could not create SWFFDataMutex\n");
	#endif
				m_hSWFFDataMutex = NULL;
				return (FALSE);
			}
		}
		// SUCCESS
		m_hSWFFDataMutex = hMutex;
		dwRet = WaitForSingleObject(m_hSWFFDataMutex, MUTEX_TIMEOUT);
	}	// End of Critical Section

	if (WAIT_OBJECT_0 == dwRet)
		return (TRUE);
	else
	{
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"CJoltMidi::LockSharedMemory() error return: %lx\n", dwRet);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif		
		return (FALSE);
	}
}


// *** ---------------------------------------------------------------------***
// Function:    CJoltMidi::UnlockSharedMemory
// Purpose:     Releases Mutex for Shared Memory access
// Parameters:  none
//
//
// Returns:     none

// Algorithm:
//
// Comments:
//
//
// *** ---------------------------------------------------------------------***
void CJoltMidi::UnlockSharedMemory(void)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();
	if (NULL != m_hSWFFDataMutex)
	{
		ReleaseMutex(m_hSWFFDataMutex);
		CloseHandle(m_hSWFFDataMutex);
		m_hSWFFDataMutex=NULL;
	}
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();

}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetAckNackData
// Purpose:		Waits for a Response ACK
//
// Parameters:	int nTImeWait		- Time to wait in 1 ms increment, 0=no wait
//				PACKNACK pAckNack	- Pointer to ACKNACK structure
//
// Returns:		SUCCESS else error code SFERR_DRIVER_ERROR
//				
// Algorithm:
//
// Note: For Short messages the MidiOutProc callback receives no MM_MOM_DONE
//		 indicating completed transmission.  Only Long (SysEx) messages do.
// Uses:
//typedef struct _ACKNACK  {
//	DWORD	cBytes;	
//	DWORD	dwAckNack;			//ACK, NACK
//	DWORD	dwErrorCode;
//	DWORD	dwEffectStatus;		//DEV_STS_EFFECT_RUNNING||DEV_STS_EFFECT_STOPPED
//} ACKNACK, *PACKNACK;
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetAckNackData(
	IN int nTimeWait,
	IN OUT PACKNACK pAckNack,
	IN USHORT usRegIndex)
{
	CriticalLock cl;

	assert(pAckNack);
// Use IOCTL from VxD to get AckNack data
// Wait for Event to be set
	if (nTimeWait && m_hMidiOutputEvent)
	{
		DWORD dwRet = WaitForSingleObject(m_hMidiOutputEvent, nTimeWait);
		//		:
#ifdef _DEBUG
		wsprintf(g_cMsg,"WaitForSingleObject %lx returned %lx, nTimeWait=%ld\n", m_hMidiOutputEvent, dwRet, nTimeWait);
		DebugOut(g_cMsg);
#endif
		BOOL bRet = ResetEvent(m_hMidiOutputEvent);
	}

	HRESULT hRet = g_pDriverCommunicator->GetAckNack(*pAckNack, usRegIndex);

	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::InitDigitalOverDrive
// Purpose:		Initialize the VxD interface
//
// Parameters:	none
//
// Returns:		SUCCESS or Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT	CJoltMidi::InitDigitalOverDrive(DWORD dwDeviceID)
{
	if (g_pDriverCommunicator != NULL)
	{	// Attempt to reinit
		ASSUME_NOT_REACHED();
		return S_OK;
	}

//
// --- THIS IS A CRITICAL SECTION
//
	HRESULT hRet = SUCCESS;
	DWORD driverMajor = 0xFFFFFFFF;
	DWORD driverMinor = 0xFFFFFFFF;

	CriticalLock cl;
	// This fork works on NT5 only (VxD stuff removed)
	assert(g_ForceFeedbackDevice.IsOSNT5() == TRUE);
	{
		g_pDriverCommunicator = new HIDFeatureCommunicator;
		if (g_pDriverCommunicator == NULL)
		{
			return DIERR_OUTOFMEMORY;
		}
		if (((HIDFeatureCommunicator*)g_pDriverCommunicator)->Initialize(dwDeviceID) == FALSE)
		{	// Could not load the driver
			hRet = SFERR_DRIVER_ERROR;
		}
	}

	if (FAILED(hRet))
	{
		return hRet;
	}

	// Loaded driver, get the version
	g_pDriverCommunicator->GetDriverVersion(driverMajor, driverMinor);

	g_ForceFeedbackDevice.SetDriverVersion(driverMajor, driverMinor);
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::UpdateDeviceMode
// Purpose:		Sets JOLT Device Mode
//
// Parameters:	ULONG ulMode
//
// Returns:		none
//				
// Algorithm:
// This is the SideWinder State structure
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// ----------------------------------------------------------------------------
void CJoltMidi::UpdateDeviceMode(ULONG ulMode)
{
//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	switch (ulMode)
	{
		case SWDEV_FORCE_ON:			// REVIEW
		case SWDEV_FORCE_OFF:
			m_DeviceState.m_ForceState = ulMode;
			break;

		case SWDEV_SHUTDOWN:
			m_DeviceState.m_ForceState = ulMode;
			m_DeviceState.m_EffectState = 0;
			break;

		case SWDEV_STOP_ALL:
		case SWDEV_CONTINUE:
		case SWDEV_PAUSE:
			m_DeviceState.m_EffectState = ulMode;
			break;

		default:
			break;
	}
// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::GetJoltID
// Purpose:		Returns JOLT ProductID
//
// Parameters:	LOCAL_PRODUCT_ID* pProductID	- Pointer to a PRODUCT_ID structure
//
// Returns:		none
//				
// Algorithm:	
//
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::GetJoltID(LOCAL_PRODUCT_ID* pProductID)
{
	HRESULT hRet;
	assert(pProductID->cBytes = sizeof(LOCAL_PRODUCT_ID));
	if (pProductID->cBytes != sizeof(LOCAL_PRODUCT_ID)) return (SFERR_INVALID_STRUCT_SIZE);

//
// --- THIS IS A CRITICAL SECTION
//
	g_CriticalSection.Enter();

	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		if (SUCCESS == (hRet = g_pDriverCommunicator->GetID(*pProductID))) break;
	}
	if (SUCCESS == hRet)
	{
		memcpy(&m_ProductID, pProductID, sizeof(LOCAL_PRODUCT_ID));
	}
	else
		DebugOut("GetJoltID: Warning! GetIDPacket - Fail\n");

// --- END OF CRITICAL SECTION
//
	g_CriticalSection.Leave();
	return (hRet);
}

// ----------------------------------------------------------------------------
// Function: 	CJoltMidi::LogError
// Purpose:		Logs Error codes
//
// Parameters:	HRESULT SystemError		- System Error code
//				HRESULT DriverError		- Driver Error code
//
// Returns:		SWFORCE Error code
//				
// Algorithm:
// ----------------------------------------------------------------------------
typedef struct _DRIVERERROR {
	ULONG	ulDriverCode;
	LONG	lSystemCode;
} DRIVERERROR, *PDRIVERERROR;

HRESULT	CJoltMidi::LogError(
	IN HRESULT SystemError,
	IN HRESULT DriverError)
{
// REVIEW: map MM error codes to our SWForce codes

	DRIVERERROR DriverErrorCodes[] = {
		{DEV_ERR_INVALID_ID        , SWDEV_ERR_INVALID_ID},
		{DEV_ERR_INVALID_PARAM     , SWDEV_ERR_INVALID_PARAM},
		{DEV_ERR_CHECKSUM          , SWDEV_ERR_CHECKSUM},
		{DEV_ERR_TYPE_FULL         , SWDEV_ERR_TYPE_FULL},
		{DEV_ERR_UNKNOWN_CMD       , SWDEV_ERR_UNKNOWN_CMD},
		{DEV_ERR_PLAYLIST_FULL     , SWDEV_ERR_PLAYLIST_FULL},
		{DEV_ERR_PROCESS_LIST_FULL , SWDEV_ERR_PROCESSLIST_FULL} };

	int nDriverErrorCodes = sizeof(DriverErrorCodes)/(sizeof(DRIVERERROR));
	for (int i=0; i<nDriverErrorCodes; i++)
	{
		if (DriverError == (LONG) DriverErrorCodes[i].ulDriverCode)
		{
			SystemError = DriverErrorCodes[i].lSystemCode;
			break;
		}
	}
	// Store in Jolt object
	m_Error.HCode = SystemError;
	m_Error.ulDriverCode = DriverError;

#ifdef _DEBUG
	wsprintf(g_cMsg,"LogError: SystemError=%.8lx, DriverError=%.8lx\n",
			 SystemError, DriverError);
	DebugOut(g_cMsg);
#endif
	return SystemError;
}

//
// ----------------------------------------------------------------------------
// Function: 	SetupROM_Fx
// Purpose:		Sets up parameters for ROM Effects
// Parameters:  PEFFECT pEffect
//				
//
// Returns:		pEffect is updated with new ROM parameters
//				OutputRate
//				Gain
//				Duration
//	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CJoltMidi::SetupROM_Fx(
	IN OUT PEFFECT pEffect)
{
	assert(pEffect);
	if (NULL == pEffect) return (SFERR_INVALID_PARAM);
							
	ULONG ulSubType = pEffect->m_SubType;
	BOOL bFound = FALSE;
	for (int i=0; i< MAX_ROM_EFFECTS; i++)
	{
		if (ulSubType == m_pRomFxTable[i].m_ROM_Id)
		{
			bFound = TRUE;
			break;
		}
	}
	if (!bFound) return (SFERR_INVALID_OBJECT);
	// Found, so fill in the default parameters, use Default if Gain=1, Duration=-1, OutputRate=-1
	BOOL bDefaultDuration = (ULONG)-1 == pEffect->m_Duration;
	if (1 == pEffect->m_Gain) pEffect->m_Gain = m_pRomFxTable[i].m_Gain;
	if (bDefaultDuration) pEffect->m_Duration = m_pRomFxTable[i].m_Duration;
	if ((ULONG)-1 == pEffect->m_ForceOutputRate)
	{
		pEffect->m_ForceOutputRate = m_pRomFxTable[i].m_ForceOutputRate;
	}
	else if(bDefaultDuration && pEffect->m_ForceOutputRate != 0)
	{
		// scale the duration to correspond to the output rate
		pEffect->m_Duration = pEffect->m_Duration*m_pRomFxTable[i].m_ForceOutputRate/pEffect->m_ForceOutputRate;
	}
	return (SUCCESS);
}

// *** ---------------------------------------------------------------------***
// Function:   	DetectMidiDevice
// Purpose:    	Determines Midi Output Device ID
// Parameters:
//				ULONG pCOMMInterface	- Ptr to COMMInterface value
//				ULONG pCOMMPort			- Ptr to COMMPort value (Registry)
// Returns:    	BOOL TRUE if successful match and IDs are filled in
//				else FALSE
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::DetectMidiDevice(
	IN	DWORD dwDeviceID,
	OUT ULONG *pCOMMPort)
{
	CriticalLock cl;

	// Set defaults
	*pCOMMPort      = NULL;

	// Turn on tristated Jolt MIDI lines by call GetIDPacket()
	LOCAL_PRODUCT_ID ProductID = {sizeof(LOCAL_PRODUCT_ID)};
	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);	
	if (SUCCESS != GetJoltID(&ProductID))
	{
		DebugOut("DetectMidiDevice: Warning! GetIDPacket - Fail\n");
		return (FALSE);
	}

#ifdef _DEBUG
	wsprintf(g_cMsg,"%s: ProductID=%.8lx, FWVersion=%d.%.2ld\n",
		&szDeviceName,	
		m_ProductID.dwProductID,
		m_ProductID.dwFWMajVersion,
		m_ProductID.dwFWMinVersion);
	DebugOut(g_cMsg);
#endif
	// Set the device firmware version from GetID
	g_ForceFeedbackDevice.SetFirmwareVersion(dwDeviceID, m_ProductID.dwFWMajVersion, m_ProductID.dwFWMinVersion);

	// Get Device status prior to starting detection
	BOOL statusPacketFailed = (g_ForceFeedbackDevice.QueryStatus() != SUCCESS);
/*	if (statusPacketFailed == FALSE) {		--- GetID does not clear soft reset bit
		if (g_ForceFeedbackDevice.IsHardwareReset()) {	// Make sure HW Reset Detect bit is cleared after GetID
    		DebugOut("DetectMidiDevice: Error! Jolt ResetDetect bit not cleared after GetID\n");
			return (FALSE);
		}
	}
*/

	// See if Serial Dongle connected, otherwise must be MIDI device
    DebugOut("SW_WHEEL:Trying Auto HW Detection: MIDI Serial Port Device...\n");

	// Get Registry values, If high bit of COMMInterface is set, then force override (should add)
	DWORD commInterface;
	if (SUCCESS != joyGetForceFeedbackCOMMInterface(dwDeviceID, &commInterface, pCOMMPort)) {
		DebugOut("DetectMidiDevice: Registry key(s) missing! Bailing Out...\n");
		return (FALSE);
	}
#ifdef _DEBUG
	wsprintf(g_cMsg, "DetectMidiDevice: Registry.COMMInterface=%lx, Registry.COMMPort=%lx\n",
			commInterface, *pCOMMPort);
	DebugOut(g_cMsg);
#endif												

	ULONG regInterface = commInterface;

	// Delete any data transmitter (unless this is called multiple times - shouldn't happen)
	if (g_pDataTransmitter != NULL) {
		DebugOut("Unexpected multiple DetectMidiDevice() calls\r\n");
		delete g_pDataTransmitter;
		g_pDataTransmitter = NULL;
	}

	// Was a serial dongle detected, or did we fail to get status
	if (g_ForceFeedbackDevice.IsSerial() || statusPacketFailed) {	// Use serial (regardless what registry says!)
		DebugOut("DetectMidiDevice: Serial Port interface detected. Or Status Packet failed\n");

		// Set to backdoor serial method by default
		m_COMMInterface = COMM_SERIAL_BACKDOOR;

		// Should we try backdoor first (old firmware, or reg says so)
		if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 16)
		 || (regInterface & MASK_SERIAL_BACKDOOR)) {
			g_pDataTransmitter = new SerialBackdoorDataTransmitter;
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
		}

		// Backdoor not warrented or didn't work - front door
		if (g_pDataTransmitter == NULL) {
			g_pDataTransmitter = new SerialDataTransmitter();			
			m_COMMInterface = COMM_SERIAL_FILE;
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {	// Failed Front Door! (yech)
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
		}

		if ((statusPacketFailed == FALSE) || (g_pDataTransmitter != NULL)) {
			return (g_pDataTransmitter != NULL);
		}
	}	// End of Serial Port Auto HW selection

	// No Serial HW dongle detected, try midi-backdoor and WinMM
	DebugOut("Trying Midi (Serial No Go or No Dongle)\n");

	ULONG ulPort = *pCOMMPort;	// Set in the registry (assumed valid if override is set
	if ( !(regInterface & MASK_OVERRIDE_MIDI_PATH) ) {	// Use Automatic detection
		DebugOut("DetectMidiDevice: Auto Detection. Trying Backdoor\n");

		// Back Door
		g_pDataTransmitter = new MidiBackdoorDataTransmitter();

		if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
			delete g_pDataTransmitter;
			g_pDataTransmitter = NULL;
		}

		if (g_pDataTransmitter == NULL) {	// Try Front Door
			DebugOut("DetectMidiDevice: trying WINMM...\n");
			g_pDataTransmitter = new WinMMDataTransmitter();
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
		}

		return (g_pDataTransmitter != NULL);
	}

	// Over-ride since high bit is set
	commInterface &= ~(MASK_OVERRIDE_MIDI_PATH | MASK_SERIAL_BACKDOOR);	// Mask out high bit (and second bit)
	switch (commInterface) {
		case COMM_WINMM: {
			g_pDataTransmitter = new WinMMDataTransmitter();
			if (!g_pDataTransmitter->Initialize(dwDeviceID)) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
			break;
		}
			
		case COMM_MIDI_BACKDOOR: {
			// Back Door
			g_pDataTransmitter = new MidiBackdoorDataTransmitter();
			if (!((MidiBackdoorDataTransmitter*)g_pDataTransmitter)->InitializeSpecific(dwDeviceID, HANDLE(ulPort))) {
				delete g_pDataTransmitter;
				g_pDataTransmitter = NULL;
			}
			break;
		}

		case COMM_SERIAL_BACKDOOR: {	// mlc - This will never work if no dongle detected
			DebugOut("Cannot force Serial Backdoor if no serial dongle is connected\r\n");
			break;
		}
	}

	if (g_pDataTransmitter == NULL) {
		DebugOut("DetectMidiDevice: Error! Invalid Over-ride parameter values\n");
	}

	return (g_pDataTransmitter != NULL);
}

// *** ---------------------------------------------------------------------***
// Function:   	QueryForJolt
// Purpose:    	Sends Shutdown and Queries for Shutdown status bit
// Parameters: 	none
// Returns:    	BOOL TRUE if Jolt found, else FALSE
//
// Comments:	SHUTDOWN is destructive!!!
//
// *** ---------------------------------------------------------------------***
BOOL CJoltMidi::QueryForJolt(void)
{
	HRESULT hRet;

	// Sanity check
	if (g_pDataPackager == NULL) {
		ASSUME_NOT_REACHED();
		return FALSE;
	}
	if (g_pDataTransmitter == NULL) {
		ASSUME_NOT_REACHED();
		return FALSE;
	}

	// Send Shutdown command then detect if Shutdown was detected
	for (int i=0;i<MAX_RETRY_COUNT;i++)
	{
		// Send a ShutDown, then check for response
		if (g_pDataPackager->SendForceFeedbackCommand(DISFFC_RESET) != SUCCESS) {
			ASSUME_NOT_REACHED();	// Could not package?
			return FALSE;
		}
		// Get rid of unneeded delay here
		DataPacket* packet = g_pDataPackager->GetPacket(0);
		if (packet != NULL) {
			packet->m_AckNackDelay = 0;
		}
		ACKNACK ackNack;
		
		if (g_pDataTransmitter->Transmit(ackNack) != SUCCESS)	{ // Send it off
			ASSUME_NOT_REACHED();	// Inable to transmit?
			return FALSE;
		}

		Sleep(DelayParamsPtrOf()->dwShutdownDelay);	// 10 ms

		hRet = g_ForceFeedbackDevice.QueryStatus();
		if (hRet == SUCCESS) {
			break;
		}
	}

	Sleep(DelayParamsPtrOf()->dwDigitalOverdrivePrechargeCmdDelay);		

	// Clear the Previous state and turn on tri-state buffers
	LOCAL_PRODUCT_ID ProductID = {sizeof(LOCAL_PRODUCT_ID)};
	hRet = GetJoltID(&ProductID);
	if (hRet != SUCCESS) {
    	DebugOut("QueryForJolt: Driver Error. Get Jolt Status/ID\n");
		return (FALSE);
	}

	return g_ForceFeedbackDevice.IsHostReset();
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendShortMsg
// Purpose:    	Send status, channel and data.
// Parameters:
//				BYTE cStatus	-  MIDI status byte for this message
//				BYTE cData1		-  MIDI data byte for this message
//				BYTE cData2		-  2nd MIDI data byte for this message (may be 0)
// Returns:    	HRESULT
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendShortMsg(
    IN BYTE cStatus,
    IN BYTE cData1,
    IN BYTE cData2)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
/*
	g_CriticalSection.Enter();

	// For diagnostics, record the attempts at this message
	BumpShortMsgCounter();

    HRESULT retVal = SFERR_DRIVER_ERROR;
	if (g_pDataTransmitter != NULL) {
		BYTE data[3];
		data[0] = cStatus;
		data[1] = cData1;
		data[2] = cData2;
		int numBytes = 3;
		DWORD cmd = cStatus & 0xF0;
		if ((cmd == 0xC0 ) || (cmd == 0xD0)) {
			numBytes = 2;
		}
		if (g_pDataTransmitter->Send(data, numBytes)) {
			retVal = SUCCESS;
		}
	}

	g_CriticalSection.Leave();
	return retVal;
*/
}

// *** ---------------------------------------------------------------------***
// Function:   	MidiSendLongMsg
// Purpose:    	Send system exclusive message or series of short messages.
// Parameters:
//				none	- assumes m_pMidiOutInfo structure is valid
//
// Returns:    	
//				
//
// *** ---------------------------------------------------------------------***
HRESULT CJoltMidi::MidiSendLongMsg(void)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
/*
	g_CriticalSection.Enter();

// For diagnostics, record the attempts at this message
	BumpLongMsgCounter();

    HRESULT retVal = SFERR_DRIVER_ERROR;
	if (g_pDataTransmitter != NULL) {
		if (g_pDataTransmitter->Send((PBYTE)m_MidiOutInfo.MidiHdr.lpData, m_MidiOutInfo.MidiHdr.dwBufferLength)) {
			retVal = SUCCESS;
		}
	}

	::Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwLongMsgDelay);

	g_CriticalSection.Leave();
	return retVal;
*/
}

// ****************************************************************************
// *** --- Helper functions for CJoltMidi
//
// ****************************************************************************
//
#define REGSTR_VAL_FIRMWARE_PARAMS	"FirmwareParams"
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(FIRMWARE_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_FIRMWARE_PARAMS,
							  NULL, NULL,
							  (PBYTE)pFirmwareParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pFirmwareParams->dwScaleKx = DEF_SCALE_KX;
		pFirmwareParams->dwScaleKy = DEF_SCALE_KY;
		pFirmwareParams->dwScaleBx = DEF_SCALE_BX;
		pFirmwareParams->dwScaleBy = DEF_SCALE_BY;
		pFirmwareParams->dwScaleMx = DEF_SCALE_MX;
		pFirmwareParams->dwScaleMy = DEF_SCALE_MY;
		pFirmwareParams->dwScaleFx = DEF_SCALE_FX;
		pFirmwareParams->dwScaleFy = DEF_SCALE_FY;
		pFirmwareParams->dwScaleW  = DEF_SCALE_W;
	}
}

#define REGSTR_VAL_SYSTEM_PARAMS	"SystemParams"
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(SYSTEM_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_SYSTEM_PARAMS,
							  NULL, NULL,
							  (PBYTE)pSystemParams,
							  &dwcb);

		// scale them
		pSystemParams->RTCSpringParam.m_XKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_YKConstant	/= SCALE_CONSTANTS;
		pSystemParams->RTCSpringParam.m_XAxisCenter /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YAxisCenter = -pSystemParams->RTCSpringParam.m_YAxisCenter/SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YSaturation /= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_XDeadBand	/= SCALE_POSITION;
		pSystemParams->RTCSpringParam.m_YDeadBand	/= SCALE_POSITION;



		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pSystemParams->RTCSpringParam.m_Bytes		= sizeof(RTCSPRING_PARAM);
		pSystemParams->RTCSpringParam.m_XKConstant	= DEFAULT_RTC_KX;
		pSystemParams->RTCSpringParam.m_YKConstant	= DEFAULT_RTC_KY;
		pSystemParams->RTCSpringParam.m_XAxisCenter = DEFAULT_RTC_X0;
		pSystemParams->RTCSpringParam.m_YAxisCenter = DEFAULT_RTC_Y0;
		pSystemParams->RTCSpringParam.m_XSaturation = DEFAULT_RTC_XSAT;
		pSystemParams->RTCSpringParam.m_YSaturation = DEFAULT_RTC_YSAT;
		pSystemParams->RTCSpringParam.m_XDeadBand	= DEFAULT_RTC_XDBAND;
		pSystemParams->RTCSpringParam.m_YDeadBand	= DEFAULT_RTC_YDBAND;
	}
}

#define REGSTR_VAL_DELAY_PARAMS	"TimingParams"
void GetDelayParams(UINT nJoystickID, PDELAY_PARAMS pDelayParams)
{
	BOOL bFail = FALSE;

	// try to open the registry key
	HKEY hKey;
	DWORD dwcb = sizeof(DELAY_PARAMS);
	LONG lr;
	hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
	if(!hKey)
		bFail = TRUE;

	if (!bFail)
	{
		// Get Firmware Parameters
		lr = RegQueryValueEx( hKey,
							  REGSTR_VAL_DELAY_PARAMS,
							  NULL, NULL,
							  (PBYTE)pDelayParams,
							  &dwcb);

		RegCloseKey(hKey);
		if (lr != ERROR_SUCCESS)
			bFail = TRUE;
	}

	if(bFail)
	{
		// if reading from the registry fails, just use the defaults
		pDelayParams->dwBytes								= sizeof(DELAY_PARAMS);
		pDelayParams->dwDigitalOverdrivePrechargeCmdDelay	= DEFAULT_DIGITAL_OVERDRIVE_PRECHARGE_CMD_DELAY;
		pDelayParams->dwShutdownDelay						= DEFAULT_SHUTDOWN_DELAY;
		pDelayParams->dwHWResetDelay						= DEFAULT_HWRESET_DELAY;
		pDelayParams->dwPostSetDeviceStateDelay				= DEFAULT_POST_SET_DEVICE_STATE_DELAY;
		pDelayParams->dwGetEffectStatusDelay				= DEFAULT_GET_EFFECT_STATUS_DELAY;
		pDelayParams->dwGetDataPacketDelay					= DEFAULT_GET_DATA_PACKET_DELAY;
		pDelayParams->dwGetStatusPacketDelay				= DEFAULT_GET_STATUS_PACKET_DELAY;
		pDelayParams->dwGetIDPacketDelay					= DEFAULT_GET_ID_PACKET_DELAY;
		pDelayParams->dwGetStatusGateDataDelay				= DEFAULT_GET_STATUS_GATE_DATA_DELAY;
		pDelayParams->dwSetIndexDelay						= DEFAULT_SET_INDEX_DELAY;
		pDelayParams->dwModifyParamDelay					= DEFAULT_MODIFY_PARAM_DELAY;
		pDelayParams->dwForceOutDelay						= DEFAULT_FORCE_OUT_DELAY;
		pDelayParams->dwShortMsgDelay						= DEFAULT_SHORT_MSG_DELAY;
		pDelayParams->dwLongMsgDelay						= DEFAULT_LONG_MSG_DELAY;
		pDelayParams->dwDestroyEffectDelay					= DEFAULT_DESTROY_EFFECT_DELAY;
		pDelayParams->dwForceOutMod							= DEFAULT_FORCE_OUT_MOD;

		// write the defaults to the registry
		hKey = joyOpenOEMForceFeedbackKey(nJoystickID);
		if(hKey)
		{
			// Modify Registry Values
			RegSetValueEx ( hKey, REGSTR_VAL_DELAY_PARAMS, 0, REG_BINARY, (const unsigned char *)pDelayParams, sizeof(DELAY_PARAMS) );

			// Close Key
			RegCloseKey(hKey);
		}

	}
	if(pDelayParams->dwForceOutMod == 0)
		pDelayParams->dwForceOutMod = 1;
}

//#define REGSTR_VAL_JOYSTICK_PARAMS	"JoystickParams"

// ****************************************************************************
// *** --- Member functions for base class CMidiEffect
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(IN ULONG ulButtonPlayMask)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	Effect.bDurationL	= 1;				// in 2ms increments
	Effect.bDurationH	= 0;				// in 2ms increments
	Effect.bAngleL		= 0;				// 0 to 359 degrees
	Effect.bAngleH		= 0;
	Effect.bGain		= (BYTE) 100;		// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE) ulButtonPlayMask & 0x7f;
	Effect.bButtonPlayH = (BYTE) ((ulButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL= DEFAULT_JOLT_FORCE_RATE;	// 1 to 500 Hz
	Effect.bForceOutRateH=0;
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default
}


// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::CMidiEffect
// Purpose:		Constructor(s)/Destructor for CMidiEffect Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiEffect::CMidiEffect(
	IN PEFFECT pEffect,
	IN PENVELOPE pEnvelope)
{
	m_bSysExCmd 		= SYS_EX_CMD;	// SysEx Fx command
	m_bEscManufID 		= 0;			// Escape to long Manufac. ID, s/b 0
	m_bManufIDL			= (MS_MANUFACTURER_ID & 0x7f);			// Low byte
	m_bManufIDH			= ((MS_MANUFACTURER_ID >> 8) & 0x7f);	// High byte
	m_bProdID			= JOLT_PRODUCT_ID;						// Product ID
	m_bAxisMask			= X_AXIS|Y_AXIS;
	m_OpCode    		= DNLOAD_DATA | X_AXIS|Y_AXIS;	// Subcommand opcode:DNLOAD_DATA
	m_bEffectID			= NEW_EFFECT_ID;	// Default to indicate create NEW
	SetDuration(pEffect->m_Duration);
	Effect.bDurationL	= (BYTE)  (m_Duration & 0x7f);					// in 2ms increments
	Effect.bDurationH	= (BYTE) ((m_Duration >> 7 ) & 0x7f);			// in 2ms increments
	Effect.bAngleL		= (BYTE)  (pEffect->m_DirectionAngle2D & 0x7f);	// 0 to 359 degrees
	Effect.bAngleH		= (BYTE) ((pEffect->m_DirectionAngle2D >> 7 ) & 0x7f);
	Effect.bGain		= (BYTE)  (pEffect->m_Gain & 0x7f);				// 1 to 100 %
	Effect.bButtonPlayL	= (BYTE)  (pEffect->m_ButtonPlayMask & 0x7f);
	Effect.bButtonPlayH = (BYTE) ((pEffect->m_ButtonPlayMask >> 7) & 0x03);// Button 1- 9
	Effect.bForceOutRateL=(BYTE)  (pEffect->m_ForceOutputRate & 0x7f);	// 1 to 500 Hz
	Effect.bForceOutRateH=(BYTE) ((pEffect->m_ForceOutputRate >> 7 ) & 0x03);
	Effect.bPercentL    = (BYTE) ((DEFAULT_PERCENT) & 0x7f);
	Effect.bPercentH    = (BYTE) ((DEFAULT_PERCENT >> 7 ) & 0x7f);
	m_LoopCount			= 1;	// Default
	SetPlayMode(PLAY_STORE);	// Default

	// Set Envelope members
	if (pEnvelope)
	{
		m_Envelope.m_Type = pEnvelope->m_Type;
		m_Envelope.m_Attack = pEnvelope->m_Attack;
		m_Envelope.m_Sustain = pEnvelope->m_Sustain;
		m_Envelope.m_Decay = pEnvelope->m_Decay;
		m_Envelope.m_StartAmp = (ULONG) (pEnvelope->m_StartAmp);
		m_Envelope.m_SustainAmp = (ULONG) (pEnvelope->m_SustainAmp);
		m_Envelope.m_EndAmp = (ULONG) (pEnvelope->m_EndAmp);
	}

	// save the original effect params
	m_OriginalEffectParam = *pEffect;
}

// --- Destructor
CMidiEffect::~CMidiEffect()
{
	memset(this, 0, sizeof(CMidiEffect));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetDuration
// Purpose:		Sets the Duration member
// Parameters:	ULONG ulArg	- the duration
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetDuration(ULONG ulArg)
{
	if (ulArg != 0)
	{
		ulArg = (ULONG) ( (float) ulArg/TICKRATE);
		if (ulArg <= 0) ulArg = 1;
	}
	m_Duration = ulArg;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SetTotalDuration
// Purpose:		Modifies the Effect.bDurationL/H parameter for Loop Counts
// Parameters:	none
//
// Returns:		Effect.bDurationL/H is filled with total duration
// Algorithm:
//	Notes: Percentage is 1 to 10000
//	Total Duration = ((Percentage of waveform)/10000) * Duration * Loop Count
//	Example: Loop count of 1, the Percentage of waveform =10000,
//			 Total Duration = (10000/10000) * 1 * Duration
//
// ----------------------------------------------------------------------------
void CMidiEffect::SetTotalDuration(void)
{
	ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);
	ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
	Effect.bDurationL = (BYTE) ulTotalDuration & 0x7f;
	Effect.bDurationH = (BYTE) (ulTotalDuration >> 7) & 0x7f;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeEnvelope
// Purpose:		Computes the Envelope for the Effect, Loopcount in consideration
// Parameters:	none
// Returns:		none
// Algorithm:
//For our standard PERCENTAGE Envelope, set the following as default:
//m_Type = PERCENTAGE
//
// Baseline is (m_MaxAmp + m_MinAmp)/2
// m_StartAmp = 0
// m_SustainAmp = Effect.m_MaxAmp - baseline
// m_EndAmp = m_StartAmp;
// where: baseline = (Effect.m_MaxAmp + Effect.m_MinAmp)/2;
// ----------------------------------------------------------------------------
void CMidiEffect::ComputeEnvelope(void)
{
	ULONG ulTimeToSustain;
	ULONG ulTimeToDecay;

	//REVIEW: TIME vs PERCENTAGE option
	if (PERCENTAGE == m_Envelope.m_Type)
	{
		ULONG ulPercent = Effect.bPercentL + ((USHORT)Effect.bPercentH << 7);		
		ULONG ulTotalDuration = (ULONG) (((float) ulPercent/10000.0)
							 * (float) m_LoopCount
							 * (float) m_Duration );
		ulTimeToSustain = (ULONG) ((m_Envelope.m_Attack * ulTotalDuration) /100.);
		ulTimeToDecay   = (ULONG) ((m_Envelope.m_Attack + m_Envelope.m_Sustain)
								 * ulTotalDuration /100.);
	}
	else	// TIME option envelope
	{
		ulTimeToSustain = (ULONG) (m_Envelope.m_Attack);
		ulTimeToDecay   = (ULONG) (m_Envelope.m_Attack + m_Envelope.m_Sustain);
		ulTimeToSustain = (ULONG) ( (float) ulTimeToSustain/TICKRATE);
		ulTimeToDecay = (ULONG) ( (float) ulTimeToDecay/TICKRATE);

	}
		Envelope.bAttackLevel  = (BYTE) (m_Envelope.m_StartAmp & 0x7f);
		Envelope.bSustainLevel = (BYTE) (m_Envelope.m_SustainAmp & 0x7f);
		Envelope.bDecayLevel   = (BYTE) (m_Envelope.m_EndAmp & 0x7f);

		Envelope.bSustainL = (BYTE) (ulTimeToSustain & 0x7f);
		Envelope.bSustainH = (BYTE) ((ulTimeToSustain >> 7) & 0x7f);
		Envelope.bDecayL   = (BYTE) (ulTimeToDecay & 0x7f);
		Envelope.bDecayH   = (BYTE) ((ulTimeToDecay >> 7) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Returns the SubType for the Effect
// Parameters:	none
// Returns:		ULONG - DirectEffect style SubType
// Algorithm:
// ----------------------------------------------------------------------------
ULONG CMidiEffect::SubTypeOf(void)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (m_SubType == EffectTypes[i].bDeviceSubType)
			return EffectTypes[i].ulHostSubType;
	}
	return (NULL);		
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SubTypeOf
// Purpose:		Sets the SubType for the Effect
// Parameters:	ULONG - DirectEffect style SubType
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiEffect::SetSubType(ULONG ulSubType)
{
static	EFFECT_TYPE EffectTypes[] = {
		{BE_SPRING           , ET_BE_SPRING},
		{BE_SPRING_2D        , ET_BE_SPRING},
		{BE_DAMPER           , ET_BE_DAMPER},
		{BE_DAMPER_2D        , ET_BE_DAMPER},
		{BE_INERTIA          , ET_BE_INERTIA},
		{BE_INERTIA_2D       , ET_BE_INERTIA},
		{BE_FRICTION         , ET_BE_FRICTION},
		{BE_FRICTION_2D      , ET_BE_FRICTION},
		{BE_WALL             , ET_BE_WALL},
		{BE_DELAY            , ET_BE_DELAY},
		{SE_CONSTANT_FORCE   , ET_SE_CONSTANT_FORCE},
		{SE_SINE             , ET_SE_SINE},
		{SE_COSINE           , ET_SE_COSINE},
		{SE_SQUARELOW        , ET_SE_SQUARELOW},
		{SE_SQUAREHIGH       , ET_SE_SQUAREHIGH},
		{SE_RAMPUP           , ET_SE_RAMPUP},
		{SE_RAMPDOWN         , ET_SE_RAMPDOWN},
		{SE_TRIANGLEUP       , ET_SE_TRIANGLEUP},
		{SE_TRIANGLEDOWN     , ET_SE_TRIANGLEDOWN},
		{SE_SAWTOOTHUP       , ET_SE_SAWTOOTHUP},
		{SE_SAWTOOTHDOWN     , ET_SE_SAWTOOTHDOWN},
		{PL_CONCATENATE		 , ET_PL_CONCATENATE},
		{PL_SUPERIMPOSE		 , ET_PL_SUPERIMPOSE},
		{RE_ROMID1		     , ET_RE_ROMID1		 },
		{RE_ROMID2			 , ET_RE_ROMID2		 },
		{RE_ROMID3			 , ET_RE_ROMID3		 },
		{RE_ROMID4			 , ET_RE_ROMID4		 },
		{RE_ROMID5			 , ET_RE_ROMID5		 },
		{RE_ROMID6			 , ET_RE_ROMID6		 },
		{RE_ROMID7			 , ET_RE_ROMID7		 },
		{RE_ROMID8			 , ET_RE_ROMID8		 },
		{RE_ROMID9			 , ET_RE_ROMID9		 },
		{RE_ROMID10			 , ET_RE_ROMID10	 },
		{RE_ROMID11			 , ET_RE_ROMID11	 },
		{RE_ROMID12			 , ET_RE_ROMID12	 },
		{RE_ROMID13			 , ET_RE_ROMID13	 },
		{RE_ROMID14			 , ET_RE_ROMID14	 },
		{RE_ROMID15			 , ET_RE_ROMID15	 },
		{RE_ROMID16			 , ET_RE_ROMID16	 },
		{RE_ROMID17			 , ET_RE_ROMID17	 },
		{RE_ROMID18			 , ET_RE_ROMID18	 },
		{RE_ROMID19			 , ET_RE_ROMID19	 },
		{RE_ROMID20			 , ET_RE_ROMID20	 },
		{RE_ROMID21			 , ET_RE_ROMID21	 },
		{RE_ROMID22			 , ET_RE_ROMID22	 },
		{RE_ROMID23			 , ET_RE_ROMID23	 },
		{RE_ROMID24			 , ET_RE_ROMID24	 },
		{RE_ROMID25			 , ET_RE_ROMID25	 },
		{RE_ROMID26			 , ET_RE_ROMID26	 },
		{RE_ROMID27			 , ET_RE_ROMID27	 },
		{RE_ROMID28			 , ET_RE_ROMID28	 },
		{RE_ROMID29			 , ET_RE_ROMID29	 },
		{RE_ROMID30			 , ET_RE_ROMID30	 },
		{RE_ROMID31			 , ET_RE_ROMID31	 },
		{RE_ROMID32			 , ET_RE_ROMID32	 }};

	int nNumEffectTypes = sizeof(EffectTypes)/(sizeof(EFFECT_TYPE));
	for (int i=0; i<nNumEffectTypes; i++)
	{
		if (ulSubType == EffectTypes[i].ulHostSubType)
		{
			m_SubType = EffectTypes[i].bDeviceSubType;
			return;
		}
	}
	m_SubType = NULL;	
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::ComputeChecksum
// Purpose:		Computes current checksum in the m_pBuffer
// Parameters:	none
// Returns:		Midi packet block is checksummed
// Algorithm:
// ----------------------------------------------------------------------------
BYTE CMidiEffect::ComputeChecksum(PBYTE pBuffer, int nBufferSize)
{
	assert(pBuffer);
	int nStart = sizeof(SYS_EX_HDR);
	PBYTE pBytePacket = pBuffer;
	pBytePacket += nStart;
	BYTE nSum = 0;
	// Checksum only the bytes in the "Body" and s/b 7 bit checksum.
	for (int i=nStart;i < (nBufferSize-2);i++)
	{
		nSum += *pBytePacket;
		pBytePacket++;
	}
	return ((-nSum) & 0x7f);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::SendPacket
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::SendPacket(PDNHANDLE pDnloadID, int nPacketSize)
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiEffect::DestroyEffect
// Purpose:		Sends the SYS_EX Packet
// Parameters:	PDNHANDLE pDnloadID	- Pointer to DnloadID
//				int nPacketSize		- Size of SysEx packet
//
// Returns:		*pDnloadID is filled.
//				else Error code
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CMidiEffect::DestroyEffect()
{
	ASSUME_NOT_REACHED();
	return SUCCESS;
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiBehavioral
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::CMidiBehavioral
// Purpose:		Constructor(s)/Destructor for CMidiBehavioral Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiBehavioral::CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope,
				PBE_XXX pBE_XXX):CMidiEffect(pEffect, NULL)
{
	SetSubType(pEffect->m_SubType);
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
	m_MidiBufferSize = sizeof(BEHAVIORAL_SYS_EX);
}

// --- Destructor
CMidiBehavioral::~CMidiBehavioral()
{
	memset(this, 0, sizeof(CMidiBehavioral));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiBehavioral::SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for BE_XXX
	SetXConstant(pBE_XXX->m_XConstant);
	SetYConstant(pBE_XXX->m_YConstant);
	SetParam3(pBE_XXX->m_Param3);
	SetParam4(pBE_XXX->m_Param4);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiBehavioral::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiBehavioral::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PBEHAVIORAL_SYS_EX pBuf = (PBEHAVIORAL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// Behavioral params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXConstantL  	= (BYTE)  XConstant & 0x7f;
	pBuf->bXConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYConstantL  	= (BYTE)  YConstant & 0x7f;
	pBuf->bYConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;

	LONG Param3 		= (LONG) (Param3Of()  * MAX_SCALE);
	LONG Param4 		= (LONG) (Param4Of()  * MAX_SCALE);
	pBuf->bParam3L  	= (BYTE)  Param3 & 0x7f;
	pBuf->bParam3H 		= (BYTE) (Param3 >> 7 ) & 0x01;
	pBuf->bParam4L  	= (BYTE)  Param4 & 0x7f;
	pBuf->bParam4H 		= (BYTE) (Param4 >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;

	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(BEHAVIORAL_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiFriction
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::CMidiFriction
// Purpose:		Constructor(s)/Destructor for CMidiFriction Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiFriction::CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(FRICTION_SYS_EX);
}

// --- Destructor
CMidiFriction::~CMidiFriction()
{
	memset(this, 0, sizeof(CMidiFriction));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiFriction::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiFriction::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PFRICTION_SYS_EX pBuf = (PFRICTION_SYS_EX) pSysExBuffer;

	SetTotalDuration();	// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL	= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH	= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_FRICTION params
	LONG XConstant 		= (LONG) (XConstantOf() * MAX_SCALE);
	LONG YConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	pBuf->bXFConstantL  = (BYTE)  XConstant & 0x7f;
	pBuf->bXFConstantH	= (BYTE) (XConstant >> 7 ) & 0x01;
	pBuf->bYFConstantL  = (BYTE)  YConstant & 0x7f;
	pBuf->bYFConstantH	= (BYTE) (YConstant >> 7 ) & 0x01;
	pBuf->bEffectID 	=  m_bEffectID;
	pBuf->bChecksum 	= ComputeChecksum((PBYTE) pSysExBuffer,
											sizeof(FRICTION_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiWall
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::CMidiWall
// Purpose:		Constructor(s)/Destructor for CMidiWall Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiWall::CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope,
						PBE_XXX pBE_XXX):CMidiBehavioral(pEffect, NULL, pBE_XXX)
{
	m_MidiBufferSize = sizeof(WALL_SYS_EX);
}

// --- Destructor
CMidiWall::~CMidiWall()
{
	memset(this, 0, sizeof(CMidiWall));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiWall::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiWall::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PWALL_SYS_EX pBuf = (PWALL_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL		= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH		= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bButtonPlayL		= (BYTE) (Effect.bButtonPlayL & 0x7f);
	pBuf->bButtonPlayH		= (BYTE) (Effect.bButtonPlayH  & 0x7f);

	// BE_WALL params
	LONG WallType 			= (LONG) (XConstantOf());
	LONG WallConstant 		= (LONG) (YConstantOf() * MAX_SCALE);
	LONG WallAngle			= (LONG)  Param3Of();
	LONG WallDistance		= (LONG) (Param4Of() * MAX_SCALE);

	pBuf->bWallType  		= (BYTE) (WallType & 0x01);
	pBuf->bWallConstantL  	= (BYTE) (WallConstant & 0x7f);
	pBuf->bWallConstantH	= (BYTE) ((WallConstant >> 7 ) & 0x01); //+/-100
	pBuf->bWallAngleL  		= (BYTE) (WallAngle & 0x7f);			// 0 to 359
	pBuf->bWallAngleH	 	= (BYTE) ((WallAngle >> 7 ) & 0x03);
	pBuf->bWallDistance		= (BYTE) (WallDistance & 0x7f);
	pBuf->bEffectID 		=  m_bEffectID;

	pBuf->bChecksum 		= ComputeChecksum((PBYTE) pSysExBuffer,
	  									sizeof(WALL_SYS_EX));
	pBuf->bEOX				= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiRTCSpring
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::CMidiRTCSpring
// Purpose:		Constructor(s)/Destructor for CMidiRTCSpring Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiRTCSpring::CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring):CMidiEffect(NULL)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// --- Destructor
CMidiRTCSpring::~CMidiRTCSpring()
{
	memset(this, 0, sizeof(CMidiRTCSpring));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::SetEffectParams
// Purpose:		Sets parameters
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiRTCSpring::SetEffectParams(PRTCSPRING_PARAM pRTCSpring)
{
	memcpy(&m_RTCSPRINGParam, pRTCSpring, sizeof(RTCSPRING_PARAM));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiRTCSpring::GenerateSysExPacket
// Purpose:		virtual
// Parameters:	none
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiRTCSpring::GenerateSysExPacket(void)
{
	return (NULL);
}

// ****************************************************************************
// *** --- Member functions for derived class CMidiDelay
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::CMidiDelay
// Purpose:		Constructor(s)/Destructor for CMidiDelay Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiDelay::CMidiDelay(PEFFECT pEffect) : CMidiEffect(pEffect, NULL)
{
	m_SubType   = ET_BE_DELAY;		// BE Effect Type: BE_DELAY
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS | PLAY_SUPERIMPOSE;
	m_MidiBufferSize = sizeof(NOP_SYS_EX);
}

// --- Destructor
CMidiDelay::~CMidiDelay()
{
	memset(this, 0, sizeof(CMidiDelay));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiDelay::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiDelay::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PNOP_SYS_EX pBuf = (PNOP_SYS_EX) pSysExBuffer;

	pBuf->bEffectID		=  m_bEffectID;
	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->bDurationL	= (BYTE) (Effect.bDurationL & 0x7f);
	pBuf->bDurationH	= (BYTE) (Effect.bDurationH & 0x7f);
	pBuf->bChecksum		= ComputeChecksum((PBYTE) pSysExBuffer,
					 				sizeof(NOP_SYS_EX));
	pBuf->bEOX			= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}


// ****************************************************************************
// *** --- Member functions for derived class CMidiSynthesized
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::CMidiSynthesized
// Purpose:		Constructor(s)/Destructor for CMidiSynthesized Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiSynthesized::CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope,
						PSE_PARAM pParam ) : CMidiEffect(pEffect, pEnvelope)
{
	SetSubType(pEffect->m_SubType);				// SE Effect Type
//	Effect.bForceOutRateL= (BYTE) pParam->m_SampleRate & 0x7f;	// 1 to 500 Hz
//	Effect.bForceOutRateH= (BYTE) ((pParam->m_SampleRate >> 7) & 0x3);
	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);

	m_Freq		= pParam->m_Freq;				// Frequency
	m_MaxAmp	= pParam->m_MaxAmp;				// Maximum Amplitude
	// Special case a SE_CONSTANT_FORCE
	if (SE_CONSTANT_FORCE == pEffect->m_SubType)
		m_MinAmp = 0;
	else
		m_MinAmp = pParam->m_MinAmp;			// Minimum Amplitude

	m_MidiBufferSize = sizeof(SE_WAVEFORM_SYS_EX);
}

// --- Destructor
CMidiSynthesized::~CMidiSynthesized()
{
	memset(this, 0, sizeof(CMidiSynthesized));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::SetEffect
// Purpose:		Sets the common MIDI_EFFECT parameters
// Parameters:	PEFFECT pEffect
// Returns:		none
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiSynthesized::SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam,
									   ULONG ulAction)
{
	// Set the MIDI_EFFECT parameters
	SetDuration(pEffect->m_Duration);
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);

	//Set the loop count from HIWORD of ulAction
	m_LoopCount = (ulAction >> 16) & 0xffff;
	if (0 == m_LoopCount) m_LoopCount++;

	Effect.bPercentL     = (BYTE) (DEFAULT_PERCENT & 0x7f);
	Effect.bPercentH     = (BYTE) ((DEFAULT_PERCENT >> 7) & 0x7f);
	
	// set the type specific parameters for SE_xxx
	m_Freq	 = pParam->m_Freq;
	m_MaxAmp = pParam->m_MaxAmp;
	m_MinAmp = pParam->m_MinAmp;
}

// ----------------------------------------------------------------------------
// Function: 	CMidiSynthesized::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiSynthesized::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);

	// Compute total with Loop count parameter, Note: Envelope parameters are
	// adjusted according to the Loop Count parameter, if affected.
	SetTotalDuration();
	ComputeEnvelope();

	// Copy SysEx Header + m_OpCode + m_SubType + m_bEffectID + MIDI_EFFECT
	//			+ MIDI_ENVELOPE
	memcpy(pSysExBuffer,&m_bSysExCmd, (sizeof(SYS_EX_HDR)+3+sizeof(MIDI_EFFECT)+
				sizeof(MIDI_ENVELOPE)) );

	PSE_WAVEFORM_SYS_EX pBuf = (PSE_WAVEFORM_SYS_EX) pSysExBuffer;
	
	// Scale the gain, and Envelope amplitudes
	pBuf->Effect.bGain = (BYTE) (pBuf->Effect.bGain * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bAttackLevel  = (BYTE) (pBuf->Envelope.bAttackLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bSustainLevel = (BYTE) (pBuf->Envelope.bSustainLevel * MAX_SCALE) & 0x7f;
	pBuf->Envelope.bDecayLevel   = (BYTE) (pBuf->Envelope.bDecayLevel * MAX_SCALE) & 0x7f;

	// Copy the SE specific parameters
	LONG MaxAmp = (LONG) (m_MaxAmp * MAX_SCALE);
	LONG MinAmp = (LONG) (m_MinAmp * MAX_SCALE);
	pBuf->bFreqL   	= (BYTE)  (m_Freq & 0x7f);
	pBuf->bFreqH   	= (BYTE) ((m_Freq >> 7 ) & 0x03); 	// 1 to 500
	pBuf->bMaxAmpL 	= (BYTE)  (MaxAmp & 0x7f);
	pBuf->bMaxAmpH 	= (BYTE) ((MaxAmp >> 7 ) &0x01); 	// +127 to -128

	pBuf->bMinAmpL 	= (BYTE)  (MinAmp & 0x7f);
	pBuf->bMinAmpH 	= (BYTE) ((MinAmp >> 7 ) & 0x01);

	pBuf->bChecksum	= ComputeChecksum((PBYTE) pSysExBuffer,
										sizeof(SE_WAVEFORM_SYS_EX));
	pBuf->bEOX	   	= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}

// ****************************************************************************
// *** --- Member functions for derived class CUD_Waveform
//
// ****************************************************************************
//

// ----------------------------------------------------------------------------
// Function: 	CUD_Waveform::CUD_Waveform
// Purpose:		Constructor(s)/Destructor for CUD_Waveform Object
// Parameters:	
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CMidiUD_Waveform::CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray) : CMidiEffect(pEffect, NULL),
	m_pRawData(NULL)
{
	m_OpCode    = DNLOAD_DATA | X_AXIS|Y_AXIS;// Sub-command opcode: DNLOAD_DATA
	m_SubType   = ET_UD_WAVEFORM;	// Effect Type: UD_WAVEFORM

	assert(pArray);
	// Create the buffer to hold the waveform data, compress it,
	// then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	// Set a fixed maximum size
	DWORD nSize = MAX_MIDI_WAVEFORM_DATA_SIZE + 2;
	m_pArrayData = new BYTE[nSize];
//	m_pRawData = new BYTE [nSize*2];
	assert(m_pArrayData);

	ULONG NewForceRate;
	m_MidiBufferSize = SetTypeParams(ulNumVectors, pArray, &NewForceRate);

	// Copy structures to object
	memcpy(&m_Effect.m_Bytes, pEffect, sizeof(EFFECT));
	SetForceOutRate(NewForceRate);
	m_Effect.m_Gain = m_Effect.m_Gain & 0x7f;
	m_Effect.m_Duration = (ULONG) ((float) (m_Effect.m_Duration / TICKRATE));
	m_Duration = m_Effect.m_Duration;
}

// --- Destructor
CMidiUD_Waveform::~CMidiUD_Waveform()
{
	if (m_pArrayData) delete [] m_pArrayData;
	memset(this, 0, sizeof(CMidiUD_Waveform));
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetEffectParams
// Purpose:		Sets the Effect specific parameters
// Parameters:	PEFFECT pEffect
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
void CMidiUD_Waveform::SetEffectParams(PEFFECT pEffect)
{	
	// Set the MIDI_EFFECT parameters
	SetButtonPlaymask(pEffect->m_ButtonPlayMask);
	SetAxisMask(X_AXIS|Y_AXIS);
	SetDirectionAngle(pEffect->m_DirectionAngle2D);
	SetGain((BYTE) (pEffect->m_Gain));
	SetForceOutRate(pEffect->m_ForceOutputRate);	
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::SetTypeParams
// Purpose:		Sets the type specific parameters
// Parameters:	int nSize		- size of the array
//				PLONG pArray - Pointer to an ARRAY of force values
//				
// Returns:		MidiBuffer size for the packet
// Algorithm:
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate)
{	
	// Compress the buffer data then copy to this object
	// The buffer size is initially set to the number of uncompressed vectors
	// x 2 bytes, for worse-case Absolute data
	// Once the buffer is compressed, the actual size is determined
	// Also, create a temp copy so that the original unscaled data is not
	// affected.

	m_pRawData = new BYTE [nSize*2];
	if (m_pRawData == NULL)
	{
		return 0;
	}

	// Convert to -128 to +127
	for (int i=0; i<nSize; i++)
	{
		m_pRawData[i] = (BYTE) ((LONG) (pArray[i] * MAX_SCALE));		
	}

	m_NumberOfVectors = CompressWaveform(&m_pRawData[0], m_pArrayData, nSize, pNewRate);
	assert(m_NumberOfVectors <= (MAX_MIDI_WAVEFORM_DATA_SIZE));
	if (m_pRawData)
	{
		delete [] m_pRawData;
		m_pRawData = 0;
	}
	if (0 == m_NumberOfVectors)		// No room!
		return (0);
	m_MidiBufferSize = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX) + 2);
	return (m_MidiBufferSize);
}

// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::CompressWaveform
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	PBYTE pSrcArray		- Source Array pointer
//				PBYTE pDestArray 	- Dest. Array Pointer
//				int nSize			- Size in Bytes of the Source Array
//
// Returns:		int 	- Size of the compressed Array (in bytes)
// Algorithm:
// To "compress" we need to fit the entire waveform into 98 points (there is a
// FW bug that limits us to 100 points only, and we need at least two samples
// for the starting Absolute mode point.
// 1.  Determine how many points over 98.
//     nSrcSize:    Total sample size
//     nMaxSamples: Maximum samples to squeeze into = 98
//	   nOver:		nSrcSize - nMaxSamples
//	   nSkipSample:	# of points to keep before skipping one
//					= nSrcSize/nOver
//	   while ( Sample is less than nSrcSize, bump index)
//	   {
//		  if ( (index % nSkipSample) == 0)	// no remainder
//		  {
//			index++							// bump to skip the next sample
//		  }
//		  Compress the data
//	   }
//
// ----------------------------------------------------------------------------
int CMidiUD_Waveform::CompressWaveform(
	IN PBYTE pSrcArray,
	IN OUT PBYTE pDestArray,
	IN int nSrcSize,
	OUT ULONG *pNewForceRate)
{
	assert(pSrcArray && pDestArray);
	LONG nDifference;

	// 8 bits (-128 to +127) Starting Absolute Data Value
	pDestArray[0] = pSrcArray[0] & 0x3f;
	pDestArray[1] = (pSrcArray[0] >> 6) & 0x03;

//	int nMaxSamples = MAX_MIDI_WAVEFORM_DATA_SIZE;

	int nSkipSample, nSrcIndex, nDestIndex;
	int nAbsolute = 0;
	int nRelative = 0;
	//
	// Start with Finest Resolution, then reduce until # of Samples <= nMaxSamples
	//
	nSkipSample = nSrcSize;
	while (TRUE)
	{
		nSrcIndex = 0;				// 1st sample already accounted for
		nDestIndex = 2;
#ifdef _DEBUG
		g_CriticalSection.Enter();
		wsprintf(g_cMsg,"nSkipSample=%d\n",nSkipSample);
		DebugOut(g_cMsg);
		g_CriticalSection.Leave();
#endif
		while (nSrcIndex < nSrcSize)
		{
			nSrcIndex++;
			if (0 == (nSrcIndex % nSkipSample))
			{
				nSrcIndex++;			// Skip next one
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-2]);
			}
			else
				nDifference = ((char) pSrcArray[nSrcIndex]) - ((char) pSrcArray[nSrcIndex-1]);

			// make sure we do not write outside of array bounds
			if(nDestIndex > MAX_MIDI_WAVEFORM_DATA_SIZE) break;

			if (abs(nDifference) < DIFFERENCE_THRESHOLD)
			{
				pDestArray[nDestIndex] = (BYTE)((nDifference & 0x3f) | DIFFERENCE_BIT);
				nDestIndex++;
				nRelative++;
			}
			else	// Switch to Absolute Data (8 bits)
			{
				pDestArray[nDestIndex] 	 = pSrcArray[nSrcIndex] & 0x3f;
				pDestArray[nDestIndex+1] = (pSrcArray[nSrcIndex] >> 6) & 0x3;
				nDestIndex = nDestIndex+2;
				nAbsolute++;
			}
		}
		if (nDestIndex <= MAX_MIDI_WAVEFORM_DATA_SIZE) break;
		// Reduce the resolution
		if (nSkipSample < 8)
			nSkipSample--;
		else
			nSkipSample = nSkipSample/2;
		if (1 == nSkipSample) return (0);	// Sorry charlie, no room!
		nAbsolute = 0;
		nRelative = 0;
	}

	// Done
	ULONG ulOriginalForceRate = ForceOutRateOf();
//	*pNewForceRate = (ulOriginalForceRate - (ULONG) (ulOriginalForceRate * ((float) nSkipSample / (float) nSrcSize)))/nSkipSample;
	*pNewForceRate = (ULONG) ((1.0f - (1.0f/nSkipSample)) * ulOriginalForceRate);


#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "CompressWaveform: nSrcSize=%d, nSkipSample=%d, NewForceRate=%d\n",
			nSrcSize, nSkipSample, *pNewForceRate);
	DebugOut(g_cMsg);
	wsprintf(g_cMsg,"\nTotal Absolute Data:%d, Relative Data:%d", nAbsolute, nRelative);
	DebugOut(g_cMsg);
	g_CriticalSection.Leave();
#endif


#ifdef _SHOWCOMPRESS
#pragma message("Compiling with SHOWCOMPRESS")
	g_CriticalSection.Enter();
	DebugOut("CMidiUD_Waveform::CompressWaveform(..) \npSrcArray Dump (Decimal)\n");
	for (int i=0; i<nSrcSize; i++)
	{
		wsprintf(g_cMsg," %0.4ld",((char) pSrcArray[i]));
		DebugOut(g_cMsg);
	}
	DebugOut("\npDestArray Dump (HEX)\n");

	for (i=0; i<nDestIndex; i++)
	{
		wsprintf(g_cMsg," %0.4x",pDestArray[i]);
		DebugOut(g_cMsg);
	}
	g_CriticalSection.Leave();
#endif
	return (nDestIndex);
}


// ----------------------------------------------------------------------------
// Function: 	CMidiUD_Waveform::GenerateSysExPacket
// Purpose:		Builds the SysEx packet into the pBuf
// Parameters:	none
// Returns:		PBYTE	- pointer to a buffer filled with SysEx Packet
// Algorithm:
// ----------------------------------------------------------------------------
PBYTE CMidiUD_Waveform::GenerateSysExPacket(void)
{
	if(NULL == g_pJoltMidi) return ((PBYTE) NULL);
	PBYTE pSysExBuffer = g_pJoltMidi->PrimaryBufferPtrOf();
	assert(pSysExBuffer);
	// Copy SysEx Header + m_OpCode + m_SubType
	memcpy(pSysExBuffer, &m_bSysExCmd, sizeof(SYS_EX_HDR)+2 );
	PUD_WAVEFORM_SYS_EX pBuf = (PUD_WAVEFORM_SYS_EX) pSysExBuffer;

	SetTotalDuration();		// Compute total with Loop count parameter
	pBuf->Effect.bDurationL     = (BYTE) (m_Duration & 0x7f);
	pBuf->Effect.bDurationH     = (BYTE) (m_Duration >> 7) & 0x7f;		
	pBuf->Effect.bAngleL	    =  Effect.bAngleL & 0x7f;	
	pBuf->Effect.bAngleH	    =  Effect.bAngleH & 0x7f;			
	pBuf->Effect.bGain		    = (BYTE) (Effect.bGain * MAX_SCALE) & 0x7f;	
	pBuf->Effect.bButtonPlayL   =  Effect.bButtonPlayL  & 0x7f;		
	pBuf->Effect.bButtonPlayH   =  Effect.bButtonPlayH  & 0x7f;	
	pBuf->Effect.bForceOutRateL =  Effect.bForceOutRateL & 0x7f;		
	pBuf->Effect.bForceOutRateH =  Effect.bForceOutRateH & 0x7f;
	pBuf->Effect.bPercentL	    =  Effect.bPercentL & 0x7f;
	pBuf->Effect.bPercentH	    =  Effect.bPercentH & 0x7f;

	// Fill in the Array Data
	PBYTE pArray = ((PBYTE) pBuf) + UD_WAVEFORM_START_OFFSET;
	memcpy(pArray, m_pArrayData, m_NumberOfVectors);	// Already scaled!

	pBuf->bEffectID	=  m_bEffectID;
	int nArraySize  = (m_NumberOfVectors + sizeof(UD_WAVEFORM_SYS_EX));
	pSysExBuffer[nArraySize] = 0;
	pSysExBuffer[nArraySize+1] = 0;
	pSysExBuffer[nArraySize] = ComputeChecksum((PBYTE) pSysExBuffer, (nArraySize+2));
	pSysExBuffer[nArraySize+1]= MIDI_EOX;
	return ((PBYTE) pSysExBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi_obj.hpp ===
/****************************************************************************

    MODULE:     	MIDI_OBJ.HPP
	Tab Settings:	5 9

    PURPOSE:    	Header to define SWFF MIDI device objects
    
    FUNCTIONS:
        		Classes with members and methods are kept in this header file

	Version Date        Author  Comments
	0.1		10-Sep-96	MEA     original
	1.1		17-Mar-97	MEA		DX-FF mode
			21-Mar-99	waltw	Removed unreferenced UpdateJoystickParams,
								GetJoystickParams
			16-Mar-99	waltw	Add dwDeviceID param: CJoltMidi::Initialize
								and pass down food chain

****************************************************************************/
#ifndef MIDI_OBJ_SEEN
#define MIDI_OBJ_SEEN
 
#include <windows.h>
#include <mmsystem.h>
#include <assert.h>
#include "hau_midi.hpp"
#include "midi.hpp"
#include "dinput.h"
#include "vxdioctl.hpp"
#include "ffeature.h"
#include "sw_error.hpp"

#define MAX_SCALE	1.27				// 1 to 100 = 1 to 127
#define TICKRATE	2					// 2 ms per tick divisor

#define SWFF_SHAREDMEM_FILE		"SWFF_SharedMemFile"
#define SWFF_MIDIEVENT			"SWFFMidiEvent\0"
#define SWFF_SHAREDMEM_MUTEX	"SWFFSharedMemMutex\0"
#define SWFF_JOLTOUTPUTDATA_MUTEX	"SWFFJoltOutputDataMutex\0"
#define SIZE_SHARED_MEMORY 1024			// 1024 bytes
#define MUTEX_TIMEOUT	10000			// 10 seconds timeout

// spring
#define DEF_SCALE_KX	100
#define DEF_SCALE_KY	100

// damper
#define DEF_SCALE_BX	100
#define DEF_SCALE_BY	100

// inertia
#define DEF_SCALE_MX	80
#define DEF_SCALE_MY	80

// friction
#define DEF_SCALE_FX	100
#define DEF_SCALE_FY	100

// wall
#define DEF_SCALE_W		100

typedef struct _FIRMWARE_PARAMS
{
	DWORD dwScaleKx;
	DWORD dwScaleKy;
	DWORD dwScaleBx;
	DWORD dwScaleBy;
	DWORD dwScaleMx;
	DWORD dwScaleMy;
	DWORD dwScaleFx;
	DWORD dwScaleFy;
	DWORD dwScaleW;
} FIRMWARE_PARAMS, *PFIRMWARE_PARAMS;
void GetFirmwareParams(UINT nJoystickID, PFIRMWARE_PARAMS pFirmwareParams);

typedef struct _SYSTEM_PARAMS
{
	RTCSPRING_PARAM RTCSpringParam;
} SYSTEM_PARAMS, *PSYSTEM_PARAMS;
void GetSystemParams(UINT nJoystickID, PSYSTEM_PARAMS pSystemParams);


#define DEF_XY_CONST		22500
#define DEF_ROT_CONST		17272
#define DEF_SLDR_CONST		126
#define DEF_AJ_POS			4
#define DEF_AJ_ROT			2
#define DEF_AJ_SLDR			2
#define DEF_SPR_SCL			((DWORD)-256)
#define DEF_BMP_SCL			60
#define DEF_DMP_SCL			((DWORD)-3436)
#define DEF_INERT_SCL		((DWORD)-2562)
#define DEF_VEL_OFFSET_SCL	54
#define DEF_ACC_OFFSET_SCL	40
#define DEF_Y_MOT_BOOST		19661
#define DEF_X_MOT_SATURATION	254

typedef struct _JOYSTICK_PARAMS
{
	DWORD dwXYConst;
	DWORD dwRotConst;
	DWORD dwSldrConst;
	DWORD dwAJPos;
	DWORD dwAJRot;
	DWORD dwAJSldr;
	DWORD dwSprScl;
	DWORD dwBmpScl;
	DWORD dwDmpScl;
	DWORD dwInertScl;
	DWORD dwVelOffScl;
	DWORD dwAccOffScl;
	DWORD dwYMotBoost;
	DWORD dwXMotSat;
	DWORD dwReserved;
	DWORD dwMasterGain;
} JOYSTICK_PARAMS, *PJOYSTICK_PARAMS;



// Shared Memory data structure
typedef struct _SHARED_MEMORY {
	char	m_cWaterMark[MAX_SIZE_SNAME];
	ULONG	m_RefCnt;
	HANDLE	m_hMidiOut;
	MIDIINFO m_MidiOutInfo;
} SHARED_MEMORY, *PSHARED_MEMORY;


// Effect Types conversion structure
typedef struct _EFFECT_TYPE {
	ULONG	ulHostSubType;
	BYTE	bDeviceSubType;
} EFFECT_TYPE, *PEFFECT_TYPE;

//
// --- ROM Effects default parameters structure
//
typedef struct _ROM_FX_PARAM {
	ULONG	m_ROM_Id;
	ULONG	m_ForceOutputRate;
	ULONG	m_Gain;
	ULONG	m_Duration;
} ROM_FX_PARAM, *PROM_FX_PARAM;


// Structure to pass instance data from the application
//   to the low-level callback function. (Output done notification)
typedef struct callbackInstance_tag
{
    HWND                hWnd;
    HANDLE              hSelf;  
    DWORD               dwDevice;
    HMIDIOUT            hMapper;
} CALLBACKINSTANCEDATA;
typedef CALLBACKINSTANCEDATA FAR *LPCALLBACKINSTANCEDATA;

class CJoltMidi;
//	--- MIDI Effect base class
class CMidiEffect : public SYS_EX_HDR
{
 protected:
	BYTE	m_OpCode;				// Sub-command opcode: e.g. DNLOAD_DATA
	BYTE	m_SubType;				// Effect SubType: e.g. BE_SPRING
	BYTE	m_bEffectID;			// 0x7F = Create New, else valid Effect ID
	MIDI_EFFECT	Effect;
	MIDI_ENVELOPE Envelope;
	BYTE	m_bAxisMask;
	BYTE	m_bPlayMode;			// DL_PLAY_SUPERIMPOSE || DL_PLAY_SOLO
    LPSTR	m_pBuffer;				// Ptr to a Midi SYS_EX Buffer
	int		m_MidiBufferSize;		// Size of SYS_EX buffer
	int		m_LoopCount;			// Loop Count for the playback
	LONG	m_Duration;				// Atomic Effect Duration (for 1 cycle)
	ENVELOPE	m_Envelope;			// Atomic Envelope (no loop count)
	EFFECT	m_OriginalEffectParam;	// the effect param when the effect was created

 public:
	// Constructor/Destructor
	CMidiEffect(ULONG ulButtonPlayMask);
	CMidiEffect(PEFFECT pEffect, PENVELOPE pEnvelope);
	virtual ~CMidiEffect(void);

	// Methods
	ULONG	SubTypeOf(void);
	BYTE	EffectIDOf(void) { return m_bEffectID; }
	ULONG	DurationOf(void) { return m_Duration * TICKRATE; }
	BYTE	AxisMaskOf(void) { return m_bAxisMask; }
	ULONG	DirectionAngle2DOf(void) 
			{ return(Effect.bAngleL+((USHORT)Effect.bAngleH<<7));}
	BYTE	GainOf(void) { return Effect.bGain; }
	ULONG	ButtonPlayMaskOf(void) 
			{ return(Effect.bButtonPlayL+((USHORT)Effect.bButtonPlayH<<7));}
	ULONG	ForceOutRateOf(void) 
			{ return (Effect.bForceOutRateL+((USHORT)Effect.bForceOutRateH<<7));}
	ULONG	PlayModeOf(void) { 
					if (DL_PLAY_SOLO == m_bPlayMode)
						return PLAY_SOLO;
					else 
						return PLAY_SUPERIMPOSE; }

	int		MidiBufferSizeOf(void) { return m_MidiBufferSize; }
    LPSTR	LockedBufferPtrOf(void) { return m_pBuffer; }
	int		LoopCountOf(void) { return m_LoopCount; }

	PEFFECT OriginalEffectParamOf() { return &m_OriginalEffectParam; }
	ENVELOPE * EnvelopePtrOf() { return &m_Envelope; }

	void	SetSubType(ULONG ulArg);
	void	SetEffectID(BYTE bArg) { m_bEffectID = bArg; }
	void	SetDuration(ULONG ulArg);
	void	SetAxisMask(BYTE bArg) { m_bAxisMask = bArg; }
	void	SetDirectionAngle(ULONG ulArg) 
			{ Effect.bAngleL = (BYTE) ulArg & 0x7f;
			  Effect.bAngleH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetGain(BYTE bArg) { Effect.bGain = (BYTE) (bArg * MAX_SCALE); }
	void	SetButtonPlaymask(ULONG ulArg)
			{ Effect.bButtonPlayL = (BYTE) ulArg & 0x7f;
			  Effect.bButtonPlayH = (BYTE) ((ulArg >> 7) & 0x03);}
	void	SetForceOutRate(ULONG ulArg) 
			{ Effect.bForceOutRateL = (BYTE) ulArg & 0x7f;
			  Effect.bForceOutRateH = (BYTE) ((ulArg >> 7) & 0x03); }
	void	SetMidiBufferSize(int nArg) { m_MidiBufferSize = nArg; }
	void	SetMidiBufferPtr(LPSTR pArg) { m_pBuffer = pArg; }
	
	void	SetPlayMode(ULONG ulArg) { 
					if (PLAY_SOLO == ulArg) 
						m_bPlayMode = DL_PLAY_SOLO;
					else
						m_bPlayMode = DL_PLAY_SUPERIMPOSE; }

	void	SetLoopCount(ULONG ulAction) 
					{ m_LoopCount = ((ulAction >> 16) & 0xffff); }
	void	SetTotalDuration(void);
	void	SetEnvelope(PENVELOPE pArg) 
				{ m_Envelope.m_Type = pArg->m_Type;
				  m_Envelope.m_Attack = pArg->m_Attack;
				  m_Envelope.m_Sustain = pArg->m_Sustain;
				  m_Envelope.m_Decay = pArg->m_Decay;
				  m_Envelope.m_StartAmp = pArg->m_StartAmp;
				  m_Envelope.m_SustainAmp = pArg->m_SustainAmp;
				  m_Envelope.m_EndAmp = pArg->m_EndAmp; }
	void	ComputeEnvelope(void);
	BYTE  	ComputeChecksum(PBYTE pArg, int nBufferSize); 
	virtual PBYTE GenerateSysExPacket(void) = 0;
	HRESULT SendPacket(PDNHANDLE pDnloadID, int nPacketSize); 

	virtual HRESULT DestroyEffect();
};

//	--- MIDI Behavioral Effect derived class
class CMidiBehavioral : public CMidiEffect
{
 protected:
	BE_XXX	m_BE_XXXParam;	// Behavioral Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiBehavioral(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiBehavioral(void);

	// Methods
	LONG	XConstantOf(void) { return m_BE_XXXParam.m_XConstant; }
	LONG	YConstantOf(void) { return m_BE_XXXParam.m_YConstant; }
	LONG	Param3Of(void) { return m_BE_XXXParam.m_Param3; }
	LONG	Param4Of(void) { return m_BE_XXXParam.m_Param4; }

	void	SetEffectParams(PEFFECT pEffect, PBE_XXX pBE_XXX);
	void	SetXConstant(LONG lArg) { m_BE_XXXParam.m_XConstant = lArg; }
	void	SetYConstant(LONG lArg) { m_BE_XXXParam.m_YConstant = lArg; }
	void	SetParam3(LONG lArg) { m_BE_XXXParam.m_Param3 = lArg; }
	void	SetParam4(LONG lArg) { m_BE_XXXParam.m_Param4 = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Friction Effect derived class
class CMidiFriction : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiFriction(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiFriction(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Wall Effect derived class
class CMidiWall : public CMidiBehavioral
{
 protected:
 public:
	// Constructor/Destructor
	CMidiWall(PEFFECT pEffect, PENVELOPE pEnvelope, PBE_XXX pBE_XXX);
	virtual ~CMidiWall(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI RTC Spring Effect derived class
class CMidiRTCSpring : public CMidiEffect
{
 protected:
	RTCSPRING_PARAM	m_RTCSPRINGParam;	// RTCSpring Parameters (non scaled)

 public:
 // Constructor/Destructor
	CMidiRTCSpring(PRTCSPRING_PARAM pRTCSpring);
	virtual ~CMidiRTCSpring(void);

	// Methods
	LONG	XKConstantOf(void) { return m_RTCSPRINGParam.m_XKConstant; }
	LONG	YKConstantOf(void) { return m_RTCSPRINGParam.m_YKConstant; }
	LONG	XAxisCenterOf(void) { return m_RTCSPRINGParam.m_XAxisCenter; }
	LONG	YAxisCenterOf(void) { return m_RTCSPRINGParam.m_YAxisCenter; }
	LONG	XSaturationOf(void) { return m_RTCSPRINGParam.m_XSaturation; }
	LONG	YSaturationOf(void) { return m_RTCSPRINGParam.m_YSaturation; }
	LONG	XDeadBandOf(void) { return m_RTCSPRINGParam.m_XDeadBand; }
	LONG	YDeadBandOf(void) { return m_RTCSPRINGParam.m_YDeadBand; }
	void	SetEffectParams(PRTCSPRING_PARAM pRTCSpring);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Delay Effect derived class
class CMidiDelay : public CMidiEffect
{
 protected:
 public:
	// Constructor/Destructor
	CMidiDelay(PEFFECT pEffect);
	virtual ~CMidiDelay(void);

	// Methods
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI Synthesized Effect derived class
class CMidiSynthesized : public CMidiEffect
{
 protected:
	ULONG	m_Freq;			// Frequency
	LONG	m_MaxAmp;		// Maximum Amplitude
	LONG	m_MinAmp;		// Minimum Amplitude
 public:
	// Constructor/Destructor
	CMidiSynthesized(PEFFECT pEffect, PENVELOPE pEnvelope, PSE_PARAM pParam);
	virtual ~CMidiSynthesized(void);

	// Methods
	ULONG	FreqOf(void)   { return m_Freq; }
	LONG	MaxAmpOf(void) { return m_MaxAmp; }
	LONG	MinAmpOf(void) { return m_MinAmp; }

	void	SetEffectParams(PEFFECT pEffect, PSE_PARAM pParam, ULONG ulMode);
	void	SetFreq(ULONG ulArg) { m_Freq = ulArg; }
	void	SetMaxAmp(LONG lArg) { m_MaxAmp = lArg; }
	void	SetMinAmp(LONG lArg) { m_MinAmp = lArg; }
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- MIDI UD_Waveform Effect derived class
class CMidiUD_Waveform : public CMidiEffect
{
 protected:
	EFFECT  m_Effect;
	int		m_NumberOfVectors;// Size of the Array
	PBYTE	m_pArrayData;	// Pointer to an scaled (+/-127) array of forces
	PBYTE	m_pRawData;		// Pointer to unscaled array of forces

 public:
	// Constructor/Destructor
	CMidiUD_Waveform(PEFFECT pEffect);
	CMidiUD_Waveform(PEFFECT pEffect, ULONG ulNumVectors, PLONG pArray);
	virtual ~CMidiUD_Waveform(void);

	// Methods
	PEFFECT EffectPtrOf() { return (PEFFECT) &m_Effect.m_Bytes; }
	int		NumberOfVectorsOf(void) { return m_NumberOfVectors; }
	PBYTE	ArrayDataPtrOf(void) { return m_pArrayData; }
	int		CompressWaveform(PBYTE pSrcArray, PBYTE pDestArray, int nSrcSize, ULONG *pNewRate);
	void	SetEffectParams(PEFFECT pEffect);
	int		SetTypeParams(int nSize, PLONG pArray, ULONG *pNewRate);
	virtual PBYTE 	GenerateSysExPacket(void);
};

//	--- Jolt Device base class
class CJoltMidi
{
 protected:
	LOCAL_PRODUCT_ID m_ProductID;			// Device information
	FIRMWARE_PARAMS	m_FirmwareParams;	// Behavioral effect fudge factors
	DELAY_PARAMS	m_DelayParams;		// Timing parameters

	// Power Cycle Restore Thread variables
#if 0
	DWORD   m_dwThreadID;
	HANDLE  m_hDataEvent;
	HANDLE  m_hDataThread;
	DWORD	m_dwThreadSignal;
	DWORD	m_dwThreadStatus;	        // TRUE = thread is alive, else FALSE
#endif
	ULONG			m_COMMInterface;	// COMM_WINMM || COMM_MIDI_BACKDOOR || COMM_SERIAL_BACKDOOR || COMM_SERIAL_FILE
	ULONG			m_COMMPort;			// e.g. 330, 3F8, or 0 for winmm
	HANDLE			m_hVxD;				// Handle to VxD for IOCTL interface
	HANDLE  		m_hMidiOutputEvent;	// Handle to Midi Output Event
	BYTE			m_MidiChannel;		// Midi Channel
	SWFF_ERROR  	m_Error;		 	// System Error codes
	MIDIINFO 		m_MidiOutInfo;		// Midi output Info structure
	BOOL			m_ShutdownSent;		// TRUE = Last command sent was Shutdown
	DIAG_COUNTER	m_DiagCounter;		// For debugging, Diagnostics counter

	SWDEVICESTATE	m_DeviceState;
	HANDLE			m_hPrimaryBuffer;	// Handle to locked memory
	LPBYTE			m_pPrimaryBuffer;	// Pointer to the Primary buffer memory
	PROM_FX_PARAM	m_pRomFxTable;		// Default settings for ROM Effects
	HANDLE	m_hSharedMemoryFile;		// Handle to a memory mapped file
	PSHARED_MEMORY	m_pSharedMemory;	// Pointer to a Shared Memory structure
	HANDLE			m_hSWFFDataMutex;	// Local copy of Mutex handle

 public:
	// Constructor/Destructor
	CJoltMidi(void);
	~CJoltMidi(void);

	// Methods
	HANDLE SWFFDataMutexHandleOf() { return m_hSWFFDataMutex; }
	HRESULT Initialize(DWORD dwDeviceID);
#if 0
	DWORD  ThreadIDOf(void) { return m_dwThreadID; }
	HANDLE DataEventOf(void) {return m_hDataEvent; }
	HANDLE DataThreadOf(void) {return m_hDataThread; }
	DWORD  ThreadSignalOf(void) { return m_dwThreadSignal; }
	DWORD  ThreadStatusOf(void) { return m_dwThreadStatus; }
#endif

	HANDLE	MidiOutputEventHandleOf(void) { return m_hMidiOutputEvent; }
	HMIDIOUT MidiOutHandleOf(void) { return HMIDIOUT(m_pSharedMemory->m_hMidiOut); }
	UINT GetSharedMemoryReferenceCount() { return (m_pSharedMemory != NULL) ? m_pSharedMemory->m_RefCnt : 0; }
	BYTE	MidiChannelOf(void) { return m_MidiChannel; }
	void	CJoltGetLastError(SWFF_ERROR* pError)
							{ pError->HCode = m_Error.HCode;
							  pError->ulDriverCode = m_Error.ulDriverCode; }
	MIDIINFO *MidiOutInfoOf(void) { return &m_MidiOutInfo; }
	BOOL	ShutdownSentOf(void) { return m_ShutdownSent; }
	PDIAG_COUNTER DiagCounterPtrOf() { return &m_DiagCounter; }
	PBYTE	PrimaryBufferPtrOf() { return m_pPrimaryBuffer; }

	LOCAL_PRODUCT_ID* ProductIDPtrOf() { return &m_ProductID; }
	PFIRMWARE_PARAMS FirmwareParamsPtrOf() {return &m_FirmwareParams; }
	PDELAY_PARAMS DelayParamsPtrOf() {return &m_DelayParams; }
	ULONG	COMMInterfaceOf() { return m_COMMInterface; }
	ULONG	COMMPortOf() { return m_COMMPort; }

#if 0
	void 	SetThreadIDOf(DWORD dwArg) { m_dwThreadID = dwArg; }
	void 	SetDataEvent(HANDLE hArg) { m_hDataEvent = hArg; }
	void 	SetDataThread(HANDLE hArg) { m_hDataThread = hArg; }
	void 	SetThreadSignal(DWORD dwArg) { m_dwThreadSignal = dwArg; }
	void 	SetThreadStatus(DWORD dwArg) { m_dwThreadStatus = dwArg; }
	BOOL	LockJoltOutputData(void);
	void	UnlockJoltOutputData(void);
#endif

	BOOL	LockSharedMemory(void);
	void	UnlockSharedMemory(void);

	void	SetSWFFDataMutexHandle(HANDLE hArg) { m_hSWFFDataMutex = hArg;}
	void 	SetMidiOutHandle(HMIDIOUT hArg) { LockSharedMemory();
											  m_pSharedMemory->m_hMidiOut = hArg;
											  UnlockSharedMemory();}
	void	SetMidiChannel(BYTE nArg) { m_MidiChannel = nArg; }
	void	SetShutdownSent(BOOL bArg) { m_ShutdownSent = bArg; }
	void	ClearDiagCounters(void) { m_DiagCounter.m_NACKCounter = 0;
									  m_DiagCounter.m_LongMsgCounter = 0; 
									  m_DiagCounter.m_ShortMsgCounter = 0;
									  m_DiagCounter.m_RetryCounter = 0; }
	void	BumpNACKCounter(void) { m_DiagCounter.m_NACKCounter++; }
	void	BumpLongMsgCounter(void) { m_DiagCounter.m_LongMsgCounter++; }
	void	BumpShortMsgCounter(void) { m_DiagCounter.m_ShortMsgCounter++; }
	void	BumpRetryCounter(void) { m_DiagCounter.m_RetryCounter++; }

	HRESULT	LogError(HRESULT hSystemError, HRESULT DriverError);

	SWDEVICESTATE GetSWDeviceStateNoUpdate() const { return m_DeviceState; } 

	void	UpdateDeviceMode(ULONG ulMode);
	HRESULT GetJoltID(LOCAL_PRODUCT_ID* pProductID);

	// Midi management
	BOOL	DetectMidiDevice(DWORD dwDeviceID, ULONG *pCOMMPort);

	HRESULT MidiSendShortMsg(BYTE cStatus, BYTE cData1,BYTE cData2);
	HRESULT MidiSendLongMsg(void);
	
	// Response from Jolt management
	HRESULT GetAckNackData(int nTimeWait, PACKNACK pAckNack, USHORT ackMethod);
	BOOL	QueryForJolt(void);

	// Digital OverDrive interface
	HRESULT	InitDigitalOverDrive(DWORD dwDeviceID);
	HANDLE	VxDHandleOf(void) { return m_hVxD; }

	// ROM Effects
	HRESULT SetupROM_Fx(PEFFECT pEffect);

	// Thread
//	HRESULT PowerCycleThreadCreate(void);
};

#endif    // of ifndef MIDI_OBJ_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_cfact.hpp ===
/****************************************************************************

    MODULE:     	SW_CFACT.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definitions, classes, and prototypes for a DLL that
    				provides Effect objects to any other object user.

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce	
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#ifndef _SW_CFACT_SEEN
#define _SW_CFACT_SEEN


//Get the object definitions
#include "SW_objec.hpp"

void ObjectDestroyed(void);

//SW_CFACT.CPP
//This class factory object creates DirectInputEffectDriver objects.

class CDirectInputEffectDriverClassFactory : public IClassFactory
{
 protected:
 	ULONG           m_cRef;

 public:
    CDirectInputEffectDriverClassFactory(void);
    ~CDirectInputEffectDriverClassFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                             , PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};

typedef CDirectInputEffectDriverClassFactory *PCDirectInputEffectDriverClassFactory;

#endif //_SW_CFACT_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\midi_out.cpp ===
/****************************************************************************

    MODULE:     	MIDI_OUT.CPP
	Tab stops 5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Uses a low-level callback function to get timestamped 
    				MIDI output. The callback function sets an Event to indicate
    				to wake up a blocked object.
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			10-Jan-97	MEA     original

****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <crtdbg.h>
#include "midi_obj.hpp"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
extern char g_cMsg[160];
#endif


// Prototypes
void CALLBACK midiOutputHandler(HMIDIOUT, UINT, DWORD, DWORD, DWORD);



// ----------------------------------------------------------------------------
// Function: 	midiOutputHandler
// Purpose:		
// Parameters:	hMidiIn - Handle for the associated output device.
//				wMsg - One of the MIM_***** messages.
//				dwInstance - Points to CALLBACKINSTANCEDATA structure.
//				dwParam1 - MIDI data.
//				dwParam2 - Timestamp (in milliseconds)
//
// Returns:		none
// Algorithm:
// Comments:
//		Low-level callback function to handle MIDI output.
//      Installed by midiOutOpen().  The Output handler checks for MM_MOM_DONE
//		message and wakes up the thread waiting for completion of MIDI SysEx 
//		output.  Note: Normal Short messages don't get notification!!!
//      This function is accessed at interrupt time, so it should be as 
//      fast and efficient as possible.  You can't make any
//      Windows calls here, except PostMessage().  The only Multimedia
//      Windows call you can make are timeGetSystemTime(), midiOutShortMsg().
// ----------------------------------------------------------------------------
void CALLBACK midiOutputHandler(
	IN HMIDIOUT hMidiOut, 
	IN UINT wMsg, 
	IN DWORD dwInstance, 
	IN DWORD dwParam1, 
	IN DWORD dwParam2)
{
	CJoltMidi *pJoltMidi = (CJoltMidi *) dwInstance;
	assert(pJoltMidi);
	BOOL bRet;
    
	switch(wMsg)
    {
        case MOM_OPEN:
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "midiOutputHandler: MOM_OPEN.\n");
#endif
            break;

        case MM_MOM_DONE:
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "midiOutputHandler: MM_MOM_DONE\n");
#endif
			// Notify task waiting on this object to trigger
			bRet = SetEvent(pJoltMidi->MidiOutputEventHandleOf());
			assert(bRet);
            break;

        default:
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "midiOutputHandler: default case.\n");
#endif
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swff_pro.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\registry.cpp ===
//@doc
/******************************************************
**
** @module REGISTRY.CPP | Implementation of Registry class
**
** Description:
**
** History:
**	Created 12/16/97 Matthew L. Coill (mlc)
**
** (c) 1986-1997 Microsoft Corporation. All Rights Reserved.
******************************************************/

#include "Registry.h"
#include <TCHAR.h>

UnassignableRegistryKey c_InvalidKey(NULL);

/***************** RegistryKey  class ********************/

/******************************************************
**
** RegistryKey::RegistryKey(RegistryKey& rkey)
**
** @mfunc Constructor.
**
******************************************************/
RegistryKey::RegistryKey(RegistryKey& rkey)
{
	if (rkey.m_pReferenceCount == NULL) {
		rkey.m_pReferenceCount = new UINT;
		if (rkey.m_pReferenceCount != NULL)
		{
			*(rkey.m_pReferenceCount) = 1;
		}
	}

	m_pReferenceCount = rkey.m_pReferenceCount;
	if (m_pReferenceCount != NULL)
	{
		++(*m_pReferenceCount);
	}
	m_OSRegistryKey = rkey.m_OSRegistryKey;
	m_ShouldClose = rkey.m_ShouldClose;
}

/******************************************************
**
** RegistryKey::~RegistryKey()
**
** @mfunc Destructor.
**
******************************************************/
RegistryKey::~RegistryKey()
{
	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}
	m_OSRegistryKey = NULL;
	m_pReferenceCount = NULL;
}

/******************************************************
**
** RegistryKey::operator=(RegistryKey& rhs)
**
** @mfunc operator=.
**
******************************************************/
RegistryKey& RegistryKey::operator=(RegistryKey& rhs)
{
	if (&rhs == this) {
		return *this;
	}

	if (rhs.m_pReferenceCount == NULL) {
		rhs.m_pReferenceCount = new UINT;
		if (rhs.m_pReferenceCount == NULL)
		{
			return *this;
		}
			*(rhs.m_pReferenceCount) = 1;
	}

	if (m_pReferenceCount != NULL) {
		if (--(*m_pReferenceCount) == 0) {
			delete m_pReferenceCount;
			m_pReferenceCount = NULL;
		}
	}
	if ((m_OSRegistryKey != NULL) && (m_ShouldClose) && (m_pReferenceCount == NULL)) {
		::RegCloseKey(m_OSRegistryKey);
	}

	m_pReferenceCount = rhs.m_pReferenceCount;
	m_OSRegistryKey = rhs.m_OSRegistryKey;
	m_ShouldClose = rhs.m_ShouldClose;

	++(*m_pReferenceCount);

	return *this;
}

/******************************************************
**
** RegistryKey::operator==(RegistryKey& comparee)
**
** @mfunc operator==.
**
******************************************************/
BOOL RegistryKey::operator==(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey == m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::operator!=(RegistryKey& comparee)
**
** @mfunc operator!=.
**
******************************************************/
BOOL RegistryKey::operator!=(const RegistryKey& comparee)
{
	return (comparee.m_OSRegistryKey != m_OSRegistryKey);
}

/******************************************************
**
** RegistryKey::CreateSubKey()
**
** @mfunc CreateSubKey.
**
******************************************************/
RegistryKey RegistryKey::CreateSubkey(const TCHAR* subkeyName, const TCHAR* typeName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	DWORD creationInfo;
	HRESULT hr = ::RegCreateKeyEx(m_OSRegistryKey, subkeyName, 0, (TCHAR*)typeName, REG_OPTION_NON_VOLATILE, /*KEY_READ*/ ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER), NULL, &newKey, &creationInfo);
	if (newKey == NULL) {
		TCHAR msg[512];
		::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, msg, 512, NULL);
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenSubkey()
**
** @mfunc OpenSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenSubkey(const TCHAR* subkeyName, REGSAM access)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return c_InvalidKey;
	}

	HKEY newKey = NULL;
	HRESULT hr = ::RegOpenKeyEx(m_OSRegistryKey, subkeyName, 0, access, &newKey);
	if (newKey == NULL) {
		return c_InvalidKey;
	}
	RegistryKey newRegistryKey(newKey);
	newRegistryKey.m_ShouldClose = TRUE;
	return newRegistryKey;
}

/******************************************************
**
** RegistryKey::OpenCreateSubkey()
**
** @mfunc OpenCreateSubkey.
**
******************************************************/
RegistryKey RegistryKey::OpenCreateSubkey(const TCHAR* subkeyName)
{
	RegistryKey key = OpenSubkey(subkeyName, KEY_READ | KEY_WRITE);
	if (key == c_InvalidKey) {
		key = CreateSubkey(subkeyName);
	}
	return key;
}

/******************************************************
**
** RegistryKey::RemoveSubkey()
**
** @mfunc RemoveSubkey.
**
******************************************************/
HRESULT RegistryKey::RemoveSubkey(const TCHAR* subkeyName)
{
	if ((m_OSRegistryKey == NULL) || (subkeyName == NULL) || (subkeyName[0] == '\0') || (subkeyName[0] == '\\')) {
		return E_FAIL;
	}
	return ::RegDeleteKey(m_OSRegistryKey, subkeyName);
}

/******************************************************
**
** RegistryKey::GetNumSubKeys()
**
** @mfunc RemoveSubkey.
**
******************************************************/
DWORD RegistryKey::GetNumSubkeys() const
{
	if (m_OSRegistryKey == NULL) {
		return 0;
	}

	DWORD numSubKeys = 0;
	::RegQueryInfoKey(m_OSRegistryKey, NULL, NULL, NULL, &numSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	return numSubKeys;
}

/******************************************************
**
** RegistryKey::QueryValue(const TCHAR* valueName, (BYTE*)& pEntryData, UINT& dataSize)
**
** @mfunc QueryValue(const.
**
******************************************************/
HRESULT RegistryKey::QueryValue(const TCHAR* valueName, BYTE* pEntryData, DWORD& dataSize)
{
	if ((m_OSRegistryKey == NULL) || (pEntryData == NULL)) {
		return E_FAIL;
	}

	DWORD dataType;
	HRESULT hr = ::RegQueryValueEx(m_OSRegistryKey, valueName, NULL, &dataType, pEntryData, &dataSize);

	return hr;
}

/******************************************************
**
** RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
**
** @mfunc SetValue.
**
******************************************************/
HRESULT RegistryKey::SetValue(const TCHAR* valueName, const BYTE* pData, DWORD dataSize, DWORD dataType)
{
	if (m_OSRegistryKey == NULL) {
		return E_FAIL;
	}

	HRESULT hr = ::RegSetValueEx(m_OSRegistryKey, valueName, 0, dataType, pData, dataSize);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\swd_guid.cpp ===
/****************************************************************************

    MODULE:         SWD_GUID.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPODE:    	Instantiate GUIDS
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce

****************************************************************************/
#ifdef   WIN32
#define  INITGUIDS
#include <objbase.h>
#else
#include <memory.h>
#include <string.h>
#include <compobj.h>
#endif
#include <initguid.h>
#include "dinput.h"
#include "dinputd.h"
#include "SWD_Guid.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_globs.cpp ===
/****************************************************************************

    MODULE:     	SW_GLOBS.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	SW_WHEEL Global Variables
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.1    		15-May-97   MEA     original
				21-Mar-99	waltw	Removed unreferenced globals & updated szDeviceName

****************************************************************************/
#include <windows.h>
#include "midi_obj.hpp"

//
// Globals
//

#ifdef _DEBUG
char g_cMsg[160];
TCHAR szDeviceName[MAX_SIZE_SNAME] = {"Microsoft SideWinder Force Feedback Pro"};
#endif

// 
// *** Global on per process space only
//
CJoltMidi *g_pJoltMidi = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_cfact.cpp ===
/****************************************************************************

    MODULE:     	SW_CFact.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Class Object structured in a DLL server.
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver

****************************************************************************/
#include "SW_CFact.hpp"
#include "SWD_Guid.hpp"

// Needed for auto registration
#include "Registry.h"
#include "CritSec.h"
#include "olectl.h"	// Self Reg errors

// Define CriticalSection object for everyone
CriticalSection g_CriticalSection;

//
// Global Data
//
ULONG       g_cObj=0;	//Count number of objects and number of locks.
ULONG       g_cLock=0;
HINSTANCE	g_MyInstance = NULL;

//
// External Functions
//

//
// Internal Function Prototypes
//


//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif

#define BUFSIZE 80


/*
 * LibMain(32)
 *
 * Purpose:
 *  Entry point provides the proper structure for each environment.
 */

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	switch (ulReason)
    {
		case DLL_PROCESS_ATTACH: {
            //
            // DLL is attaching to the address space of the current process.
            //
            g_MyInstance = hInstance;
#ifdef _DEBUG
			_RPT0(_CRT_WARN, "SW_WHEEL.DLL: DLL_PROCESS_ATTACH\r\n");
#endif
           	return (TRUE);
		}
		case DLL_THREAD_ATTACH:
     	//
     	// A new thread is being created in the current process.
     	//
#ifdef _DEBUG
            _RPT0(_CRT_WARN, "SW_WHEEL.DLL: DLL_THREAD_ATTACH\r\n");
#endif
	   		break;

       	case DLL_THREAD_DETACH:
     	//
     	// A thread is exiting cleanly.
     	//
#ifdef _DEBUG
            _RPT0(_CRT_WARN, "SW_WHEEL.dll: DLL_THREAD_DETACH\r\n");
#endif
     		break;

		case DLL_PROCESS_DETACH:
    	//
    	// The calling process is detaching the DLL from its address space.
    	//
#ifdef _DEBUG
            _RPT0(_CRT_WARN, "SW_WHEEL.dll: DLL_PROCESS_DETACH\r\n");
#endif
			break;
	}
   return(TRUE);
}

// ----------------------------------------------------------------------------
// Function: 	DllGetClassObject
//
// Purpose:		Provides an IClassFactory for a given CLSID that this DLL is
//				registered to support.  This DLL is placed under the CLSID
//				in the registration database as the InProcServer.
//
// Parameters:  REFCLSID clsID	- REFCLSID that identifies the class factory
//                				  desired.  Since this parameter is passed this
//                				  DLL can handle any number of objects simply
//                				  by returning different class factories here
//                				  for different CLSIDs.
//
//				REFIID riid     - REFIID specifying the interface the caller 
//				                  wants on the class object, usually 
//								  IID_ClassFactory.
//
//				PPVOID ppv      - PPVOID in which to return the interface ptr.
//
// Returns:		HRESULT         NOERROR on success, otherwise an error code.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT             hr;
    CDirectInputEffectDriverClassFactory *pObj;

#ifdef _DEBUG
    _RPT0(_CRT_WARN, "SW_WHEEL.dll: DllGetClassObject()\r\n");
#endif                 
    if (CLSID_DirectInputEffectDriver !=rclsid) return ResultFromScode(E_FAIL);

    pObj=new CDirectInputEffectDriverClassFactory();

    if (NULL==pObj) return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))	delete pObj;
    return hr;
}


// ----------------------------------------------------------------------------
// Function: 	DllCanUnloadNow
//
// Purpose:		Answers if the DLL can be freed, that is, if there are no
//				references to anything this DLL provides.
//				
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //Our answer is whether there are any object or locks
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}


// ----------------------------------------------------------------------------
// Function: 	ObjectDestroyed
//
// Purpose:		Function for the DirectInputEffectDriver object to call when it gets destroyed.
//				Since we're in a DLL we only track the number of objects here,
//				letting DllCanUnloadNow take care of the rest.
//
// Parameters:  none
//
// Returns:		BOOL            TRUE if nothing is using us, FALSE otherwise.
// Algorithm:
// ----------------------------------------------------------------------------
void ObjectDestroyed(void)
{
    g_cObj--;
    return;
}

// ----------------------------------------------------------------------------
// Function: 	DllRegisterServer
//
// Purpose:		Auto-magically puts default entries into registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
	// Register CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}
	// -- If the key is there get it (else Create)
	RegistryKey driverKey = clsidKey.OpenCreateSubkey(CLSID_DirectInputEffectDriver_String);
	// -- Set value (if valid key)
	if (driverKey != c_InvalidKey) {
		driverKey.SetValue(NULL, (BYTE*)DRIVER_OBJECT_NAME, sizeof(DRIVER_OBJECT_NAME)/sizeof(TCHAR), REG_SZ);
		RegistryKey inproc32Key = driverKey.OpenCreateSubkey(TEXT("InProcServer32"));
		if (inproc32Key != c_InvalidKey) {
			TCHAR fileName[MAX_PATH];
			DWORD nameSize = ::GetModuleFileName(g_MyInstance, fileName, MAX_PATH);
			if (nameSize > 0) {
				fileName[nameSize] = '\0';
				inproc32Key.SetValue(NULL, (BYTE*)fileName, sizeof(fileName)/sizeof(TCHAR), REG_SZ);
			}
			inproc32Key.SetValue(TEXT("ThreadingModel"), (BYTE*)THREADING_MODEL_STRING, sizeof(THREADING_MODEL_STRING)/sizeof(TCHAR), REG_SZ);
		}
		// NotInsertable ""
		RegistryKey notInsertableKey = driverKey.OpenCreateSubkey(TEXT("NotInsertable"));
		if (notInsertableKey != c_InvalidKey) {
			notInsertableKey.SetValue(NULL, (BYTE*)TEXT(""), sizeof(TEXT(""))/sizeof(TCHAR), REG_SZ);
		}
		// ProgID "Sidewinder ForceFeedback blah blah2.0"
		RegistryKey progIDKey = driverKey.OpenCreateSubkey(TEXT("ProgID"));
		if (progIDKey != c_InvalidKey) {
			progIDKey.SetValue(NULL, (BYTE*)PROGID_NAME, sizeof(PROGID_NAME)/sizeof(TCHAR), REG_SZ);
		}
		// VersionIndpendentProgID "Sidewinder ForceFeedback blah blah"
		RegistryKey progIDVersionlessKey = driverKey.OpenCreateSubkey(TEXT("VersionIndpendentProgID"));
		if (progIDVersionlessKey != c_InvalidKey) {
			progIDVersionlessKey.SetValue(NULL, (BYTE*)PROGID_NOVERSION_NAME, sizeof(PROGID_NOVERSION_NAME)/sizeof(TCHAR), REG_SZ);
		}
	} else {
		return SELFREG_E_CLASS;
	}

	// Made it here valid driver key
	return S_OK;
}

// ----------------------------------------------------------------------------
// Function: 	DllUnregisterServer
//
// Purpose:		Auto-magically removed default entries from registry
//
// Parameters:	NONE
//
// Returns:		HRESULT - S_OK on success.
// ----------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
	// Unregister CLSID for DIEffectDriver
	// -- Get HKEY_CLASSES_ROOT\CLSID key
	RegistryKey classesRootKey(HKEY_CLASSES_ROOT);
	RegistryKey clsidKey = classesRootKey.OpenSubkey(TEXT("CLSID"), KEY_READ | KEY_WRITE);
	if (clsidKey == c_InvalidKey) {
		return E_UNEXPECTED;	// No CLSID key????
	}

	DWORD numSubKeys = 0;
	{	// driverKey Destructor will close the key
		// -- If the key is there get it, else we don't have to remove it
		RegistryKey driverKey = clsidKey.OpenSubkey(CLSID_DirectInputEffectDriver_String);
		if (driverKey != c_InvalidKey) {	// Is it there
			driverKey.RemoveSubkey(TEXT("InProcServer32"));
			driverKey.RemoveSubkey(TEXT("NotInsertable"));
			driverKey.RemoveSubkey(TEXT("ProgID"));
			driverKey.RemoveSubkey(TEXT("VersionIndpendentProgID"));
			numSubKeys = driverKey.GetNumSubkeys();
		} else {	// Key is not there (I guess removal was successful)
			return S_OK;
		}
	}

	if (numSubKeys == 0) {
		return clsidKey.RemoveSubkey(CLSID_DirectInputEffectDriver_String);
	}

	// Made it here valid driver key
	return S_OK;
}


/*
 * CVIObjectClassFactory::CVIObjectClassFactory
 * CVIObjectClassFactory::~CVIObjectClassFactory
 *
 * Constructor Parameters:
 *  None
 */

CDirectInputEffectDriverClassFactory::CDirectInputEffectDriverClassFactory(void)
{
    m_cRef=0L;
    return;
}

CDirectInputEffectDriverClassFactory::~CDirectInputEffectDriverClassFactory(void)
{
    return;
}




/*
 * CDirectInputEffectDriverClassFactory::QueryInterface
 * CDirectInputEffectDriverClassFactory::AddRef
 * CDirectInputEffectDriverClassFactory::Release
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;
    if (IID_IUnknown==riid || IID_IClassFactory==riid) *ppv=this;
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
    	return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDirectInputEffectDriverClassFactory::Release(void)
{
    if (0L!=--m_cRef) return m_cRef;
    delete this;
    return 0L;
}

/*
 * CDirectInputEffectDriverClassFactory::CreateInstance
 *
 * Purpose:
 *  Instantiates a DirectInputEffectDriver object returning an interface pointer.
 *
 * Parameters:
 *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
 *                  being used in an aggregation.
 *  riid            REFIID identifying the interface the caller
 *                  desires to have for the new object.
 *  ppvObj          PPVOID in which to store the desired
 *                  interface pointer for the new object.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
 *                  if we cannot support the requested interface.
 */

STDMETHODIMP CDirectInputEffectDriverClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, 
    REFIID riid, PPVOID ppvObj)
{
    PCDirectInputEffectDriver       pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    //Verify that a controlling unknown asks for IUnknown
    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    pObj=new CDirectInputEffectDriver(pUnkOuter, ObjectDestroyed);

    if (NULL==pObj) return hr;

    if (pObj->Init()) hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))	
    	delete pObj;
    else
        g_cObj++;
    return hr;
}


/*
 * CDirectInputEffectDriverClassFactory::LockServer
 *
 * Purpose:
 *  Increments or decrements the lock count of the DLL.  If the
 *  lock count goes to zero and there are no objects, the DLL
 *  is allowed to unload.  See DllCanUnloadNow.
 *
 * Parameters:
 *  fLock           BOOL specifying whether to increment or
 *                  decrement the lock count.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */
STDMETHODIMP CDirectInputEffectDriverClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        g_cLock++;
    else
        g_cLock--;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_error.hpp ===
/****************************************************************************

    MODULE:     	SW_Error.HPP
	Tab settings: 	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header for Error Codes
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version Date            Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    	22-Jan-96       MEA     original

****************************************************************************/
#ifndef SW_Error_SEEN
#define SW_Error_SEEN

#include <winerror.h>
#include <windows.h>
#include <mmsystem.h>

typedef struct _SWFF_ERROR {
	HRESULT	HCode;			// HRESULT code
	ULONG	ulDriverCode;	// Error code from device driver
} SWFF_ERROR, *PSWFF_ERROR;

//---------------------------------------------------------------------------
// Error Status Codes
//---------------------------------------------------------------------------
/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */

// SWForce Errors
#define MAKE_FF_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

#define MAKE_FF_E( err )  (MAKE_FF_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_FF_S( warn ) (MAKE_FF_SCODE( 0, FACILITY_ITF, warn ))

#define DINPUT_DRIVER_ERR_BASE	0x500

#define SUCCESS					0x00										// successful
#define SFERR_INVALID_OBJECT		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 1)	// Invalid object ID
#define SFERR_INVALID_PARAM			DIERR_INVALIDPARAM						// Invalid parameters
#define SFERR_NO_SUPPORT			DIERR_UNSUPPORTED						// Function not supported
#define SFERR_INVALID_DEVICE		DIERR_DEVICENOTREG						// Device not found
#define	SFERR_FFDEVICE_MEMORY		DIERR_DEVICEFULL						// Out of download RAM
#define SFERR_END_OF_LIST			MAKE_FF_S(DINPUT_DRIVER_ERR_BASE + 6)	// End of the list
#define SFERR_DEVICE_NACK			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 7)	// Device NACK received
#define SFERR_INVALID_STRUCT_SIZE 	DIERR_INVALIDPARAM						// Invalid structure passed
#define SFERR_EFFECT_NOT_IN_DEVICE 	DIERR_NOTDOWNLOADED					// Effect was not downloaded, so
																			// cannot unload.
#define SFERR_RAW_OUT_DATAEVENT_CREATION 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 10)	// Could not create Event
#define SFERR_RAW_OUT_THREAD_CREATION 		MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 11)	// Could not create a thread
#define SFERR_EFFECT_STATUS_BUSY DIERR_EFFECTPLAYING								// Device busy playing Effect
#define SFERR_OUT_OF_FF_MEMORY		DIERR_OUTOFMEMORY								// FF system has run out of memory
																					//  cannot create new Effect
#define SFERR_SYSTEM_INIT			MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 14)	// Could not create SWForce
#define SFERR_DRIVER_ERROR      	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 15)  // Driver error detected
#define SFERR_NON_FF_DEVICE     	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 16)  // This is a non-FF device, driver not found
#define SFERR_INVALID_HAL_OBJECT 	MAKE_FF_E(DINPUT_DRIVER_ERR_BASE + 17)	// HAL cannot emulate this object
#define SFERR_INVALID_MEMBER_VALUE 	DIERR_INVALIDPARAM						// Data structure has invalid member value

// VFX_ error codes
#define VFX_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 100
#define VFX_ERR_FILE_NOT_FOUND				HRESULT_FROM_WIN32(MMIOERR_FILENOTFOUND)
#define VFX_ERR_FILE_OUT_OF_MEMORY			DIERR_OUTOFMEMORY
#define VFX_ERR_FILE_CANNOT_OPEN			HRESULT_FROM_WIN32(MMIOERR_CANNOTOPEN)
#define VFX_ERR_FILE_CANNOT_CLOSE			HRESULT_FROM_WIN32(MMIOERR_CANNOTCLOSE)
#define VFX_ERR_FILE_CANNOT_READ			HRESULT_FROM_WIN32(MMIOERR_CANNOTREAD)
#define VFX_ERR_FILE_CANNOT_WRITE			HRESULT_FROM_WIN32(MMIOERR_CANNOTWRITE)
#define VFX_ERR_FILE_CANNOT_SEEK			HRESULT_FROM_WIN32(MMIOERR_CANNOTSEEK)
#define VFX_ERR_FILE_UNKNOWN_ERROR			MAKE_FF_E(VFX_ERR_BASE + 8)
#define VFX_ERR_FILE_BAD_FORMAT				MAKE_FF_E(VFX_ERR_BASE + 9)
#define VFX_ERR_FILE_ACCESS_DENIED			HRESULT_FROM_WIN32(MMIOERR_ACCESSDENIED)
#define VFX_ERR_FILE_SHARING_VIOLATION		HRESULT_FROM_WIN32(MMIOERR_SHARINGVIOLATION)
#define VFX_ERR_FILE_NETWORK_ERROR			HRESULT_FROM_WIN32(MMIOERR_NETWORKERROR)
#define VFX_ERR_FILE_TOO_MANY_OPEN_FILES	HRESULT_FROM_WIN32(MMIOERR_TOOMANYOPENFILES)
#define VFX_ERR_FILE_INVALID				HRESULT_FROM_WIN32(MMIOERR_INVALIDFILE)
#define VFX_ERR_FILE_END_OF_FILE			MAKE_FF_E(VFX_ERR_BASE + 15)

// SideWinder Driver Error codes
#define SWDEV_ERR_BASE						DINPUT_DRIVER_ERR_BASE + 200
#define SWDEV_ERR_INVALID_ID				MAKE_FF_E(SWDEV_ERR_BASE + 1)  // Invalid Download ID
#define SWDEV_ERR_INVALID_PARAM				MAKE_FF_E(SWDEV_ERR_BASE + 2)  // Invalid Download Parameter
#define SWDEV_ERR_CHECKSUM					MAKE_FF_E(SWDEV_ERR_BASE + 3)  // Invalid Checksum in COMM Packet
#define SWDEV_ERR_TYPE_FULL					MAKE_FF_E(SWDEV_ERR_BASE + 4)  // No More RAM space for Effect Type
#define SWDEV_ERR_UNKNOWN_CMD				MAKE_FF_E(SWDEV_ERR_BASE + 5)  // Unrecognized Device command
#define SWDEV_ERR_PLAYLIST_FULL				MAKE_FF_E(SWDEV_ERR_BASE + 6)  // Play List is full, cannot play any more Effects
#define SWDEV_ERR_PROCESSLIST_FULL			MAKE_FF_E(SWDEV_ERR_BASE + 7)  // Process List is full, cannot download 


#endif // of ifndef SW_Error_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\swd_guid.hpp ===
/****************************************************************************

    MODULE:     	SWD_GUID.HPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:            CLSIDs and IIDs defined for DirectInputForce

    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan
		MLD		Michael L. Day

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver
	2.0			29-Jun-98	MLD		Added Saitek Modification

****************************************************************************/
#ifndef _SWD_GUID_SEEN
#define _SWD_GUID_SEEN

#ifdef INITGUIDS
#include <initguid.h>
#endif //INITGUIDS


/*
 * GUIDs
 *
 */

#ifdef SAITEK

//
// --- Saitek Force Feedback Device Driver Interface
//
DEFINE_GUID(CLSID_DirectInputEffectDriver, /* {0A98BE81-0F6D-11d2-BCE0-0000F8757F9F} */
	0xa98be81,
	0xf6d,
	0x11d2,
	0xbc, 0xe0, 0x0, 0x0, 0xf8, 0x75, 0x7f, 0x9f
);


// For use in creating registry
#define CLSID_DirectInputEffectDriver_String TEXT("{0A98BE81-0F6D-11d2-BCE0-0000F8757F9F}")
#define DRIVER_OBJECT_NAME TEXT("Saitek Force Feedback Effect Driver Object")
#define PROGID_NAME TEXT("Saitek Force Feedback Effect Driver 2.0")
#define PROGID_NOVERSION_NAME TEXT("Saitek Force Feedback Effect Driver")
#define THREADING_MODEL_STRING TEXT("Both")

#else // #ifdef SAITEK

//
// --- SideWinder Force Feedback Device Driver Interface
//
// --- Old one
//DEFINE_GUID(CLSID_DirectInputEffectDriver, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
DEFINE_GUID(CLSID_DirectInputEffectDriver, /* 0d33e080-da1f-11d1-9483-00c04fc2aa8f */
    0x0d33e080,
    0xda1f,
    0x11d1,
    0x94, 0x83, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0x8f
);


// For use in creating registry
#define CLSID_DirectInputEffectDriver_String TEXT("{0d33e080-da1f-11d1-9483-00c04fc2aa8f}")
#define DRIVER_OBJECT_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver Object")
#define PROGID_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver 2.0")
#define PROGID_NOVERSION_NAME TEXT("Microsoft SideWinder Force Feedback Effect Driver")
#define THREADING_MODEL_STRING TEXT("Both")

#endif // #ifdef SAITEK

//
// --- Effect GUIDs
//
DEFINE_GUID(GUID_Wall, /* e84cd1a1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ProcessList, /* e84cd1a2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

// Built in ROM Effects
DEFINE_GUID(GUID_RandomNoise, /* e84cd1a3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_AircraftCarrierTakeOff, /* e84cd1a4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_BasketballDribble, /* e84cd1a5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_CarEngineIdle, /* e84cd1a6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawIdle, /* e84cd1a7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_ChainsawInAction, /* e84cd1a8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_DieselEngineIdle, /* e84cd1a9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1a9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Jump, /* e84cd1aa-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1aa,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Land, /* e84cd1ab-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ab,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_MachineGun, /* e84cd1ac-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ac,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_Punched, /* e84cd1ad-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ad,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_RocketLaunch, /* e84cd1ae-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ae,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SecretDoor, /* e84cd1af-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1af,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );
DEFINE_GUID(GUID_SwitchClick, /* e84cd1b0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindGust, /* e84cd1b1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_WindShear, /* e84cd1b2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Pistol, /* e84cd1b3-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b3,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Shotgun, /* e84cd1b4-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b4,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser1, /* e84cd1b5-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b5,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser2, /* e84cd1b6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser3, /* e84cd1b7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser4, /* e84cd1b8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser5, /* e84cd1b9-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1b9,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Laser6, /* e84cd1ba-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1ba,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_OutOfAmmo, /* e84cd1bb-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bb,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_LightningGun, /* e84cd1bc-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bc,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Missile, /* e84cd1bd-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bd,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_GatlingGun, /* e84cd1be-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1be,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_ShortPlasma, /* e84cd1bf-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1bf,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon1, /* e84cd1c0-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c0,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_PlasmaCannon2, /* e84cd1c1-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c1,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_Cannon, /* e84cd1c2-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c2,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RawForce, /* e84cd1c6-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c6,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_VFXEffect, /* e84cd1c7-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c7,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

DEFINE_GUID(GUID_RTCSpring, /* e84cd1c8-81fa-11d0-94ab-0080c74c7e95 */
    0xe84cd1c8,
    0x81fa,
    0x11d0,
    0x94, 0xab, 0x00, 0x80, 0xc7, 0x4c, 0x7e, 0x95
  );

//
// --- UNUSED but reserved for future GUIDs
//


#endif //_SWD_GUID_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\version.h ===
/*******************************************************************************
**
**       MODULE: VERSION.H
**
**  DESCRIPTION: Contains version numbers for Vger Project
**
**
**       AUTHOR: Manolito Adan
**
**
**      CREATED: 30-Sep-96
**		REVISED: 23-Dec-96
**				 15-Mar-99	waltw	Now get info from ntverp.h & common.ver in
**									NT build tree
**
**
**
**
**  (C) C O P Y R I G H T   M I C R O S O F T    C O R P   1 9 8 1 - 1 9 9 4.
**
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_objec.cpp ===
/****************************************************************************

    MODULE:     	SW_OBJEC.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IUnknown Method(s) for DirectInputEffectDriver Class objects
    
    FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver
				21-Mar-99	waltw	Removed unreferenced CreateDirectInputEffectDriver
				21-Mar-99	waltw	Moved CJoltMidi initialization from
									CDirectInputEffectDriver::Init to
									CImpIDirectInputEffectDriver::DeviceID

****************************************************************************/
#include "SW_objec.hpp"
#include <crtdbg.h>

//
// External Data
//                                   
#ifdef _DEBUG
extern char g_cMsg[160]; 
#endif
extern HANDLE g_hSWFFDataMutex;


// ****************************************************************************
// *** --- Member functions for base class CDirectInputEffectDriver
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::CDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CDirectInputEffectDriver Object
// Parameters:  LPUNKNOWN 		pUnkOuter	 - Ptr to a controlling unknown.
//				PFNDESTROYED	pfnDestroy   - Call when object is destroyed.
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CDirectInputEffectDriver::CDirectInputEffectDriver(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy)
{
#ifdef _DEBUG
   	_RPT0(_CRT_WARN, "CDirectInputEffectDriver::CDirectInputEffectDriver()\r\n");
#endif

    m_cRef=0;

    m_pImpIDirectInputEffectDriver=NULL;
    m_pUnkOuter=pUnkOuter;
    m_pfnDestroy=pfnDestroy;
    return;
}

CDirectInputEffectDriver::~CDirectInputEffectDriver(void)
{
#ifdef _DEBUG
   	_RPT0(_CRT_WARN, "CDirectInputEffectDriver::~CDirectInputEffectDriver()\r\n");
#endif

//Delete the interface implementations created in Init
    DeleteInterfaceImp(m_pImpIDirectInputEffectDriver);
    return;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::Init
// Purpose:		Instantiates the interface implementations for this object.
// Parameters:  none
//				
// Returns:		BOOL	- TRUE if initialization succeeds, FALSE otherwise.
// Algorithm:
//
// Note:
//		Creating the interfaces means creating instances of
//		the interface implementation classes.  The constructor
//		parameters is a pointer to CDirectInputEffectDriver that has the
//		IUnknown functions to which the interface implementations
//		delegate.
//
// ----------------------------------------------------------------------------
BOOL CDirectInputEffectDriver::Init(void)
{
#ifdef _DEBUG
	_RPT0(_CRT_WARN, "CDirectInputEffectDriver::Init\n");
#endif

    m_pImpIDirectInputEffectDriver=new CImpIDirectInputEffectDriver(this);
    if (NULL==m_pImpIDirectInputEffectDriver)
		return FALSE;

	return (TRUE);
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::QueryInterface
// Purpose:		Manages the interfaces for this object which supports the
//				IUnknown, and IDirectInputEffectDriver interfaces.
//
// Parameters:  REFIID riid		- REFIID of the interface to return.
//				PPVOID ppv      - PPVOID in which to store the pointer.
//
//				
// Returns:		HRESULT         NOERROR on success, E_NOINTERFACE if the
//				                interface is not supported.
//
// Algorithm:
//
// Note:
//		IUnknown comes from CDirectInputEffectDriver.  Note that here and in
//		the lines below we do not need to explicitly typecast
//		the object pointers into interface pointers because
//		the vtables are identical.  If we had additional virtual
//		member functions in the object, we would have to cast
//		in order to set the right vtable.  This is demonstrated
//		in the multiple-inheritance version, CObject3.
//
// ----------------------------------------------------------------------------
STDMETHODIMP CDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
	//Always NULL the out-parameters
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    //Other interfaces come from interface implementations
    if (IID_IDirectInputEffectDriver==riid)
        *ppv=m_pImpIDirectInputEffectDriver;

    if (NULL==*ppv)
        return ResultFromScode(E_NOINTERFACE);

    //AddRef any interface we'll return.
    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


// ----------------------------------------------------------------------------
// Function: 	CDirectInputEffectDriver::AddRef and CDirectInputEffectDriver::Release
// Purpose:		Reference counting members.  When Release sees a zero count
//				the object destroys itself.
//
// Parameters:  none
//				
// Returns:		DWORD	m_cRef value
//
// Algorithm:
//
// Note:
//
// ----------------------------------------------------------------------------
DWORD CDirectInputEffectDriver::AddRef(void)
{
	return ++m_cRef;
}

DWORD CDirectInputEffectDriver::Release(void)
{
    if (0!=--m_cRef) return m_cRef;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_objec.hpp ===
/****************************************************************************

    MODULE:     	SW_Objec.hpp
	Tab settings: 	5 9
	Copyright 1995, 1996, 1999, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Definition of the CDirectInputEffectDriver class that uses interface
					implementations to provide IDirectInputEffectDriver
    
	FUNCTIONS:

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
   	1.0    		06-Feb-97   MEA     original, Based on SWForce
				23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
				26-Feb-97	MEA		Added SetGain
				21-Mar-99	waltw	Removed unreferenced CreateDirectInputEffectDriver

****************************************************************************/
#ifndef _SW_OBJEC_SEEN
#define _SW_OBJEC_SEEN

#include <windows.h>
#include <mmsystem.h>
#include <memory.h>
#include "dinput.h"
#include "dinputd.h"
#include "midi_obj.hpp"
#include "dx_map.hpp"


//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
            {\
            if (NULL!=p)\
                 {\
                delete p;\
                p=NULL;\
                }\
            }

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
            {\
            if (NULL!=p)\
                {\
                p->Release();\
                p=NULL;\
                }\
            }

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

/*
 * The object we want to provide in OLE supports the IUnknown,
 * IDirectInputEffectDriver interfaces.
 *
 * The C++ class, CDirectInputEffectDriver, implements these interfaces with
 * "interface implementations" where the C++ class itself inherits
 * from and implements IUnknown members and then contains
 * other C++ classes that each separately inherit from the other
 * interfaces.  The other classes are the "interface implementations."
 */


/*
 * In this technique you'll generally need forward references
 * like this for use in declaring the object class.
 */
class CImpIDirectInputEffectDriver;
typedef CImpIDirectInputEffectDriver *PCImpIDirectInputEffectDriver;

//The C++ class that manages the actual object.
class CDirectInputEffectDriver : public IUnknown
{
    /*
     * Usually interface implementations will need back pointers
     * to the object itself since this object usually manages
     * the important data members.  In that case, make the
     * interface implementation classes friends of the object.
     */

    friend CImpIDirectInputEffectDriver;

 protected:
 	ULONG           m_cRef;         //Object reference count
    LPUNKNOWN       m_pUnkOuter;    //Controlling unknown

    PFNDESTROYED    m_pfnDestroy;   //To call on closure

    /*
     * I use "m_pImpI" as a prefix to differentiate interface
     * implementations for this object from other interface
     * pointer variables I might hold to other objects, which
     * would be prefixed with "m_pI".
     */
    PCImpIDirectInputEffectDriver  m_pImpIDirectInputEffectDriver;

 public:
     CDirectInputEffectDriver(LPUNKNOWN, PFNDESTROYED);
     ~CDirectInputEffectDriver(void);

     BOOL Init(void);

     //IUnknown members
     STDMETHODIMP         QueryInterface(REFIID, PPVOID);
     STDMETHODIMP_(DWORD) AddRef(void);
     STDMETHODIMP_(DWORD) Release(void);
};


typedef CDirectInputEffectDriver *PCDirectInputEffectDriver;


/*
 * Interface implementation classes are C++ classes that
 * each singly inherit from an interface.  Their IUnknown
 * members delegate calls to CDirectInputEffectDriver's IUnknown members--
 * since IUnknown members affect the entire *object*, and
 * since these interfaces are not the object itself, we must
 * delegate to implement the correct behavior.
 */

class CImpIDirectInputEffectDriver : public IDirectInputEffectDriver
{
 private:
	DWORD		m_cRef;         //For debugging
	PCDirectInputEffectDriver	m_pObj;	//Back pointer for delegation

	// SideWinder Force Feedback Device
	CJoltMidi *m_pJoltMidi;

 public:
    CImpIDirectInputEffectDriver(PCDirectInputEffectDriver);
    ~CImpIDirectInputEffectDriver(void);

	 // CEffect access methods
	 CJoltMidi *CJoltMidiPtrOf() { return m_pJoltMidi; }
	 void SetJoltMidiPtr(CJoltMidi* pJoltMidi) { m_pJoltMidi = pJoltMidi; }

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(DWORD) AddRef(void);
    STDMETHODIMP_(DWORD) Release(void);

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID);
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS);
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE);
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD);
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD);
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE);
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD);
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD);
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD);
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD);
};

#endif _SW_OBJEC_SEEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\sw_cimpi.cpp ===
/****************************************************************************

    MODULE:     	SW_CImpI.CPP
	Tab Settings:	5 9
	Copyright 1995, 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	IDEffect Implementation.
    
    Function(s):
					CImpIDirectInputEffectDriver::DeviceID
					CImpIDirectInputEffectDriver::GetVersions
    			    CImpIDirectInputEffectDriver::Escape
				    CImpIDirectInputEffectDriver::SetGain
    			    CImpIDirectInputEffectDriver::SendForceFeedbackCommand
    			    CImpIDirectInputEffectDriver::GetForceFeedbackState
    			    CImpIDirectInputEffectDriver::DownloadEffect
    			    CImpIDirectInputEffectDriver::DestroyEffect
    			    CImpIDirectInputEffectDriver::StartEffect
    			    CImpIDirectInputEffectDriver::StopEffect
    			    CImpIDirectInputEffectDriver::GetEffectStatus

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
  	1.0    	06-Feb-97   MEA     original, Based on SWForce
			23-Feb-97	MEA		Modified for DirectInput FF Device Driver	
			23-Mar-97	MEA/DS	Added VFX support
			16-Mar-99	waltw	GetFirmwareParams, GetSystemParams,
								CMD_Download_RTCSpring, GetDelayParams,
								GetJoystickParams, & UpdateJoystickParams
								calls removed from DeviceID since they are
								called from g_pJoltMidi->Initialize.
			23-Mar-99	waltw	GetEffectStatus now uses data returned by
								Transmit instead of obsolete GetStatusGateData

****************************************************************************/
#include <windows.h>
#include <math.h>
#include <assert.h>
#include "dinput.h"
#include "dinputd.h"
#include "SW_objec.hpp"
#include "hau_midi.hpp"
#include "ffd_swff.hpp"
#include "FFDevice.h"
#include "DPack.h"
#include "DTrans.h"
#include <ntverp.h>
#include "CritSec.h"

/****************************************************************************

   Declaration of externs

****************************************************************************/
#ifdef _DEBUG
	extern char g_cMsg[160];
	extern TCHAR szDeviceName[MAX_SIZE_SNAME];
	extern void DebugOut(LPCTSTR szDebug);
#else !_DEBUG
	#define DebugOut(x)
#endif _DEBUG

extern CJoltMidi *g_pJoltMidi;

// To convert a nack error code to a DIError code
HRESULT g_NackToError[] = 
{
	SFERR_DRIVER_ERROR,		//	DEV_ERR_SUCCESS_200 - but it NACKd!
	SWDEV_ERR_INVALID_ID,		//	DEV_ERR_INVALID_ID_200
	SWDEV_ERR_INVALID_PARAM,		//	DEV_ERR_BAD_PARAM_200
	SWDEV_ERR_CHECKSUM,		//	DEV_ERR_BAD_CHECKSUM_200
	SFERR_DRIVER_ERROR,		//	DEV_ERR_BAD_INDEX_200
	SWDEV_ERR_UNKNOWN_CMD,		//	DEV_ERR_UNKNOWN_CMD_200
	SWDEV_ERR_PLAYLIST_FULL,		//	DEV_ERR_PLAY_FULL_200
	DIERR_DEVICEFULL,		//	DEV_ERR_MEM_FULL_200
	MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)		//	DEV_ERR_BANDWIDTH_FULL_200
};

// ****************************************************************************
// *** --- Member functions for base class CImpIDirectInputEffectDriver Interface
//
// ****************************************************************************
//
// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver
// Purpose:		Constructor(s)/Destructor for CImpIDirectInputEffectDriver Object
// Parameters:  PCDirectInputEffectDriver pObj	- Ptr to the outer object
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
CImpIDirectInputEffectDriver::CImpIDirectInputEffectDriver(PCDirectInputEffectDriver pObj)
{
    m_cRef=0;
    m_pObj=pObj;
	m_pJoltMidi = NULL;		// The Jolt Device object 
    return;
}

CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver(void)
{
	DebugOut("CImpIDirectInputEffectDriver::~CImpIDirectInputEffectDriver()\n");

	// Destroy the CEffect object we created and release any interfaces
	if (g_pJoltMidi) 
	{
		delete g_pJoltMidi;
		g_pJoltMidi = NULL;
	}

	// No critical section here because g_CriticalSection already destroyed
	DebugOut("CImpIDirectInputEffectDriver::~CimpIDEffect()\n");
}

// ----------------------------------------------------------------------------
// Function: 	CImpIDirectInputEffectDriver::QueryInterface
//				CImpIDirectInputEffectDriver::AddRef
//				CImpIDirectInputEffectDriver::Release
//
// Purpose:		IUnknown members that delegate to m_pObj
// Parameters:  
//
// Returns:		
// Algorithm:
// ----------------------------------------------------------------------------
STDMETHODIMP CImpIDirectInputEffectDriver::QueryInterface(REFIID riid, PPVOID ppv)
{
    return m_pObj->QueryInterface(riid, ppv);
}

DWORD CImpIDirectInputEffectDriver::AddRef(void)
{
//
//  We maintain an "interface reference count" for debugging
//  purposes, because the client of an object should match
//  AddRef and Release calls through each interface pointer.
//  
    ++m_cRef;
    return m_pObj->AddRef();
}

DWORD CImpIDirectInputEffectDriver::Release(void)
{
//	m_cRef is again only for debugging.  It doesn't affect
//	CSWEffect although the call to m_pObj->Release does.
	--m_cRef;
    return m_pObj->Release();
}


// ----------------------------------------------------------------------------
// Function:    DeviceID
//
// Purpose:     
// Parameters:  DWORD dwExternalID		-The joystick ID number being us
//				DWORD fBegin			-Nonzero if access to the device is beginning; Zero if ending
//				DWORD dwInternalID		-Internal joystick id
//				LPVOID lpReserved		-Reserved for future use (HID)
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DeviceID(
	IN DWORD dwDirectInputVersion,
    IN DWORD dwExternalID,
    IN DWORD fBegin,
    IN DWORD dwInternalID,
	LPVOID lpReserved)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::DeviceID(%lu, %lu, %lu, %lu, %lx)\n", dwDirectInputVersion, dwExternalID, fBegin, dwInternalID, lpReserved);
	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG

	if (g_pDataPackager) {
		g_pDataPackager->SetDirectInputVersion(dwDirectInputVersion);
	}
	assert(NULL == g_pJoltMidi);
	
	// Create and Initialize our CJoltMidi object
#ifdef _DEBUG
	OutputDebugString("Creating and Initializing CJoltMidi object\n");
#endif
	g_pJoltMidi = new CJoltMidi();
	if (NULL == g_pJoltMidi)
	{
		return (E_OUTOFMEMORY);
	}
	else
	{
		return g_pJoltMidi->Initialize(dwExternalID);
	}
}


// ----------------------------------------------------------------------------
// Function:    GetVersions
//
// Purpose:     
// Parameters:  LPDIDRIVERVERSIONS pvers -Pointer to structure which receives version info
//
// Returns:		SUCCESS or Error code
//			
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetVersions(
	IN OUT LPDIDRIVERVERSIONS pvers)
{
	if (g_pJoltMidi == NULL) {
		return E_FAIL;
	}

	LOCAL_PRODUCT_ID* pProductID = g_pJoltMidi->ProductIDPtrOf();
	if (pProductID == NULL) {
		return E_FAIL;
	}

	pvers->dwFirmwareRevision = (pProductID->dwFWMajVersion << 8) | (pProductID->dwFWMinVersion);
	pvers->dwHardwareRevision = pProductID->dwProductID;

	// Get version from ntverp.h (was FULLVersion from version.h)
	pvers->dwFFDriverVersion = VER_PRODUCTVERSION_DW;

#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg,"CImpIDirectInputEffectDriver::GetVersions(%lu, %lu, %lu)\n", pvers->dwFirmwareRevision, pvers->dwHardwareRevision, pvers->dwFFDriverVersion);
	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif // _DEBUG

	return SUCCESS;
}

// ----------------------------------------------------------------------------
// Function:    Escape
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				LPDIEFFESCAPE pEsc	- Pointer to a DIFEFESCAPE struct
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::Escape(
    IN DWORD dwDeviceID,
	IN DWORD dwEffectID,
	IN OUT LPDIEFFESCAPE pEsc )
{
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->Escape(dwEffectID, pEsc);
	if (hr != SUCCESS) {
		return hr;
	}

	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}


// ----------------------------------------------------------------------------
// Function:    SetGain
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwGain		- Device gain
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SetGain(
    IN DWORD dwDeviceID,
    IN DWORD dwGain)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
	wsprintf(g_cMsg, "SetGain: %s Gain=%ld\r\n", &szDeviceName, dwGain);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	BOOL truncation = (dwGain > 10000);
	if (truncation) {
		dwGain = 10000;
	}
	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->SetGain(dwGain);
	if (FAILED(hr)) {
		return hr;
	}

	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if ((hr == SUCCESS) && (truncation)) {
		return DI_TRUNCATED;
	}
	return hr;
}

// ----------------------------------------------------------------------------
// Function:    SendForceFeedbackCommand
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD dwState		- Command to set Device state
//
//
// Returns:		SUCCESS or Error code
//
// Need to map the following DX to Jolt
// DS_FORCE_SHUTDOWN   0x00000001	// Actuators (Motors) are enabled.
// DS_FORCE_ON         0x00000002	// Actuators (Motors) are disabled.
// DS_FORCE_OFF        0x00000003	// All Effects are "Paused"
// DS_CONTINUE         0x00000004	// All "Paused" Effects are continued
// DS_PAUSE            0x00000005	// All Effects are stopped.
// DS_STOP_ALL         0x00000006	// All Effects destroyed,Motors disabled
//
//	Jolt Device ulMode:
//	SWDEV_SHUTDOWN 		1L			// All Effects destroyed, Motors disabled
//	SWDEV_FORCE_ON 		2L			// Motors enabled.  "Un-Mute"
//	SWDEV_FORCE_OFF		3L			// Motors disabled.	"Mute"
//	SWDEV_CONTINUE 		4L			// All "Paused" Effects are allow to continue
//	SWDEV_PAUSE	   		5L			// All Effects are "Paused"
//	SWDEV_STOP_ALL 		6L			// Stops all Effects.  
//   	
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::SendForceFeedbackCommand(
    IN DWORD dwDeviceID,
    IN DWORD dwState)
{
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->SendForceFeedbackCommand(dwState);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr == SUCCESS) {
		g_ForceFeedbackDevice.StateChange(dwDeviceID, dwState);
		g_pJoltMidi->UpdateDeviceMode(dwState);
	}
	return hr;
}

// ----------------------------------------------------------------------------
// Function:    GetForceFeedbackState
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				LPDIDEVICESTATE pDeviceState	- Pointer to a DIDEVICESTATE struct
//
// Returns:		SUCCESS or Error code and state updated in pDeviceState
//
// Member: dwState
//		DS_FORCE_SHUTDOWN   	0x00000001
//		DS_FORCE_ON         	0x00000002
//		DS_FORCE_OFF        	0x00000003
//		DS_CONTINUE         	0x00000004
//		DS_PAUSE            	0x00000005
//		DS_STOP_ALL         	0x00000006
//
// Member: dwSwitches
//		DSW_ACTUATORSON         0x00000001
//		DSW_ACTUATORSOFF        0x00000002
//		DSW_POWERON             0x00000004
//		DSW_POWEROFF            0x00000008
//		DSW_SAFETYSWITCHON      0x00000010
//		DSW_SAFETYSWITCHOFF     0x00000020
//		DSW_USERFFSWITCHON      0x00000040
//		DSW_USERFFSWTTCHOFF     0x00000080
//
// Algorithm:
// This is the DI Device State structure
//typedef struct DIDEVICESTATE {
//    DWORD   dwSize;
//    DWORD   dwState;
//    DWORD   dwSwitches;
//    DWORD   dwLoading;
//} DEVICESTATE, *LPDEVICESTATE;
//
// This is the SideWinder State structure (copy kept in CJoltMidi object)
//typedef struct _SWDEVICESTATE {
//	ULONG	m_Bytes;			// size of this structure
//	ULONG	m_ForceState;		// DS_FORCE_ON || DS_FORCE_OFF || DS_SHUTDOWN
//	ULONG	m_EffectState;		// DS_STOP_ALL || DS_CONTINUE || DS_PAUSE
//	ULONG	m_HOTS;				// Hands On Throttle and Stick Status
//								//  0 = Hands Off, 1 = Hands On
//	ULONG	m_BandWidth;		// Percentage of CPU available 1 to 100%
//								// Lower number indicates CPU is in trouble!
//	ULONG	m_ACBrickFault;		// 0 = AC Brick OK, 1 = AC Brick Fault
//	ULONG	m_ResetDetect;		// 1 = HW Reset Detected
//	ULONG	m_ShutdownDetect;	// 1 = Shutdown detected
//	ULONG	m_CommMode;			// 0 = Midi, 1-4 = Serial
//} SWDEVICESTATE, *PSWDEVICESTATE;
//
// Note: Apparently, DSW_ACTUATORSON and DSW_ACTUATORSOFF is a mirrored state
//		 from DS_FORCE_ON and DS_FORCE_OFF as set from SetForceFeedbackState
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetForceFeedbackState(
    IN DWORD dwDeviceID,
    IN LPDIDEVICESTATE pDeviceState)
{
	// Driver sanity Check;
	if (g_pJoltMidi == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_DRIVER_ERROR;
	}

	// User sanity check
	if (pDeviceState == NULL) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}
	if (pDeviceState->dwSize != sizeof(DIDEVICESTATE)) {
		ASSUME_NOT_REACHED();	// Has structure changed?
		return SFERR_INVALID_PARAM;
	}

	// Fix 1.20 state bug (needs to be changed for jolt support)
	if ((g_ForceFeedbackDevice.GetFirmwareVersionMajor() == 1) && (g_ForceFeedbackDevice.GetFirmwareVersionMinor() == 20)) {
		if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
			return SFERR_DRIVER_ERROR;
		}
		HRESULT hr;

		if ((g_pJoltMidi->GetSWDeviceStateNoUpdate().m_ForceState == SWDEV_FORCE_OFF)) {	// Echo state back to fix 1.20 bug
			hr = g_pDataPackager->SendForceFeedbackCommand(SWDEV_FORCE_OFF);
		} else {
			hr = g_pDataPackager->SendForceFeedbackCommand(SWDEV_FORCE_ON);
		}

		if (hr != SUCCESS) {
			return hr;
		}
		ACKNACK ackNack;
		g_pDataTransmitter->Transmit(ackNack);	// Send it off

	}

	pDeviceState->dwState = 0;

	// Ask the device for state
   	HRESULT hRet = g_ForceFeedbackDevice.QueryStatus();
	if (hRet != SUCCESS) {
		return hRet;
	}

	// Set flags from the device
	if (g_ForceFeedbackDevice.IsUserDisable()) {
		pDeviceState->dwState = DIGFFS_SAFETYSWITCHOFF;
	} else {
		pDeviceState->dwState = DIGFFS_SAFETYSWITCHON;
	}
	if (g_ForceFeedbackDevice.IsHostDisable()) {
		pDeviceState->dwState |= DIGFFS_ACTUATORSOFF;
	} else {
		pDeviceState->dwState |= DIGFFS_ACTUATORSON;
	}
	if (g_ForceFeedbackDevice.IsHostPause()) {
		pDeviceState->dwState |= DIGFFS_PAUSED;
	}

	// All effects been stopped from host?
	if (g_ForceFeedbackDevice.GetDIState() == DIGFFS_STOPPED) {
		pDeviceState->dwState |= DIGFFS_STOPPED;
	}

	// Have any effects been created?
	BOOL bEmpty = TRUE;
	for (int i=2; i < MAX_EFFECT_IDS; i++) {
		if (g_ForceFeedbackDevice.GetEffect(i) != NULL) {
			bEmpty = FALSE;
			break;
		}
	}	
	if(bEmpty) {
		pDeviceState->dwState |= DIGFFS_EMPTY;
	}

	// NYI Firmware
/*	if (m_DeviceState.m_ACBrickFault)
		pDeviceState->dwState |= DIGFFS_POWEROFF;
	else
		pDeviceState->dwState |= DIGFFS_POWERON;
*/
	pDeviceState->dwState |= DIGFFS_POWERON;	// Always on in Zep (and Zep is on or we wouldn't be here)

	pDeviceState->dwLoad = 0;

	return hRet;
}


// ----------------------------------------------------------------------------
// Function:    DownloadEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID			- Device ID
//				DWORD dwInternalEffectType	- Internal Effect Type
//				IN OUT LPDWORD pDnloadID	- Pointer to a DWORD for DnloadID
//				IN LPCDIEFFECT pEffect		- Pointer to a DIEFFECT structure
//				IN DWORD dwFlags			- for parameters that changed
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// The following dwFlags may be sent by the kernel
//
//#define DIEP_ALLPARAMS 				0x000000FF	- All fields valid
//#define DIEP_AXES 					0x00000020	- cAxes and rgdwAxes
//#define DIEP_DIRECTION 				0x00000040	- cAxes and rglDirection
//#define DIEP_DURATION 				0x00000001	- dwDuration
//#define DIEP_ENVELOPE 				0x00000080	- lpEnvelope
//#define DIEP_GAIN 					0x00000004	- dwGain
//#define DIEP_NODOWNLOAD 				0x80000000	- suppress auto - download
//#define DIEP_SAMPLEPERIOD 			0x00000002	- dwSamplePeriod
//#define DIEP_TRIGGERBUTTON 			0x00000008	- dwTriggerButton
//#define DIEP_TRIGGERREPEATINTERVAL 	0x00000010	- dwTriggerRepeatInterval
//#define DIEP_TYPESPECIFICPARAMS 		0x00000100	- cbTypeSpecificParams
//													  and lpTypeSpecificParams
// Jolt has two options for downloading - Full SysEx or Modify Parameter
// Pass the dwFlags to each CMD_xxx function and let the MIDI function
// determine whether to use SysEx or Modify Parameter.
//
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DownloadEffect(
    IN DWORD dwDeviceID,
    IN DWORD dwInternalEffectType,
    IN OUT LPDWORD pDnloadID,
    IN LPCDIEFFECT pEffect,
	IN DWORD dwFlags)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s 3Effect. DnloadID= %ld, Type=%lx, dwFlags= %lx\r\n",
   					&szDeviceName[0], *pDnloadID, dwInternalEffectType, dwFlags);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	// Quick sanity check
	if ((pEffect == NULL) || (pDnloadID == NULL)) {
		ASSUME_NOT_REACHED();
		return SFERR_INVALID_PARAM;
	}

	// Are we setup properly
	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	HRESULT hr = SFERR_DRIVER_ERROR;
	HRESULT createResult = SUCCESS;
	BOOL downLoad = (dwFlags & DIEP_NODOWNLOAD) == 0;
	BOOL createdAttempted = FALSE;

	InternalEffect* pLocalEffect = NULL;
	if (*pDnloadID != 0) {		// 0 Indicates create new
		pLocalEffect = g_ForceFeedbackDevice.GetEffect(*pDnloadID);
	}
	if (pLocalEffect == NULL) {	// New effect create it (or Raw Force)
		createdAttempted = TRUE;
		BOOL wasZero = (*pDnloadID == 0);
		pLocalEffect = g_ForceFeedbackDevice.CreateEffect(dwInternalEffectType, *pEffect, *pDnloadID, createResult, (downLoad == FALSE));

		if (FAILED(createResult)) {
			return createResult;
		}
		if (pLocalEffect == NULL) {
			if ((*pDnloadID == RAW_FORCE_ALIAS) && (wasZero == FALSE)) {
				if ((dwFlags & (DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERREPEATINTERVAL | DIEP_TRIGGERBUTTON | DIEP_ENVELOPE)) != 0) {
					return S_FALSE;
				}
			}
			return createResult;
		}

		hr = g_pDataPackager->CreateEffect(*pLocalEffect, dwFlags);
		if (!downLoad) {
			delete pLocalEffect;
			pLocalEffect = NULL;
		}
	} else { // Effect Exists, modify it
		InternalEffect* pDIEffect = g_ForceFeedbackDevice.CreateEffect(dwInternalEffectType, *pEffect, *pDnloadID, createResult, (downLoad == FALSE)); // Create new
		if ((pDIEffect == NULL) || (FAILED(createResult))) {
			return createResult;
		}

		hr = g_pDataPackager->ModifyEffect(*pLocalEffect, *pDIEffect, dwFlags);	// Package relative changes
		if (FAILED(hr)) {
			delete pDIEffect;
			return hr;
		}

		if (downLoad) {
			g_ForceFeedbackDevice.SetEffect(BYTE(*pDnloadID), pDIEffect);		// Replace the old with the new
			pDIEffect->SetDeviceID(pLocalEffect->GetDeviceID());	// Update device IDs
			delete pLocalEffect;	// Delete the old
		} else {
			delete pDIEffect;
		}
	}

	if ((FAILED(hr)) || (downLoad == FALSE)) {
		return hr;
	}
	HRESULT  modProblems = hr;

	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr == SFERR_DEVICE_NACK) {
		if (ackNack.dwErrorCode <= DEV_ERR_BANDWIDTH_FULL_200) {
			return g_NackToError[ackNack.dwErrorCode];
		} else {
			return SFERR_DRIVER_ERROR;
		}
	}
	if (FAILED(hr)) {
		return hr;
	}
	if (createdAttempted == TRUE) {
		g_ForceFeedbackDevice.SetDeviceIDFromStatusPacket(*pDnloadID);
	}

	// Check for start flag
	if (dwFlags & DIEP_START) {
		// Create a command/data packet - send it of to the stick
		HRESULT hr = g_pDataPackager->StartEffect(*pDnloadID, 0, 1);
		if (hr != SUCCESS) {
			return hr;
		}
		hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
		if (hr == SFERR_DEVICE_NACK) {
			if (ackNack.dwErrorCode <= DEV_ERR_BANDWIDTH_FULL_200) {
				return g_NackToError[ackNack.dwErrorCode];
			} else {
				return SFERR_DRIVER_ERROR;
			}
		}
		pLocalEffect->SetPlaying(TRUE);
		return hr;
	}

	if (createResult != SUCCESS) {	// Truncation and whatnot
		return createResult;
	}
	return modProblems;	// Wow we got this far!
}

// ----------------------------------------------------------------------------
// Function:    DestroyEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to destroy
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::DestroyEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s DestroyEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->DestroyEffect(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}

// ----------------------------------------------------------------------------
// Function:    StartEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Start
//				DWORD dwMode		- Playback mode
//				DWORD dwCount		- Loop count
//
//
// Returns:		SUCCESS or Error code
//
//  dwMode: Playback mode is available with the following options:
//          PLAY_SOLO       - stop other forces playing, make this the only one.
//          PLAY_SUPERIMPOSE- mix with currently playing device
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StartEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    IN DWORD dwMode,
    IN DWORD dwCount)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StartEffect. DnloadID:%ld, Mode:%lx, Count:%lx\r\n",
   			  &szDeviceName[0], DnloadID, dwMode, dwCount);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT packageResult = g_pDataPackager->StartEffect(DnloadID, dwMode, dwCount);
	if (FAILED(packageResult)) {
		return packageResult;
	}

	ACKNACK ackNack;
	HRESULT hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr == SFERR_DEVICE_NACK) {
		if (ackNack.dwErrorCode <= DEV_ERR_BANDWIDTH_FULL_200) {
			return g_NackToError[ackNack.dwErrorCode];
		} else {
			return SFERR_DRIVER_ERROR;
		}
	}

	InternalEffect* pEffect = g_ForceFeedbackDevice.GetEffect(DnloadID);
	if (pEffect != NULL) {
		pEffect->SetPlaying(TRUE);
	}

	if (hr == SUCCESS) {
		return packageResult;
	}
	return hr;
}

// ----------------------------------------------------------------------------
// Function:    StopEffect
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	- Device ID
//				DWORD DnloadID		- Download ID to Stop
//
//
// Returns:		SUCCESS or Error code
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::StopEffect(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID)
{
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "%s StopEffect. DnloadID:%ld\r\n",
   			  &szDeviceName[0], DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->StopEffect(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	return g_pDataTransmitter->Transmit(ackNack);	// Send it off
}

// ----------------------------------------------------------------------------
// Function:    GetEffectStatus
//
// Purpose:     
// Parameters:  DWORD dwDeviceID	-	 Device ID
//				DWORD DnloadID			- Download ID to get Status
//				LPDWORD pdwStatusCode	- Pointer to a DWORD for Status
//
//
// Returns:		SUCCESS or Error code
//				Status Code: DEV_STS_EFFECT_STOPPED
//							 DEV_STS_EFFECT_RUNNING
//
// Algorithm:
// ----------------------------------------------------------------------------
HRESULT CImpIDirectInputEffectDriver::GetEffectStatus(
    IN DWORD dwDeviceID,
    IN DWORD DnloadID,
    OUT LPDWORD pdwStatusCode)
{
	HRESULT hRet = SUCCESS;
#ifdef _DEBUG
	g_CriticalSection.Enter();
   	wsprintf(g_cMsg, "GetEffectStatus, DnloadID=%d\r\n", DnloadID);
   	_RPT0(_CRT_WARN, g_cMsg);
	g_CriticalSection.Leave();
#endif

	ASSUME_NOT_NULL(g_pDataPackager);
	ASSUME_NOT_NULL(g_pDataTransmitter);
	ASSUME_NOT_NULL(pdwStatusCode);
	if ((g_pDataPackager == NULL) || (g_pDataTransmitter == NULL) || (pdwStatusCode == NULL)) {
		return SFERR_DRIVER_ERROR;
	}

	// Create a command/data packet - send it of to the stick
	HRESULT hr = g_pDataPackager->GetEffectStatus(DnloadID);
	if (hr != SUCCESS) {
		return hr;
	}
	ACKNACK ackNack;
	hr = g_pDataTransmitter->Transmit(ackNack);	// Send it off
	if (hr != SUCCESS) {
		return hr;
	}

	// Use result returned by GetAckNackData in Transmit
	DWORD dwIn = ackNack.dwEffectStatus;

	// Interpret result (cooked RUNNING_MASK_200 becomes SWDEV_STS_EFFECT_RUNNING)
	if ((g_ForceFeedbackDevice.GetDriverVersionMajor() != 1) && (dwIn & SWDEV_STS_EFFECT_RUNNING)) {
		*pdwStatusCode = DIEGES_PLAYING;
	} else {
		*pdwStatusCode = NULL; // Stopped;
	}
	g_ForceFeedbackDevice.GetEffect(DnloadID)->SetPlaying(*pdwStatusCode == DIEGES_PLAYING);
	return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\vxdioctl.hpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.HPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Header file for VXDIOCTL.CPP
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL	
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				21-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!
				23-Mar-99	waltw	Nuked GetStatusGateData (old Jolt code)

****************************************************************************/
#ifndef __VXDIOCTL_HPP__
#define __VXDIOCTL_HPP__

#include <windows.h>
#include "FFeature.h"

#ifndef override
#define override
#endif

//--------------------- Host converted AckNack,Effect Status Structure ------
typedef struct _ACKNACK  {
	DWORD	cBytes;	
	DWORD	dwAckNack;			//ACK, NACK
	DWORD	dwErrorCode;
	DWORD	dwEffectStatus;		//SWDEV_STS_EFFECT_RUNNING||SWDEV_STS_EFFECT_STOPPED
} ACKNACK, *PACKNACK;

//--------------------- Host converted Channel ID Structure -----------------
struct LOCAL_PRODUCT_ID {
	DWORD	cBytes;	
	DWORD	dwProductID;
	DWORD	dwFWMajVersion;
	DWORD	dwFWMinVersion;
};

// Bitmasks for Response Status - 1.xx (we don't support version 1 - informational only)
//#define STATUS_GATE_1XX			0x08
//#define RUNNING_MASK_1XX			0x04
//#define ACKNACK_MASK_1XX			0x02
//#define SCLK_MASK_1XX				0x01

// Bitmasks for Response Status - Version 2
#define STATUS_GATE_200				0x80
#define RUNNING_MASK_200			0x40
#define ACKNACK_MASK_200			0x20
#define SCLK_MASK_200				0x10

// Bitmasks for Get Status packet dwDeviceStatus member
#define ERROR_STATUS_MASK			0x07	// only bits 0-2 valid
#define BANDWIDTH_OVERFLOW_200		0x0200

// Error code from device (plus own)
#define DEV_ERR_SUCCESS_200			0x00	// Success
#define DEV_ERR_INVALID_ID_200		0x01	// Effect ID is invalid or not found
#define DEV_ERR_BAD_PARAM_200		0x02	// Invalid parameter in data structure
#define DEV_ERR_BAD_CHECKSUM_200	0x03	// Invalid checksum
#define DEV_ERR_BAD_INDEX_200		0x04	// Invalid index sent (modify)
#define DEV_ERR_UNKNOWN_CMD_200		0x05	// Unrecognized command
#define DEV_ERR_PLAY_FULL_200		0x06	// Play List is full, cannot play anymore
#define DEV_ERR_MEM_FULL_200		0x07	// Out of memory
#define DEV_ERR_BANDWIDTH_FULL_200	0x08	// used to signal bandwidth error


/************************************************************************
**
**	@class DriverCommunicator |
**		This is the interface for driver communications
**
*************************************************************************/
class DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		DriverCommunicator() {};
		//@cmember destructor
		virtual ~DriverCommunicator() {};

		virtual HRESULT ResetDevice() { return E_NOTIMPL; }
		virtual HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor) { return E_NOTIMPL; }
		virtual HRESULT GetPortByte(ULONG& portByte) { return E_NOTIMPL; }
		virtual HRESULT GetID(LOCAL_PRODUCT_ID& rProductID) { return E_NOTIMPL; }
		virtual HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus) { return E_NOTIMPL; }
		virtual HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex) { return E_NOTIMPL; }
		virtual HRESULT SetBackdoorPort(ULONG ulPortAddress) { return E_NOTIMPL; }
		virtual HRESULT SendBackdoor(BYTE* pMidiData, DWORD dwNumBytes) { return E_NOTIMPL; }
};

/************************************************************************
**
**	@class HIDFeatureCommunicator |
**		Communicates with the HID driver via HID Features (NT5)
**
*************************************************************************/
class HIDFeatureCommunicator :
	public DriverCommunicator
{
	//@access Constructor/Destructor
	public:
		//@cmember constructor
		HIDFeatureCommunicator();
		//@cmember destructor
		override ~HIDFeatureCommunicator();

		BOOL Initialize(UINT uJoystickId);
		override HRESULT ResetDevice();
		override HRESULT GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor);
		override HRESULT GetID(LOCAL_PRODUCT_ID& rProductID);
		override HRESULT GetPortByte(ULONG& portByte);
		override HRESULT GetStatus(JOYCHANNELSTATUS& rChannelStatus);
		override HRESULT GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex);
	//@access Private Data Members
	private:
		CForceFeatures m_ForceFeature;
};


extern DriverCommunicator* g_pDriverCommunicator;


#endif __VXDIOCTL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\input\legacy\mshgame\sw_wheel\vxdioctl.cpp ===
/****************************************************************************

    MODULE:     	VXDIOCTL.CPP
	Tab stops 5 9
	Copyright 1995-1997, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Methods for communicating with VJoyD min-driver specific
    				to Jolt Midi device
    
    FUNCTIONS: 		

	Author(s):	Name:
	----------	----------------
		MEA		Manolito E. Adan

	Revision History:
	-----------------
	Version 	Date        Author  Comments
	-------     ------  	-----   -------------------------------------------
	1.0			03-Jan-97	MEA   	Original
	1.1			14-Apr-97	MEA		Added SetMidiPort IOCTL
				11-Jun-97	MEA		Added JoltHWReset IOCTL
				17-Jun-97	MEA		Added MAX_RETRY_COUNT on IOCTLs
				21-Mar-99	waltw	Nuked VxDCommunicator, this is NT5 only!
				21-Mar-99	waltw	Nuked unused IsHandleValid
				23-Mar-99	waltw	Nuked GetStatusGateData (old Jolt code)

****************************************************************************/

#include "vxdioctl.hpp"
//#include <crtdbg.h>			// For RPT macros
#include <WINIOCTL.H>		// For IOCTL definitions (CTL_CODE)
#include "FFDevice.h"		// For g_ForceFeedbackDevice
#include "sw_error.hpp"		// For Sidewinder HRESULT Error codes
#include "hau_midi.hpp"		// For MAX_RETRY_COUNT and others
#include "midi_obj.hpp"		// Global Jolt midi object and definition
#include "JoyRegst.hpp"		// The differnt types of ACK_NACK
#include "DTrans.h"			// For global Data Transmitter

DriverCommunicator* g_pDriverCommunicator = NULL;
extern DataTransmitter* g_pDataTransmitter;
extern HINSTANCE g_MyInstance;
extern CJoltMidi* g_pJoltMidi;

// Bitmasks for FW Version 
#define FW_MAJOR_VERSION			0xFF00		// wheel
#define FW_MINOR_VERSION			0x00FF		// wheel
//#define FW_MAJOR_VERSION			0x40		// Bit 6	Jolt
//#define FW_MINOR_VERSION			0x3F		// Bit 5-0	Jolt
#define FW_PRODUCT_ID				0xff

/********************************** HIDFeatureCommunicator class ***********************************/

/****************************************
**
**	HIDFeatureCommunicator::HIDFeatureCommunicator()
**
**	@mfunc Constructor for VxD Communications path
**
*****************************************/
HIDFeatureCommunicator::HIDFeatureCommunicator() :
	DriverCommunicator(),
	m_ForceFeature()
{
}

/****************************************
**
**	HIDFeatureCommunicator::~HIDFeatureCommunicator()
**
**	@mfunc Destructor for VxD communications path
**
*****************************************/
HIDFeatureCommunicator::~HIDFeatureCommunicator()
{
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::Initialize(UINT uJoystickId)
**
**	@mfunc Opens the driver for communications via IOCTLs
**
**	@rdesc TRUE if driver opened, FALSE otherwise
**
*****************************************/
BOOL HIDFeatureCommunicator::Initialize
(
	UINT uJoystickId //@parm Joystick ID to use
)
{
	if (g_ForceFeedbackDevice.IsOSNT5() == FALSE)
	{	// Only allowable on NT5
		return FALSE;
	}

	return (SUCCEEDED(m_ForceFeature.Initialize(uJoystickId, g_MyInstance)));
}

/****************************************
**
**	BOOL HIDFeatureCommunicator::ResetDevice()
**
**	@mfunc Sends the driver a device reset IOCTL
**
**	@rdesc S_OK if IOCTL suceeds, 
**
*****************************************/
HRESULT HIDFeatureCommunicator::ResetDevice()
{
	return m_ForceFeature.DoReset();
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetDriverVersion(DWORD& rdwMajor, DWORD& rdwMinor)
**
**	@mfunc IOCTLs a version request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetDriverVersion
(
	DWORD& rdwMajor,	//@parm reference to returned major part of version
	DWORD& rdwMinor		//@parm reference to returned minor part of version
)
{
	ULONG ulVersion = m_ForceFeature.GetVersion();
	rdwMajor = (ulVersion >> 16) & 0x0000FFFF;
	rdwMinor = ulVersion & 0x0000FFFF;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetID(LOCAL_PRODUCT_ID& rProductID)
**
**	@mfunc IOCTLs a product id request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetID
(
	LOCAL_PRODUCT_ID& rProductID	//@parm reference to local product id structure for return value
)
{
	if (rProductID.cBytes != sizeof LOCAL_PRODUCT_ID)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Create report packet and request
	PRODUCT_ID_REPORT productIDReport;
	productIDReport.ProductId.cBytes = sizeof PRODUCT_ID;
	HRESULT hr = m_ForceFeature.GetId(productIDReport);
	if (FAILED(hr))
	{	// There was a problem
		return hr;
	}

	// Decode to local packet
	rProductID.dwProductID = productIDReport.ProductId.dwProductID & FW_PRODUCT_ID;
	rProductID.dwFWMajVersion = 1;
	if (productIDReport.ProductId.dwFWVersion & FW_MAJOR_VERSION)
	{
		rProductID.dwFWMajVersion++;
	}
	rProductID.dwFWMinVersion = productIDReport.ProductId.dwFWVersion & FW_MINOR_VERSION;

	return S_OK;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetPortByte(ULONG& portByte)
**
**	@mfunc IOCTLs a request for the port byte
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetPortByte
(
	ULONG& portByte	//@parm reference to byte return value for port data
)
{
	ULONG_REPORT report;
	HRESULT hr = m_ForceFeature.GetSync(report);
	portByte = report.uLong;
	return hr;
}


/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetStatus(JOYCHANNELSTATUS& rChannelStatus)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetStatus
(
	JOYCHANNELSTATUS& rChannelStatus	//@parm reference to status packet for result
)
{
	if (rChannelStatus.cBytes != sizeof JOYCHANNELSTATUS)
	{	// structure size is invalid
		return SFERR_INVALID_STRUCT_SIZE;
	}
	if (NULL == g_pJoltMidi) return (SFERR_DRIVER_ERROR);

	// Create report packet and perform request
	JOYCHANNELSTATUS_REPORT statusReport;
	statusReport.JoyChannelStatus.cBytes = sizeof JOYCHANNELSTATUS;

	HRESULT hr = S_OK;
	for (int i=0; i < MAX_GET_STATUS_PACKET_RETRY_COUNT; i++) {
		Sleep(g_pJoltMidi->DelayParamsPtrOf()->dwGetStatusPacketDelay);

		hr = m_ForceFeature.GetStatus(statusReport);

		if (FAILED(hr))
		{	// There was a problem
			if (i > 5)
			{
				Sleep(1);
			}
		}
		else
		{
			break;
		}
	}

	if (SUCCEEDED(hr))
	{	// Get the data from report packet
		::memcpy(g_ForceFeedbackDevice.GetLastStatusPacket(), &(statusReport.JoyChannelStatus), sizeof(JOYCHANNELSTATUS));
		::memcpy(&rChannelStatus, &(statusReport.JoyChannelStatus), sizeof JOYCHANNELSTATUS);
	}
	return hr;
}

/****************************************
**
**	HRESULT HIDFeatureCommunicator::GetAckNack(ACKNACK& rAckNack, USHORT usRegIndex)
**
**	@mfunc IOCTLs a status request
**
**	@rdesc S_OK on success E_FAIL if driver not initialized
**
*****************************************/
HRESULT HIDFeatureCommunicator::GetAckNack
(
	ACKNACK& rAckNack,	//@parm Structure for return of acking
	USHORT usRegIndex	//@parm Index to what type of ack/nack to do
)
{
	if (rAckNack.cBytes != sizeof ACKNACK)
	{	// Invalid structure size
		return SFERR_INVALID_STRUCT_SIZE;
	}

	// Determine how to get the result
	switch (g_ForceFeedbackDevice.GetAckNackMethod(usRegIndex))
	{
		case ACKNACK_NOTHING:
		{	// This one is real easy - do nothing
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		case ACKNACK_BUTTONSTATUS:
		{	// Look at the button status (status gate)
			ULONG_REPORT report;
			report.uLong = 0L;
			HRESULT hr = S_OK;
			if (g_pDataTransmitter && g_pDataTransmitter->NackToggle())
			{
				hr = m_ForceFeature.GetNakAck(report);
			}
			else
			{
				hr = m_ForceFeature.GetAckNak(report);
			}
			if (FAILED(hr))
			{	// There was a problem
				return hr;
			}
#if 0
			// NT5 driver doesn't touch report.uLong on failure (returns above)
			if (report.uLong & ACKNACK_MASK_200)
			{ // NACK error, so get Error code
				rAckNack.dwAckNack = NACK;
				JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
				if (FAILED(hr = GetStatus(statusPacket)))
				{	// Failed to get status error
					return hr;
				}
				rAckNack.dwErrorCode = (statusPacket.dwDeviceStatus & ERROR_STATUS_MASK);
				return S_OK;
			}
#endif
			// ACK success
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;

			if (report.uLong & RUNNING_MASK_200)
			{	// Current driver and effect running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_RUNNING;
			}
			else
			{	// Effect not running
				rAckNack.dwEffectStatus = SWDEV_STS_EFFECT_STOPPED;
			}

			return S_OK;
		}
		case ACKNACK_STATUSPACKET:
		{	// Use the Status Packet Error code field to determine ACK or NACK and Get Error code
			JOYCHANNELSTATUS statusPacket = { sizeof JOYCHANNELSTATUS };
 
			HRESULT hr = GetStatus(statusPacket);
			if (FAILED(hr))
			{	// Failed (retried inside GetStatus)
				return SFERR_DRIVER_ERROR;
			}
			rAckNack.dwErrorCode = statusPacket.dwDeviceStatus & ERROR_STATUS_MASK;
			rAckNack.dwAckNack = (rAckNack.dwErrorCode) ? NACK : ACK;
			return S_OK;
		}
		default:
		{	// Someone put garbage in the registry (do nothing)
			rAckNack.dwAckNack = ACK;
			rAckNack.dwErrorCode = 0;
			return S_OK;
		}
		
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\exe\rwbulk.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    RWBulk.c

Abstract:

    Console test app for BulkUsb.sys driver

Environment:

    user mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        11/17/97: created

--*/

#include <windows.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

#include "devioctl.h"

#include <setupapi.h>
#include <basetyps.h>
#include "BulkUsr.h"

#include "usbdi.h"

#define NOISY(_x_) printf _x_ ;

char inPipe[32] = "PIPE00";     // pipe name for bulk input pipe on our test board
char outPipe[32] = "PIPE01";    // pipe name for bulk output pipe on our test board
char completeDeviceName[256] = "";  //generated from the GUID registered by the driver itself

BOOL fDumpUsbConfig = FALSE;    // flags set in response to console command line switches
BOOL fDumpReadData = FALSE;
BOOL fRead = FALSE;
BOOL fWrite = FALSE;

int gDebugLevel = 1;      // higher == more verbose, default is 1, 0 turns off all

ULONG IterationCount = 1; //count of iterations of the test we are to perform
int WriteLen = 0;         // #bytes to write
int ReadLen = 0;          // #bytes to read

// functions


HANDLE
OpenOneDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
        IN               char *devName
    )
/*++
Routine Description:

    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific usb device,
    open that device and fill in all the relevant information in the given
    USB_DEVICE_DESCRIPTOR structure.

Arguments:

    HardwareDeviceInfo:  handle to info obtained from Pnp mgr via SetupDiGetClassDevs()
    DeviceInfoData:      ptr to info obtained via SetupDiEnumDeviceInterfaces()

Return Value:

    return HANDLE if the open and initialization was successfull,
        else INVLAID_HANDLE_VALUE.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
        HANDLE                                                           hOut = INVALID_HANDLE_VALUE;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    if(NULL == functionClassDeviceData) {
        return INVALID_HANDLE_VALUE;
    }
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
                free( functionClassDeviceData );
        return INVALID_HANDLE_VALUE;
    }

        strcpy( devName,functionClassDeviceData->DevicePath) ;
        printf( "Attempting to open %s\n", devName );

    hOut = CreateFile (
                  functionClassDeviceData->DevicePath,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                  NULL, // no SECURITY_ATTRIBUTES structure
                  OPEN_EXISTING, // No special create flags
                  0, // No special attributes
                  NULL); // No template file

    if (INVALID_HANDLE_VALUE == hOut) {
                printf( "FAILED to open %s\n", devName );
    }
        free( functionClassDeviceData );
        return hOut;
}


HANDLE
OpenUsbDevice( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

   Do the required PnP things in order to find
   the next available proper device in the system at this time.

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated name for this device

Return Value:

    return HANDLE if the open and initialization was successful,
        else INVLAID_HANDLE_VALUE.
--*/
{
   ULONG NumberDevices;
   HANDLE hOut = INVALID_HANDLE_VALUE;
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR       *UsbDevices = &usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR   tempDevDesc;

   *UsbDevices = NULL;
   tempDevDesc = NULL;
   NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   // SetupDiGetClassDevs() returns a device information set that contains info on all
   // installed devices of a specified class.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           pGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess at the number of devices we have;
   // Be prepared to realloc and retry if there are more than we guessed
   //
   NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      NumberDevices *= 2;

      if (*UsbDevices) {
            tempDevDesc = 
               realloc (*UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR)));
            if(tempDevDesc) {
                *UsbDevices = tempDevDesc;
                tempDevDesc = NULL;
            }
            else {
                free(*UsbDevices);
                *UsbDevices = NULL;
            }
      } else {
         *UsbDevices = calloc (NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR));
      }

      if (NULL == *UsbDevices) {

         // SetupDiDestroyDeviceInfoList destroys a device information set
         // and frees all associated memory.

         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return INVALID_HANDLE_VALUE;
      }

      usbDeviceInst = *UsbDevices + i;

      for (; i < NumberDevices; i++) {

         // SetupDiEnumDeviceInterfaces() returns information about device interfaces
         // exposed by one or more devices. Each call returns information about one interface;
         // the routine can be called repeatedly to get information about several interfaces
         // exposed by one or more devices.

         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                         0, // We don't care about specific PDOs
                                                                                 pGuid,
                                         i,
                                         &deviceInfoData)) {

            hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf);
                        if ( hOut != INVALID_HANDLE_VALUE ) {
               done = TRUE;
               break;
                        }
         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   NumberDevices = i;

   // SetupDiDestroyDeviceInfoList() destroys a device information set
   // and frees all associated memory.

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   free ( *UsbDevices );
   return hOut;
}




BOOL
GetUsbDeviceFileName( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

    Given a ptr to a driver-registered GUID, give us a string with the device name
    that can be used in a CreateFile() call.
    Actually briefly opens and closes the device and sets outBuf if successfull;
    returns FALSE if not

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated zero-terminated name for this device

Return Value:

    TRUE on success else FALSE

--*/
{
        HANDLE hDev = OpenUsbDevice( pGuid, outNameBuf );
        if ( hDev != INVALID_HANDLE_VALUE )
        {
                CloseHandle( hDev );
                return TRUE;
        }
        return FALSE;

}

HANDLE
open_dev()
/*++
Routine Description:

    Called by dumpUsbConfig() to open an instance of our device

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        HANDLE hDEV = OpenUsbDevice( (LPGUID)&GUID_CLASS_I82930_BULK, completeDeviceName);


        if (hDEV == INVALID_HANDLE_VALUE) {
                printf("Failed to open (%s) = %d", completeDeviceName, GetLastError());
        } else {
                printf("DeviceName = (%s)\n", completeDeviceName);
    }           

        return hDEV;
}


HANDLE
open_file( char *filename)
/*++
Routine Description:

    Called by main() to open an instance of our device after obtaining its name

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        int success = 1;
        HANDLE h;

        if ( !GetUsbDeviceFileName(
                (LPGUID) &GUID_CLASS_I82930_BULK,
                completeDeviceName) )
        {
                NOISY(("Failed to GetUsbDeviceFileName err - %d\n", GetLastError()));
                return  INVALID_HANDLE_VALUE;
        }

    strcat (completeDeviceName,
                        "\\"
                        );                      

    if((strlen(completeDeviceName) + strlen(filename)) > 255) {
        NOISY(("Failed to open handle - possibly long filename\n"));
        return INVALID_HANDLE_VALUE;
    }

    strcat (completeDeviceName,
                        filename
                        );                                      

        printf("completeDeviceName = (%s)\n", completeDeviceName);

        h = CreateFile(completeDeviceName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

        if (h == INVALID_HANDLE_VALUE) {
                NOISY(("Failed to open (%s) = %d", completeDeviceName, GetLastError()));
                success = 0;
        } else {
                        NOISY(("Opened successfully.\n"));
    }           

        return h;
}

void
usage()
/*++
Routine Description:

    Called by main() to dump usage info to the console when
    the app is called with no parms or with an invalid parm

Arguments:

    None

Return Value:

    None

--*/
{
    static int i=1;

    if (i) {
        printf("Usage for Read/Write test:\n");
        printf("-r [n] where n is number of bytes to read\n");
        printf("-w [n] where n is number of bytes to write\n");
        printf("-c [n] where n is number of iterations (default = 1)\n");
        printf("-i [s] where s is the input pipe\n");
        printf("-o [s] where s is the output pipe\n");
        printf("-v verbose -- dumps read data\n");

        printf("\nUsage for USB and Endpoint info:\n");
        printf("-u to dump USB configuration and pipe info \n");
        i = 0;
    }
}


void
parse(
    int argc,
    char *argv[] )
/*++
Routine Description:

    Called by main() to parse command line parms

Arguments:

    argc and argv that was passed to main()

Return Value:

    Sets global flags as per user function request

--*/
{
    int i;

        if ( argc < 2 ) // give usage if invoked with no parms
                usage();

    for (i=0; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case 'r':
            case 'R':
                ReadLen = atoi(&argv[i+1][0]);
                                fRead = TRUE;
                i++;
                break;
            case 'w':
            case 'W':
                WriteLen = atoi(&argv[i+1][0]);
                                fWrite = TRUE;
                i++;
                break;
            case 'c':
            case 'C':
                IterationCount = atoi(&argv[i+1][0]);
                i++;
                break;
            case 'i':
            case 'I':
                strcpy(inPipe, &argv[i+1][0]);
                i++;
                break;
            case 'u':
            case 'U':
                fDumpUsbConfig = TRUE;
                                i++;
                break;
            case 'v':
            case 'V':
                fDumpReadData = TRUE;
                                i++;
                break;
                         case 'o':
             case 'O':
                strcpy(outPipe, &argv[i+1][0]);
                i++;
                break;
            default:
                usage();
            }
        }
    }
}

BOOL
compare_buffs(char *buff1, char *buff2, int length)
/*++
Routine Description:

    Called to verify read and write buffers match for loopback test

Arguments:

    buffers to compare and length

Return Value:

    TRUE if buffers match, else FALSE

--*/
{
    int ok = 1;

        if (memcmp(buff1, buff2, length )) {

                // Edi, and Esi point to the mismatching char and ecx indicates the
                // remaining length.
                ok = 0;
        }


    return ok;
}

#define NPERLN 8

void
dump(
   UCHAR *b,
   int len
)
/*++
Routine Description:

    Called to do formatted ascii dump to console of the io buffer

Arguments:

    buffer and length

Return Value:

    none

--*/
{
    ULONG i;
        ULONG longLen = (ULONG)len / sizeof( ULONG );
        PULONG pBuf = (PULONG) b;

        // dump an ordinal ULONG for each sizeof(ULONG)'th byte
    printf("\n****** BEGIN DUMP LEN decimal %d, 0x%x\n", len,len);
    for (i=0; i<longLen; i++) {
        printf("%04X ", *pBuf++);
        if (i % NPERLN == (NPERLN - 1)) {
            printf("\n");
        }
    }
    if (i % NPERLN != 0) {
        printf("\n");
    }
    printf("\n****** END DUMP LEN decimal %d, 0x%x\n", len,len);
}





// Begin, routines for USB configuration dump (Cmdline "rwbulk -u" )


char
*usbDescriptorTypeString(UCHAR bDescriptorType )
/*++
Routine Description:

    Called to get ascii string of USB descriptor

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bDescriptorType or
        PUSB_DEVICE_DESCRIPTOR->bDescriptorType or
        PUSB_INTERFACE_DESCRIPTOR->bDescriptorType or
        PUSB_STRING_DESCRIPTOR->bDescriptorType or
        PUSB_POWER_DESCRIPTOR->bDescriptorType or
        PUSB_CONFIGURATION_DESCRIPTOR->bDescriptorType

Return Value:

    ptr to string

--*/{

        switch(bDescriptorType) {

        case USB_DEVICE_DESCRIPTOR_TYPE:
                return "USB_DEVICE_DESCRIPTOR_TYPE";

        case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                return "USB_CONFIGURATION_DESCRIPTOR_TYPE";
                

        case USB_STRING_DESCRIPTOR_TYPE:
                return "USB_STRING_DESCRIPTOR_TYPE";
                

        case USB_INTERFACE_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_DESCRIPTOR_TYPE";
                

        case USB_ENDPOINT_DESCRIPTOR_TYPE:
                return "USB_ENDPOINT_DESCRIPTOR_TYPE";
                

#ifdef USB_POWER_DESCRIPTOR_TYPE // this is the older definintion which is actually obsolete
    // workaround for temporary bug in 98ddk, older USB100.h file
        case USB_POWER_DESCRIPTOR_TYPE:
                return "USB_POWER_DESCRIPTOR_TYPE";
#endif
                
#ifdef USB_RESERVED_DESCRIPTOR_TYPE  // this is the current version of USB100.h as in NT5DDK

        case USB_RESERVED_DESCRIPTOR_TYPE:
                return "USB_RESERVED_DESCRIPTOR_TYPE";

        case USB_CONFIG_POWER_DESCRIPTOR_TYPE:
                return "USB_CONFIG_POWER_DESCRIPTOR_TYPE";

        case USB_INTERFACE_POWER_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_POWER_DESCRIPTOR_TYPE";
#endif // for current nt5ddk version of USB100.h

        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbEndPointTypeString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of endpt descriptor type

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_ENDPOINT_TYPE_MASK;


        switch( typ) {
        case USB_ENDPOINT_TYPE_INTERRUPT:
                return "USB_ENDPOINT_TYPE_INTERRUPT";

        case USB_ENDPOINT_TYPE_BULK:
                return "USB_ENDPOINT_TYPE_BULK";        

        case USB_ENDPOINT_TYPE_ISOCHRONOUS:
                return "USB_ENDPOINT_TYPE_ISOCHRONOUS"; 
                
        case USB_ENDPOINT_TYPE_CONTROL:
                return "USB_ENDPOINT_TYPE_CONTROL";     
                
        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbConfigAttributesString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of USB_CONFIGURATION_DESCRIPTOR attributes

Arguments:

        PUSB_CONFIGURATION_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_CONFIG_POWERED_MASK;


        switch( typ) {

        case USB_CONFIG_BUS_POWERED:
                return "USB_CONFIG_BUS_POWERED";

        case USB_CONFIG_SELF_POWERED:
                return "USB_CONFIG_SELF_POWERED";
                
        case USB_CONFIG_REMOTE_WAKEUP:
                return "USB_CONFIG_REMOTE_WAKEUP";

                
        default:
                return "??? UNKNOWN!!"; 
        }
}


void
print_USB_CONFIGURATION_DESCRIPTOR(PUSB_CONFIGURATION_DESCRIPTOR cd)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB config descriptor

Arguments:

    ptr to USB configuration descriptor

Return Value:

    none

--*/
{
    printf("\n===================\nUSB_CONFIGURATION_DESCRIPTOR\n");

    printf(
    "bLength = 0x%x, decimal %d\n", cd->bLength, cd->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", cd->bDescriptorType, usbDescriptorTypeString( cd->bDescriptorType )
    );

    printf(
    "wTotalLength = 0x%x, decimal %d\n", cd->wTotalLength, cd->wTotalLength
    );

    printf(
    "bNumInterfaces = 0x%x, decimal %d\n", cd->bNumInterfaces, cd->bNumInterfaces
    );

    printf(
    "bConfigurationValue = 0x%x, decimal %d\n", cd->bConfigurationValue, cd->bConfigurationValue
    );

    printf(
    "iConfiguration = 0x%x, decimal %d\n", cd->iConfiguration, cd->iConfiguration
    );

    printf(
    "bmAttributes = 0x%x ( %s )\n", cd->bmAttributes, usbConfigAttributesString( cd->bmAttributes )
    );

    printf(
    "MaxPower = 0x%x, decimal %d\n", cd->MaxPower, cd->MaxPower
    );
}


void
print_USB_INTERFACE_DESCRIPTOR(PUSB_INTERFACE_DESCRIPTOR id, UINT ix)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB interface descriptor

Arguments:

    ptr to USB interface descriptor

Return Value:

    none

--*/
{
    printf("\n-----------------------------\nUSB_INTERFACE_DESCRIPTOR #%d\n", ix);


    printf(
    "bLength = 0x%x\n", id->bLength
    );


    printf(
    "bDescriptorType = 0x%x ( %s )\n", id->bDescriptorType, usbDescriptorTypeString( id->bDescriptorType )
    );


    printf(
    "bInterfaceNumber = 0x%x\n", id->bInterfaceNumber
    );
    printf(
    "bAlternateSetting = 0x%x\n", id->bAlternateSetting
    );
    printf(
    "bNumEndpoints = 0x%x\n", id->bNumEndpoints
    );
    printf(
    "bInterfaceClass = 0x%x\n", id->bInterfaceClass
    );
    printf(
    "bInterfaceSubClass = 0x%x\n", id->bInterfaceSubClass
    );
    printf(
    "bInterfaceProtocol = 0x%x\n", id->bInterfaceProtocol
    );
    printf(
    "bInterface = 0x%x\n", id->iInterface
    );
}


void
print_USB_ENDPOINT_DESCRIPTOR(PUSB_ENDPOINT_DESCRIPTOR ed, int i)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB endpoint descriptor

Arguments:

    ptr to USB endpoint descriptor,
        index of this endpt in interface desc

Return Value:

    none

--*/
{
    printf(
        "------------------------------\nUSB_ENDPOINT_DESCRIPTOR for Pipe%02d\n", i
        );

    printf(
    "bLength = 0x%x\n", ed->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", ed->bDescriptorType, usbDescriptorTypeString( ed->bDescriptorType )
    );


        if ( USB_ENDPOINT_DIRECTION_IN( ed->bEndpointAddress ) ) {
                printf(
                "bEndpointAddress= 0x%x ( INPUT )\n", ed->bEndpointAddress
                );
        } else {
                printf(
                "bEndpointAddress= 0x%x ( OUTPUT )\n", ed->bEndpointAddress
                );
        }

    printf(
    "bmAttributes= 0x%x ( %s )\n", ed->bmAttributes, usbEndPointTypeString ( ed->bmAttributes )
    );


    printf(
    "wMaxPacketSize= 0x%x, decimal %d\n", ed->wMaxPacketSize, ed->wMaxPacketSize
    );
    printf(
    "bInterval = 0x%x, decimal %d\n", ed->bInterval, ed->bInterval
    );
}

void
rw_dev( HANDLE hDEV )
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwbulk -u" )

Arguments:

    handle to device

Return Value:

    none

--*/
{
        UINT success;
        int siz, nBytes;
        char buf[256];
    PUSB_CONFIGURATION_DESCRIPTOR cd;
    PUSB_INTERFACE_DESCRIPTOR id;
    PUSB_ENDPOINT_DESCRIPTOR ed;

        siz = sizeof(buf);

        if (hDEV == INVALID_HANDLE_VALUE) {
                NOISY(("DEV not open"));
                return;
        }
        
        success = DeviceIoControl(hDEV,
                        IOCTL_BULKUSB_GET_CONFIG_DESCRIPTOR,
                        buf,
                        siz,
                        buf,
                        siz,
                        &nBytes,
                        NULL);

        NOISY(("request complete, success = %d nBytes = %d\n", success, nBytes));
        
        if (success) {
        ULONG i;
                UINT  j, n;
        char *pch;

        pch = buf;
                n = 0;

        cd = (PUSB_CONFIGURATION_DESCRIPTOR) pch;

        print_USB_CONFIGURATION_DESCRIPTOR( cd );

        pch += cd->bLength;

        do {

            id = (PUSB_INTERFACE_DESCRIPTOR) pch;

            print_USB_INTERFACE_DESCRIPTOR(id, n++);

            pch += id->bLength;
            for (j=0; j<id->bNumEndpoints; j++) {

                ed = (PUSB_ENDPOINT_DESCRIPTOR) pch;

                print_USB_ENDPOINT_DESCRIPTOR(ed,j);

                pch += ed->bLength;
            }
            i = (ULONG)(pch - buf);
        } while (i<cd->wTotalLength);

        }
        
        return;

}


int  dumpUsbConfig()
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwbulk -u" )

Arguments:

    none

Return Value:

    none

--*/
{

        HANDLE hDEV = open_dev();

        if ( hDEV )
        {
                rw_dev( hDEV );
                CloseHandle(hDEV);
        }

        return 0;
}
//  End, routines for USB configuration and pipe info dump  (Cmdline "rwbulk -u" )



int _cdecl main(
    int argc,
        char *argv[])
/*++
Routine Description:

    Entry point to rwbulk.exe
    Parses cmdline, performs user-requested tests

Arguments:

    argc, argv  standard console  'c' app arguments

Return Value:

    Zero

--*/

{
    char *pinBuf = NULL, *poutBuf = NULL;
    int nBytesRead, nBytesWrite, nBytes;
        ULONG i, j;
    int ok;
    UINT success;
    HANDLE hRead = INVALID_HANDLE_VALUE, hWrite = INVALID_HANDLE_VALUE;
        char buf[1024];
        clock_t start, finish;
        ULONG totalBytes = 0L;
        double seconds;
        ULONG fail = 0L;

    parse(argc, argv );

        // dump USB configuation and pipe info
        if( fDumpUsbConfig ) {
                dumpUsbConfig();
        }


        // doing a read, write, or both test
        if ((fRead) || (fWrite)) {

            if (fRead) {
            //
            // open the output file
            //
                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( ReadLen % sizeof( ULONG ) )
                                                ReadLen++;
                        }

            hRead = open_file( inPipe);
        
                pinBuf = malloc(ReadLen);

            }

            if (fWrite) {

                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( WriteLen % sizeof( ULONG ) )
                                                WriteLen++;
                        }

                hWrite = open_file( outPipe);
                poutBuf = malloc(WriteLen);
            }


        for (i=0; i<IterationCount; i++) {

            if (fWrite && poutBuf && hWrite != INVALID_HANDLE_VALUE) {

                                PULONG pOut = (PULONG) poutBuf;
                                ULONG  numLongs = WriteLen / sizeof( ULONG );
                //
                // put some data in the output buffer
                //

                for (j=0; j<numLongs; j++) {
                    *(pOut+j) = j;
                }

                //
                // send the write
                //

                    WriteFile(hWrite,
                              poutBuf,
                              WriteLen,
                              &nBytesWrite,
                              NULL);

                    printf("<%s> W (%04.4d) : request %06.6d bytes -- %06.6d bytes written\n",
                            outPipe, i, WriteLen, nBytesWrite);
                assert(nBytesWrite == WriteLen);
                }

                if (fRead && pinBuf) {

                    success = ReadFile(hRead,
                                  pinBuf,
                              ReadLen,
                                  &nBytesRead,
                                  NULL);

                    printf("<%s> R (%04.4d) : request %06.6d bytes -- %06.6d bytes read\n",
                        inPipe, i, ReadLen, nBytesRead);

                if (fWrite) {

                    //
                    // validate the input buffer against what
                    // we sent to the 82930 (loopback test)
                    //

                    ok = compare_buffs(pinBuf, poutBuf,  nBytesRead);

                                        if( fDumpReadData ) {
                                                printf("Dumping read buffer\n");
                                                dump( pinBuf, nBytesRead );     
                                                printf("Dumping write buffer\n");
                                                dump( poutBuf, nBytesRead );

                                        }

                    assert(ok);

                                        if(ok != 1)
                                                fail++;

                    assert(ReadLen == WriteLen);
                    assert(nBytesRead == ReadLen);
                    assert(nBytesWrite == WriteLen);
                }
                }
        
        }


        if (pinBuf) {
            free(pinBuf);
        }

        if (poutBuf) {
            free(poutBuf);
        }


                // close devices if needed
                if(hRead != INVALID_HANDLE_VALUE)
                        CloseHandle(hRead);
                if(hWrite != INVALID_HANDLE_VALUE)
                        CloseHandle(hWrite);

    }           

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkdev.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkdev.c

Abstract:

    This file contains dispatch routines for create, 
    close and selective suspend. 
    The selective suspend feature is enabled if
    the SSRegistryEnable key in the registry is set to 1.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkusr.h"
#include "bulkwmi.h"
#include "bulkrwr.h"

NTSTATUS
BulkUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for create.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    ULONG                       i;
    NTSTATUS                    ntStatus;
    PFILE_OBJECT                fileObject;
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          irpStack;
    PBULKUSB_PIPE_CONTEXT       pipeContext;
    PUSBD_INTERFACE_INFORMATION interface;

    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchCreate - begins\n"));

    //
    // initialize variables
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(deviceExtension->DeviceState != Working) {

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto BulkUsb_DispatchCreate_Exit;
    }

    if(deviceExtension->UsbInterface) {

        interface = deviceExtension->UsbInterface;
    }
    else {

        BulkUsb_DbgPrint(1, ("UsbInterface not found\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto BulkUsb_DispatchCreate_Exit;
    }

    //
    // FsContext is Null for the device
    //
    if(fileObject) {
        
        fileObject->FsContext = NULL; 
    }
    else {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto BulkUsb_DispatchCreate_Exit;
    }

    if(0 == fileObject->FileName.Length) {

        //
        // opening a device as opposed to pipe.
        //
        ntStatus = STATUS_SUCCESS;

        InterlockedIncrement(&deviceExtension->OpenHandleCount);

        //
        // the device is idle if it has no open handles or pending PnP Irps
        // since we just received an open handle request, cancel idle req.
        //
        if(deviceExtension->SSEnable) {
        
            CancelSelectSuspend(deviceExtension);
        }

        goto BulkUsb_DispatchCreate_Exit;
    }
    
    pipeContext = BulkUsb_PipeWithName(DeviceObject, &fileObject->FileName);

    if(pipeContext == NULL) {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto BulkUsb_DispatchCreate_Exit;
    }

    ntStatus = STATUS_INVALID_PARAMETER;

    for(i=0; i<interface->NumberOfPipes; i++) {

        if(pipeContext == &deviceExtension->PipeContext[i]) {

            //
            // found a match
            //
            BulkUsb_DbgPrint(3, ("open pipe %d\n", i));

            fileObject->FsContext = &interface->Pipes[i];
            
            ASSERT(fileObject->FsContext);

            pipeContext->PipeOpen = TRUE;

            ntStatus = STATUS_SUCCESS;

            //
            // increment OpenHandleCounts
            //
            InterlockedIncrement(&deviceExtension->OpenHandleCount);

            //
            // the device is idle if it has no open handles or pending PnP Irps
            // since we just received an open handle request, cancel idle req.
            //
            if(deviceExtension->SSEnable) {

                CancelSelectSuspend(deviceExtension);
            }
        }
    }

BulkUsb_DispatchCreate_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
BulkUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for close.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PBULKUSB_PIPE_CONTEXT  pipeContext;
    PUSBD_PIPE_INFORMATION pipeInformation;
    
    PAGED_CODE();

    //
    // initialize variables
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    pipeContext = NULL;
    pipeInformation = NULL;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClose - begins\n"));

    if(fileObject && fileObject->FsContext) {

        pipeInformation = fileObject->FsContext;

        if(0 != fileObject->FileName.Length) {

            pipeContext = BulkUsb_PipeWithName(DeviceObject, 
                                               &fileObject->FileName);
        }

        if(pipeContext && pipeContext->PipeOpen) {
            
            pipeContext->PipeOpen = FALSE;
        }
    }

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    info = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if(deviceExtension->DeviceState != Working) {

        BulkUsb_DbgPrint(1, ("Invalid device state\n"));

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = info;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchDevCtrl::"));
    BulkUsb_IoIncrement(deviceExtension);

    //
    // It is true that the client driver cancelled the selective suspend
    // request in the dispatch routine for create.
    // But there is no guarantee that it has indeed been completed.
    // so wait on the NoIdleReqPendEvent and proceed only if this event
    // is signalled.
    //
    BulkUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));
    
    //
    // make sure that the selective suspend request has been completed.
    //

    if(deviceExtension->SSEnable) {

        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    switch(code) {

    case IOCTL_BULKUSB_RESET_PIPE:
    {
        PFILE_OBJECT           fileObject;
        PUSBD_PIPE_INFORMATION pipe;

        pipe = NULL;
        fileObject = NULL;

        //
        // FileObject is the address of the kernel file object to
        // which the IRP is directed. Drivers use the FileObject
        // to correlate IRPs in a queue.
        //
        fileObject = irpStack->FileObject;

        if(fileObject == NULL) {

            ntStatus = STATUS_INVALID_PARAMETER;

            break;
        }

        pipe = (PUSBD_PIPE_INFORMATION) fileObject->FsContext;

        if(pipe == NULL) {

            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else {
            
            ntStatus = BulkUsb_ResetPipe(DeviceObject, pipe);
        }

        break;
    }

    case IOCTL_BULKUSB_GET_CONFIG_DESCRIPTOR:
    {
        ULONG length;

        if(deviceExtension->UsbConfigurationDescriptor) {

            length = deviceExtension->UsbConfigurationDescriptor->wTotalLength;

            if(outputBufferLength >= length) {

                RtlCopyMemory(ioBuffer,
                              deviceExtension->UsbConfigurationDescriptor,
                              length);

                info = length;

                ntStatus = STATUS_SUCCESS;
            }
            else {
                
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
        else {
            
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        break;
    }

    case IOCTL_BULKUSB_RESET_DEVICE:
        
        ntStatus = BulkUsb_ResetDevice(DeviceObject);

        break;

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchDevCtrl::"));
    BulkUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
BulkUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    )
/*++
 
Routine Description:

    This routine synchronously submits a URB_FUNCTION_RESET_PIPE
    request down the stack.

Arguments:

    DeviceObject - pointer to device object
    PipeInfo - pointer to PipeInformation structure
               to retrieve the pipe handle

Return Value:

    NT status value

--*/
{
    PURB              urb;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    //
    // initialize variables
    //

    urb = NULL;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_PIPE_REQUEST));

    if(urb) {

        urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = PipeInfo->PipeHandle;

        ntStatus = CallUSBD(DeviceObject, urb);

        ExFreePool(urb);
    }
    else {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NT_SUCCESS(ntStatus)) {
    
        BulkUsb_DbgPrint(3, ("BulkUsb_ResetPipe - success\n"));
        ntStatus = STATUS_SUCCESS;
    }
    else {

        BulkUsb_DbgPrint(1, ("BulkUsb_ResetPipe - failed\n"));
    }

    return ntStatus;
}

NTSTATUS
BulkUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine invokes BulkUsb_ResetParentPort to reset the device

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    NTSTATUS ntStatus;
    ULONG    portStatus;

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetDevice - begins\n"));

    ntStatus = BulkUsb_GetPortStatus(DeviceObject, &portStatus);

    if((NT_SUCCESS(ntStatus))                 &&
       (!(portStatus & USBD_PORT_ENABLED))    &&
       (portStatus & USBD_PORT_CONNECTED)) {

        ntStatus = BulkUsb_ResetParentPort(DeviceObject);
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG     PortStatus
    )
/*++
 
Routine Description:

    This routine retrieves the status value

Arguments:

    DeviceObject - pointer to device object
    PortStatus - port status

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    *PortStatus = 0;

    BulkUsb_DbgPrint(3, ("BulkUsb_GetPortStatus - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        BulkUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    BulkUsb_DbgPrint(3, ("BulkUsb_GetPortStatus - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_ResetParentPort(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine sends an IOCTL_INTERNAL_USB_RESET_PORT
    synchronously down the stack.

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetParentPort - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_RESET_PORT,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        BulkUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetParentPort - ends\n"));

    return ntStatus;
}


NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    BulkUsb_DbgPrint(3, ("SubmitIdleRequest - begins\n"));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if(PowerDeviceD0 != DeviceExtension->DevPower) {

        ntStatus = STATUS_POWER_STATE_INVALID;

        goto SubmitIdleRequestIrp_Exit;
    }

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        BulkUsb_DbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitIdleRequestIrp_Exit;
    }

    //
    // clear the NoIdleReqPendEvent because we are about 
    // to submit an idle request. Since we are so early
    // to clear this event, make sure that if we fail this
    // request we set back the event.
    //
    KeClearEvent(&DeviceExtension->NoIdleReqPendEvent);

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;

        //
        // we use IoAllocateIrp to create an irp to selectively suspend the 
        // device. This irp lies pending with the hub driver. When appropriate
        // the hub driver will invoked callback, where we power down. The completion
        // routine is invoked when we power back.
        //
        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            BulkUsb_DbgPrint(1, ("cannot build idle request irp\n"));

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitIdleRequestIrp_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;

        //
        // we initialize the count to 2.
        // The reason is, if the CancelSelectSuspend routine manages
        // to grab the irp from the device extension, then the last of the
        // CancelSelectSuspend routine/IdleNotificationRequestComplete routine 
        // to execute will free this irp. We need to have this schema so that
        // 1. completion routine does not attempt to touch the irp freed by 
        //    CancelSelectSuspend routine.
        // 2. CancelSelectSuspend routine doesnt wait for ever for the completion
        //    routine to complete!
        //
        DeviceExtension->FreeIdleIrpCount = 2;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension) ||
           PowerDeviceD0 != DeviceExtension->DevPower) {

            //
            // IRPs created using IoBuildDeviceIoControlRequest should be
            // completed by calling IoCompleteRequest and not merely 
            // deallocated.
            //
     
            BulkUsb_DbgPrint(1, ("Device is not idle\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            //
            // it is still safe to touch the local variable "irp" here.
            // the irp has not been passed down the stack, the irp has
            // no cancellation routine. The worse position is that the
            // CancelSelectSuspend has run after we released the spin 
            // lock above. It is still essential to free the irp.
            //
            if(irp) {

                IoFreeIrp(irp);
            }

            ntStatus = STATUS_UNSUCCESSFUL;

            goto SubmitIdleRequestIrp_Exit;
        }

        BulkUsb_DbgPrint(3, ("Cancel the timers\n"));
        //
        // Cancel the timer so that the DPCs are no longer fired.
        // Thus, we are making judicious usage of our resources.
        // we do not need DPCs because we already have an idle irp pending.
        // The timers are re-initialized in the completion routine.
        //
        KeCancelTimer(&DeviceExtension->Timer);

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitIdleRequestIrp_Exit;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Memory allocation for idleCallbackInfo failed\n"));

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitIdleRequestIrp_Exit:

    BulkUsb_DbgPrint(3, ("SubmitIdleRequest - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    BulkUsb_DbgPrint(3, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        BulkUsb_DbgPrint(1, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        BulkUsb_DbgPrint(3, ("IdleNotificationCallback::"));
        BulkUsb_IoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        if(STATUS_PENDING == ntStatus) {

            BulkUsb_DbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    
    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    BulkUsb_DbgPrint(3, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    LARGE_INTEGER           dueTime;
    PIRP                    idleIrp;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    BulkUsb_DbgPrint(3, ("IdleNotificationRequestCompete - begins\n"));

    idleIrp = NULL;

    //
    // check the Irp status
    //

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        BulkUsb_DbgPrint(1, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            BulkUsb_DbgPrint(1, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            BulkUsb_DbgPrint(1, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            BulkUsb_DbgPrint(1, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            BulkUsb_DbgPrint(1, ("STATUS_DEVICE_BUSY\n"));

            break;

        default:

            BulkUsb_DbgPrint(1, ("default: status = %X\n", ntStatus));

            break;
        }

        //
        // if in error, issue a SetD0 (only when not in D0)
        //

        if(PowerDeviceD0 != DeviceExtension->DevPower) {
            BulkUsb_DbgPrint(3, ("IdleNotificationRequestComplete::"));
            BulkUsb_IoIncrement(DeviceExtension);

            powerState.DeviceState = PowerDeviceD0;

            ntStatus = PoRequestPowerIrp(
                              DeviceExtension->PhysicalDeviceObject, 
                              IRP_MN_SET_POWER, 
                              powerState, 
                              (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                              DeviceExtension, 
                              NULL);

            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1, ("PoRequestPowerIrp failed\n"));
            }
        }
    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    idleIrp = (PIRP) InterlockedExchangePointer(
                                        &DeviceExtension->PendingIdleIrp,
                                        NULL);

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    //
    // since the irp was created using IoAllocateIrp, 
    // the Irp needs to be freed using IoFreeIrp.
    // Also return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not reference this in the near future.
    //

    if(idleIrp) {

        BulkUsb_DbgPrint(3, ("completion routine has a valid irp and frees it\n"));
        IoFreeIrp(Irp);
        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    else {

        //
        // The CancelSelectiveSuspend routine has grabbed the Irp from the device 
        // extension. Now the last one to decrement the FreeIdleIrpCount should
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            BulkUsb_DbgPrint(3, ("completion routine frees the irp\n"));
            IoFreeIrp(Irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    if(DeviceExtension->SSEnable) {

        BulkUsb_DbgPrint(3, ("Set the timer to fire DPCs\n"));

        dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

        KeSetTimerEx(&DeviceExtension->Timer, 
                     dueTime,
                     IDLE_INTERVAL,                              // 5000 ms
                     &DeviceExtension->DeferredProcCall);

        BulkUsb_DbgPrint(3, ("IdleNotificationRequestCompete - ends\n"));
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked to cancel selective suspend request.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None.

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    BulkUsb_DbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        BulkUsb_DbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    //
    // since we have a valid Irp ptr,
    // we can call IoCancelIrp on it,
    // without the fear of the irp 
    // being freed underneath us.
    //
    if(irp) {

        //
        // This routine has the irp pointer.
        // It is safe to call IoCancelIrp because we know that
        // the compleiton routine will not free this irp unless...
        // 
        //        
        if(IoCancelIrp(irp)) {

            BulkUsb_DbgPrint(3, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            BulkUsb_DbgPrint(3, ("IoCancelIrp returns FALSE\n"));
        }

        //
        // ....we decrement the FreeIdleIrpCount from 2 to 1.
        // if completion routine runs ahead of us, then this routine 
        // decrements the FreeIdleIrpCount from 1 to 0 and hence shall
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            BulkUsb_DbgPrint(3, ("CancelSelectSuspend frees the irp\n"));
            IoFreeIrp(irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    BulkUsb_DbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in 
    IdleNotificationCallback.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //
    irpContext = NULL;

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        BulkUsb_DbgPrint(3, ("PoIrpCompletionFunc::"));
        BulkUsb_IoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in IdleNotification
    RequestComplete routine.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    BulkUsb_DbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    BulkUsb_IoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for PoRequest wait wake irp

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.    

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    BulkUsb_DbgPrint(3, ("WWIrpCompletionFunc::"));
    BulkUsb_IoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkdev.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkdev.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_DEV_H
#define _BULKUSB_DEV_H

NTSTATUS
BulkUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    );

NTSTATUS
BulkUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
BulkUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    );

NTSTATUS
BulkUsb_ResetParentPort(
    IN IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkpnp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_PNP_H
#define _BULKUSB_PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
BulkUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
BulkUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    );

NTSTATUS
BulkUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
BulkUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
BulkUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
BulkUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkpnp.c

Abstract:

	Bulk USB device driver for Intel 82930 USB test board
	Plug and Play module.
    This file contains routines to handle pnp requests.
    These routines are not USB specific but is required
    for every driver which conforms to the WDM model.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

NTSTATUS
BulkUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.
    Most of these requests the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status value

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    BulkUsb_DbgPrint(3, ("///////////////////////////////////////////\n"));
    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::"));
    BulkUsb_IoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        if(deviceExtension->SSEnable) {

            CancelSelectSuspend(deviceExtension);
        }
    }

    BulkUsb_DbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // if we cannot stop the device, we fail the query stop irp
        //

        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // if we cannot remove the device, we fail the query remove irp
        //
        ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::default::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;

    } // switch

//
// complete request 
//

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//
// decrement count
//
    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::"));
    BulkUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

    This is the dispatch routine for IRP_MN_START_DEVICE

Arguments:

    DeviceObject - pointer to a device object.

    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    BulkUsb_DbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    deviceExtension->UsbConfigurationDescriptor = NULL;
    deviceExtension->UsbInterface = NULL;
    deviceExtension->PipeContext = NULL;

    //
    // We cannot touch the device (send it any non pnp irps) until a
    // start device has been passed down to the lower drivers.
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake outstanding flag to false.
    // and issue a wait wake.
    
    deviceExtension->FlagWWOutstanding = 0;
    deviceExtension->FlagWWCancel = 0;
    deviceExtension->WaitWakeIrp = NULL;
    
    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);


    if(WinXpOrBetter == deviceExtension->WdmVersion) {


        deviceExtension->SSEnable = deviceExtension->SSRegistryEnable;

        //
        // set timer.for selective suspend requests
        //

        if(deviceExtension->SSEnable) {

            dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

            KeSetTimerEx(&deviceExtension->Timer, 
                         dueTime,
                         IDLE_INTERVAL,                              // 5000 ms
                         &deviceExtension->DeferredProcCall);

            deviceExtension->FreeIdleIrpCount = 0;
        }
    }

    BulkUsb_DbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine configures the USB device.
    In this routines we get the device descriptor, 
    the configuration descriptor and select the
    configuration descriptor.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value.

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
                            
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to allocate memory for deviceDescriptor\n"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to allocate memory for urb\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;

    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1,("Failed to read configuration descriptor\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        //
        // save a copy of configurationDescriptor in deviceExtension
        // remember to free it later.
        //
        deviceExtension->UsbConfigurationDescriptor = configurationDescriptor;

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }
    else {

        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++
 
Routine Description:

    This helper routine selects the configuration

Arguments:

    DeviceObject - pointer to device object
    ConfigurationDescriptor - pointer to the configuration
    descriptor for the device

Return Value:

    NT status value

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION Interface;

    //
    // initialize the variables
    //

    urb = NULL;
    Interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        BulkUsb_DbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        Interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<Interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            Interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(NT_SUCCESS(ntStatus)) {

            //
            // save a copy of interface information in the device extension.
            //
            deviceExtension->UsbInterface = ExAllocatePool(NonPagedPool,
                                                           Interface->Length);

            if(deviceExtension->UsbInterface) {
                
                RtlCopyMemory(deviceExtension->UsbInterface,
                              Interface,
                              Interface->Length);
            }
            else {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                BulkUsb_DbgPrint(1, ("memory alloc for UsbInterface failed\n"));
            }

            //
            // Dump the interface to the debugger
            //

            Interface = &urb->UrbSelectConfiguration.Interface;

            BulkUsb_DbgPrint(3, ("---------\n"));
            BulkUsb_DbgPrint(3, ("NumberOfPipes 0x%x\n", 
                                 Interface->NumberOfPipes));
            BulkUsb_DbgPrint(3, ("Length 0x%x\n", 
                                 Interface->Length));
            BulkUsb_DbgPrint(3, ("Alt Setting 0x%x\n", 
                                 Interface->AlternateSetting));
            BulkUsb_DbgPrint(3, ("Interface Number 0x%x\n", 
                                 Interface->InterfaceNumber));
            BulkUsb_DbgPrint(3, ("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                 Interface->Class,
                                 Interface->SubClass,
                                 Interface->Protocol));
            //
            // Initialize the PipeContext
            // Dump the pipe info
            //

            if(Interface->NumberOfPipes) {
                deviceExtension->PipeContext = 
                    ExAllocatePool(NonPagedPool,
                                   Interface->NumberOfPipes *
                                   sizeof(BULKUSB_PIPE_CONTEXT));

                if(deviceExtension->PipeContext) {
                
                    for(i=0; i<Interface->NumberOfPipes; i++) {

                        deviceExtension->PipeContext[i].PipeOpen = FALSE;
                    }
                }
                else {
                    
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    BulkUsb_DbgPrint(1, ("memory alloc for UsbInterface failed\n"));
                }
            }

            for(i=0; i<Interface->NumberOfPipes; i++) {

                BulkUsb_DbgPrint(3, ("---------\n"));
                BulkUsb_DbgPrint(3, ("PipeType 0x%x\n", 
                                     Interface->Pipes[i].PipeType));
                BulkUsb_DbgPrint(3, ("EndpointAddress 0x%x\n", 
                                     Interface->Pipes[i].EndpointAddress));
                BulkUsb_DbgPrint(3, ("MaxPacketSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumPacketSize));
                BulkUsb_DbgPrint(3, ("Interval 0x%x\n", 
                                     Interface->Pipes[i].Interval));
                BulkUsb_DbgPrint(3, ("Handle 0x%x\n", 
                                     Interface->Pipes[i].PipeHandle));
                BulkUsb_DbgPrint(3, ("MaximumTransferSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumTransferSize));
            }

            BulkUsb_DbgPrint(3, ("---------\n"));
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        BulkUsb_DbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine is invoked when the device is removed or stopped.
    This routine de-configures the usb device.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

    This routine synchronously submits an urb down the stack.

Arguments:

    DeviceObject - pointer to device object
    Urb - USB request block

Return Value:

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        BulkUsb_DbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    BulkUsb_DbgPrint(3, ("CallUSBD::"));
    BulkUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    BulkUsb_DbgPrint(3, ("CallUSBD::"));
    BulkUsb_IoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services the Irps of minor type IRP_MN_QUERY_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    BulkUsb_DbgPrint(3, ("HandleQueryStopDevice::"));
    BulkUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT value

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    BulkUsb_DbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This routine services Irp of minor type IRP_MN_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // Thus, we are making judicious usage of our resources.
            // we do not need DPCs because the device is stopping.
            // The timers are re-initialized while handling the start
            // device irp.
            //

            KeCancelTimer(&deviceExtension->Timer);

            //
            // after the device is stopped, it can be surprise removed.
            // we set this to 0, so that we do not attempt to cancel
            // the timer while handling surprise remove or remove irps.
            // when we get the start device request, this flag will be
            // reinitialized.
            //
            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    if(deviceExtension->WaitWakeEnable) {
    
        CancelWaitWake(deviceExtension);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //

    ReleaseMemory(DeviceObject);

    ntStatus = DeconfigureDevice(DeviceObject);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    ntStatus = CanRemoveDevice(DeviceObject, Irp);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    BulkUsb_DbgPrint(3, ("HandleQueryRemoveDevice::"));
    BulkUsb_IoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    BulkUsb_DbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_SURPRISE_REMOVAL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    if(deviceExtension->WaitWakeEnable) {
    
        CancelWaitWake(deviceExtension);
    }


    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // we do not need DPCs because the device has been surprise
            // removed
            //  
        
            KeCancelTimer(&deviceExtension->Timer);

            deviceExtension->SSEnable = 0;

            //  
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }

    RtlFreeUnicodeString(&deviceExtension->InterfaceName);

    BulkUsb_AbortPipes(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        if(deviceExtension->WaitWakeEnable) {
        
            CancelWaitWake(deviceExtension);
        }

        if(WinXpOrBetter == deviceExtension->WdmVersion) {

            if(deviceExtension->SSEnable) {

                //
                // Cancel the timer so that the DPCs are no longer fired.
                // we do not need DPCs because the device has been removed
                //            
                KeCancelTimer(&deviceExtension->Timer);

                deviceExtension->SSEnable = 0;

                //
                // make sure that if a DPC was fired before we called cancel timer,
                // then the DPC and work-time have run to their completion
                //
                KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);

                //
                // make sure that the selective suspend request has been completed.
                //  
                KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);
            }
        }

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        RtlFreeUnicodeString(&deviceExtension->InterfaceName);

        BulkUsb_AbortPipes(DeviceObject);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    BulkUsb_WmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = BulkUsb_IoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = BulkUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    ReleaseMemory(DeviceObject);
    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    //
    // Detach the FDO from the device stack
    //
    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_CAPABILITIES

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value  

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    BulkUsb_DbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    //
    // We will provide here an example of an IRP that is processed
    // both on its way down and on its way up: there might be no need for
    // a function driver process this Irp (the bus driver will do that).
    // The driver will wait for the lower drivers (the bus driver among 
    // them) to process this IRP, then it processes it again.
    //

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        BulkUsb_DbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Add in the SurpriseRemovalOK bit before passing it down.
    //
    pdc->SurpriseRemovalOK = TRUE;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }

        //
        // since its safe to surprise-remove this device, we shall
        // set the SurpriseRemoveOK flag to supress any dialog to 
        // user.
        //

        pdc->SurpriseRemovalOK = 1;
    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    BulkUsb_DbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

    DPC routine triggered by the timer to check the idle state
    of the device and submit an idle request for the device.

Arguments:

    DeferredContext - context for the dpc routine.
                      DeviceObject in our case.

Return Value:

    None

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    BulkUsb_DbgPrint(3, ("DpcRoutine - begins\n"));

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // Clear this event since a DPC has been fired!
    //
    KeClearEvent(&deviceExtension->NoDpcWorkItemPendingEvent);

    if(CanDeviceSuspend(deviceExtension)) {

        BulkUsb_DbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            BulkUsb_DbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // signal the NoDpcWorkItemPendingEvent.
            //
            KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }
    else {
        
        BulkUsb_DbgPrint(3, ("Idle event not signaled\n"));

        //
        // signal the NoDpcWorkItemPendingEvent.
        //
        KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }

    BulkUsb_DbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the work item fired from the DPC.
    This workitem checks the idle state of the device
    and submits an idle request.

Arguments:

    DeviceObject - pointer to device object
    Context - context for the work item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    BulkUsb_DbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        BulkUsb_DbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        BulkUsb_DbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    //
    // signal the NoDpcWorkItemPendingEvent.
    //
    KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
               IO_NO_INCREMENT,
               FALSE);

    BulkUsb_DbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    Remove and process the entries in the queue. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are complete with STATUS_DELETE_PENDING

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    BulkUsb_DbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                BulkUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                BulkUsb_IoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                BulkUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                BulkUsb_IoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY cancelEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(cancelEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    BulkUsb_DbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}

NTSTATUS
BulkUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    )
/*++
 
Routine Description:

    This routine reads the specified reqistry value.

Arguments:

    RegPath - registry path
    ValueName - property to be fetched from the registry
    Value - corresponding value read from the registry.

Return Value:

    NT status value

--*/
{
    ULONG                    defaultData;
    WCHAR                    buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS                 ntStatus;
    UNICODE_STRING           regPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    BulkUsb_DbgPrint(3, ("BulkUsb_GetRegistryDword - begins\n"));

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    RtlZeroMemory(regPath.Buffer, regPath.MaximumLength);
    RtlMoveMemory(regPath.Buffer,
                  RegPath,
                  wcslen(RegPath) * sizeof(WCHAR));

    RtlZeroMemory(paramTable, sizeof(paramTable));

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = ValueName;
    paramTable[0].EntryContext = Value;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &defaultData;
    paramTable[0].DefaultLength = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE |
                                      RTL_REGISTRY_OPTIONAL,
                                      regPath.Buffer,
                                      paramTable,
                                      NULL,
                                      NULL);

    if(NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(3, ("success Value = %X\n", *Value));
        return STATUS_SUCCESS;
    }
    else {

        *Value = 0;
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
BulkUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_CLEANUP

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager

Return Value:

    NT status value

--*/
{
    PDEVICE_EXTENSION  deviceExtension;
    KIRQL              oldIrql;
    LIST_ENTRY         cleanupList;
    PLIST_ENTRY        thisEntry, 
                       nextEntry, 
                       listHead;
    PIRP               pendingIrp;
    PIO_STACK_LOCATION pendingIrpStack, 
                       irpStack;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    InitializeListHead(&cleanupList);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClean::"));
    BulkUsb_IoIncrement(deviceExtension);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClean::"));
    BulkUsb_IoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}


BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the routine where we check if the device
    can selectively suspend. 

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    TRUE - if the device can suspend
    FALSE - otherwise.

--*/
{
    BulkUsb_DbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}

NTSTATUS
BulkUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description

    sends an abort pipe request for open pipes.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB                        urb;
    ULONG                       i;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PBULKUSB_PIPE_CONTEXT       pipeContext;
    PUSBD_PIPE_INFORMATION      pipeInformation;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pipeContext = deviceExtension->PipeContext;
    interfaceInfo = deviceExtension->UsbInterface;
    
    BulkUsb_DbgPrint(3, ("BulkUsb_AbortPipes - begins\n"));
    
    if(interfaceInfo == NULL || pipeContext == NULL) {

        return STATUS_SUCCESS;
    }

    for(i=0; i<interfaceInfo->NumberOfPipes; i++) {

        if(pipeContext[i].PipeOpen) {

            BulkUsb_DbgPrint(3, ("Aborting open pipe %d\n", i));
    
            urb = ExAllocatePool(NonPagedPool,
                                 sizeof(struct _URB_PIPE_REQUEST));

            if(urb) {

                urb->UrbHeader.Length = sizeof(struct _URB_PIPE_REQUEST);
                urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                urb->UrbPipeRequest.PipeHandle = 
                                        interfaceInfo->Pipes[i].PipeHandle;

                ntStatus = CallUSBD(DeviceObject, urb);

                ExFreePool(urb);
            }
            else {

                BulkUsb_DbgPrint(1, ("Failed to alloc memory for urb\n"));

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                return ntStatus;
            }

            if(NT_SUCCESS(ntStatus)) {

                pipeContext[i].PipeOpen = FALSE;
            }
        }
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_AbortPipes - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine is a completion routine.
    In this routine we set an event.

    Since the completion routine returns 
    STATUS_MORE_PROCESSING_REQUIRED, the Irps,
    which set this routine as the completion routine,
    should be marked pending.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - 

Return Value:

    NT status value

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


LONG
BulkUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine bumps up the I/O count.
    This routine is typically invoked when any of the
    dispatch routines handle new irps for the driver.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    BulkUsb_DbgPrint(3, ("BulkUsb_IoIncrement::%d\n", result));

    return result;
}

LONG
BulkUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine decrements the outstanding I/O count
    This is typically invoked after the dispatch routine
    has finished processing the irp.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    BulkUsb_DbgPrint(3, ("BulkUsb_IoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely stopped. In our 
    particular case, we'll assume we can always stop the device.
    A device might fail the request if it doesn't have a queue for the
    requests it might come or if it was notified that it is in the paging
    path. 
  
Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.

Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely removed. In our 
    particular case, we'll assume we can always remove the device.
    A device shouldn't be removed if, for example, it has open handles or
    removing the device could result in losing data (plus the reasons 
    mentioned at CanStopDevice). The PnP manager on Windows 2000 fails 
    on its own any attempt to remove, if there any open handles to the device. 
    However on Win9x, the driver must keep count of open handles and fail 
    query_remove if there are any open handles.

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine returns all the memory allocations acquired during
    device startup. 
    
Arguments:

    DeviceObject - pointer to the device object.
        
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
    //
    // Disconnect from the interrupt and unmap any I/O ports
    //
    
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(deviceExtension->UsbConfigurationDescriptor) {

        ExFreePool(deviceExtension->UsbConfigurationDescriptor);
        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

    if(deviceExtension->UsbInterface) {
        
        ExFreePool(deviceExtension->UsbInterface);
        deviceExtension->UsbInterface = NULL;
    }

    if(deviceExtension->PipeContext) {

        ExFreePool(deviceExtension->PipeContext);
        deviceExtension->PipeContext = NULL;
    }

    return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    bulkpwr.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    This code is not USB specific. It is essential for every WDM driver
    to handle power irps.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpwr.h"
#include "bulkpnp.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

NTSTATUS
BulkUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    The power dispatch routine.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPower::"));
    BulkUsb_IoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            HandleSystemSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            HandleSystemQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("Lower drivers failed the wait-wake Irp\n"));
        }

        ntStatus = STATUS_PENDING;

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        BulkUsb_DbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        BulkUsb_IoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("Lower drivers failed default power Irp\n"));
        }
        
        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPower::"));
        BulkUsb_IoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine handles the irp with minor function of type IRP_MN_QUERY_POWER
    for the system power states.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    BulkUsb_DbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    BulkUsb_DbgPrint(3, ("Query for system power state S%X\n"
                         "Current system power state S%X\n",
                         systemState - 1,
                         deviceExtension->SysPower - 1));

    //
    // if querying for a lower S-state, issue a wait-wake
    //

    if((systemState > deviceExtension->SysPower) &&
       (deviceExtension->WaitWakeEnable)) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the system power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    BulkUsb_DbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    BulkUsb_DbgPrint(3, ("Set request for system power state S%X\n"
                         "Current system power state S%X\n",
                         systemState - 1,
                         deviceExtension->SysPower - 1));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_QUERY_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    BulkUsb_DbgPrint(3, ("Query for device power state D%X\n"
                         "Current device power state D%X\n",
                         deviceState - 1,
                         deviceExtension->DevPower - 1));

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower::"));
    BulkUsb_IoDecrement(deviceExtension);

    BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the completion routine for the system power irps of minor
    function types IRP_MN_QUERY_POWER and IRP_MN_SET_POWER.
    This completion routine sends the corresponding device power irp and
    returns STATUS_MORE_PROCESSING_REQUIRED. The system irp is passed as a
    context to the device power irp completion routine and is completed in
    the device power irp completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    BulkUsb_DbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        BulkUsb_DbgPrint(3, ("SysPoCompletionRoutine::"));
        BulkUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine of the system power
    irp. This routine will PoRequest a device power irp. The system irp is 
    passed as a context to the the device power irp.

Arguments:

    DeviceObject - pointer to device object
    SIrp - system power irp.

Return Value:

    None

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        BulkUsb_DbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        BulkUsb_DbgPrint(3, ("SendDeviceIrp::"));
        BulkUsb_IoDecrement(deviceExtension);

    }

    BulkUsb_DbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest - completion routine for the device power irp.
    This routine is responsible for completing the system power irp, 
    received as a context.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - minor function of the irp.
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status of the device power irp.

Return Value:

    None

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    BulkUsb_DbgPrint(3, ("DevPoCompletionRoutine::"));
    BulkUsb_IoDecrement(deviceExtension);

    ExFreePool(powerContext);

    BulkUsb_DbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    BulkUsb_DbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    BulkUsb_DbgPrint(3, ("Set request for device power state D%X\n"
                         "Current device power state D%X\n",
                         newDevState - 1,
                         deviceExtension->DevPower - 1));

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        BulkUsb_DbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //

            BulkUsb_DbgPrint(3, ("Removing power from the device\n"));

            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                BulkUsb_DbgPrint(3, ("HandleDeviceSetPower::"));
                BulkUsb_IoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }

        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //

            BulkUsb_DbgPrint(3, ("A SetD0 request\n"));

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    BulkUsb_DbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    completion routine for the device power UP irp with minor function
    IRP_MN_SET_POWER.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    BulkUsb_DbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        BulkUsb_DbgPrint(3, ("FinishDevPoUpIrp::"));
        BulkUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    BulkUsb_DbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine processes queue of pending irps.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    BulkUsb_DbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("SetDeviceFunctional::"));
    BulkUsb_IoDecrement(DeviceExtension);

    BulkUsb_DbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is the completion routine for device power DOWN irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    BulkUsb_DbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        BulkUsb_DbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    BulkUsb_DbgPrint(3, ("FinishDevPoDnIrp::"));
    BulkUsb_IoDecrement(DeviceExtension);

    BulkUsb_DbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine is called on query or set power DOWN irp for the device.
    This routine queues a workitem.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            BulkUsb_DbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    BulkUsb_DbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine waits for the I/O in progress to finish and then
    sends the device power irp (query/set) down the stack.

Arguments:

    DeviceObject - pointer to device object
    Context - context passed to the work-item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke BulkUsb_IoDecrement twice: once each for the S-Irp and D-Irp.
    //
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoDecrement(deviceExtension);
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoIncrement(deviceExtension);
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Queue the Irp in the device queue

Arguments:

    DeviceExtension - pointer to device extension
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    BulkUsb_DbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    BulkUsb_DbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine removes the irp from the queue and completes it with
    STATUS_CANCELLED

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    BulkUsb_DbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine will PoRequest a WAIT WAKE irp for the device

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value.

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    BulkUsb_DbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        return STATUS_DEVICE_BUSY;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    BulkUsb_DbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine cancels the Wait Wake request.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    None.

--*/
{
    PIRP Irp;

    BulkUsb_DbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    BulkUsb_DbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the IoSet completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    BulkUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    BulkUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - irp minor function
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status block.

Return Value:

    None

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    BulkUsb_DbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        BulkUsb_DbgPrint(3, ("device already powered up...\n"));

        return;
    }

    BulkUsb_DbgPrint(3, ("WaitWakeCallback::"));
    BulkUsb_IoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    BulkUsb_DbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkpwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_POWER_H
#define _BULKUSB_POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
BulkUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkrwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkrwr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/
#ifndef _BULKUSB_RWR_H
#define _BULKUSB_RWR_H

typedef struct _BULKUSB_RW_CONTEXT {

    PURB              Urb;
    PMDL              Mdl;
    ULONG             Length;         // remaining to xfer
    ULONG             Numxfer;        // cumulate xfer
    ULONG_PTR         VirtualAddress; // va for next segment of xfer.
    PDEVICE_EXTENSION DeviceExtension;

} BULKUSB_RW_CONTEXT, * PBULKUSB_RW_CONTEXT;

PBULKUSB_PIPE_CONTEXT
BulkUsb_PipeWithName(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PUNICODE_STRING FileName
    );

NTSTATUS
BulkUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_ReadWriteCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkrwr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkrwr.c

Abstract:

    This file has routines to perform reads and writes.
    The read and writes are for bulk transfers.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

PBULKUSB_PIPE_CONTEXT
BulkUsb_PipeWithName(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PUNICODE_STRING FileName
    )
/*++
 
Routine Description:

    This routine will pass the string pipe name and
    fetch the pipe number.

Arguments:

    DeviceObject - pointer to DeviceObject
    FileName - string pipe name

Return Value:

    The device extension maintains a pipe context for 
    the pipes on 82930 board.
    This routine returns the pointer to this context in
    the device extension for the "FileName" pipe.

--*/
{
    LONG                  ix;
    ULONG                 uval; 
    ULONG                 nameLength;
    ULONG                 umultiplier;
    PDEVICE_EXTENSION     deviceExtension;
    PBULKUSB_PIPE_CONTEXT pipeContext;

    //
    // initialize variables
    //
    pipeContext = NULL;
    //
    // typedef WCHAR *PWSTR;
    //
    nameLength = (FileName->Length / sizeof(WCHAR));
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_PipeWithName - begins\n"));

    if(nameLength != 0) {
    
        BulkUsb_DbgPrint(3, ("Filename = %ws nameLength = %d\n", FileName->Buffer, nameLength));

        //
        // Parse the pipe#
        //
        ix = nameLength - 1;

        // if last char isn't digit, decrement it.
        while((ix > -1) &&
              ((FileName->Buffer[ix] < (WCHAR) '0')  ||
               (FileName->Buffer[ix] > (WCHAR) '9')))             {

            ix--;
        }

        if(ix > -1) {

            uval = 0;
            umultiplier = 1;

            // traversing least to most significant digits.

            while((ix > -1) &&
                  (FileName->Buffer[ix] >= (WCHAR) '0') &&
                  (FileName->Buffer[ix] <= (WCHAR) '9'))          {
        
                uval += (umultiplier *
                         (ULONG) (FileName->Buffer[ix] - (WCHAR) '0'));

                ix--;
                umultiplier *= 10;
            }

            if(uval < 6 && deviceExtension->PipeContext) {
        
                pipeContext = &deviceExtension->PipeContext[uval];
            }
        }
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_PipeWithName - ends\n"));

    return pipeContext;
}

NTSTATUS
BulkUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for read and write.
    This routine creates a BULKUSB_RW_CONTEXT for a read/write.
    This read/write is performed in stages of BULKUSB_MAX_TRANSFER_SIZE.
    once a stage of transfer is complete, then the irp is circulated again, 
    until the requested length of tranfer is performed.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    PMDL                   mdl;
    PURB                   urb;
    ULONG                  totalLength;
    ULONG                  stageLength;
    ULONG                  urbFlags;
    BOOLEAN                read;
    NTSTATUS               ntStatus;
    ULONG_PTR              virtualAddress;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PIO_STACK_LOCATION     nextStack;
    PBULKUSB_RW_CONTEXT    rwContext;
    PUSBD_PIPE_INFORMATION pipeInformation;

    //
    // initialize variables
    //
    urb = NULL;
    mdl = NULL;
    rwContext = NULL;
    totalLength = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    read = (irpStack->MajorFunction == IRP_MJ_READ) ? TRUE : FALSE;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchReadWrite - begins\n"));

    if(deviceExtension->DeviceState != Working) {

        BulkUsb_DbgPrint(1, ("Invalid device state\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto BulkUsb_DispatchReadWrite_Exit;
    }

    //
    // It is true that the client driver cancelled the selective suspend
    // request in the dispatch routine for create Irps.
    // But there is no guarantee that it has indeed completed.
    // so wait on the NoIdleReqPendEvent and proceed only if this event
    // is signalled.
    //
    BulkUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));
    
    //
    // make sure that the selective suspend request has been completed.
    //

    if(deviceExtension->SSEnable) {

        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    if(fileObject && fileObject->FsContext) {

        pipeInformation = fileObject->FsContext;

        if((UsbdPipeTypeBulk != pipeInformation->PipeType) &&
           (UsbdPipeTypeInterrupt != pipeInformation->PipeType)) {
            
            BulkUsb_DbgPrint(1, ("Usbd pipe type is not bulk or interrupt\n"));

            ntStatus = STATUS_INVALID_HANDLE;
            goto BulkUsb_DispatchReadWrite_Exit;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Invalid handle\n"));

        ntStatus = STATUS_INVALID_HANDLE;
        goto BulkUsb_DispatchReadWrite_Exit;
    }

    rwContext = (PBULKUSB_RW_CONTEXT)
                ExAllocatePool(NonPagedPool,
                               sizeof(BULKUSB_RW_CONTEXT));

    if(rwContext == NULL) {
        
        BulkUsb_DbgPrint(1, ("Failed to alloc mem for rwContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto BulkUsb_DispatchReadWrite_Exit;
    }

    if(Irp->MdlAddress) {

        totalLength = MmGetMdlByteCount(Irp->MdlAddress);
    }

    if(totalLength > BULKUSB_TEST_BOARD_TRANSFER_BUFFER_SIZE) {

        BulkUsb_DbgPrint(1, ("Transfer length > circular buffer\n"));

        ntStatus = STATUS_INVALID_PARAMETER;

        ExFreePool(rwContext);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    if(totalLength == 0) {

        BulkUsb_DbgPrint(1, ("Transfer data length = 0\n"));

        ntStatus = STATUS_SUCCESS;

        ExFreePool(rwContext);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    urbFlags = USBD_SHORT_TRANSFER_OK;
    virtualAddress = (ULONG_PTR) MmGetMdlVirtualAddress(Irp->MdlAddress);

    if(read) {

        urbFlags |= USBD_TRANSFER_DIRECTION_IN;
        BulkUsb_DbgPrint(3, ("Read operation\n"));
    }
    else {

        urbFlags |= USBD_TRANSFER_DIRECTION_OUT;
        BulkUsb_DbgPrint(3, ("Write operation\n"));
    }

    //
    // the transfer request is for totalLength.
    // we can perform a max of BULKUSB_MAX_TRANSFER_SIZE
    // in each stage.
    //
    if(totalLength > BULKUSB_MAX_TRANSFER_SIZE) {

        stageLength = BULKUSB_MAX_TRANSFER_SIZE;
    }
    else {

        stageLength = totalLength;
    }

    mdl = IoAllocateMdl((PVOID) virtualAddress,
                        totalLength,
                        FALSE,
                        FALSE,
                        NULL);

    if(mdl == NULL) {
    
        BulkUsb_DbgPrint(1, ("Failed to alloc mem for mdl\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        ExFreePool(rwContext);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    //
    // map the portion of user-buffer described by an mdl to another mdl
    //
    IoBuildPartialMdl(Irp->MdlAddress,
                      mdl,
                      (PVOID) virtualAddress,
                      stageLength);

    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));

    if(urb == NULL) {

        BulkUsb_DbgPrint(1, ("Failed to alloc mem for urb\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        ExFreePool(rwContext);
        IoFreeMdl(mdl);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    UsbBuildInterruptOrBulkTransferRequest(
                            urb,
                            sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                            pipeInformation->PipeHandle,
                            NULL,
                            mdl,
                            stageLength,
                            urbFlags,
                            NULL);

    //
    // set BULKUSB_RW_CONTEXT parameters.
    //
    
    rwContext->Urb             = urb;
    rwContext->Mdl             = mdl;
    rwContext->Length          = totalLength - stageLength;
    rwContext->Numxfer         = 0;
    rwContext->VirtualAddress  = virtualAddress + stageLength;
    rwContext->DeviceExtension = deviceExtension;

    //
    // use the original read/write irp as an internal device control irp
    //

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = (PVOID) urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                             IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)BulkUsb_ReadWriteCompletion,
                           rwContext,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // since we return STATUS_PENDING call IoMarkIrpPending.
    // This is the boiler plate code.
    // This may cause extra overhead of an APC for the Irp completion
    // but this is the correct thing to do.
    //

    IoMarkIrpPending(Irp);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchReadWrite::"));
    BulkUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("IoCallDriver fails with status %X\n", ntStatus));

        //
        // if the device was yanked out, then the pipeInformation 
        // field is invalid.
        // similarly if the request was cancelled, then we need not
        // invoked reset pipe/device.
        //
        if((ntStatus != STATUS_CANCELLED) && 
           (ntStatus != STATUS_DEVICE_NOT_CONNECTED)) {
            
            ntStatus = BulkUsb_ResetPipe(DeviceObject,
                                     pipeInformation);
    
            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1, ("BulkUsb_ResetPipe failed\n"));

                ntStatus = BulkUsb_ResetDevice(DeviceObject);
            }
        }
        else {

            BulkUsb_DbgPrint(3, ("ntStatus is STATUS_CANCELLED or "
                                 "STATUS_DEVICE_NOT_CONNECTED\n"));
        }
    }

    //
    // we return STATUS_PENDING and not the status returned by the lower layer.
    //
    return STATUS_PENDING;

BulkUsb_DispatchReadWrite_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchReadWrite - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_ReadWriteCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine for reads/writes
    If the irp completes with success, we check if we
    need to recirculate this irp for another stage of
    transfer. In this case return STATUS_MORE_PROCESSING_REQUIRED.
    if the irp completes in error, free all memory allocs and
    return the status.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - context passed to the completion routine.

Return Value:

    NT status value

--*/
{
    ULONG               stageLength;
    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  nextStack;
    PBULKUSB_RW_CONTEXT rwContext;

    //
    // initialize variables
    //
    rwContext = (PBULKUSB_RW_CONTEXT) Context;
    ntStatus = Irp->IoStatus.Status;

    UNREFERENCED_PARAMETER(DeviceObject);
    BulkUsb_DbgPrint(3, ("BulkUsb_ReadWriteCompletion - begins\n"));

    //
    // successfully performed a stageLength of transfer.
    // check if we need to recirculate the irp.
    //
    if(NT_SUCCESS(ntStatus)) {

        if(rwContext) {

            rwContext->Numxfer += 
              rwContext->Urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
        
            if(rwContext->Length) {

                //
                // another stage transfer
                //
                BulkUsb_DbgPrint(3, ("Another stage transfer...\n"));

                if(rwContext->Length > BULKUSB_MAX_TRANSFER_SIZE) {
            
                    stageLength = BULKUSB_MAX_TRANSFER_SIZE;
                }
                else {
                
                    stageLength = rwContext->Length;
                }

                // the source MDL is not mapped and so when the lower driver
                // calls MmGetSystemAddressForMdl(Safe) on Urb->Mdl (target Mdl), 
                // system PTEs are used.
                // IoFreeMdl calls MmPrepareMdlForReuse to release PTEs (unlock
                // VA address before freeing any Mdl
                // Rather than calling IoFreeMdl and IoAllocateMdl each time,
                // just call MmPrepareMdlForReuse
                // Not calling MmPrepareMdlForReuse will leak system PTEs
                // 
                MmPrepareMdlForReuse(rwContext->Mdl);

                IoBuildPartialMdl(Irp->MdlAddress,
                                  rwContext->Mdl,
                                  (PVOID) rwContext->VirtualAddress,
                                  stageLength);
            
                //
                // reinitialize the urb
                //
                rwContext->Urb->UrbBulkOrInterruptTransfer.TransferBufferLength 
                                                                  = stageLength;
                rwContext->VirtualAddress += stageLength;
                rwContext->Length -= stageLength;

                nextStack = IoGetNextIrpStackLocation(Irp);
                nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                nextStack->Parameters.Others.Argument1 = rwContext->Urb;
                nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                            IOCTL_INTERNAL_USB_SUBMIT_URB;

                IoSetCompletionRoutine(Irp,
                                       BulkUsb_ReadWriteCompletion,
                                       rwContext,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                IoCallDriver(rwContext->DeviceExtension->TopOfStackDeviceObject, 
                             Irp);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else {

                //
                // this is the last transfer
                //

                Irp->IoStatus.Information = rwContext->Numxfer;
            }
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("ReadWriteCompletion - failed with status = %X\n", ntStatus));
    }
    
    if(rwContext) {

        //
        // dump rwContext
        //
        BulkUsb_DbgPrint(3, ("rwContext->Urb             = %X\n", 
                             rwContext->Urb));
        BulkUsb_DbgPrint(3, ("rwContext->Mdl             = %X\n", 
                             rwContext->Mdl));
        BulkUsb_DbgPrint(3, ("rwContext->Length          = %d\n", 
                             rwContext->Length));
        BulkUsb_DbgPrint(3, ("rwContext->Numxfer         = %d\n", 
                             rwContext->Numxfer));
        BulkUsb_DbgPrint(3, ("rwContext->VirtualAddress  = %X\n", 
                             rwContext->VirtualAddress));
        BulkUsb_DbgPrint(3, ("rwContext->DeviceExtension = %X\n", 
                             rwContext->DeviceExtension));

        BulkUsb_DbgPrint(3, ("BulkUsb_ReadWriteCompletion::"));
        BulkUsb_IoDecrement(rwContext->DeviceExtension);

        ExFreePool(rwContext->Urb);
        IoFreeMdl(rwContext->Mdl);
        ExFreePool(rwContext);
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_ReadWriteCompletion - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkusr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSUsr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_USER_H
#define _BULKUSB_USER_H

#include <initguid.h>

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_CLASS_I82930_BULK, 
0x873fdf, 0x61a8, 0x11d1, 0xaa, 0x5e, 0x0, 0xc0, 0x4f, 0xb1, 0x72, 0x8b);

#define BULKUSB_IOCTL_INDEX             0x0000


#define IOCTL_BULKUSB_GET_CONFIG_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     BULKUSB_IOCTL_INDEX,     \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)
                                                   
#define IOCTL_BULKUSB_RESET_DEVICE          CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     BULKUSB_IOCTL_INDEX + 1, \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_BULKUSB_RESET_PIPE            CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     BULKUSB_IOCTL_INDEX + 2, \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\makefile.inc ===
mofcomp: bulkusb.bmf

bulkusb.bmf: bulkusb.mof
        mofcomp -B:bulkusb.bmf bulkusb.mof
        wmimofck bulkusb.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkwmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    bulkwmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpwr.h"
#include "bulkpnp.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_BULKUSB_DRIVER_INFORMATION 0

DEFINE_GUID (BULKUSB_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO BulkWmiGuidList[1] = { {

        &BULKUSB_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

NTSTATUS
BulkUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (BulkWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = BulkWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = BulkUsb_QueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = BulkUsb_QueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = BulkUsb_SetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = BulkUsb_SetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
BulkUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
BulkUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchSysCtrl::"));
    BulkUsb_IoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchSysCtrl::"));
    BulkUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
BulkUsb_QueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.BulkUsb_RegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
BulkUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_BULKUSB_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            BulkUsb_DbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_BUFFER_TOO_SMALL;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
BulkUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_BULKUSB_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_BULKUSB_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkwmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkwmi.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_WMI_H
#define _BULKUSB_WMI_H

NTSTATUS
BulkUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
BulkUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
BulkUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
BulkUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
BulkUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
BulkUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkusb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkusb.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <wdm.h>
#include <wmilib.h>
#include <wmistr.h>
#include "usbdi.h"
#include "usbdlib.h"

#ifndef _BULKUSB_H
#define _BULKUSB_H

#define BULKTAG (ULONG) 'KluB'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, BULKTAG);

#if DBG

#define BulkUsb_DbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint _x_; \
            }

#else

#define BulkUsb_DbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING BulkUsb_RegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

typedef enum _WDM_VERSION {

    WinXpOrBetter,
    Win2kOrBetter,
    WinMeOrBetter,
    Win98OrBetter

} WDM_VERSION;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;


#define BULKUSB_MAX_TRANSFER_SIZE   256
#define BULKUSB_TEST_BOARD_TRANSFER_BUFFER_SIZE (64 *1024 )

//
// registry path used for parameters 
// global to all instances of the driver
//

#define BULKUSB_REGISTRY_PARAMETERS_PATH  \
	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\BULKUSB\\Parameters"


typedef struct _BULKUSB_PIPE_CONTEXT {

    BOOLEAN PipeOpen;

} BULKUSB_PIPE_CONTEXT, *PBULKUSB_PIPE_CONTEXT;

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    // Bus drivers set the appropriate values in this structure in response
    // to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    // alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // Configuration Descriptor
    PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;

    // Interface Information structure
    PUSBD_INTERFACE_INFORMATION UsbInterface;

    // Pipe context for the bulkusb driver
    PBULKUSB_PIPE_CONTEXT PipeContext;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables

    LONG SSEnable;

    LONG SSRegistryEnable;

    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    LONG FreeIdleIrpCount;

    KSPIN_LOCK IdleReqStateLock;

    KEVENT NoIdleReqPendEvent;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    // selective suspend model uses timers, dpcs and work item.
    KTIMER Timer;

    KDPC DeferredProcCall;

    // This event is cleared when a DPC/Work Item is queued.
    // and signaled when the work-item completes.
    // This is essential to prevent the driver from unloading
    // while we have DPC or work-item queued up.
    KEVENT NoDpcWorkItemPendingEvent;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

    // WDM version
    WDM_VERSION WdmVersion;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

extern GLOBALS Globals;
extern ULONG DebugLevel;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\dll\create.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CREATE.C

Abstract:

    This module contains the code to Find and Create files to generic USB
    devices

Environment:

    User mode

Revision History:

    Sept-01 : created by Kenneth Ray

--*/

#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include <stdio.h>
#include <string.h>
#include <winioctl.h>

#include "genusbio.h"
#include "umgusb.h"

BOOL __stdcall
GenUSB_FindKnownDevices (
   IN  GENUSB_FIND_KNOWN_DEVICES_FILTER Filter,
   IN  PVOID            Context,
   OUT PGENUSB_DEVICE * Devices, // A array of struct _HID_DEVICE
   OUT PULONG           NumberDevices // the length of this array.
   )
/*++
Routine Description:
    Do the required PnP things in order to find all the devices in
    the system at this time.
--*/
{
    HDEVINFO                    hardwareDeviceInfo = NULL;
    SP_DEVICE_INTERFACE_DATA    deviceInterfaceData;
    ULONG                       predictedLength = 0;
    ULONG                       requiredLength = 0, bytes=0;
    ULONG                       i, current;
    HKEY                        regkey;
    DWORD                       Err;
    //
    // Open a handle to the device interface information set of all 
    // present toaster class interfaces.
    //
    *Devices = NULL;
    *NumberDevices = 0;

    hardwareDeviceInfo = SetupDiGetClassDevs (
                       (LPGUID)&GUID_DEVINTERFACE_GENUSB,
                       NULL, // Define no enumerator (global)
                       NULL, // Define no parent
                       (DIGCF_PRESENT | // Only Devices present
                       DIGCF_DEVICEINTERFACE)); // Function class devices.
    if(INVALID_HANDLE_VALUE == hardwareDeviceInfo)
    {
        goto GenUSB_FIND_KNOWN_DEVICES_REJECT;
    }
    
    //
    // Enumerate devices 
    //
    deviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);
    for (i=0; TRUE; i++) 
    {
        if (!SetupDiEnumDeviceInterfaces (
                        hardwareDeviceInfo,
                        0, // No care about specific PDOs
                        (LPGUID)&GUID_DEVINTERFACE_GENUSB,
                        i, //
                        &deviceInterfaceData)) 
        {
            if (ERROR_NO_MORE_ITEMS == GetLastError ())
            { 
                break;
            }
            else
            {
                goto GenUSB_FIND_KNOWN_DEVICES_REJECT;
            }
        }
    }
                                 
    *NumberDevices = i;
    *Devices = malloc (sizeof (PGENUSB_DEVICE) * i);
    if (NULL == *Devices)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto GenUSB_FIND_KNOWN_DEVICES_REJECT;
    }
    ZeroMemory (*Devices, (sizeof (PGENUSB_DEVICE) * i));
    
    for (i=0, current=0; i < *NumberDevices; i++, current++)
    {
        if (!SetupDiEnumDeviceInterfaces (
                        hardwareDeviceInfo,
                        0, // No care about specific PDOs
                        (LPGUID)&GUID_DEVINTERFACE_GENUSB,
                        i, //
                        &deviceInterfaceData)) 
        {
            goto GenUSB_FIND_KNOWN_DEVICES_REJECT;
        }

        regkey = SetupDiOpenDeviceInterfaceRegKey (
                      hardwareDeviceInfo,
                      &deviceInterfaceData,
                      0, // reserved
                      STANDARD_RIGHTS_READ);

        if (INVALID_HANDLE_VALUE == regkey)
        { 
            current--; 
            continue;
        }
        if (!(*Filter)(regkey, Context))
        {
            current--;
            RegCloseKey (regkey);
            continue;
        }

        RegCloseKey (regkey);

        //
        // First find out required length of the buffer
        //

        SetupDiGetDeviceInterfaceDetail (
            hardwareDeviceInfo,
            &deviceInterfaceData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node

        Err = GetLastError();

        predictedLength = requiredLength;

        (*Devices)[current].DetailData = malloc (predictedLength);
        if (!(*Devices)[current].DetailData)
        {
            goto GenUSB_FIND_KNOWN_DEVICES_REJECT;
        }

        ((*Devices)[current].DetailData)->cbSize = 
            sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

        if (! SetupDiGetDeviceInterfaceDetail (
                       hardwareDeviceInfo,
                       &deviceInterfaceData,
                       (*Devices)[current].DetailData,
                       predictedLength,
                       &requiredLength,
                       NULL)) 
        {
            Err = GetLastError();
            goto GenUSB_FIND_KNOWN_DEVICES_REJECT;
        }

    }
    *NumberDevices = current;
    
    SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    hardwareDeviceInfo = NULL;

    return TRUE;

GenUSB_FIND_KNOWN_DEVICES_REJECT:
    
    if (hardwareDeviceInfo)
    {
        SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
    }
    if (*Devices)
    {
        for (i=0; i < (*NumberDevices); i++)
        {
            if ((*Devices)[i].DetailData)
            {
                free ((*Devices)[i].DetailData);
            }
        }
        free (*Devices);
    }

    *Devices = NULL;
    *NumberDevices = 0;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\dll\tools.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    TOOLS.C

Abstract:

    This module contains the tools for the
    helper lib that talks to the generic USB driver

Environment:

    Kernel & user mode

Revision History:

    Sept-01 : created by Kenneth Ray

--*/

#include <stdlib.h>
#include <wtypes.h>
#include <winioctl.h>
#include <assert.h>

#include <initguid.h>
#include "genusbio.h"
#include "umgusb.h"


PUSB_COMMON_DESCRIPTOR __stdcall
GenUSB_ParseDescriptor(
    IN PVOID DescriptorBuffer,
    IN ULONG TotalLength,
    IN PVOID StartPosition,
    IN LONG DescriptorType
    )
/*++

Routine Description:

    Parses a group of standard USB configuration descriptors (returned
    from a device) for a specific descriptor type.

Arguments:

    DescriptorBuffer - pointer to a block of contiguous USB desscriptors
    TotalLength - size in bytes of the Descriptor buffer
    StartPosition - starting position in the buffer to begin parsing,
                    this must point to the begining of a USB descriptor.
    DescriptorType - USB descritor type to locate.


Return Value:

    pointer to a usb descriptor with a DescriptorType field matching the
            input parameter or NULL if not found.

--*/
{
    PUCHAR pch;
    PUCHAR end;
    PUSB_COMMON_DESCRIPTOR usbDescriptor;
    PUSB_COMMON_DESCRIPTOR foundUsbDescriptor;

    pch = (PUCHAR) StartPosition;
    end = ((PUCHAR) (DescriptorBuffer)) + TotalLength;
    foundUsbDescriptor = NULL;

    while (pch < end)
    {
        // see if we are pointing at the right descriptor
        // if not skip over the other junk
        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;

        if ((0 == DescriptorType) ||
            (usbDescriptor->bDescriptorType == DescriptorType)) 
        {
            foundUsbDescriptor = usbDescriptor;
            break;
        }

        // catch the evil case which will keep us looping forever.
        if (usbDescriptor->bLength == 0) 
        {
            break;
        }
        pch += usbDescriptor->bLength;
    }
    return foundUsbDescriptor;
}

PGENUSB_CONFIGURATION_INFORMATION_ARRAY __stdcall
GenUSB_ParseDescriptorsToArray(
    IN PUSB_CONFIGURATION_DESCRIPTOR  ConfigDescriptor
    )
{
    UCHAR  numberInterfaces;
    UCHAR  numberOtherDescriptors;
    UCHAR  numberEndpointDescriptors;
    ULONG  size;
    PCHAR  buffer;
    PCHAR  bufferEnd;
    PVOID  end;
    PUSB_COMMON_DESCRIPTOR                   current;
    PGENUSB_INTERFACE_DESCRIPTOR_ARRAY       interfaceArray;
    PGENUSB_CONFIGURATION_INFORMATION_ARRAY  configArray;
    PUSB_ENDPOINT_DESCRIPTOR               * endpointArray;
    PUSB_COMMON_DESCRIPTOR                 * otherArray;
    //
    // Create a flat memory structure that will hold this array of arrays
    // to descriptors
    //
    numberInterfaces = 0;
    numberEndpointDescriptors = 0;
    numberOtherDescriptors = 0;

    // 
    // Walk the list first to count the number of descriptors in this 
    // Configuration descriptor.
    // 
    current = (PUSB_COMMON_DESCRIPTOR) ConfigDescriptor;
    end = (PVOID) ((PCHAR) current + ConfigDescriptor->wTotalLength);

    size = 0;

    for ( ;(PVOID)current < end; (PUCHAR) current += current->bLength)
    {
        current = GenUSB_ParseDescriptor (ConfigDescriptor,
                                          ConfigDescriptor->wTotalLength,
                                          current,
                                          0); // the very next one.
        if (NULL == current)
        {
            //
            // There's a problem with this config descriptor
            // Throw up our hands
            //
            return NULL;
        }
        if (0 == current->bLength)
        {
            //
            // There's a problem with this config descriptor
            // Throw up our hands
            //
            return NULL;
        }
        if (USB_CONFIGURATION_DESCRIPTOR_TYPE == current->bDescriptorType)
        {   // Skip this one.
            ;
        }
        else if (USB_INTERFACE_DESCRIPTOR_TYPE == current->bDescriptorType)
        {
            numberInterfaces++;
        }
        else if (USB_ENDPOINT_DESCRIPTOR_TYPE == current->bDescriptorType)
        { 
            numberEndpointDescriptors++;
            size += ROUND_TO_PTR (current->bLength);
        }
        else
        {
            numberOtherDescriptors++;
            size += ROUND_TO_PTR (current->bLength);
        }
    }
    if (0 == numberInterfaces)
    {
        //
        // There's a problem with this config descriptor
        // Throw up our hands
        //
        return NULL;
    }

    // size now has room for all of the descriptor data, no make room for headers
    size += sizeof (GENUSB_CONFIGURATION_INFORMATION_ARRAY) // Global structure
          // the interfaces structures
          + (sizeof (GENUSB_INTERFACE_DESCRIPTOR_ARRAY) * numberInterfaces) 
          // array of pointers to the endpoint descriptors
          + (sizeof (PVOID) * numberEndpointDescriptors) 
          // array of pointers to the other descriptors
          + (sizeof (PVOID) * numberOtherDescriptors); 

    configArray = malloc (size);
    if (NULL == configArray)
    {
        return configArray;
    }
    ZeroMemory (configArray, size);
    bufferEnd = (PCHAR) configArray + size;

    //
    // Fill in the top array
    //
    configArray->NumberInterfaces = numberInterfaces;
    buffer = (PCHAR) configArray 
           + sizeof (GENUSB_CONFIGURATION_INFORMATION_ARRAY)
           + sizeof (GENUSB_INTERFACE_DESCRIPTOR_ARRAY) * numberInterfaces;

    endpointArray = (PUSB_ENDPOINT_DESCRIPTOR *) buffer;
    buffer += sizeof (PVOID) * numberEndpointDescriptors;

    otherArray = (PUSB_COMMON_DESCRIPTOR *) buffer;
    
    //
    // Walk the array again putting the data into our arrays.
    //
    current = (PUSB_COMMON_DESCRIPTOR) ConfigDescriptor;
    numberInterfaces = 0;
    interfaceArray = NULL;
    
    for ( ;(PVOID)current < end; (PUCHAR) current += current->bLength)
    {
        current = GenUSB_ParseDescriptor (ConfigDescriptor,
                                          ConfigDescriptor->wTotalLength,
                                          current,
                                          0); // the very next one.

        if (USB_CONFIGURATION_DESCRIPTOR_TYPE == current->bDescriptorType)
        {   // should only get here once
            configArray->ConfigurationDescriptor  
                = * (PUSB_CONFIGURATION_DESCRIPTOR) current;
        }
        else if (USB_INTERFACE_DESCRIPTOR_TYPE == current->bDescriptorType)
        {
            //
            // Allocate an interface array
            //
            interfaceArray = &configArray->Interfaces[numberInterfaces++];
            interfaceArray->Interface = *((PUSB_INTERFACE_DESCRIPTOR) current);
            interfaceArray->NumberEndpointDescriptors = 0;
            interfaceArray->NumberOtherDescriptors = 0;
            interfaceArray->EndpointDescriptors = endpointArray;
            interfaceArray->OtherDescriptors = otherArray;

        }  
        else
        {
            //
            // you must first have an interface descriptor before you 
            // can have any other type of descriptors.
            // So if we get here without interfaceArray set to something
            // Then there's a problem with your descriptor and we 
            // should throw up our hands.
            //
            if (NULL == interfaceArray)
            {
                free (configArray);
                return NULL;
            }
            //
            // allocate this one from the end.
            //
            bufferEnd -= ROUND_TO_PTR(current->bLength);
            CopyMemory (bufferEnd, current, current->bLength);

            if (USB_ENDPOINT_DESCRIPTOR_TYPE == current->bDescriptorType)
            { 
                *endpointArray = (PUSB_ENDPOINT_DESCRIPTOR) bufferEnd;
                endpointArray++;
                interfaceArray->NumberEndpointDescriptors++;
            } 
            else 
            {
                *otherArray = (PUSB_COMMON_DESCRIPTOR) bufferEnd;
                otherArray++;
                interfaceArray->NumberOtherDescriptors++;
            }
        }
    }

    if ((PCHAR) otherArray != bufferEnd)
    {
        // shootme.  
        assert ((PCHAR) otherArray == bufferEnd);
        free (configArray);
        return NULL;
    }
    else if ((PCHAR)endpointArray != buffer)
    { 
        // shootme.
        assert ((PCHAR)endpointArray != buffer);
        free (configArray);
        return NULL;
    }
    
    return configArray;
}

void __stdcall
GenUSB_FreeConfigurationDescriptorArray (
    PGENUSB_CONFIGURATION_INFORMATION_ARRAY ConfigurationArray
    )
{
    free (ConfigurationArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkusb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkusb.c

Abstract:

    Bulk USB device driver for Intel 82930 USB test board
	Main module

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkwmi.h"
#include "bulkusr.h"
#include "bulkrwr.h"

//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 1;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
BulkUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
BulkUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, BulkUsb_DriverUnload)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:

    NT status value
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.BulkUsb_RegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        BulkUsb_DbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = BulkUsb_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = BulkUsb_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = BulkUsb_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = BulkUsb_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = BulkUsb_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = BulkUsb_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_READ]           =
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = BulkUsb_DispatchReadWrite;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = BulkUsb_DispatchSysCtrl;
    DriverObject->DriverUnload                         = BulkUsb_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         BulkUsb_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
BulkUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will free the memory allocations in DriverEntry.

Arguments:

    DriverObject - pointer to driver object 

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    BulkUsb_DbgPrint(3, ("BulkUsb_DriverUnload - begins\n"));

    registryPath = &Globals.BulkUsb_RegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DriverUnload - ends\n"));

    return;
}

NTSTATUS
BulkUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful 
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    BulkUsb_DbgPrint(3, ("BulkUsb_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //                
        BulkUsb_DbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // initialize the device state lock and set the device state
    //

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //

    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = BulkUsb_WmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("BulkUsb_WmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Typically, the function driver for a device is its 
    // power policy owner, although for some devices another 
    // driver or system component may assume this role. 
    // Set the initial power state of the device, if known, by calling 
    // PoSetPowerState.
    // 

    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //

    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        BulkUsb_WmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_CLASS_I82930_BULK, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_WmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

    //
    // WinXP only
    // check the registry flag -
    // whether the device should selectively
    // suspend when idle
    //

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        BulkUsb_GetRegistryDword(BULKUSB_REGISTRY_PARAMETERS_PATH,
                                 L"BulkUsbEnable",
                                 &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {

            //
            // initialize DPC
            //
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

            //
            // initialize the timer.
            // the DPC and the timer in conjunction, 
            // monitor the state of the device to 
            // selectively suspend the device.
            //
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

            //
            // Initialize the NoDpcWorkItemPendingEvent to signaled state.
            // This event is cleared when a Dpc is fired and signaled
            // on completion of the work-item.
            //
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

            //
            // Initialize the NoIdleReqPendEvent to ensure that the idle request
            // is indeed complete before we unload the drivers.
            //
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags. 
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    BulkUsb_DbgPrint(3, ("BulkUsb_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\dll\umgusb.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    HIDDLL.H

Abstract:

    This module contains the PRIVATE definitions for the
    code that implements the HID dll.

Environment:

    Kernel & user mode

Revision History:

    Aug-96 : created by Kenneth Ray

--*/


#ifndef _HIDDLL_H
#define _HIDDLL_H


#define malloc(size) LocalAlloc (LPTR, size)
#define free(ptr) LocalFree (ptr)

#define ROUND_TO_PTR(_val_) (((_val_) + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\dll\umgusb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    UMGUSB.C

Abstract:

    This module contains the code for the
    helper lib that talks to the generic USB driver

Environment:

    Kernel & user mode

Revision History:

    Sept-01 : created by Kenneth Ray

--*/

#include <stdlib.h>
#include <wtypes.h>
#include <winioctl.h>

#include <initguid.h>
#include "genusbio.h"
#include "umgusb.h"

//
// __cdecl main (int argc, char *argv[])
// {
//    return 0;
// }
//


STDAPI_(BOOL)
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        default: return TRUE;
        }
}


int GenUSB_Hello (char * buff, int len)
{
   CHAR ret[] = "Hello\n";
   ULONG length = (sizeof (ret) < len) ? sizeof (ret) : len;

   CopyMemory (buff, ret, length);
   return sizeof (ret);
}



void __stdcall
GenUSB_GetDeviceInterfaceGuid (
   OUT   LPGUID      Guid
   )
/*++
Routine Description:
   Please see hidsdi.h for explination

Notes:
--*/
{
   *Guid = GUID_DEVINTERFACE_GENUSB;
}



BOOL __stdcall
GenUSB_GetCapabilities (
   IN    HANDLE                GenUSBDeviceObject,
   OUT   PGENUSB_CAPABILITIES  Capabilities
   )
/*++
Routine Description:
   please see gusb.h for explination

Notes:
--*/
{
   ULONG  bytes;

   return DeviceIoControl (GenUSBDeviceObject,
                           IOCTL_GENUSB_GET_CAPS,
                           0, 0,
                           Capabilities, sizeof (GENUSB_CAPABILITIES),
                           &bytes, NULL);

}


BOOL __stdcall
GenUSB_GetDeviceDescriptor (
   IN    HANDLE                  GenUSBDeviceObject,
   OUT   PUSB_DEVICE_DESCRIPTOR  Descriptor,
   IN    ULONG                   DescriptorLength
   )
/*++
Routine Description:
   please see gusb.h for explination

Notes:
--*/
{
   ULONG                bytes;

   return DeviceIoControl (GenUSBDeviceObject,
                           IOCTL_GENUSB_GET_DEVICE_DESCRIPTOR,
                           0, 0,
                           Descriptor, DescriptorLength,
                           &bytes, NULL);
}


BOOL __stdcall
GenUSB_GetConfigurationInformation (
   IN    HANDLE                         GenUSBDeviceObject,
   OUT   PUSB_CONFIGURATION_DESCRIPTOR  Descriptor,
   IN    ULONG                          DescriptorLength
   )
/*++
Routine Description:
   please see gusb.h for explination

Notes:
--*/
{
   ULONG                bytes;

   return DeviceIoControl (GenUSBDeviceObject,
                           IOCTL_GENUSB_GET_CONFIGURATION_DESCRIPTOR,
                           0, 0,
                           Descriptor, DescriptorLength,
                           &bytes, NULL);
}

BOOL __stdcall
GenUSB_GetStringDescriptor (
   IN    HANDLE   GenUSBDeviceObject,
   IN    UCHAR    Recipient,
   IN    UCHAR    Index,
   IN    USHORT   LanguageId,
   OUT   PUCHAR   Descriptor,
   IN    USHORT   DescriptorLength
   )
/*++
Routine Description:
   please see gusb.h for explination

Notes:
--*/
{
    ULONG                          bytes;
    GENUSB_GET_STRING_DESCRIPTOR   getString;

    getString.Recipient = Recipient;
    getString.Index = Index;
    getString.LanguageId = LanguageId;

    return DeviceIoControl (GenUSBDeviceObject,
                           IOCTL_GENUSB_GET_STRING_DESCRIPTOR,
                           &getString, sizeof (GENUSB_GET_STRING_DESCRIPTOR),
                           Descriptor, DescriptorLength,
                           &bytes, NULL);
}

BOOL __stdcall
GenUSB_DefaultControlRequest (
   IN     HANDLE                  GenUSBDeviceObject,
   IN     UCHAR                   RequestType,
   IN     UCHAR                   Request,
   IN     USHORT                  Value,
   IN     USHORT                  Index,
   IN OUT PGENUSB_REQUEST_RESULTS Result,
   IN     USHORT                  BufferLength
   )
/*++
Routine Description:
   please see gusb.h for explination

Notes:
--*/
{
    ULONG                bytes;
    GENUSB_GET_REQUEST   getReq;
    BOOL                 result;

    getReq.RequestType = RequestType;
    getReq.Request = Request;
    getReq.Value = Value;
    getReq.Index = Index;

    if (BufferLength < sizeof (GENUSB_REQUEST_RESULTS))
    {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return DeviceIoControl (GenUSBDeviceObject,
                            IOCTL_GENUSB_GET_REQUEST,
                            &getReq, sizeof (GENUSB_GET_REQUEST),
                            Result, BufferLength,
                            &bytes, NULL);

}


BOOL __stdcall
GenUSB_SelectConfiguration (
    IN  HANDLE                    GenUSBDeviceObject,
    IN  UCHAR                     RequestedNumberInterfaces,
    IN  USB_INTERFACE_DESCRIPTOR  RequestedInterfaces[],
    OUT PUCHAR                    FoundNumberInterfaces,
    OUT USB_INTERFACE_DESCRIPTOR  FoundInterfaces[]
    )
{
    ULONG     i;
    ULONG     size;
    ULONG     bytes;
    PGENUSB_SELECT_CONFIGURATION  select;

    size = sizeof (GENUSB_SELECT_CONFIGURATION) 
         + (sizeof (USB_INTERFACE_DESCRIPTOR) * RequestedNumberInterfaces);

    select = malloc (size);

    if (NULL == select)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    select->NumberInterfaces = RequestedNumberInterfaces;
    for (i=0; i < RequestedNumberInterfaces; i++)
    {
        select->Interfaces[i] = RequestedInterfaces[i];
    }

    if (!DeviceIoControl (GenUSBDeviceObject,
                          IOCTL_GENUSB_SELECT_CONFIGURATION,
                          select, size,
                          select, size,
                          &bytes, NULL))
    {
        free (select);
        return FALSE;
    }

    *FoundNumberInterfaces = select->NumberInterfaces;

    for (i=0; i < *FoundNumberInterfaces; i++)
    {
        FoundInterfaces[i] = select->Interfaces[i];
    }

    free (select);
    return TRUE;
}

BOOL __stdcall
GenUSB_DeselectConfiguration (
    IN  HANDLE                    GenUSBDeviceObject
    )
{
    ULONG bytes;

    return DeviceIoControl (GenUSBDeviceObject,
                            IOCTL_GENUSB_DESELECT_CONFIGURATION,
                            NULL, 0,
                            NULL, 0,
                            &bytes, NULL);
}

BOOL __stdcall
GenUSB_GetPipeInformation (
    IN  HANDLE                  GenUSBDeviceObject,
    IN  UCHAR                   InterfaceNumber,
    IN  UCHAR                   EndpointAddress,
    OUT PUSBD_PIPE_INFORMATION  PipeInformation
    )
{
    ULONG bytes;
    BOOL  result;
    GENUSB_PIPE_INFORMATION  pipeInfo;
    GENUSB_PIPE_INFO_REQUEST pipeReq;

    pipeReq.InterfaceNumber = InterfaceNumber;
    pipeReq.EndpointAddress = EndpointAddress;

    RtlZeroMemory (&pipeInfo, sizeof (GENUSB_PIPE_INFORMATION));
    
    result = DeviceIoControl (GenUSBDeviceObject,
                              IOCTL_GENUSB_GET_PIPE_INFO,
                              &pipeReq, sizeof (GENUSB_PIPE_INFO_REQUEST),
                              &pipeInfo, sizeof (GENUSB_PIPE_INFORMATION),
                              &bytes, NULL);

    PipeInformation->MaximumPacketSize = pipeInfo.MaximumPacketSize;
    PipeInformation->EndpointAddress = pipeInfo.EndpointAddress;
    PipeInformation->Interval = pipeInfo.Interval;
    PipeInformation->PipeType = pipeInfo.PipeType;
    PipeInformation->MaximumTransferSize = pipeInfo.MaximumTransferSize;
    PipeInformation->PipeFlags = pipeInfo.PipeFlags;

    //
    // We are retrieving an ulong from kernel mode, but for simplicity 
    // we pass back a USBD_PIPE_HANDLE, which happens to be a PVOID.
    //
    PipeInformation->PipeHandle = (PVOID) (ULONG_PTR) pipeInfo.PipeHandle;
    
    return result;
}

BOOL __stdcall 
GenUSB_GetPipeProperties (
    IN  HANDLE                  GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE        PipeHandle,
    OUT PGENUSB_PIPE_PROPERTIES Properties
    )
{
    ULONG bytes;
    ULONG ulongPipeHandle;

    ulongPipeHandle = (GENUSB_PIPE_HANDLE) (ULONG_PTR) PipeHandle;

    return DeviceIoControl (GenUSBDeviceObject,
                            IOCTL_GENUSB_GET_PIPE_PROPERTIES,
                            &ulongPipeHandle, sizeof (ULONG),
                            Properties, sizeof (GENUSB_PIPE_PROPERTIES),
                            &bytes, NULL);
}

BOOL __stdcall 
GenUSB_SetPipeProperties (
    IN  HANDLE                  GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE        PipeHandle,
    IN  PGENUSB_PIPE_PROPERTIES Properties
    )
{
    ULONG bytes;
    struct {
        ULONG                  PipeHandle;
        GENUSB_PIPE_PROPERTIES Properties;
    } data;

    data.PipeHandle = (GENUSB_PIPE_HANDLE) (ULONG_PTR) PipeHandle;
    data.Properties = *Properties;

    return DeviceIoControl (GenUSBDeviceObject,
                            IOCTL_GENUSB_SET_PIPE_PROPERTIES,
                            &data, sizeof (data),
                            NULL, 0,
                            &bytes, NULL);
}

BOOL __stdcall
GenUSB_ResetPipe (
    IN HANDLE            GenUSBDeviceObject,
    IN USBD_PIPE_HANDLE  PipeHandle,
    IN BOOL              ResetPipe,
    IN BOOL              ClearStall,
    IN BOOL              FlushData
    )
{
    GENUSB_RESET_PIPE reset;
    ULONG bytes;

    reset.Pipe = (GENUSB_PIPE_HANDLE) (ULONG_PTR) PipeHandle;
    reset.ResetPipe = (ResetPipe ? TRUE : FALSE);
    reset.ClearStall = (ClearStall ? TRUE : FALSE);
    reset.FlushData = (FlushData ? TRUE : FALSE);

    return DeviceIoControl (GenUSBDeviceObject,
                            IOCTL_GENUSB_RESET_PIPE,
                            &reset, sizeof (reset),
                            NULL, 0,
                            &bytes, NULL);
}


BOOL __stdcall
GenUSB_SetReadWritePipes (
    IN  HANDLE           GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE ReadPipe,
    IN  USBD_PIPE_HANDLE WritePipe
    )
{
    ULONG bytes;
    GENUSB_SET_READ_WRITE_PIPES pipes;

    pipes.ReadPipe = (GENUSB_PIPE_HANDLE) (ULONG_PTR) ReadPipe;
    pipes.WritePipe = (GENUSB_PIPE_HANDLE) (ULONG_PTR) WritePipe;

    return DeviceIoControl (GenUSBDeviceObject,
                            IOCTL_GENUSB_SET_READ_WRITE_PIPES,
                            &pipes, sizeof (GENUSB_SET_READ_WRITE_PIPES),
                            NULL, 0,
                            &bytes, NULL);
}

BOOL __stdcall
GenUSB_ReadPipe (
    IN  HANDLE           GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE Pipe,
    IN  BOOL             ShortTransferOk,
    IN  PVOID            Buffer,
    IN  ULONG            RequestedBufferLength,
    OUT PULONG           ReturnedBufferLength,
    OUT USBD_STATUS    * UrbStatus
    )
{ 
    ULONG bytes;
    BOOL  result;
    GENUSB_READ_WRITE_PIPE transfer;

    transfer.Pipe = (GENUSB_PIPE_HANDLE) (ULONG_PTR) Pipe;
    transfer.UsbdTransferFlags = USBD_TRANSFER_DIRECTION_IN
                               | (ShortTransferOk ? USBD_SHORT_TRANSFER_OK : 0);

    transfer.UrbStatus = USBD_STATUS_SUCCESS;
    transfer.BufferLength = RequestedBufferLength;

    // Junk is a union with UserBuffer, which initializes the upper bits in
    // case we are calling a 64 bit kernel with a 32 bit user mode dll.
    transfer.Junk = 0;
    transfer.UserBuffer = Buffer;

    *ReturnedBufferLength = 0;
    *UrbStatus = 0;

    result = DeviceIoControl (GenUSBDeviceObject,
                              IOCTL_GENUSB_READ_WRITE_PIPE,
                              &transfer, sizeof (GENUSB_READ_WRITE_PIPE),
                              NULL, 0,
                              &bytes, NULL);
    
    *ReturnedBufferLength = transfer.BufferLength;
    *UrbStatus= transfer.UrbStatus;

    return result;
}

BOOL __stdcall
GenUSB_WritePipe (
    IN  HANDLE           GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE Pipe,
    IN  BOOL             ShortTransferOk,
    IN  PVOID            Buffer,
    IN  ULONG            RequestedBufferLength,
    OUT PULONG           ReturnedBufferLength,
    OUT USBD_STATUS    * UrbStatus
    )
{ 
    ULONG bytes;
    BOOL  result;
    GENUSB_READ_WRITE_PIPE transfer;

    transfer.Pipe = (GENUSB_PIPE_HANDLE) (ULONG_PTR) Pipe;
    transfer.UsbdTransferFlags = USBD_TRANSFER_DIRECTION_OUT
                               | (ShortTransferOk ? USBD_SHORT_TRANSFER_OK : 0);

    transfer.UrbStatus = USBD_STATUS_SUCCESS;
    transfer.BufferLength = RequestedBufferLength;
    
    // Junk is a union with UserBuffer, which initializes the upper bits in
    // case we are calling a 64 bit kernel with a 32 bit user mode dll.
    transfer.Junk = 0;
    transfer.UserBuffer = Buffer;

    *ReturnedBufferLength = 0;
    *UrbStatus = 0;

    result = DeviceIoControl (GenUSBDeviceObject,
                              IOCTL_GENUSB_READ_WRITE_PIPE,
                              &transfer, sizeof (GENUSB_READ_WRITE_PIPE),
                              NULL, 0,
                              &bytes, NULL);
     
    *ReturnedBufferLength = transfer.BufferLength;
    *UrbStatus= transfer.UrbStatus;

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\inc\genusbio.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    GENUSBIO.H

Abstract

    Contains the IOCTL definitions shared between the generic USB driver and
    its corresponding user mode dll.  This is not a public interface.

Environment:

    User / Kernel mode 

Revision History:


--*/

#include <basetyps.h>

#include "gusb.h"

//
//  Define the interface guid *OUTSIDE* the #ifndef/#endif to allow
//  multiple includes with precompiled headers.
//
// fc21b2d1-2c37-4440-8eb0-b7e383a034e2
//

DEFINE_GUID( GUID_DEVINTERFACE_GENUSB, 0xfc21b2d1L, 0x2c37, 0x4440, 0x8e, 0xb0, 0xb7, 0xee, 0x83, 0xa0, 0x34, 0xe2);


#ifndef __GENUSBIO_H__
#define __GENUSBIO_H__

typedef ULONG GENUSB_PIPE_HANDLE;

#define GUID_DEVINTERFACE_GENUSB_STR "fc21b2d1-2c37-4440-8eb0-b7e383a034e2"

typedef struct _GENUSB_GET_STRING_DESCRIPTOR {
    UCHAR     Index;
    UCHAR     Recipient;
    USHORT    LanguageId;

} GENUSB_GET_STRING_DESCRIPTOR, *PGENUSB_GET_STRING_DESCRIPTOR;

typedef struct _GENUSB_GET_REQUEST {
    UCHAR    RequestType; // bmRequestType
    UCHAR    Request; // bRequest
    USHORT   Value; // wValue
    USHORT   Index; // wIndex

} GENUSB_GET_REQUEST, *PGENUSB_GET_REQUEST;


typedef struct _GENUSB_SELECT_CONFIGURATION {

    UCHAR                    NumberInterfaces;
    UCHAR                    Reserved[3];
    USB_INTERFACE_DESCRIPTOR Interfaces[];  
    // provide an array of USB_INTERFACE_DESCRIPTOR structures to set the 
    // interfaces desired in a select configuration.
    // Use -1 on any of the fields in this struct for that field to be ignored.

} GENUSB_SELECT_CONFIGURATION, *PGENUSB_SELECT_CONFIGURATION;

typedef struct _GENUSB_PIPE_INFO_REQUEST {
    UCHAR  InterfaceNumber;
    UCHAR  EndpointAddress;
    UCHAR  Reserved[2];

} GENUSB_PIPE_INFO_REQUEST, *PGENUSB_PIPE_INFO_REQUEST;


// 
// This structure shouldn't be needed.  We should be able to reuse 
// USBD_PIPE_INFORMATION.  (as we do in user mode.)  The trouble is that
// USBD_PIPE_INFORMATION has an embedded pointer (namely PipeHandle which is
// a PVOID.  This causes a problem if the user mode piece is running in a 
// 32 bit app on a 64 bit machine.  (aka the driver is 64 bits and user is 32.)
// because of that, I have redefined this structure, for use only in the 
// comunication between the driver and the DLL so that no pointer is exchanged.
//
// Cleanups and confusions to follow.
//
typedef struct _GENUSB_PIPE_INFORMATION {
    USHORT MaximumPacketSize;  // Maximum packet size for this pipe
    UCHAR  EndpointAddress;    // 8 bit USB endpoint address (includes direction)
                               // taken from endpoint descriptor
    UCHAR Interval;            // Polling interval in ms if interrupt pipe 
    
    USBD_PIPE_TYPE PipeType;   // PipeType identifies type of transfer valid for this pipe
    ULONG MaximumTransferSize; // Maximum size for a single request
                               // in bytes.
    ULONG PipeFlags;
    GENUSB_PIPE_HANDLE PipeHandle;
    ULONG Reserved [8];

} GENUSB_PIPE_INFORMATION, *PGENUSB_PIPE_INFORMATION;

typedef struct _GENUSB_SET_READ_WRITE_PIPES {
    ULONG ReadPipe;
    ULONG WritePipe;

} GENUSB_SET_READ_WRITE_PIPES, *PGENUSB_SET_READ_WRITE_PIPES;

typedef struct _GENUSB_READ_WRITE_PIPE {
    GENUSB_PIPE_HANDLE  Pipe;
    ULONG               UsbdTransferFlags;
    USBD_STATUS         UrbStatus;
    ULONG               BufferLength;

    // Since this IOCTL goes between kernel and user modes, it could be traveling
    // between a 64 bit system and a 32 bit subsystem.  Therefore this embedded
    // pointer causes a problem.
    // To take care of that, one must first initialize junk to zero, and then
    // fill in UserBuffer. If the code is 64 bit code then all that happened 
    // was an unneeded step was taken, if the code is 32 bit, then what happens
    // is that the more significant bits are now all zero, so that the other 
    // side can still use UserBuffer as a pointer.
    union {
        PVOID           UserBuffer;
        LONGLONG        Junk; 
    };

} GENUSB_READ_WRITE_PIPE, *PGENUSB_READ_WRITE_PIPE;

typedef struct _GENUSB_RESET_PIPE {
    GENUSB_PIPE_HANDLE  Pipe;

    // Reset the usbd pipe, nothing goes out to the device
    BOOLEAN             ResetPipe;  

    // Send a clear stall to the device.
    BOOLEAN             ClearStall;

    // If using buffered Reads use this to flush out the buffer
    BOOLEAN             FlushData;

    UCHAR               Reserved;

} GENUSB_RESET_PIPE, *PGENUSB_RESET_PIPE;

/////////////////////////////////////////////
// Description IOCTLs 
/////////////////////////////////////////////
//
// macro for defining HID ioctls
//
#define FILE_DEVICE_GENUSB 0x00000040

#define GENUSB_CTL_CODE(id)    \
    CTL_CODE(FILE_DEVICE_GENUSB, (id), METHOD_NEITHER, FILE_ANY_ACCESS)
#define GENUSB_BUFFER_CTL_CODE(id)  \
    CTL_CODE(FILE_DEVICE_GENUSB, (id), METHOD_BUFFERED, FILE_ANY_ACCESS)
#define GENUSB_IN_CTL_CODE(id)  \
    CTL_CODE(FILE_DEVICE_GENUSB, (id), METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define GENUSB_OUT_CTL_CODE(id)  \
    CTL_CODE(FILE_DEVICE_GENUSB, (id), METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

//
// Capabilities
//
#define IOCTL_GENUSB_GET_CAPS              GENUSB_BUFFER_CTL_CODE(0x100)

//
// Preformated descriptors
//
#define IOCTL_GENUSB_GET_DEVICE_DESCRIPTOR         GENUSB_BUFFER_CTL_CODE(0x110)
#define IOCTL_GENUSB_GET_CONFIGURATION_DESCRIPTOR  GENUSB_BUFFER_CTL_CODE(0x111)
#define IOCTL_GENUSB_GET_STRING_DESCRIPTOR         GENUSB_BUFFER_CTL_CODE(0x112)

// Commands
#define IOCTL_GENUSB_GET_REQUEST                   GENUSB_BUFFER_CTL_CODE(0x113)

//
// Configure
//

#define IOCTL_GENUSB_SELECT_CONFIGURATION    GENUSB_BUFFER_CTL_CODE(0x120)
#define IOCTL_GENUSB_DESELECT_CONFIGURATION  GENUSB_BUFFER_CTL_CODE(0x121)

//
// IO
//
#define IOCTL_GENUSB_GET_PIPE_INFO           GENUSB_BUFFER_CTL_CODE(0x130)
#define IOCTL_GENUSB_SET_READ_WRITE_PIPES    GENUSB_BUFFER_CTL_CODE(0x131)
#define IOCTL_GENUSB_SET_PIPE_TIMEOUT        GENUSB_BUFFER_CTL_CODE(0x132)
#define IOCTL_GENUSB_GET_PIPE_PROPERTIES     GENUSB_BUFFER_CTL_CODE(0x133)
#define IOCTL_GENUSB_SET_PIPE_PROPERTIES     GENUSB_BUFFER_CTL_CODE(0x134)
#define IOCTL_GENUSB_RESET_PIPE              GENUSB_BUFFER_CTL_CODE(0x135)

#define IOCTL_GENUSB_READ_WRITE_PIPE         GENUSB_CTL_CODE(0X140)

/////////////////////////////////////////////
// Configuration IOCTLs
/////////////////////////////////////////////


#endif  // __GENUSBIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\exe\testgusb.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    TestGUSB.C
   

Abstract:

    Console test app for Generic USB Lib
    This is a hastily writen file for testing purposes only.

Environment:

    user mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

    Sept 01  Created by KenRay

--*/

// #include <windows.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include <basetyps.h>

#include "gusb.h"

BOOL
FilterOnlyOne (
    IN     HKEY    Key,
    IN OUT PULONG  Context
    )
{
    if (0 == * Context)
    {
        * Context = 1;
        return TRUE;
    }
    return FALSE;
}


HANDLE
OpenOneDevice ()
{
    ULONG           context = 0;
    PGENUSB_DEVICE  devices;
    ULONG           numberDevices;
    HANDLE          hOut;

    if (!GenUSB_FindKnownDevices (
                     FilterOnlyOne,
                     &context,
                     &devices,
                     &numberDevices))
    {
        printf("problem");
        return INVALID_HANDLE_VALUE;
    }

    assert (numberDevices = 1);

    hOut = CreateFile (
                  devices[0].DetailData->DevicePath,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                  NULL, // no SECURITY_ATTRIBUTES structure
                  OPEN_EXISTING, // No special create flags
                  0, // No special attributes
                  NULL); // No template file

    if (INVALID_HANDLE_VALUE == hOut) {
        printf( "FAILED to open %ws\n", devices[0].DetailData->DevicePath);
    }
    return hOut;
}

void
usage()
/*++
Routine Description:

    Called by main() to dump usage info to the console when
    the app is called with no parms or with an invalid parm

Arguments:

    None

Return Value:

    None

--*/
{
    printf("Usage for Read/Write test:\n");
    printf("-l <Length of buffer>\n");
    printf("-c <Iterration count>\n");
    printf("-r <Read Interface No> <Read Pipe No>\n");
    printf("-w <Write Interface No> <Write Pipe No>\n");
    printf("-e // try to retrieve the extended configuration desc\n");
    printf("-i <Number of interfaces to configure>\n");
    printf("-t <Timeout Value to use for all transfers>\n");
    printf("-m // Use IRP_MJ_READ / WRITE \n");
    printf("-n // turn off auto truncate \n");
}


BOOL
Parse(
    int     argc,
    char  * argv[],
    PULONG  Length,
    PULONG  IterationCount,
    PCHAR   ReadInterface,
    PCHAR   ReadPipe,
    PCHAR   WriteInterface,
    PCHAR   WritePipe,
    PBOOL   GetExtConfigDesc,
    PUCHAR  NumberInterfaces,
    PUSHORT Timeout,
    PBOOL   UseMajorReadsWrites,
    PBOOL   NoTruncate
    )
/*++
Routine Description:

    Called by main() to parse command line parms

Arguments:

    argc and argv that was passed to main()

Return Value:

    Sets global flags as per user function request

--*/
{
    BOOL result = TRUE;
    int i;

    *GetExtConfigDesc = FALSE;
    *NumberInterfaces = 1;
    *Length = 0;
    *IterationCount = 0;
    *ReadInterface = -1;
    *ReadPipe = -1;
    *WriteInterface = -1;
    *WritePipe = -1;
    *Timeout = 20; 
    *UseMajorReadsWrites = FALSE;
    *NoTruncate = FALSE;

    if ( argc < 2 ) // give usage if invoked with no parms
    {
        usage();
        result = FALSE;
    }

    for (i=0; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case 'l':
            case 'L':
                *Length = atoi(&argv[i+1][0]);
                i++;
                break;
            case 'c':
            case 'C':
                *IterationCount = (UCHAR) atoi(&argv[i+1][0]);
                i++;
                break;
            case 'r':
            case 'R':
                *ReadInterface = (UCHAR) atoi(&argv[i+1][0]);
                *ReadPipe = (UCHAR) atoi(&argv[i+2][0]);
                i++;
                i++;
                break;

            case 'w':
            case 'W':
                *WriteInterface = (UCHAR) atoi(&argv[i+1][0]);
                *WritePipe = (UCHAR) atoi(&argv[i+2][0]);
                i++;
                i++;
                break;

            case 'e':
            case 'E':
                *GetExtConfigDesc = TRUE;
                break;

            case 'i':
            case 'I':
                *NumberInterfaces = (UCHAR) atoi(&argv[i+1][0]);
                i++;
                break;

            case 't':
            case 'T':
                *Timeout = (USHORT) atoi(&argv[i+1][0]);
                i++;
                break;

            case 'm':
            case 'M':
                *UseMajorReadsWrites = TRUE;
                break;

            case 'n':
            case 'N':
                *NoTruncate = TRUE;
                break;

            default:
                usage();
                result = FALSE;
            }
        }
    }
    return result;
}

#define MAX_ENDS 5
#define MAX_INTS 5

void
ReadWriteData (
    HANDLE Handle,
    ULONG  Length,
    ULONG  IterationCount,
    CHAR   ReadInterface,
    CHAR   ReadPipeNo,
    CHAR   WriteInterface,
    CHAR   WritePipeNo,
    USHORT Timeout,
    BOOL   UseMajorReadsWrites,
    BOOL   NoTruncate,
    PUSBD_PIPE_INFORMATION Pipes    
    )
{
    ULONG i,j;
    PCHAR outBuffer;
    PCHAR inBuffer;
    ULONG returnedLength;
    USBD_STATUS status;
    GENUSB_PIPE_PROPERTIES readProps;
    GENUSB_PIPE_PROPERTIES writeProps;
    USBD_PIPE_HANDLE readPipe;
    USBD_PIPE_HANDLE writePipe;
    BOOL result;
    CHAR pattern[] = "happy happy joy joy 1234567890";

    readPipe = writePipe = NULL;
    
    printf("len %x C %x Read %x %x Write %x %x Time %x\n",
           Length, IterationCount,
           ReadInterface, ReadPipeNo,
           WriteInterface, WritePipeNo,
           Timeout);

    if ((Length == 0) || (IterationCount == 0))
    {
        printf("Not reading\n");
        return; 
    }

    printf("Reading %x times, to %x %x from %x %x len %x %s\n", 
           IterationCount,
           WriteInterface,
           WritePipeNo,
           ReadInterface,
           ReadPipeNo,
           Length,
           (UseMajorReadsWrites ? 
            "Using IRP_MJ_READ/WRITE" : 
            "Using IOCTL read/write"));
           
    ZeroMemory (&readProps, sizeof (readProps));
    ZeroMemory (&writeProps, sizeof (writeProps));

    outBuffer = malloc (Length);
    inBuffer = malloc (Length);
    
    printf("Setting Pipe Properties\n");
    
    if (-1 != WritePipeNo)
    {
        writePipe = (Pipes + (WriteInterface * MAX_ENDS) + WritePipeNo)->PipeHandle;
        
        if (!GenUSB_GetPipeProperties(Handle, writePipe, &writeProps))
        {
            printf("failed to get write properties\n");
            return;
        }
        writeProps.Timeout = Timeout;
        writeProps.NoTruncateToMaxPacket = (NoTruncate ? TRUE: FALSE);
        
        if (!GenUSB_SetPipeProperties(Handle, writePipe, &writeProps))
            { 
            printf("failed to set write Properties\n"); 
            return;
        }

        //
        // verify that it got set  (not needed just for testing only)
        // 
        RtlZeroMemory (&writeProps, sizeof (GENUSB_PIPE_PROPERTIES));
        if (!GenUSB_GetPipeProperties(Handle, writePipe, &writeProps))
        {
            printf("failed to get write properties\n");
            return;
        }
        printf("Write Timeout %x NoTruncate %x DirectionIn %x Handle %x \n", 
               writeProps.Timeout,
               writeProps.NoTruncateToMaxPacket, 
               writeProps.DirectionIn, 
               writeProps.PipePropertyHandle);
    } 

    if (-1 != ReadPipeNo)
    {
        readPipe = (Pipes + (ReadInterface * MAX_ENDS) + ReadPipeNo)->PipeHandle;
        
        if (!GenUSB_GetPipeProperties(Handle, readPipe, &readProps))
        {
            printf("failed to get read properties\n");
            return;
        }
        readProps.Timeout = Timeout;
        readProps.NoTruncateToMaxPacket = (NoTruncate ? TRUE: FALSE);
        
        if (!GenUSB_SetPipeProperties(Handle, readPipe, &readProps))
        { 
            printf("failed to set read Properties\n"); 
            return;
        }

        //
        // verify that it got set  (not needed just for testing only)
        // 
        RtlZeroMemory (&readProps, sizeof (GENUSB_PIPE_PROPERTIES));
        if (!GenUSB_GetPipeProperties(Handle, readPipe, &readProps))
        {
            printf("failed to get read properties\n");
            return;
        }
        printf("Read Timeout %x NoTruncate %x In %x Handle %x\n", 
               readProps.Timeout,
               readProps.NoTruncateToMaxPacket,
               readProps.DirectionIn,
               readProps.PipePropertyHandle);
    }

    if ((NULL == outBuffer) || (NULL == inBuffer))
    {
        return;
    }

    for (i=0; i<Length; i+= sizeof (pattern))
    {
        CopyMemory( &outBuffer[i], 
                    pattern,
                    (((Length - i) < sizeof (pattern)) ? 
                     (Length - i) :
                     sizeof (pattern)));

    }

    if (UseMajorReadsWrites)
    {
        if (!GenUSB_SetReadWritePipes (Handle, readPipe, writePipe))
        {
            printf("Failed to set Read/Write pipes %x\n", 
                   GetLastError ());
            return;
        }
    }

    for (i=0; i<IterationCount; i++)
    {
        returnedLength = 0;
        status = 0;
        
        if (-1 != WritePipeNo)
        {
            if (!UseMajorReadsWrites)
            {
                result = GenUSB_WritePipe (Handle,
                                          writePipe,
                                          TRUE, // short OK
                                          outBuffer,
                                          Length,
                                          &returnedLength,
                                          &status);
            }
            else 
            {
                result = WriteFile (Handle,
                                   outBuffer,
                                   Length,
                                   &returnedLength,
                                   NULL);
                status = -1; // unknown
            }

            if (!result)
            {
                printf("Error:  err:%x, urbstatus:%x, len:%x\n", 
                       GetLastError(), status, returnedLength);
            } 
            else 
            {
                printf("did write %x %x\n", returnedLength, status);

                for (j=0; j<returnedLength; j++)
                {
                    printf(" %c(%x)", outBuffer[j], outBuffer[j]);
                }
                printf("\n");
            }
        }
        
        if (-1 != ReadPipeNo)
        { 
            FillMemory (inBuffer, Length, -1);

            if (!UseMajorReadsWrites)
            {
                result = GenUSB_ReadPipe (Handle,
                                          readPipe,
                                          TRUE, // short OK
                                          inBuffer,
                                          Length,
                                          &returnedLength,
                                          &status);
            } 
            else 
            {
                result = ReadFile (Handle,
                                   inBuffer,
                                   Length,
                                   &returnedLength,
                                   NULL);
                status = -1; // unknonw
            }

            if (!result)
            {
                printf("Error:  err:%x, urbstatus:%x, len:%x\n", 
                       GetLastError(), status, returnedLength);
            } 
            else 
            {
                printf("did read %x %x\n", returnedLength, status);
            }

            for (j=0; j<returnedLength; j++)
            {
                printf(" %c(%x)", inBuffer[j], inBuffer[j]);
            }
            printf("\n");

            if ((USBD_STATUS_BUFFER_OVERRUN == status) ||
                (UseMajorReadsWrites && !result))
            {
                printf("Data overrun.................  \nResetting Pipe \n");

                GenUSB_ResetPipe (Handle,
                                  readPipe,
                                  TRUE, // Reset the pipe
                                  TRUE, // No clear stall
                                  FALSE); // No flush data
            }
        }
    }
}


int _cdecl main(
    int argc,
    char *argv[])
/*++
Routine Description:

    Entry point to rwbulk.exe
    Parses cmdline, performs user-requested tests

Arguments:

    argc, argv  standard console  'c' app arguments

Return Value:

    Zero

--*/

{
    char *pinBuf = NULL, *poutBuf = NULL;
    ULONG i, j;
    int ok;
    UINT success;
    ULONG totalBytes = 0L;
    HANDLE handle;
    double seconds;
    ULONG fail = 0L;
    ULONG Length;
    ULONG IterationCount;
    CHAR ReadInterface;
    CHAR ReadPipe;
    CHAR WriteInterface;
    CHAR WritePipe;
    UCHAR NumberInterfaces; 
    USHORT Timeout;
    BOOL  GetExtConfigDesc;
    BOOL  UseMajorReadsWrites;
    BOOL  NoTruncate;
    UCHAR OutPipe;
    GENUSB_CAPABILITIES caps;
    USB_DEVICE_DESCRIPTOR devDesc;
    PUSB_CONFIGURATION_DESCRIPTOR configDesc;
    UCHAR stringDesc[18];
    ULONG result;
    UCHAR code;
    PGENUSB_REQUEST_RESULTS extConfig;
    USHORT size;

    if (!Parse(argc, argv, &Length, &IterationCount, 
               &ReadInterface, &ReadPipe,
               &WriteInterface, &WritePipe,
               &GetExtConfigDesc, &NumberInterfaces,
               &Timeout, &UseMajorReadsWrites,
               &NoTruncate))
    {
        return;
    }

    handle = OpenOneDevice ();

    if (INVALID_HANDLE_VALUE == handle)
    {
        return;
    }

    result = GenUSB_GetCapabilities (handle, &caps);
    printf("desc length %d, config length %d\n", 
           caps.DeviceDescriptorLength,
           caps.ConfigurationInformationLength);

    result = GenUSB_GetDeviceDescriptor (handle, &devDesc, sizeof (devDesc));
    printf("len %x, type %x, bcd %x, Class %x, subClass %x, Prot %x, Pack %x, \n"
           "Vid %x, Pid %x, Rev %x, Man %x, Prod %x, Serial %x, #config %x\n",
           devDesc.bLength,
           devDesc.bDescriptorType,
           devDesc.bcdUSB,
           devDesc.bDeviceClass,
           devDesc.bDeviceSubClass,
           devDesc.bDeviceProtocol,
           devDesc.bMaxPacketSize0,
           devDesc.idVendor,
           devDesc.idProduct,
           devDesc.bcdDevice,
           devDesc.iManufacturer,
           devDesc.iProduct,
           devDesc.iSerialNumber,
           devDesc.bNumConfigurations);

    printf("---------------------------------\n");

    configDesc = malloc (caps.ConfigurationInformationLength);
    result = GenUSB_GetConfigurationInformation (
                   handle, 
                   configDesc, 
                   caps.ConfigurationInformationLength);

    printf("len %x, type %x, totlen %x, #ints %x, fig %x, figStr %x, Attr %x, pow %x\n",
           configDesc->bLength,
           configDesc->bDescriptorType,
           configDesc-> wTotalLength,
           configDesc->bNumInterfaces,
           configDesc->bConfigurationValue,
           configDesc->iConfiguration,
           configDesc->bmAttributes,
           configDesc->MaxPower);

    for (i = 0; i < caps.ConfigurationInformationLength; i++)
    {
        printf(" %x", ((PUCHAR)configDesc)[i]);
    }
    printf("\n");

     
    if (GetExtConfigDesc)
    { 
        printf("------------Get Magic String Descriptor--------\n");

        result = GenUSB_GetStringDescriptor (handle,
                                             GENUSB_RECIPIENT_DEVICE,
                                             0xEE,
                                             0,
                                             stringDesc,
                                             sizeof (stringDesc));

        code = stringDesc [16];
        printf("String descriptor 0xEE\n");
        for (i=0; i < sizeof (stringDesc); i++)
        {
            printf(" %x", stringDesc [i]);
        }
        printf("\n magic code 0x%x\n", code);

        printf("---------Get OS Descriptor------------------\n");

        size = sizeof (GENUSB_REQUEST_RESULTS) + 0x28;

        extConfig = malloc (size);
        result = GenUSB_DefaultControlRequest (handle,
                                               0xC0,
                                               code,
                                               0x0000,
                                               0,
                                               extConfig,
                                               size);

        printf("URB status %x\n", extConfig->Status);
        printf("length %x\n", extConfig->Length);

        printf("Extended Config descriptor\n");
        for (i=0; i < 40 ; i++)
        {
            printf(" %x", extConfig->Buffer[i]);
        }
        printf("\n");
    }
    
    printf("---------Set Configuraiton---------------------\n");

    printf("number interfaces %x\n", configDesc->bNumInterfaces);

    {
        USB_INTERFACE_DESCRIPTOR * interfaces;
        USBD_PIPE_INFORMATION pipes[MAX_INTS][MAX_ENDS];
        PGENUSB_CONFIGURATION_INFORMATION_ARRAY configArray;
        PGENUSB_INTERFACE_DESCRIPTOR_ARRAY interfaceArray;
        PUSB_ENDPOINT_DESCRIPTOR endpoint;
        PUSB_COMMON_DESCRIPTOR commonDesc;
        ULONG k;

        printf("----------------------Config Array-------------------\n");

        configArray = GenUSB_ParseDescriptorsToArray (configDesc);

        for (i=0; i < configArray->NumberInterfaces; i++)
        {
            interfaceArray = &configArray->Interfaces[i];
            printf("Interface %x\n", i);

            printf("Len %x, Type %x, # %x, AltSet %x, #end %x, "
                   "Cl %x, SCl %x, Prot %x, i %x\n",
                   interfaceArray->Interface.bLength,
                   interfaceArray->Interface.bDescriptorType,
                   interfaceArray->Interface.bInterfaceNumber,
                   interfaceArray->Interface.bAlternateSetting,
                   interfaceArray->Interface.bNumEndpoints,
                   interfaceArray->Interface.bInterfaceClass,
                   interfaceArray->Interface.bInterfaceSubClass,
                   interfaceArray->Interface.bInterfaceProtocol,
                   interfaceArray->Interface.iInterface); 

            for (j=0; j < interfaceArray->NumberEndpointDescriptors; j++)
            { 
                endpoint = interfaceArray->EndpointDescriptors[j];
                printf("(%x) %x :", j, endpoint->bDescriptorType);

                for (k=0; k < endpoint->bLength; k++)
                {
                    printf(" %x", ((PUCHAR) endpoint)[k]);
                }
                printf("\n");
            }
            
            for (j=0; j < interfaceArray->NumberOtherDescriptors; j++)
            { 
                commonDesc = interfaceArray->OtherDescriptors[j];
                printf("(%x) %x :", j, commonDesc->bDescriptorType);

                for (k=0; k < commonDesc->bLength; k++)
                {
                    printf(" %x", ((PUCHAR) commonDesc)[k]);
                }
                printf("\n");
            }
        }

        size = (USHORT) (sizeof (USB_INTERFACE_DESCRIPTOR) * NumberInterfaces);
        interfaces = malloc (size);

        FillMemory (interfaces, size, -1);
 
        for (i=0; i < NumberInterfaces; i++)
        {
            interfaces[i].bInterfaceNumber = (UCHAR)i;
        }

        printf("numb ints %x\n", NumberInterfaces);

        for (i=0; i < NumberInterfaces; i++)
        {
            printf("Len %x, Type %x, # %x, AltSet %x, #end %x, "
                   "Cl %x, SCl %x, Prot %x, i %x\n",
                   interfaces[i].bLength,
                   interfaces[i].bDescriptorType,
                   interfaces[i].bInterfaceNumber,
                   interfaces[i].bAlternateSetting,
                   interfaces[i].bNumEndpoints,
                   interfaces[i].bInterfaceClass,
                   interfaces[i].bInterfaceSubClass,
                   interfaces[i].bInterfaceProtocol,
                   interfaces[i].iInterface);

        }
        
        result = GenUSB_SelectConfiguration (handle,
                                             NumberInterfaces,
                                             interfaces,
                                             &NumberInterfaces,
                                             interfaces);
        printf("result %x\n", result);
        printf("numb ints %x\n", NumberInterfaces);
        for (i=0; i<NumberInterfaces; i++)
        {
            printf("Len %x, Type %x, # %x, AltSet %x, #end %x, "
                   "Cl %x, SCl %x, Prot %x, i %x\n",
                   interfaces[i].bLength,
                   interfaces[i].bDescriptorType,
                   interfaces[i].bInterfaceNumber,
                   interfaces[i].bAlternateSetting,
                   interfaces[i].bNumEndpoints,
                   interfaces[i].bInterfaceClass,
                   interfaces[i].bInterfaceSubClass,
                   interfaces[i].bInterfaceProtocol,
                   interfaces[i].iInterface);

        }

        printf("----------------Get Pipe Info-----------------------\n");

        for (i=0; i<NumberInterfaces; i++)
        {
            interfaceArray = &configArray->Interfaces[i];
            
            for (j=0; j<interfaceArray->NumberEndpointDescriptors; j++)
            {
                endpoint = (PUSB_ENDPOINT_DESCRIPTOR) 
                           interfaceArray->EndpointDescriptors[j];

                GenUSB_GetPipeInformation (handle,
                                           (UCHAR) i, // interface
                                           endpoint->bEndpointAddress,
                                           &pipes[i][j]);
                
                printf("Max %x Addr %x Int %x Type %x Handle %x Trans %x Flags %x\n",
                       pipes[i][j].MaximumPacketSize,
                       pipes[i][j].EndpointAddress,
                       pipes[i][j].Interval,
                       pipes[i][j].PipeType,
                       (ULONG) (ULONG_PTR) pipes[i][j].PipeHandle,
                       pipes[i][j].MaximumTransferSize,
                       pipes[i][j].PipeFlags);
            }
        }

        ReadWriteData (handle,
                       Length,
                       IterationCount,
                       ReadInterface,
                       ReadPipe,
                       WriteInterface,
                       WritePipe,
                       Timeout,
                       UseMajorReadsWrites,
                       NoTruncate,
                       &pipes[0][0]);
    }

    GenUSB_DeselectConfiguration (handle);

    CloseHandle (handle);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\inc\gusb.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    GUSB.H

Abstract:

    This module contains the PUBLIC definitions for the
    helper lib that talks to the generic USB driver

Environment:

    Kernel & user mode

@@BEGIN_DDKSPLIT

Revision History:

    Sept-01 : created by Kenneth Ray

@@END_DDKSPLIT
--*/


#ifndef __GUSB_H_
#define __GUSB_H_

#ifndef __GUSB_H_KERNEL_
#include <pshpack4.h>

#include <wtypes.h>
#include <windef.h>
#include <basetyps.h>
#include <setupapi.h>
#include <usb.h>
#endif //__GUSB_H_KERNEL_


//////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////


//
// Used with GenUSB_GetCapabilities.
//
// This structure returns the size of standard descriptors so that
//
typedef struct _GENUSB_CAPABILITIES {
    USHORT    DeviceDescriptorLength;
    USHORT    ConfigurationInformationLength;
    USHORT    ReservedFields[14]; // Don't use these fields

} GENUSB_CAPABILITIES, *PGENUSB_CAPABILITIES;

//
// Used with GenUSB_DefaultControlRequest
//
// Returns the status of special reequest sent down to the device.
//
typedef struct _GENUSB_REQUEST_RESULTS {
    USBD_STATUS Status;
    USHORT      Length;
    USHORT      Reserved;

    // Pointer to the buffer to be transmitted or received.
    UCHAR       Buffer[]; 
} GENUSB_REQUEST_RESULTS, *PGENUSB_REQUEST_RESULTS;

//
// An array of pointers to all the descriptors in a interface descriptor
// not including the interface descriptor itself.
//
typedef struct _GENUSB_INTERFACE_DESCRIPTOR_ARRAY {
    USB_INTERFACE_DESCRIPTOR   Interface; // sizeof (9)
    UCHAR                      NumberEndpointDescriptors;
    UCHAR                      NumberOtherDescriptors;
    UCHAR                      Reserved;
    PUSB_ENDPOINT_DESCRIPTOR * EndpointDescriptors; // array of pointers to endpoint descriptors
    PUSB_COMMON_DESCRIPTOR   * OtherDescriptors; // array of pointers to the other descriptors

} GENUSB_INTERFACE_DESCRIPTOR_ARRAY, *PGENUSB_INTERFACE_DESCRIPTOR_ARRAY;


//
// An array of pointers to all the interface descriptors in a configuration
// descriptor
//
typedef struct _GENUSB_CONFIGURATION_INFORMATION_ARRAY {
    UCHAR                                NumberInterfaces;
    USB_CONFIGURATION_DESCRIPTOR         ConfigurationDescriptor; // sizeof (9) 
    UCHAR                                Reserved[2];
    GENUSB_INTERFACE_DESCRIPTOR_ARRAY    Interfaces[];

} GENUSB_CONFIGURATION_INFORMATION_ARRAY, *PGENUSB_CONFIGURATION_INFORMATION_ARRAY;


//
// per pipe settings
//
// These can be read and set with
//
// GenUSB_GetPipeProperties
// GenUSB_SetPipeProperties
//
typedef struct _PGENUSB_PIPE_PROPERTIES {
    // Handle to this Pipe Properties
    // This field is set by GenUSB_GetPipeProperties, and should
    // be returned unchanged to GenUSB_SetPipeProperties.  
    USHORT    PipePropertyHandle;

    // Elliminate the problem of buffer overruns by truncating all requests to
    // read from the device to a multiple of maxpacket.  This will prevent 
    // there being a request down on the host controller, that cannot hold 
    // an entire maxpacket.  Genusb Truncates by default.  (AKA FALSE)
    BOOLEAN   NoTruncateToMaxPacket;

    // Direction bit.  Although this information exists implicitely in the 
    // endpoint address, duplicate it here to make things easier.
    // Set to TRUE for a in pipe, and false for an out pipe.
    BOOLEAN   DirectionIn;

    // The default Timeout for a given Pipe in seconds (must be greater than 1)
    USHORT    Timeout; 
    USHORT    ReservedFields[13];

}GENUSB_PIPE_PROPERTIES, *PGENUSB_PIPE_PROPERTIES;

#ifndef __GUSB_H_KERNEL_

//
// A structure that contains the information needed to open the generic USB
// device driver.
//
// Returned as an array from GenUSB_FindKnownDevices
//
typedef struct _GENUSB_DEVICE {
    PSP_DEVICE_INTERFACE_DETAIL_DATA    DetailData;

} GENUSB_DEVICE, *PGENUSB_DEVICE;

#endif  // __GUSB_H_KERNEL_

/////////////////////////////////////////////
// Device Interface Registry Strings
/////////////////////////////////////////////

//
// These values are used by the FIND_KNOWN_DEVICES_FILTER
// to find out whether or not you want to use a givend device
//
#define GENUSB_REG_STRING_DEVICE_CLASS L"Device Class"
#define GENUSB_REG_STRING_DEVICE_SUB_CLASS L"Device Sub Class"
#define GENUSB_REG_STRING_DEVICE_PROTOCOL L"Device Protocol"
#define GENUSB_REG_STRING_VID L"Vendor ID"
#define GENUSB_REG_STRING_PID L"Product ID"
#define GENUSB_REG_STRING_REV L"Revision"

//////////////////////////////////////////////////////////////////
//
// Flags
//
//////////////////////////////////////////////////////////////////

//
// As defined in the USB spec chapter 9.
//
#define GENUSB_RECIPIENT_DEVICE    0
#define GENUSB_RECIPIENT_INTERFACE 1
#define GENUSB_RECIPIENT_ENDPOINT  2
#define GENUSB_RECIPIENT_OTHER     3

#ifndef __GUSB_H_KERNEL_
//////////////////////////////////////////////////////////////////
//
// Exported Functions
//
//////////////////////////////////////////////////////////////////

//
// Used with GenUSB_FindKnownDevices
//
// GenUSB_FindKnownDevices calls this function for each device in the system 
// that has the GenUSB Device Interface.  The filter function gets a handle 
// to the device interface registry key, so that it can see if this is a 
// device it wishes to use.  See the registry values above.
//
// This filter should return TRUE for all devices that the client wants to use.
//
typedef 
BOOL 
(*GENUSB_FIND_KNOWN_DEVICES_FILTER) (
    IN HKEY   Regkey,
    IN PVOID  Context
    );

/*++
GenUSB_FindKnownDevices

Routine Descriptor:
    find all the devices in the system that have the device interface
    guid for generic USB and return them in this array.
    
    This function allocates the memory and the caller must free it.
    
Arguments:
    Filter - a pointer to the GENUSB_FIND_KNOWN_DEVICES_FILTER to filter the
             devices returned.
             
    Contect - a pointer to context data that the call wants passed into 
              the filter function.
              
    Devices - returns a pointer to an array of PGENUSB_DEVICE structures
              to which the filter function returned TRUE.
              The call must free this memory.
              
    NumberDevices - the length of the Devices array.
    
--*/    
BOOL __stdcall
GenUSB_FindKnownDevices (
   IN  GENUSB_FIND_KNOWN_DEVICES_FILTER Filter,
   IN  PVOID            Context,
   OUT PGENUSB_DEVICE * Devices, // A array of device interfaces.
   OUT PULONG           NumberDevices // the length of this array.
   );


/*++
GenUSB_GetCapabilities

Routine Description:
    Retrive the Capabilities from this devices.

--*/
BOOL __stdcall
GenUSB_GetCapabilities (
   IN    HANDLE                GenUSBDeviceObject,
   OUT   PGENUSB_CAPABILITIES  Capabilities
   );

/*++ 
GenUSB_GetDeviceDescriptor

Routine Description:
    Get the Device Descriptor for this USB device.
    
    Use (PGENUSB_CAPABILITIES)->DeviceDescriptorLength to find out the size.
    
--*/
BOOL __stdcall
GenUSB_GetDeviceDescriptor (
   IN    HANDLE                  GenUSBDeviceObject,
   OUT   PUSB_DEVICE_DESCRIPTOR  Descriptor,
   IN    ULONG                   DescriptorLength
   );

/*++ 
GenUSB_GetConfigurationDescriptor

Routine Description:
    Get the complete configuraiton descriptor for this device, including all 
    of the follow on descriptors that the device returns for the configuration.
    
    Use (PGENUSB_CAPABILITIES)->ConfigurationInformationLength to find out 
    the size.
    
--*/
BOOL __stdcall
GenUSB_GetConfigurationInformation (
   IN    HANDLE                         GenUSBDeviceObject,
   OUT   PUSB_CONFIGURATION_DESCRIPTOR  Descriptor,
   IN    ULONG                          ConfigurationInformationLength
   );


/*++ 
GenUSB_GetStringDescriptor

Routine Description:
    Retrieve any string descriptor from the device.        

Arguments
    Recipient:  Use GENUSB_RECIPIENT_Xxx Flags to indicate which kind of 
                string descriptor required.
                
    Index: See USB (Capter 9) specified string index.
    
    LanguageID: See USB (chapter 9) for information on using Language ID.
    
    Descriptor: Pointer to the caller allocated memory to receive the 
                string descriptor.
                
    DescriptorLength: size in bytes of this buffer.    
    
--*/
BOOL __stdcall
GenUSB_GetStringDescriptor (
   IN    HANDLE   GenUSBDeviceObject,
   IN    UCHAR    Recipient,
   IN    UCHAR    Index,
   IN    USHORT   LanguageId,
   OUT   PUCHAR   Descriptor,
   IN    USHORT   DescriptorLength
   );

/*++ 
GenUSB_DefaultControlRequest 

Routine Description:
    Send a control request down the default pipe of the given USB device as 
    devined in USB (Chapter 9.3).
    
    RequestType: bRequestType of the setup Data.
    Reqeust: bRrequest of the setup Data.
    Value: wValue of the setup Data.
    Index: wIndex of the setup Data.
    
    Result: a pointer to a GENUSB_REQUEST_RESULTS structure that will receive
            the result of this command to the device.  
    
    BufferLength: the size in bytes of the Results stucture allocated.

--*/
BOOL __stdcall
GenUSB_DefaultControlRequest (
    IN     HANDLE                  GenUSBDeviceObject,
    IN     UCHAR                   RequestType,
    IN     UCHAR                   Request,
    IN     USHORT                  Value,
    IN     USHORT                  Index,
    IN OUT PGENUSB_REQUEST_RESULTS Result,
    IN     USHORT                  BufferLength
   );


/*++
GenUSB_ParseDescriptor

Routine Description:

    Parses a group of standard USB configuration descriptors (returned
    from a device) for a specific descriptor type.

Arguments:

    DescriptorBuffer - pointer to a block of contiguous USB desscriptors
    TotalLength - size in bytes of the Descriptor buffer
    StartPosition - starting position in the buffer to begin parsing,
                    this must point to the begining of a USB descriptor.
    DescriptorType - USB descritor type to locate.  (Zero means the next one.)


Return Value:

    pointer to a usb descriptor with a DescriptorType field matching the
            input parameter or NULL if not found.

--*/
PUSB_COMMON_DESCRIPTOR __stdcall
GenUSB_ParseDescriptor(
    IN PVOID DescriptorBuffer,
    IN ULONG TotalLength,
    IN PVOID StartPosition,
    IN LONG DescriptorType
    );


/*++
GenUSB_ParseDescriptorToArray

Routine Description:

    Parses a group of standard USB configuration descriptors (returned
    from a device) into an array of _GENUSB_INTERFACE_DESCRIPTOR_ARRAY
    for each interface found.
    
    The call must free this structure using 
    GenUSB_FreeConfigurationDescriptorArray

Arguments:

    ConfigurationDescriptor


Return Value:

    Pointer to an allocated array.

--*/
PGENUSB_CONFIGURATION_INFORMATION_ARRAY __stdcall
GenUSB_ParseDescriptorsToArray(
    IN PUSB_CONFIGURATION_DESCRIPTOR  ConfigigurationInfomation
    );


/*++
GenUSB_FreeConfigurationDescriptorArray

Routine Description:

    Frees the memory allocated by ParseDescriptorsToArray.

Arguments:

    ConfigurationArray - the return of ParseDescriptorsToArray.    

Return Value:


--*/
void __stdcall
GenUSB_FreeConfigurationDescriptorArray (
    PGENUSB_CONFIGURATION_INFORMATION_ARRAY ConfigurationArray
    );



/*++ 
GenUSB_SetConfiguration

Routine Description:
    Configure a USB device by selecting an interface.  
    Currently this function only allows for turning on the primary configuraion
    of a USB device.  (This is so callers need not understand whether or not
    they are merely a part of a composite device.)

Arguments:

    RequestedNumberInterfaces: Specifies the number of interfaces the caller 
                               wants to activate (and get handles for).

                               This value is typically one.
                               
    ReqeustedInterfaces[]: An array of interface descriptor structures listed
                           out the interfaces that the caller wants to activate.
                           The Generic USB driver searches on the configuration
                           descriptor for entries in this list.  Based on the 
                           matches found, it configures the device.  The caller
                           need not fill out all entries in a this structure
                           to find a match on an interface.  The caller must set
                           any fields "left blank" to -1.  
                           
    FoundNumberInterfaces: Returns the number of interfaces found in the 
                           default configuration.  
                     
    FoundInterfaces: An array of all the now active interfaces on the device.

--*/
BOOL __stdcall
GenUSB_SelectConfiguration (
    IN  HANDLE                    GenUSBDeviceObject,
    IN  UCHAR                     RequestedNumberInterfaces,
    IN  USB_INTERFACE_DESCRIPTOR  RequestedInterfaces[],
    OUT PUCHAR                    FoundNumberInterfaces,
    OUT USB_INTERFACE_DESCRIPTOR  FoundInterfaces[]
    );

BOOL __stdcall
GenUSB_DeselectConfiguration (
    IN  HANDLE                    GenUSBDeviceObject
    );


/*++
GenUSB_GetPipeInformation

RoutineDescription:
    Return a USBD_PIPE_INFORMATION strucutre for a given pipe. (as specified
    by a given interface and endpoint)
   
Arguments
    
--*/
BOOL __stdcall
GenUSB_GetPipeInformation (
    IN  HANDLE                  GenUSBDeviceObject,
    IN  UCHAR                   InterfaceNumber,
    IN  UCHAR                   EndpointAddress,
    OUT PUSBD_PIPE_INFORMATION  PipeInformation
    );  

/*++ 
GenUSB_GetPipeProperties

RoutineDescription:
    Get the properties on this particular Pipe
--*/
BOOL __stdcall 
GenUSB_GetPipeProperties (
    IN  HANDLE                  GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE        PipeHandle,
    IN  PGENUSB_PIPE_PROPERTIES Properties
    );

/*++ 
GenUSB_SetPipeProperties

RoutineDescription:
    Set the properties on this particular Pipe
--*/
BOOL __stdcall 
GenUSB_SetPipeProperties (
    IN  HANDLE                  GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE        PipeHandle,
    IN  PGENUSB_PIPE_PROPERTIES Properties
    );

/*++ 
GenUSB_ResetPipe

RoutineDescription:
    Reset the pipe
    
--*/
BOOL __stdcall
GenUSB_ResetPipe (
    IN HANDLE            GenUSBDeviceObject,
    IN USBD_PIPE_HANDLE  PipeHandle,

    // Reset USBD for this pipe (eg after a buffer overrun)
    IN BOOL              ResetPipe,

    // Send a clear stall to the endpoint for this pipe
    IN BOOL              ClearStall,

    // If you are using buffered reads / flush the pipe
    IN BOOL              FlushData  // Not yet implemented must be FALSE
    );

/*++
GenUSB_SetReadWritePipes

Routine Description:

    Sets the pipes default for IRP_MJ_READ and IRP_MJ_WRITE to the generic USB
    driver

Arguments:

    ReadPipe - the Pipe Handle (returned from GenUSB_GetPipeInformation)
               that corresponds to the specific read endpoint desired.                    
               Set to NULL if not using this value.               

    WritePipe - the Pipe Handle (returned from GenUSB_GetPipeInformation)
                that corresponds to the specific write endpoint desired.                    
                Set to NULL if not using this value.               

--*/
BOOL __stdcall
GenUSB_SetReadWritePipes (
    IN  HANDLE           GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE ReadPipe,
    IN  USBD_PIPE_HANDLE WritePipe
    );


/*++
GenUSB_ReadPipe

Routine Description:

    Read a chunk of data from a given interface and pipe on the device.

Arguments:
    
    Pipe - the pipe handle to read from ( found from select config)
    
    ShortTransferOk - allow the USB protocol defined behavior of short 
                      transfers
                      
    Buffer - the destination for the data
    
    RequestedBufferLength - how much data the caller wishes to retrieve
    
    ReturnedBufferLength - the amount of data actually read
    
    UrbStatus - the URB status code that the core usb stack returned for this
                transfer


--*/
BOOL __stdcall
GenUSB_ReadPipe (
    IN  HANDLE           GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE Pipe,
    IN  BOOL             ShortTransferOk,
    IN  PVOID            Buffer,
    IN  ULONG            RequestedBufferLength,
    OUT PULONG           ReturnedBufferLength,
    OUT USBD_STATUS    * UrbStatus
    );

BOOL __stdcall
GenUSB_WritePipe (
    IN  HANDLE           GenUSBDeviceObject,
    IN  USBD_PIPE_HANDLE Pipe,
    IN  BOOL             ShortTransferOk,
    IN  PVOID            Buffer,
    IN  ULONG            RequestedBufferLength,
    OUT PULONG           ReturnedBufferLength,
    OUT USBD_STATUS    * UrbStatus
    );
 
//
// Set Idle
// buffered read
//
// ????
// overlapped read / write ioctls
// Set Alternate Interfaces
//

#include <poppack.h>

#endif //__GUSB_H_KERNEL_
#endif  // __GUSB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\help.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.c

Abstract:

    WinDbg Extension Api
    implements !_log

Author:

    KenRay 

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "genusbkd.h"

DECLARE_API( help )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    dprintf("GenUsbKd Usage: \n\n");

    dprintf("dumplog <GenUSB Device Extension> <# of entries>\n");

    dprintf("\n\n\n");
    
    return S_OK;             
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\genusbkd.h ===
//#define DEBUGIT

typedef union _SIG {
    UCHAR c[4];
    ULONG l;
} SIG, *PSIG;    

typedef struct _FLAG_TABLE {
    PUCHAR Name;
    ULONG Mask;
} FLAG_TABLE, *PFLAG_TABLE;

#define GETMEMLOC(base, typ, field) \
    ((base) + FIELD_OFFSET(typ, field))


typedef ULONG64 MEMLOC, *PMEMLOC; 

typedef struct _STRUC_ENTRY {
    PUCHAR FieldName;
    ULONG FieldType;
} STRUC_ENTRY, *PSTRUC_ENTRY;

#define FT_ULONG        1
#define FT_UCHAR        2
#define FT_USHORT       3
#define FT_PTR          4
#define FT_SIG          5
#define FT_DEVSPEED     6 
#define FT_ULONG64      7 

ULONG
CheckSym();


#define CHECKSYM()\
    {\
    ULONG n;\
    if ((n=CheckSym()) != S_OK) {\
        return n;\
    }\
    }



CPPMOD
ScanfMemLoc(
    PMEMLOC MemLoc,
    PCSTR args
    );

VOID
PrintfMemLoc(
     PUCHAR Str1,
     MEMLOC MemLoc,
     PUCHAR Str2
     );    

VOID
BadMemLoc(
    ULONG MemLoc
    );

VOID
BadSig(
    ULONG Sig,
    ULONG ExpectedSig
    );
    
VOID    
DumpIPipe(
    MEMLOC MEmLoc
    );

PCHAR
ListEmpty(
    MEMLOC HeadMemLoc
    );

VOID
DumpUnicodeString(
    UNICODE_STRING uniString
    );

VOID
Sig(
    ULONG Sig,
    PUCHAR p
    );    

ULONG
UsbFieldOffset(
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

MEMLOC
UsbReadFieldPtr(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

ULONG
UsbReadFieldUlong(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );        

UCHAR
UsbReadFieldUchar(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );

USHORT
UsbReadFieldUshort(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

VOID    
DumpEHCI_StaticQHs(
    MEMLOC MemLoc
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\genusbkd.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

--*/

extern "C"
void
_disable (
    void
    );

extern "C"
void
_enable (
    void
    );

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG64                 STeip;
ULONG64                 STebp;
ULONG64                 STesp;

DBGKD_GET_VERSION64     KernelVersionPacket;
KDDEBUGGER_DATA64       KdDebuggerData;

ULONG64 EXPRLastDump = 0;

//
// Valid for the lifetime of the debug session.
//

ULONG   PageSize;
ULONG64 PaeEnabled;
ULONG   TargetMachine;
BOOL    Connected;

//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                            DEBUG_DATA_PaeEnabled, &PaeEnabled,
                                            sizeof(PaeEnabled), NULL)) == S_OK)
                {
                    if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                                DEBUG_DATA_MmPageSize, &Page,
                                                sizeof(Page), NULL)) == S_OK)
                    {
                        PageSize = (ULONG)(ULONG_PTR)Page;
                    }
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //

            if (PageSize)
            {
                if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                           (void **)&DebugControl)) == S_OK)
                {
                    if ((Hr = DebugControl->GetActualProcessorType(
                                                 &TargetMachine)) == S_OK)
                    {
                        Connected = TRUE;
                    }

                    DebugControl->Release();
                }
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        PaeEnabled = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}

BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 0) {
        if (!Ioctl( IG_GET_KERNEL_VERSION, &KernelVersionPacket, sizeof(KernelVersionPacket))) {
            havedata = 2;
        } else if (KernelVersionPacket.MajorVersion == 0) {
            havedata = 2;
        } else {
            havedata = 1;
        }
    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

BOOL
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if (Client) {
        if (Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                   (void **)&DebugSystem) != S_OK) {
            return 0;
        }

        DebugSystem->GetCurrentThreadHandle(&hCurrentThread);
        if (phCurrentThread) { 
            *phCurrentThread = (HANDLE) hCurrentThread;
        }
        if (pProcessor) {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }

        DebugSystem->Release();
        return TRUE;
    }
    return FALSE;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\kdext.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Stephane Plante (splante)
    jdunn, adapted to USB2

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

#ifdef USB_KD64
DBGKD_GET_VERSION64     KernelVersionPacket;
#else 
DBGKD_GET_VERSION32     KernelVersionPacket;
#endif

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    return;
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ( (SavedMajorVersion != 0x0c) ||
         (SavedMinorVersion != VER_PRODUCTBUILD) ) {

        dprintf(
            "\r\n*** Extension DLL(%d Checked) does not match target "
            "system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f) ? "Free" : "Checked"
            );

    }
#else
    if ( (SavedMajorVersion != 0x0f) ||
         (SavedMinorVersion != VER_PRODUCTBUILD) ) {

        dprintf(
            "\r\n*** Extension DLL(%d Free) does not match target "
            "system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f) ? "Free" : "Checked"
            );

    }
#endif
}


BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 2) {
        return FALSE;
    }

    if (havedata == 0) {
        if (!Ioctl(
                IG_GET_KERNEL_VERSION,
                (PVOID)(&KernelVersionPacket),
                sizeof(KernelVersionPacket)
                )
            ) {
            havedata = 2;

        } else if (KernelVersionPacket.MajorVersion == 0) {

            havedata = 2;

        } else {

            havedata = 1;

        }

    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

#if 0
BOOL
GetUlong (
    IN  PCHAR   String,
    IN  PULONG  Value
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Value,
        sizeof(ULONG),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}


BOOL
GetUlongPtr (
    IN  PCHAR   String,
    IN  PULONG_PTR Address
    )
{
    BOOL    status;
    ULONG_PTR Location;
    ULONG   result;


    Location = GetExpression( String );
    if (!Location) {

        dprintf("unable to get %s\n",String);
        return FALSE;

    }

    status = ReadMemory(
        Location,
        Address,
        sizeof(ULONG_PTR),
        &result
        );
    if (status == FALSE || result != sizeof(ULONG)) {

        return FALSE;

    }
    return TRUE;
}
#endif //xxx

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf(
        "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
        DebuggerType,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
        );

   return S_OK;         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Author:

    Chris Robinson (crobins) Feburary 1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "genusbkd.h"
#include "..\sys\genusb.h"

VOID    
DumpUSBDescriptor(
    PVOID Descriptor
    )
{
    PUSB_DEVICE_DESCRIPTOR dd = Descriptor;
    PUSB_COMMON_DESCRIPTOR cd = Descriptor;
    PUSB_INTERFACE_DESCRIPTOR id = Descriptor;
    PUSB_CONFIGURATION_DESCRIPTOR cf = Descriptor;
    PUSB_ENDPOINT_DESCRIPTOR ed = Descriptor;

    switch (cd->bDescriptorType) {
    case USB_CONFIGURATION_DESCRIPTOR_TYPE:
        dprintf("[CONFIGURATION DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", cf->bLength);
        dprintf("bDescriptorType 0x%x\n", cf->bDescriptorType);
        dprintf("wTotalLength 0x%x (%d)\n", cf->wTotalLength, cf->wTotalLength);
        dprintf("bNumInterfaces 0x%x\n", cf->bNumInterfaces);
        dprintf("bConfigurationValue 0x%x\n", cf->bConfigurationValue);
        dprintf("iConfiguration 0x%x\n", cf->iConfiguration);
        dprintf("bmAttributes 0x%x\n", cf->bmAttributes);
        dprintf("MaxPower 0x%x (%d)\n", cf->MaxPower, cf->MaxPower);
        break;
        
    case USB_INTERFACE_DESCRIPTOR_TYPE:
        dprintf("[INTERFACE DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", id->bLength);
        dprintf("bDescriptorType 0x%x\n", id->bDescriptorType);
        dprintf("bInterfaceNumber 0x%x\n", id->bInterfaceNumber);
        dprintf("bAlternateSetting 0x%x\n", id->bAlternateSetting);
        dprintf("bNumEndpoints 0x%x\n", id->bNumEndpoints);
        dprintf("bInterfaceClass 0x%x\n", id->bInterfaceClass);
        dprintf("bInterfaceSubClass 0x%x\n", id->bInterfaceSubClass);
        dprintf("bInterfaceProtocol 0x%x\n", id->bInterfaceProtocol);
        dprintf("iInterface 0x%x\n", id->iInterface);
        break;
                    
    case USB_DEVICE_DESCRIPTOR_TYPE:
        dprintf("[DEVICE DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", dd->bLength);
        dprintf("bDescriptorType 0x%x\n", dd->bDescriptorType);
        dprintf("bcdUSB 0x%x\n", dd->bcdUSB);
        dprintf("bDeviceClass 0x%x\n", dd->bDeviceClass);
        dprintf("bDeviceSubClass 0x%x\n", dd->bDeviceSubClass); 
        dprintf("bDeviceProtocol 0x%x\n", dd->bDeviceProtocol);
        dprintf("bMaxPacketSize0 0x%x\n", dd->bMaxPacketSize0);
        dprintf("idVendor 0x%x\n", dd->idVendor);
        dprintf("idProduct 0x%x\n", dd->idProduct);
        dprintf("bcdDevice 0x%x\n", dd->bcdDevice);
        dprintf("iManufacturer 0x%x\n", dd->iManufacturer);
        dprintf("iProduct 0x%x\n", dd->iProduct);
        dprintf("iSerialNumber 0x%x\n", dd->iSerialNumber);
        dprintf("bNumConfigurations 0x%x\n", dd->bNumConfigurations);
        break;
    case USB_ENDPOINT_DESCRIPTOR_TYPE:
        dprintf("[ENDPOINT DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", ed->bLength);
        dprintf("bDescriptorType 0x%x\n", ed->bDescriptorType);
        dprintf("bEndpointAddress 0x%x\n", ed->bEndpointAddress);
        dprintf("bmAttributes 0x%x\n", ed->bmAttributes);
        dprintf("wMaxPacketSize 0x%x\n", ed->wMaxPacketSize);
        dprintf("bInterval 0x%x\n", ed->bInterval);
        break;
        
    default:        
        dprintf("[DESCRIPTOR ???]\n");
    }   
    
}


VOID
DumpUnicodeString(
    UNICODE_STRING uniString
    )
{

       
    dprintf(">> Buffer: %08.8x, Length %d\n", 
        uniString.Buffer, uniString.Length);                    

}    


VOID
Sig(
    ULONG Sig,
    PUCHAR p
    )
{
    SIG s;
    
    dprintf(p);
    s.l = Sig;
    dprintf("Sig:%08.8x %c%c%c%c\n", Sig,
            s.c[0],  s.c[1],  s.c[2], s.c[3]); 

}      


CPPMOD
ScanfMemLoc(
    PMEMLOC MemLoc,
    PCSTR args
    )
{
//    UCHAR           buffer[256];
    ULONG tmp1 = 0, tmp2 = 0;

    //buffer[0] = '\0';

    if (IsPtr64()) {
        //sscanf(args, "%lx %lx", &MemLoc->p64, buffer);
    } else {
        sscanf(args, "%lx %lx", &tmp1, &tmp2);
        *MemLoc = (ULONG64) tmp1;             
        dprintf("tmp1 = %x tmp2 = %x\n", tmp1, tmp2);
    }
}          


VOID
PrintfMemLoc(
     PUCHAR Str1,
     MEMLOC MemLoc,
     PUCHAR Str2
     )
{
    if (IsPtr64()) {   
        ULONG tmp = (ULONG) MemLoc;
        ULONG tmp1 = (ULONG) (MemLoc>>32); 
#ifdef DEBUGIT          
        dprintf("%s%08.8x%08.8x (64)%s", Str1, tmp1, tmp, Str2); 
#else
        dprintf("%s%08.8x%08.8x %s", Str1, tmp1, tmp, Str2); 
#endif
    } else {
        ULONG tmp = (ULONG) MemLoc;
#ifdef DEBUGIT          
        dprintf("%s%08.8x (32)%s", Str1, tmp, Str2); 
#else   
        dprintf("%s%08.8x %s", Str1, tmp, Str2);
#endif        
    }
}


VOID
BadMemLoc(
    ULONG MemLoc
    )
{
    dprintf("could not read mem location %08.8x\n", MemLoc);
}     


VOID
BadSig(
    ULONG Sig,
    ULONG ExpectedSig
    )
{
    dprintf("Bad Structure Signature %08.8x\n", Sig);
}     


VOID 
UsbDumpFlags(
    ULONG Flags,
    PFLAG_TABLE FlagTable,
    ULONG NumEntries
    )
{
    ULONG i;
    PFLAG_TABLE ft = FlagTable;
    
    for (i=0; i< NumEntries; i++) {
        if (ft->Mask & Flags) {
            dprintf ("\t> %s\n", ft->Name);
        }
        ft++;
    }
}


ULONG
UsbFieldOffset(
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    ULONG offset;
    ULONG r;

    r = GetFieldOffset(Type, Field, &offset);
#ifdef DEBUGIT      
    dprintf("<UsbReadFieldPtr %x offset %x>", r, offset);
#endif     

    return offset;
}


MEMLOC
UsbReadFieldPtr(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    MEMLOC p;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, p);
#ifdef DEBUGIT      
    dprintf("<UsbReadFieldPtr %x>", r);
#endif    
    return p;
}


UCHAR
UsbReadFieldUchar(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    UCHAR ch;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, ch);
#ifdef DEBUGIT     
    dprintf("<UsbReadFieldUchar %x>", r);
#endif      
    return ch;
}


ULONG
UsbReadFieldUlong(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    ULONG l;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, l);
#ifdef DEBUGIT     
    dprintf("<UsbReadFieldUlong %x>", r);
#endif    
    return l;
}


USHORT
UsbReadFieldUshort(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    USHORT s;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, s);
#ifdef DEBUGIT    
    dprintf("<UsbReadFieldUshort %x>", r);
#endif    
    return s;
}

VOID
UsbDumpStruc(
    MEMLOC MemLoc,
    PUCHAR Cs,
    PSTRUC_ENTRY FieldList,
    ULONG NumEntries
    )
{
    ULONG i, l;
    UCHAR s[80];
    SIG sig;

    for (i=0; i< NumEntries; i++) {
        switch (FieldList->FieldType) {
        case FT_ULONG:
            dprintf("%s: 0x%08.8x\n",
                FieldList->FieldName,
                UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_UCHAR:
            dprintf("%s: 0x%02.2x\n",
                FieldList->FieldName,
                UsbReadFieldUchar(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_USHORT:
            dprintf("%s: 0x%04.4x\n",
                FieldList->FieldName,
                UsbReadFieldUshort(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_PTR:
            sprintf(s, "%s: ", FieldList->FieldName);
            PrintfMemLoc(s, 
            UsbReadFieldPtr(MemLoc, Cs, FieldList->FieldName),
            "\n");
            break;
        case FT_SIG:
            sig.l = UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName);
            Sig(sig.l, "");
            break;
        case FT_DEVSPEED:
            l = UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName);
            dprintf("%s: ",
                FieldList->FieldName);
            switch (l) {
            case UsbLowSpeed:
                dprintf("UsbLowSpeed\n");
                break;
            case UsbFullSpeed:
                dprintf("UsbFullSpeed\n");
                break;
            case UsbHighSpeed:
                dprintf("UsbHighSpeed\n");
                break;            
            }
            break;
        }       
        FieldList++;
    }
    
}

ULONG
CheckSym() 
{
    MEMLOC m;
    
    //
    // Verify that we have the right symbols.
    //

    m = GetExpression ("usbport!USBPORT_MiniportDriverList");

    if (m == 0) {

        dprintf ("Incorrect symbols for USBPORT\n");
        return E_INVALIDARG;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\dbg.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    DBG.C

Abstract:
    
    Copied from USBSTOR driver debug utility functions

Environment:

    kernel mode

Revision History:

    September 2001: Created by KenRay

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include "genusb.h"

#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text(PAGE, GenUSB_QueryGlobalParams)
#endif
#if DEBUG_LOG
#pragma alloc_text(PAGE, GenUSB_LogInit)
#pragma alloc_text(PAGE, GenUSB_LogUnInit)
#endif
#if DBG
#pragma alloc_text(PAGE, DumpDeviceDesc)
#pragma alloc_text(PAGE, DumpConfigDesc)
#pragma alloc_text(PAGE, DumpConfigurationDescriptor)
#pragma alloc_text(PAGE, DumpInterfaceDescriptor)
#pragma alloc_text(PAGE, DumpEndpointDescriptor)
#endif
#endif


//******************************************************************************
//
// G L O B A L S
//
//******************************************************************************

DRIVERGLOBALS GenUSB_DriverGlobals =
{
    0, // DBGF_BRK_DRIVERENTRY // DebugFlags
    0, // DebugLevel
};


//******************************************************************************
//
// GenUSB_QueryGlobalParams()
//
//******************************************************************************

VOID
GenUSB_QueryGlobalParams (
    )
{
    RTL_QUERY_REGISTRY_TABLE paramTable[3];

    DBGPRINT(2, ("enter: GENUSB_QueryGlobalParams\n"));

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"DebugFlags";
    paramTable[0].EntryContext  = &GenUSB_DriverGlobals.DebugFlags;
    paramTable[0].DefaultType   = REG_BINARY;
    paramTable[0].DefaultData   = &GenUSB_DriverGlobals.DebugFlags;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &GenUSB_DriverGlobals.DebugLevel;
    paramTable[1].DefaultType   = REG_BINARY;
    paramTable[1].DefaultData   = &GenUSB_DriverGlobals.DebugLevel;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"GENUSB",
                           &paramTable[0],
                           NULL,           // Context
                           NULL);          // Environment

    DBGPRINT(2, ("exit: GENUSB_QueryGlobalParams\n"));
}

#if DBG || DEBUG_LOG

//*****************************************************************************
//
// GenUSB_LogInit()
//
//*****************************************************************************

VOID
GenUSB_LogInit (
    PDEVICE_EXTENSION DeviceExtension
)
{
    ULONG size = (1 << LOGSIZE);
    ULONG length = size * sizeof (GENUSB_LOG_ENTRY);

    DeviceExtension->LogStart = ExAllocatePool (NonPagedPool, length);

    if (NULL == DeviceExtension->LogStart)
    {
        // No troubles here.  Just make sure that ever time we use the log
        // we check for null.
    } 
    else
    { 
        RtlZeroMemory (DeviceExtension->LogStart, length);
    }
    DeviceExtension->LogIndex = 0;
    DeviceExtension->LogMask = size - 1;
}

//*****************************************************************************
//
// GenUSB_LogUnInit()
//
//*****************************************************************************

VOID
GenUSB_LogUnInit (
    PDEVICE_EXTENSION DeviceExtension
)
{

    ExFreePool (DeviceExtension->LogStart);
    DeviceExtension->LogStart = 0;

}

//*****************************************************************************
//
// GenUSB_LogEntry()
//
//*****************************************************************************

VOID
GenUSB_LogEntry ( 
    IN PDEVICE_EXTENSION  DeviceExtension,
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
)
{
    //
    // The assumption here is that the number of log entries is an
    // even power of 2.  Therefore we need only mask off the lower bits
    //
    ULONG index;
    PGENUSB_LOG_ENTRY log;

    if (DeviceExtension->LogStart == NULL)
    {
        return;
    }

    index = InterlockedIncrement (&DeviceExtension->LogIndex);
    index = (index & DeviceExtension->LogMask);

    log = &(DeviceExtension->LogStart[index]);

    log->le_tag     = Tag;
    log->le_info1   = Info1;
    log->le_info2   = Info2;
    log->le_info3   = Info3;
}
#endif

#if DBG

//*****************************************************************************
//
// PnPMinorFunctionString()
//
// MinorFunction - The IRP_MJ_PNP minor function
//
//*****************************************************************************

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerMinorFunctionString()
//
// MinorFunction - The IRP_MJ_POWER minor function
//
//*****************************************************************************

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerDeviceStateString()
//
// State - The DEVICE_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
)
{
    switch (State)
    {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

//*****************************************************************************
//
// PowerSystemStateString()
//
// State - The SYSTEM_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
)
{
    switch (State)
    {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

//*****************************************************************************
//
// DumpDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    DBGPRINT(3, ("------------------\n"));
    DBGPRINT(3, ("Device Descriptor:\n"));

    DBGPRINT(3, ("bcdUSB:             0x%04X\n",
                 DeviceDesc->bcdUSB));

    DBGPRINT(3, ("bDeviceClass:         0x%02X\n",
                 DeviceDesc->bDeviceClass));

    DBGPRINT(3, ("bDeviceSubClass:      0x%02X\n",
                 DeviceDesc->bDeviceSubClass));

    DBGPRINT(3, ("bDeviceProtocol:      0x%02X\n",
                 DeviceDesc->bDeviceProtocol));

    DBGPRINT(3, ("bMaxPacketSize0:      0x%02X (%d)\n",
                 DeviceDesc->bMaxPacketSize0,
                 DeviceDesc->bMaxPacketSize0));

    DBGPRINT(3, ("idVendor:           0x%04X\n",
                 DeviceDesc->idVendor));

    DBGPRINT(3, ("idProduct:          0x%04X\n",
                 DeviceDesc->idProduct));

    DBGPRINT(3, ("bcdDevice:          0x%04X\n",
                 DeviceDesc->bcdDevice));

    DBGPRINT(3, ("iManufacturer:        0x%02X\n",
                 DeviceDesc->iManufacturer));

    DBGPRINT(3, ("iProduct:             0x%02X\n",
                 DeviceDesc->iProduct));

    DBGPRINT(3, ("iSerialNumber:        0x%02X\n",
                 DeviceDesc->iSerialNumber));

    DBGPRINT(3, ("bNumConfigurations:   0x%02X\n",
                 DeviceDesc->bNumConfigurations));

}

//*****************************************************************************
//
// DumpConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 dumpUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        dumpUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                dumpUnknown = TRUE;
                break;
        }

        if (dumpUnknown)
        {
            // DumpUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// DumpConfigurationDescriptor()
//
//*****************************************************************************

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    DBGPRINT(3, ("-------------------------\n"));
    DBGPRINT(3, ("Configuration Descriptor:\n"));

    DBGPRINT(3, ("wTotalLength:       0x%04X\n",
                 ConfigDesc->wTotalLength));

    DBGPRINT(3, ("bNumInterfaces:       0x%02X\n",
                 ConfigDesc->bNumInterfaces));

    DBGPRINT(3, ("bConfigurationValue:  0x%02X\n",
                 ConfigDesc->bConfigurationValue));

    DBGPRINT(3, ("iConfiguration:       0x%02X\n",
                 ConfigDesc->iConfiguration));

    DBGPRINT(3, ("bmAttributes:         0x%02X\n",
                 ConfigDesc->bmAttributes));

    if (ConfigDesc->bmAttributes & 0x80)
    {
        DBGPRINT(3, ("  Bus Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        DBGPRINT(3, ("  Self Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        DBGPRINT(3, ("  Remote Wakeup\n"));
    }

    DBGPRINT(3, ("MaxPower:             0x%02X (%d Ma)\n",
                 ConfigDesc->MaxPower,
                 ConfigDesc->MaxPower * 2));

}

//*****************************************************************************
//
// DumpInterfaceDescriptor()
//
//*****************************************************************************

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    DBGPRINT(3, ("---------------------\n"));
    DBGPRINT(3, ("Interface Descriptor:\n"));

    DBGPRINT(3, ("bInterfaceNumber:     0x%02X\n",
                 InterfaceDesc->bInterfaceNumber));

    DBGPRINT(3, ("bAlternateSetting:    0x%02X\n",
                 InterfaceDesc->bAlternateSetting));

    DBGPRINT(3, ("bNumEndpoints:        0x%02X\n",
                 InterfaceDesc->bNumEndpoints));

    DBGPRINT(3, ("bInterfaceClass:      0x%02X\n",
                 InterfaceDesc->bInterfaceClass));

    DBGPRINT(3, ("bInterfaceSubClass:   0x%02X\n",
                 InterfaceDesc->bInterfaceSubClass));

    DBGPRINT(3, ("bInterfaceProtocol:   0x%02X\n",
                 InterfaceDesc->bInterfaceProtocol));

    DBGPRINT(3, ("iInterface:           0x%02X\n",
                 InterfaceDesc->iInterface));

}

//*****************************************************************************
//
// DumpEndpointDescriptor()
//
//*****************************************************************************

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    DBGPRINT(3, ("--------------------\n"));
    DBGPRINT(3, ("Endpoint Descriptor:\n"));

    DBGPRINT(3, ("bEndpointAddress:     0x%02X\n",
                 EndpointDesc->bEndpointAddress));

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            DBGPRINT(3, ("Transfer Type:     Control\n"));
            break;

        case 0x01:
            DBGPRINT(3, ("Transfer Type: Isochronous\n"));
            break;

        case 0x02:
            DBGPRINT(3, ("Transfer Type:        Bulk\n"));
            break;

        case 0x03:
            DBGPRINT(3, ("Transfer Type:   Interrupt\n"));
            break;
    }

    DBGPRINT(3, ("wMaxPacketSize:     0x%04X (%d)\n",
                 EndpointDesc->wMaxPacketSize,
                 EndpointDesc->wMaxPacketSize));

    DBGPRINT(3, ("bInterval:            0x%02X\n",
                 EndpointDesc->bInterval));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\dbg.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.H

Abstract:

    Copied from Header file for USBSTOR driver debug utility functions

Environment:

    kernel mode

Revision History:

    September 2001: Created by KenRay

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#if DBG
  #if defined(DEBUG_LOG)
    #undef DEBUG_LOG
  #endif
  #define DEBUG_LOG 1
#else
  #if !defined(DEBUG_LOG)
    #define DEBUG_LOG 0
  #endif
#endif


#if !DBG

#define DBGFBRK(flag)
#define DBGPRINT(level, _x_)

#else

#define DBGF_BRK_DRIVERENTRY            0x00000001
#define DBGF_BRK_UNLOAD                 0x00000002
#define DBGF_BRK_ADDDEVICE              0x00000004
#define DBGF_BRK_REMOVEDEVICE           0x00000008
#define DBGF_BRK_STARTDEVICE            0x00000010
#define DBGF_BRK_STOPDEVICE             0x00000020
#define DBGF_BRK_QUERYSTOPDEVICE        0x00000040
#define DBGF_BRK_CANCELSTOPDEVICE       0x00000080
#define DBGF_BRK_RESET                  0x00000100
#define DBGF_BRK_RESETPIPE              0x00000200
#define DBGF_BRK_CREATE                 0x00010000
#define DBGF_BRK_CLOSE                  0x00020000
#define DBGF_BRK_READWRITE              0x00040000
#define DBGF_BRK_IOCTL                  0x00080000
#define DBGF_BRK_SCSI                   0x00100000
#define DBGF_BRK_INVALID_REQ            0x00200000

#define DBGFBRK(flag) do { \
    if (GenUSB_DriverGlobals.DebugFlags & flag) { \
        DbgBreakPoint(); \
    } \
} while (0)

#define DBGPRINT(level, _x_) do { \
    if (level <= GenUSB_DriverGlobals.DebugLevel) { \
        KdPrint(("GenUSB: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

#if !DEBUG_LOG

#define LOGINIT(ext)
#define LOGUNINIT(ext)
#define LOGENTRY(ext, tag, info1, info2, info3)

#else

#define LOGSIZE 10 // the power of two that gives the size of the log.

#define LOGINIT(ext) GenUSB_LogInit(ext)

#define LOGUNINIT(ext) GenUSB_LogUnInit(ext)

#define LOGENTRY(ext, tag, info1, info2, info3) \
   GenUSB_LogEntry(ext, \
                   ((((tag) >> 24) & 0x000000FF) | \
                    (((tag) >>  8) & 0x0000FF00) | \
                    (((tag) <<  8) & 0x00FF0000) | \
                    (((tag) << 24) & 0xFF000000)), \
                   ((ULONG_PTR)info1),             \
                   ((ULONG_PTR)info2),             \
                   ((ULONG_PTR)info3))

#endif

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

#ifdef _WIN64
#define GENUSB_LOG_ENTRY GENUSB_LOG_ENTRY64    
#define PGENUSB_LOG_ENTRY PGENUSB_LOG_ENTRY64  
#else 
#define GENUSB_LOG_ENTRY GENUSB_LOG_ENTRY32 
#define PGENUSB_LOG_ENTRY PGENUSB_LOG_ENTRY32 
#endif

typedef struct _GENUSB_LOG_ENTRY64 {
    ULONG   le_tag;
    ULONG   pad;
    ULONG64 le_info1;
    ULONG64 le_info2;
    ULONG64 le_info3;
} GENUSB_LOG_ENTRY64, *PGENUSB_LOG_ENTRY64;

typedef struct _GENUSB_LOG_ENTRY32 {
    ULONG   le_tag;
    ULONG   le_info1;
    ULONG   le_info2;
    ULONG   le_info3;
} GENUSB_LOG_ENTRY32, *PGENUSB_LOG_ENTRY32;

typedef struct _DRIVERGLOBALS
{
    ULONG               DebugFlags;     // DBGF_* Flags
    LONG                DebugLevel;     // Level of debug output
//    PGENUSB_LOG_ENTRY   LogStart;       // Start of log buffer (older entries)
//    ULONG               LogIndex;
//    ULONG               LogMask;
} DRIVERGLOBALS;

//*****************************************************************************
//
// G L O B A L S
//
//*****************************************************************************

//
// DBG.C
//

extern DRIVERGLOBALS GenUSB_DriverGlobals;


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// DBG.C
//

VOID
GenUSB_QueryGlobalParams (
    );

#if DEBUG_LOG

VOID
GenUSB_LogInit (
    struct _DEVICE_EXTENSION * DeviceExtension
);

VOID
GenUSB_LogUnInit (
    struct _DEVICE_EXTENSION * DeviceExtension
);

VOID
GenUSB_LogEntry (
    IN struct _DEVICE_EXTENSION * DeviceExtension,
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
);

#endif

#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
);

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
);

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\log.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.c

Abstract:

    WinDbg Extension Api
    implements !_log

Author:

    KenRay stolen from jd 

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "genusbkd.h"
#include "..\sys\genusb.h"

VOID    
DumpLog(
    MEMLOC StartMemLoc,
    ULONG  LogIndex,
    ULONG  LogMask,
    ULONG  NumEntriesToDump
    )
{
    ULONG i;
    GENUSB_LOG_ENTRY32 logEntry32;
    GENUSB_LOG_ENTRY64 logEntry64;
    ULONG cb;
    SIG tag;
    MEMLOC mlog, m1, m2, m3;
    
    PrintfMemLoc("*TRANSFER LOGSTART: ", StartMemLoc, " ");
    dprintf("(%x) ", LogIndex);
    dprintf("# %d \n", NumEntriesToDump);
    

    for (i=0; i< NumEntriesToDump; i++, LogIndex--) {

        mlog = StartMemLoc + ((LogIndex & LogMask) * sizeof (GENUSB_LOG_ENTRY));
        
        if (IsPtr64()) { 
            ReadMemory(mlog,
               &logEntry64,
               sizeof(logEntry64),
               &cb);
  
            tag.l = logEntry64.le_tag;

            m1 = logEntry64.le_info1;                
            m2 = logEntry64.le_info2;  
            m3 = logEntry64.le_info3; 
            
        } else {
            ReadMemory(mlog,
               &logEntry32,
               sizeof(logEntry32),
               &cb);

            tag.l = logEntry32.le_tag;

            m1 = logEntry32.le_info1;                
            m2 = logEntry32.le_info2;  
            m3 = logEntry32.le_info3;  
        }
 
        dprintf("[%3.3d]", i);
        PrintfMemLoc(" ", mlog, " ");
        dprintf("%c%c%c%c ", tag.c[0],  tag.c[1],  tag.c[2], tag.c[3]);

        PrintfMemLoc(" ", m1, " ");
        PrintfMemLoc(" ", m2, " ");
        PrintfMemLoc(" ", m3, "\n");
        
    }
}



DECLARE_API( dumplog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    ULONG len = 5;
    MEMLOC logPtr;
    UCHAR cs[] = "genusb!_DEVICE_EXTENSION";
    ULONG logIndex, logMask;
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, "%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) 
    {
        sscanf(buffer1, "%d", &len);
    } 
    else 
    {
        len = 20;
    }

    logPtr = UsbReadFieldPtr(addr, cs, "LogStart");
    logIndex = UsbReadFieldUlong(addr, cs, "LogIndex");
    logMask = UsbReadFieldUlong(addr, cs, "LogMask");
    
    dprintf(">LOG %p index = %x mask %x length %x\n", 
            logPtr, logIndex, logMask, len);
    
    DumpLog (logPtr, logIndex, logMask, len);

    return S_OK;             
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\kdexts\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/
#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <wdbgexts.h>
#include <dbgeng.h>
 
#include <usb.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#define EXIT_API     ExtRelease

extern WINDBG_EXTENSION_APIS ExtensionApis;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\genusb.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    GENUSB.C

Abstract:

    This source file contains the DriverEntry() and AddDevice() entry points
    for the GENUSB driver and the dispatch routines which handle:

    IRP_MJ_POWER
    IRP_MJ_SYSTEM_CONTROL
    IRP_MJ_PNP

Environment:

    kernel mode

Revision History:

    Sep 2001 : Copied from USBMASS

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <initguid.h>
#include "genusb.h"


//*****************************************************************************
// L O C A L    F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, GenUSB_Unload)
#pragma alloc_text(PAGE, GenUSB_AddDevice)
#pragma alloc_text(PAGE, GenUSB_QueryParams)
#pragma alloc_text(PAGE, GenUSB_Pnp)
#pragma alloc_text(PAGE, GenUSB_StartDevice)
#pragma alloc_text(PAGE, GenUSB_StopDevice)
#pragma alloc_text(PAGE, GenUSB_RemoveDevice)
#pragma alloc_text(PAGE, GenUSB_QueryStopRemoveDevice)
#pragma alloc_text(PAGE, GenUSB_CancelStopRemoveDevice)
#pragma alloc_text(PAGE, GenUSB_SetDeviceInterface)
#pragma alloc_text(PAGE, GenUSB_SyncPassDownIrp)
#pragma alloc_text(PAGE, GenUSB_SyncSendUsbRequest)
#pragma alloc_text(PAGE, GenUSB_SetDIRegValues)
#pragma alloc_text(PAGE, GenUSB_SystemControl)
#pragma alloc_text(PAGE, GenUSB_Power)
#pragma alloc_text(PAGE, GenUSB_SetPower)
#if 0
#pragma alloc_text(PAGE, GenUSB_AbortPipe)
#endif
#endif



//******************************************************************************
//
// DriverEntry()
//
//******************************************************************************

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    PAGED_CODE();

    // Query the registry for global parameters
    GenUSB_QueryGlobalParams();

    DBGPRINT(2, ("enter: DriverEntry\n"));

    DBGFBRK(DBGF_BRK_DRIVERENTRY);

    //
    // Initialize the Driver Object with the driver's entry points
    //

    //
    // GENUSB.C
    //
    DriverObject->DriverUnload                          = GenUSB_Unload;
    DriverObject->DriverExtension->AddDevice            = GenUSB_AddDevice;

    //
    // OCRW.C
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = GenUSB_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = GenUSB_Close;
    DriverObject->MajorFunction[IRP_MJ_READ]            = GenUSB_Read;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = GenUSB_Write;

    //
    // DEVIOCTL.C
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = GenUSB_DeviceControl;

    //
    // GENUSB.C
    //
    DriverObject->MajorFunction[IRP_MJ_PNP]             = GenUSB_Pnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = GenUSB_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = GenUSB_SystemControl;

    DBGPRINT(2, ("exit:  DriverEntry\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// GenUSB_Unload()
//
//******************************************************************************

VOID
GenUSB_Unload (
    IN PDRIVER_OBJECT   DriverObject
    )
{
    DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_Unload\n"));

    DBGFBRK(DBGF_BRK_UNLOAD);

    DBGPRINT(2, ("exit:  GenUSB_Unload\n"));
}

//******************************************************************************
//
// GenUSB_AddDevice()
//
//******************************************************************************

NTSTATUS
GenUSB_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS            ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_AddDevice\n"));

    DBGFBRK(DBGF_BRK_ADDDEVICE);

    // Create the FDO
    //
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_UNKNOWN,
                              0,
                              FALSE,
                              &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    fdoDeviceExtension = deviceObject->DeviceExtension;
    
    LOGENTRY(fdoDeviceExtension, 'ADDD', DriverObject, PhysicalDeviceObject, 0);

    // Set all DeviceExtension pointers to NULL and all variable to zero
    RtlZeroMemory(fdoDeviceExtension, sizeof(DEVICE_EXTENSION));

    // Store a back point to the DeviceObject for this DeviceExtension
    fdoDeviceExtension->Self = deviceObject;

    // Remember our PDO
    fdoDeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Attach the FDO we created to the top of the PDO stack
    fdoDeviceExtension->StackDeviceObject = 
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    LOGINIT (fdoDeviceExtension);

    IoInitializeRemoveLock (&fdoDeviceExtension->RemoveLock,
                            POOL_TAG,
                            0,
                            0);
    
    // Set the initial system and device power states
    fdoDeviceExtension->SystemPowerState = PowerSystemWorking;
    fdoDeviceExtension->DevicePowerState = PowerDeviceD0;

    // Initialize the spinlock which protects the PDO DeviceFlags
    KeInitializeSpinLock(&fdoDeviceExtension->SpinLock);
    ExInitializeFastMutex(&fdoDeviceExtension->ConfigMutex);

    fdoDeviceExtension->OpenedCount = 0;

    GenUSB_QueryParams(deviceObject);

    fdoDeviceExtension->ReadInterface = -1;
    fdoDeviceExtension->ReadPipe = -1;
    fdoDeviceExtension->WriteInterface = -1;
    fdoDeviceExtension->ReadPipe = -1;

    IoInitializeTimer (deviceObject, GenUSB_Timer, NULL);

    deviceObject->Flags |=  DO_DIRECT_IO;
    deviceObject->Flags |=  DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DBGPRINT(2, ("exit:  GenUSB_AddDevice\n"));

    LOGENTRY(fdoDeviceExtension, 
             'addd', 
             deviceObject, 
             fdoDeviceExtension,
             fdoDeviceExtension->StackDeviceObject);

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// GenUSB_QueryParams()
//
// This is called at AddDevice() time when the FDO is being created to query
// device parameters from the registry.
//
//******************************************************************************

VOID
GenUSB_QueryParams (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION           deviceExtension;
    RTL_QUERY_REGISTRY_TABLE    paramTable[3];
    HANDLE                      handle;
    NTSTATUS                    status;
    ULONG                       defaultReadPipe;
    ULONG                       defaultWritePipe;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_QueryFdoParams\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Set the default value in case the registry key does not exist.
    defaultReadPipe = 0; 
    defaultWritePipe = 0;

    status = IoOpenDeviceRegistryKey(
                   deviceExtension->PhysicalDeviceObject,
                   PLUGPLAY_REGKEY_DRIVER,
                   STANDARD_RIGHTS_ALL,
                   &handle);

    if (NT_SUCCESS(status))
    {
        RtlZeroMemory (&paramTable[0], sizeof(paramTable));

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = REGKEY_DEFAULT_READ_PIPE;
        paramTable[0].EntryContext  = &defaultReadPipe;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &defaultReadPipe;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = REGKEY_DEFAULT_WRITE_PIPE;
        paramTable[1].EntryContext  = &defaultWritePipe;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &defaultWritePipe;
        paramTable[1].DefaultLength = sizeof(ULONG);

        RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                               (PCWSTR)handle,
                               &paramTable[0],
                               NULL,           // Context
                               NULL);          // Environment

        ZwClose(handle);
    }


//    deviceExtension->DefaultReadPipe = defaultReadPipe;
//    deviceExtension->DefaultWritePipe = defaultWritePipe;

    DBGPRINT(2, ("DefaultReadPipe  %08X\n", defaultReadPipe));
    DBGPRINT(2, ("DefaultWritePipe  %08X\n", defaultWritePipe));

    DBGPRINT(2, ("exit:  GenUSB_QueryFdoParams\n"));
}


//******************************************************************************
//
// GenUSB_Pnp()
//
// Dispatch routine which handles IRP_MJ_PNP
//
//******************************************************************************

NTSTATUS
GenUSB_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: GenUSB_Pnp %s\n",
                 PnPMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY(deviceExtension, 'PNP ', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE:
            status = GenUSB_StartDevice(DeviceObject, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            status = GenUSB_RemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
            status = GenUSB_QueryStopRemoveDevice(DeviceObject, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            status = GenUSB_CancelStopRemoveDevice(DeviceObject, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            break;
        
        case IRP_MN_STOP_DEVICE:
            status = GenUSB_StopDevice(DeviceObject, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            //
            // The documentation says to set the status before passing the
            // Irp down the stack
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;

            // nothing else special yet, just fall through to default

        default:
            //
            // Pass the request down to the next lower driver
            //
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->StackDeviceObject, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            break;
    }

    DBGPRINT(2, ("exit:  GenUSB_Pnp %08X\n", status));

    LOGENTRY(deviceExtension, 'pnp ', status, 0, 0);

    return status;
}

//******************************************************************************
//
// GenUSB_StartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
GenUSB_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION           deviceExtension;
    NTSTATUS                    status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_StartDevice\n"));

    DBGFBRK(DBGF_BRK_STARTDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'STRT', DeviceObject, Irp, 0);

    if (deviceExtension->IsStarted)
    {
        status = STATUS_SUCCESS;
        goto GenUSB_StartDeviceDone;
    }

    // Pass IRP_MN_START_DEVICE Irp down the stack first before we do anything.
    status = GenUSB_SyncPassDownIrp(DeviceObject, Irp);

    if (!NT_SUCCESS(status)) {

        DBGPRINT(1, ("Lower driver failed IRP_MN_START_DEVICE\n"));
        LOGENTRY(deviceExtension, 'STRF', DeviceObject, Irp, status);
        goto GenUSB_StartDeviceDone;
    }

    // If this is the first time the device as been started, retrieve the
    // Device and Configuration Descriptors from the device.
    if (deviceExtension->DeviceDescriptor == NULL) {

        status = GenUSB_GetDescriptors(DeviceObject);

        if (!NT_SUCCESS(status)) {

            goto GenUSB_StartDeviceDone;
        }
        // Create the interface but do not set it yet.
        GenUSB_SetDeviceInterface (deviceExtension, TRUE, FALSE);
        // Set up the registry values for the clients
        GenUSB_SetDIRegValues (deviceExtension);
        // Set up the device Interface.
        GenUSB_SetDeviceInterface (deviceExtension, FALSE, TRUE);
    }
    else 
    {
        ExAcquireFastMutex (&deviceExtension->ConfigMutex);
        if (NULL != deviceExtension->ConfigurationHandle)
        {
            IoStartTimer (DeviceObject);
        }
        ExReleaseFastMutex (&deviceExtension->ConfigMutex);
    }


    deviceExtension->IsStarted = TRUE;

GenUSB_StartDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  GenUSB_FdoStartDevice %08X\n", status));

    LOGENTRY(deviceExtension, 'strt', status, 0, 0);

    return status;
}
//******************************************************************************
//
// GenUSB_SetDeviceInterface()
//
// This routine is called at START_DEVICE time to publish a device interface 
// GUID so that the user mode LIB can find the FDOs.
// 
//******************************************************************************
NTSTATUS 
GenUSB_SetDeviceInterface (
    IN PDEVICE_EXTENSION  DeviceExtension,
    IN BOOLEAN            Create,
    IN BOOLEAN            Set
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if (Create || Set)
    {
        if (Create)
        {
            ASSERT (NULL == DeviceExtension->DevInterfaceLinkName.Buffer);
            status = IoRegisterDeviceInterface (
                            DeviceExtension->PhysicalDeviceObject,
                            (LPGUID)&GUID_DEVINTERFACE_GENUSB,
                            NULL,
                            &DeviceExtension->DevInterfaceLinkName);
        }
        if (NT_SUCCESS(status) && Set)
        {
            status = IoSetDeviceInterfaceState (
                             &DeviceExtension->DevInterfaceLinkName, 
                             TRUE);
        }
    }
    else 
    {
        ASSERT (NULL != DeviceExtension->DevInterfaceLinkName.Buffer);
        status = IoSetDeviceInterfaceState(
                             &DeviceExtension->DevInterfaceLinkName, 
                             FALSE);

        RtlFreeUnicodeString (&DeviceExtension->DevInterfaceLinkName);
    }
    return status;
}


//******************************************************************************
//
// GenUSB_SyncCompletionRoutine()
//
// Completion routine used by GenUSB_SyncPassDownIrp and
// GenUSB_SyncSendUsbRequest
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
GenUSB_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PDEVICE_EXTENSION deviceExtension;

    KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// GenUSB_SyncPassDownIrp()
//
//******************************************************************************

NTSTATUS
GenUSB_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;
    KEVENT              localevent;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_SyncPassDownIrp\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    KeInitializeEvent(&localevent, SynchronizationEvent, FALSE);

    // Copy down Irp params for the next driver
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Set the completion routine, which will signal the event
    IoSetCompletionRoutine(Irp,
                           GenUSB_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp down the stack
    status = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

    KeWaitForSingleObject(&localevent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    status = Irp->IoStatus.Status;

    DBGPRINT(2, ("exit:  GenUSB_SyncPassDownIrp %08X\n", status));
    return status;
}

//******************************************************************************
//
// GenUSB_SyncSendUsbRequest()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
GenUSB_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              localevent;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            status;

    PAGED_CODE();

    DBGPRINT(3, ("enter: GenUSB_SyncSendUsbRequest\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    KeInitializeEvent(&localevent, SynchronizationEvent, FALSE);

    // Allocate the Irp
    irp = IoAllocateIrp(deviceExtension->StackDeviceObject->StackSize, FALSE);

    LOGENTRY(deviceExtension, 'SSUR', DeviceObject, irp, Urb);

    if (NULL == irp)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    IoSetCompletionRoutine(irp,
                           GenUSB_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel



    // Pass the Irp & Urb down the stack
    status = IoCallDriver (deviceExtension->StackDeviceObject, irp);

    // If the request is pending, block until it completes
    if (status == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        status = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (status == STATUS_TIMEOUT)
        {
            status = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            IoCancelIrp(irp);

            // And wait until the cancel completes
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            status = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    IoFreeIrp(irp);

    LOGENTRY(deviceExtension, 'ssur', status, Urb, Urb->UrbHeader.Status);

    DBGPRINT(3, ("exit:  GenUSB_SyncSendUsbRequest %08X\n", status));

    return status;
}

//******************************************************************************
//
// GenUSB_QueryStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_STOP_DEVICE and
// IRP_MN_QUERY_REMOVE_DEVICE for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
//******************************************************************************

NTSTATUS
GenUSB_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();
    
    DBGPRINT(2, ("enter: GenUSB_QueryStopRemoveDevice\n"));
    DBGFBRK(DBGF_BRK_QUERYSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'QSRD', Irp, 0, 0);
    
    //
    // Notification that we are about to stop or be removed, but we don't care
    // Pass the IRP_MN_QUERY_STOP/REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

    DBGPRINT(2, ("exit:  GenUSB_FdoQueryStopRemoveDevice %08X\n", status));

    LOGENTRY(deviceExtension, 'qsrd', Irp, 0, status);

    return status;
}


//******************************************************************************
//
// GenUSB_FdoCancelStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_CANCEL_STOP_DEVICE and
// IRP_MN_CANCEL_REMOVE_DEVICE for the FDO.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
GenUSB_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;
    
    PAGED_CODE();
    DBGPRINT(2, ("enter: GenUSB_FdoCancelStopRemoveDevice\n"));
    DBGFBRK(DBGF_BRK_CANCELSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'CSRD', DeviceObject, Irp, 0);

    // The documentation says to set the status before passing the Irp down
    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Notification that the attempt to stop or be removed, is cancelled
    // but we don't care
    // Pass the IRP_MN_CANCEL_STOP/REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

    DBGPRINT(2, ("exit:  GenUSB_FdoQueryStopRemoveDevice %08X\n", status));

    LOGENTRY(deviceExtension, 'qsrd', Irp, 0, status);

    return status;
}


//******************************************************************************
//
// GenUSB_FdoStopDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_STOP_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// The PnP Manager only sends this IRP if a prior IRP_MN_QUERY_STOP_DEVICE
// completed successfully.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  A driver must
// not fail this IRP.  If a driver cannot release the device's hardware
// resources, it can fail a query-stop IRP, but once it succeeds the query-stop
// request it must succeed the stop request.
//
//******************************************************************************

NTSTATUS
GenUSB_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension;
    NTSTATUS           status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_FdoStopDevice\n"));

    DBGFBRK(DBGF_BRK_STOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'STOP', Irp, 0, 0);

    // Release the device resources allocated during IRP_MN_START_DEVICE

    // Stop the timeout timer
    IoStopTimer(DeviceObject);

    // The documentation says to set the status before passing the
    // Irp down the stack
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_STOP_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

    DBGPRINT(2, ("exit:  GenUSB_FdoStopDevice %08X\n", status));

    LOGENTRY(deviceExtension, 'stop', 0, 0, status);

    return status;
}


//******************************************************************************
//
// GenUSB_RemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE for the FDO
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  Drivers must not
// fail this IRP.
//
//******************************************************************************

NTSTATUS
GenUSB_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_FdoRemoveDevice\n"));

    DBGFBRK(DBGF_BRK_REMOVEDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    IoReleaseRemoveLockAndWait (&deviceExtension->RemoveLock, Irp);

    // Free everything that was allocated during IRP_MN_START_DEVICE

    // The configuration should have been desected in the close,
    // which we should have received even in a surprise remove case.
    //
    // GenUSB_DeselectConfiguration (deviceExtension, FALSE);
    // 

    LOGUNINIT(deviceExtension);

    ASSERT (NULL == deviceExtension->ConfigurationHandle);

    if (deviceExtension->DeviceDescriptor != NULL)
    {
        ExFreePool(deviceExtension->DeviceDescriptor);
    }

    if (deviceExtension->ConfigurationDescriptor != NULL)
    {
        ExFreePool(deviceExtension->ConfigurationDescriptor);
    }

    if (deviceExtension->SerialNumber != NULL)
    {
        ExFreePool(deviceExtension->SerialNumber);
    }

    // The documentation says to set the status before passing the Irp down
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_REMOVE_DEVICE Irp down the stack.
    IoSkipCurrentIrpStackLocation(Irp);

    status = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

    LOGENTRY(deviceExtension, 'rem3', DeviceObject, 0, 0);

    // Free everything that was allocated during AddDevice
    IoDetachDevice(deviceExtension->StackDeviceObject);

    IoDeleteDevice(DeviceObject);

    DBGPRINT(2, ("exit:  GenUSB_FdoRemoveDevice %08X\n", status));
    return status;
}

NTSTATUS
GenUSB_SetDIRegValues (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status;
    HANDLE   key;
    UNICODE_STRING name;
    ULONG    value = 0xf00d;

    RtlInitUnicodeString (&name, L"PlaceHolder");

    status = IoOpenDeviceInterfaceRegistryKey (
                    &DeviceExtension->DevInterfaceLinkName,
                    STANDARD_RIGHTS_ALL,
                    &key);

    if (!NT_SUCCESS (status))
    {
        ASSERT (NT_SUCCESS (status));
        return status;
    }
    
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));
    
    if (!NT_SUCCESS (status))
    {
        ASSERT (NT_SUCCESS (status));
        return status;
    }
    
    
    //
    // Write in the class code and subcodes.
    //
    ASSERT (DeviceExtension->DeviceDescriptor);
    RtlInitUnicodeString (&name, GENUSB_REG_STRING_DEVICE_CLASS);
    value = DeviceExtension->DeviceDescriptor->bDeviceClass;
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));

    ASSERT (NT_SUCCESS (status));

    RtlInitUnicodeString (&name, GENUSB_REG_STRING_DEVICE_SUB_CLASS);
    value = DeviceExtension->DeviceDescriptor->bDeviceSubClass;
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));
    ASSERT (NT_SUCCESS (status));

    RtlInitUnicodeString (&name, GENUSB_REG_STRING_DEVICE_PROTOCOL);
    value = DeviceExtension->DeviceDescriptor->bDeviceProtocol;
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));
    ASSERT (NT_SUCCESS (status));

    RtlInitUnicodeString (&name, GENUSB_REG_STRING_VID);
    value = DeviceExtension->DeviceDescriptor->idVendor;
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));
    ASSERT (NT_SUCCESS (status));

    RtlInitUnicodeString (&name, GENUSB_REG_STRING_PID);
    value = DeviceExtension->DeviceDescriptor->idProduct;
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));
    ASSERT (NT_SUCCESS (status));

    RtlInitUnicodeString (&name, GENUSB_REG_STRING_REV);
    value = DeviceExtension->DeviceDescriptor->bcdDevice;
    status = ZwSetValueKey (
                 key,
                 &name,
                 0,
                 REG_DWORD,
                 &value,
                 sizeof (value));
    ASSERT (NT_SUCCESS (status));

    ZwClose (key);

    return status;
}


//******************************************************************************
//
// GenUSB_Power()
//
// Dispatch routine which handles IRP_MJ_POWER
//
//******************************************************************************

NTSTATUS
GenUSB_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS           status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: GenUSB_Power %08X %08X %s\n",
                 DeviceObject,
                 Irp,
                 PowerMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY(deviceExtension, 'PWR_', 
             Irp, 
             deviceExtension->DevicePowerState,
             irpStack->MinorFunction);

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        LOGENTRY(deviceExtension, 'PWRs',
                 irpStack->Parameters.Power.Type,
                 irpStack->Parameters.Power.State.SystemState,
                 irpStack->Parameters.Power.ShutdownType);

        DBGPRINT(2, ("%s IRP_MN_SET_POWER %s\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     "System" : "Device",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     PowerSystemStateString(irpStack->Parameters.Power.State.SystemState) :
                     PowerDeviceStateString(irpStack->Parameters.Power.State.DeviceState)));
    }

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        //
        // Handle powering the FDO down and up...
        //
        status = GenUSB_SetPower(deviceExtension, Irp);
    }
    else
    {
        // No special processing for IRP_MN_QUERY_POWER, IRP_MN_WAIT_WAKE,
        // or IRP_MN_POWER_SEQUENCE at this time.  Just pass the request
        // down to the next lower driver now.
        //
        PoStartNextPowerIrp(Irp);
 
        IoSkipCurrentIrpStackLocation(Irp);

        status = PoCallDriver(deviceExtension->StackDeviceObject, Irp);
    }

    DBGPRINT(2, ("exit:  GenUSB_Power %08X\n", status));

    LOGENTRY(deviceExtension, 'powr', status, 0, 0);

    return status;
}

//******************************************************************************
//
// GenUSB_FdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the FDO
//
//******************************************************************************

NTSTATUS
GenUSB_SetPower (
    PDEVICE_EXTENSION   DeviceExtension,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION  irpStack;
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    POWER_STATE         oldState;
    POWER_STATE         newState;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    LOGENTRY(DeviceExtension, 'FDSP', Irp, powerType, powerState.SystemState);

    switch (powerType)
    {
    case SystemPowerState:
        // Remember the current system state.
        //
        DeviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (DeviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceExtension, Irp,
                         PowerDeviceStateString(DeviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(DeviceExtension->CurrentPowerIrp == NULL);

            DeviceExtension->CurrentPowerIrp = Irp;

            status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       newState,
                                       GenUSB_SetPowerCompletion,
                                       DeviceExtension,
                                       NULL);

        }
        break;

    case DevicePowerState:

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceExtension, Irp,
                     PowerDeviceStateString(DeviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        //
        // Update the current device state.
        //
        oldState.DeviceState = DeviceExtension->DevicePowerState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            //
            // DeviceState is checked on devicecontrol, read and write, but is
            // only set here and in the completion routine
            // GenUSB_SetPowerD0Completion
            //
            DeviceExtension->DevicePowerState = powerState.DeviceState;

            //
            // After talking extensively with JD, he tells me that I do not need  
            // to queue requests for power downs or query stop.  If that is the 
            // case then even if the device power state isn't PowerDeviceD0 we 
            // can still allow trasfers.  This, of course, is a property of the 
            // brand new port driver that went into XP.
            //
            // Also we shouldn't need to queue our current request. 
            // Instead we will just let the transfers fail. 
            //
            // The app will see the failures returned with the appropriate 
            // status codes so that they can do the right thing.
            //

            PoStartNextPowerIrp (Irp);
            IoSkipCurrentIrpStackLocation (Irp);
            status = PoCallDriver(DeviceExtension->StackDeviceObject, Irp);

        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            //
            // Since we didn't have to do anything for powering down
            // We likewise need to do nothing for powering back up.
            //

            IoCopyCurrentIrpStackLocationToNext (Irp);

            IoSetCompletionRoutine (Irp, 
                                    GenUSB_SetPowerD0Completion,
                                    NULL, // no context
                                    TRUE,
                                    TRUE,
                                    TRUE);

            status = PoCallDriver(DeviceExtension->StackDeviceObject, Irp);
        }
    }

    DBGPRINT(2, ("exit:  GenUSB_FdoSetPower %08X\n", status));

    LOGENTRY(DeviceExtension, 'fdsp', status, 0, 0);

    return status;
}

//******************************************************************************
//
// GenUSB_SetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in GenUSB_FdoSetPower.
//
// The purpose of this routine is to block passing down the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
GenUSB_SetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_EXTENSION  deviceExtension;
    PIRP               irp;

    deviceExtension = (PDEVICE_EXTENSION) Context;

    ASSERT(deviceExtension->CurrentPowerIrp != NULL);

    irp = deviceExtension->CurrentPowerIrp;

    deviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        DBGPRINT(2, ("GenUSB_SetPowerCompletion %08X %08X %s %08X\n",
                     deviceExtension, irp,
                     PowerSystemStateString(systemState),
                     IoStatus->Status));

        LOGENTRY(deviceExtension, 'fspc', 0, systemState, IoStatus->Status);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now pass down the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    PoStartNextPowerIrp(irp);

    IoCopyCurrentIrpStackLocationToNext(irp);

    // Mark the Irp pending since GenUSB_FdoSetPower() would have
    // originally returned STATUS_PENDING after calling PoRequestPowerIrp().
    IoMarkIrpPending(irp);

    PoCallDriver(deviceExtension->StackDeviceObject, irp);
}

//******************************************************************************
//
// GenUSB_SetPowerD0Completion()
//
// Completion routine used by GenUSB_FdoSetPower when passing down a
// IRP_MN_SET_POWER DevicePowerState PowerDeviceD0 Irp for the FDO.
//
// The purpose of this routine is to delay unblocking the device queue
// until after the DevicePowerState PowerDeviceD0 Irp completes.
//
//******************************************************************************

NTSTATUS
GenUSB_SetPowerD0Completion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{

    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    DEVICE_POWER_STATE  deviceState;
    KIRQL               irql;
    NTSTATUS            status;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(PowerDeviceD0 == irpStack->Parameters.Power.State.DeviceState);
    ASSERT(deviceExtension->DevicePowerState != PowerDeviceD0);
    deviceState=deviceExtension->DevicePowerState;

    //
    // DeviceState is checked on devicecontrol, read, and write, but is only 
    // set here, and in the power down code of GenUSB_SetPower.
    //
    deviceExtension->DevicePowerState = PowerDeviceD0;
        
    status = Irp->IoStatus.Status;

    DBGPRINT(2, ("GenUSB_FdoSetPowerD0Completion %08X %08X %s %08X\n",
                 DeviceObject, Irp,
                 PowerDeviceStateString(deviceState),
                 status));

    LOGENTRY(deviceExtension, 'fs0c', DeviceObject, deviceState, status);

    // Powering up.  Unblock the device queue which was left blocked
    // after GenUSB_StartIo() passed down the power down Irp.

    PoStartNextPowerIrp(Irp);

    return status;
}

//******************************************************************************
//
// GenUSB_SystemControl()
//
// Dispatch routine which handles IRP_MJ_SYSTEM_CONTROL
//
//******************************************************************************

NTSTATUS
GenUSB_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: GenUSB_SystemControl %2X\n", irpStack->MinorFunction));

    LOGENTRY(deviceExtension, 'SYSC', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
        //
        // XXXXX Need to handle any of these?
        //

    default:
        //
        // Pass the request down to the next lower driver
        //
        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);
        break;
    }

    DBGPRINT(2, ("exit:  GenUSB_SystemControl %08X\n", ntStatus));

    LOGENTRY(deviceExtension, 'sysc', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\devioctl.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    GENUSB.C

Abstract:

    This source file contains the DriverEntry() and AddDevice() entry points
    for the GENUSB driver and the dispatch routines which handle:

    IRP_MJ_POWER
    IRP_MJ_SYSTEM_CONTROL
    IRP_MJ_PNP

Environment:

    kernel mode

Revision History:

    Sep 2001 : Copied from USBMASS

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include "genusb.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, GenUSB_DeviceControl)
#endif


//******************************************************************************
//
// GenUSB_DeviceControl()
//
//******************************************************************************


NTSTATUS
GenUSB_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS           status;
    PDEVICE_EXTENSION  deviceExtension;
    ULONG              ioControlCode;
    ULONG              buffLen;
    ULONG              requiredLen;
    ULONG              numberInterfaces;
    ULONG              i;
    PVOID              source;
    PIO_STACK_LOCATION irpSp;
    PCHAR              buffer;
    ULONG              urbStatus;
    USHORT             resultLength;
    BOOLEAN            complete;
    USBD_PIPE_HANDLE   usbdPipeHandle;

    PGENUSB_GET_STRING_DESCRIPTOR   stringDescriptor;
    PGENUSB_GET_REQUEST             request;
    PGENUSB_REQUEST_RESULTS         requestResult;
    PGENUSB_SELECT_CONFIGURATION    selectConfig;
    PGENUSB_SET_READ_WRITE_PIPES    readWritePipes;
    GENUSB_READ_WRITE_PIPE          transfer;

    PAGED_CODE ();

    complete = TRUE;

    deviceExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // While there are several readers of the IsStarted state, it is only
    // set at the end of GenUSB_StartDevice.
    if (!deviceExtension->IsStarted) { 
        LOGENTRY(deviceExtension,'IOns', DeviceObject, Irp, 0);
        status = STATUS_DEVICE_NOT_CONNECTED;
        goto GenUSB_DeviceControlDone;
    }

    //
    // After talking extensively with JD, he tells me that I do not need  
    // to queue requests for power downs or query stop.  If that is the 
    // case then even if the device power state isn't PowerDeviceD0 we 
    // can still allow trasfers.  This, of course, is a property of the 
    // brand new port driver that went into XP.
    //
    // if (DeviceExtension->DevicePowerState != PowerDeviceD0) 
    // {
    // }
    //
    
    //
    // BUGBUG if we ever implement IDLE, we need to turn the device
    // back on here.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    // Get the Ioctl code
    ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    // We need to clear the information field in all cases.
    Irp->IoStatus.Information = 0;

    switch (ioControlCode) {

    case IOCTL_GENUSB_GET_DEVICE_DESCRIPTOR:
    case IOCTL_GENUSB_GET_CONFIGURATION_DESCRIPTOR:
        LOGENTRY(deviceExtension, 'IO_1', ioControlCode, DeviceObject, Irp);

        //
        // All of these ioctls copy data from the device extension
        // to the caller's buffer
        //
        switch (ioControlCode) {
        case IOCTL_GENUSB_GET_DEVICE_DESCRIPTOR:
            source = deviceExtension->DeviceDescriptor;
            requiredLen = deviceExtension->DeviceDescriptor->bLength;
            break;
        case IOCTL_GENUSB_GET_CONFIGURATION_DESCRIPTOR:
            source = deviceExtension->ConfigurationDescriptor;
            requiredLen = deviceExtension->ConfigurationDescriptor->wTotalLength;
            break;
        default:
            // Panic
            ASSERT (ioControlCode);
            status = STATUS_INVALID_PARAMETER;
            goto GenUSB_DeviceControlDone;
        }

        // Verify that there is a system buffer
        if (NULL == Irp->AssociatedIrp.SystemBuffer) {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        buffer = Irp->AssociatedIrp.SystemBuffer;

        // Verify that this buffer is of sufficient length
        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen < requiredLen) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        // Copy in the data and return the length in the information field.
        RtlCopyMemory (buffer, source, requiredLen);
        Irp->IoStatus.Information = requiredLen;
        break;

    case IOCTL_GENUSB_GET_STRING_DESCRIPTOR:
        LOGENTRY(deviceExtension, 'IO_2', ioControlCode, DeviceObject, Irp);

        if (NULL == Irp->AssociatedIrp.SystemBuffer)
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        stringDescriptor = Irp->AssociatedIrp.SystemBuffer;
        buffer = Irp->AssociatedIrp.SystemBuffer;

        //
        // verify input length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_GET_STRING_DESCRIPTOR))
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // verify output length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen < sizeof (USB_STRING_DESCRIPTOR)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        //
        // if the caller didn't specify a language ID, then insert the default
        // language ID.  (but only if the caller is not trying to retrive
        // the array of language IDs.
        //
        if ((0 == stringDescriptor->LanguageId) && 
            (0 != stringDescriptor->Index)) {
            stringDescriptor->LanguageId = deviceExtension->LanguageId;
        }

        switch (stringDescriptor->Recipient)
        {

        case GENUSB_RECIPIENT_DEVICE:
            stringDescriptor->Recipient = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
            break;

        case GENUSB_RECIPIENT_INTERFACE:
            stringDescriptor->Recipient = URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
            break;

        case GENUSB_RECIPIENT_ENDPOINT:
            stringDescriptor->Recipient = URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
            goto GenUSB_DeviceControlDone;
        }

        status = GenUSB_GetDescriptor (DeviceObject,
                                       stringDescriptor->Recipient,
                                       USB_STRING_DESCRIPTOR_TYPE,
                                       stringDescriptor->Index,
                                       stringDescriptor->LanguageId,
                                       0, // retry count
                                       buffLen,
                                       &buffer);

        if (!NT_SUCCESS (status)) {

            DBGPRINT(1, ("Get String Descriptor failed (%x) %08X\n", 
                         stringDescriptor->Index,
                         status));
            break;
        }
        Irp->IoStatus.Information = buffLen;
        break;

    case IOCTL_GENUSB_GET_REQUEST:
        LOGENTRY(deviceExtension, 'IO_3', ioControlCode, DeviceObject, Irp);
        
        if (NULL == Irp->AssociatedIrp.SystemBuffer) {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        request = Irp->AssociatedIrp.SystemBuffer;
        requestResult = Irp->AssociatedIrp.SystemBuffer;

        //
        // verify input length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_GET_REQUEST)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // verify output length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen < sizeof (GENUSB_REQUEST_RESULTS)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // adjust the buffer 
        //
        buffer = requestResult->Buffer;
        buffLen -= FIELD_OFFSET (GENUSB_REQUEST_RESULTS, Buffer);

        LOGENTRY(deviceExtension, 
                 'IoGR', 
                 (request->RequestType << 8) & request->Request, 
                 request->Value,
                 request->Index);
        
        DBGPRINT(2, ("Get Request: Type %x Request %x Value %x Index %x\n",
                     request->RequestType,
                     request->Request,
                     request->Value,
                     request->Index));

        status = GenUSB_VendorControlRequest (DeviceObject,
                                              request->RequestType,
                                              request->Request,
                                              request->Value,
                                              request->Index,
                                              (USHORT) buffLen, // disallow longer descriptors
                                              0, // retry count
                                              &urbStatus,
                                              &resultLength,
                                              &buffer);

        requestResult->Status = urbStatus;
        requestResult->Length = resultLength;
        
        if (!NT_SUCCESS (status))
        {
            DBGPRINT(1, ("Get Descriptor failed (%x) %08X\n", urbStatus));
            Irp->IoStatus.Information = sizeof (GENUSB_REQUEST_RESULTS);
            status = STATUS_SUCCESS;

        } else {
            Irp->IoStatus.Information = resultLength
                + FIELD_OFFSET (GENUSB_REQUEST_RESULTS, Buffer);

        }
        break;

    case IOCTL_GENUSB_GET_CAPS:
        LOGENTRY(deviceExtension, 'IO_4', ioControlCode, DeviceObject, Irp);
        //
        // METHOD_BUFFERED irp.  the buffer is in the AssociatedIrp.
        //

        if (NULL == Irp->AssociatedIrp.SystemBuffer) {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        buffer = Irp->AssociatedIrp.SystemBuffer;

        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen < sizeof (GENUSB_CAPABILITIES)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        ((PGENUSB_CAPABILITIES) buffer) ->DeviceDescriptorLength = 
            deviceExtension->DeviceDescriptor->bLength;

        ((PGENUSB_CAPABILITIES) buffer) ->ConfigurationInformationLength = 
            deviceExtension->ConfigurationDescriptor->wTotalLength;

        Irp->IoStatus.Information = sizeof (GENUSB_CAPABILITIES);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_GENUSB_SELECT_CONFIGURATION:
        LOGENTRY(deviceExtension, 'IO_5', ioControlCode, DeviceObject, Irp);

        //
        // GenUSB_SelectInterface checks to see if the configuration handle
        // is already set and fails if it is.
        //
        //    if (NULL != deviceExtension->ConfigurationHandle)
        //    {
        //        status = STATUS_UNSUCCESSFUL;
        //    }
        //

        if (NULL == Irp->AssociatedIrp.SystemBuffer) 
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        selectConfig = Irp->AssociatedIrp.SystemBuffer;

        //
        // The input buffer must be long enough to contain at least the 
        // header information
        //
        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen < sizeof (GENUSB_SELECT_CONFIGURATION)) 
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // The input buffer must be exactly the length as specfied by the 
        // header information.
        //
        numberInterfaces = selectConfig->NumberInterfaces;
        if (buffLen != sizeof (GENUSB_SELECT_CONFIGURATION) 
                     + (sizeof (USB_INTERFACE_DESCRIPTOR) * numberInterfaces)) 
        {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // The output buffer must be same length 
        //
        if (buffLen != irpSp->Parameters.DeviceIoControl.OutputBufferLength) 
        {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        status = GenUSB_SelectConfiguration (deviceExtension, 
                                             numberInterfaces, 
                                             selectConfig->Interfaces,
                                             selectConfig->Interfaces);
        if (!NT_SUCCESS (status)) 
        {
            break;
        }

        //
        // rebase the interface numbers
        //
        for (i = 0; i < selectConfig->NumberInterfaces; i++) 
        {

            selectConfig->Interfaces[i].bInterfaceNumber = (UCHAR) i;
        }
        selectConfig->NumberInterfaces = deviceExtension->InterfacesFound;
        Irp->IoStatus.Information = buffLen;

        break;

    case IOCTL_GENUSB_DESELECT_CONFIGURATION:
        LOGENTRY(deviceExtension, 'IO_6', ioControlCode, DeviceObject, Irp);

        status = GenUSB_DeselectConfiguration (deviceExtension, TRUE);
        Irp->IoStatus.Information = 0;

        break;

    case IOCTL_GENUSB_GET_PIPE_INFO:
        LOGENTRY(deviceExtension, 'IO_7', ioControlCode, DeviceObject, Irp);

        if (NULL == Irp->AssociatedIrp.SystemBuffer) 
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        //
        // verify input length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_PIPE_INFO_REQUEST)) 
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // verify output length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen != sizeof (GENUSB_PIPE_INFORMATION)) 
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        status = 
            GenUSB_GetSetPipe (
                deviceExtension,
                NULL, // no interface index
                &((PGENUSB_PIPE_INFO_REQUEST) Irp->AssociatedIrp.SystemBuffer)->InterfaceNumber,
                NULL, // no pipe index
                &((PGENUSB_PIPE_INFO_REQUEST) Irp->AssociatedIrp.SystemBuffer)->EndpointAddress,
                NULL, // No set Properties
                (PGENUSB_PIPE_INFORMATION) Irp->AssociatedIrp.SystemBuffer,
                NULL, // No set Properties
                NULL); // No UsbdPipeHandles needed

        if (NT_SUCCESS (status))
        {
            Irp->IoStatus.Information = sizeof (GENUSB_PIPE_INFORMATION);
        }

        break;

    case IOCTL_GENUSB_SET_READ_WRITE_PIPES:
        LOGENTRY(deviceExtension, 'IO_8', ioControlCode, DeviceObject, Irp);

        if (NULL == Irp->AssociatedIrp.SystemBuffer) 
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        readWritePipes = 
            (PGENUSB_SET_READ_WRITE_PIPES) Irp->AssociatedIrp.SystemBuffer;
        //
        // verify input length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_SET_READ_WRITE_PIPES))
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // verify output length
        //
        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen != 0)
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = GenUSB_SetReadWritePipes (
                    deviceExtension,
                    (PGENUSB_PIPE_HANDLE) &readWritePipes->ReadPipe,
                    (PGENUSB_PIPE_HANDLE) &readWritePipes->WritePipe);


        //  on success the information field stays at zero.
        //
        //        if (NT_SUCCESS (status))
        //        {
        //            Irp->IoStatus.Information = 0;
        //        }

        break;
    case IOCTL_GENUSB_GET_PIPE_PROPERTIES:
        LOGENTRY(deviceExtension, 'IO_9', ioControlCode, DeviceObject, Irp);
        //
        // METHOD_BUFFERED irp.  the buffer is in the AssociatedIrp.
        //

        if (NULL == Irp->AssociatedIrp.SystemBuffer)  
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        buffer = Irp->AssociatedIrp.SystemBuffer;

        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_PIPE_HANDLE)) 
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen != sizeof (GENUSB_PIPE_PROPERTIES)) 
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        } 

        if (! VERIFY_PIPE_HANDLE_SIG (buffer, deviceExtension))
        { 
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = 
            GenUSB_GetSetPipe (
                deviceExtension,
                &((PGENUSB_PIPE_HANDLE) buffer)->InterfaceIndex,
                NULL, // no interface number
                &((PGENUSB_PIPE_HANDLE) buffer)->PipeIndex,
                NULL, // no endpoint address
                NULL, // no set
                NULL, // no Pipe Info
                ((PGENUSB_PIPE_PROPERTIES) buffer),
                NULL); // usbd PipeHandle not needed

        Irp->IoStatus.Information = sizeof (GENUSB_PIPE_PROPERTIES);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_GENUSB_SET_PIPE_PROPERTIES:
        LOGENTRY(deviceExtension, 'IO_A', ioControlCode, DeviceObject, Irp);
        //
        // METHOD_BUFFERED irp.  the buffer is in the AssociatedIrp.
        //
        if (NULL == Irp->AssociatedIrp.SystemBuffer) 
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        buffer = Irp->AssociatedIrp.SystemBuffer;

        // Verify Input Length
        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_PIPE_HANDLE) + sizeof (GENUSB_PIPE_PROPERTIES)) 
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        // Verify Output Length
        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen != 0) 
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        } 

        if (! VERIFY_PIPE_HANDLE_SIG (buffer, deviceExtension))
        { 
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = 
            GenUSB_GetSetPipe (
                deviceExtension,
                &((PGENUSB_PIPE_HANDLE) buffer)->InterfaceIndex,
                NULL, // no interface number
                &((PGENUSB_PIPE_HANDLE) buffer)->PipeIndex,
                NULL, // no endpoint address
                (PGENUSB_PIPE_PROPERTIES) (buffer + sizeof (GENUSB_PIPE_HANDLE)),
                NULL, // no Pipe Info
                NULL, // no Get
                NULL); // no UsbdPipeHandle needed

        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        break;

    case IOCTL_GENUSB_RESET_PIPE:
        LOGENTRY(deviceExtension, 'IO_B', ioControlCode, DeviceObject, Irp);
        //
        // METHOD_BUFFERED irp.  the buffer is in the AssociatedIrp.
        //

        if (NULL == Irp->AssociatedIrp.SystemBuffer)  
        {
            ASSERT (Irp->AssociatedIrp.SystemBuffer);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        buffer = Irp->AssociatedIrp.SystemBuffer;

        buffLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (buffLen != sizeof (GENUSB_RESET_PIPE)) 
        {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        buffLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
        if (buffLen != 0)
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        } 

        if (! VERIFY_PIPE_HANDLE_SIG (buffer, deviceExtension))
        { 
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = 
            GenUSB_GetSetPipe (
                deviceExtension,
                &((PGENUSB_PIPE_HANDLE) buffer)->InterfaceIndex,
                NULL, // no interface number
                &((PGENUSB_PIPE_HANDLE) buffer)->PipeIndex,
                NULL, // no endpoint address
                NULL, // no set
                NULL, // no Pipe Info
                NULL, // no PipeProperties
                &usbdPipeHandle);

        if (!NT_SUCCESS (status))
        {
            break;
        }

        status = GenUSB_ResetPipe (deviceExtension,
                                   usbdPipeHandle,
                                   ((PGENUSB_RESET_PIPE)buffer)->ResetPipe,
                                   ((PGENUSB_RESET_PIPE)buffer)->ClearStall,
                                   ((PGENUSB_RESET_PIPE)buffer)->FlushData);

        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_GENUSB_READ_WRITE_PIPE:
        LOGENTRY(deviceExtension, 'IO_C', ioControlCode, DeviceObject, Irp);

        status = GenUSB_ProbeAndSubmitTransfer (Irp, irpSp, deviceExtension);
        complete = FALSE;
        break;

    default:
        //
        // 'Fail' the Irp by returning the default status.
        //
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

GenUSB_DeviceControlDone:

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    if (complete)
    {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT); 
    }
    return status;
}

NTSTATUS
GenUSB_ProbeAndSubmitTransferComplete (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PGENUSB_TRANSFER  LocalTrans,
    IN USBD_STATUS       Status,
    IN ULONG             Length
    );

NTSTATUS
GenUSB_ProbeAndSubmitTransfer (
    IN  PIRP               Irp,
    IN  PIO_STACK_LOCATION IrpSp,
    IN  PDEVICE_EXTENSION  DeviceExtension
    )
{
    NTSTATUS status;
    PMDL     mdl;
    BOOLEAN  userLocked;
    BOOLEAN  transferLocked;

    PGENUSB_READ_WRITE_PIPE userTrans; // a pointer to the user's buffer
    PGENUSB_TRANSFER        localTrans;  // a local copy of the user data.
    
    LOGENTRY(DeviceExtension, 'PROB', DeviceExtension->Self, Irp, 0);
    
    status = STATUS_SUCCESS; 
    userTrans = NULL;
    localTrans = NULL;
    userLocked = FALSE;
    transferLocked = FALSE;

    //
    // Validate the user's buffer.
    //
    try {
        
        if (sizeof (GENUSB_READ_WRITE_PIPE) != 
            IrpSp->Parameters.DeviceIoControl.InputBufferLength)
        { 
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        userTrans = (PGENUSB_READ_WRITE_PIPE)  
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        if (NULL == userTrans)
        {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        localTrans = (PGENUSB_TRANSFER)
                     ExAllocatePool (NonPagedPool, sizeof (GENUSB_TRANSFER));

        if (NULL == localTrans)
        { 
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        } 

        RtlZeroMemory (localTrans, sizeof (GENUSB_TRANSFER));

        //
        // The input comes in User Buffer, and should be a 
        // PGENUSB_READ_WRITE_PIPE structure.
        //
        localTrans->UserMdl = IoAllocateMdl (userTrans,
                                             sizeof(PGENUSB_READ_WRITE_PIPE),
                                             FALSE, // no 2nd buffer
                                             TRUE, // charge quota
                                             NULL); // no associated irp

        if (NULL == localTrans->UserMdl)
        { 
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        MmProbeAndLockPages (localTrans->UserMdl,
                             KernelMode,
                             ((localTrans->UserCopy.UsbdTransferFlags
                                   & USBD_TRANSFER_DIRECTION_IN) 
                              ? IoReadAccess
                              : IoWriteAccess));
        userLocked = TRUE;

 
        // make a local copy of the user data so that it doesn't move.
        localTrans->UserCopy = *userTrans;

        // mask off the invalid flags.
        localTrans->UserCopy.UsbdTransferFlags &= 
            USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION;

        // Now probe the transfer location
        localTrans->TransferMdl = IoAllocateMdl (
                                        localTrans->UserCopy.UserBuffer,
                                        localTrans->UserCopy.BufferLength,
                                        FALSE, // no 2nd buffer
                                        TRUE, // do charge the quota
                                        NULL); // no associated irp
 
        if (NULL == localTrans->TransferMdl)
        { 
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        MmProbeAndLockPages (localTrans->TransferMdl,
                             KernelMode,
                             ((localTrans->UserCopy.UsbdTransferFlags
                                   & USBD_TRANSFER_DIRECTION_IN) 
                              ? IoReadAccess
                              : IoWriteAccess));

        transferLocked = TRUE;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        goto GenUSBProbSubmitTransferReject;
    }

    if (! VERIFY_PIPE_HANDLE_SIG (&localTrans->UserCopy.Pipe, DeviceExtension))
    {
        status = STATUS_INVALID_PARAMETER;
        goto GenUSBProbSubmitTransferReject;
    }

    // Unfortunately we complete, we will no longer running in the contect
    //  of the caller.
    // Therefore we we cannot use LocalTrans->UserCopy.UserBuffer to just
    // dump the return data.  We instead need a system address for it.
    localTrans->SystemAddress = 
        MmGetSystemAddressForMdlSafe (localTrans->UserMdl, NormalPagePriority);

    if (NULL == localTrans->SystemAddress)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GenUSBProbSubmitTransferReject;
    }

    // 
    // now perform the transfer.
    //
    LOGENTRY(DeviceExtension, 'prob', DeviceExtension->Self, Irp, status);
    status = GenUSB_TransmitReceive (
                DeviceExtension,
                Irp,
                ((PGENUSB_PIPE_HANDLE)&localTrans->UserCopy.Pipe)->InterfaceIndex,
                ((PGENUSB_PIPE_HANDLE)&localTrans->UserCopy.Pipe)->PipeIndex,
                localTrans->UserCopy.UsbdTransferFlags,
                NULL, // no buffer pointer
                localTrans->TransferMdl,
                localTrans->UserCopy.BufferLength,
                localTrans,
                GenUSB_ProbeAndSubmitTransferComplete);

    return status;

GenUSBProbSubmitTransferReject:
    
    LOGENTRY (DeviceExtension, 'prob', DeviceExtension->Self, Irp, status);
    if (NULL != localTrans)
    {
        if (localTrans->UserMdl)
        { 
            if (userLocked)
            {
                MmUnlockPages (localTrans->UserMdl);
            }
            IoFreeMdl (localTrans->UserMdl);
        }
        if (localTrans->TransferMdl)
        { 
            if (transferLocked)
            { 
                MmUnlockPages (localTrans->TransferMdl);
            }
            IoFreeMdl (localTrans->TransferMdl);
        }
        ExFreePool (localTrans);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
GenUSB_ProbeAndSubmitTransferComplete (
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PGENUSB_TRANSFER   LocalTrans,
    IN USBD_STATUS        UrbStatus,
    IN ULONG              Length
    )
{ 
    PDEVICE_EXTENSION       deviceExtension;
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'PrbC', Irp, Length, UrbStatus);
    
    // Regardless of whether or not the transaction was successful, 
    // we need to free the MDL that points to the users transfer buffer.
    MmUnlockPages (LocalTrans->TransferMdl);
    IoFreeMdl (LocalTrans->TransferMdl);
    
    LocalTrans->UserCopy.UrbStatus = UrbStatus;
    LocalTrans->UserCopy.BufferLength = Length;

    //
    // since we are not in the caller's context any more 
    // we cannot just use LocalTrans->UserCopy.UserBuffer to copy the data
    // back.  We must instead use the system address, which should already
    // be all set up.
    //
    ASSERT (NULL != LocalTrans->SystemAddress);
    *LocalTrans->SystemAddress = LocalTrans->UserCopy;
     
    // Now free the user buffer containing the arguments.
    MmUnlockPages (LocalTrans->UserMdl);
    IoFreeMdl (LocalTrans->UserMdl);


    ExFreePool (LocalTrans);

    return Irp->IoStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\globals.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    GLOBALS.C

Abstract:

    This module's only purpose is to host global variables defined in usbhub.h.

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    2-2-96 : created

--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */

#define HOST_GLOBALS
#include "usbhub.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\ocrw.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    OCRW.C

Abstract:

    This source file contains the dispatch routines which handle
    opening, closing, reading, and writing to the device, i.e.:

    IRP_MJ_CREATE
    IRP_MJ_CLOSE
    IRP_MJ_READ
    IRP_MJ_WRITE

Environment:

    kernel mode

Revision History:

    Sept 01 : KenRay 

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include "genusb.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, GenUSB_Create)
#pragma alloc_text(PAGE, GenUSB_Close)
#pragma alloc_text(PAGE, GenUSB_Read)
#pragma alloc_text(PAGE, GenUSB_Write)
#endif

//******************************************************************************
//
// GenUSB_Create()
//
// Dispatch routine which handles IRP_MJ_CREATE
//
//******************************************************************************

NTSTATUS
GenUSB_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension;
    NTSTATUS           status;

    DBGPRINT(2, ("enter: GenUSB_Create\n"));
    DBGFBRK(DBGF_BRK_CREATE);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    LOGENTRY(deviceExtension, 'CREA', DeviceObject, Irp, 0);
    
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // While there are several readers of the IsStarted state, it is only
    // set at the end of GenUSB_StartDevice.
    if (!deviceExtension->IsStarted) 
    { 
        LOGENTRY(deviceExtension, 'IOns', DeviceObject, Irp, 0);
        status = STATUS_DEVICE_NOT_CONNECTED;
    } 
    else if (1 != InterlockedIncrement (&deviceExtension->OpenedCount))
    {
        InterlockedDecrement (&deviceExtension->OpenedCount);
        status = STATUS_SHARING_VIOLATION;
    }
    else 
    {
        status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
    }
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: GenUSB_Create\n"));
    LOGENTRY(deviceExtension, 'crea', 0, 0, 0);

    return status;
}


//******************************************************************************
//
// GenUSB_Close()
//
// Dispatch routine which handles IRP_MJ_CLOSE
//
//******************************************************************************

NTSTATUS
GenUSB_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension;

    //
    // Never check the remove lock, or started for close.
    //

    DBGPRINT(2, ("enter: GenUSB_Close\n"));
    DBGFBRK(DBGF_BRK_CLOSE);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'CLOS', DeviceObject, Irp, 0);
    
    GenUSB_DeselectConfiguration (deviceExtension, TRUE);
    
    InterlockedDecrement (&deviceExtension->OpenedCount);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: GenUSB_Close\n"));

    LOGENTRY(deviceExtension, 'clos', 0, 0, 0);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// GenUSB_ReadWrite()
//
// Dispatch routine which handles IRP_MJ_READ and IRP_MJ_WRITE
//
//******************************************************************************

NTSTATUS
GenUSB_ReadComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Unused,
    IN USBD_STATUS      UrbStatus,
    IN ULONG            Length
    )
{
    PDEVICE_EXTENSION       deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'RedC', Irp, Length, UrbStatus);

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    Irp->IoStatus.Information = Length;
    return Irp->IoStatus.Status;
}

NTSTATUS
GenUSB_Read (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpSp;

    DBGPRINT(2, ("enter: GenUSB_Read\n"));
    DBGFBRK(DBGF_BRK_READWRITE);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'R  ', DeviceObject, Irp, 0);
    
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // While there are several readers of the IsStarted state, it is only
    // set at the end of GenUSB_StartDevice.
    if (!deviceExtension->IsStarted) 
    { 
        LOGENTRY(deviceExtension, 'IOns', DeviceObject, Irp, 0);
        status = STATUS_DEVICE_NOT_CONNECTED;

        goto GenUSB_ReadReject;
    } 

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (0 != irpSp->Parameters.Read.ByteOffset.QuadPart)
    {
        status = STATUS_NOT_IMPLEMENTED;
        goto GenUSB_ReadReject;
    }

    //
    // After talking extensively with JD, he tells me that I do not need  
    // to queue requests for power downs or query stop.  If that is the 
    // case then even if the device power state isn't PowerDeviceD0 we 
    // can still allow trasfers.  This, of course, is a property of the 
    // brand new port driver that went into XP.
    //
    // if (DeviceExtension->DevicePowerState != PowerDeviceD0) 
    // {
    // }
    //
    
    //
    // BUGBUG if we ever implement IDLE, we need to turn the device
    // back on here.
    //

    return GenUSB_TransmitReceive (
               deviceExtension,
               Irp,
               deviceExtension->ReadInterface,
               deviceExtension->ReadPipe,
               USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK,
               NULL,
               Irp->MdlAddress,
               irpSp->Parameters.Read.Length,
               NULL,
               GenUSB_ReadComplete);


GenUSB_ReadReject:

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    DBGPRINT(2, ("exit: GenUSB_Read %08X\n", status));
    LOGENTRY(deviceExtension, 'r  ', status, 0, 0);

    return status;
}

NTSTATUS
GenUSB_WriteComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Unused,
    IN USBD_STATUS      UrbStatus,
    IN ULONG            Length
    )
{
    PDEVICE_EXTENSION       deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    LOGENTRY(deviceExtension, 'WrtC', Irp, Length, UrbStatus);

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    
    Irp->IoStatus.Information = Length;
    return Irp->IoStatus.Status;
}

NTSTATUS
GenUSB_Write (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpSp;

    DBGPRINT(2, ("enter: GenUSB_Write\n"));
    DBGFBRK(DBGF_BRK_READWRITE);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    LOGENTRY(deviceExtension, 'W  ', DeviceObject, Irp, 0);

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    // While there are several readers of the IsStarted state, it is only
    // set at the end of GenUSB_StartDevice.
    if (!deviceExtension->IsStarted) 
    { 
        LOGENTRY(deviceExtension, 'IOns', DeviceObject, Irp, 0);
        status = STATUS_DEVICE_NOT_CONNECTED;
        
        goto GenUSB_WriteReject;
    } 
    
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    if (0 != irpSp->Parameters.Write.ByteOffset.QuadPart)
    {
        status = STATUS_NOT_IMPLEMENTED;
        goto GenUSB_WriteReject;
    }
    
    //
    // After talking extensively with JD, he tells me that I do not need  
    // to queue requests for power downs or query stop.  If that is the 
    // case then even if the device power state isn't PowerDeviceD0 we 
    // can still allow trasfers.  This, of course, is a property of the 
    // brand new port driver that went into XP.
    //
    // if (DeviceExtension->DevicePowerState != PowerDeviceD0) 
    // {
    // }
    //
    
    //
    // BUGBUG if we ever implement IDLE, we need to turn the device
    // back on here.
    //

    return GenUSB_TransmitReceive (
               deviceExtension,
               Irp,
               deviceExtension->WriteInterface,
               deviceExtension->WritePipe,
               USBD_TRANSFER_DIRECTION_OUT,
               NULL,
               Irp->MdlAddress,
               irpSp->Parameters.Read.Length,
               NULL,
               GenUSB_WriteComplete);


GenUSB_WriteReject:
    
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    DBGPRINT(2, ("exit: GenUSB_Write %08X\n", status));
    LOGENTRY(deviceExtension, 'w  ', status, 0, 0);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\usb.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    USB.C

Abstract:

    This source file contains the functions for communicating with 
    the usb bus.

Environment:

    kernel mode

Revision History:

    Sep 2001 : Copied from USBMASS

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include "genusb.h"

//*****************************************************************************
// L O C A L    F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, GenUSB_GetDescriptor)
#pragma alloc_text(PAGE, GenUSB_GetDescriptors)
#pragma alloc_text(PAGE, GenUSB_GetStringDescriptors)
#pragma alloc_text(PAGE, GenUSB_VendorControlRequest)
#pragma alloc_text(PAGE, GenUSB_ResetPipe)
#endif




//******************************************************************************
//
// GenUSB_GetDescriptors()
//
// This routine is called at START_DEVICE time for the FDO to retrieve the
// Device and Configurations descriptors from the device and store them in
// the device extension.
//
//******************************************************************************

NTSTATUS
GenUSB_GetDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PUCHAR              descriptor;
    ULONG               descriptorLength;
    NTSTATUS            status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_GetDescriptors\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    descriptor = NULL;

    LOGENTRY(deviceExtension, 'GDSC', DeviceObject, 0, 0);

    //
    // Get Device Descriptor
    //
    status = GenUSB_GetDescriptor(DeviceObject,
                                  USB_RECIPIENT_DEVICE,
                                  USB_DEVICE_DESCRIPTOR_TYPE,
                                  0,  // Index
                                  0,  // LanguageId
                                  2,  // RetryCount
                                  sizeof(USB_DEVICE_DESCRIPTOR),
                                  &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Device Descriptor failed\n"));
        goto GenUSB_GetDescriptorsDone;
    }

    ASSERT(NULL == deviceExtension->DeviceDescriptor);
    deviceExtension->DeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)descriptor;
    descriptor = NULL;

    //
    // Get Configuration Descriptor (just the Configuration Descriptor)
    //
    status = GenUSB_GetDescriptor(DeviceObject,
                                  USB_RECIPIENT_DEVICE,
                                  USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                  0,  // Index
                                  0,  // LanguageId
                                  2,  // RetryCount
                                  sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                  &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Configuration Descriptor failed (1)\n"));
        goto GenUSB_GetDescriptorsDone;
    }

    descriptorLength = ((PUSB_CONFIGURATION_DESCRIPTOR)descriptor)->wTotalLength;

    ExFreePool(descriptor);
    descriptor = NULL;

    if (descriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        status = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Configuration Descriptor failed (2)\n"));
        goto GenUSB_GetDescriptorsDone;
    }

    //
    // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
    //
    status = GenUSB_GetDescriptor(DeviceObject,
                                  USB_RECIPIENT_DEVICE,
                                  USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                  0,  // Index
                                  0,  // LanguageId
                                  2,  // RetryCount
                                  descriptorLength,
                                  &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Configuration Descriptor failed (3)\n"));
        goto GenUSB_GetDescriptorsDone;
    }

    ASSERT(NULL == deviceExtension->ConfigurationDescriptor);
    deviceExtension->ConfigurationDescriptor = 
        (PUSB_CONFIGURATION_DESCRIPTOR)descriptor;

    //
    // Get the Serial Number String Descriptor, if there is one
    //
    if (deviceExtension->DeviceDescriptor->iSerialNumber)
    {
        GenUSB_GetStringDescriptors(DeviceObject);
    }

#if DBG
    DumpDeviceDesc(deviceExtension->DeviceDescriptor);
    DumpConfigDesc(deviceExtension->ConfigurationDescriptor);
#endif

GenUSB_GetDescriptorsDone:

    DBGPRINT(2, ("exit:  GenUSB_GetDescriptors %08X\n", status));

    LOGENTRY(deviceExtension,
             'gdsc', 
             status, 
             deviceExtension->DeviceDescriptor,
             deviceExtension->ConfigurationDescriptor);

    return status;
}

//******************************************************************************
//
// GenUSB_GetDescriptor()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
GenUSB_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Function,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    )
{
    PURB        urb;
    NTSTATUS    status;
    BOOLEAN     descriptorAllocated = FALSE;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_GetDescriptor\n"));

    if (NULL == *Descriptor)
    {
        // Allocate a descriptor buffer
        *Descriptor = ExAllocatePool(NonPagedPool, DescriptorLength);
        descriptorAllocated = TRUE;
    }

    if (NULL != *Descriptor)
    {
        // Allocate a URB for the Get Descriptor request
        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

        if (NULL != urb)
        {
            do
            {
                // Initialize the URB
                urb->UrbHeader.Function = Function;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);
                urb->UrbControlDescriptorRequest.TransferBufferLength = DescriptorLength;
                urb->UrbControlDescriptorRequest.TransferBuffer = *Descriptor;
                urb->UrbControlDescriptorRequest.TransferBufferMDL = NULL;
                urb->UrbControlDescriptorRequest.UrbLink = NULL;
                urb->UrbControlDescriptorRequest.DescriptorType = DescriptorType;
                urb->UrbControlDescriptorRequest.Index = Index;
                urb->UrbControlDescriptorRequest.LanguageId = LanguageId;

                // Send the URB down the stack
                status = GenUSB_SyncSendUsbRequest(DeviceObject, urb);

                if (NT_SUCCESS(status))
                {
                    // No error, make sure the length and type are correct
                    if ((DescriptorLength ==
                         urb->UrbControlDescriptorRequest.TransferBufferLength) &&
                        (DescriptorType ==
                         ((PUSB_COMMON_DESCRIPTOR)*Descriptor)->bDescriptorType))
                    {
                        // The length and type are correct, all done
                        break;
                    }
                    else
                    {
                        // No error, but the length or type is incorrect
                        status = STATUS_DEVICE_DATA_ERROR;
                    }
                }

            } while (RetryCount-- > 0);

            ExFreePool(urb);
        }
        else
        {
            // Failed to allocate the URB
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Failed to allocate the descriptor buffer
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status))
    {
        if ((*Descriptor != NULL) && descriptorAllocated)
        {
            ExFreePool(*Descriptor);
            *Descriptor = NULL;
        }
    }

    DBGPRINT(2, ("exit:  GenUSB_GetDescriptor %08X\n", status));

    return status;
}

//******************************************************************************
//
// GenUSB_GetStringDescriptors()
//
// This routine is called at START_DEVICE time for the FDO to retrieve the
// Serial Number string descriptor from the device and store it in
// the device extension.
//
//******************************************************************************

GenUSB_GetStringDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PUCHAR              descriptor;
    ULONG               descriptorLength;
    ULONG               i, numIds;
    NTSTATUS            status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_GetStringDescriptors\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    descriptor = NULL;

    LOGENTRY(deviceExtension, 'GSDC', DeviceObject, 0, 0);

    // Get the list of Language IDs (descriptor header only)
    status = GenUSB_GetDescriptor(DeviceObject,
                                  USB_RECIPIENT_DEVICE,
                                  USB_STRING_DESCRIPTOR_TYPE,
                                  0,  // Index
                                  0,  // LanguageId
                                  2,  // RetryCount
                                  sizeof(USB_COMMON_DESCRIPTOR),
                                  &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Language IDs failed (1) %08X\n", status));
        goto GenUSB_GetStringDescriptorsDone;
    }

    descriptorLength = ((PUSB_COMMON_DESCRIPTOR)descriptor)->bLength;
    
    ExFreePool(descriptor);
    descriptor = NULL;

    if ((descriptorLength < sizeof(USB_COMMON_DESCRIPTOR) + sizeof(USHORT)) ||
        (descriptorLength & 1))
    {
        status = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Language IDs failed (2) %d\n", descriptorLength));
        goto GenUSB_GetStringDescriptorsDone;
    }

    // Get the list of Language IDs (complete descriptor)
    status = GenUSB_GetDescriptor(DeviceObject,
                                   USB_RECIPIENT_DEVICE,
                                   USB_STRING_DESCRIPTOR_TYPE,
                                   0,  // Index
                                   0,  // LanguageId
                                   2,  // RetryCount
                                   descriptorLength,
                                   &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Language IDs failed (3) %08X\n", status));
        goto GenUSB_GetStringDescriptorsDone;
    }

    // Search the list of LanguageIDs for US-English (0x0409).  If we find
    // it in the list, that's the LanguageID we'll use.  Else just default
    // to the first LanguageID in the list.

    numIds = (descriptorLength - sizeof(USB_COMMON_DESCRIPTOR)) / sizeof(USHORT);

    deviceExtension->LanguageId = ((PUSHORT)descriptor)[1];

    for (i = 2; i <= numIds; i++)
    {
        if (((PUSHORT)descriptor)[i] == 0x0409)
        {
            deviceExtension->LanguageId = 0x0409;
            break;
        }
    }
    ExFreePool(descriptor);
    descriptor = NULL;

    //
    // Get the Serial Number (descriptor header only)
    //
    status = GenUSB_GetDescriptor(DeviceObject,
                                  USB_RECIPIENT_DEVICE,
                                  USB_STRING_DESCRIPTOR_TYPE,
                                  deviceExtension->DeviceDescriptor->iSerialNumber,
                                  deviceExtension->LanguageId,
                                  2,  // RetryCount
                                  sizeof(USB_COMMON_DESCRIPTOR),
                                  &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Serial Number failed (1) %08X\n", status));
        goto GenUSB_GetStringDescriptorsDone;
    }

    descriptorLength = ((PUSB_COMMON_DESCRIPTOR)descriptor)->bLength;

    ExFreePool(descriptor);
    descriptor = NULL;

    if ((descriptorLength < sizeof(USB_COMMON_DESCRIPTOR) + sizeof(USHORT)) ||
        (descriptorLength & 1))
    {
        status = STATUS_DEVICE_DATA_ERROR;
        DBGPRINT(1, ("Get Serial Number failed (2) %d\n", descriptorLength));
        goto GenUSB_GetStringDescriptorsDone;
    }

    //
    // Get the Serial Number (complete descriptor)
    //
    status = GenUSB_GetDescriptor(DeviceObject,
                                  USB_RECIPIENT_DEVICE,
                                  USB_STRING_DESCRIPTOR_TYPE,
                                  deviceExtension->DeviceDescriptor->iSerialNumber,
                                  deviceExtension->LanguageId,
                                  2,  // RetryCount
                                  descriptorLength,
                                  &descriptor);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(1, ("Get Serial Number failed (3) %08X\n", status));
        goto GenUSB_GetStringDescriptorsDone;
    }

    ASSERT(NULL == deviceExtension->SerialNumber);
    deviceExtension->SerialNumber = (PUSB_STRING_DESCRIPTOR)descriptor;

GenUSB_GetStringDescriptorsDone:

    DBGPRINT(2, ("exit:  GenUSB_GetStringDescriptors %08X %08X\n",
                 status, deviceExtension->SerialNumber));

    LOGENTRY(deviceExtension, 
             'gdsc', 
             status, 
             deviceExtension->LanguageId, 
             deviceExtension->SerialNumber);

    return status;
}

NTSTATUS
GenUSB_VendorControlRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            RequestType,
    IN UCHAR            Request,
    IN USHORT           Value,
    IN USHORT           Index,
    IN USHORT           Length,
    IN ULONG            RetryCount,
    OUT PULONG          UrbStatus,
    OUT PUSHORT         ResultLength,
    OUT PUCHAR         *Descriptor
    )
{
    PURB        urb;
    NTSTATUS    status;
    BOOLEAN     descriptorAllocated = FALSE;

    PAGED_CODE();

    DBGPRINT(2, ("enter: GenUSB_GetDescriptor\n"));

    if (NULL == *Descriptor) 
    {
        // Allocate a descriptor buffer
        *Descriptor = ExAllocatePool(NonPagedPool, Length);
        descriptorAllocated = TRUE;
    }

    if (NULL != *Descriptor)
    {
        // Allocate a URB for the Get Descriptor request
        urb = ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_TRANSFER));

        if (NULL != urb)
        {
            do
            {
                // Initialize the URB
                urb->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_TRANSFER);
                urb->UrbHeader.Status = USBD_STATUS_SUCCESS;

                urb->UrbControlTransfer.PipeHandle = NULL;
                urb->UrbControlTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN
                                              | USBD_DEFAULT_PIPE_TRANSFER
                                              | USBD_SHORT_TRANSFER_OK;

                urb->UrbControlTransfer.TransferBufferLength = Length;
                urb->UrbControlTransfer.TransferBuffer = *Descriptor;
                urb->UrbControlTransfer.TransferBufferMDL = NULL;
                urb->UrbControlTransfer.UrbLink = NULL;

                urb->UrbControlTransfer.SetupPacket [0] = RequestType;
                urb->UrbControlTransfer.SetupPacket [1] = Request;
                ((WCHAR *) urb->UrbControlTransfer.SetupPacket) [1] = Value;
                ((WCHAR *) urb->UrbControlTransfer.SetupPacket) [2] = Index;
                ((WCHAR *) urb->UrbControlTransfer.SetupPacket) [3] = Length;


                // Send the URB down the stack
                status = GenUSB_SyncSendUsbRequest(DeviceObject, urb);

                if (NT_SUCCESS(status))
                {
                    break;
                }

            } while (RetryCount-- > 0);
            
            *UrbStatus = urb->UrbHeader.Status;
            *ResultLength = (USHORT) urb->UrbControlTransfer.TransferBufferLength;
            ExFreePool(urb);
        }
        else
        {
            // Failed to allocate the URB
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Failed to allocate the descriptor buffer
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status))
    {
        if ((*Descriptor != NULL) && descriptorAllocated)
        {
            ExFreePool(*Descriptor);
            *Descriptor = NULL;
        }
    }

    DBGPRINT(2, ("exit:  GenUSB_GetDescriptor %08X\n", status));

    return status;
}

void blah()
{
    return;
}

VOID
GenUSB_ParseConfigurationDescriptors(
    IN  PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN  ULONG                         NumberInterfaces,
    IN  USB_INTERFACE_DESCRIPTOR      DesiredArray[],
    OUT USB_INTERFACE_DESCRIPTOR      FoundArray[],
    OUT PUCHAR                        InterfacesFound,
    OUT PUSBD_INTERFACE_LIST_ENTRY    DescriptorArray
    )
/*++

Routine Description:

    Parses a standard USB configuration descriptor (returned from a device)
    for an array of specific interfaces, alternate setting class subclass or 
    protocol codes

Arguments:

Return Value:

    NT status code.

--*/
{
    ULONG i;
    ULONG foo;
    PUSB_INTERFACE_DESCRIPTOR inter;

    PAGED_CODE();
    ASSERT (NULL != InterfacesFound);
    ASSERT (NULL != DescriptorArray);

    *InterfacesFound = 0;  // none found yet.

    ASSERT(ConfigurationDescriptor->bDescriptorType
        == USB_CONFIGURATION_DESCRIPTOR_TYPE);
    //
    // we walk the table of desired interfaces descriptors looking for an
    // looking for all of them in the configuration descriptor
    //

    //
    // here we use ParseConfigurationDescriptorEx, which walks through the
    // entire configuration descriptor looking for matches.  While this is 
    // more or less order n^2 things are not much better if done by hand
    // so just use the given routine.
    //
    for (i = 0; i < NumberInterfaces; i++)
    {
        inter = USBD_ParseConfigurationDescriptorEx (
                           ConfigurationDescriptor,
                           ConfigurationDescriptor,
                           (CHAR) DesiredArray[i].bInterfaceNumber,
                           (CHAR) DesiredArray[i].bAlternateSetting,
                           (CHAR) DesiredArray[i].bInterfaceClass,
                           (CHAR) DesiredArray[i].bInterfaceSubClass,
                           (CHAR) DesiredArray[i].bInterfaceProtocol);

        if (NULL != inter)
        {
            DescriptorArray[*InterfacesFound].InterfaceDescriptor = inter;
            (*InterfacesFound)++;
            FoundArray[i] = *inter;
        }
    }
}


//******************************************************************************
//
// GenUSB_SelectConfiguration()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
GenUSB_SelectConfiguration (
    IN  PDEVICE_EXTENSION          DeviceExtension,
    IN  ULONG                      NumberInterfaces,
    IN  PUSB_INTERFACE_DESCRIPTOR  DesiredArray,
    OUT PUSB_INTERFACE_DESCRIPTOR  FoundArray
    )
{
    PGENUSB_INTERFACE               inter;
    // Apparently the compiler will not allow a local variable of the name
    // interface for some probably valid but frustrating reason.
    PURB                            urb;
    NTSTATUS                        status;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;
    PUSBD_INTERFACE_LIST_ENTRY      interfaceList;
    ULONG                           i,j;
    ULONG                           size;
    UCHAR                           interfacesFound;
    BOOLEAN                         directionIn;
    KIRQL                           irql;
   
    ExAcquireFastMutex (&DeviceExtension->ConfigMutex);

    DBGPRINT(2, ("enter: GenUSB_SelectConfiguration\n"));
    LOGENTRY(DeviceExtension, 'SCON', DeviceExtension->Self, 0, 0);
    
    urb = 0;
    interfaceList = 0;

    //
    // We shouldn't have a currently selected interface.
    // You must unconfigure the device before configuring it again.
    //    
    if (NULL != DeviceExtension->ConfigurationHandle) 
    {
        status = STATUS_INVALID_PARAMETER;
        goto GenUSB_SelectConfigurationReject;
    }
    ASSERT (NULL == DeviceExtension->Interface);
    ASSERT (0 == DeviceExtension->InterfacesFound);

    configurationDescriptor = DeviceExtension->ConfigurationDescriptor;
    // Allocate storage for an Inteface List to use as an input/output
    // parameter to USBD_CreateConfigurationRequestEx().
    //
    interfaceList = 
        ExAllocatePool(PagedPool,
                       sizeof(USBD_INTERFACE_LIST_ENTRY) * (NumberInterfaces + 1));

    if (NULL == interfaceList)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GenUSB_SelectConfigurationReject;
    }
    
    // NB we are holding a Fast Mutex whist calling this function
    GenUSB_ParseConfigurationDescriptors(configurationDescriptor,
                                         NumberInterfaces,
                                         DesiredArray,
                                         FoundArray,
                                         &interfacesFound,
                                         interfaceList);

    if (interfacesFound < NumberInterfaces)
    {
        // We couldn't select all of the interfaces.  
        // For now, allow that.
        // status = STATUS_INVALID_PARAMETER;
        // goto GenUSB_SelectConfigurationReject;
        ;
    }

    ASSERT (interfacesFound <= NumberInterfaces);

    // Terminate the list.
    interfaceList[interfacesFound].InterfaceDescriptor = NULL;

    // Create a SELECT_CONFIGURATION URB, turning the Interface
    // Descriptors in the interfaceList into USBD_INTERFACE_INFORMATION
    // structures in the URB.
    //

    // NB we are holding a Fast Mutex whist calling this function
    urb = USBD_CreateConfigurationRequestEx(
                       configurationDescriptor,
                       interfaceList);

    if (NULL == urb)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GenUSB_SelectConfigurationReject;
    }
    
    // Now issue the USB request to set the Configuration
    // NB we are holding a Fast Mutex whist calling this function
    status = GenUSB_SyncSendUsbRequest(DeviceExtension->Self, urb);

    if (!NT_SUCCESS(status))
    {
        goto GenUSB_SelectConfigurationReject;
    }
    
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &irql);
    {
        DeviceExtension->InterfacesFound = interfacesFound;
        DeviceExtension->TotalNumberOfPipes = 0;

        // Save the configuration handle for this device in
        // the Device Extension.
        DeviceExtension->ConfigurationHandle =
            urb->UrbSelectConfiguration.ConfigurationHandle;

        // 
        // Now for each interface in the list...
        // Save a copy of the interface information returned
        // by the SELECT_CONFIGURATION request in the Device
        // Extension.  This gives us a list of PIPE_INFORMATION
        // structures for each pipe opened in this configuration.
        //
        size = interfacesFound * sizeof (PVOID);
        DeviceExtension->Interface = ExAllocatePool (NonPagedPool, size);

        if (NULL == DeviceExtension->Interface)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } 
        else 
        {
            RtlZeroMemory (DeviceExtension->Interface, size);

            interfaceInfo = &urb->UrbSelectConfiguration.Interface;
            for (i=0; i < interfacesFound; i++)
            {
                size = sizeof (GENUSB_INTERFACE)
                     + (interfaceInfo->NumberOfPipes * sizeof(GENUSB_PIPE_INFO));

                inter = 
                    DeviceExtension->Interface[i] = 
                        ExAllocatePool (NonPagedPool, size);

                if (inter)
                { 
                    RtlZeroMemory (inter, size);

                    inter->InterfaceNumber = interfaceInfo->InterfaceNumber;
                    inter->CurrentAlternate = interfaceInfo->AlternateSetting;
                    inter->Handle = interfaceInfo->InterfaceHandle;
                    inter->NumberOfPipes = (UCHAR)interfaceInfo->NumberOfPipes;

                    DeviceExtension->TotalNumberOfPipes += inter->NumberOfPipes;

                    for (j=0; j < inter->NumberOfPipes; j++)
                    {
                        inter->Pipes[j].Info = interfaceInfo->Pipes[j];

                        // Set the default timeout for this device to be zero.
                        // (structure already initialized to zero.)
                        //
                        // inter->Pipes[j].Properties.DefaultTimeout = 0;
                        // inter->Pipes[j].CurrentTimeout = 0;

                        // set the outstanding number of transactions for this
                        // pipe to be 0.
                        //
                        // inter->Pipes[j].OutandingIO = 0;

                        directionIn = 
                            USBD_PIPE_DIRECTION_IN (&inter->Pipes[j].Info);

                        if (directionIn)
                        {
                            //
                            // by default we always truncate reads requests from
                            // the device. 
                            //
                            inter->Pipes[j].Properties.DirectionIn = TRUE;
                            inter->Pipes[j].Properties.NoTruncateToMaxPacket = FALSE;
                        }
                    }
                }
                else
                {
                    // Could not allocate a copy of interface information
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                //
                // find the next interfaceInfo
                //
                interfaceInfo = (PUSBD_INTERFACE_INFORMATION)
                                ((PUCHAR) interfaceInfo + interfaceInfo->Length);
            }
        }

        //
        // Regardless of whether or not we've been successful...
        // We've just invalidated the pipe table so blow away the 
        // read and write values.
        //
        DeviceExtension->ReadInterface = -1;
        DeviceExtension->ReadPipe = -1;
        DeviceExtension->WriteInterface = -1;
        DeviceExtension->WritePipe = -1;
    }
    KeReleaseSpinLock (&DeviceExtension->SpinLock, irql);

    if (!NT_SUCCESS (status))
    {
        goto GenUSB_SelectConfigurationReject;
    }

    IoInitializeRemoveLock (&DeviceExtension->ConfigurationRemoveLock, 
                            POOL_TAG,
                            0,
                            0);

    IoStartTimer (DeviceExtension->Self);

    ExFreePool(urb);
    ExFreePool(interfaceList);

    DBGPRINT(2, ("exit:  GenUSB_SelectConfiguration %08X\n", status));
    LOGENTRY(DeviceExtension, 'scon', 0, 0, status);

    ExReleaseFastMutex (&DeviceExtension->ConfigMutex);
    return status;


GenUSB_SelectConfigurationReject:

    if (interfaceList)
    {
        ExFreePool (interfaceList);
    }
    if (urb)
    {
        ExFreePool (urb);
    }

    GenUSB_FreeInterfaceTable (DeviceExtension);

    LOGENTRY(DeviceExtension, 'scon', 0, 0, status);

    ExReleaseFastMutex (&DeviceExtension->ConfigMutex);
    return status;
}

VOID 
GenUSB_FreeInterfaceTable (
    PDEVICE_EXTENSION DeviceExtension
    )
{ 
    KIRQL  irql;
    ULONG  i;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &irql);
    {
        if (DeviceExtension->Interface)
        {
            for (i = 0; i < DeviceExtension->InterfacesFound; i++)
            {
                if (DeviceExtension->Interface[i])
                {
                    ExFreePool (DeviceExtension->Interface[i]);
                }
            }
    
            ExFreePool (DeviceExtension->Interface);
            DeviceExtension->Interface = 0;
        }
        DeviceExtension->InterfacesFound = 0;
        DeviceExtension->ConfigurationHandle = NULL; // Freed automatically by USB
    }
    KeReleaseSpinLock (&DeviceExtension->SpinLock, irql);
}


//******************************************************************************
//
// GenUSB_UnConfigure()
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
GenUSB_DeselectConfiguration (
    PDEVICE_EXTENSION  DeviceExtension,
    BOOLEAN            SendUrb
    )
{
    NTSTATUS  status;
    PURB      urb;
    ULONG     ulSize;

    ExAcquireFastMutex (&DeviceExtension->ConfigMutex);
    
    DBGPRINT(2, ("enter: GenUSB_UnConfigure\n"));
    LOGENTRY(DeviceExtension, 'UCON', DeviceExtension->Self, 0, 0);

    if (NULL == DeviceExtension->ConfigurationHandle)
    {
        status = STATUS_UNSUCCESSFUL;
        LOGENTRY(DeviceExtension, 'ucon', 1, 0, status);
        ExReleaseFastMutex (&DeviceExtension->ConfigMutex);
        return status;
    }

    status = STATUS_SUCCESS;

    IoStopTimer (DeviceExtension->Self);

    // Allocate a URB for the SELECT_CONFIGURATION request.  As we are
    // unconfiguring the device, the request needs no pipe and interface
    // information structures.
    if (SendUrb)
    {
        ulSize = sizeof(struct _URB_SELECT_CONFIGURATION);
        urb = ExAllocatePool (NonPagedPool, ulSize);
        if (urb)
        {
            // Initialize the URB.  A NULL Configuration Descriptor indicates
            // that the device should be unconfigured.
            //
            UsbBuildSelectConfigurationRequest(urb, (USHORT)ulSize, NULL);

            // Now issue the USB request to set the Configuration
            //
            status = GenUSB_SyncSendUsbRequest(DeviceExtension->Self, urb);
            ASSERT ((STATUS_SUCCESS == status) ||
                    (STATUS_DEVICE_NOT_CONNECTED == status) ||
                    (STATUS_DEVICE_POWERED_OFF == status));

            ExFreePool (urb);
        }
        else
        {
            // Could not allocate the URB.
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } 

    //
    // We need to wait for all outstanding IO to finish before 
    // freeing the pipe table
    //
    // In order to use ReleaseAndWait, we need to first take the lock another 
    // time.  
    //
    status = IoAcquireRemoveLock (&DeviceExtension->ConfigurationRemoveLock, 
                                  DeviceExtension);

    ASSERT (STATUS_SUCCESS == status);
    
    IoReleaseRemoveLockAndWait (&DeviceExtension->ConfigurationRemoveLock, 
                                DeviceExtension);
    
    GenUSB_FreeInterfaceTable (DeviceExtension);

    //
    // We've just invalidated the pipe table so blow away the 
    // read and write values.
    //
    DeviceExtension->ReadInterface = -1;
    DeviceExtension->ReadPipe = -1;
    DeviceExtension->WriteInterface = -1;
    DeviceExtension->WritePipe = -1;

    DBGPRINT(2, ("exit:  GenUSB_UnConfigure %08X\n", status));
    LOGENTRY(DeviceExtension, 'ucon', 0, 0, status);
    
    ExReleaseFastMutex (&DeviceExtension->ConfigMutex);

    return status;
}



NTSTATUS
GenUSB_GetSetPipe (
    IN  PDEVICE_EXTENSION         DeviceExtension,
    IN  PUCHAR                    InterfaceIndex, // Optional
    IN  PUCHAR                    InterfaceNumber, // Optional
    IN  PUCHAR                    PipeIndex, // Optional
    IN  PUCHAR                    EndpointAddress, // Optional
    IN  PGENUSB_PIPE_PROPERTIES   SetPipeProperties, // Optional
    OUT PGENUSB_PIPE_INFORMATION  PipeInfo, // Optional
    OUT PGENUSB_PIPE_PROPERTIES   GetPipeProperties, // Optional
    OUT USBD_PIPE_HANDLE        * UsbdPipeHandle // Optional
    )
{
    KIRQL    irql;
    UCHAR    i;
    NTSTATUS status;
    BOOLEAN  directionIn;
    UCHAR    trueInterIndex;
    
    PGENUSB_INTERFACE  genusbInterface;
    PGENUSB_PIPE_INFO  pipe; 

    status = IoAcquireRemoveLock (&DeviceExtension->ConfigurationRemoveLock, 
                                  PipeInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = STATUS_INVALID_PARAMETER;

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &irql);
    {
        if (NULL != InterfaceNumber)
        {
            // We need to walk the list of interfaces looking for this 
            // interface number.
            //
            // set trueInterIndex to an invalid value to start so that if it's
            // not found, we will fall through the error path.
            //
            trueInterIndex = DeviceExtension->InterfacesFound;

            for (i=0; i<DeviceExtension->InterfacesFound; i++)
            {
                genusbInterface = DeviceExtension->Interface[i];
                if (genusbInterface->InterfaceNumber == *InterfaceNumber)
                {
                    trueInterIndex = i;
                    break;
                }
            }
        }
        else
        {
            ASSERT (NULL != InterfaceIndex);
            trueInterIndex = *InterfaceIndex;
        }

        if (trueInterIndex < DeviceExtension->InterfacesFound)
        {
            genusbInterface = DeviceExtension->Interface[trueInterIndex];

            //
            // Find the Pipe in question using either the PipeIndex
            // or the Endpoint Address.
            //
            pipe = NULL;
            
            if (NULL != PipeIndex) 
            { 
                ASSERT (0 == EndpointAddress);
                if (*PipeIndex < genusbInterface->NumberOfPipes)
                { 
                    pipe = &genusbInterface->Pipes[*PipeIndex];
                }
            } 
            else 
            {
                for (i=0; i < genusbInterface->NumberOfPipes; i++)
                {
                    if (genusbInterface->Pipes[i].Info.EndpointAddress == 
                        *EndpointAddress)
                    {
                        // *PipeInfo = genusbInterface->Pipes[i].Info;
                        pipe = &genusbInterface->Pipes[i]; 
                        break;
                    }
                }
            }
            
            if (NULL != pipe)
            {
                // 
                // Now that we have the Pipe, retrieve and set optional info
                // 
                if (PipeInfo)
                { 
                    // *PipeInfo = pipe->Info;
                    PipeInfo->MaximumPacketSize = pipe->Info.MaximumPacketSize;
                    PipeInfo->EndpointAddress = pipe->Info.EndpointAddress;
                    PipeInfo->Interval = pipe->Info.Interval;
                    PipeInfo->PipeType = pipe->Info.PipeType;
                    PipeInfo->MaximumTransferSize = pipe->Info.MaximumTransferSize;
                    PipeInfo->PipeFlags = pipe->Info.PipeFlags;
                    
                    ((PGENUSB_PIPE_HANDLE)&PipeInfo->PipeHandle)->InterfaceIndex 
                        = trueInterIndex;
                    ((PGENUSB_PIPE_HANDLE)&PipeInfo->PipeHandle)->PipeIndex = i;
                    ((PGENUSB_PIPE_HANDLE)&PipeInfo->PipeHandle)->Signature 
                        = CONFIGURATION_CHECK_BITS (DeviceExtension);
                    
                    status = STATUS_SUCCESS;
                }
                if (SetPipeProperties)
                {

                    C_ASSERT (RTL_FIELD_SIZE (GENUSB_PIPE_PROPERTIES, ReservedFields) +
                              FIELD_OFFSET (GENUSB_PIPE_PROPERTIES, ReservedFields) ==
                              sizeof (GENUSB_PIPE_PROPERTIES));
                    
                    // ensure that this is a valid set request.
                    // the check bits must be present that were set when the 
                    // caller did a get, and the unused fields must be zero.
                    if (!VERIFY_PIPE_PROPERTIES_HANDLE (SetPipeProperties, pipe))
                    {
                        ; // status is already set.
                    }
                    else if (RtlEqualMemory (pipe->Properties.ReservedFields,
                                             SetPipeProperties->ReservedFields,
                                             RTL_FIELD_SIZE (GENUSB_PIPE_PROPERTIES, 
                                                             ReservedFields)))
                    {
                        // This field is not settable
                        directionIn = pipe->Properties.DirectionIn;

                        pipe->Properties = *SetPipeProperties;
                        // the timeout must be greater than one so fix that here.
                        if (1 == pipe->Properties.Timeout)
                        {
                            pipe->Properties.Timeout++;
                        }

                        pipe->Properties.DirectionIn = directionIn;
                        
                        status = STATUS_SUCCESS;
                    }
                }
                if (GetPipeProperties)
                {
                    *GetPipeProperties = pipe->Properties;
                    // set the checkbits before returning to the user
                    GetPipeProperties->PipePropertyHandle = 
                        PIPE_PROPERTIES_CHECK_BITS (pipe);
                    
                    status = STATUS_SUCCESS;
                }
                if (UsbdPipeHandle)
                {
                    *UsbdPipeHandle = pipe->Info.PipeHandle;
                    status = STATUS_SUCCESS;
                }
            }
        }
    }
    KeReleaseSpinLock (&DeviceExtension->SpinLock, irql);

    IoReleaseRemoveLock (&DeviceExtension->ConfigurationRemoveLock, PipeInfo);

    return status;
}

NTSTATUS
GenUSB_SetReadWritePipes (
    IN  PDEVICE_EXTENSION    DeviceExtension,
    IN  PGENUSB_PIPE_HANDLE  ReadPipe,
    IN  PGENUSB_PIPE_HANDLE  WritePipe
    )
{
    NTSTATUS          status;
    KIRQL             irql;
    PGENUSB_INTERFACE inter;
    BOOLEAN           isReadPipe;
    BOOLEAN           isWritePipe;

    PUSBD_PIPE_INFORMATION pipeInfo;

    isReadPipe = isWritePipe = TRUE;

    status = IoAcquireRemoveLock (&DeviceExtension->ConfigurationRemoveLock, 
                                  GenUSB_SetReadWritePipes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if ((0 == ReadPipe->Signature) && 
        (0 == ReadPipe->InterfaceIndex) &&
        (0 == ReadPipe->PipeIndex))
    {
        isReadPipe = FALSE;
    }
    else if (! VERIFY_PIPE_HANDLE_SIG (ReadPipe, DeviceExtension))
    { 
        status = STATUS_INVALID_PARAMETER;
    }

    if ((0 == WritePipe->Signature) && 
        (0 == WritePipe->InterfaceIndex) &&
        (0 == WritePipe->PipeIndex))
    {
        isWritePipe = FALSE;
    }
    else if (! VERIFY_PIPE_HANDLE_SIG (WritePipe, DeviceExtension))
    { 
        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS (status))
    {
        KeAcquireSpinLock (&DeviceExtension->SpinLock, &irql);
        //
        // Verify that the given values for read and write pipes are 
        // within range and then set them.
        //
        if (isReadPipe)
        { 
            if (ReadPipe->InterfaceIndex < DeviceExtension->InterfacesFound)
            {
                inter = DeviceExtension->Interface[ReadPipe->InterfaceIndex];

                if (ReadPipe->PipeIndex < inter->NumberOfPipes)
                {
                    // ok the ranges are now valid, test to make sure that 
                    // we are configuring for pipes in the correct direction
                    // and for the correct endpoint type
                    //
                    // Right now we only support Bulk and Interrupt.
                    pipeInfo = &inter->Pipes[ReadPipe->PipeIndex].Info;
                    if (   (USBD_PIPE_DIRECTION_IN (pipeInfo))
                        && (    (UsbdPipeTypeBulk == pipeInfo->PipeType)
                             || (UsbdPipeTypeInterrupt == pipeInfo->PipeType)))
                    {
                        DeviceExtension->ReadInterface = ReadPipe->InterfaceIndex;
                        DeviceExtension->ReadPipe = ReadPipe->PipeIndex;
                        status = STATUS_SUCCESS;
                    }
                }
            }
        }
        if (isWritePipe) 
        {
            if (WritePipe->InterfaceIndex < DeviceExtension->InterfacesFound)
            {
                inter = DeviceExtension->Interface[WritePipe->InterfaceIndex];

                if (WritePipe->PipeIndex < inter->NumberOfPipes)
                {
                    // ok the ranges are now valid, test to make sure that 
                    // we are configuring for pipes in the correct direction
                    // and for the correct endpoint type
                    //
                    // Right now we only support Bulk and Interrupt.
                    pipeInfo = &inter->Pipes[WritePipe->PipeIndex].Info;
                    if (   (!USBD_PIPE_DIRECTION_IN (pipeInfo))
                        && (    (UsbdPipeTypeBulk == pipeInfo->PipeType)
                             || (UsbdPipeTypeInterrupt == pipeInfo->PipeType)))
                    {
                        DeviceExtension->WriteInterface = WritePipe->InterfaceIndex;
                        DeviceExtension->WritePipe = WritePipe->PipeIndex;
                        status = STATUS_SUCCESS;
                    }
                }
            }
        }
        KeReleaseSpinLock (&DeviceExtension->SpinLock, irql);
    }

    IoReleaseRemoveLock (&DeviceExtension->ConfigurationRemoveLock, 
                         GenUSB_SetReadWritePipes);
    
    return status;
}

NTSTATUS
GenUSB_TransmitReceiveComplete (
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PGENUSB_TRANS_RECV Trc
    )
{
    PVOID             context; 
    USBD_STATUS       urbStatus;
    ULONG             length;
    PDEVICE_EXTENSION deviceExtension;
    PGENUSB_PIPE_INFO pipe;

    PGENUSB_COMPLETION_ROUTINE complete;

    ASSERT (NULL != Trc);

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    complete = Trc->CompletionRoutine;
    context = Trc->Context;
    urbStatus = Trc->TransUrb.Hdr.Status;
    length = Trc->TransUrb.TransferBufferLength;
    pipe = Trc->Pipe;

    LOGENTRY(deviceExtension, 'TR_C', Irp, urbStatus, Irp->IoStatus.Status);

// 
//  JD has convinced me that auto reset is not something we should
//  do for the vendors, since there are so many different cases that
//  require special handling of the data.  They will need to do a reset 
//  themselves explicitely.
//
//    if (pipe->Properties.AutoReset  && 
//        (!USBD_SUCCESS(urbStatus)) &&
//        urbStatus != USBD_STATUS_CANCELED)
//    { 
//        GenUSB_ResetPipe (deviceExtension, Irp, Trc);
//        return STATUS_MORE_PROCESSING_REQUIRED;
//    }

    InterlockedDecrement (&pipe->OutstandingIO);
    
    ExFreePool (Trc);
 
    IoReleaseRemoveLock (&deviceExtension->ConfigurationRemoveLock, Irp);
    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    return ((*complete) (DeviceObject, Irp, context, urbStatus, length));
}

//******************************************************************************
//
// GenUSB_TransmitReceive()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Initializes the Bulk or Interrupt transfer Urb and sends it down the stack
//
// scratch: Transfer Flags:  USBD_SHORT_TRANSFER_OK 
//                           USBD_DEFAULT_PIPE_TRANSFER
//                           USBD_TRANSFER_DIRECTION_OUT 
//                           USBD_TRANSFER_DIRECTION_IN
//
//
//******************************************************************************

NTSTATUS
GenUSB_TransmitReceive (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP              Irp,
    IN UCHAR             InterfaceNo,
    IN UCHAR             PipeNo,
    IN ULONG             TransferFlags,
    IN PCHAR             Buffer,
    IN PMDL              BufferMDL,
    IN ULONG             BufferLength,
    IN PVOID             Context,

    IN PGENUSB_COMPLETION_ROUTINE CompletionRoutine
    )
{
    PIO_STACK_LOCATION   stack;
    KIRQL                irql;
    NTSTATUS             status;
    GENUSB_TRANS_RECV  * trc;
    PGENUSB_PIPE_INFO    pipe;

    DBGPRINT(3, ("enter: GenUSB_TransmitReceive\n"));
    LOGENTRY(DeviceExtension,
             'TR__', 
             DeviceExtension, 
             ((InterfaceNo << 16) | PipeNo), 
             ((NULL == Buffer) ? (PCHAR) BufferMDL : Buffer));
    
    trc = NULL;
    pipe = NULL;

    //
    // Add another ref count to the remove lock for this completion routine.
    // since the caller will in all cases free the reference that it took.
    //
    status = IoAcquireRemoveLock (&DeviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    status = IoAcquireRemoveLock (&DeviceExtension->ConfigurationRemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
         
        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, Irp);

        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // find the pipe in question.
    //
    KeAcquireSpinLock (&DeviceExtension->SpinLock, &irql);
    {
        if (InterfaceNo < DeviceExtension->InterfacesFound)
        {
            if (PipeNo < DeviceExtension->Interface[InterfaceNo]->NumberOfPipes)
            {
                pipe = &DeviceExtension->Interface[InterfaceNo]->Pipes[PipeNo];
            }
        }
    }
    KeReleaseSpinLock (&DeviceExtension->SpinLock, irql);
    
    if (NULL == pipe)
    {
        status = STATUS_INVALID_PARAMETER;
        goto GenUSB_TransmitReceiveReject;
    }

    trc = ExAllocatePool (NonPagedPool, sizeof (GENUSB_TRANS_RECV));
    if (NULL == trc)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GenUSB_TransmitReceiveReject;
    }
    RtlZeroMemory (trc, sizeof (GENUSB_TRANS_RECV));

    trc->Context = Context;
    trc->Pipe = pipe;
    trc->CompletionRoutine = CompletionRoutine;

    // truncate a read packet to the max packet size if necessary.
    if ((pipe->Properties.DirectionIn) && 
        (!pipe->Properties.NoTruncateToMaxPacket) &&
        (BufferLength > pipe->Info.MaximumPacketSize))
    {
        BufferLength -= (BufferLength % pipe->Info.MaximumPacketSize);
    }

    // Initialize the TransferURB
    trc->TransUrb.Hdr.Length = sizeof (trc->TransUrb);
    trc->TransUrb.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    trc->TransUrb.PipeHandle = pipe->Info.PipeHandle;
    trc->TransUrb.TransferFlags = TransferFlags;
    trc->TransUrb.TransferBufferLength = BufferLength;
    trc->TransUrb.TransferBuffer = Buffer;
    trc->TransUrb.TransferBufferMDL = BufferMDL;

    // Set up the Irp
    stack = IoGetNextIrpStackLocation (Irp);
    stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    stack->Parameters.Others.Argument1 = &trc->TransUrb;

    InterlockedIncrement (&pipe->OutstandingIO);

    // Reset the timer Value.
    pipe->CurrentTimeout = pipe->Properties.Timeout;

    IoSetCompletionRoutine (Irp,
                            GenUSB_TransmitReceiveComplete,
                            trc,
                            TRUE,
                            TRUE,
                            TRUE);

    //
    // The rule is: if your completion routine is going to cause the 
    // Irp to be completed asynchronously (by returning 
    // STATUS_MORE_PROCESSING_REQUIRED) or if it is going to change 
    // the status of the Irp, then the dispatch function must mark
    // the Irp as pending and return STATUS_PENDING.  The completion
    // routine TransmitReceiveComplete doesn't change the status,
    // but ProbeAndSubmitTransferComlete might.
    //
    // In either case this prevents us from having to perculate the pending
    // bit in the completion routine as well.
    //

    IoMarkIrpPending (Irp);
    status = IoCallDriver (DeviceExtension->StackDeviceObject, Irp);
    DBGPRINT(3, ("exit:  GenUSB_TransRcv %08X\n", status));
    LOGENTRY(DeviceExtension, 'TR_x', Irp, trc, status);

    status = STATUS_PENDING;

    return status;

GenUSB_TransmitReceiveReject:

    if (trc)
    {  
        IoReleaseRemoveLock (&DeviceExtension->ConfigurationRemoveLock, Irp);
        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, Irp);
        ExFreePool (trc);
    }
    
    LOGENTRY(DeviceExtension, 'TR_x', Irp, trc, status);

    ((*CompletionRoutine) (DeviceExtension->Self, Irp, Context, 0, 0)); 

    // 
    // Complete the Irp only after this routine fires, since we pass the 
    // Irp into this routine.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}

//******************************************************************************
//
// GenUSB_Timer()
//
//
//
// This is a watchdog timer routine.  The assumption here is that this is not
// a highly acurate timer (in fact it only has an accuracy of a single second.
// the point is to see if there is any pipe on this device that has 
// outstanding transactions that are stuck, and then reset that pipe.
// We therefore do not spend any effort closing the race conditions 
// between a just completing transaction and the timer firing.
// It is sufficient to know that it got that close to reset the pipe.
//
// Apon pipe reset, all outstanding IRPs on the pipe should return with 
// and error.  (which is just fine.)
// 
//
//******************************************************************************

typedef struct _GENUSB_ABORT_CONTEXT {
    ULONG            NumHandles;
    PIO_WORKITEM     WorkItem;
    USBD_PIPE_HANDLE Handles[];
} GENUSB_ABORT_CONTEXT, *PGENUSB_ABORT_CONTEXT;

VOID
GenUSB_AbortPipeWorker (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PGENUSB_ABORT_CONTEXT Context
    )
{
    ULONG    i;
    NTSTATUS status;
    PDEVICE_EXTENSION        deviceExtension;
    struct _URB_PIPE_REQUEST urb;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    for (i=0; i < Context->NumHandles; i++)
    { 
        RtlZeroMemory (&urb, sizeof (urb));
        urb.Hdr.Length = sizeof (urb);
        urb.Hdr.Function = URB_FUNCTION_ABORT_PIPE;
        urb.PipeHandle = Context->Handles [i];

        LOGENTRY (deviceExtension, 'Abor', urb.PipeHandle, 0, 0);

        status = GenUSB_SyncSendUsbRequest (DeviceObject, (PURB) &urb);
        if (!NT_SUCCESS (status))
        {
            LOGENTRY (deviceExtension, 'Abor', urb.PipeHandle, 0, status);
        }
    }
    IoReleaseRemoveLock (&deviceExtension->ConfigurationRemoveLock, GenUSB_Timer); 
    IoFreeWorkItem (Context->WorkItem);
    ExFreePool (Context);
}

VOID
GenUSB_Timer (
    PDEVICE_OBJECT DeviceObject,
    PVOID          Unused
    )
{ 
    PGENUSB_PIPE_INFO     pipe; 
    PGENUSB_INTERFACE     inter;
    ULONG                 i,j;
    PDEVICE_EXTENSION     deviceExtension;
    KIRQL                 irql; 
    PGENUSB_ABORT_CONTEXT context;
    ULONG                 size;
    NTSTATUS              status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
 
    status = IoAcquireRemoveLock (&deviceExtension->ConfigurationRemoveLock, 
                                  GenUSB_Timer);
    if (!NT_SUCCESS(status)) {

        return;
    }

    //
    // BUGBUG preallocate this structure;
    // allowing the workitem and this timer to run at the same time.
    //
    size = sizeof (GENUSB_ABORT_CONTEXT) 
         + sizeof (USBD_PIPE_HANDLE) * deviceExtension->TotalNumberOfPipes;
    context = ExAllocatePool (NonPagedPool, size);

    if (NULL == context)
    {
        status = STATUS_INSUFFICIENT_RESOURCES; 
        return;
    }

    context->WorkItem = IoAllocateWorkItem (DeviceObject);
    if (NULL == context->WorkItem)
    {
        status = STATUS_INSUFFICIENT_RESOURCES; 
        ExFreePool (context);
        return;
    }


    context->NumHandles = 0;

    KeAcquireSpinLock (&deviceExtension->SpinLock, &irql);
    {
        // Walk through the list of interfaces and then pipes on those interfaces 
        // to find any pipes that may need a bit of a bump.

        for (i=0; i < deviceExtension->InterfacesFound; i++)
        { 
            inter = deviceExtension->Interface [i];

            for (j=0; j < inter->NumberOfPipes; j++)
            {
                pipe = &inter->Pipes[j];

                // now test for the timeout (given the assumptions above)
                if (pipe->OutstandingIO)
                {
                    if (0 != pipe->Properties.Timeout)
                    {
                        ASSERT (0 < pipe->CurrentTimeout);
                        
                        if (0 == InterlockedDecrement (&pipe->CurrentTimeout))
                        {
                            // abort this pipe.
                            context->Handles[context->NumHandles] 
                                = pipe->Info.PipeHandle;

                            context->NumHandles++;
                        }
                    }
                }
            }
        }
    }
    KeReleaseSpinLock (&deviceExtension->SpinLock, irql);

    LOGENTRY(deviceExtension, 
             'Time', 
             deviceExtension->InterfacesFound,
             deviceExtension->TotalNumberOfPipes,
             context->NumHandles);

    if (0 < context->NumHandles)
    {
        IoQueueWorkItem (context->WorkItem,
                         GenUSB_AbortPipeWorker,
                         DelayedWorkQueue,
                         context);
    }
    else 
    {
        IoFreeWorkItem (context->WorkItem);
        ExFreePool (context);
        IoReleaseRemoveLock (&deviceExtension->ConfigurationRemoveLock, 
                             GenUSB_Timer);
    }

    return;
} 



//******************************************************************************
//
// GenUSB_ResetPipe()
//
//******************************************************************************

NTSTATUS
GenUSB_ResetPipe (
    IN PDEVICE_EXTENSION  DeviceExtension,
    IN USBD_PIPE_HANDLE   UsbdPipeHandle,
    IN BOOLEAN            ResetPipe,
    IN BOOLEAN            ClearStall,
    IN BOOLEAN            FlushData
    )

{
    NTSTATUS           status;
    struct _URB_PIPE_REQUEST urb;

    PAGED_CODE ();

    DBGPRINT(2, ("enter: GenUSB_ResetPipe\n"));

    LOGENTRY(DeviceExtension, 'RESP', 
             UsbdPipeHandle, 
             (ResetPipe << 24) | (ClearStall << 16) | (FlushData << 8),
             0);

    RtlZeroMemory (&urb, sizeof (urb));
    urb.Hdr.Length = sizeof (urb);
    urb.PipeHandle = UsbdPipeHandle;

    if (ResetPipe && ClearStall)
    {
        urb.Hdr.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    }
    else if (ResetPipe)
    {
        urb.Hdr.Function = URB_FUNCTION_SYNC_RESET_PIPE;
    }
    else if (ClearStall)
    {
        urb.Hdr.Function = URB_FUNCTION_SYNC_CLEAR_STALL;
    }

    status = GenUSB_SyncSendUsbRequest (DeviceExtension->Self, (PURB) &urb);

    LOGENTRY(DeviceExtension, 'resp', 
             UsbdPipeHandle, 
             (ResetPipe << 24) | (ClearStall << 16) | (FlushData << 8),
             status);

    DBGPRINT(2, ("exit:  GenUSB_ResetPipe %08X\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\busif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    busif.c

Abstract:

    Links to new usb 2.0 stack

    The effect is that when running on the USB2 stack the hub
    is no longer depenent on the port driver archetecture or
    USBD for the PnP services:

    CreateDevice
    InitailiazeDevice
    RemoveDevice


Environment:

    kernel mode only

Notes:



Revision History:

    10-29-95 : created

--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"

#ifdef USB2

NTSTATUS
USBD_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBHUB_GetBusInterface(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PUSB_HUB_BUS_INTERFACE BusInterface
    )
/*++

Routine Description:

Arguments:

Return Value:

    returns success if USB2 stack

--*/
{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    irp = IoAllocateIrp(RootHubPdo->StackSize, FALSE);

    if (!irp) {
        return STATUS_UNSUCCESSFUL;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBD_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_INTERFACE;

    // init busif
    //busIf->
    nextStack->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        RootHubPdo;
    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_HUB_GUID;
    nextStack->Parameters.QueryInterface.Size =
        sizeof(*BusInterface);
    nextStack->Parameters.QueryInterface.Version =
        HUB_BUSIF_VERSION;

    ntStatus = IoCallDriver(RootHubPdo,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;
    }

    if (NT_SUCCESS(ntStatus)) {
        // we have a bus interface

        ASSERT(BusInterface->Version == HUB_BUSIF_VERSION);
        ASSERT(BusInterface->Size == sizeof(*BusInterface));

    }

    IoFreeIrp(irp);
    // get the bus interface

    return ntStatus;
}


NTSTATUS
USBD_CreateDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE *DeviceData,
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags,
    IN USHORT PortStatus,
    IN USHORT PortNumber
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS                    ntStatus;
    PUSB_DEVICE_HANDLE          hubDeviceHandle;
    PUSB_HUB_BUS_INTERFACE   busIf;

    // note no device extension for USBD if running on
    // usb 2 stack


    // If the HUB was ever reset through USBH_ResetDevice, the HUB PDO
    // DeviceExtensionPort->DeviceData could have changed.  Instead of trying
    // to propagate a change in the HUB PDO DeviceExtensionPort->DeviceData
    // through to the HUB FDO DeviceExtensionHub when a change happens, let's
    // just retrieve the HubDeviceHandle every time we use it (which is only
    // in this routine) instead of keeping a cached copy.
    //
    hubDeviceHandle =
        USBH_SyncGetDeviceHandle(DeviceExtensionHub->TopOfStackDeviceObject);


    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->CreateUsbDevice) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->CreateUsbDevice(busIf->BusContext,
                                          DeviceData,
                                          hubDeviceHandle,
                                          PortStatus,
                                          // ttnumber
                                          PortNumber);

        
    }

    // get the hack flags

    return ntStatus;
}


NTSTATUS
USBD_InitUsb2Hub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS                    ntStatus;
    PUSB_DEVICE_HANDLE          hubDeviceHandle;
    PUSB_HUB_BUS_INTERFACE   busIf;
    ULONG ttCount = 1;
    
    // note no device extension for USBD if running on
    // usb 2 stack

    // should only call this on a usb 2.0 hub
    USBH_ASSERT(DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB);

    if (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_MULTI_TT) {
        PUSB_HUB_DESCRIPTOR hubDescriptor;
    
        hubDescriptor = DeviceExtensionHub->HubDescriptor;
        USBH_ASSERT(NULL != hubDescriptor);

        ttCount = hubDescriptor->bNumberOfPorts;
    }

    // If the HUB was ever reset through USBH_ResetDevice, the HUB PDO
    // DeviceExtensionPort->DeviceData could have changed.  Instead of trying
    // to propagate a change in the HUB PDO DeviceExtensionPort->DeviceData
    // through to the HUB FDO DeviceExtensionHub when a change happens, let's
    // just retrieve the HubDeviceHandle every time we use it (which is only
    // in this routine) instead of keeping a cached copy.
    //
    hubDeviceHandle =
        USBH_SyncGetDeviceHandle(DeviceExtensionHub->TopOfStackDeviceObject);


    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->Initialize20Hub) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->Initialize20Hub(busIf->BusContext,
                                          hubDeviceHandle,
                                          ttCount);
    }

    return ntStatus;
}


NTSTATUS
USBD_InitializeDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{

    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->InitializeUsbDevice || !busIf->GetUsbDescriptors) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->InitializeUsbDevice(busIf->BusContext,
                                              DeviceData);
    }

    // if successful fetch the descriptors
    if (NT_SUCCESS(ntStatus)) {

        ntStatus = busIf->GetUsbDescriptors(busIf->BusContext,
                                              DeviceData,
                                              (PUCHAR) DeviceDescriptor,
                                              &DeviceDescriptorLength,
                                              (PUCHAR) ConfigDescriptor,
                                              &ConfigDescriptorLength);
    }

    return ntStatus;
}


NTSTATUS
USBD_RemoveDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    // flags are currently not used by usb2 stack

    if (!busIf->RemoveUsbDevice) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RemoveUsbDevice(busIf->BusContext,
                                          DeviceData,
                                          Flags);
    }

    return ntStatus;
}


NTSTATUS
USBD_GetDeviceInformationEx(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_NODE_CONNECTION_INFORMATION_EX DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSB_DEVICE_HANDLE DeviceData
    )
/*
    This function maps the new port service on to the 
    old hub api.
*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    ULONG length, lengthCopied;
    ULONG i, need;
    PUSB_DEVICE_INFORMATION_0 level_0 = NULL;
    PUSB_NODE_CONNECTION_INFORMATION_EX localDeviceInfo;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->QueryDeviceInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    // call the new API and map the data to the old format

//    USBH_KdPrint((0, "'Warning: Caller is using old style IOCTL.\n"));
//    USBH_KdPrint((0, "'If this is a WinOS component or Test Application please fix it.\n"));
//    TEST_TRAP();

    length = sizeof(*level_0);

    do {
        ntStatus = STATUS_SUCCESS;

        level_0 = UsbhExAllocatePool(PagedPool, length);
        if (level_0 == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(ntStatus)) {
            USBH_ASSERT(level_0 != NULL);     
            level_0->InformationLevel = 0;

            ntStatus = busIf->QueryDeviceInformation(busIf->BusContext,
                                                     DeviceData,
                                                     level_0,
                                                     length,
                                                     &lengthCopied);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = level_0->ActualLength;
                UsbhExFreePool(level_0);
                level_0 = NULL;
            }
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    // do we have enough to satisfiy the API?
    if (NT_SUCCESS(ntStatus)) {
        USBH_ASSERT(level_0 != NULL);
        need = level_0->NumberOfOpenPipes * sizeof(USB_PIPE_INFO) +
                sizeof(USB_NODE_CONNECTION_INFORMATION);

        localDeviceInfo = UsbhExAllocatePool(PagedPool, need);
        if (localDeviceInfo == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }        

    if (NT_SUCCESS(ntStatus)) {

        USBH_KdPrint((2, "'level_0 %x\n", level_0 ));

        // BUGBUG
        // DeviceInformation has some preset fields, save them
        // in the loacl info buffer
        localDeviceInfo->DeviceIsHub =
            DeviceInformation->DeviceIsHub;

        localDeviceInfo->ConnectionIndex =
            DeviceInformation->ConnectionIndex;

        localDeviceInfo->ConnectionStatus =
            DeviceInformation->ConnectionStatus;

        localDeviceInfo->DeviceIsHub =
            DeviceInformation->DeviceIsHub;

        // map to the old format
        localDeviceInfo->DeviceDescriptor =
            level_0->DeviceDescriptor;

        localDeviceInfo->CurrentConfigurationValue =
            level_0->CurrentConfigurationValue;

        localDeviceInfo->Speed = (UCHAR) level_0->DeviceSpeed;

        // draw this from our extension
        localDeviceInfo->DeviceIsHub =
            (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB)
                ? TRUE : FALSE;

        localDeviceInfo->DeviceAddress =
            level_0->DeviceAddress;

        localDeviceInfo->NumberOfOpenPipes =
            level_0->NumberOfOpenPipes;

        // BUGBUG - hardcode to 'connected' ?
        // is this used by callers?
//        DeviceInformation->ConnectionStatus =
//            DeviceConnected;

        for (i=0; i< level_0->NumberOfOpenPipes; i++) {

            localDeviceInfo->PipeList[i].EndpointDescriptor =
                level_0->PipeList[i].EndpointDescriptor;

            localDeviceInfo->PipeList[i].ScheduleOffset =
                level_0->PipeList[i].ScheduleOffset;
        }
    }

    if (level_0 != NULL) {
        UsbhExFreePool(level_0);
        level_0 = NULL;
    }

    if (localDeviceInfo != NULL) {
        if (need > DeviceInformationLength) {
            // return what we can
            RtlCopyMemory(DeviceInformation,
                          localDeviceInfo,
                          DeviceInformationLength);

            ntStatus = STATUS_BUFFER_TOO_SMALL;
        } else {
            // return what is appropriate
            RtlCopyMemory(DeviceInformation,
                          localDeviceInfo ,
                          need);
        }

        UsbhExFreePool(localDeviceInfo);
        localDeviceInfo = NULL;
    }

    return ntStatus;
}


//ULONG
//USBD_GetHackFlags(
//    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
//    )
//{
//    NTSTATUS ntStatus;
//    ULONG flags;
//    PUSB_HUB_BUS_INTERFACE busIf;
//
//    busIf = &DeviceExtensionHub->BusIf;
//
//    // flags are currently not used by usb2 stack
//
//    ntStatus = busIf->GetPortHackFlags(busIf->BusContext, &flags);
//
//    return flags;
//}


NTSTATUS
USBD_MakePdoNameEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    )
/*++

Routine Description:

    This service Creates a name for a PDO created by the HUB

Arguments:

Return Value:


--*/
{
    PWCHAR nameBuffer = NULL;
    WCHAR rootName[] = L"\\Device\\USBPDO-";
    UNICODE_STRING idUnicodeString;
    WCHAR buffer[32];
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT length;

    length = sizeof(buffer)+sizeof(rootName);

    //
    // use ExAllocate because client will free it
    //
    nameBuffer = UsbhExAllocatePool(PagedPool, length);

    if (nameBuffer) {
        RtlCopyMemory(nameBuffer, rootName, sizeof(rootName));

        RtlInitUnicodeString(PdoNameUnicodeString,
                             nameBuffer);
        PdoNameUnicodeString->MaximumLength =
            length;

        RtlInitUnicodeString(&idUnicodeString,
                             &buffer[0]);
        idUnicodeString.MaximumLength =
            sizeof(buffer);

        ntStatus = RtlIntegerToUnicodeString(
                  Index,
                  10,
                  &idUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
             ntStatus = RtlAppendUnicodeStringToString(PdoNameUnicodeString,
                                                       &idUnicodeString);
        }

        USBH_KdPrint((2, "'USBD_MakeNodeName string = %x\n",
            PdoNameUnicodeString));

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus) && nameBuffer) {
        UsbhExFreePool(nameBuffer);
    }

    return ntStatus;
}


NTSTATUS
USBD_RestoreDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE OldDeviceData,
    IN OUT PUSB_DEVICE_HANDLE NewDeviceData,
    IN PDEVICE_OBJECT RootHubPdo
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->RestoreUsbDevice) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RestoreUsbDevice(busIf->BusContext,
                                        OldDeviceData,
                                        NewDeviceData);
    }

    return ntStatus;
}


NTSTATUS
USBD_QuerySelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PBOOLEAN SelectiveSuspendEnabled
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    USB_CONTROLLER_INFORMATION_0 controllerInfo;
    ULONG dataLen = 0;

    controllerInfo.InformationLevel = 0;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->GetControllerInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->GetControllerInformation(busIf->BusContext,
                                                &controllerInfo,
                                                sizeof(controllerInfo),
                                                &dataLen);
    }

    USBH_ASSERT(dataLen);

    if (dataLen) {
        *SelectiveSuspendEnabled = controllerInfo.SelectiveSuspendEnabled;
    }

    return ntStatus;
}


VOID 
USBHUB_RhHubCallBack(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    DeviceExtensionHub->HubFlags |= HUBFLAG_OK_TO_ENUMERATE;

    // if irp is null'ed out then it must have been stopped or removed before 
    // our callback   we just check for NULL here instead of the dozen or so 
    // flags the hub has.
    if (DeviceExtensionHub->Irp != NULL) {
    
        USBH_SubmitInterruptTransfer(DeviceExtensionHub);

        USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                         BusRelations);
    }                                                 
}


NTSTATUS
USBD_RegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->RootHubInitNotification) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RootHubInitNotification(busIf->BusContext,
                                             DeviceExtensionHub,
                                             USBHUB_RhHubCallBack);
    }

    return ntStatus;
}


NTSTATUS
USBD_UnRegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->RootHubInitNotification) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RootHubInitNotification(busIf->BusContext,
                                             NULL,
                                             NULL);
    }

    return ntStatus;
}


NTSTATUS
USBD_SetSelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN BOOLEAN SelectiveSuspendEnabled
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->ControllerSelectiveSuspend) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->ControllerSelectiveSuspend(busIf->BusContext,
                                                    SelectiveSuspendEnabled);
    }

    return ntStatus;
}


BOOLEAN
USBH_ValidateConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    Validate a configuration descriptor

Arguments:

    ConfigurationDescriptor -

    Urb -

Return Value:

    TRUE if it looks valid

--*/
{
    BOOLEAN valid = TRUE;

    if (ConfigurationDescriptor->bDescriptorType !=
        USB_CONFIGURATION_DESCRIPTOR_TYPE) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }

    // USB 1.1, Section 9.5 Descriptors:
    //
    // If a descriptor returns with a value in its length field that is
    // less than defined by this specification, the descriptor is invalid and
    // should be rejected by the host.  If the descriptor returns with a
    // value in its length field that is greater than defined by this
    // specification, the extra bytes are ignored by the host, but the next
    // descriptor is located using the length returned rather than the length
    // expected.

    if (ConfigurationDescriptor->bLength <
        sizeof(USB_CONFIGURATION_DESCRIPTOR)) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }

    return valid;

}


NTSTATUS
USBHUB_GetBusInterfaceUSBDI(
    IN PDEVICE_OBJECT HubPdo,
    IN PUSB_BUS_INTERFACE_USBDI_V2 BusInterface
    )
/*++

Routine Description:

Arguments:

Return Value:

    returns success if USB2 stack

--*/
{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    irp = IoAllocateIrp(HubPdo->StackSize, FALSE);

    if (!irp) {
        return STATUS_UNSUCCESSFUL;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBD_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_INTERFACE;

    // init busif
    //busIf->
    nextStack->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    // this is the device handle, filled in as we pass down the 
    // stack
    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        NULL;
    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_USBDI_GUID;
    nextStack->Parameters.QueryInterface.Size =
        sizeof(*BusInterface);
    nextStack->Parameters.QueryInterface.Version =
        USB_BUSIF_USBDI_VERSION_2;

    ntStatus = IoCallDriver(HubPdo,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;
    }

    if (NT_SUCCESS(ntStatus)) {
        // we have a bus interface

        ASSERT(BusInterface->Version == USB_BUSIF_USBDI_VERSION_2);
        ASSERT(BusInterface->Size == sizeof(*BusInterface));

    }

    IoFreeIrp(irp);
    // get the bus interface

    return ntStatus;
}


NTSTATUS
USBHUB_GetBusInfoDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSB_BUS_NOTIFICATION BusInfo
    )
/*++

Routine Description:

    Return the bus information relative to a specific device
    
Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    PVOID busContext;

    busIf = &DeviceExtensionHub->BusIf;

    busContext = busIf->GetDeviceBusContext(busIf->BusContext,
                                            DeviceExtensionPort->DeviceData);
                                  
    // get the TT handle for this device and query the 
    // bus information relative to it

    ntStatus = USBHUB_GetBusInfo(DeviceExtensionHub,
                      BusInfo,
                      busContext);
                      
    return ntStatus;
}


NTSTATUS
USBHUB_GetBusInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_BUS_NOTIFICATION BusInfo,
    IN PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PUSB_BUS_INFORMATION_LEVEL_1 level_1;
    PUSB_BUS_INTERFACE_USBDI_V2 busIf;
    ULONG length, actualLength;
    NTSTATUS ntStatus;

    busIf = &DeviceExtensionHub->UsbdiBusIf;

    if (!busIf->QueryBusInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    length = sizeof(USB_BUS_INFORMATION_LEVEL_1);

    do {
        level_1 = UsbhExAllocatePool(PagedPool, length);
        if (level_1 != NULL) {
            if (BusContext == NULL) {
                BusContext = busIf->BusContext;
            }                
        
            ntStatus = busIf->QueryBusInformation(BusContext,
                                                  1,
                                                  level_1,
                                                  &length,
                                                  &actualLength);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = actualLength;
                UsbhExFreePool(level_1);
                level_1 = NULL;
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(ntStatus)) {

        LOGENTRY(LOG_PNP, "lev1", level_1, 0, 0);

        BusInfo->TotalBandwidth = level_1->TotalBandwidth;
        BusInfo->ConsumedBandwidth = level_1->ConsumedBandwidth;

        /* length of the UNICODE symbolic name (in bytes) for the controller
           that this device is attached to.
           not including NULL */
        BusInfo->ControllerNameLength = level_1->ControllerNameLength;
        UsbhExFreePool(level_1);
    }

    return ntStatus;
}


NTSTATUS
USBHUB_GetExtendedHubInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_EXTHUB_INFORMATION_0 ExtendedHubInfo
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    PVOID busContext;
    ULONG length;

    busIf = &DeviceExtensionHub->BusIf;
    
    ntStatus = busIf->GetExtendedHubInformation(busIf->BusContext,
                                                DeviceExtensionHub->PhysicalDeviceObject,
                                                ExtendedHubInfo,
                                                sizeof(*ExtendedHubInfo),
                                                &length);
                                  
    return ntStatus;
}


PUSB_DEVICE_HANDLE
USBH_SyncGetDeviceHandle(
    IN PDEVICE_OBJECT DeviceObject
    )
 /* ++
  *
  * Routine Description:
  *
  * Arguments:
  *
  * Return Value:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PUSB_DEVICE_HANDLE handle = NULL;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetDeviceHandle\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        goto USBH_SyncGetDeviceHandle_Done;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    nextStack->Parameters.Others.Argument1 =  &handle;

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetDeviceHandle (%x)\n", ntStatus));

USBH_SyncGetDeviceHandle_Done:

    return handle;
}


USB_DEVICE_TYPE
USBH_GetDeviceType(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData
    )
/*
    This function maps the new port service on to the
    old hub api.
*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    ULONG length, lengthCopied;
    ULONG i, need;
    PUSB_DEVICE_INFORMATION_0 level_0 = NULL;
    // if all else fails assum it is 11
    USB_DEVICE_TYPE deviceType = Usb11Device;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->QueryDeviceInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    length = sizeof(*level_0);

    do {
        ntStatus = STATUS_SUCCESS;

        level_0 = UsbhExAllocatePool(PagedPool, length);
        if (level_0 == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(ntStatus)) {
            level_0->InformationLevel = 0;

            ntStatus = busIf->QueryDeviceInformation(busIf->BusContext,
                                                     DeviceData,
                                                     level_0,
                                                     length,
                                                     &lengthCopied);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = level_0->ActualLength;
                UsbhExFreePool(level_0);
            }
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    // do we have enough to satisfiy the API?

    need = level_0->NumberOfOpenPipes * sizeof(USB_PIPE_INFO) +
            sizeof(USB_NODE_CONNECTION_INFORMATION);

    if (NT_SUCCESS(ntStatus)) {
        deviceType = level_0->DeviceType;
    }

    if (level_0 != NULL) {
        UsbhExFreePool(level_0);
        level_0 = NULL;
    }

    USBH_KdPrint((2,"'exit USBH_GetDeviceType (%x)\n", deviceType));

    return deviceType;
}


VOID
USBH_InitializeUSB2Hub(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            ntStatus;
    PUSB_DEVICE_HANDLE  hubDeviceHandle;

    // NOTE: if we are running on the old 1.1 stack a NULL
    // is returned
    hubDeviceHandle =
        USBH_SyncGetDeviceHandle(DeviceExtensionHub->TopOfStackDeviceObject);

    // if we are a USB 2 hub then set the hub flag so we ignore
    // failed resets
    if (hubDeviceHandle != NULL &&
        USBH_GetDeviceType(DeviceExtensionHub,
                           hubDeviceHandle) == Usb20Device) {

        DeviceExtensionHub->HubFlags |= HUBFLAG_USB20_HUB;
    }

#ifdef TEST_2X_UI
    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        // To test the UI, mark the root hub as 2.x capable.
        DeviceExtensionHub->HubFlags |= HUBFLAG_USB20_HUB;
    }
#endif

}

NTSTATUS
USBHUB_GetControllerName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_HUB_NAME Buffer,
    IN ULONG BufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PUSB_BUS_INFORMATION_LEVEL_1 level_1;
    PUSB_BUS_INTERFACE_USBDI_V2 busIf;
    ULONG lenToCopy, length, actualLength;
    NTSTATUS ntStatus;

    busIf = &DeviceExtensionHub->UsbdiBusIf;

    if (!busIf->QueryBusInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    length = sizeof(USB_BUS_INFORMATION_LEVEL_1);

    do {
        level_1 = UsbhExAllocatePool(PagedPool, length);
        if (level_1 != NULL) {
            ntStatus = busIf->QueryBusInformation(busIf->BusContext,
                                                  1,
                                                  level_1,
                                                  &length,
                                                  &actualLength);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = actualLength;
                UsbhExFreePool(level_1);
                level_1 = NULL;
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(ntStatus)) {

        LOGENTRY(LOG_PNP, "lev1", level_1, 0, 0);

        // not sure if BufferLength includes size of the
        // ActualLength field, we will assume it does
        Buffer->ActualLength = level_1->ControllerNameLength;

        if ((BufferLength - sizeof(Buffer->ActualLength))
            >= level_1->ControllerNameLength) {
            lenToCopy = level_1->ControllerNameLength;
        } else {
            lenToCopy = BufferLength - sizeof(Buffer->ActualLength);
        }

        // copy what we can
        RtlCopyMemory(&Buffer->HubName[0],
                      &level_1->ControllerNameUnicodeString[0],
                      lenToCopy);

        UsbhExFreePool(level_1);
    }

    return ntStatus;
}


NTSTATUS
USBHUB_GetRootHubName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PVOID Buffer,
    IN PULONG BufferLength
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->GetRootHubSymbolicName) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->GetRootHubSymbolicName(
                            busIf->BusContext,
                            Buffer,
                            *BufferLength,
                            BufferLength);
    }

    return ntStatus;
}


VOID
USBHUB_FlushAllTransfers(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->FlushTransfers) {
        USBH_ASSERT(FALSE);
    } else {
        busIf->FlushTransfers(busIf->BusContext,
                              NULL);
    }

    return;
}


VOID
USBHUB_SetDeviceHandleData(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PDEVICE_OBJECT PdoDeviceObject,
    PVOID DeviceData 
    )
{
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    // associate this PDO with the device handle
    // (if we can)
    if (!busIf->SetDeviceHandleData) {
        USBH_ASSERT(FALSE);
    } else { 
        busIf->SetDeviceHandleData(busIf->BusContext,
                                   DeviceData,
                                   PdoDeviceObject);
    }                                           

    return;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\dbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    This module contains debug only code for USB Hub driver

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    11-5-96 : created

--*/


#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */

#include "stdarg.h"
#include "stdio.h"
#include "usbhub.h"

#ifdef MAX_DEBUG
#define DEBUG_HEAP
#endif

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


#if DBG 

// this flag causes us to write a ' in the format string 
// so that the string goes to the NTKERN buffer
// this trick causes problems with driver verifier on NT
// and the trace buffer isn't in NT anyway 
ULONG USBH_W98_Debug_Trace = 
#ifdef NTKERN_TRACE
1;
#else 
0;
#endif

VOID
USBH_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    DBGBREAK();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}


ULONG
_cdecl
USBH_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[6];
    
    if (USBH_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            if (USBH_W98_Debug_Trace) {             
                //override trace buffer
#ifdef USBHUB20  
                DbgPrint("USBHUB20.SYS: ");
#else
                DbgPrint("USBHUB.SYS: ");
#endif                
                *Format = ' ';
            } else {
#ifdef USBHUB20  
                DbgPrint("USBHUB20.SYS: ");
#else
                DbgPrint("USBHUB.SYS: ");
#endif                 
            }
        } else {
#ifdef USBHUB20 
            DbgPrint("USBHUB20.SYS: ");
#else
            DbgPrint("USBHUB.SYS: ");
#endif             
        }
        va_start(list, Format);
        for (i=0; i<6; i++) 
            arg[i] = va_arg(list, int);
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    } 

    return 0;
}


VOID
UsbhWarning(
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    PUCHAR Message,
    BOOLEAN DebugBreak
    )
{                                                                                               
    DbgPrint("USBHUB: Warning **************************************************************\n");
    if (DeviceExtensionPort) {
        DbgPrint("Device PID %04.4x, VID %04.4x\n",     
                 DeviceExtensionPort->DeviceDescriptor.idProduct, 
                 DeviceExtensionPort->DeviceDescriptor.idVendor); 
    }
    DbgPrint("%s", Message);

    DbgPrint("******************************************************************************\n");

    if (DebugBreak) {
        DBGBREAK();
    }
      
}


VOID 
UsbhInfo(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    ULONG i;

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    
    USBH_KdPrint((1, "'*****************************************************\n"));
    
    if (USBH_HubIsBusPowered(DeviceExtensionHub->FunctionalDeviceObject,
                             DeviceExtensionHub->ConfigurationDescriptor)) {
        USBH_KdPrint((1, "'*** Hub VID %04.4x PID %04.4x is BUS POWERED \n",
                DeviceExtensionHub->DeviceDescriptor.idVendor,
                DeviceExtensionHub->DeviceDescriptor.idProduct));                             
    } else {
        USBH_KdPrint((1, "'*** Hub VID %04.4x PID %04.4x is SELF POWERED \n",
                DeviceExtensionHub->DeviceDescriptor.idVendor,
                DeviceExtensionHub->DeviceDescriptor.idProduct));
    }                
    USBH_KdPrint((1, "'*** has %d ports\n", 
            hubDescriptor->bNumberOfPorts));
    if (HUB_IS_GANG_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {
        USBH_KdPrint((1,"'*** is 'gang power switched'\n"));
    } else if (HUB_IS_NOT_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {
        USBH_KdPrint((1,"'*** is 'not power switched'\n"));
    } else if (HUB_IS_PORT_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {
        USBH_KdPrint((1,"'*** is 'port power switched'\n"));
    } else {
        TEST_TRAP();
    }

    for (i=0; i< hubDescriptor->bNumberOfPorts; i++) {
    
        if (PORT_ALWAYS_POWER_SWITCHED(hubDescriptor, i+1)) {
            USBH_KdPrint((1,"'*** port (%d) is power switched\n", i+1));    
        }
        
        if (PORT_DEVICE_NOT_REMOVABLE(hubDescriptor, i+1)) {
            USBH_KdPrint((1,"'*** port (%d) device is not removable\n", i+1));    
        }
    }
    
    USBH_KdPrint((1, "'*****************************************************\n"));    
}        


PVOID
UsbhGetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    PoolType - pool type passed to ExAllocatePool
    
    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    
    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER)*2,
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;        
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;

        tagBuffer = (PHEAP_TAG_BUFFER) (p + NumberOfBytes);
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;     
    }                                            

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, "GetH", p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else    
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */                
    return p;
}


VOID
UsbhRetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER endTagBuffer;    
    PHEAP_TAG_BUFFER beginTagBuffer;

    USBH_ASSERT(P != 0);
    
    beginTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));
    endTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P + beginTagBuffer->Length);

    *TotalAllocatedHeapSpace -= beginTagBuffer->Length;

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);    
//    LOGENTRY(LOG_MISC, "RetH", P, tagBuffer->Length, stk[1] & 0x00FFFFFF);

    USBH_ASSERT(*TotalAllocatedHeapSpace >= 0);
    USBH_ASSERT(beginTagBuffer->Sig == Signature);
    USBH_ASSERT(endTagBuffer->Sig == Signature);
    USBH_ASSERT(endTagBuffer->Length == beginTagBuffer->Length);
    
    // fill the buffer with bad data
    RtlFillMemory(P, beginTagBuffer->Length, 0xff);
    beginTagBuffer->Sig = USBHUB_FREE_TAG;

    // free the original block
    ExFreePool(beginTagBuffer);    
#else
    ExFreePool(P);        
#endif /* DEBUG_HEAP */
}

#endif /* DBG */

#ifdef DEBUG_LOG

KSPIN_LOCK LogSpinLock;

struct USBH_LOG_ENTRY {
    CHAR         le_name[4];      // Identifying string
    ULONG_PTR    le_info1;        // entry specific info
    ULONG_PTR    le_info2;        // entry specific info
    ULONG_PTR    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct USBH_LOG_ENTRY *HubLStart = 0;    // No log yet
struct USBH_LOG_ENTRY *HubLPtr;
struct USBH_LOG_ENTRY *HubLEnd;
#ifdef PROFILE
ULONG LogMask = LOG_PROFILE;
#else 
ULONG LogMask = 0xFFFFFFFF;
#endif

VOID
USBH_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name, 
    IN ULONG_PTR Info1, 
    IN ULONG_PTR Info2, 
    IN ULONG_PTR Info3
    )
/*++

Routine Description:

    Adds an Entry to USBH log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (HubLStart == 0) {
        return;
    }        

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }        
    
    if (HubLPtr > HubLStart) {
        HubLPtr -= 1;    // Decrement to next entry
    } else {
        HubLPtr = HubLEnd;
    }        

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }        

    USBH_ASSERT(HubLPtr >= HubLStart);
    
    RtlCopyMemory(HubLPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);
    HubLPtr->le_info1 = Info1;
    HubLPtr->le_info2 = Info2;
    HubLPtr->le_info3 = Info3;

    return;
}


VOID
USBH_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;    
#else
    ULONG logSize = 4096*3;    
#endif

    
    KeInitializeSpinLock(&LogSpinLock);

    HubLStart = ExAllocatePoolWithTag(NonPagedPool, 
                                      logSize,
                                      USBHUB_HEAP_TAG); 

    if (HubLStart) {
        HubLPtr = HubLStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        HubLEnd = HubLStart + (logSize / sizeof(struct USBH_LOG_ENTRY)) - 1;
    } else {
        USBH_KdBreak(("no mem for log!\n"));
    }

    return;
}

VOID
USBH_LogFree(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    if (HubLStart) {
        ExFreePool(HubLStart);
    }
}

#endif /* DEBUG_LOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\genusb\sys\genusb.h ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    USBMASS.H

Abstract:

    Header file for USBSTOR driver

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#ifndef KDEXTMODE
#include <wdm.h>
#include <usb.h>
#include <usbioctl.h>
#include <usbdlib.h>
#endif

#define __GUSB_H_KERNEL_
#include "genusbio.h"

struct _DEVICE_EXTENSION;

#include "dbg.h"

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))


#define CLASS_URB(urb)      urb->UrbControlVendorClassRequest
#define FEATURE_URB(urb)    urb->UrbControlFeatureRequest

#define POOL_TAG 'UNEG'

#undef ExAllocatePool
#define ExAllocatePool(_type_, _length_) \
        ExAllocatePoolWithTag(_type_, _length_, POOL_TAG)

//*****************************************************************************
//  Registry Strings
//*****************************************************************************

// driver keys

// The pipe number for IRP_MJ_READ
#define REGKEY_DEFAULT_READ_PIPE L"DefaultReadPipe"
// The pipe number for IRP_MJ_WRITE
#define REGKEY_DEFAULT_WRITE_PIPE L"DefaultWritePipe"


#define USB_RECIPIENT_DEVICE    URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
#define USB_RECIPIENT_INTERFACE URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE
#define USB_RECIPIENT_ENDPOINT  URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT

typedef struct _GENUSB_PIPE_INFO
{
    USBD_PIPE_INFORMATION  Info;
    GENUSB_PIPE_PROPERTIES Properties;
    LONG                   CurrentTimeout;
    ULONG                  OutstandingIO;

} GENUSB_PIPE_INFO, *PGENUSB_PIPE_INFO;

typedef struct _GENUSB_INTERFACE
{
    UCHAR                    InterfaceNumber;
    UCHAR                    CurrentAlternate;
    UCHAR                    NumberOfPipes;
    UCHAR                    Reserved;
    USBD_INTERFACE_HANDLE    Handle;

    GENUSB_PIPE_INFO Pipes[];
  
} GENUSB_INTERFACE, *PGENUSB_INTERFACE;

typedef struct _GENUSB_TRANSFER 
{ 
    GENUSB_READ_WRITE_PIPE  UserCopy;
    PMDL                    UserMdl; 
    PMDL                    TransferMdl;
    PGENUSB_READ_WRITE_PIPE SystemAddress;

} GENUSB_TRANSFER, *PGENUSB_TRANSFER;

typedef struct _GENUSB_PIPE_HANDLE {
    UCHAR   InterfaceIndex;
    UCHAR   PipeIndex;
    USHORT  Signature;

} *PGENUSB_PIPE_HANDLE;

C_ASSERT (sizeof (GENUSB_PIPE_HANDLE) == sizeof (struct _GENUSB_PIPE_HANDLE));

//
// Note: these routines do NOT actually secure that a transaction to a Pipe 
// handle is no longer valid across a DeselectConfiguration, since the 
// new configuration Handle might fall in the same address, and the old pipe 
// handle might capture the same interface Index and Pipe Index.  It does
// however catch a few sainity checks, and will prevent the user mode piece 
// from manufacturing their own configuration handles (Without at least seeing
// the first one from a given configuration.)  This just keeps them more 
// honest, and doesn't really cause us any additional pain.
//
// In every case where we check the signatures, we also check to make sure 
// that the interface and pipe indices contained in the handle are also 
// still valid.
//

#define CONFIGURATION_CHECK_BITS(DeviceExtension) \
    ((USHORT) (((ULONG_PTR) ((DeviceExtension)->ConfigurationHandle)) >> 6))

#define VERIFY_PIPE_HANDLE_SIG(Handle, DeviceExtension) \
        (CONFIGURATION_CHECK_BITS(DeviceExtension) == \
         ((PGENUSB_PIPE_HANDLE) (Handle))->Signature)
//
// Do something similar with the Pipe properties so that people are forced to 
// do a get and set of the pipe properties.  This will help to ensure that 
// they are honest with these values and don't change other fields inadvertantly
//
#define PIPE_PROPERTIES_CHECK_BITS(PipeInfo) \
    ((USHORT) (((ULONG_PTR) &((PipeInfo)->Info)) >> 6))
// ((USHORT) (((ULONG_PTR) (PipeInfo) is equiv, but we do it this other way
// to check the type, by referecing the first field.
#define VERIFY_PIPE_PROPERTIES_HANDLE(PipeProperty, PipeInfo) \
    (PIPE_PROPERTIES_CHECK_BITS(PipeInfo) == (PipeProperty)->PipePropertyHandle)


// Device Extension for the FDO we attach on top of the USB enumerated PDO.
//
typedef struct _DEVICE_EXTENSION
{
    // Back pointer to Device Object for this Device Extension
    PDEVICE_OBJECT                  Self;

    BOOLEAN                         IsStarted;
    BOOLEAN                         Reserved0[3];

    // PDO passed to AddDevice
    PDEVICE_OBJECT                  PhysicalDeviceObject;

    // Our FDO is attached to this device object
    PDEVICE_OBJECT                  StackDeviceObject;

    // Device specific log.
    PGENUSB_LOG_ENTRY   LogStart;       // Start of log buffer (older entries)
    ULONG               LogIndex;
    ULONG               LogMask;

    // lock to protect from IRP_MN_REMOVE 
    IO_REMOVE_LOCK                  RemoveLock;

    // Current power states
    SYSTEM_POWER_STATE              SystemPowerState;
    DEVICE_POWER_STATE              DevicePowerState;

    PIRP                            CurrentPowerIrp;

    // SpinLock which protects the allocated data
    KSPIN_LOCK                      SpinLock;
    
    // Mutex to protect from overlapped changes to the configuration
    FAST_MUTEX                      ConfigMutex;

    // Device Descriptor retrieved from the device
    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    // Configuration Descriptor retrieved from the device
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigurationDescriptor;

    // Serial Number String Descriptor
    PUSB_STRING_DESCRIPTOR          SerialNumber;

    // track the number of Creates verses Closes
    ULONG                           OpenedCount;

    // A string to hold the Symbolic Link name for a device interface
    UNICODE_STRING                  DevInterfaceLinkName;

    // The Configuration Handle
    // If this value is NULL then the device is assumed to be unconfigured.
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    // a lock to track users of a configuration so that when it is deselected 
    // we won't delete the resouces too soon.
    IO_REMOVE_LOCK                  ConfigurationRemoveLock;

    // An array of Interface Information
    PGENUSB_INTERFACE             * Interface;

    // The lenght of said Interface information
    UCHAR                           InterfacesFound;
    UCHAR                           TotalNumberOfPipes;

    // The default language ID of this device
    USHORT                          LanguageId;

    // The Interface and Pipe of used for IRP_MJ_READ 
    // -1 means unconfigured
    UCHAR                           ReadInterface;
    UCHAR                           ReadPipe;
    
    // The Interface and Pipe of used for IRP_MJ_WRITE
    // -1 means unconfigured
    UCHAR                           WriteInterface;
    UCHAR                           WritePipe;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef
NTSTATUS
(*PGENUSB_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context,
    IN USBD_STATUS    UrbStatus,
    IN ULONG          TransferLength
    );

typedef struct _GENUSB_TRANS_RECV {
    
    PVOID             Context;
    PGENUSB_PIPE_INFO Pipe;
    
    PGENUSB_COMPLETION_ROUTINE              CompletionRoutine;
    struct _URB_BULK_OR_INTERRUPT_TRANSFER  TransUrb;
    struct _URB_PIPE_REQUEST                ResetUrb;

} GENUSB_TRANS_RECV, *PGENUSB_TRANS_RECV;


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// GENUSB.C
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
GenUSB_Unload (
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
GenUSB_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

VOID
GenUSB_QueryParams (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
GenUSB_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    );

NTSTATUS 
GenUSB_SetDeviceInterface (
    IN PDEVICE_EXTENSION  DeviceExtension,
    IN BOOLEAN            Create,
    IN BOOLEAN            Set
    );

NTSTATUS
GenUSB_SetDIRegValues (
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
GenUSB_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_SetPower (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP              Irp
    );

VOID
GenUSB_SetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
GenUSB_SetPowerD0Completion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
GenUSB_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
//
// USB.C
//

NTSTATUS
GenUSB_GetDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
GenUSB_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    );

GenUSB_GetStringDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
GenUSB_VendorControlRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            RequestType,
    IN UCHAR            Request,
    IN USHORT           Value,
    IN USHORT           Index,
    IN USHORT           Length,
    IN ULONG            RetryCount,
    OUT PULONG          UrbStatus,
    OUT PUSHORT         ResultLength,
    OUT PUCHAR         *Result
    );
 
NTSTATUS
GenUSB_SelectConfiguration (
    IN  PDEVICE_EXTENSION         DeviceExtension,
    IN  ULONG                     NubmerInterfaces,
    IN  PUSB_INTERFACE_DESCRIPTOR DesiredArray,
    OUT PUSB_INTERFACE_DESCRIPTOR FoundArray
    );

NTSTATUS
GenUSB_DeselectConfiguration (
    IN  PDEVICE_EXTENSION    DeviceExtension,
    IN  BOOLEAN              SendUrb
    );

NTSTATUS
GenUSB_GetSetPipe (
    IN  PDEVICE_EXTENSION          DeviceExtension,
    IN  PUCHAR                     InterfaceIndex, // Optional
    IN  PUCHAR                     InterfaceNumber, // Optional 
    IN  PUCHAR                     PipeIndex, // Optional
    IN  PUCHAR                     EndpointAddress, // Optional
    IN  PGENUSB_PIPE_PROPERTIES    SetPipeProperties, // Optional
    OUT PGENUSB_PIPE_INFORMATION   PipeInfo, // Optional
    OUT PGENUSB_PIPE_PROPERTIES    GetPipeProperties, // Optional
    OUT USBD_PIPE_HANDLE         * UsbdPipeHandle // Optional
    );

NTSTATUS
GenUSB_SetReadWritePipes (
    IN  PDEVICE_EXTENSION    DeviceExtension,
    IN  PGENUSB_PIPE_HANDLE  ReadPipe,
    IN  PGENUSB_PIPE_HANDLE  WritePipe
    );

NTSTATUS
GenUSB_RestartTimer (
    PDEVICE_EXTENSION  DeviceExtension,
    PGENUSB_PIPE_INFO  Pipe
    );
 
VOID 
GenUSB_FreeInterfaceTable (
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
GenUSB_TransmitReceive (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP              Irp,
    IN UCHAR             InterfaceNo,
    IN UCHAR             PipeNo,
    IN ULONG             TransferFlags,
    IN PCHAR             Buffer,
    IN PMDL              BufferMDL,
    IN ULONG             BufferLength,
    IN PVOID             Context,

    IN PGENUSB_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
GenUSB_ResetPipe (
    IN PDEVICE_EXTENSION  DeviceExtension,
    IN USBD_PIPE_HANDLE   UsbdPipeHandle,
    IN BOOLEAN            ResetPipe,
    IN BOOLEAN            ClearStall,
    IN BOOLEAN            FlushData
    );

VOID
GenUSB_Timer (
    PDEVICE_OBJECT DeviceObject,
    PVOID          Context
    );


#if 0

VOID
GenUSB_AdjustConfigurationDescriptor (
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    OUT PUSB_INTERFACE_DESCRIPTOR      *InterfaceDesc,
    OUT PLONG                           BulkInIndex,
    OUT PLONG                           BulkOutIndex,
    OUT PLONG                           InterruptInIndex
    );

NTSTATUS
GenUSB_GetPipes (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
GenUSB_CreateChildPDO (
    IN PDEVICE_OBJECT   FdoDeviceObject,
    IN UCHAR            Lun
    );

NTSTATUS
GenUSB_FdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
CopyField (
    IN PUCHAR   Destination,
    IN PUCHAR   Source,
    IN ULONG    Count,
    IN UCHAR    Change
    );

NTSTATUS
GenUSB_StringArrayToMultiSz(
    PUNICODE_STRING MultiString,
    PCSTR           StringArray[]
    );

NTSTATUS
GenUSB_GetMaxLun (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PUCHAR          MaxLun
    );

NTSTATUS
GenUSB_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    );


#endif

//
// OCRW.C
//

NTSTATUS
GenUSB_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_Read (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
GenUSB_Write (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
// DEVIOCTL.C
//

NTSTATUS
GenUSB_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );


NTSTATUS
GenUSB_ProbeAndSubmitTransfer (
    IN  PIRP               Irp,
    IN  PIO_STACK_LOCATION IrpSp,
    IN  PDEVICE_EXTENSION  DeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\hubpwr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    HUBPWR.C

Abstract:

    This module contains functions to handle power irps
    to the hub PDOs and FDOs.

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    7-1-97 : created

--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_SetPowerD0)
#pragma alloc_text(PAGE, USBH_SetPowerD1orD2)
#pragma alloc_text(PAGE, USBH_PdoSetPower)
#pragma alloc_text(PAGE, USBH_PdoPower)
#pragma alloc_text(PAGE, USBH_IdleCompletePowerHubWorker)
#pragma alloc_text(PAGE, USBH_CompletePortIdleIrpsWorker)
#pragma alloc_text(PAGE, USBH_CompletePortWakeIrpsWorker)
#pragma alloc_text(PAGE, USBH_HubAsyncPowerWorker)
#pragma alloc_text(PAGE, USBH_IdleCancelPowerHubWorker)
#endif
#endif


VOID
USBH_CompletePowerIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN NTSTATUS NtStatus)
 /* ++
  *
  * Description:
  *
  * This function complete the specified Irp with no priority boost. It also
  * sets up the IoStatusBlock.
  *
  * Arguments:
  *
  * Irp - the Irp to be completed by us NtStatus - the status code we want to
  * return
  *
  * Return:
  *
  * None
  *
  * -- */
{
    Irp->IoStatus.Status = NtStatus;

    PoStartNextPowerIrp(Irp);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;
}


NTSTATUS
USBH_SetPowerD3(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
/*++

Routine Description:

    Put the PDO in D3

Arguments:

    DeviceExtensionPort - port PDO deviceExtension

    Irp - Power Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    KIRQL irql;
    PIRP hubWaitWake = NULL;
    LONG pendingPortWWs;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;

    USBH_KdPrint((2,"'PdoSetPower D3\n"));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;

    LOGENTRY(LOG_PNP, "spD3", deviceExtensionHub, DeviceExtensionPort->DeviceState, 0);

    if (DeviceExtensionPort->DeviceState == PowerDeviceD3) {
        // already in D3
        USBH_KdPrint((0,"'PDO is already in D3\n"));

        ntStatus = STATUS_SUCCESS;
        goto USBH_SetPowerD3_Done;
    }

    //
    // Keep track of what PNP thinks is the current power state of the
    // port is.  Do this now so that we will refuse another WW IRP that may be
    // posted after the cancel below.
    //

    DeviceExtensionPort->DeviceState = PowerDeviceD3;

    //
    // kill our wait wake irp
    //
    // we take the cancel spinlock here to ensure our cancel routine does
    // not complete the irp for us.
    //

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {
        idleIrp = DeviceExtensionPort->IdleNotificationIrp;
        DeviceExtensionPort->IdleNotificationIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

        IoSetCancelRoutine(idleIrp, NULL);

        LOGENTRY(LOG_PNP, "IdlX", deviceExtensionHub, DeviceExtensionPort, idleIrp);
        USBH_KdPrint((1,"'PDO %x going to D3, failing idle notification request IRP %x\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject, idleIrp));
    }

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_REMOTE_WAKEUP_ENABLED) {

        LOGENTRY(LOG_PNP, "cmWW", deviceExtensionHub, DeviceExtensionPort->WaitWakeIrp, 0);

        USBH_KdPrint((1,"'Power state is incompatible with wakeup\n"));

        if (DeviceExtensionPort->WaitWakeIrp) {

            waitWakeIrp = DeviceExtensionPort->WaitWakeIrp;
            DeviceExtensionPort->WaitWakeIrp = NULL;
            DeviceExtensionPort->PortPdoFlags &=
                ~PORTPDO_REMOTE_WAKEUP_ENABLED;

            if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                waitWakeIrp = NULL;

                // Must decrement pending request count here because
                // we don't complete the IRP below and USBH_WaitWakeCancel
                // won't either because we have cleared the IRP pointer
                // in the device extension above.

                USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
            }

            pendingPortWWs =
                InterlockedDecrement(&deviceExtensionHub->NumberPortWakeIrps);

            if (0 == pendingPortWWs && deviceExtensionHub->PendingWakeIrp) {
                hubWaitWake = deviceExtensionHub->PendingWakeIrp;
                deviceExtensionHub->PendingWakeIrp = NULL;
            }
        }
    }

    //
    // Finally, release the cancel spin lock
    //
    IoReleaseCancelSpinLock(irql);

    if (idleIrp) {
        idleIrp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
    }

    if (waitWakeIrp) {
        USBH_CompletePowerIrp(deviceExtensionHub, waitWakeIrp,
            STATUS_POWER_STATE_INVALID);
    }

    //
    // If there are no more outstanding WW irps, we need to cancel the WW
    // to the hub.
    //
    if (hubWaitWake) {
        USBH_HubCancelWakeIrp(deviceExtensionHub, hubWaitWake);
    }

    //
    // first suspend the port, this will cause the
    // device to draw minimum power.
    //
    // we don't turn the port off because if we do we
    // won't be able to detect plug/unplug.
    //

    USBH_SyncSuspendPort(deviceExtensionHub,
                         portNumber);

    //
    // note that powering off the port disables connect/disconnect
    // detection by the hub and effectively removes the device from
    // the bus.
    //

    DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
    RtlCopyMemory(&DeviceExtensionPort->OldDeviceDescriptor,
                  &DeviceExtensionPort->DeviceDescriptor,
                  sizeof(DeviceExtensionPort->DeviceDescriptor));

    USBH_KdPrint((1, "'Setting HU pdo(%x) to D3, status = %x complt\n",
            DeviceExtensionPort->PortPhysicalDeviceObject, ntStatus));

USBH_SetPowerD3_Done:

    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_HubSetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent, 1, FALSE);

    ntStatus = IoStatus->Status;

    return ntStatus;
}


NTSTATUS
USBH_HubSetD0(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Set the hub to power state D0

Arguments:

    DeviceExtensionPort - Hub FDO deviceExtension

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    KEVENT event;
    POWER_STATE powerState;
    NTSTATUS ntStatus;

    rootHubDevExt = USBH_GetRootHubDevExt(DeviceExtensionHub);

    // Skip powering up the hub if the system is not at S0.

    if (rootHubDevExt->CurrentSystemPowerState != PowerSystemWorking) {
        USBH_KdPrint((1,"'HubSetD0, skip power up hub %x because system not at S0\n",
            DeviceExtensionHub));

        return STATUS_INVALID_DEVICE_STATE;
    }

    USBH_KdPrint((1,"'HubSetD0, power up hub %x\n", DeviceExtensionHub));

    LOGENTRY(LOG_PNP, "H!D0", DeviceExtensionHub,
        DeviceExtensionHub->CurrentPowerState,
        rootHubDevExt->CurrentSystemPowerState);

    // If the parent hub is currently in the process of idling out,
    // wait until that is done.

    if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->SubmitIdleEvent,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    // Now, send the actual power up request.

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    powerState.DeviceState = PowerDeviceD0;

    // Power up the hub.
    ntStatus = PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                                 IRP_MN_SET_POWER,
                                 powerState,
                                 USBH_HubSetD0Completion,
                                 &event,
                                 NULL);

    USBH_ASSERT(ntStatus == STATUS_PENDING);
    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        ntStatus = KeWaitForSingleObject(&event,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    return ntStatus;
}


NTSTATUS
USBH_SetPowerD0(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
/*++

Routine Description:

    Put the PDO in D0

Arguments:

    DeviceExtensionPort - port PDO deviceExtension

    Irp - Power Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;
    PORT_STATE state;

    PAGED_CODE();
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'PdoSetPower D0\n"));
    LOGENTRY(LOG_PNP, "P>D0", deviceExtensionHub, DeviceExtensionPort,
        DeviceExtensionPort->DeviceState);

    if (DeviceExtensionPort->DeviceState == PowerDeviceD3) {

        //
        // device was in D3, port may be off or suspended
        // we will need to reset the port state in any case
        //

        // get port state
        ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                          portNumber,
                                          (PUCHAR) &state,
                                          sizeof(state));

        // refresh our internal port state.
        portData->PortState = state;

        LOGENTRY(LOG_PNP, "PD0s", deviceExtensionHub, *((PULONG) &state), ntStatus);

        if (NT_SUCCESS(ntStatus)) {

            // port state should be suspended or OFF
            // if the hub was powered off then the port
            // state will be powered but disabled

            if ((state.PortStatus & PORT_STATUS_SUSPEND)) {
                //
                // resume the port if it was suspended
                //
                ntStatus = USBH_SyncResumePort(deviceExtensionHub,
                                               portNumber);

            } else if (!(state.PortStatus & PORT_STATUS_POWER)) {
                //
                // probably some kind of selective OFF by the device
                // driver -- we just need to power on the port
                //
                // this requires a hub with individual port power
                // switching.
                //
                ntStatus = USBH_SyncPowerOnPort(deviceExtensionHub,
                                                portNumber,
                                                TRUE);
            }

        } else {
            // the hub driver will notify thru WMI
            USBH_KdPrint((0, "'Hub failed after power change from D3\n"));
//            USBH_ASSERT(FALSE);
        }

        //
        // if port power switched on this is just like plugging
        // in the device for the first time.

        // NOTE:
        // ** the driver should know that the device needs to be
        // re-initialized since it allowed it's PDO to go in to
        // the D3 state.

        //
        // We always call restore device even though we don't need
        // to if the port was only suspended, we do this so that
        // drivers don't relay on the suspend behavior by mistake.
        //

        if (NT_SUCCESS(ntStatus)) {

            //
            // if we still have a device connected attempt to
            // restore it.
            //
            //
            // Note: we check here to see if the device object still
            // exists in case a change is asserted during the resume.
            //

            // Note also that we now ignore the connect status bit because
            // some machines (e.g. Compaq Armada 7800) are slow to power
            // up the ports on the resume and thus port status can show
            // no device connected when in fact one is.  It shouldn't
            // hurt to try to restore the device if it had been removed
            // during the suspend/hibernate.  In fact, this code handled the
            // case where the device had been swapped for another, so this
            // is really no different.

            if (portData->DeviceObject) {
                //
                // if this fails the device must have changed
                // during power off, in that case we succeed the
                // power on.
                //
                // it will be tossed on the next enumeration
                // and relaced with this new device
                //
                if (USBH_RestoreDevice(DeviceExtensionPort, TRUE) != STATUS_SUCCESS) {

                    PDEVICE_OBJECT pdo = portData->DeviceObject;

                    LOGENTRY(LOG_PNP, "PD0!", DeviceExtensionPort, 0, pdo);
                    USBH_KdPrint((1,"'Device appears to have been swapped during power off\n"));
                    USBH_KdPrint((1,"'Marking PDO %x for removal\n", portData->DeviceObject));

                    // leave ref to hub since device data wll need to be
                    // deleted on remove.
                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;

                    // track the Pdo so we know to remove it after we tell PnP it
                    // is gone
                    // device should be present if we do this
                    USBH_ASSERT(PDO_EXT(pdo)->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT);

                    InsertTailList(&deviceExtensionHub->DeletePdoList,
                                   &PDO_EXT(pdo)->DeletePdoLink);
                }
            }

            DeviceExtensionPort->DeviceState =
                irpStack->Parameters.Power.State.DeviceState;
        }

    } else if (DeviceExtensionPort->DeviceState == PowerDeviceD2 ||
               DeviceExtensionPort->DeviceState == PowerDeviceD1) {

        // get port state
        ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                          portNumber,
                                          (PUCHAR) &state,
                                          sizeof(state));

        //
        // if we got an error assume then the hub is hosed
        // just set our flag and bail
        //

        if (NT_SUCCESS(ntStatus)) {
        // see if suspeneded (according to spec). Otherwise only
        // try to resume if the port is really suspended.
        //
            if (state.PortStatus & PORT_STATUS_OVER_CURRENT) {
                //
                // overcurrent condition indicates this port
                // (and hub) are hosed

                ntStatus = STATUS_UNSUCCESSFUL;

            } else if (state.PortStatus & PORT_STATUS_SUSPEND) {

                ntStatus = USBH_SyncResumePort(deviceExtensionHub,
                                               portNumber);

            } else {
                //
                // Most OHCI controllers enable all the ports after a usb
                // resume on any port (in violation of the USB spec), in this
                // case we should detect that the port is no longer in suspend
                // and not try to resume it.
                //
                // Also, if the device where removed while suspended or the HC
                // lost power we should end up here.
                //

                ntStatus = STATUS_SUCCESS;
            }
        } else {
            USBH_KdPrint((0, "'Hub failed after power change from D2/D1\n"));
            LOGENTRY(LOG_PNP, "d0f!", deviceExtensionHub,
                0, 0);

//            USBH_ASSERT(FALSE);
        }

        //
        // port is now in D0
        //

        DeviceExtensionPort->DeviceState =
            irpStack->Parameters.Power.State.DeviceState;

        USBH_CompletePortIdleNotification(DeviceExtensionPort);

        if (NT_SUCCESS(ntStatus)) {

            if (DeviceExtensionPort->PortPdoFlags &
                PORTPDO_NEED_CLEAR_REMOTE_WAKEUP) {

                NTSTATUS status;

                //
                // disable remote wakeup
                //

                status = USBH_SyncFeatureRequest(DeviceExtensionPort->PortPhysicalDeviceObject,
                                                 USB_FEATURE_REMOTE_WAKEUP,
                                                 0,
                                                 TO_USB_DEVICE,
                                                 TRUE);

                DeviceExtensionPort->PortPdoFlags &=
                    ~PORTPDO_NEED_CLEAR_REMOTE_WAKEUP;
            }
        }
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((1,"'Set D0 Failure, status = %x\n", ntStatus));

        LOGENTRY(LOG_PNP, "d0!!", deviceExtensionHub,
                0, ntStatus);
        // we return success to PNP, we will let
        // the driver handle the fact that the
        // device has lost its brains
        //
        // NB: This can result in a redundant suspend request for this port
        // later on.  (Since if we fail here port will remain suspended,
        // but our state will indicate that we are in D0.)

        ntStatus = STATUS_SUCCESS;
    }

    DeviceExtensionPort->DeviceState =
           irpStack->Parameters.Power.State.DeviceState;

    USBH_KdPrint((1, "'Setting HU pdo(%x) to D0, status = %x  complt IRP (%x)\n",
            DeviceExtensionPort->PortPhysicalDeviceObject, ntStatus, Irp));

    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

    return ntStatus;
}


VOID
USBH_IdleCancelPowerHubWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to power up a hub on completion of an Idle request
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_PORT_IDLE_POWER_WORK_ITEM workItemIdlePower;
    PIRP irp;

    PAGED_CODE();

    workItemIdlePower = Context;

    USBH_HubSetD0(workItemIdlePower->DeviceExtensionHub);

    irp = workItemIdlePower->Irp;
    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    USBH_DEC_PENDING_IO_COUNT(workItemIdlePower->DeviceExtensionHub);
    UsbhExFreePool(workItemIdlePower);
}


VOID
USBH_PortIdleNotificationCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

    Irp - Power Irp.

Return Value:


--*/
{
    PUSBH_PORT_IDLE_POWER_WORK_ITEM workItemIdlePower;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PIRP irpToCancel = NULL;

    USBH_KdPrint((1,"'Idle notification IRP %x cancelled\n", Irp));

    deviceExtensionPort = DeviceObject->DeviceExtension;

    USBH_ASSERT(deviceExtensionPort->IdleNotificationIrp == NULL ||
                deviceExtensionPort->IdleNotificationIrp == Irp);

    deviceExtensionPort->IdleNotificationIrp = NULL;
    deviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

    if (deviceExtensionHub &&
        deviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {
        irpToCancel = deviceExtensionHub->PendingIdleIrp;
        deviceExtensionHub->PendingIdleIrp = NULL;
    } else {
        ASSERT(!deviceExtensionHub->PendingIdleIrp);
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Cancel the Idle request to the hub if there is one.
    if (irpToCancel) {
        USBH_HubCancelIdleIrp(deviceExtensionHub, irpToCancel);
    }

    // Also, power up the hub here before we complete this Idle IRP.
    //
    // (HID will start to send requests immediately upon its completion,
    // which may be before the hub's Idle IRP cancel routine is called
    // which powers up the hub.)

    if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0) {

        // Since we are at DPC we must use a work item to power up the
        // hub synchronously, because that function yields and we can't
        // yield at DPC level.

        workItemIdlePower = UsbhExAllocatePool(NonPagedPool,
                                sizeof(USBH_PORT_IDLE_POWER_WORK_ITEM));

        if (workItemIdlePower) {

            workItemIdlePower->DeviceExtensionHub = deviceExtensionHub;
            workItemIdlePower->Irp = Irp;

            ExInitializeWorkItem(&workItemIdlePower->WorkQueueItem,
                                 USBH_IdleCancelPowerHubWorker,
                                 workItemIdlePower);

            LOGENTRY(LOG_PNP, "icIT", deviceExtensionHub,
                &workItemIdlePower->WorkQueueItem, 0);

            USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
            ExQueueWorkItem(&workItemIdlePower->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_IdleCancelPowerHubWorker()
            // Don't try to access the WorkItem after it is queued.
        }

    } else {
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}


VOID
USBH_CompletePortIdleNotification(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
{
    NTSTATUS status;
    KIRQL irql;
    PIRP irp = NULL;
    PDRIVER_CANCEL oldCancelRoutine;

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {

        irp = DeviceExtensionPort->IdleNotificationIrp;

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine) {
            USBH_ASSERT(oldCancelRoutine == USBH_PortIdleNotificationCancelRoutine);
            DeviceExtensionPort->IdleNotificationIrp = NULL;
            DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;
        }
#if DBG
        else {
            USBH_ASSERT(irp->Cancel);
        }
#endif
    }

    IoReleaseCancelSpinLock(irql);

    if (irp) {
        USBH_KdPrint((1,"'Completing idle request IRP %x\n", irp));
        irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


NTSTATUS
USBH_SetPowerD1orD2(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
/*++

Routine Description:

    Put the PDO in D1/D2 ie suspend

Arguments:

    DeviceExtensionPort - port PDO deviceExtension

    Irp - Worker Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;

    USBH_KdPrint((2,"'PdoSetPower D1/D2\n"));

    if (DeviceExtensionPort->DeviceState == PowerDeviceD1  ||
        DeviceExtensionPort->DeviceState == PowerDeviceD2) {
        return STATUS_SUCCESS;
    }

    //
    // Enable the device for remote wakeup if necessary
    //

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_REMOTE_WAKEUP_ENABLED) {
        NTSTATUS status;

        status = USBH_SyncFeatureRequest(DeviceExtensionPort->PortPhysicalDeviceObject,
                                         USB_FEATURE_REMOTE_WAKEUP,
                                         0,
                                         TO_USB_DEVICE,
                                         FALSE);

        DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_CLEAR_REMOTE_WAKEUP;

#if DBG
        // With the new Selective Suspend support, people are complaining
        // about this noise.  Let's display it only if debug trace level
        // is 1 or higher.

        if (USBH_Debug_Trace_Level > 0) {
            UsbhWarning(DeviceExtensionPort,
                        "Device is Enabled for REMOTE WAKEUP\n",
                        FALSE);
        }
#endif

        // what do we do about an error here?
        // perhaps signal the waitwake irp??
    }

    ntStatus = USBH_SyncSuspendPort(deviceExtensionHub,
                                    portNumber);

    //
    // keep track of what OS thinks is the current power state of the
    // the device on this port.
    //

    DeviceExtensionPort->DeviceState =
            irpStack->Parameters.Power.State.DeviceState;

    DeviceExtensionPort->PortPdoFlags |= PORTPDO_USB_SUSPEND;

    USBH_KdPrint((2,"'DeviceExtensionPort->DeviceState = %x\n",
        DeviceExtensionPort->DeviceState));


    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((1,"'Set D1/D2 Failure, status = %x\n", ntStatus));

        // don't pass an error to PnP
        ntStatus = STATUS_SUCCESS;
    }

    USBH_KdPrint((1, "'Setting HU pdo(%x) to D%d, status = %x complt\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.DeviceState - 1,
            ntStatus));

    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_PdoQueryPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  *     Handles a power irp to a hub PDO
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;
    POWER_STATE powerState;

    PAGED_CODE();
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT( DeviceExtensionPort->PortNumber < 1000);
    portNumber = DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'USBH_PdoQueryPower pdo(%x)\n", deviceObject));

    switch (irpStack->Parameters.Power.Type) {
    case SystemPowerState:
    {
        //
        // We are currently faced with the decision to fail or allow the
        // transition to the given S power state.  In order to make an
        // informed decision, we must first calculate the maximum amount
        // of D power allowed in the given S state, and then see if this
        // conflicts with a pending Wait Wake IRP.
        //

        //
        // The maximum amount of D power allowed in this S state.
        //
        powerState.DeviceState =
            deviceExtensionHub->DeviceState[irpStack->Parameters.Power.State.SystemState];

        //
        // These tables should have already been fixed up by the root hub
        // (usbd.sys) to not contain an entry of unspecified.
        //
        ASSERT (PowerDeviceUnspecified != powerState.DeviceState);

        //
        // The presence of a pending wait wake irp together with a D state that
        // will not support waking of the machine means we should fail this
        // query.
        //
        // However, if we are going into Hibernate (or power off) then we
        // should not fail this query.
        //
        if (powerState.DeviceState == PowerDeviceD3 &&
            DeviceExtensionPort->WaitWakeIrp &&
            irpStack->Parameters.Power.State.SystemState < PowerSystemHibernate) {

            ntStatus = STATUS_UNSUCCESSFUL;
            USBH_KdPrint(
                (1, "'IRP_MJ_POWER HU pdo(%x) MN_QUERY_POWER Failing Query\n", deviceObject));
        } else {
            ntStatus = STATUS_SUCCESS;
        }

        LOGENTRY(LOG_PNP, "QPWR", DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.SystemState,
            powerState.DeviceState);

        USBH_KdPrint(
        (1, "'IRP_MJ_POWER HU pdo(%x) MN_QUERY_POWER(S%x -> D%x), complt %x\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.SystemState - 1,
            powerState.DeviceState - 1,
            ntStatus));

#if DBG
        if (!NT_SUCCESS(ntStatus)) {
            LOGENTRY(LOG_PNP, "QPW!", deviceExtensionHub,
                DeviceExtensionPort->WaitWakeIrp,
                ntStatus);
        }
#endif

        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        }
        break;

    case DevicePowerState:
        // Return success on this one or NDIS will choke on the suspend.
        ntStatus = STATUS_SUCCESS;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        break;

    default:
        TEST_TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    } /* power type */

    return ntStatus;
}


NTSTATUS
USBH_PdoSetPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  *     Handles a power irp to a hub PDO
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;

    PAGED_CODE();
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT( DeviceExtensionPort->PortNumber < 1000);
    portNumber = DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'USBH_PdoSetPower pdo(%x)\n", deviceObject));

    switch (irpStack->Parameters.Power.Type) {
    case SystemPowerState:
        {
        //
        // see if the current state of this pdo is valid for the
        // system state , if is not then we will need to set the
        // pdo to a valid D state.
        //
        ntStatus = STATUS_SUCCESS;

        USBH_KdPrint(
        (1, "'IRP_MJ_POWER HU pdo(%x) MN_SET_POWER(SystemPowerState S%x), complt\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.DeviceState - 1,
            ntStatus));

        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        }
        break;

    case DevicePowerState:
        USBH_KdPrint(
            (1, "'IRP_MJ_POWER HU pdo(%x) MN_SET_POWER(DevicePowerState D%x)\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.DeviceState - 1));
        LOGENTRY(LOG_PNP, "P>Dx", deviceExtensionHub,
             DeviceExtensionPort->PortPhysicalDeviceObject,
             irpStack->Parameters.Power.State.DeviceState);

        // If we are already in the requested power state,
        // just complete the request.

        if (DeviceExtensionPort->DeviceState ==
            irpStack->Parameters.Power.State.DeviceState) {

            // If we are skipping this set power request and it is a SetD0
            // request, assert that the parent hub is in D0.

            USBH_ASSERT(DeviceExtensionPort->DeviceState != PowerDeviceD0 ||
                deviceExtensionHub->CurrentPowerState == PowerDeviceD0);

            ntStatus = STATUS_SUCCESS;
            goto PdoSetPowerCompleteIrp;
        }

//        USBH_ASSERT(deviceExtensionHub->CurrentPowerState == PowerDeviceD0);

        switch (irpStack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:
            ntStatus = USBH_SetPowerD0(Irp, DeviceExtensionPort);
            break;
        case PowerDeviceD1:
        case PowerDeviceD2:
            ntStatus = USBH_SetPowerD1orD2(Irp, DeviceExtensionPort);
            break;
        case PowerDeviceD3:
            //
            // In the case of D3 we need to complete any pending WaitWake
            // Irps with the status code STATUS_POWER_STATE_INVALID.
            // This is done in USBH_SetPowerD3.
            //
            ntStatus = USBH_SetPowerD3(Irp, DeviceExtensionPort);
            break;
        default:
            USBH_KdTrap(("Bad Power State\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        }
        break;

    default:
        TEST_TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
PdoSetPowerCompleteIrp:
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    } /* power type */

    return ntStatus;
}


VOID
USBH_WaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    NTSTATUS ntStatus = STATUS_CANCELLED;
    LONG pendingPortWWs;
    PIRP hubWaitWake = NULL;

    USBH_KdPrint((1,"'WaitWake Irp %x for PDO cancelled\n", Irp));
    USBH_ASSERT(DeviceObject);

    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) Irp->IoStatus.Information;
    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

    LOGENTRY(LOG_PNP, "WWca", Irp, deviceExtensionPort, deviceExtensionHub);

    if (Irp != deviceExtensionPort->WaitWakeIrp) {
        //
        // Nothing to do
        // This Irp has already been taken care of.
        // We are in the process of completing this IRP in
        // USBH_HubCompletePortWakeIrps.
        //
        TEST_TRAP();
        IoReleaseCancelSpinLock(Irp->CancelIrql);

    } else {
        deviceExtensionPort->WaitWakeIrp = NULL;
        deviceExtensionPort->PortPdoFlags &=
                ~PORTPDO_REMOTE_WAKEUP_ENABLED;
        IoSetCancelRoutine(Irp, NULL);

        pendingPortWWs = InterlockedDecrement(&deviceExtensionHub->NumberPortWakeIrps);
        if (0 == pendingPortWWs && deviceExtensionHub->PendingWakeIrp) {
            // Set PendingWakeIrp to NULL since we cancel it below.
            hubWaitWake = deviceExtensionHub->PendingWakeIrp;
            deviceExtensionHub->PendingWakeIrp = NULL;
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        //
        // If there are no more outstanding WW irps, we need to cancel the WW
        // to the hub.
        //

        if (hubWaitWake) {
            USBH_HubCancelWakeIrp(deviceExtensionHub, hubWaitWake);
        }
//        else {
            // This assert is no longer valid as I now clear the PendingWakeIrp
            // pointer for the hub in USBH_FdoWaitWakeIrpCompletion, instead
            // of waiting to do it here when NumberPortWakeIrps reaches zero.
            // So it is completely normal to arrive here with no port wake
            // IRP's and a NULL PendingWakeIrp for the hub.

//            ASSERT (0 < pendingPortWWs);
//        }
    }
}


NTSTATUS
USBH_PdoWaitWake(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;
    KIRQL irql;
    PDRIVER_CANCEL oldCancel;
    LONG pendingPortWWs = 0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT( DeviceExtensionPort->PortNumber < 1000);
    portNumber = (USHORT) DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'PnP WaitWake Irp passed to PDO %x\n", deviceObject));
    LOGENTRY(LOG_PNP, "PWW_", deviceObject, DeviceExtensionPort, deviceExtensionHub);

    if (DeviceExtensionPort->DeviceState != PowerDeviceD0 ||
        deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) {

        LOGENTRY(LOG_PNP, "!WWh", DeviceExtensionPort, deviceExtensionHub, 0);

        UsbhWarning(NULL,
                    "Client driver should not be submitting WW IRPs at this time.\n",
                    TRUE);

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        return ntStatus;
    }

    //
    // First verify that there is not already a WaitWake Irp pending for
    // this PDO.
    //

    //
    // make sure that this device can support remote wakeup.
    //
    // NOTE: that we treat all hubs as capable of remote
    // wakeup regardless of what the device reports. The reason
    // is that all hubs must propagate resume signalling regardless
    // of their abilty to generate resume signalling on a
    // plug-in/out event.
    //

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_WAKE_REQUEST) {
        DeviceExtensionPort->PortPdoFlags &=
                ~PORTPDO_REMOTE_WAKEUP_SUPPORTED;
    }
#endif

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_REMOTE_WAKEUP_SUPPORTED) {

        IoAcquireCancelSpinLock(&irql);
        if (DeviceExtensionPort->WaitWakeIrp != NULL) {
            LOGENTRY(LOG_PNP, "PWWx", deviceObject, DeviceExtensionPort,
                DeviceExtensionPort->WaitWakeIrp);
            ntStatus = STATUS_DEVICE_BUSY;
            IoReleaseCancelSpinLock(irql);
            USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        } else {

            // set a cancel routine
            oldCancel = IoSetCancelRoutine(Irp, USBH_WaitWakeCancel);
            USBH_ASSERT (NULL == oldCancel);

            if (Irp->Cancel) {

                oldCancel = IoSetCancelRoutine(Irp, NULL);

                if (oldCancel) {
                    //
                    // Cancel routine hasn't fired.
                    //
                    ASSERT(oldCancel == USBH_WaitWakeCancel);

                    ntStatus = STATUS_CANCELLED;
                    IoReleaseCancelSpinLock(irql);
                    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
                } else {
                    //
                    // Cancel routine WAS called
                    //
                    IoMarkIrpPending(Irp);
                    ntStatus = Irp->IoStatus.Status = STATUS_PENDING;
                    IoReleaseCancelSpinLock(irql);
                }

            } else {

                USBH_KdPrint(
                    (1, "'enabling remote wakeup for USB device PDO (%x)\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject));

                // flag this device as "enabled for wakeup"
                DeviceExtensionPort->WaitWakeIrp = Irp;
                DeviceExtensionPort->PortPdoFlags |=
                    PORTPDO_REMOTE_WAKEUP_ENABLED;
                Irp->IoStatus.Information = (ULONG_PTR) DeviceExtensionPort;
                pendingPortWWs =
                    InterlockedIncrement(&deviceExtensionHub->NumberPortWakeIrps);
                IoMarkIrpPending(Irp);
                LOGENTRY(LOG_PNP, "PWW+", DeviceExtensionPort, Irp, pendingPortWWs);
                IoReleaseCancelSpinLock(irql);

                ntStatus = STATUS_PENDING;
            }
        }

        //
        // Now we must enable the hub for wakeup.
        //
        // We may already have a WW IRP pending if this hub were previously
        // selective suspended, but we had to power it back on (USBH_HubSetD0)
        // for a PnP request.  Don't post a new WW IRP if there is already
        // one pending.
        //
        if (ntStatus == STATUS_PENDING && 1 == pendingPortWWs &&
            !(deviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP)) {

            USBH_FdoSubmitWaitWakeIrp(deviceExtensionHub);
        }

    } else {

        ntStatus = STATUS_NOT_SUPPORTED;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    }

    return ntStatus;
}


VOID
USBH_HubAsyncPowerWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a hub ESD failure.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_HUB_ASYNC_POWER_WORK_ITEM context;
    NTSTATUS ntStatus;

    PAGED_CODE();

    context = Context;

    if (context->Irp->PendingReturned) {
        IoMarkIrpPending(context->Irp);
    }

    switch (context->MinorFunction) {

    case IRP_MN_SET_POWER:

        ntStatus = USBH_PdoSetPower(context->DeviceExtensionPort,
                                    context->Irp);
        break;

    case IRP_MN_QUERY_POWER:

        ntStatus = USBH_PdoQueryPower(context->DeviceExtensionPort,
                                      context->Irp);
        break;

    default:
        // Should never get here.
        USBH_ASSERT(FALSE);
    }

    UsbhExFreePool(context);
}


NTSTATUS
USBH_HubAsyncPowerSetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBH_HUB_ASYNC_POWER_WORK_ITEM context;
    NTSTATUS ntStatus, status;

    context = Context;

    ntStatus = IoStatus->Status;

    // We schedule the work item regardless of whether the hub power up
    // request was successful or not.

    ExInitializeWorkItem(&context->WorkQueueItem,
                         USBH_HubAsyncPowerWorker,
                         context);

    LOGENTRY(LOG_PNP, "HAPW", context->DeviceExtensionPort,
        &context->WorkQueueItem, 0);

    // critical saves time on resume
    ExQueueWorkItem(&context->WorkQueueItem,
                    CriticalWorkQueue);

    // The WorkItem is freed by USBH_HubAsyncPowerWorker()
    // Don't try to access the WorkItem after it is queued.

    return ntStatus;
}


NTSTATUS
USBH_PdoPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl Power for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    POWER_STATE powerState;
    PUSBH_HUB_ASYNC_POWER_WORK_ITEM context;

    PAGED_CODE();
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    USBH_KdPrint((2,"'USBH_PdoPower pdo(%x)\n", deviceObject));

    // special case device removed

    if (deviceExtensionHub == NULL) {
        // if there is no backpointer to the parent hub then there
        // is a delete/remove comming.  just complete this power
        // request with success

        USBH_KdPrint((1,"'complete power on orphan Pdo %x\n", deviceObject));

        if (MinorFunction == IRP_MN_SET_POWER ||
            MinorFunction == IRP_MN_QUERY_POWER) {
            Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;

            PoStartNextPowerIrp(Irp);
        } else {
            Irp->IoStatus.Status = ntStatus = STATUS_NOT_SUPPORTED;
        }

        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    USBH_ASSERT(deviceExtensionHub);

    // specail case device not in D0

    // one more item pending in the hub
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);

    // If the hub has been selectively suspended, then we need to power it up
    // to service QUERY or SET POWER requests.  However, we can't block on
    // this power IRP waiting for the parent hub to power up, so we need to
    // power up the parent hub asynchronously and handle this IRP after the
    // hub power up request has completed.  Major PITA.

    if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (MinorFunction == IRP_MN_SET_POWER ||
         MinorFunction == IRP_MN_QUERY_POWER)) {

        // Allocate buffer for context.

        context = UsbhExAllocatePool(NonPagedPool,
                    sizeof(USBH_HUB_ASYNC_POWER_WORK_ITEM));

        if (context) {
            context->DeviceExtensionPort = DeviceExtensionPort;
            context->Irp = Irp;
            context->MinorFunction = MinorFunction;

            // We'll complete this IRP in the completion routine for the hub's
            // Set D0 IRP.

            IoMarkIrpPending(Irp);

            powerState.DeviceState = PowerDeviceD0;

            // Power up the hub.
            ntStatus = PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         powerState,
                                         USBH_HubAsyncPowerSetD0Completion,
                                         context,
                                         NULL);

            // We need to return STATUS_PENDING here because we marked the
            // IRP pending above with IoMarkIrpPending.

            USBH_ASSERT(ntStatus == STATUS_PENDING);

            // In the case where an allocation failed, PoRequestPowerIrp can
            // return a status code other than STATUS_PENDING.  In this case,
            // we need to complete the IRP passed to us, but we still need
            // to return STATUS_PENDING from this routine.

            if (ntStatus != STATUS_PENDING) {
                USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
            }

            ntStatus = STATUS_PENDING;

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        }

    } else switch (MinorFunction) {

    case IRP_MN_SET_POWER:

        ntStatus = USBH_PdoSetPower(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_WAIT_WAKE:

        ntStatus = USBH_PdoWaitWake(DeviceExtensionPort, Irp);
        USBH_KdPrint((1, "'IRP_MN_WAIT_WAKE pdo(%x), status = 0x%x\n",
                      DeviceExtensionPort->PortPhysicalDeviceObject, ntStatus));
        break;

    case IRP_MN_QUERY_POWER:

        ntStatus = USBH_PdoQueryPower(DeviceExtensionPort, Irp);
        break;

    default:

        ntStatus = Irp->IoStatus.Status;

        USBH_KdPrint((1, "'IRP_MN_[%d](%x), status = 0x%x (not handled)\n",
            MinorFunction,
            DeviceExtensionPort->PortPhysicalDeviceObject,
            ntStatus));

        USBH_KdBreak(("PdoPower unknown\n"));
        //
        // return the original status passed to us
        //
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    }

    USBH_KdPrint((2,"'USBH_PdoPower pdo exit %x\n", ntStatus));

    return ntStatus;
}


VOID
USBH_SetPowerD0Worker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a Set Power D0 IRP for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_SET_POWER_D0_WORK_ITEM    workItemSetPowerD0;
    PDEVICE_EXTENSION_HUB           deviceExtensionHub;
    PIRP                            irp;
    PPORT_DATA                      portData;
    ULONG                           p, numberOfPorts;
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    workItemSetPowerD0 = Context;
    deviceExtensionHub = workItemSetPowerD0->DeviceExtensionHub;
    irp = workItemSetPowerD0->Irp;

    USBH_KdPrint((2,"'Hub Set Power D0 work item\n"));
    LOGENTRY(LOG_PNP, "HD0W", deviceExtensionHub, irp, 0);

    // restore the hub from OFF

    // the device has lost its brains, we need to go thru the
    // init process again

    // our ports will be indicating status changes at this
    // point.  We need to flush out any change indications
    // before we re-enable the hub

    // first clear out our port status info

    portData = deviceExtensionHub->PortData;

    if (portData &&
        deviceExtensionHub->HubDescriptor) {

        numberOfPorts = deviceExtensionHub->HubDescriptor->bNumberOfPorts;

        // first clear out our port status info

        for (p = 1;
             p <= numberOfPorts;
             p++, portData++) {

            portData->PortState.PortChange = 0;
            portData->PortState.PortStatus = 0;
        }
        portData = deviceExtensionHub->PortData;

        // power up the hub

        ntStatus = USBH_SyncPowerOnPorts(deviceExtensionHub);

// Probably need to enable this code for Mike Mangum's bug.
//        UsbhWait(500);  // Allow USB storage devices some time to power up.

        // flush out any change indications

        if (NT_SUCCESS(ntStatus)) {
            for (p = 1;
                 p <= numberOfPorts;
                 p++, portData++) {

                if (portData->DeviceObject) {
                    ntStatus = USBH_FlushPortChange(deviceExtensionHub,
                                                    portData->DeviceObject->DeviceExtension);
                    if (NT_ERROR(ntStatus)) {
                        LOGENTRY(LOG_PNP, "flsX", deviceExtensionHub, p,
                                    portData->DeviceObject);
                        USBH_KdPrint((1,"'USBH_FlushPortChange failed!\n"));
                    }
                }
            }
        }

        // Since we just flushed all port changes we now don't
        // know if there were any real port changes (e.g. a
        // device was unplugged).  We must call
        // IoInvalidateDeviceRelations to trigger a QBR
        // so that we can see if the devices are still there.

        USBH_IoInvalidateDeviceRelations(deviceExtensionHub->PhysicalDeviceObject,
                                         BusRelations);
    }

    if (!(deviceExtensionHub->HubFlags &
            HUBFLAG_HUB_STOPPED)) {
        USBH_SubmitInterruptTransfer(deviceExtensionHub);
    }

    // Tell ACPI that we are ready for another power IRP and complete
    // the IRP.

    irp->IoStatus.Status = ntStatus;
    PoStartNextPowerIrp(irp);
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    UsbhExFreePool(workItemSetPowerD0);
}


NTSTATUS
USBH_PowerIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;
    DEVICE_POWER_STATE oldPowerState;
    PUSBH_SET_POWER_D0_WORK_ITEM workItemSetPowerD0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ntStatus = Irp->IoStatus.Status;

    USBH_ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    LOGENTRY(LOG_PNP, "PwrC", deviceExtensionHub, Irp,
                irpStack->Parameters.Power.State.DeviceState);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (NT_SUCCESS(ntStatus)) {
        switch (irpStack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:

            oldPowerState = deviceExtensionHub->CurrentPowerState;

            deviceExtensionHub->CurrentPowerState =
               irpStack->Parameters.Power.State.DeviceState;

            deviceExtensionHub->HubFlags &= ~HUBFLAG_SET_D0_PENDING;

            if ((deviceExtensionHub->HubFlags & HUBFLAG_HIBER) &&
                 oldPowerState != PowerDeviceD3) {

                ULONG p, numberOfPorts;
                PPORT_DATA portData;
                PDEVICE_EXTENSION_PORT deviceExtensionPort;

                // we are going to d0 from hibernate, we may
                // have been in D2 but we want to always go
                // thru the D3->D0 codepath since the bus was reset.

                oldPowerState = PowerDeviceD3;

                // modify children
                numberOfPorts = deviceExtensionHub->HubDescriptor->bNumberOfPorts;
                portData = deviceExtensionHub->PortData;

                for (p = 1;
                     p <= numberOfPorts;
                     p++, portData++) {

                    if (portData->DeviceObject) {
                        deviceExtensionPort =
                            portData->DeviceObject->DeviceExtension;
                        deviceExtensionPort->DeviceState = PowerDeviceD3;

                        deviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
                    }
                }
            }

            deviceExtensionHub->HubFlags &= ~HUBFLAG_HIBER;

            if (oldPowerState == PowerDeviceD3) {
                //
                // Schedule a work item to process this.
                //
                workItemSetPowerD0 = UsbhExAllocatePool(NonPagedPool,
                                        sizeof(USBH_SET_POWER_D0_WORK_ITEM));

                if (workItemSetPowerD0) {

                    workItemSetPowerD0->DeviceExtensionHub = deviceExtensionHub;
                    workItemSetPowerD0->Irp = Irp;

                    ExInitializeWorkItem(&workItemSetPowerD0->WorkQueueItem,
                                         USBH_SetPowerD0Worker,
                                         workItemSetPowerD0);

                    LOGENTRY(LOG_PNP, "HD0Q", deviceExtensionHub,
                        &workItemSetPowerD0->WorkQueueItem, 0);

                    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
                    // critical saves time on resume
                    ExQueueWorkItem(&workItemSetPowerD0->WorkQueueItem,
                                    CriticalWorkQueue);

                    // The WorkItem is freed by USBH_SetPowerD0Worker()
                    // Don't try to access the WorkItem after it is queued.

                    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                if (!(deviceExtensionHub->HubFlags &
                        HUBFLAG_HUB_STOPPED)) {
                    USBH_SubmitInterruptTransfer(deviceExtensionHub);
                }
            }

            // If we're not going to complete the PowerDeviceD0 request later
            // in USBH_SetPowerD0Worker(), start the next power IRP here now.
            //
            if (ntStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                PoStartNextPowerIrp(Irp);
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            deviceExtensionHub->CurrentPowerState =
                irpStack->Parameters.Power.State.DeviceState;

            break;
        }

        USBH_KdPrint((1, "'Setting HU fdo(%x) to D%d, status = %x\n",
                deviceExtensionHub->FunctionalDeviceObject,
                irpStack->Parameters.Power.State.DeviceState - 1,
                ntStatus));
    } else {

        if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {
            // Don't forget to start the next power IRP if this is set D0
            // and it failed.
            PoStartNextPowerIrp(Irp);

            deviceExtensionHub->HubFlags &= ~HUBFLAG_SET_D0_PENDING;
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_FdoDeferPoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION_FDO deviceExtension;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = NULL;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpStack;

    deviceExtension = Context;
    irp = deviceExtension->PowerIrp;
    // return the status of this operation
    ntStatus = IoStatus->Status;

    USBH_KdPrint((2,"'USBH_FdoDeferPoRequestCompletion, ntStatus = %x\n",
        ntStatus));

// It is normal for the power IRP to fail if a hub was removed during
// hibernate.
//
//#if DBG
//    if (NT_ERROR(ntStatus)) {
//        USBH_KdTrap(("Device Power Irp Failed (%x)\n", ntStatus));
//    }
//#endif

    if (deviceExtension->ExtensionType == EXTENSION_TYPE_HUB) {
        deviceExtensionHub = Context;
    }

    irpStack = IoGetCurrentIrpStackLocation(irp);

    if (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking &&
        deviceExtensionHub != NULL &&
        IS_ROOT_HUB(deviceExtensionHub)) {

        // Allow selective suspend once again now that the root hub has
        // been powered up.

        LOGENTRY(LOG_PNP, "ESus", deviceExtensionHub, 0, 0);
        USBH_KdPrint((1,"'Selective Suspend possible again because Root Hub is now at D0\n"));

        // We know this is the root hub so we don't need to call
        // USBH_GetRootHubDevExt to get it.

        deviceExtensionHub->CurrentSystemPowerState =
            irpStack->Parameters.Power.State.SystemState;
    }

    USBH_KdPrint((2,"'irp = %x devobj = %x\n",
        irp, deviceExtension->TopOfStackDeviceObject));

    IoCopyCurrentIrpStackLocationToNext(irp);
    PoStartNextPowerIrp(irp);
    PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                 irp);

    return ntStatus;
}


VOID
USBH_HubQueuePortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete
    )
/*++

Routine Description:

    Called to queue all the pending child port WW IRPs of a given
    hub into a private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    PIRP irp;
    KIRQL irql;
    ULONG numberOfPorts, i;
    LONG pendingPortWWs;

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);

    numberOfPorts = hubDescriptor->bNumberOfPorts;

    InitializeListHead(IrpsToComplete);

    // First, queue all the port wake IRPs into a local list while
    // the cancel spinlock is held.  This will prevent new WW IRPs for
    // these ports from being submitted while we are traversing the list.
    // Once we have queued them all we will release the spinlock (because
    // the list no longer needs protection), then complete the IRPs.

    IoAcquireCancelSpinLock(&irql);

    for (i=0; i<numberOfPorts; i++) {

        portData = &DeviceExtensionHub->PortData[i];
        if (portData->DeviceObject) {

            deviceExtensionPort = portData->DeviceObject->DeviceExtension;

            irp = deviceExtensionPort->WaitWakeIrp;
            deviceExtensionPort->WaitWakeIrp = NULL;
            // signal the waitwake irp if we have one
            if (irp) {

                IoSetCancelRoutine(irp, NULL);

                deviceExtensionPort->PortPdoFlags &=
                    ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                pendingPortWWs =
                    InterlockedDecrement(&DeviceExtensionHub->NumberPortWakeIrps);

                InsertTailList(IrpsToComplete, &irp->Tail.Overlay.ListEntry);
            }
        }
    }

    USBH_ASSERT(DeviceExtensionHub->PendingWakeIrp == NULL);

    IoReleaseCancelSpinLock(irql);
}


VOID
USBH_HubCompleteQueuedPortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called to complete all the pending child port WW IRPs in the given
    private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PLIST_ENTRY listEntry;

    while (!IsListEmpty(IrpsToComplete)) {
        listEntry = RemoveHeadList(IrpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        USBH_KdPrint((1,"'Signaling WaitWake IRP (%x)\n", irp));
        USBH_CompletePowerIrp(DeviceExtensionHub, irp, NtStatus);
    }
}


VOID
USBH_HubCompletePortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub
    Propagates the wake irp completion to all the ports.

Arguments:

    DeviceExtensionHub

Return Value:

    The function value is the final status from the operation.

--*/
{
    LIST_ENTRY irpsToComplete;

    LOGENTRY(LOG_PNP, "pWWc", DeviceExtensionHub, NtStatus, 0);

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        // Hub has already been removed and child WW IRP's should have already
        // been completed.
        LOGENTRY(LOG_PNP, "WWcl", DeviceExtensionHub, 0, 0);

        return;
    }

    USBH_HubQueuePortWakeIrps(DeviceExtensionHub, &irpsToComplete);

    // Ok, we have queued all the port wake IRPs and have released the
    // cancel spinlock.  Let's complete all the IRPs.

    USBH_HubCompleteQueuedPortWakeIrps(DeviceExtensionHub, &irpsToComplete,
        NtStatus);
}


VOID
USBH_HubQueuePortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete
    )
/*++

Routine Description:

    Called to queue all the pending child port Idle IRPs of a given
    hub into a private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    PIRP irp;
    PDRIVER_CANCEL oldCancelRoutine;
    KIRQL irql;
    ULONG numberOfPorts, i;

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);

    numberOfPorts = hubDescriptor->bNumberOfPorts;

    InitializeListHead(IrpsToComplete);

    // First, queue all the port idle IRPs into a local list while
    // the cancel spinlock is held.  This will prevent new WW IRPs for
    // these ports from being submitted while we are traversing the list.
    // Once we have queued them all we will release the spinlock (because
    // the list no longer needs protection), then complete the IRPs.

    IoAcquireCancelSpinLock(&irql);

    for (i=0; i<numberOfPorts; i++) {

        portData = &DeviceExtensionHub->PortData[i];
        if (portData->DeviceObject) {

            deviceExtensionPort = portData->DeviceObject->DeviceExtension;

            irp = deviceExtensionPort->IdleNotificationIrp;
            deviceExtensionPort->IdleNotificationIrp = NULL;
            // Complete the Idle IRP if we have one.
            if (irp) {

                oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
                if (oldCancelRoutine) {
                    deviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

                    InsertTailList(IrpsToComplete, &irp->Tail.Overlay.ListEntry);
                }
#if DBG
                  else {
                    //
                    //  The IRP was cancelled and the cancel routine was called.
                    //  The cancel routine will dequeue and complete the IRP,
                    //  so don't do it here.

                    USBH_ASSERT(irp->Cancel);
                }
#endif
            }
        }
    }

    if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {
        irp = DeviceExtensionHub->PendingIdleIrp;
        DeviceExtensionHub->PendingIdleIrp = NULL;
    } else {
        irp = NULL;
        ASSERT(!DeviceExtensionHub->PendingIdleIrp);
    }

    IoReleaseCancelSpinLock(irql);

    if (irp) {
        USBH_HubCancelIdleIrp(DeviceExtensionHub, irp);
    }
}


VOID
USBH_HubCompleteQueuedPortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called to complete all the pending child port Idle IRPs in the given
    private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PLIST_ENTRY listEntry;

    while (!IsListEmpty(IrpsToComplete)) {
        listEntry = RemoveHeadList(IrpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        USBH_KdPrint((1,"'Completing port Idle IRP (%x)\n", irp));
        irp->IoStatus.Status = NtStatus;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


VOID
USBH_HubCompletePortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Complete all the Idle IRPs for the given hub.

Arguments:

    DeviceExtensionHub

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    PIRP irp;
    PDRIVER_CANCEL oldCancelRoutine;
    LIST_ENTRY irpsToComplete;
    PLIST_ENTRY listEntry;
    KIRQL irql;
    ULONG numberOfPorts, i;

    LOGENTRY(LOG_PNP, "pIIc", DeviceExtensionHub, NtStatus, 0);

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        // Hub has already been removed and child Idle IRP's should have already
        // been completed.

        return;
    }

    USBH_HubQueuePortIdleIrps(DeviceExtensionHub, &irpsToComplete);

    // Ok, we have queued all the port idle IRPs and have released the
    // cancel spinlock.  Let's complete all the IRPs.

    USBH_HubCompleteQueuedPortIdleIrps(DeviceExtensionHub, &irpsToComplete,
        NtStatus);
}


VOID
USBH_HubCancelWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called to cancel the pending WaitWake IRP for a hub.
    This routine safely cancels the IRP.  Note that the pending WaitWake
    IRP pointer in the hub's device extension should have been already
    cleared before calling this function.

Arguments:

    Irp - Irp to cancel.

Return Value:

--*/
{
    IoCancelIrp(Irp);

    if (InterlockedExchange(&DeviceExtensionHub->WaitWakeIrpCancelFlag, 1)) {

        // This IRP has been completed on another thread and the other thread
        // did not complete the IRP.  So, we must complete it here.
        //
        // Note that we do not use USBH_CompletePowerIrp as the hub's pending
        // I/O counter was already decremented on the other thread in the
        // completion routine.

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}


VOID
USBH_HubCancelIdleIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called to cancel the pending Idle IRP for a hub.
    This routine safely cancels the IRP.  Note that the pending Idle
    IRP pointer in the hub's device extension should have been already
    cleared before calling this function.

Arguments:

    Irp - Irp to cancel.

Return Value:

--*/
{
    IoCancelIrp(Irp);

    if (InterlockedExchange(&DeviceExtensionHub->IdleIrpCancelFlag, 1)) {

        // This IRP has been completed on another thread and the other thread
        // did not free the IRP.  So, we must free it here.

        IoFreeIrp(Irp);
    }
}


NTSTATUS
USBH_FdoPoRequestD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when the hub has entered D0 as a result of a
    wake irp completeing

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;

    ntStatus = IoStatus->Status;

    USBH_KdPrint((1,"'WaitWake D0 completion(%x) for HUB VID %x, PID %x\n",
        ntStatus,
        deviceExtensionHub->DeviceDescriptor.idVendor, \
        deviceExtensionHub->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "hWD0", deviceExtensionHub,
                              deviceExtensionHub->PendingWakeIrp,
                              0);

    // Since we can't easily determine which ports are asserting resume
    // signalling we complete the WW IRPs for all of them.
    //
    // Ken says that we will need to determine what caused the hub WW
    // to complete and then only complete the WW Irp for that port, if any.
    // It is possible for more than one port to assert WW (e.g. user bumped
    // the mouse at the same time a pressing a key), and it is also possible
    // for a port with no device to have caused the hub WW to complete (e.g.
    // device insertion or removal).

    USBH_HubCompletePortWakeIrps(deviceExtensionHub, STATUS_SUCCESS);

    // Ok to idle hub again.

    deviceExtensionHub->HubFlags &= ~HUBFLAG_WW_SET_D0_PENDING;

    // Also ok to remove hub.

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

    return ntStatus;
}


NTSTATUS
USBH_FdoWaitWakeIrpCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;

    ntStatus = IoStatus->Status;

    return ntStatus;
}


NTSTATUS
USBH_FdoWWIrpIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This is the IoCompletionRoutine for the WW IRP for the hub, not to be
    confused with the PoRequestCompletionRoutine.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;
    POWER_STATE powerState;
    KIRQL irql;
    PIRP irp;

    ntStatus = Irp->IoStatus.Status;

    USBH_KdPrint((1,"'WaitWake completion(%x) for HUB VID %x, PID %x\n",
        ntStatus,
        deviceExtensionHub->DeviceDescriptor.idVendor, \
        deviceExtensionHub->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "hWWc", deviceExtensionHub,
                              ntStatus,
                              deviceExtensionHub->PendingWakeIrp);

    // We have to clear the PendingWakeIrp pointer here because in the case
    // where a device is unplugged between here and when the port loop is
    // processed in HubCompletePortWakeIrps, we will miss one of the port
    // WW IRP's, NumberPortWakeIrps will not decrement to zero, and we will
    // not clear the PendingWakeIrp pointer.  This is bad because the IRP
    // has been completed and the pointer is no longer valid.
    //
    // Hopefully the WW IRP for the port will be completed and
    // NumberPortWakeIrps adjusted properly when the device processes MN_REMOVE.
    //
    // BUT: Make sure that we have a PendingWakeIrp first before clearing
    // because it may have already been cleared when the last port WW was
    // canceled in USBH_WaitWakeCancel.

    IoAcquireCancelSpinLock(&irql);

    // We clear the flag regardless of whether PendingWakeIrp is present or
    // not because if the WW IRP request in FdoSubmitWaitWakeIrp fails
    // immediately, PendingWakeIrp will be NULL.

    deviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
    irp = InterlockedExchangePointer(&deviceExtensionHub->PendingWakeIrp, NULL);

    // deref the hub, no wake irp is pending
    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

    IoReleaseCancelSpinLock(irql);

    if (NT_SUCCESS(ntStatus)) {

        //
        // this means that either we were the source for
        // the wakeup or a device attached to one of our
        // ports is.
        //
        // our mission now is to discover what caused the
        // wakeup
        //

        USBH_KdPrint((1,"'Remote Wakeup Detected for HUB VID %x, PID %x\n",
            deviceExtensionHub->DeviceDescriptor.idVendor, \
            deviceExtensionHub->DeviceDescriptor.idProduct));

        // Prevent idling hub until this Set D0 request completes.

        deviceExtensionHub->HubFlags |= HUBFLAG_WW_SET_D0_PENDING;

        // Also prevent hub from being removed before Set D0 is complete.

        USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);

        powerState.DeviceState = PowerDeviceD0;

        // first we need to power up the hub
        PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              USBH_FdoPoRequestD0Completion,
                              deviceExtensionHub,
                              NULL);

        ntStatus = STATUS_SUCCESS;
    } else {

        // We complete the port Wake IRPs in a workitem on another
        // thread so that we don't fail a new Wake IRP for the hub
        // which might arrive in the same context, before we've
        // finished completing the old one.

        workItemCompletePortIrps = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_COMPLETE_PORT_IRPS_WORK_ITEM));

        if (workItemCompletePortIrps) {

            workItemCompletePortIrps->DeviceExtensionHub = deviceExtensionHub;
            workItemCompletePortIrps->ntStatus = ntStatus;

            USBH_HubQueuePortWakeIrps(deviceExtensionHub,
                &workItemCompletePortIrps->IrpsToComplete);

            ExInitializeWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                                 USBH_CompletePortWakeIrpsWorker,
                                 workItemCompletePortIrps);

            LOGENTRY(LOG_PNP, "wITM", deviceExtensionHub,
                &workItemCompletePortIrps->WorkQueueItem, 0);

            USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
            // critical saves time on resume
            ExQueueWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                            CriticalWorkQueue);

            // The WorkItem is freed by USBH_CompletePortWakeIrpsWorker()
            // Don't try to access the WorkItem after it is queued.
        }
    }

    if (!irp) {

        // If we have no IRP here this means that another thread wants to
        // cancel the IRP.  Handle accordingly.

        if (!InterlockedExchange(&deviceExtensionHub->WaitWakeIrpCancelFlag, 1)) {

            // We got the cancel flag before the other thread did.  Hold
            // on to the IRP here and let the cancel routine complete it.

            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
    }

    IoMarkIrpPending(Irp);

    if (ntStatus != STATUS_MORE_PROCESSING_REQUIRED) {
        PoStartNextPowerIrp(Irp);
    }

    return ntStatus;
}


NTSTATUS
USBH_FdoSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    called when a child Pdo is enabled for wakeup, this
    function allocates a wait wake irp and passes it to
    the parents PDO.


Arguments:

Return Value:

--*/
{
    PIRP irp;
    KIRQL irql;
    NTSTATUS ntStatus;
    POWER_STATE powerState;

    USBH_ASSERT(DeviceExtensionHub->PendingWakeIrp == NULL);

    USBH_KdPrint((1,"'USBH_FdoSubmitWaitWakeIrp (%x)\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "hWW_", DeviceExtensionHub, 0, 0);

    powerState.DeviceState = DeviceExtensionHub->SystemWake;

    DeviceExtensionHub->HubFlags |= HUBFLAG_PENDING_WAKE_IRP;
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    InterlockedExchange(&DeviceExtensionHub->WaitWakeIrpCancelFlag, 0);
    ntStatus = PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                                      IRP_MN_WAIT_WAKE,
                                      powerState,
                                      USBH_FdoWaitWakeIrpCompletion,
                                      DeviceExtensionHub,
                                      &irp);

    USBH_ASSERT(ntStatus == STATUS_PENDING);

    IoAcquireCancelSpinLock(&irql);

    if (ntStatus == STATUS_PENDING) {

        // Must check flag here because in the case where the WW IRP failed
        // immediately, this flag will be cleared in the completion routine
        // and if that happens we don't want to save this IRP because it
        // will soon be invalid if it isn't already.

        if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP) {

            // Successfully posted a Wake IRP.
            // This hub is now enabled for wakeup.

            LOGENTRY(LOG_PNP, "hWW+", DeviceExtensionHub, irp, 0);
            DeviceExtensionHub->PendingWakeIrp = irp;
        }

    } else {
        USBH_ASSERT(FALSE);     // Want to know if we ever hit this.
        DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
        USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
    }

    IoReleaseCancelSpinLock(irql);

    return ntStatus;
}


VOID
USBH_FdoIdleNotificationCallback(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Called when it is time to idle out the hub device itself.

Arguments:

Return Value:

--*/
{
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    KIRQL irql;
    PIRP idleIrp;
    PIRP irpToCancel = NULL;
    POWER_STATE powerState;
    NTSTATUS ntStatus;
    ULONG i;
    BOOLEAN bIdleOk = TRUE;

    LOGENTRY(LOG_PNP, "hId!", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
    USBH_KdPrint((1,"'Hub %x going idle!\n", DeviceExtensionHub));

    if (DeviceExtensionHub->HubFlags &
        (HUBFLAG_DEVICE_STOPPING |
         HUBFLAG_HUB_GONE |
         HUBFLAG_HUB_FAILURE |
         HUBFLAG_CHILD_DELETES_PENDING |
         HUBFLAG_WW_SET_D0_PENDING |
         HUBFLAG_POST_ESD_ENUM_PENDING |
         HUBFLAG_HUB_HAS_LOST_BRAINS)) {

        // Don't idle this hub if it was just disconnected or otherwise
        // being stopped.

        LOGENTRY(LOG_PNP, "hId.", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'Hub %x being stopped, in low power, etc., abort idle\n", DeviceExtensionHub));
        return;
    }

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP)) {

        // If there is not already a WW IRP pending for the hub, submit
        // one now.  This will ensure that the hub will wakeup on connect
        // change events while it is suspended.

        ntStatus = USBH_FdoSubmitWaitWakeIrp(DeviceExtensionHub);
        if (ntStatus != STATUS_PENDING) {
            LOGENTRY(LOG_PNP, "hIdX", DeviceExtensionHub, ntStatus, 0);

            UsbhWarning(NULL,
                "Could not post WW IRP for hub, aborting IDLE.\n",
                FALSE);

            return;
        }
    }

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            USBH_KdPrint((1,"'idleCB child PDO %x\n", DeviceExtensionHub->PortData[i].DeviceObject));

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;
            idleIrp = childDeviceExtensionPort->IdleNotificationIrp;

            if (idleIrp) {
                idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
                    IoGetCurrentIrpStackLocation(idleIrp)->\
                        Parameters.DeviceIoControl.Type3InputBuffer;

                USBH_ASSERT(idleCallbackInfo && idleCallbackInfo->IdleCallback);

                if (idleCallbackInfo && idleCallbackInfo->IdleCallback) {

                    // Here we actually call the driver's callback routine,
                    // telling the driver that it is OK to suspend their
                    // device now.

                    LOGENTRY(LOG_PNP, "IdCB", childDeviceExtensionPort,
                        idleCallbackInfo, idleCallbackInfo->IdleCallback);
                    USBH_KdPrint((1,"'FdoIdleNotificationCallback: Calling driver's idle callback routine! %x %x\n",
                        idleCallbackInfo, idleCallbackInfo->IdleCallback));

                    idleCallbackInfo->IdleCallback(idleCallbackInfo->IdleContext);

                    // Be sure that the child actually powered down.
                    // This is important in the case where the child is also
                    // a hub.  Abort if the child aborted.

                    if (childDeviceExtensionPort->DeviceState == PowerDeviceD0) {

                        LOGENTRY(LOG_PNP, "IdAb", childDeviceExtensionPort,
                            idleCallbackInfo, idleCallbackInfo->IdleCallback);
                        USBH_KdPrint((1,"'FdoIdleNotificationCallback: Driver's idle callback routine did not power down! %x %x\n",
                            idleCallbackInfo, idleCallbackInfo->IdleCallback));

                        bIdleOk = FALSE;
                        break;
                    }

                } else {

                    // No callback

                    bIdleOk = FALSE;
                    break;
                }

            } else {

                // No Idle IRP

                bIdleOk = FALSE;
                break;
            }
        }
    }

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (bIdleOk) {

        // If all the port PDOs have been powered down,
        // it is time to power down the hub.

        powerState.DeviceState = DeviceExtensionHub->DeviceWake;

        PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                          IRP_MN_SET_POWER,
                          powerState,
                          NULL,
                          NULL,
                          NULL);
    } else {

        // One or more of the port PDOs did not have an Idle IRP
        // (i.e. it was just cancelled), or the Idle IRP did not have a
        // callback function pointer.  Abort this Idle procedure and cancel
        // the Idle IRP to the hub.

        LOGENTRY(LOG_PNP, "hIdA", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'Aborting Idle for Hub %x\n", DeviceExtensionHub));

        IoAcquireCancelSpinLock(&irql);

        if (DeviceExtensionHub && DeviceExtensionHub->PendingIdleIrp) {
            irpToCancel = DeviceExtensionHub->PendingIdleIrp;
            DeviceExtensionHub->PendingIdleIrp = NULL;
        }

        IoReleaseCancelSpinLock(irql);

        // Cancel the Idle request to the hub if there is one.

        if (irpToCancel) {
            USBH_HubCancelIdleIrp(DeviceExtensionHub, irpToCancel);
        }

        USBH_HubCompletePortIdleIrps(DeviceExtensionHub, STATUS_CANCELLED);
    }
}


VOID
USBH_IdleCompletePowerHubWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to power up a hub on completion of an Idle request
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_HUB_IDLE_POWER_WORK_ITEM workItemIdlePower;

    PAGED_CODE();

    workItemIdlePower = Context;

    USBH_HubSetD0(workItemIdlePower->DeviceExtensionHub);
    USBH_HubCompletePortIdleIrps(workItemIdlePower->DeviceExtensionHub,
                                 workItemIdlePower->ntStatus);

    USBH_DEC_PENDING_IO_COUNT(workItemIdlePower->DeviceExtensionHub);
    UsbhExFreePool(workItemIdlePower);
}


VOID
USBH_CompletePortIdleIrpsWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to complete the child port Idle IRPs
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;

    PAGED_CODE();

    workItemCompletePortIrps = Context;

    USBH_HubCompleteQueuedPortIdleIrps(
        workItemCompletePortIrps->DeviceExtensionHub,
        &workItemCompletePortIrps->IrpsToComplete,
        workItemCompletePortIrps->ntStatus);

    USBH_DEC_PENDING_IO_COUNT(workItemCompletePortIrps->DeviceExtensionHub);
    UsbhExFreePool(workItemCompletePortIrps);
}


VOID
USBH_CompletePortWakeIrpsWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to complete the child port Idle IRPs
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;

    PAGED_CODE();

    workItemCompletePortIrps = Context;

    USBH_HubCompleteQueuedPortWakeIrps(
        workItemCompletePortIrps->DeviceExtensionHub,
        &workItemCompletePortIrps->IrpsToComplete,
        workItemCompletePortIrps->ntStatus);

    USBH_DEC_PENDING_IO_COUNT(workItemCompletePortIrps->DeviceExtensionHub);
    UsbhExFreePool(workItemCompletePortIrps);
}


NTSTATUS
USBH_FdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Completion routine for the Idle request IRP for the hub device.

Arguments:

Return Value:

--*/
{
    PUSBH_HUB_IDLE_POWER_WORK_ITEM workItemIdlePower;
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;
    NTSTATUS ntStatus;
    KIRQL irql;
    PIRP irp;
    BOOLEAN bHoldIrp = FALSE;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    LOGENTRY(LOG_PNP, "hIdC", DeviceExtensionHub, Irp, Irp->IoStatus.Status);
    USBH_KdPrint((1,"'Idle notification IRP for hub %x completed %x\n",
            DeviceExtensionHub, Irp->IoStatus.Status));

    USBH_ASSERT(Irp->IoStatus.Status != STATUS_DEVICE_BUSY);

    IoAcquireCancelSpinLock(&irql);

    irp = InterlockedExchangePointer(&DeviceExtensionHub->PendingIdleIrp, NULL);
    DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_IDLE_IRP;
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    IoReleaseCancelSpinLock(irql);

    ntStatus = Irp->IoStatus.Status;

    // Complete port Idle IRPs w/error if hub Idle IRP failed.
    //
    // Skip this if the hub is stopping or has been removed as HubDescriptor
    // might have already been freed and FdoCleanup will complete these anyway.

    if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_POWER_STATE_INVALID) &&
        !(DeviceExtensionHub->HubFlags & (HUBFLAG_HUB_GONE | HUBFLAG_HUB_STOPPED))) {

        if (DeviceExtensionHub->CurrentPowerState != PowerDeviceD0) {

            // Since we are at DPC we must use a work item to power up the
            // hub synchronously, because that function yields and we can't
            // yield at DPC level.

            workItemIdlePower = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_HUB_IDLE_POWER_WORK_ITEM));

            if (workItemIdlePower) {

                workItemIdlePower->DeviceExtensionHub = DeviceExtensionHub;
                workItemIdlePower->ntStatus = ntStatus;

                ExInitializeWorkItem(&workItemIdlePower->WorkQueueItem,
                                     USBH_IdleCompletePowerHubWorker,
                                     workItemIdlePower);

                LOGENTRY(LOG_PNP, "iITM", DeviceExtensionHub,
                    &workItemIdlePower->WorkQueueItem, 0);

                USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
                ExQueueWorkItem(&workItemIdlePower->WorkQueueItem,
                                DelayedWorkQueue);

                // The WorkItem is freed by USBH_IdleCompletePowerHubWorker()
                // Don't try to access the WorkItem after it is queued.
            }

        } else {

            // We complete the port Idle IRPs in a workitem on another
            // thread so that we don't fail a new Idle IRP for the hub
            // which might arrive in the same context, before we've
            // finished completing the old one.

            workItemCompletePortIrps = UsbhExAllocatePool(NonPagedPool,
                                        sizeof(USBH_COMPLETE_PORT_IRPS_WORK_ITEM));

            if (workItemCompletePortIrps) {

                workItemCompletePortIrps->DeviceExtensionHub = DeviceExtensionHub;
                workItemCompletePortIrps->ntStatus = ntStatus;

                USBH_HubQueuePortIdleIrps(DeviceExtensionHub,
                    &workItemCompletePortIrps->IrpsToComplete);

                ExInitializeWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                                     USBH_CompletePortIdleIrpsWorker,
                                     workItemCompletePortIrps);

                LOGENTRY(LOG_PNP, "iIT2", DeviceExtensionHub,
                    &workItemCompletePortIrps->WorkQueueItem, 0);

                USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
                ExQueueWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                                DelayedWorkQueue);

                // The WorkItem is freed by USBH_CompletePortIdleIrpsWorker()
                // Don't try to access the WorkItem after it is queued.
            }
        }
    }

    if (!irp) {

        // If we have no IRP here this means that another thread wants to
        // cancel the IRP.  Handle accordingly.

        if (!InterlockedExchange(&DeviceExtensionHub->IdleIrpCancelFlag, 1)) {

            // We got the cancel flag before the other thread did.  Hold
            // on to the IRP here and let the cancel routine complete it.

            bHoldIrp = TRUE;
        }
    }

    // Since we allocated the IRP we must free it, but return
    // STATUS_MORE_PROCESSING_REQUIRED so the kernel does not try to touch
    // the IRP after we've freed it.

    if (!bHoldIrp) {
        IoFreeIrp(Irp);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBH_FdoSubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Called when all children PDO's are idled (or there are no children).
    This function allocates an idle request IOCTL IRP and passes it to
    the parent's PDO.

Arguments:

Return Value:

--*/
{
    PIRP irp = NULL;
    PIO_STACK_LOCATION nextStack;
    KIRQL irql;
    NTSTATUS ntStatus;

    USBH_KdPrint((1,"'USBH_FdoSubmitIdleRequestIrp %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "hId_", DeviceExtensionHub, 0, 0);

    USBH_ASSERT(DeviceExtensionHub->PendingIdleIrp == NULL);

    if (DeviceExtensionHub->PendingIdleIrp) {
        // Probably don't want to clear the flag here because an Idle IRP
        // is pending.
        LOGENTRY(LOG_PNP, "hIb_", DeviceExtensionHub, 0, 0);

        KeSetEvent(&DeviceExtensionHub->SubmitIdleEvent, 1, FALSE);
        return STATUS_DEVICE_BUSY;
    }

    DeviceExtensionHub->IdleCallbackInfo.IdleCallback = USBH_FdoIdleNotificationCallback;
    DeviceExtensionHub->IdleCallbackInfo.IdleContext = (PVOID)DeviceExtensionHub;

    irp = IoAllocateIrp(DeviceExtensionHub->PhysicalDeviceObject->StackSize,
                        FALSE);

    if (irp == NULL) {
        // Be sure to set the event and clear the flag on error before exiting.
        DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_IDLE_IRP;
        KeSetEvent(&DeviceExtensionHub->SubmitIdleEvent, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;
    nextStack->Parameters.DeviceIoControl.Type3InputBuffer = &DeviceExtensionHub->IdleCallbackInfo;
    nextStack->Parameters.DeviceIoControl.InputBufferLength = sizeof(struct _USB_IDLE_CALLBACK_INFO);

    IoSetCompletionRoutine(irp,
                           USBH_FdoIdleNotificationRequestComplete,
                           DeviceExtensionHub,
                           TRUE,
                           TRUE,
                           TRUE);


    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    InterlockedExchange(&DeviceExtensionHub->IdleIrpCancelFlag, 0);
    ntStatus = IoCallDriver(DeviceExtensionHub->PhysicalDeviceObject, irp);

    LOGENTRY(LOG_PNP, "hI>>", DeviceExtensionHub, ntStatus, 0);

    IoAcquireCancelSpinLock(&irql);

    if (ntStatus == STATUS_PENDING) {

        // Must check flag here because in the case where the Idle IRP failed
        // immediately, this flag will be cleared in the completion routine
        // and if that happens we don't want to save this IRP because it
        // will soon be invalid if it isn't already.
        LOGENTRY(LOG_PNP, "hIpp", DeviceExtensionHub, irp, 0);

        if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {

            // Successfully posted an Idle IRP.

            LOGENTRY(LOG_PNP, "hId+", DeviceExtensionHub, irp, 0);
            DeviceExtensionHub->PendingIdleIrp = irp;
        }
    }

    IoReleaseCancelSpinLock(irql);

    KeSetEvent(&DeviceExtensionHub->SubmitIdleEvent, 1, FALSE);

    return ntStatus;
}


NTSTATUS
USBH_FdoPower(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    BOOLEAN allPDOsAreOff, bHubNeedsWW;
    PPORT_DATA portData;
    ULONG i, numberOfPorts;
    KIRQL irql;
    PIRP hubWaitWake = NULL;
    POWER_STATE powerState;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;
    USBH_KdPrint((2,"'Power Request, FDO %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
        //
        // Pass it down to Pdo to handle these
        //
    case IRP_MN_SET_POWER:

        //
        // Hub is being asked to change power state
        //

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            {
            POWER_STATE powerState;

            LOGENTRY(LOG_PNP, "sysP", DeviceExtensionHub,
                     DeviceExtensionHub->FunctionalDeviceObject,
                     0);

            // Track the current system power state in the hub's device ext.
            // Note that we only set this back to S0 (i.e. allow selective
            // suspend once again) once the root hub is fully powered up.

            if (irpStack->Parameters.Power.State.SystemState != PowerSystemWorking) {

                LOGENTRY(LOG_PNP, "DSus", DeviceExtensionHub, 0, 0);
                USBH_KdPrint((1,"'Selective Suspend disabled because system is suspending\n"));

                rootHubDevExt = USBH_GetRootHubDevExt(DeviceExtensionHub);

                rootHubDevExt->CurrentSystemPowerState =
                    irpStack->Parameters.Power.State.SystemState;
            }

            if (irpStack->Parameters.Power.State.SystemState ==
                PowerSystemHibernate) {
                DeviceExtensionHub->HubFlags |= HUBFLAG_HIBER;
                     USBH_KdPrint((1, "'Hibernate Detected\n"));
                     //TEST_TRAP();
            }

            // map the system state to the appropriate D state.
            // our policy is:
            //      if we are enabled for wakeup -- go to D2
            //      else go to D3

            USBH_KdPrint(
                (1, "'IRP_MJ_POWER HU fdo(%x) MN_SET_POWER(SystemPowerState S%x)\n",
                    DeviceExtensionHub->FunctionalDeviceObject,
                    irpStack->Parameters.Power.State.SystemState - 1));

            //
            // walk are list of PDOs, if all are in D3 yje set the
            // allPDOsAreOff flag

            allPDOsAreOff = TRUE;
            portData = DeviceExtensionHub->PortData;

            //
            // NOTE: if we are stopped the HubDescriptor will be NULL
            //

            if (portData &&
                DeviceExtensionHub->HubDescriptor) {
                numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

                for (i=0; i < numberOfPorts; i++) {
                    PDEVICE_EXTENSION_PORT deviceExtensionPort;

                    LOGENTRY(LOG_PNP, "cPRT", portData->DeviceObject,
                          0,
                          0);

                    if (portData->DeviceObject) {
                        deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                        if (deviceExtensionPort->DeviceState != PowerDeviceD3) {
                            allPDOsAreOff = FALSE;
                            break;
                        }
                    }
                    portData++;
                }

#if DBG
                // if all PDOs are in D3 then this means the hub itself is a
                // wakeup source
                if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP) {
                    if (allPDOsAreOff) {
                        USBH_KdPrint(
                           (1, "'**Hub enabled for wakeup -- hub is only potential wakeup source\n"));
                    } else {
                         USBH_KdPrint(
                           (1, "'**Hub enabled for wakeup -- device is potential wakeup source\n"));
                    }
                }
#endif
            }

            if (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking) {
                //
                // go to ON
                //
                powerState.DeviceState = PowerDeviceD0;
                LOGENTRY(LOG_PNP, "syON", 0,
                          0,
                          0);

            } else if ((DeviceExtensionHub->HubFlags &
                            HUBFLAG_PENDING_WAKE_IRP) ||
                        !allPDOsAreOff) {

                //
                // based on the system power state
                // request a setting to the appropriate
                // Dx state.
                //
                // all low power states have already been mapped
                // to suspend

                powerState.DeviceState =
                    DeviceExtensionHub->DeviceState[irpStack->Parameters.Power.State.SystemState];

                //
                // These tables should have already been fixed up by the root hub
                // (usbd.sys) to not contain an entry of unspecified.
                //
                ASSERT (PowerDeviceUnspecified != powerState.DeviceState);

                LOGENTRY(LOG_PNP, "syDX", powerState.DeviceState,
                          0,
                          0);
                USBH_KdPrint((1,"'System state maps to device state 0x%x (D%x)\n",
                    powerState.DeviceState,
                    powerState.DeviceState - 1));

            } else {
                powerState.DeviceState = PowerDeviceD3;
                LOGENTRY(LOG_PNP, "syD3", powerState.DeviceState,
                          0,
                          0);
            }

            //
            // only make the request if it is for a different power
            // state then the one we are in, and it is a valid state for the
            // request.  Also, make sure the hub has been started.
            //

            LOGENTRY(LOG_PNP, "H>Sx", DeviceExtensionHub,
                     DeviceExtensionHub->FunctionalDeviceObject,
                     powerState.DeviceState);

            if (powerState.DeviceState != PowerDeviceUnspecified &&
                powerState.DeviceState != DeviceExtensionHub->CurrentPowerState &&
                (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

                DeviceExtensionHub->PowerIrp = Irp;
                IoMarkIrpPending(Irp);

                ntStatus = PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                                             IRP_MN_SET_POWER,
                                             powerState,
                                             USBH_FdoDeferPoRequestCompletion,
                                             DeviceExtensionHub,
                                             NULL);

                USBH_KdPrint((2,"'PoRequestPowerIrp returned 0x%x\n", ntStatus));

                // We need to return STATUS_PENDING here because we marked the
                // IRP pending above with IoMarkIrpPending.

                USBH_ASSERT(ntStatus == STATUS_PENDING);

                // In the case where an allocation failed, PoRequestPowerIrp
                // can return a status code other than STATUS_PENDING.  In this
                // case, we still need to pass the IRP down to the lower driver,
                // but we still need to return STATUS_PENDING from this routine.

                if (ntStatus != STATUS_PENDING) {
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    PoStartNextPowerIrp(Irp);
                    ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                            Irp);
                }

                ntStatus = STATUS_PENDING;

            } else {

                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                        Irp);
            }
            }
            break; //SystemPowerState

        case DevicePowerState:

            USBH_KdPrint(
                (1, "'IRP_MJ_POWER HU fdo(%x) MN_SET_POWER(DevicePowerState D%x)\n",
                    DeviceExtensionHub->FunctionalDeviceObject,
                    irpStack->Parameters.Power.State.DeviceState - 1));

            LOGENTRY(LOG_PNP, "H>Dx", DeviceExtensionHub,
                     DeviceExtensionHub->FunctionalDeviceObject,
                     irpStack->Parameters.Power.State.DeviceState);

            // If we are already in the requested power state, or if this is
            // a Set D0 request and we already have one pending,
            // just pass the request on.

            if ((DeviceExtensionHub->CurrentPowerState ==
                irpStack->Parameters.Power.State.DeviceState) ||
                (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0 &&
                 (DeviceExtensionHub->HubFlags & HUBFLAG_SET_D0_PENDING))) {

                LOGENTRY(LOG_PNP, "HDxP", DeviceExtensionHub, 0, 0);

                IoCopyCurrentIrpStackLocationToNext(Irp);

                PoStartNextPowerIrp(Irp);

                IoMarkIrpPending(Irp);
                PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                             Irp);

                ntStatus = STATUS_PENDING;

                break;
            }

            switch (irpStack->Parameters.Power.State.DeviceState) {

            case PowerDeviceD0:

                USBH_ASSERT(DeviceExtensionHub->CurrentPowerState != PowerDeviceD0);

                DeviceExtensionHub->HubFlags &=
                    ~(HUBFLAG_DEVICE_STOPPING | HUBFLAG_DEVICE_LOW_POWER);
                DeviceExtensionHub->HubFlags |= HUBFLAG_SET_D0_PENDING;

                //
                // must pass this on to our PDO
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       USBH_PowerIrpCompletion,
                                       DeviceExtensionHub,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                IoMarkIrpPending(Irp);
                PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                             Irp);

                // For some strange PnP reason, we have to return
                // STATUS_PENDING here if our completion routine will also
                // pend (e.g. return STATUS_MORE_PROCESSING_REQUIRED).
                // (Ignore the PoCallDriver return value.)

                ntStatus = STATUS_PENDING;

                break;

            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:

                // If there is a ChangeIndicationWorkitem pending, then we
                // must wait for that to complete.

                if (DeviceExtensionHub->ChangeIndicationWorkitemPending) {

                    USBH_KdPrint((2,"'Wait for single object\n"));

                    ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->CWKEvent,
                                                     Suspended,
                                                     KernelMode,
                                                     FALSE,
                                                     NULL);

                    USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
                }

                //
                // set our stop flag so that ChangeIndication does not submit
                // any more transfers
                //
                // note that we skip this if the hub is 'stopped'

                if (!(DeviceExtensionHub->HubFlags &
                        HUBFLAG_HUB_STOPPED)) {

                    NTSTATUS status;
                    BOOLEAN bRet;

                    DeviceExtensionHub->HubFlags |=
                        (HUBFLAG_DEVICE_STOPPING | HUBFLAG_DEVICE_LOW_POWER);

                    bRet = IoCancelIrp(DeviceExtensionHub->Irp);



                    // always wait -- this fixes a bosd on an IBM laptop
                    // the if was a hack someone put in but we have no idea why
                    // if (bRet) {
                    LOGENTRY(LOG_PNP, "aWAT", DeviceExtensionHub,
                            &DeviceExtensionHub->AbortEvent,  bRet);

                    status = KeWaitForSingleObject(
                               &DeviceExtensionHub->AbortEvent,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL);

                    LOGENTRY(LOG_PNP, "awat", DeviceExtensionHub,
                            0,  status);


                }

                //
                // must pass this on to our PDO
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       USBH_PowerIrpCompletion,
                                       DeviceExtensionHub,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                PoStartNextPowerIrp(Irp);
                IoMarkIrpPending(Irp);
                PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                             Irp);
                // toss status and return status pending
                // we do this because our completion routine
                // stalls completion but we do not block here
                // in dispatch.
                // OS code only waits if status_pending is returned
                ntStatus = STATUS_PENDING;
                break;
            }

            break; //DevicePowerState
        }

        break; // MN_SET_POWER

    case IRP_MN_QUERY_POWER:

        USBH_KdPrint((1, "'IRP_MJ_POWER HU fdo(%x) MN_QUERY_POWER\n",
            DeviceExtensionHub->FunctionalDeviceObject));

        // Cancel our WW IRP if we are going to D3, the hub is idled
        // (selectively suspended), and the hub is empty.  We don't want
        // to prevent going to D3 if the hub is selectively suspended and
        // there are no children that would require the hub be wake-enabled.

        powerState.DeviceState =
            DeviceExtensionHub->DeviceState[irpStack->Parameters.Power.State.SystemState];

        bHubNeedsWW = USBH_DoesHubNeedWaitWake(DeviceExtensionHub);

        IoAcquireCancelSpinLock(&irql);

        if (powerState.DeviceState == PowerDeviceD3 &&
            DeviceExtensionHub->PendingWakeIrp &&
            !bHubNeedsWW) {

            hubWaitWake = DeviceExtensionHub->PendingWakeIrp;
            DeviceExtensionHub->PendingWakeIrp = NULL;
        }

        IoReleaseCancelSpinLock(irql);

        if (hubWaitWake) {
            USBH_KdPrint((1, "'Cancelling hub's WW because we are going to D3 and there are no children\n"));

            USBH_HubCancelWakeIrp(DeviceExtensionHub, hubWaitWake);
        }

        //
        // Now pass this on to our PDO.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                Irp);

        break;

    case IRP_MN_WAIT_WAKE:

        USBH_KdPrint((1, "'IRP_MJ_POWER HU fdo(%x) MN_WAIT_WAKE\n",
            DeviceExtensionHub->FunctionalDeviceObject));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                               USBH_FdoWWIrpIoCompletion,
                               DeviceExtensionHub,
                               TRUE,
                               TRUE,
                               TRUE);

        PoStartNextPowerIrp(Irp);
        IoMarkIrpPending(Irp);
        PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                     Irp);

        // For some strange PnP reason, we have to return
        // STATUS_PENDING here if our completion routine will also
        // pend (e.g. return STATUS_MORE_PROCESSING_REQUIRED).
        // (Ignore the PoCallDriver return value.)

        ntStatus = STATUS_PENDING;
        break;

        //
        // otherwise pass the Irp down
        //

    default:

        USBH_KdPrint((2,"'Unhandled Power request to fdo %x  %x, passed to PDO\n",
                          deviceObject, MinorFunction));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                Irp);

        break;
    }

    USBH_KdPrint((2,"'FdoPower exit %x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\ioctli.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    IOCTLI.C

Abstract:

    This module implements usb IOCTL requests to usb hub.

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    1-2-97 : re-wriiten

--*/

/*

//
// ** User mode IOCTLS **
//

//
// IOCTL_USB_GET_NODE_INFORMATION
//

input:
None

output:
outputbufferlength = sizeof(USB_BUS_NODE_INFORMATION)
outputbuffer = filled in with USB_BUS_NODE_INFORMATION structure.

//
// IOCTL_USB_GET_NODE_CONNECTION_INFORMATION
//

input:
inputbufferlength = size of user supplied buffer
inpubuffer =  ptr to USB_NODE_CONNECTION_INFORMATION structure with
    connectionIndex set to the requested connection.

output:
outputbufferlength = size of user supplied buffer
outputbuffer = filled in with USB_NODE_CONNECTION_INFORMATION structure.

//
// IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION
//

input:
inputbufferlength = size of user supplied buffer.
inputbuffer = ptr to USB_DESCRIPTOR_REQUEST, includes setup packet
                and connection index.

output:
outputbufferlength = length of descriptor data plus sizeof sizeof(USB_DESCRIPTOR_REQUEST).
outputbuffer = ptr to USB_DESCRIPTOR_REQUEST filled in with returned data.

//
// ** Internal IOCTLS **
//

//
// IOCTL_INTERNAL_USB_RESET_PORT
//

*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmistr.h>
#include <wdmguid.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_IoctlGetNodeInformation)
#pragma alloc_text(PAGE, USBH_IoctlGetHubCapabilities)
#pragma alloc_text(PAGE, USBH_IoctlGetNodeConnectionInformation)
#pragma alloc_text(PAGE, USBH_IoctlGetNodeConnectionDriverKeyName)
#pragma alloc_text(PAGE, USBH_IoctlGetNodeName)
#pragma alloc_text(PAGE, USBH_PdoIoctlGetPortStatus)
#pragma alloc_text(PAGE, USBH_PdoIoctlEnablePort)
#pragma alloc_text(PAGE, USBH_IoctlGetDescriptorForPDO)
#pragma alloc_text(PAGE, USBH_SystemControl)
#pragma alloc_text(PAGE, USBH_PortSystemControl)
#pragma alloc_text(PAGE, USBH_ExecuteWmiMethod)
#pragma alloc_text(PAGE, USBH_QueryWmiRegInfo)
#pragma alloc_text(PAGE, USBH_CheckLeafHubsIdle)
#endif
#endif

NTSTATUS
USBH_IoctlGetNodeInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_INFORMATION outputBuffer;
    ULONG outputBufferLength;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeInformation\n"));

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBuffer = (PUSB_NODE_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;

    RtlZeroMemory(outputBuffer, outputBufferLength);

    if (outputBufferLength >= sizeof(USB_NODE_INFORMATION)) {

        //
        // for now everything is a hub
        //

        outputBuffer->NodeType = UsbHub;
        RtlCopyMemory(&outputBuffer->u.HubInformation.HubDescriptor,
                      DeviceExtensionHub->HubDescriptor,
                      sizeof(*DeviceExtensionHub->HubDescriptor));

        // 100 milliamps/port means bus powered
        outputBuffer->u.HubInformation.HubIsBusPowered =
            USBH_HubIsBusPowered(DeviceExtensionHub->FunctionalDeviceObject,
                                 DeviceExtensionHub->ConfigurationDescriptor);

        Irp->IoStatus.Information = sizeof(USB_NODE_INFORMATION);
    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlCycleHubPort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PULONG buffer;
    ULONG bufferLength;
    ULONG port;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlCycleHubPort\n"));

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and its length.
    //

    buffer = (PULONG) Irp->AssociatedIrp.SystemBuffer;
    bufferLength = ioStack->Parameters.DeviceIoControl.InputBufferLength;

    if (bufferLength < sizeof(port)) {    
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBH_IoctlCycleHubPort_Done;
    } 

    // port number is input only
    port = *buffer;
    Irp->IoStatus.Information = 0;

    USBH_KdPrint((1,"'Request Cycle Port %d\n", port));

    if (port <= DeviceExtensionHub->HubDescriptor->bNumberOfPorts && 
        port > 0) {
    
        PPORT_DATA portData;
        PDEVICE_EXTENSION_PORT deviceExtensionPort;

        portData = &DeviceExtensionHub->PortData[port-1];
        if (portData->DeviceObject) {
            deviceExtensionPort = portData->DeviceObject->DeviceExtension;
            
            USBH_InternalCyclePort(DeviceExtensionHub, 
                                   (USHORT) port,
                                   deviceExtensionPort);
        } else {
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        USBH_KdPrint((1,"'Cycle Port %d %x\n", port, ntStatus));
    }
    
USBH_IoctlCycleHubPort_Done:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetHubCapabilities(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_HUB_CAPABILITIES outputBuffer;
    ULONG outputBufferLength, copyLen;
    USB_HUB_CAPABILITIES localBuffer;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetHubCapabilities\n"));

    RtlZeroMemory(&localBuffer, sizeof(USB_HUB_CAPABILITIES));

    // Fill in the data in the local buffer first, then copy as much of
    // this data to the user's buffer as requested (as indicated by the
    // size of the request buffer).

    localBuffer.HubIs2xCapable =
        (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) ? 1:0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and its length.
    //
    

    outputBuffer = (PUSB_HUB_CAPABILITIES) Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (outputBufferLength <= sizeof(localBuffer)) {
        copyLen = outputBufferLength;
    } else {
        copyLen = sizeof(localBuffer);
    }

    // zero buffer passed in
    RtlZeroMemory(outputBuffer,
                  outputBufferLength);

    // Only give the user the amount of data that they ask for
    // this may only be part of our info strucure

    RtlCopyMemory(outputBuffer,
                  &localBuffer,
                  copyLen);

    Irp->IoStatus.Information = copyLen;

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetNodeConnectionDriverKeyName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * ConnectionIndex - The one-based port index to which a device is attached.
  * The devnode name of the will be returned, if there is sufficient buffer space.
  *
  * ActualLength - The structure size in bytes necessary to hold the NULL
  * terminated name.  This includes the entire structure, not
  * just the name.
  *
  * NodeName - The UNICODE NULL terminated name of the devnode for the device
  * attached to this port.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_CONNECTION_DRIVERKEY_NAME outputBuffer;
    ULONG outputBufferLength, length, i;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeConnectionDriverKeyName\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_DRIVERKEY_NAME) Irp->AssociatedIrp.SystemBuffer;

    // find the PDO

    if (outputBufferLength >= sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME)) {
        USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));

        ntStatus = STATUS_INVALID_PARAMETER;

        for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            if (i == outputBuffer->ConnectionIndex) {

                portData = &DeviceExtensionHub->PortData[outputBuffer->ConnectionIndex - 1];

                if (portData->DeviceObject) {

                    deviceExtensionPort = portData->DeviceObject->DeviceExtension;

                    // Validate the PDO for PnP purposes.  (PnP will bugcheck
                    // if passed a not-quite-initialized PDO.)

                    if (deviceExtensionPort->PortPdoFlags &
                        PORTPDO_VALID_FOR_PNP_FUNCTION) {

                        // we have the PDO, now attempt to
                        // get the devnode name and return it

                        length = outputBufferLength -
                                    sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME);
                        USBH_KdPrint((1,"'Get DKN length = %d\n", length));

                        ntStatus = IoGetDeviceProperty(
                            portData->DeviceObject,
                            DevicePropertyDriverKeyName,
                            length,
                            outputBuffer->DriverKeyName,
                            &length);

                        USBH_KdPrint((1,"'Get DKN prop length = %d %x\n", 
                            length, ntStatus));
                            

                        if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                            ntStatus = STATUS_SUCCESS;
                        }

                        outputBuffer->ActualLength =
                            length + sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME);

                        USBH_KdPrint((1,"'DKN actual length = %d \n", 
                            outputBuffer->ActualLength));
                                                    

                        // see how much data we actully copied
                        if (outputBufferLength >= outputBuffer->ActualLength) {
                            // user buffer is bigger, just indicate how much we copied
                            Irp->IoStatus.Information = outputBuffer->ActualLength;

                        } else {
                            // it is not clear that IoGetDeviceProperty
                            // returns anything in the case of BUFFER_TOO_SMALL
                            // so to avoid returning unitialized memory we will 
                            // just return the structure passed in 
                            outputBuffer->DriverKeyName[0] = 0;
                            
                            Irp->IoStatus.Information = 
                                sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME);
                        }

                    } else {
                        ntStatus = STATUS_INVALID_DEVICE_STATE;
                    }
                }
            }
        }
    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetNodeConnectionInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN BOOLEAN ExApi
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_CONNECTION_INFORMATION_EX outputBuffer;
    ULONG outputBufferLength, length, i;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeConnectionInformation\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

    if (outputBufferLength >= sizeof(USB_NODE_CONNECTION_INFORMATION)) {

        ULONG index;

        USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));


        // Clear the buffer in case we don't call USBD_GetDeviceInformation
        // below, but make sure to keep the ConnectionIndex!

        index = outputBuffer->ConnectionIndex;
        RtlZeroMemory(outputBuffer, outputBufferLength);
        outputBuffer->ConnectionIndex = index;

        ntStatus = STATUS_INVALID_PARAMETER;

        for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            if (i == outputBuffer->ConnectionIndex) {
                length = sizeof(USB_NODE_CONNECTION_INFORMATION);

                if (portData->DeviceObject) {

                    deviceExtensionPort = portData->DeviceObject->DeviceExtension;

                    outputBuffer->ConnectionStatus =
                        portData->ConnectionStatus;

                    outputBuffer->DeviceIsHub =
                        (deviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB)
                            ? TRUE : FALSE;
                    USBH_KdPrint((2,"'outputbuffer = %x\n", outputBuffer));

                    RtlCopyMemory(&outputBuffer->DeviceDescriptor,
                                  &deviceExtensionPort->DeviceDescriptor,
                                  sizeof(outputBuffer->DeviceDescriptor));

                    if (deviceExtensionPort->DeviceData) {
#ifdef USB2
                        USBH_KdPrint((2,"'devicedata = %x\n",
                            deviceExtensionPort->DeviceData));

                        ntStatus = USBD_GetDeviceInformationEx(
                                         deviceExtensionPort,
                                         DeviceExtensionHub,
                                         outputBuffer,
                                         outputBufferLength,
                                         deviceExtensionPort->DeviceData);
#else
                        ntStatus = USBD_GetDeviceInformation(outputBuffer,
                                         outputBufferLength,
                                         deviceExtensionPort->DeviceData);
#endif
                    } else {
                        //
                        // We have a device connected, but it failed to start.
                        // Since it hasn't started, there are no open pipes, so
                        // we don't need to get pipe information. We are going
                        // to return some relevant information, however, so
                        // return STATUS_SUCCESS.
                        //

                        ntStatus = STATUS_SUCCESS;
                    }

                    USBH_KdPrint((2,"'status from USBD_GetDeviceInformation %x\n",
                            ntStatus));

                    if (NT_SUCCESS(ntStatus)) {
                        ULONG j;

                        USBH_KdPrint((2,"'status %x \n", outputBuffer->ConnectionStatus));
    //                    USBH_KdPrint((2,"'NodeName %s\n", outputBuffer->NodeName));
                        USBH_KdPrint((2,"'PID 0x%x\n",
                            outputBuffer->DeviceDescriptor.idProduct));
                        USBH_KdPrint((2,"'VID 0x%x\n",
                            outputBuffer->DeviceDescriptor.idVendor));
                        USBH_KdPrint((2,"'Current Configuration Value 0x%x\n",
                            outputBuffer->CurrentConfigurationValue));

                        // map the speed field for the old API which returned 
                        // a BOOLEAN
                        if (!ExApi) {  
                            PUSB_NODE_CONNECTION_INFORMATION tmp =
                                (PUSB_NODE_CONNECTION_INFORMATION) outputBuffer;

                            tmp->LowSpeed = (outputBuffer->Speed == UsbLowSpeed) 
                                ? TRUE : FALSE;
                        }

                        USBH_KdPrint((2,"'Speed = %x\n", outputBuffer->Speed));
                        USBH_KdPrint((2,"'Address = %x\n", outputBuffer->DeviceAddress));

                        USBH_KdPrint((2,"'NumberOfOpenPipes = %d\n",
                            outputBuffer->NumberOfOpenPipes));

                        for(j=0; j< outputBuffer->NumberOfOpenPipes; j++) {
                            USBH_KdPrint((2,"'Max Packet %x\n",
                                outputBuffer->PipeList[j].EndpointDescriptor.wMaxPacketSize));
                            USBH_KdPrint((2,"'Interval %x \n",
                                outputBuffer->PipeList[j].EndpointDescriptor.bInterval));
                        }

                        Irp->IoStatus.Information =
                            sizeof(USB_NODE_CONNECTION_INFORMATION) +
                            sizeof(USB_PIPE_INFO) * outputBuffer->NumberOfOpenPipes;
                    } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                        Irp->IoStatus.Information =
                            sizeof(USB_NODE_CONNECTION_INFORMATION);
                        ntStatus = STATUS_SUCCESS;
                    }


                } else { //no device object

//                  This assert is no longer valid because we now support
//                  displaying the UI on device enumeration failure.
//
//                    USBH_ASSERT(portData->ConnectionStatus == NoDeviceConnected ||
//                                portData->ConnectionStatus == DeviceCausedOvercurrent);
                    outputBuffer->ConnectionStatus = portData->ConnectionStatus;
                    Irp->IoStatus.Information =
                        sizeof(USB_NODE_CONNECTION_INFORMATION);
                    ntStatus = STATUS_SUCCESS;
                }

                break;
            }

            portData++;
        } /* for */

    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}

NTSTATUS
USBH_IoctlGetNodeConnectionAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_CONNECTION_ATTRIBUTES outputBuffer;
    ULONG outputBufferLength, length, i;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeConnectionInformation\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer;

    if (outputBufferLength >= sizeof(USB_NODE_CONNECTION_ATTRIBUTES)) {

        ULONG index;

        USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));

        // Clear the buffer in case we don't call USBD_GetDeviceInformation
        // below, but make sure to keep the ConnectionIndex!

        index = outputBuffer->ConnectionIndex;
        RtlZeroMemory(outputBuffer, outputBufferLength);
        outputBuffer->ConnectionIndex = index;

        ntStatus = STATUS_INVALID_PARAMETER;

        for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

            if (i == outputBuffer->ConnectionIndex) {

                length = sizeof(USB_NODE_CONNECTION_ATTRIBUTES);

                outputBuffer->ConnectionStatus =
                    portData->ConnectionStatus;

                USBH_KdPrint((2,"'outputbuffer = %x\n", outputBuffer));

                // map extended hub info here
                outputBuffer->PortAttributes = portData->PortAttributes;

                Irp->IoStatus.Information =
                            sizeof(USB_NODE_CONNECTION_ATTRIBUTES);
                ntStatus = STATUS_SUCCESS;

                break;
            }

            portData++;
        } /* for */

    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlHubSymbolicName(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Takes as input and output a pointer to the following structure:
  *
  * typedef struct _USB_HUB_NAME {
  *     ULONG ActualLength;    // OUTPUT
  *     WCHAR HubName[1];      // OUTPUT
  * } USB_HUB_NAME;
  *
  * Arguments:
  *
  * ActualLength - The structure size in bytes necessary to hold the NULL
  * terminated symbolic link name.  This includes the entire structure, not
  * just the name.
  *
  * NodeName - The UNICODE NULL terminated symbolic link name of the external
  * hub attached to the port.  If there is no external hub attached to the port
  * a single NULL is returned.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          ioStack;
    PUSB_HUB_NAME               outputBuffer;
    ULONG                       outputBufferLength;

    PAGED_CODE();

    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the pointer to the input/output buffer and it's length
    //
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;

    outputBuffer = (PUSB_HUB_NAME) Irp->AssociatedIrp.SystemBuffer;

    // Make sure that the output buffer is large enough for the base
    // structure that will be returned.
    //
    if (outputBufferLength < sizeof(USB_HUB_NAME)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto GetHubDone;
    }

    if ((DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) &&
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) &&
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK)) {

        PUNICODE_STRING hubNameUnicodeString;
        ULONG length, offset=0;
        WCHAR *pwch;


        // Device is a hub, get the name of the hub
        //
        hubNameUnicodeString = &DeviceExtensionPort->SymbolicLinkName;

        // assuming the string is \n\name strip of '\n\' where
        // n is zero or more chars

        pwch = &hubNameUnicodeString->Buffer[0];

        USBH_ASSERT(*pwch == '\\');
        if (*pwch == '\\') {
            pwch++;
            while (*pwch != '\\' && *pwch) {
                pwch++;
            }
            USBH_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
            }
            offset = (ULONG)((PUCHAR)pwch -
                (PUCHAR)&hubNameUnicodeString->Buffer[0]);
        }

        // Strip off the '\DosDevices\' prefix.
        // Length does not include a terminating NULL.
        //
        length = hubNameUnicodeString->Length - offset;
        RtlZeroMemory(outputBuffer, outputBufferLength);

        if (outputBufferLength >= length +
            sizeof(USB_HUB_NAME)) {
            RtlCopyMemory(&outputBuffer->HubName[0],
                          &hubNameUnicodeString->Buffer[offset/2],
                          length);

            Irp->IoStatus.Information = length+
                                        sizeof(USB_HUB_NAME);
            outputBuffer->ActualLength = (ULONG)Irp->IoStatus.Information;
            ntStatus = STATUS_SUCCESS;

        } else {

            // Output buffer is too small to hold the entire
            // string.  Return just the length needed to hold
            // the entire string.
            //
            outputBuffer->ActualLength =
                length + sizeof(USB_HUB_NAME);

            outputBuffer->HubName[0] = (WCHAR)0;

            Irp->IoStatus.Information =  sizeof(USB_HUB_NAME);

        }

    } else {

        // Device is not a hub or does not currently have a symbolic link
        // allocated, just return a NULL terminated string.
        //
        outputBuffer->ActualLength = sizeof(USB_HUB_NAME);

        outputBuffer->HubName[0] = 0;

        Irp->IoStatus.Information = sizeof(USB_HUB_NAME);

    }

GetHubDone:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;

}


NTSTATUS
USBH_IoctlGetNodeName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Takes as input and output a pointer to the following structure:
  *
  * typedef struct _USB_NODE_CONNECTION_NAME {
  *     ULONG ConnectionIndex;  // INPUT
  *     ULONG ActualLength;     // OUTPUT
  *     WCHAR NodeName[1];      // OUTPUT
  * } USB_NODE_CONNECTION_NAME;
  *
  * Arguments:
  *
  * ConnectionIndex - The one-based port index to which a device is attached.
  * If an external hub is attached to this port, the symbolic link name of the
  * hub will be returned, if there is sufficient buffer space.
  *
  * ActualLength - The structure size in bytes necessary to hold the NULL
  * terminated symbolic link name.  This includes the entire structure, not
  * just the name.
  *
  * NodeName - The UNICODE NULL terminated symbolic link name of the external
  * hub attached to the port.  If there is no external hub attached to the port
  * a single NULL is returned.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          ioStack;
    PUSB_NODE_CONNECTION_NAME   outputBuffer;
    ULONG                       outputBufferLength;
    PPORT_DATA                  portData;
    PDEVICE_EXTENSION_PORT      deviceExtensionPort;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeName\n"));

    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the pointer to the input/output buffer and it's length
    //
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_NAME) Irp->AssociatedIrp.SystemBuffer;

    // Make sure that the output buffer is large enough for the base
    // structure that will be returned.
    //
    if (outputBufferLength < sizeof(USB_NODE_CONNECTION_NAME)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto GetNodeNameDone;
    }

    USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));

    // Make sure that the (one-based) port index is valid.
    //
    if ((outputBuffer->ConnectionIndex == 0) ||
        (outputBuffer->ConnectionIndex >
         DeviceExtensionHub->HubDescriptor->bNumberOfPorts)) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto GetNodeNameDone;
    }

    // Get a pointer to the data associated with the specified (one-based) port
    //

    portData = &DeviceExtensionHub->PortData[outputBuffer->ConnectionIndex - 1];

    if (portData->DeviceObject) {

        deviceExtensionPort = portData->DeviceObject->DeviceExtension;

        if ((deviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) &&
            (deviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) &&
            (deviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK)) {
            PUNICODE_STRING nodeNameUnicodeString;
            ULONG length, offset=0;
            WCHAR *pwch;


            // Device is a hub, get the name of the hub
            //
            nodeNameUnicodeString = &deviceExtensionPort->SymbolicLinkName;

            // assuming the string is \n\name strip of '\n\' where
            // n is zero or more chars

            pwch = &nodeNameUnicodeString->Buffer[0];

            USBH_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
                while (*pwch != '\\' && *pwch) {
                    pwch++;
                }
                USBH_ASSERT(*pwch == '\\');
                if (*pwch == '\\') {
                    pwch++;
                }
                offset = (ULONG)((PUCHAR)pwch -
                    (PUCHAR)&nodeNameUnicodeString->Buffer[0]);
            }

            // Strip off the '\DosDevices\' prefix.
            // Length does not include a terminating NULL.
            //
            length = nodeNameUnicodeString->Length - offset;
            RtlZeroMemory(&outputBuffer->ActualLength, 
                outputBufferLength - sizeof(outputBuffer->ConnectionIndex));

            if (outputBufferLength >= length +
                sizeof(USB_NODE_CONNECTION_NAME)) {
                RtlCopyMemory(&outputBuffer->NodeName[0],
                              &nodeNameUnicodeString->Buffer[offset/2],
                              length);

                Irp->IoStatus.Information = length+
                                            sizeof(USB_NODE_CONNECTION_NAME);
                outputBuffer->ActualLength = (ULONG)Irp->IoStatus.Information;
                ntStatus = STATUS_SUCCESS;

            } else {

                // Output buffer is too small to hold the entire
                // string.  Return just the length needed to hold
                // the entire string.
                //
                outputBuffer->ActualLength =
                    length + sizeof(USB_NODE_CONNECTION_NAME);

                outputBuffer->NodeName[0] = (WCHAR)0;

                Irp->IoStatus.Information =  sizeof(USB_NODE_CONNECTION_NAME);

            }

        } else {

            // Device is not a hub or does not currently have a symbolic link
            // allocated, just return a NULL terminated string.
            //
            outputBuffer->ActualLength = sizeof(USB_NODE_CONNECTION_NAME);

            outputBuffer->NodeName[0] = 0;

            Irp->IoStatus.Information = sizeof(USB_NODE_CONNECTION_NAME);

        }

    } else {

        // No device attached, just return a NULL terminated string.

        Irp->IoStatus.Information = sizeof(USB_NODE_CONNECTION_NAME);

        outputBuffer->ActualLength = sizeof(USB_NODE_CONNECTION_NAME);

        outputBuffer->NodeName[0] = 0;

    }

GetNodeNameDone:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_PdoIoctlGetPortStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;
    PULONG portStatus;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_PdoIoctlGetPortStatus DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", deviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
    KeWaitForSingleObject(&deviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", deviceExtensionHub));
    portData = &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    portStatus = ioStackLocation->Parameters.Others.Argument1;

    USBH_ASSERT(portStatus != NULL);

    *portStatus = 0;

    // Refresh our notion of what the port status actually is.
    ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portData->PortState,
                                      sizeof(portData->PortState));

    if (DeviceExtensionPort->PortPhysicalDeviceObject == portData->DeviceObject) {

        // translate hup port status bits
        if (portData->PortState.PortStatus & PORT_STATUS_ENABLE) {
            *portStatus |= USBD_PORT_ENABLED;
        }

        if (portData->PortState.PortStatus & PORT_STATUS_CONNECT ) {
            *portStatus |= USBD_PORT_CONNECTED;
        }
    }

    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", deviceExtensionHub));
    KeReleaseSemaphore(&deviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_PdoIoctlEnablePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;
    PORT_STATE portState;

    USBH_KdPrint((2,"'USBH_PdoIoctlEnablePort DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", deviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
    KeWaitForSingleObject(&deviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", deviceExtensionHub));

    portData = &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

      // validate that there is actually a device still conected
    ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    if ((NT_SUCCESS(ntStatus) &&
        (portState.PortStatus & PORT_STATUS_CONNECT))) {

        LOGENTRY(LOG_PNP, "estE",
                deviceExtensionHub,
                DeviceExtensionPort->PortNumber,
                0);
        ntStatus = USBH_SyncEnablePort(deviceExtensionHub,
                                       DeviceExtensionPort->PortNumber);
    } else {

        // error or no device connected or
        // can't be sure, fail the request

        LOGENTRY(LOG_PNP, "estx",
                deviceExtensionHub,
                DeviceExtensionPort->PortNumber,
                0);

        ntStatus = STATUS_UNSUCCESSFUL;
    }

    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", deviceExtensionHub));
    KeReleaseSemaphore(&deviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetDescriptorForPDO(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    ULONG outputBufferLength;
    PUCHAR outputBuffer;
    PUSB_DESCRIPTOR_REQUEST request;
    PPORT_DATA portData;
    ULONG i;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlDescriptorRequest\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    if (outputBufferLength < sizeof(USB_DESCRIPTOR_REQUEST)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBH_IoctlGetDescriptorForPDO_Complete;
    }

    request = (PUSB_DESCRIPTOR_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    outputBuffer = &request->Data[0];

    //
    // do some parameter checking
    //
    // the wLength in the setup packet better be the size of the
    // outputbuffer minus header
    //
    if (request->SetupPacket.wLength >
        outputBufferLength - sizeof(USB_DESCRIPTOR_REQUEST)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBH_IoctlGetDescriptorForPDO_Complete;
    } else {
        // request won't return more than wLength
        outputBufferLength = request->SetupPacket.wLength;
    }

    // return invalid parameter if conn index is out 
    // of bounds
    ntStatus = STATUS_INVALID_PARAMETER;

    for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (i == request->ConnectionIndex) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            // make sure we have a valid devobj for this index
            if (portData->DeviceObject == NULL) {
                goto USBH_IoctlGetDescriptorForPDO_Complete;
            }

            deviceExtensionPort =
                portData->DeviceObject->DeviceExtension;

            if (request->SetupPacket.wValue ==
                ((USB_CONFIGURATION_DESCRIPTOR_TYPE << 8) | 0) &&
                outputBufferLength == sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
                //
                // Only wants the basic configuration descriptor without the
                // rest of them tacked on (ie. interface, endpoint descriptors).
                //
                USBH_ASSERT(deviceExtensionPort->ExtensionType == EXTENSION_TYPE_PORT);

                RtlCopyMemory(outputBuffer,
                              &deviceExtensionPort->ConfigDescriptor,
                              outputBufferLength);
                Irp->IoStatus.Information =
                    outputBufferLength + sizeof(USB_DESCRIPTOR_REQUEST);
                ntStatus = STATUS_SUCCESS;                    
            } else {

                PURB urb;

                //
                // OK send the request
                //

                USBH_KdPrint((2,"'sending descriptor request for ioclt\n"));

                //
                // Allocate an Urb and descriptor buffer.
                //

                urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

                if (urb) {

                    UsbBuildGetDescriptorRequest(urb,
                                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                 request->SetupPacket.wValue >> 8,
                                                 request->SetupPacket.wValue & 0xff,
                                                 0,
                                                 outputBuffer,
                                                 NULL,
                                                 outputBufferLength,
                                                 NULL);

                    RtlCopyMemory(&urb->UrbControlDescriptorRequest.Reserved1,
                                  &request->SetupPacket.bmRequest,
                                  8);

                    ntStatus = USBH_SyncSubmitUrb(deviceExtensionPort->PortPhysicalDeviceObject, urb);

                    Irp->IoStatus.Information =
                        urb->UrbControlDescriptorRequest.TransferBufferLength +
                        sizeof(USB_DESCRIPTOR_REQUEST);

                    UsbhExFreePool(urb);

                } else {
                    USBH_KdBreak(("SyncGetDeviceConfigurationDescriptor fail alloc Urb\n"));
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            break;
        }

        portData++;

    }

USBH_IoctlGetDescriptorForPDO_Complete:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}

NTSTATUS
USBH_PdoIoctlResetPort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  *     driver is requesting us to reset the port to which the device
  *     is attached.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_PdoIoctlResetPort DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    if (!deviceExtensionHub) {
        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBH_PdoIoctlResetPortExit;
    }

    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", deviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
    KeWaitForSingleObject(&deviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", deviceExtensionHub));

    portData =
        &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];

    LOGENTRY(LOG_PNP, "Drst", deviceExtensionHub,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                portData->DeviceObject);

    if (DeviceExtensionPort->PortPhysicalDeviceObject ==
        portData->DeviceObject && DeviceExtensionPort->DeviceData != NULL) {

#ifdef USB2
        USBD_RemoveDeviceEx(deviceExtensionHub,
                          DeviceExtensionPort->DeviceData,
                          deviceExtensionHub->RootHubPdo,
                          USBD_MARK_DEVICE_BUSY);
#else
        USBD_RemoveDevice(DeviceExtensionPort->DeviceData,
                          deviceExtensionHub->RootHubPdo,
                          USBD_MARK_DEVICE_BUSY);
#endif

        ntStatus = USBH_ResetDevice(deviceExtensionHub,
                                    DeviceExtensionPort->PortNumber,
                                    TRUE,
                                    0);         // RetryIteration
    } else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    USBH_KdPrint((1,"'Warning: driver has reset the port (%x)\n",
        ntStatus));

    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", deviceExtensionHub));
    KeReleaseSemaphore(&deviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

USBH_PdoIoctlResetPortExit:

    // Must do this before completing the IRP because client driver may want
    // to post URB transfers in the completion routine.  These transfers will
    // fail if this flag is still set.

    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_RESET_PENDING;

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


VOID
USBH_InternalCyclePort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /*
  * Description:
  *
  * "Cycles" the requested port, i.e. causes PnP REMOVE and reenumeration
  * of the device.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PPORT_DATA portData;
    PWCHAR sernumbuf = NULL;
    
    portData = &DeviceExtensionHub->PortData[PortNumber-1];

    LOGENTRY(LOG_PNP, "WMIo", DeviceExtensionHub,
                PortNumber,
                DeviceExtensionPort);

    // synchronize with QBR
    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    {
    PDEVICE_OBJECT pdo;
    pdo = portData->DeviceObject;
    portData->DeviceObject = NULL;
    portData->ConnectionStatus = NoDeviceConnected;

    if (pdo) {
        // device should be present if we do this
        USBH_ASSERT(PDO_EXT(pdo)->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT);
        
        InsertTailList(&DeviceExtensionHub->DeletePdoList, 
                        &PDO_EXT(pdo)->DeletePdoLink);
    }
    }

    // in some overcurrent scenarios we may not have a PDO.
    
    // this function is synchronous, so the device should have 
    // no tranfsers on completion
    if (DeviceExtensionPort) {
        USBD_RemoveDeviceEx(DeviceExtensionHub,
                            DeviceExtensionPort->DeviceData,
                            DeviceExtensionHub->RootHubPdo,
                            0);
                        
        DeviceExtensionPort->DeviceData = NULL;                          
         // this prevents resets by the client
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_CYCLED;
        // keep ref until removeal of hub OR child
        //DeviceExtensionPort->DeviceExtensionHub = NULL;

    
        // disable the port so no traffic passes to the device until reset
        USBH_SyncDisablePort(DeviceExtensionHub,
                             DeviceExtensionPort->PortNumber);
    
    
        sernumbuf = InterlockedExchangePointer(
                        &DeviceExtensionPort->SerialNumberBuffer,
                        NULL);
    }

    if (sernumbuf) {
        UsbhExFreePool(sernumbuf);
    }

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
    
    USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                     BusRelations);
}


NTSTATUS
USBH_PdoIoctlCyclePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  *     driver is requesting us to reset the port to which the device
  *     is attached.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_PdoIoctlResetPort DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;

    USBH_InternalCyclePort(deviceExtensionHub, portNumber, DeviceExtensionPort);

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}

#ifdef WMI_SUPPORT
NTSTATUS
USBH_BuildConnectionNotification(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PUSB_CONNECTION_NOTIFICATION Notification
    )
 /*
  * Description:
  *
  *     driver is requesting us to reset the port to which the device
  *     is attached.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS, status;
    USB_CONNECTION_STATUS connectStatus;
    USB_HUB_NAME hubName;
    PPORT_DATA portData;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    portData =
        &DeviceExtensionHub->PortData[PortNumber-1];

    if (portData->DeviceObject &&
        portData->ConnectionStatus != DeviceHubNestedTooDeeply) {

        deviceExtensionPort = portData->DeviceObject->DeviceExtension;
        connectStatus = UsbhGetConnectionStatus(deviceExtensionPort);
    } else {
        deviceExtensionPort = NULL;
        connectStatus = portData->ConnectionStatus;
    }

    RtlZeroMemory(Notification, sizeof(*Notification));

    Notification->ConnectionNumber = PortNumber;

    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        hubName.ActualLength = sizeof(hubName) - sizeof(hubName.ActualLength);
        status = USBHUB_GetRootHubName(DeviceExtensionHub,
                                       &hubName.HubName,
                                       &hubName.ActualLength);
    } else {
        status = USBH_SyncGetHubName(DeviceExtensionHub->TopOfStackDeviceObject,
                                     &hubName,
                                     sizeof(hubName));
    }

    USBH_KdPrint((1,"'Notification, hub name length = %d\n",
        hubName.ActualLength));

    if (NT_SUCCESS(status)) {
        Notification->HubNameLength = hubName.ActualLength;
    } else {
        Notification->HubNameLength = 0;
    }

    switch(connectStatus) {
    case DeviceFailedEnumeration:
        // need to track some some reasons
        if (deviceExtensionPort) {
            Notification->EnumerationFailReason =
                deviceExtensionPort->FailReasonId;
        } else {
            Notification->EnumerationFailReason = 0;
        }
        Notification->NotificationType = EnumerationFailure;
        break;

    case DeviceCausedOvercurrent:
        Notification->NotificationType = OverCurrent;
        break;

    case DeviceNotEnoughPower:
        Notification->NotificationType = InsufficentPower;
        if (deviceExtensionPort) {
            Notification->PowerRequested =
                deviceExtensionPort->PowerRequested;
        }
        break;

    case DeviceNotEnoughBandwidth:
        Notification->NotificationType = InsufficentBandwidth;
        if (deviceExtensionPort) {
            Notification->RequestedBandwidth =
                deviceExtensionPort->RequestedBandwidth;
        }
        break;

    case DeviceHubNestedTooDeeply:
        Notification->NotificationType = HubNestedTooDeeply;
        break;

    case DeviceInLegacyHub:
        Notification->NotificationType = ModernDeviceInLegacyHub;
        break;

    case DeviceGeneralFailure:
    default:
        // nothing wrong?
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

#endif


NTSTATUS
USBH_PdoEvent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber
    )
 /*
  * Description:
  *
  * Triggers a WMI event based on the current connection status of the port
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

#ifdef WMI_SUPPORT
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PPORT_DATA portData;
    PUSB_CONNECTION_NOTIFICATION notification;

    portData =
        &DeviceExtensionHub->PortData[PortNumber-1];

    if (portData->DeviceObject) {
        deviceExtensionPort = portData->DeviceObject->DeviceExtension;
    }

    USBH_KdPrint((1,"'Fire WMI Event for Port Ext %x on hub ext %x\n",
        deviceExtensionPort, DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "WMIe", DeviceExtensionHub,
                deviceExtensionPort,
                0);


    notification = ExAllocatePoolWithTag(PagedPool,
                                         sizeof(USB_CONNECTION_NOTIFICATION),
                                         USBHUB_HEAP_TAG);

    if (notification) {

        ntStatus = USBH_BuildConnectionNotification(
                        DeviceExtensionHub,
                        PortNumber,
                        notification);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = WmiFireEvent(
                                    DeviceExtensionHub->FunctionalDeviceObject,
                                    (LPGUID)&GUID_USB_WMI_STD_NOTIFICATION,
                                    0,
                                    sizeof(*notification),
                                    notification);
        } else {

            // Since we did not call WmiFireEvent then we must free the buffer
            // ourselves.

            ExFreePool(notification);
        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

#endif /* WMI_SUPPORT */

    return ntStatus;
}

#ifdef WMI_SUPPORT

NTSTATUS
USBH_SystemControl (
    IN  PDEVICE_EXTENSION_FDO DeviceExtensionFdo,
    IN  PIRP Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    SYSCTL_IRP_DISPOSITION IrpDisposition;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ntStatus = WmiSystemControl(
                &DeviceExtensionFdo->WmiLibInfo,
                DeviceExtensionFdo->FunctionalDeviceObject,
                Irp,
                &IrpDisposition);

    switch (IrpDisposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            ntStatus = USBH_PassIrp(Irp, DeviceExtensionFdo->TopOfStackDeviceObject);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            ntStatus = USBH_PassIrp(Irp, DeviceExtensionFdo->TopOfStackDeviceObject);
            break;
        }
    }

    return(ntStatus);
}


NTSTATUS
USBH_PortSystemControl (
    IN  PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN  PIRP Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    SYSCTL_IRP_DISPOSITION IrpDisposition;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ntStatus = WmiSystemControl(
                &DeviceExtensionPort->WmiLibInfo,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                Irp,
                &IrpDisposition);

    switch (IrpDisposition)
    {
    case IrpNotWmi:
        // Don't change status of IRP we don't know about.
        ntStatus = Irp->IoStatus.Status;
        // fall through
    case IrpNotCompleted:
    case IrpForward:
    default:
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IrpProcessed:
        // Don't complete the IRP in this case.
        break;
    }

    return(ntStatus);
}


PDEVICE_EXTENSION_PORT
USBH_GetPortPdoExtension(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN ULONG PortNumber
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;

    portData = DeviceExtensionHub->PortData;

    //
    // hub descriptor will be null if the hub is already stopped
    //

    if (portData &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (nextPortNumber = 1;
             nextPortNumber <= numberOfPorts;
             nextPortNumber++, portData++) {

            USBH_KdPrint((1,"'portdata %x, do %x\n", portData, portData->DeviceObject));

            if (PortNumber == nextPortNumber) {

                if (portData->DeviceObject)
                    return portData->DeviceObject->DeviceExtension;
                else
                    return NULL;

            }
        }

    }

    return NULL;
}


VOID
USBH_CheckLeafHubsIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function walks the chain of hubs downstream from the specified hub,
  * and idles the leaf hubs if ready.
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    PDEVICE_EXTENSION_HUB childDeviceExtensionHub;
    BOOLEAN bHaveChildrenHubs = FALSE;
    ULONG i;

    PAGED_CODE();

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

//    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
//    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
//    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
//                          Executive,
//                          KernelMode,
//                          FALSE,
//                          NULL);
//    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (childDeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {

                PDRIVER_OBJECT hubDriver;
                PDEVICE_OBJECT childHubPdo, childHubFdo;
                 
                // We have a child hub.  This means that we are not a leaf hub.
                // Indicate this and recurse down to the child hub.

                bHaveChildrenHubs = TRUE;

                hubDriver = DeviceExtensionHub->FunctionalDeviceObject->DriverObject;
                childHubPdo = childDeviceExtensionPort->PortPhysicalDeviceObject;
 
                do {
                     childHubFdo = childHubPdo->AttachedDevice;
                     childHubPdo = childHubFdo;
                } while (childHubFdo->DriverObject != hubDriver);

                childDeviceExtensionHub = childHubFdo->DeviceExtension;
 
                USBH_CheckLeafHubsIdle(childDeviceExtensionHub);
            }
        }
    }

//    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
//    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
//                       LOW_REALTIME_PRIORITY,
//                       1,
//                       FALSE);
//
//    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (!bHaveChildrenHubs) {

        // If this hub has no children then it is a leaf hub.  See if
        // it is ready to be idled out.

        USBH_CheckHubIdle(DeviceExtensionHub);
    }
}


//
// WMI System Call back functions
//


NTSTATUS
USBH_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_FDO   deviceExtensionFdo;
    PDEVICE_EXTENSION_HUB   deviceExtensionHub;
    NTSTATUS status;
    ULONG size = 0;
    BOOLEAN bEnableSS, bSelectiveSuspendEnabled = FALSE, globaDisableSS;

    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) DeviceObject->DeviceExtension;
    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_USB_DRIVER_INFORMATION:

        status = /*STATUS_WMI_READ_ONLY*/STATUS_INVALID_DEVICE_REQUEST;
        break;

    case WMI_USB_POWER_DEVICE_ENABLE:

        // We only support this for the Root Hub but this WMI request should
        // only occur for the Root Hub because we only register this GUID
        // for the Root Hub.  We perform a sanity check anyway.

        USBH_ASSERT(deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB);
        USBH_ASSERT(IS_ROOT_HUB(deviceExtensionHub));
    
        USBH_RegQueryUSBGlobalSelectiveSuspend(&globaDisableSS);
        
        if (deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB &&
            IS_ROOT_HUB(deviceExtensionHub) && 
            !globaDisableSS) {

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else if (0 != InstanceIndex) {
                status = STATUS_INVALID_DEVICE_REQUEST;
            } else {
                bEnableSS = *(PBOOLEAN)Buffer;

                status = USBD_QuerySelectiveSuspendEnabled(deviceExtensionHub,
                                                    &bSelectiveSuspendEnabled);

                if (NT_SUCCESS(status) &&
                    bEnableSS != bSelectiveSuspendEnabled) {

                    // Update global flag and registry with new setting.

                    status = USBD_SetSelectiveSuspendEnabled(deviceExtensionHub,
                                                            bEnableSS);

                    if (NT_SUCCESS(status)) {

                        if (bEnableSS) {
                            // We are being asked to enable Selective Suspend
                            // when it was previously disabled.

                            // Find the end hubs in the chain and idle them
                            // out if ready.  This will trickle down to
                            // the parent hubs if all hubs are idle.

                            USBH_CheckLeafHubsIdle(deviceExtensionHub);

                            status = STATUS_SUCCESS;

                        } else {
                            // We are being asked to disable Selective Suspend
                            // when it was previously enabled.

                            if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
                                (deviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

                                USBH_HubSetD0(deviceExtensionHub);
                            } else {
                                USBH_HubCompletePortIdleIrps(deviceExtensionHub,
                                                             STATUS_CANCELLED);
                            }

                            status = STATUS_SUCCESS;
                        }
                    }

                }
            }

        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
USBH_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_FDO deviceExtensionFdo;
    PUSB_NOTIFICATION notification;
    NTSTATUS    status;
    ULONG       size = 0;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    BOOLEAN bSelectiveSuspendEnabled = FALSE,globaDisableSS;

    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) DeviceObject->DeviceExtension;
    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;

    notification = (PUSB_NOTIFICATION) Buffer;
    USBH_KdPrint((1,"'WMI Query Data Block on hub ext %x\n",
        deviceExtensionHub));

    switch (GuidIndex) {
    case WMI_USB_DRIVER_INFORMATION:

        if (InstanceLengthArray != NULL) {
            *InstanceLengthArray = 0;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case WMI_USB_POWER_DEVICE_ENABLE:

        // We only support this for the Root Hub but this WMI request should
        // only occur for the Root Hub because we only register this GUID
        // for the Root Hub.  We perform a sanity check anyway.

        USBH_ASSERT(deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB);
        USBH_ASSERT(IS_ROOT_HUB(deviceExtensionHub));

        USBH_RegQueryUSBGlobalSelectiveSuspend(&globaDisableSS);

        if (deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB &&
            IS_ROOT_HUB(deviceExtensionHub) &&
            !globaDisableSS) {

            //
            // Only registers 1 instance for this GUID.
            //
            if ((0 != InstanceIndex) || (1 != InstanceCount)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            size = sizeof(BOOLEAN);

            if (OutBufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            status = USBD_QuerySelectiveSuspendEnabled(deviceExtensionHub,
                                                &bSelectiveSuspendEnabled);

            if (!NT_SUCCESS(status)) {
                break;
            }

            *(PBOOLEAN)Buffer = bSelectiveSuspendEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;

        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                size,
                                IO_NO_INCREMENT);

    return status;
}


NTSTATUS
USBH_PortQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_DEVICE_UI_FIRMWARE_REVISION fwRevBuf;
    NTSTATUS    status;
    ULONG       size = 0;
    PWCHAR      revstr;
    USHORT      bcdDevice;
    USHORT      stringsize;

    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) DeviceObject->DeviceExtension;

    USBH_KdPrint((1,"'WMI Query Data Block on PORT PDO ext %x\n",
        deviceExtensionPort));

    switch (GuidIndex) {
    case 0:

        // Return USB device FW revision # in the following format "xx.xx".
        // Need buffer large enough for this string plus NULL terminator.

        stringsize = 6 * sizeof(WCHAR);

        size = sizeof(USB_DEVICE_UI_FIRMWARE_REVISION) + (ULONG)stringsize;

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        bcdDevice = deviceExtensionPort->DeviceDescriptor.bcdDevice;

        fwRevBuf = (PUSB_DEVICE_UI_FIRMWARE_REVISION)Buffer;

        revstr = &fwRevBuf->FirmwareRevisionString[0];

        *revstr = BcdNibbleToAscii(bcdDevice >> 12);
        *(revstr+1) = BcdNibbleToAscii((bcdDevice >> 8) & 0x000f);
        *(revstr+2) = '.';
        *(revstr+3) = BcdNibbleToAscii((bcdDevice >> 4) & 0x000f);
        *(revstr+4) = BcdNibbleToAscii(bcdDevice & 0x000f);
        *(revstr+5) = 0;

        fwRevBuf->Length = stringsize;

        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        USBH_KdPrint((1,"'WMI Query Data Block, returning FW rev # '%ws'\n",
            revstr));
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                size,
                                IO_NO_INCREMENT);

    return status;
}


NTSTATUS
USBH_ExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being called.

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer on entry has the input data block and on return has the output
        output data block.


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_FDO deviceExtensionFdo;
    PUSB_NOTIFICATION notification;

    NTSTATUS    ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    ULONG       size = 0;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_EXTENSION_PORT portPdoExt;
    BOOLEAN bDoCheckHubIdle = FALSE;

    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) DeviceObject->DeviceExtension;

    if (deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_PARENT) {

        // Looks like a child PDO of a composite device is causing the problem.
        // Let's be sure to get the correct device extension for the hub.

        portPdoExt = deviceExtensionFdo->PhysicalDeviceObject->DeviceExtension;
        deviceExtensionHub = portPdoExt->DeviceExtensionHub;
    } else {
        deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;
    }

    USBH_ASSERT(EXTENSION_TYPE_HUB == deviceExtensionHub->ExtensionType);

    // If this hub is currently Selective Suspended, then we need to
    // power up the hub first before sending any requests along to it.
    // Make sure hub has been started, though.

    if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (deviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        bDoCheckHubIdle = TRUE;
        USBH_HubSetD0(deviceExtensionHub);
    }

    notification = (PUSB_NOTIFICATION) Buffer;
    USBH_KdPrint((1,"'WMI Execute Method on hub ext %x\n",
        deviceExtensionHub));

    switch (GuidIndex) {
    case WMI_USB_DRIVER_INFORMATION:
        size = sizeof(*notification);
        if (OutBufferSize < size) {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        // switch(MethodId) {
        switch (notification->NotificationType) {
        case EnumerationFailure:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method EnumerationFailure %x\n"));

            connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'pwr - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                portPdoExt =
                    USBH_GetPortPdoExtension(deviceExtensionHub,
                                             connectionNotification->ConnectionNumber);
                if (portPdoExt) {
                    connectionNotification->EnumerationFailReason =
                        portPdoExt->FailReasonId;
                    ntStatus = STATUS_SUCCESS;
                } else {
                    USBH_KdPrint((1,"'ef - bad connection index\n"));
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
            }
            }
            break;

        case InsufficentBandwidth:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method InsufficentBandwidth\n"));

            connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'pwr - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                portPdoExt =
                    USBH_GetPortPdoExtension(deviceExtensionHub,
                                             connectionNotification->ConnectionNumber);
                if (portPdoExt) {
                    connectionNotification->RequestedBandwidth =
                        portPdoExt->RequestedBandwidth;
                    ntStatus = STATUS_SUCCESS;
                 } else {
                    USBH_KdPrint((1,"'bw - bad connection index\n"));
                    ntStatus = STATUS_INVALID_PARAMETER;
                 }
            }
            }
            break;

        case OverCurrent:
            // nothing to do here
            USBH_KdPrint((1,"'Method OverCurrent\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;
        case InsufficentPower:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method InsufficentPower\n"));
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'pwr - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
                USBH_KdPrint((1,"'pwr - connection %d\n",
                    connectionNotification->ConnectionNumber));
                if (connectionNotification->ConnectionNumber) {
                    if (portPdoExt = USBH_GetPortPdoExtension(deviceExtensionHub,
                                                              connectionNotification->ConnectionNumber)) {
                        connectionNotification->PowerRequested =
                            portPdoExt->PowerRequested;
                        ntStatus = STATUS_SUCCESS;
                    }
                } else {
                    USBH_KdPrint((1,"'pwr - bad connection index\n"));
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
            }
            }
            break;
        case ResetOvercurrent:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method ResetOvercurrent\n"));
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'reset - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
                if (connectionNotification->ConnectionNumber) {
                    USBH_KdPrint((1,"'reset - port %d\n", connectionNotification->ConnectionNumber));
                    portPdoExt = USBH_GetPortPdoExtension(deviceExtensionHub,
                                                          connectionNotification->ConnectionNumber);
                    ntStatus = USBH_ResetPortOvercurrent(deviceExtensionHub,
                                                         (USHORT)connectionNotification->ConnectionNumber,
                                                         portPdoExt);
//                    } else {
//                        // bad connection index
//                        USBH_KdPrint((1,"'reset - bad connection index\n"));
//                        ntStatus = STATUS_INVALID_PARAMETER;
//                    }
                } else {
                    // this is a reset for the whole hub
                    USBH_KdPrint((1,"'not implemented yet\n"));
                    TEST_TRAP();
                    ntStatus = STATUS_NOT_IMPLEMENTED;
                }
            }
            }
            break;

        case AcquireBusInfo:
            {
            PUSB_BUS_NOTIFICATION busNotification;

            USBH_KdPrint((1,"'Method AcquireBusInfo\n"));
            size = sizeof(*busNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'AcquireBusInfo - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                busNotification = (PUSB_BUS_NOTIFICATION) Buffer;
//                ntStatus = USBH_SyncGetControllerInfo(
//                                deviceExtensionHub->TopOfStackDeviceObject,
//                                busNotification,
//                                sizeof(*busNotification),
//                                IOCTL_INTERNAL_USB_GET_BUS_INFO);

                ntStatus = USBHUB_GetBusInfo(deviceExtensionHub,
                                             busNotification,
                                             NULL);

                USBH_KdPrint((1,"'Notification, controller name length = %d\n",
                    busNotification->ControllerNameLength));
            }
            }
            break;

        case AcquireHubName:
            /*+
                we utilize the fact that these structures have some 
                elements in common
            
                USB_HUB_NAME                USB_ACQUIRE_INFO
                ------------                ----------------  
                                            USB_NOTIFICATION_TYPE NotificationType;
                ULONG ActualLength;         ULONG TotalSize;
                WCHAR HubName[1];           WCHAR Buffer[1];

                 USB_NOTIFICATION_TYPE NotificationType;
            +*/
            {
            PUSB_HUB_NAME hubName;
            PUSB_ACQUIRE_INFO acquireInfo;

            USBH_KdPrint((1,"'Method AcquireHubName\n"));

            size = sizeof(USB_ACQUIRE_INFO);
            acquireInfo = (PUSB_ACQUIRE_INFO) Buffer;

            if (OutBufferSize < size ||
                acquireInfo->TotalSize < size) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // return the samller of the two as the output length so we don't 
            // copy more than necessary
            size = acquireInfo->TotalSize > OutBufferSize ? OutBufferSize : acquireInfo->TotalSize;
            hubName = (PUSB_HUB_NAME) &acquireInfo->TotalSize;
            // TotalSize contains the size of the notification type as well
            // comsume notification type field
            hubName->ActualLength -= sizeof(USB_NOTIFICATION_TYPE);
            OutBufferSize -= sizeof(USB_NOTIFICATION_TYPE);
            
            // As long as ActualLength is less than the true output buffer 
            // length we are safe 
            if (hubName->ActualLength > OutBufferSize) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if (IS_ROOT_HUB(deviceExtensionHub)) {
                // consume the length field
                hubName->ActualLength -= sizeof(hubName->ActualLength);
                // this will set HubName to the name plus set the 
                // actual length field to the true length of the name
                // the API needs to return the length of the entire hubname
                // structure
                ntStatus = USBHUB_GetRootHubName(deviceExtensionHub,
                                                 hubName->HubName,
                                                 &hubName->ActualLength);
                                                 
                // ActualLength is the length of the entire structure                                                 
                hubName->ActualLength += sizeof(hubName->ActualLength);
            } else {
                // passes the hubname strucutre down, ActualLength is the 
                // length of the entire structure
                ntStatus = USBH_SyncGetHubName(
                                deviceExtensionHub->TopOfStackDeviceObject,
                                hubName,
                                hubName->ActualLength);
            }

            // readjust to previous value
            hubName->ActualLength += sizeof(USB_NOTIFICATION_TYPE);
            OutBufferSize += sizeof(USB_NOTIFICATION_TYPE);
            }
            break;
            
        case AcquireControllerName:
            /*+
                we utilize the fact that these structures have some 
                elements in common
            
                USB_HUB_NAME                USB_ACQUIRE_INFO
                ------------                ----------------  
                                            USB_NOTIFICATION_TYPE NotificationType;
                ULONG ActualLength;         ULONG TotalSize;
                WCHAR HubName[1];           WCHAR Buffer[1];

                 USB_NOTIFICATION_TYPE NotificationType;
            +*/
            {
            PUSB_HUB_NAME controllerName;
            PUSB_ACQUIRE_INFO acquireInfo;

            USBH_KdPrint((1,"'Method AcquireControllerName\n"));

            size = sizeof(USB_ACQUIRE_INFO);
            acquireInfo = (PUSB_ACQUIRE_INFO) Buffer;

            if (OutBufferSize < size ||
                acquireInfo->TotalSize < size) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            USBH_KdPrint((1,"'TotalSize %d\n", acquireInfo->TotalSize));
            USBH_KdPrint((1,"'NotificationType %x\n", acquireInfo->NotificationType));

            // use the smaller of the two specified values for the copy 
            // back to user mode
            size = acquireInfo->TotalSize > OutBufferSize ? OutBufferSize : acquireInfo->TotalSize;
            
            controllerName = (PUSB_HUB_NAME) &acquireInfo->TotalSize;

            // TotalSize contains the size of the notification type as well
            // consume USB_NOTIFICATION_TYPE
            controllerName->ActualLength -= sizeof(USB_NOTIFICATION_TYPE);
            OutBufferSize -= sizeof(USB_NOTIFICATION_TYPE);
            
            if (controllerName->ActualLength > OutBufferSize) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            ntStatus = USBHUB_GetControllerName(deviceExtensionHub,
                                                controllerName,
                                                controllerName->ActualLength);

            // readjust to previous value
            controllerName->ActualLength += sizeof(USB_NOTIFICATION_TYPE);
            OutBufferSize += sizeof(USB_NOTIFICATION_TYPE);
            
            USBH_KdPrint((1,"'Method AcquireControllerName %x - %d\n",
                acquireInfo, controllerName->ActualLength));
            }
            break;

        case HubOvercurrent:
            USBH_KdPrint((1,"'Method HubOvercurrent\n"));
            USBH_KdPrint((1,"'not implemented yet\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;

        case HubPowerChange:
            USBH_KdPrint((1,"'Method HubPowerChange\n"));
            USBH_KdPrint((1,"'not implemented yet\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;

        case HubNestedTooDeeply:
            // nothing to do here
            USBH_KdPrint((1,"'Method HubNestedTooDeeply\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;

        case ModernDeviceInLegacyHub:
            // nothing to do here
            USBH_KdPrint((1,"'Method ModernDeviceInLegacyHub\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;
        }
        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                  Irp,
                                  ntStatus,
                                  size,
                                  IO_NO_INCREMENT);

    if (bDoCheckHubIdle) {
        USBH_CheckHubIdle(deviceExtensionHub);
    }

    return ntStatus;
}

NTSTATUS
USBH_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_HUB deviceExtensionHub;  // pointer to our device
                                               // extension

    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &UsbhRegistryPath;
    *Pdo = deviceExtensionHub->PhysicalDeviceObject;

    return STATUS_SUCCESS;
}

NTSTATUS
USBH_PortQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &UsbhRegistryPath;
    *Pdo = deviceExtensionPort->PortPhysicalDeviceObject;

    return STATUS_SUCCESS;
}

#endif /* WMI_SUPPORT */


NTSTATUS
USBH_ResetPortOvercurrent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /*
  * Description:
  *
  * Reset the overcurrent condition for a port
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS, status;
    PORT_STATE portState;

    USBH_KdPrint((0,"'Reset Overcurrent for port %d\n", PortNumber));

    // we will need to re-enable and re-power the port

    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    //
    // port should be powered off at this point
    //
    LOGENTRY(LOG_PNP, "RPOv", DeviceExtensionHub,
                portState.PortStatus,
                portState.PortChange);

    if (NT_SUCCESS(ntStatus)) {

        if (portState.PortStatus & PORT_STATUS_POWER) {

            ntStatus = STATUS_INVALID_PARAMETER;

        } else {

            if (DeviceExtensionPort) {
                // clear overcurrent Flags
                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_OVERCURRENT;
            }

            // power up the port
            ntStatus = USBH_SyncPowerOnPort(DeviceExtensionHub,
                                            PortNumber,
                                            TRUE);

            USBH_InternalCyclePort(DeviceExtensionHub, PortNumber, DeviceExtensionPort);
        }
    }
    return ntStatus;
}


NTSTATUS
USBH_CalculateInterfaceBandwidth(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSBD_INTERFACE_INFORMATION Interface,
    IN OUT PULONG Bandwidth // in kenr units?
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i, bw;

    // we'll need to walk through the interface
    // and figure out how much BW it requires

    for (i=0; i<Interface->NumberOfPipes; i++) {

//#ifdef USB2
//        bw = USBD_CalculateUsbBandwidthEx(
//                (ULONG) Interface->Pipes[i].MaximumPacketSize,
//                (UCHAR) Interface->Pipes[i].PipeType,
//                (BOOLEAN) (DeviceExtensionPort->PortPdoFlags &
//                            PORTPDO_LOW_SPEED_DEVICE));
//#else
        bw = USBD_CalculateUsbBandwidth(
                (ULONG) Interface->Pipes[i].MaximumPacketSize,
                (UCHAR) Interface->Pipes[i].PipeType,
                (BOOLEAN) (DeviceExtensionPort->PortPdoFlags &
                            PORTPDO_LOW_SPEED_DEVICE));
//#endif
        USBH_KdPrint((1,"'ept = %d packetsize =  %d  bw = %d\n",
            Interface->Pipes[i].PipeType,
            Interface->Pipes[i].MaximumPacketSize, bw));

        *Bandwidth += bw;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\usbhub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usbhub.h

Abstract:

    This header define structures and macros for USB Hub driver.

Author:

    JohnLee

Environment:

    Kernel mode

Revision History:

    2-2-96 : created
    11-18-96 : jdunn -- added composite device support

--*/

#include <wdmwarn4.h>

#include <usb.h>        // usbdi.h has been replaced by usb.h
#include <usbdlib.h>
#include <msosdesc.h>   // contains internal definitions for MS OS Desc.

#ifdef USB2
#include "hubbusif.h"    // hub service bus interface
#include "usbbusif.h"    // usb client service bus interface
#else
#include <hcdi.h>
#include <usbdlibi.h>
#endif
#include <usbioctl.h>
#include <wmidata.h>

#include <enumlog.h>

//enable pageable code
#ifndef PAGE_CODE
#define PAGE_CODE
#endif

#define MULTI_FUNCTION_SUPPORT
#define EARLY_RESOURCE_RELEASE

#define USBH_MAX_FUNCTION_INTERFACES 4


#define BcdNibbleToAscii( byte ) (byte)+ '0'


//
// fail reason codes
//

// "Device Failed Enumeration"
// indicates the device failed some part of the enumeration process
// when this happens we cannot tell enough about the device to load
// the appropriate driver.
#define USBH_FAILREASON_ENUM_FAILED             1
// "Device General Failure"
// this is our 'if it does not fit any other catagory' error
#define USBH_FAILREASON_GEN_DEVICE_FAILURE      2
// "Device Caused Overcurrent"
// if a hub supports per port power switching and the device
// causes an overcurrent condition (over-current is like blowing
// a fuse) the we report this error.
#define USBH_FAILREASON_PORT_OVERCURRENT        3
// "Not Enough Power"
// indicates that the device requested a configuration that requires
// more power than the hub can provide.
#define USBH_FAILREASON_NOT_ENOUGH_POWER        4
// "Hub General failure"
// if the hub starts failing transfer requests the driver will
// disable it and report this error.
#define USBH_FAILREASON_HUB_GENERAL_FAILURE     5
// "Cannot connect more than five hubs"
#define USBH_FAILREASON_MAXHUBS_CONNECTED       6
// "An overcurrent condition has disabled the hub"
// if a device generates overcurrent and the hub implements
// gang power switching the entire hub will be disabled and
// this error reported.
#define USBH_FAILREASON_HUB_OVERCURRENT         7

//
//  Struc definitions
//

//
// Work item
//
#define USBH_WKFLAG_REQUEST_RESET       0x00000001

typedef struct _USBH_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    ULONG Flags;
    PVOID Context;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    KDPC Dpc;
    KTIMER Timer;
    UCHAR Data[0];
} USBH_WORK_ITEM, *PUSBH_WORK_ITEM;

typedef struct _USBH_RESET_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
    PIRP Irp;
} USBH_RESET_WORK_ITEM, *PUSBH_RESET_WORK_ITEM;

typedef struct _USBH_COMP_RESET_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PARENT *DeviceExtensionParent;
} USBH_COMP_RESET_WORK_ITEM, *PUSBH_COMP_RESET_WORK_ITEM;

typedef struct _USBH_BANDWIDTH_TIMEOUT_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
} USBH_BANDWIDTH_TIMEOUT_WORK_ITEM, *PUSBH_BANDWIDTH_TIMEOUT_WORK_ITEM;

typedef struct _USBH_COMP_RESET_TIMEOUT_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PARENT *DeviceExtensionParent;
} USBH_COMP_RESET_TIMEOUT_WORK_ITEM, *PUSBH_COMP_RESET_TIMEOUT_WORK_ITEM;

typedef struct _USBH_SET_POWER_D0_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    PIRP Irp;
} USBH_SET_POWER_D0_WORK_ITEM, *PUSBH_SET_POWER_D0_WORK_ITEM;

typedef struct _USBH_HUB_ESD_RECOVERY_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
} USBH_HUB_ESD_RECOVERY_WORK_ITEM, *PUSBH_HUB_ESD_RECOVERY_WORK_ITEM;

typedef struct _USBH_HUB_IDLE_POWER_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    NTSTATUS ntStatus;
} USBH_HUB_IDLE_POWER_WORK_ITEM, *PUSBH_HUB_IDLE_POWER_WORK_ITEM;

typedef struct _USBH_PORT_IDLE_POWER_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    PIRP Irp;
} USBH_PORT_IDLE_POWER_WORK_ITEM, *PUSBH_PORT_IDLE_POWER_WORK_ITEM;

typedef struct _USBH_COMPLETE_PORT_IRPS_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    LIST_ENTRY IrpsToComplete;
    NTSTATUS ntStatus;
} USBH_COMPLETE_PORT_IRPS_WORK_ITEM, *PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM;

typedef struct _USBH_HUB_ASYNC_POWER_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
    PIRP Irp;
    UCHAR MinorFunction;
} USBH_HUB_ASYNC_POWER_WORK_ITEM, *PUSBH_HUB_ASYNC_POWER_WORK_ITEM;

typedef struct _HUB_TIMEOUT_CONTEXT {
    PIRP Irp;
    KEVENT Event;
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    KSPIN_LOCK TimeoutSpin;
    BOOLEAN Complete;
} HUB_TIMEOUT_CONTEXT, *PHUB_TIMEOUT_CONTEXT;

typedef struct _PORT_TIMEOUT_CONTEXT {
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
    BOOLEAN CancelFlag;
} PORT_TIMEOUT_CONTEXT, *PPORT_TIMEOUT_CONTEXT;

typedef struct _COMP_RESET_TIMEOUT_CONTEXT {
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    struct _DEVICE_EXTENSION_PARENT *DeviceExtensionParent;
    BOOLEAN CancelFlag;
} COMP_RESET_TIMEOUT_CONTEXT, *PCOMP_RESET_TIMEOUT_CONTEXT;

typedef struct _HUB_ESD_RECOVERY_CONTEXT {
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
} HUB_ESD_RECOVERY_CONTEXT, *PHUB_ESD_RECOVERY_CONTEXT;

typedef struct _USB_DEVICE_UI_FIRMWARE_REVISION
{
    USHORT Length;
    WCHAR FirmwareRevisionString[1];

} USB_DEVICE_UI_FIRMWARE_REVISION, *PUSB_DEVICE_UI_FIRMWARE_REVISION;

typedef struct _HUB_STATE {
    USHORT HubStatus;
    USHORT HubChange;
} HUB_STATE, *PHUB_STATE;

typedef struct _PORT_STATE {
    USHORT PortStatus;
    USHORT PortChange;
} PORT_STATE, *PPORT_STATE;

//
// Hub and Port status defined below also apply to StatusChnage bits
//
#define HUB_STATUS_LOCAL_POWER      0x01
#define HUB_STATUS_OVER_CURRENT     0x02

#define PORT_STATUS_CONNECT         0x001
#define PORT_STATUS_ENABLE          0x002
#define PORT_STATUS_SUSPEND         0x004
#define PORT_STATUS_OVER_CURRENT    0x008
#define PORT_STATUS_RESET           0x010
#define PORT_STATUS_POWER           0x100
#define PORT_STATUS_LOW_SPEED       0x200
#define PORT_STATUS_HIGH_SPEED      0x400

//
// Port data to describe relevant info about a port
//

// values for PortFlags
// #define PORTFLAG_ 0x00000001


typedef struct _PORT_DATA {
    PORT_STATE              PortState;          // the status & change bit mask of the port
    PDEVICE_OBJECT          DeviceObject;       // the PDO
    USB_CONNECTION_STATUS   ConnectionStatus;
    // extended port attributes as defined in USB.H
    ULONG                   PortAttributes;
    // revised port data structure
    ULONG                   PortFlags;
} PORT_DATA, *PPORT_DATA;

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//
#define FILE_DEVICE_USB_HUB  0x00008600

#define USBH_MAX_ENUMERATION_ATTEMPTS   3

//
// Common fields for Pdo and Fdo extensions
//
#define EXTENSION_TYPE_PORT 0x54524f50      // "PORT"
#define EXTENSION_TYPE_HUB  0x20425548      // "HUB "
#define EXTENSION_TYPE_PARENT  0x50525400   // "PRT "
#define EXTENSION_TYPE_FUNCTION  0xfefefeff   // ""

typedef struct _USBH_POWER_WORKER {
    PIRP Irp;
    WORK_QUEUE_ITEM WorkQueueItem;
} USBH_POWER_WORKER, *PUSBH_POWER_WORKER;

typedef struct _DEVICE_EXTENSION_HEADER {
    ULONG ExtensionType;
} DEVICE_EXTENSION_HEADER, *PDEVICE_EXTENSION_HEADER;


typedef struct _DEVICE_EXTENSION_COMMON {
    PDEVICE_OBJECT  FunctionalDeviceObject; // points back to owner device object
    PDEVICE_OBJECT  PhysicalDeviceObject;   // the PDO for this device
    PDEVICE_OBJECT  TopOfStackDeviceObject; // to of stack passed to adddevice
} DEVICE_EXTENSION_COMMON, *PDEVICE_EXTENSION_COMMON;

// common to FDO for hub and generic parent
typedef struct _DEVICE_EXTENSION_FDO {
    DEVICE_EXTENSION_HEADER;
    DEVICE_EXTENSION_COMMON;
    KEVENT PnpStartEvent;
    PIRP PowerIrp;
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT  WmiLibInfo;
#endif /* WMI_SUPPORT */

} DEVICE_EXTENSION_FDO, *PDEVICE_EXTENSION_FDO;


//
// Device_Extension for HUB
//
typedef struct _DEVICE_EXTENSION_HUB {
    //
    // *** NOTE the first four fields must match
    // DEVICE_EXTENSION_FDO
    //

    DEVICE_EXTENSION_HEADER;
    DEVICE_EXTENSION_COMMON;
    KEVENT PnpStartEvent;
    PIRP PowerIrp;
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT  WmiLibInfo;
#endif /* WMI_SUPPORT */

    //
    // Pdo created by HCD for the root hub
    //
    PDEVICE_OBJECT          RootHubPdo;
    //
    // top of the host controller stack
    // typically this is the FDO for the HCD
    //
    PDEVICE_OBJECT          TopOfHcdStackDeviceObject;

    ULONG                   HubFlags;

    //
    // we use the hub mutex to serialize access to the
    // hub ports between ioctls and pnp events
    //

    ULONG                   PendingRequestCount;
    ULONG                   ErrorCount;
    HUB_STATE               HubState;
    PIRP                    Irp;

    PIRP                    PendingWakeIrp;
    LONG                    NumberPortWakeIrps;
    PUCHAR                  TransferBuffer;
    ULONG                   TransferBufferLength;
    PKEVENT                 Event;

    PUSB_HUB_DESCRIPTOR     HubDescriptor;
    PPORT_DATA              PortData;
    USBD_CONFIGURATION_HANDLE Configuration;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;

    DEVICE_POWER_STATE      DeviceState[PowerSystemMaximum];
    SYSTEM_POWER_STATE      SystemWake;
    DEVICE_POWER_STATE      DeviceWake;
    DEVICE_POWER_STATE      CurrentPowerState;
    LONG                    MaximumPowerPerPort;
    PORT_STATE              PortStateBuffer;

    LONG                    ResetPortNumber;
    PUSBH_WORK_ITEM         WorkItemToQueue;

    KEVENT                  AbortEvent;
    KEVENT                  PendingRequestEvent;

    //
    // we use the hub mutex to serialize access to the
    // hub ports between ioctls and pnp events
    //

    KSEMAPHORE              HubMutex;
    KSEMAPHORE              HubPortResetMutex;
    KSEMAPHORE              ResetDeviceMutex;

    USB_DEVICE_DESCRIPTOR   DeviceDescriptor;
    USBD_PIPE_INFORMATION   PipeInformation;
    URB                     Urb;

    LONG                    InESDRecovery;

#ifdef USB2
    USB_BUS_INTERFACE_HUB_V5 BusIf;
    USB_BUS_INTERFACE_USBDI_V2 UsbdiBusIf;
#endif

    PIRP                    PendingIdleIrp;
    USB_IDLE_CALLBACK_INFO  IdleCallbackInfo;
    KEVENT                  SubmitIdleEvent;

    LONG                    ChangeIndicationWorkitemPending;

    LONG                    WaitWakeIrpCancelFlag;
    LONG                    IdleIrpCancelFlag;

    KEVENT                  CWKEvent;

    // Only used for the Root Hub!
    SYSTEM_POWER_STATE      CurrentSystemPowerState;

    KSPIN_LOCK              CheckIdleSpinLock;

    // revised extension

    // deleted Pdo list, we use this list to handle 
    // async deletion of PDOs.  Basically these are 
    // PDO we have not reported gone to PnP yet.
    LIST_ENTRY              DeletePdoList;


} DEVICE_EXTENSION_HUB, *PDEVICE_EXTENSION_HUB;

#define HUBFLAG_NEED_CLEANUP            0x00000001
#define HUBFLAG_ENABLED_FOR_WAKEUP      0x00000002
#define HUBFLAG_DEVICE_STOPPING         0x00000004
#define HUBFLAG_HUB_FAILURE             0x00000008
#define HUBFLAG_SUPPORT_WAKEUP          0x00000010
#define HUBFLAG_HUB_STOPPED             0x00000020
#define HUBFLAG_HUB_BUSY                0x00000040
#define HUBFLAG_PENDING_WAKE_IRP        0x00000080
#define HUBFLAG_PENDING_PORT_RESET      0x00000100
#define HUBFLAG_HUB_HAS_LOST_BRAINS     0x00000200
#define HUBFLAG_SET_D0_PENDING          0x00000400
#define HUBFLAG_DEVICE_LOW_POWER        0x00000800
#define HUBFLAG_PENDING_IDLE_IRP        0x00001000
#define HUBFLAG_CHILD_DELETES_PENDING   0x00002000
#define HUBFLAG_HUB_GONE                0x00004000
#define HUBFLAG_USB20_HUB               0x00008000
#define HUBFLAG_NEED_IDLE_CHECK         0x00010000
#define HUBFLAG_WW_SET_D0_PENDING       0x00020000
#define HUBFLAG_USB20_MULTI_TT          0x00040000
#define HUBFLAG_POST_ESD_ENUM_PENDING   0x00080000
#define HUBFLAG_OK_TO_ENUMERATE         0x00100000
#define HUBFLAG_IN_IDLE_CHECK           0x00200000
#define HUBFLAG_HIBER                   0x00400000



typedef struct _DEVICE_EXTENSION_PARENT {
    DEVICE_EXTENSION_HEADER;
    DEVICE_EXTENSION_COMMON;

    KEVENT PnpStartEvent;
    PIRP PowerIrp;
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT  WmiLibInfo;
#endif /* WMI_SUPPORT */

    PIRP PendingWakeIrp;
    LONG NumberFunctionWakeIrps;
    ULONG FunctionCount;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
    SINGLE_LIST_ENTRY FunctionList;
    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    DEVICE_POWER_STATE CurrentPowerState;
    ULONG ParentFlags;
    BOOLEAN NeedCleanup;
    UCHAR CurrentConfig;
    UCHAR Reserved[2];
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;

    PCOMP_RESET_TIMEOUT_CONTEXT CompResetTimeoutContext;
    KSEMAPHORE ParentMutex;
    KSPIN_LOCK ParentSpinLock;

} DEVICE_EXTENSION_PARENT, *PDEVICE_EXTENSION_PARENT;

typedef struct _FUNCTION_INTERFACE {
    PUSBD_INTERFACE_INFORMATION InterfaceInformation;
    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
    ULONG InterfaceDescriptorLength;
} FUNCTION_INTERFACE, *PFUNCTION_INTERFACE;


typedef struct _DEVICE_EXTENSION_FUNCTION {
    DEVICE_EXTENSION_HEADER;

    PDEVICE_EXTENSION_PARENT DeviceExtensionParent;
    PDEVICE_OBJECT FunctionPhysicalDeviceObject;
    PIRP WaitWakeIrp;
    PIRP ResetIrp;
    ULONG InterfaceCount;
    ULONG FunctionPdoFlags;
    SINGLE_LIST_ENTRY ListEntry;
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;
    WCHAR UniqueIdString[4]; // room for three unicode digits plus
                             // NULL
    FUNCTION_INTERFACE FunctionInterfaceList[USBH_MAX_FUNCTION_INTERFACES];
} DEVICE_EXTENSION_FUNCTION, *PDEVICE_EXTENSION_FUNCTION;

//
// Device Extension for Port
//
typedef struct _DEVICE_EXTENSION_PORT {
    DEVICE_EXTENSION_HEADER;
    PDEVICE_OBJECT                  PortPhysicalDeviceObject;
    PDEVICE_EXTENSION_HUB           DeviceExtensionHub;
    USHORT                          PortNumber;
    // port you are on on your parent hub.
    USHORT                          SerialNumberBufferLength;
    PVOID                           DeviceData;
    DEVICE_POWER_STATE              DeviceState;
    PIRP                            WaitWakeIrp;
    // these flags describe the state of the PDO and
    // the capabilities of the device connected
    ULONG                           PortPdoFlags;
    ULONG                           DeviceHackFlags;

    PWCHAR                          SerialNumberBuffer;

    WCHAR                           UniqueIdString[4];
    // room for three unicode digits plus NULL
    UNICODE_STRING                  SymbolicLinkName;
    USB_DEVICE_DESCRIPTOR           DeviceDescriptor;
    USB_DEVICE_DESCRIPTOR           OldDeviceDescriptor;
    USB_CONFIGURATION_DESCRIPTOR    ConfigDescriptor;
    USB_INTERFACE_DESCRIPTOR        InterfaceDescriptor;

    // information returned through WMI
    //
    ULONG                           FailReasonId;
    ULONG                           PowerRequested;
    ULONG                           RequestedBandwidth;
    ULONG                           EnumerationFailReason;

    PPORT_TIMEOUT_CONTEXT           PortTimeoutContext;

    UCHAR                           FeatureDescVendorCode;
    PIRP                            IdleNotificationIrp;
    KSPIN_LOCK                      PortSpinLock;

    DEVICE_CAPABILITIES             DevCaps;
    PDEVICE_EXTENSION_HUB           HubExtSave;
    
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT                  WmiLibInfo;
#endif /* WMI_SUPPORT */

    // revised extension

    // Storage for MS Extended Config Descriptor Compatible IDs
    UCHAR                           CompatibleID[8];
    UCHAR                           SubCompatibleID[8];

    ULONG                           PnPFlags;

    LIST_ENTRY                      DeletePdoLink;

} DEVICE_EXTENSION_PORT, *PDEVICE_EXTENSION_PORT;


// values for PNP flags 
// #define PDO_PNPFLAG_     
#define PDO_PNPFLAG_DEVICE_PRESENT      0x00000001

typedef struct _SERIAL_NUMBER_ENTRY {
    ULONG   Vid;
    ULONG   Pid;
    PVOID   Pdo;
} SERIAL_NUMBER_ENTRY, *PSERIAL_NUMBER_ENTRY;

typedef struct _SERIAL_NUMBER_TABLE {
    ULONG                   NumEntries;
    ULONG                   MaxEntries;
    PSERIAL_NUMBER_ENTRY    Entries;
    FAST_MUTEX              Mutex;
} SERIAL_NUMBER_TABLE, * PSERIAL_NUMBER_TABLE;


//
// values for PortPdoFlags
//

#define PORTPDO_DEVICE_IS_HUB               0x00000001
#define PORTPDO_DEVICE_IS_PARENT            0x00000002
#define PORTPDO_DEVICE_ENUM_ERROR           0x00000004
#define PORTPDO_LOW_SPEED_DEVICE            0x00000008
#define PORTPDO_REMOTE_WAKEUP_SUPPORTED     0x00000010
#define PORTPDO_REMOTE_WAKEUP_ENABLED       0x00000020
#define PORTPDO_DELETED_PDO                 0x00000040
// revised
// set when the device for a PDO is removed from bus  
// (physically detached from hub)
// PnP may or may not know the device is gone.
#define PORTPDO_DELETE_PENDING              0x00000080
#define PORTPDO_NEED_RESET                  0x00000100
#define PORTPDO_STARTED                     0x00000200
#define PORTPDO_USB20_DEVICE_IN_LEGACY_HUB  0x00000400
#define PORTPDO_SYM_LINK                    0x00000800
#define PORTPDO_DEVICE_FAILED               0x00001000
#define PORTPDO_USB_SUSPEND                 0x00002000
#define PORTPDO_OVERCURRENT                 0x00004000
#define PORTPDO_DD_REMOVED                  0x00008000
#define PORTPDO_NOT_ENOUGH_POWER            0x00010000
// revised not used
//#define PORTPDO_PDO_RETURNED                0x00020000
#define PORTPDO_NO_BANDWIDTH                0x00040000
#define PORTPDO_RESET_PENDING               0x00080000
#define PORTPDO_OS_STRING_DESC_REQUESTED    0x00100000
#define PORTPDO_MS_VENDOR_CODE_VALID        0x00200000
#define PORTPDO_IDLE_NOTIFIED               0x00400000
#define PORTPDO_HIGH_SPEED_DEVICE           0x00800000
#define PORTPDO_NEED_CLEAR_REMOTE_WAKEUP    0x01000000
#define PORTPDO_WMI_REGISTERED              0x02000000
#define PORTPDO_VALID_FOR_PNP_FUNCTION      0x04000000
#define PORTPDO_CYCLED                      0x08000000

//
// NOTE: this macro will alway inavlidate the device state but
//      never change the current "fail reason"

#define HUB_FAILURE(de) \
    { \
    de->HubFlags |= HUBFLAG_HUB_FAILURE; \
    USBH_KdPrint((1, "'hub failure, VID %x PID %x line %d file %s\n", \
        de->DeviceDescriptor.idVendor, \
        de->DeviceDescriptor.idProduct, __LINE__, __FILE__)); \
    LOGENTRY(LOG_PNP, "HUB!", de, __LINE__, de->HubFlags); \
    }

//#define DEVICE_FAILURE(dep) \
//    { \
//    dep->PortPdoFlags |= PORTPDO_DEVICE_FAILED; \
//    USBH_KdPrint((1, "'device failure, VID %x PID %x line %d file %s\n", \
//        dep->DeviceDescriptor.idVendor, \
//        dep->DeviceDescriptor.idProduct,\
//        __LINE__, __FILE__)); \
//    LOGENTRY(LOG_PNP, "DEV!", dep, 0, 0); \
//    }

#define IS_ROOT_HUB(de) (de->PhysicalDeviceObject == de->RootHubPdo)

#define USBH_IoInvalidateDeviceRelations(devobj, b) \
    { \
    LOGENTRY(LOG_PNP, "HUBr", devobj, 0, 0); \
    USBH_KdPrint((1, "'IoInvalidateDeviceRelations %x\n", devobj));\
    IoInvalidateDeviceRelations(devobj, b); \
    }

//
// Length of buffer for Hub and port status are both 4
//
#define STATUS_HUB_OR_PORT_LENGTH 4

//
// Hub Characterics
//
//
// Powere switch mode
//
#define HUB_CHARS_POWER_SWITCH_MODE_MASK    0x0003
#define HUB_CHARS_POWER_SWITCH_GANGED       0x0000 //00
#define HUB_CHARS_POWER_SWITCH_INDIVIDUAL   0x0001 //01
#define HUB_CHARS_POWER_SWITCH_NONE         0x0002 //1X

#define HUB_IS_GANG_POWER_SWITCHED(hc) \
    (((hc) & HUB_CHARS_POWER_SWITCH_MODE_MASK) == HUB_CHARS_POWER_SWITCH_GANGED)

#define HUB_IS_NOT_POWER_SWITCHED(hc) \
    (((hc) & HUB_CHARS_POWER_SWITCH_NONE) ==  HUB_CHARS_POWER_SWITCH_NONE)

#define HUB_IS_PORT_POWER_SWITCHED(hc) \
    (((hc) & HUB_CHARS_POWER_SWITCH_MODE_MASK) == HUB_CHARS_POWER_SWITCH_INDIVIDUAL)


BOOLEAN
IsBitSet(
    PVOID Bitmap,
    ULONG PortNumber
    );

#define PORT_ALWAYS_POWER_SWITCHED(hd, p) \
    IsBitSet(&(hd)->bRemoveAndPowerMask[((hd)->bNumberOfPorts)/8 + 1], \
             (p))

#define PORT_DEVICE_NOT_REMOVABLE(hd, p) \
    IsBitSet(&(hd)->bRemoveAndPowerMask[0], \
             (p))

//
// Compound Device
//
#define HUB_CHARS_COMPOUND_DEVICE           0x4

//
// Over Current Protection Mode
//
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_MASK          0x18
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_GLOBAL        0x0
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_INDIVIDUAL    0x8
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_NONE          0x10


//
// Request codes, defined in Ch11
//
#define REQUEST_GET_STATUS          0
#define REQUEST_CLEAR_FEATURE       1
#define REQUEST_GET_STATE           2
#define REQUEST_SET_FEATURE         3
#define REQUEST_SET_ADDRESS         5
#define REQUEST_GET_DESCRIPTOR      6
#define REQUEST_SET_DESCRIPTOR      7
#define REQUEST_GET_CONFIGURATION   8
#define REQUEST_SET_CONFIGURATION   9
#define REQUEST_GET_INTERFACE       10
#define REQUEST_SET_INTERFACE       11
#define REQUEST_SYNCH_FRAME         12

//
// These request types can be composed.
// But it is just easy to define them.
//
#define REQUEST_TYPE_CLEAR_HUB_FEATURE  0x20
#define REQUEST_TYPE_CLEAR_PORT_FEATURE 0x23
#define REQUEST_TYPE_GET_BUS_STATE      0xa3
#define REQUEST_TYPE_GET_HUB_DESCRIPTOR 0xa0
#define REQUEST_TYPE_GET_HUB_STATUS     0xa0
#define REQUEST_TYPE_GET_PORT_STATUS    0xa3
#define REQUEST_TYPE_SET_HUB_DESCRIPTOR 0x20
#define REQUEST_TYPE_SET_HUB_FEATURE    0x20
#define REQUEST_TYPE_SET_PORT_FEATURE   0x23

//
// Feature selector, defined in Ch11
//
#define FEATURE_C_HUB_LOCAL_POWER   0
#define FEATURE_C_HUB_OVER_CURRENT  1
#define FEATURE_PORT_CONNECT        0
#define FEATURE_PORT_ENABLE         1
#define FEATURE_PORT_SUSPEND        2
#define FEATURE_PORT_OVER_CURRENT   3
#define FEATURE_PORT_RESET          4
#define FEATURE_PORT_POWER          8
#define FEATURE_PORT_LOW_SPEED      9
#define FEATURE_C_PORT_CONNECT      16
#define FEATURE_C_PORT_ENABLE       17
#define FEATURE_C_PORT_SUSPEND      18
#define FEATURE_C_PORT_OVER_CURRENT 19
#define FEATURE_C_PORT_RESET        20

//----------------------------------------------------------------------------------
// Utility Macros

#define UsbhBuildGetDescriptorUrb(\
                                pUrb, \
                                pDeviceData, \
                                bDescriptorType, \
                                bDescriptorIndex, \
                                wLanguageId, \
                                ulTransferLength, \
                                pTransferBuffer) \
    {\
    (pUrb)->UrbHeader.UsbdDeviceHandle = pDeviceData;\
    (pUrb)->UrbHeader.Length = (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST);\
    (pUrb)->UrbHeader.Function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;\
    (pUrb)->UrbControlDescriptorRequest.DescriptorType = bDescriptorType;\
    (pUrb)->UrbControlDescriptorRequest.Index =  bDescriptorIndex;\
    (pUrb)->UrbControlDescriptorRequest.LanguageId = wLanguageId;\
    (pUrb)->UrbControlDescriptorRequest.TransferBufferLength = ulTransferLength;\
    (pUrb)->UrbControlDescriptorRequest.TransferBuffer = pTransferBuffer;\
    (pUrb)->UrbControlDescriptorRequest.TransferBufferMDL = NULL;\
    (pUrb)->UrbControlVendorClassRequest.UrbLink = NULL;\
    }

#define UsbhBuildVendorClassUrb(\
                                    pUrb,\
                                    pDeviceData,\
                                    wFunction,\
                                    ulTransferFlags,\
                                    bRequestType,\
                                    bRequest,\
                                    wFeatureSelector,\
                                    wPort,\
                                    ulTransferBufferLength,\
                                    pTransferBuffer)\
    {\
    (pUrb)->UrbHeader.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);\
    (pUrb)->UrbHeader.Function = wFunction;\
    (pUrb)->UrbHeader.UsbdDeviceHandle = pDeviceData;\
    (pUrb)->UrbControlVendorClassRequest.TransferFlags = ulTransferFlags;\
    (pUrb)->UrbControlVendorClassRequest.TransferBufferLength = ulTransferBufferLength;\
    (pUrb)->UrbControlVendorClassRequest.TransferBuffer = pTransferBuffer;\
    (pUrb)->UrbControlVendorClassRequest.TransferBufferMDL = NULL;\
    (pUrb)->UrbControlVendorClassRequest.RequestTypeReservedBits = bRequestType;\
    (pUrb)->UrbControlVendorClassRequest.Request = bRequest;\
    (pUrb)->UrbControlVendorClassRequest.Value = wFeatureSelector;\
    (pUrb)->UrbControlVendorClassRequest.Index = wPort;\
    (pUrb)->UrbControlVendorClassRequest.UrbLink = NULL;\
    }

//----------------------------------------------------------------------------------
//
// string macros. these work with char and wide char strings
//
//  Counting the byte count of an ascii string or wide char string
//
#define STRLEN( Length, p )\
    {\
    int i;\
    for ( i=0; (p)[i]; i++ );\
    Length = i*sizeof(*p);\
    }

//
// copy wide char string
//
#define STRCPY( pDst, pSrc )\
    {\
    int nLength, i;\
    STRLEN( nLength, pSrc );\
    nLength /= sizeof( *pSrc );\
    for ( i=0; i < nLength; i++ ) pDst[i] = pSrc[i];\
    pDst[i] = 0;\
    }

//
// concat (wide) char strings
//
#define STRCAT( pFirst, pSecond )\
    {\
    int j, k;\
    int nLength;\
    STRLEN( j, pFirst );\
    STRLEN( nLength, pSecond );\
    j /= sizeof( *pFirst );\
    nLength /= sizeof( *pSecond);\
    for ( k=0; k < nLength; k++, j++ ) pFirst[j] = pSecond[k];\
    pFirst[j] = 0;\
    }

//
// append a (wide) char,
//
#define APPEND( pString, ch )\
    {\
    int nLength;\
    STRLEN( nLength, pString );\
    nLength /= sizeof( *pString );\
    pString[nLength] = ch;\
    pString[nLength+1] = 0;\
    }

//----------------------------------------------------------------------------------
//
// Debug Macros
//

#ifdef NTKERN
// Win95 only
#define DBGBREAK() _asm {int 3}
#else
#define DBGBREAK() DbgBreakPoint()
#endif

#define USBHUB_HEAP_TAG 0x42554855  //"UHUB"
#define USBHUB_FREE_TAG 0x62756875  //"uhub"

#if DBG

PVOID
UsbhGetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

VOID
UsbhRetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

// TEST_TRAP() is a code coverage trap these should be removed
// if you are able to 'g' past the OK
//
// KdTrap() breaks in the debugger on the debug build
// these indicate bugs in client drivers, kernel apis or fatal error
// conditions that should be debugged. also used to mark
// code for features not implemented yet.
//
// KdBreak() breaks in the debugger when in MAX_DEBUG mode
// ie debug trace info is turned on, these are intended to help
// debug drivers devices and special conditions on the
// bus.

ULONG
_cdecl
USBH_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define UsbhExAllocatePool(pt, l) UsbhGetHeap(pt, l, USBHUB_HEAP_TAG, \
    &UsbhHeapCount)
#define UsbhExFreePool(p)   UsbhRetHeap(p, USBHUB_HEAP_TAG, &UsbhHeapCount)
#define DBG_ONLY(s) s
#define USBH_KdPrint(_s_) USBH_KdPrintX _s_

//#define USBH_KdPrintAlways(s) { DbgPrint( "USBH: "); \
//                                DbgPrint s; \
//                              }
#ifdef MAX_DEBUG
#define USBH_KdBreak(s) if (USBH_Debug_Trace_Level) { \
                            DbgPrint( "USBH: "); \
                            DbgPrint s; \
                         } \
                         DBGBREAK();
#else
#define USBH_KdBreak(s)
#endif /* MAX_DEBUG */

#define USBH_KdTrap(s)  { DbgPrint( "USBH: ");\
                          DbgPrint s; \
                          DBGBREAK(); }

#define TEST_TRAP()  { DbgPrint( "USBH: Code coverage trap %s line: %d\n", __FILE__, __LINE__);\
                       DBGBREAK();}
#else // not debug
#define UsbhExAllocatePool(pt, l) ExAllocatePoolWithTag(pt, l, USBHUB_HEAP_TAG)
#define UsbhExFreePool(p)   ExFreePool(p)
#define DBG_ONLY(s)
#define USBH_KdPrint(_s_)
#define USBH_KdBreak(s)
#define USBH_KdTrap(s)
//#define USBH_KdPrintAlways(s)
#define TEST_TRAP();
#endif

#ifdef HOST_GLOBALS
#define DECLARE(type, var, init_value ) type var = init_value;
#define DECLARE_NO_INIT(type, var) type var;
#else
#define DECLARE(type, var, init_value ) extern type var;
#define DECLARE_NO_INIT(type, var ) extern type var;
#endif

//----------------------------------------------------------------------------------
//
// Global Variables
//

//
// Remember our driver object
//
DECLARE( PDRIVER_OBJECT, UsbhDriverObject, NULL)

extern PWCHAR GenericUSBDeviceString;


#if DBG
//
// keep track of heap allocations
//
DECLARE( ULONG, UsbhHeapCount, 0)

#define PNP_TEST_FAIL_ENUM          0x00000001
#define PNP_TEST_FAIL_DEV_POWER     0x00000002
#define PNP_TEST_FAIL_HUB_COUNT     0x00000004
#define PNP_TEST_FAIL_HUB           0x00000008
#define PNP_TEST_FAIL_PORT_RESET    0x00000010
#define PNP_TEST_FAIL_WAKE_REQUEST  0x00000020
#define PNP_TEST_FAIL_RESTORE       0x00000040

DECLARE( ULONG, UsbhPnpTest, 0)
#endif

//
// The following strings are used to build HardwareId etc.
//
// USB string
//
DECLARE( PWCHAR, pwchUsbSlash, L"USB\\");

// Vendor ID string
//
DECLARE( PWCHAR, pwchVid, L"Vid_");

//
// Product Id string
//
DECLARE( PWCHAR, pwchPid, L"Pid_");

//
// Revision string
//
DECLARE( PWCHAR, pwchRev, L"Rev_");

//
// Device Class string
//
DECLARE( PWCHAR, pwchDevClass, L"DevClass_");

//
// Class string
//
DECLARE( PWCHAR, pwchClass, L"Class_");

//
// Composite
//
DECLARE( PWCHAR, pwchComposite, L"USB\\COMPOSITE");

//
// SubClass string
//
DECLARE( PWCHAR, pwchSubClass, L"SubClass_");

//
// MultiInterface string
//
DECLARE( PWCHAR, pwchMultiInterface, L"USB\\MI");

//
// Device Protocol string
//
DECLARE( PWCHAR, pwchProt, L"Prot_");


DECLARE_NO_INIT( UNICODE_STRING, UsbhRegistryPath);

//
// To set the verbose level of the debug print
//
#ifdef MAX_DEBUG
#define DEBUG3
#endif /* MAX_DEBUG */

#ifdef DEBUG3
DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 3))
#else
    #ifdef DEBUG2
    DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 2))
    #else
        #ifdef DEBUG1
        DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 1))
        #else
        DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 0))
        #endif // DEBUG1
    #endif // DEBUG2
#endif // DEBUG3

#define USBH_DEBUGFLAG_BREAK_PDO_START       0x00000001

DBG_ONLY( DECLARE( ULONG, USBH_Debug_Flags, 0))

#if DBG

VOID
UsbhWarning(
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    PUCHAR Message,
    BOOLEAN DebugBreak
    );

#define ASSERT_HUB(de) USBH_ASSERT(EXTENSION_TYPE_HUB == ((PDEVICE_EXTENSION_HUB) de)->ExtensionType)
#define ASSERT_PORT(de) USBH_ASSERT(EXTENSION_TYPE_PORT == ((PDEVICE_EXTENSION_PORT) de)->ExtensionType)
#define ASSERT_FUNCTION(de) USBH_ASSERT(EXTENSION_TYPE_FUNCTION == ((PDEVICE_EXTENSION_FUNCTION) de)->ExtensionType)
#else

#define UsbhWarning(x, y, z)

#define ASSERT_HUB(de)
#define ASSERT_PORT(de)
#define ASSERT_FUNCTION(de)
#endif

#define TO_USB_DEVICE       0
#define TO_USB_INTERFACE    1
#define TO_USB_ENDPOINT     2


//
// maximum number of times we will attempt to reset
// the hub before giving up
//

#define USBH_MAX_ERRORS     3

//----------------------------------------------------------------------------------
//
// Function Prototypes
//

#ifdef USB2

VOID
USBH_InitializeUSB2Hub(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

// use version 5
#define PUSB_HUB_BUS_INTERFACE PUSB_BUS_INTERFACE_HUB_V5
#define HUB_BUSIF_VERSION USB_BUSIF_HUB_VERSION_5

NTSTATUS
USBHUB_GetBusInterface(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PUSB_HUB_BUS_INTERFACE BusInterface
    );

VOID
USBHUB_SetDeviceHandleData(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PDEVICE_OBJECT PdoDeviceObject,
    PVOID DeviceData 
    );    

NTSTATUS
USBD_CreateDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE *DeviceData,
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags,
    IN USHORT PortStatus,
    IN USHORT PortNumber
    );

VOID
USBHUB_FlushAllTransfers(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );    

NTSTATUS
USBD_InitializeDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    );

NTSTATUS
USBD_RemoveDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG Flags
    );

NTSTATUS
USBD_GetDeviceInformationEx(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_NODE_CONNECTION_INFORMATION_EX DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSB_DEVICE_HANDLE DeviceData
    );

NTSTATUS
USBD_MakePdoNameEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    );

ULONG
USBD_CalculateUsbBandwidthEx(
    IN ULONG MaxPacketSize,
    IN UCHAR EndpointType,
    IN BOOLEAN LowSpeed
    );

NTSTATUS
USBD_RestoreDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE OldDeviceData,
    IN OUT PUSB_DEVICE_HANDLE NewDeviceData,
    IN PDEVICE_OBJECT RootHubPdo
    );

NTSTATUS
USBD_QuerySelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PBOOLEAN SelectiveSuspendEnabled
    );

NTSTATUS
USBD_SetSelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN BOOLEAN SelectiveSuspendEnabled
    );

NTSTATUS
USBHUB_GetRootHubName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PVOID Buffer,
    IN PULONG BufferLength
    );

//ULONG
//USBD_GetHackFlags(
//    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
//    );
#endif

NTSTATUS
USBH_SyncResetPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBH_SyncResumePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncSuspendPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

VOID
USBH_ProcessHubStateChange(
    IN PHUB_STATE CurrentHubState,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub);

VOID
USBH_ProcessPortStateChange(
    IN PPORT_STATE CurrentPortState,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub);

NTSTATUS
USBH_SyncGetPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength);

NTSTATUS
USBH_SyncClearPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN USHORT Feature);

NTSTATUS
USBH_SyncClearHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT Feature);

NTSTATUS
USBH_SyncEnablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncPowerOnPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN WaitForPowerGood);

NTSTATUS
USBH_SyncPowerOffPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncPowerOnPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING UniRegistryPath);

NTSTATUS
USBH_HubDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
USBH_DriverUnload(
    IN PDRIVER_OBJECT DriverObject);

VOID
UsbhWait(
    ULONG MiliSeconds);

NTSTATUS
USBH_PdoDispatch(
    PDEVICE_EXTENSION_PORT pDeviceExtensionPort,
    PIRP pIrp);

NTSTATUS
USBH_SyncGetHubDescriptor(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub);

NTSTATUS
USBH_SyncGetDeviceConfigurationDescriptor(
    PDEVICE_OBJECT DeviceObject,
    PUCHAR DataBuffer,
    ULONG DataBufferLength,
    OUT PULONG BytesReturned);

BOOLEAN
USBH_ValidateSerialNumberString(
    PWCHAR DeviceId
    );

NTSTATUS
USBH_CreateDevice(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    USHORT PortNumber,
    USHORT PortStatus,
    ULONG RetryIteration
    );

NTSTATUS
USBH_FdoSyncSubmitUrb(
    PDEVICE_OBJECT HubDeviceObject,
    IN PURB Urb);

NTSTATUS
USBH_SyncGetRootHubPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PDEVICE_OBJECT *RootHubPdo,
    IN OUT PDEVICE_OBJECT *HcdDeviceObject,
    IN OUT PULONG Count
    );

NTSTATUS
USBH_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject);

NTSTATUS
USBH_FdoPnP(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PIRP Irp,
    UCHAR MinorFunction);

NTSTATUS
USBH_FdoPower(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PIRP Irp,
    UCHAR MinorFunction);

NTSTATUS
USBH_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context);

VOID
USBH_ChangeIndicationWorker(
    PVOID Context);

NTSTATUS
USBH_PassIrp(
    PIRP Irp,
    PDEVICE_OBJECT NextDeviceObject);

VOID
USBH_CompleteIrp(
     IN PIRP Irp,
     IN NTSTATUS NtStatus);

NTSTATUS
USBH_SyncDisablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncGetHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength);

NTSTATUS
USBH_FdoHubStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp);

NTSTATUS
USBH_ParentFdoStartDevice(
    IN OUT PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN BOOLEAN NewList
    );

NTSTATUS
USBH_ParentDispatch(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

NTSTATUS
USBH_GetConfigurationDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR *DataBuffer
    );

PWCHAR
USBH_BuildDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    );

PWCHAR
USBH_BuildHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    );

PWCHAR
USBH_BuildCompatibleIDs(
    IN PUCHAR CompatibleID,
    IN PUCHAR SubCompatibleID,
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    );

PWCHAR
USBH_BuildInstanceID(
    IN PWCHAR UniqueIdString,
    IN ULONG Length
    );

NTSTATUS
USBH_GetDeviceDescriptor(
    IN PDEVICE_OBJECT HubFDO,
    OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor
    );

NTSTATUS
USBH_GetDeviceQualifierDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    OUT PUSB_DEVICE_QUALIFIER_DESCRIPTOR DeviceQualifierDescriptor
    );

NTSTATUS
USBH_FunctionPdoDispatch(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    );

NTSTATUS
USBH_CloseConfiguration(
    IN PDEVICE_EXTENSION_FDO DeviceExtensionFdo
    );

NTSTATUS
USBH_IoctlGetNodeInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_IoctlGetHubCapabilities(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_IoctlGetNodeConnectionInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN BOOLEAN ExApi
    );

NTSTATUS
USBH_IoctlGetDescriptorForPDO(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_SyncSubmitUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );

NTSTATUS
USBH_Transact(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    IN BOOLEAN DataOutput,
    IN USHORT Function,
    IN UCHAR RequestType,
    IN UCHAR Request,
    IN USHORT Feature,
    IN USHORT Port,
    OUT PULONG BytesTransferred
    );

NTSTATUS
USBH_GetNameFromPdo(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString
    );

NTSTATUS
USBH_MakeName(
    PDEVICE_OBJECT PdoDeviceObject,
    ULONG NameLength,
    PWCHAR Name,
    PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBH_FdoStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

NTSTATUS
USBH_FdoStopDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoRemoveDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoQueryBusRelations(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
UsbhFdoCleanup(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_ProcessDeviceInformation(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_PdoQueryId(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoPnP(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN PBOOLEAN CompleteIrp
    );

NTSTATUS
USBH_PdoRemoveDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoQueryCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoSetPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_ParentFdoStopDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

NTSTATUS
USBH_ParentFdoRemoveDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

VOID
UsbhParentFdoCleanup(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    );

NTSTATUS
USBH_ParentQueryBusRelations(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

NTSTATUS
USBH_FunctionPdoQueryId(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    );

NTSTATUS
USBH_FunctionPdoQueryDeviceText(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    );

NTSTATUS
USBH_FunctionPdoPnP(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN OUT PBOOLEAN IrpNeedsCompletion
    );

NTSTATUS
USBH_IoctlGetNodeName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

BOOLEAN
USBH_HubIsBusPowered(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
USBH_SyncGetStatus(
    IN PDEVICE_OBJECT HubFDO,
    IN OUT PUSHORT StatusBits,
    IN USHORT function,
    IN USHORT Index
    );

NTSTATUS
USBH_GetSerialNumberString(
    IN PDEVICE_OBJECT DevicePDO,
    IN OUT PWCHAR *SerialNumberBuffer,
    IN OUT PUSHORT SerialNumberBufferLength,
    IN LANGID LanguageId,
    IN UCHAR StringIndex
    );

NTSTATUS
USBH_SyncGetStringDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    IN UCHAR Index,
    IN USHORT LangId,
    IN OUT PUSB_STRING_DESCRIPTOR Buffer,
    IN ULONG BufferLength,
    IN PULONG BytesReturned,
    IN BOOLEAN ExpectHeader
    );

NTSTATUS
USBH_SyncFeatureRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT FeatureSelector,
    IN USHORT Index,
    IN USHORT Target,
    IN BOOLEAN ClearFeature
    );

NTSTATUS
USBH_PdoIoctlGetPortStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoIoctlEnablePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoDeferPoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

NTSTATUS
USBH_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_BuildFunctionConfigurationDescriptor(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN OUT PUCHAR Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned
    );

NTSTATUS
USBH_ResetHub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_ResetDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN KeepConfiguration,
    IN ULONG RetryIteration
    );

NTSTATUS
USBH_PdoIoctlResetPort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_SetPowerD1orD2(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_SetPowerD0(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_SetPowerD3(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_PdoQueryDeviceText(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_CheckDeviceLanguage(
    IN PDEVICE_OBJECT DevicePDO,
    IN LANGID LanguageId
    );

NTSTATUS
USBH_PdoPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    );

NTSTATUS
USBH_SubmitInterruptTransfer(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_SymbolicLink(
    BOOLEAN CreateFlag,
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    LPGUID lpGuid
    );

NTSTATUS
USBH_SyncPowerOffPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_RestoreDevice(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN BOOLEAN KeepConfiguration
    );

NTSTATUS
USBH_PnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_ParentCreateFunctionList(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList,
    IN PURB Urb
    );

NTSTATUS
USBH_PdoStopDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_ChangeIndicationProcessChange(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_ChangeIndicationAckChangeComplete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_ChangeIndicationAckChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port,
    IN USHORT FeatureSelector
    );

NTSTATUS
USBH_IoctlGetNodeConnectionDriverKeyName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_ChangeIndicationQueryChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port
    );

NTSTATUS
USBH_InvalidatePortDeviceState(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USB_CONNECTION_STATUS ConnectStatus,
    IN USHORT PortNumber
    );

NTSTATUS
USBH_PdoEvent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber
    );

USB_CONNECTION_STATUS
UsbhGetConnectionStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_ParentSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    );

NTSTATUS
USBH_WriteFailReason(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG FailReason
    );

NTSTATUS
USBH_WriteRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN ULONG Data
    );

NTSTATUS
USBH_SystemControl (
    IN  PDEVICE_EXTENSION_FDO DeviceExtensionFdo,
    IN  PIRP            Irp
    );

NTSTATUS
USBH_PortSystemControl (
    IN  PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN  PIRP Irp
    );

NTSTATUS
USBH_ExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

NTSTATUS
USBH_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
USBH_PortQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
USBH_FlushPortChange(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_PdoIoctlCyclePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_ResetPortOvercurrent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_SyncGetControllerInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG Ioctl
    );

NTSTATUS
USBH_SyncGetHubName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
USBH_IoctlHubSymbolicName(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
USBH_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

NTSTATUS
USBH_PortQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

NTSTATUS
USBH_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    );

NTSTATUS
USBH_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    );

NTSTATUS
USBH_GetPdoRegistryParameter(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PWCHAR           ValueName,
    OUT PVOID           Data,
    IN ULONG            DataLength,
    OUT PULONG          Type,
    OUT PULONG          ActualDataLength
    );

NTSTATUS
USBH_OsVendorCodeQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
USBH_GetMsOsVendorCode(
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBH_GetMsOsFeatureDescriptor(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            Interface,
    IN USHORT           Index,
    IN OUT PVOID        DataBuffer,
    IN ULONG            DataBufferLength,
    OUT PULONG          BytesReturned
    );

VOID
USBH_InstallExtPropDesc (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
USBH_InstallExtPropDescSections (
    PDEVICE_OBJECT      DeviceObject,
    PMS_EXT_PROP_DESC   pMsExtPropDesc
    );

PMS_EXT_CONFIG_DESC
USBH_GetExtConfigDesc (
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
USBH_ValidateExtConfigDesc (
    IN PMS_EXT_CONFIG_DESC              MsExtConfigDesc,
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor
    );

NTSTATUS
USBH_CalculateInterfaceBandwidth(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSBD_INTERFACE_INFORMATION Interface,
    IN OUT PULONG Bandwidth // in kenr units?
    );

NTSTATUS
USBH_RegQueryDeviceIgnoreHWSerNumFlag(
    IN USHORT idVendor,
    IN USHORT idProduct,
    IN OUT PBOOLEAN IgnoreHWSerNumFlag
    );

NTSTATUS
USBH_RegQueryGenericUSBDeviceString(
    IN OUT PWCHAR *GenericUSBDeviceString
    );

VOID
USBH_ParentCompleteFunctionWakeIrps(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN NTSTATUS NtStatus
    );

BOOLEAN
USBH_ValidateConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdSatus
    );

VOID
USBH_HubCompletePortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    );

VOID
USBH_HubCompletePortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    );

PUSB_DEVICE_HANDLE
USBH_SyncGetDeviceHandle(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
USBH_CompletePowerIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN NTSTATUS NtStatus
    );

VOID
USBH_HubESDRecoveryWorker(
    IN PVOID Context);

NTSTATUS
USBH_ScheduleESDRecovery(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

// these are for the USB2 'backport'
PWCHAR
USBH_BuildHubHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId
    );

PWCHAR
USBH_BuildHubCompatibleIDs(
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    );

NTSTATUS
USBH_IoctlCycleHubPort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_InternalCyclePort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );    

PWCHAR
USBH_BuildHubDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId
    );

NTSTATUS
USBHUB_GetBusInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_BUS_NOTIFICATION BusInfo,
    IN PVOID BusContext
    );

NTSTATUS
USBHUB_GetBusInfoDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSB_BUS_NOTIFICATION BusInfo
    );

NTSTATUS
USBHUB_GetBusInterfaceUSBDI(
    IN PDEVICE_OBJECT HubPdo,
    IN PUSB_BUS_INTERFACE_USBDI_V2 BusInterface
    );

USB_DEVICE_TYPE
USBH_GetDeviceType(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData
    );

VOID
USBH_CompletePortIdleNotification(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

VOID
USBH_PortIdleNotificationCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoSubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_HubSetD0(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBHUB_GetControllerName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_HUB_NAME Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
USBHUB_GetExtendedHubInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_EXTHUB_INFORMATION_0 ExtendedHubInfo
    );

BOOLEAN
USBH_DoesHubNeedWaitWake(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_CheckHubIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_PdoSetContentId(
    IN PIRP                          irp,
    IN PVOID                         pKsProperty,
    IN PVOID                         pvData
    );

BOOLEAN
USBH_CheckDeviceIDUnique(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT IDVendor,
    IN USHORT IDProduct,
    IN PWCHAR SerialNumberBuffer,
    IN USHORT SerialNumberBufferLength
    );

VOID
USBH_IdleCompletePowerHubWorker(
    IN PVOID Context
    );

BOOLEAN
USBH_DeviceIs2xDualMode(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

PDEVICE_EXTENSION_HUB
USBH_GetRootHubDevExt(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_CheckLeafHubsIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_HubCancelWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_HubCancelIdleIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_IoctlGetNodeConnectionAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_CompletePortIdleIrpsWorker(
    IN PVOID Context);

VOID
USBH_CompletePortWakeIrpsWorker(
    IN PVOID Context);

VOID
USBH_HubAsyncPowerWorker(
    IN PVOID Context);

VOID
USBH_IdleCancelPowerHubWorker(
    IN PVOID Context);

NTSTATUS
USBD_InitUsb2Hub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_PdoSetCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );    

NTSTATUS
USBH_HubPnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_RegQueryUSBGlobalSelectiveSuspend(
    IN OUT PBOOLEAN DisableSelectiveSuspend
    );

VOID
USBH_SyncRefreshPortAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBD_RegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBD_UnRegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_PdoStartDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

#define PDO_EXT(p) PdoExt((p))

PDEVICE_EXTENSION_PORT
PdoExt(
    PDEVICE_OBJECT DeviceObject
    );    
    
#ifdef TEST_MS_DESC

#pragma message ("Warning! Compiling in non-retail test code!")

NTSTATUS
USBH_SyncGetMsOsDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT Index,
    IN OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned);

NTSTATUS
USBH_TestGetMsOsDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT Index
    );

#endif

#define LOG_PNP 0x00000001

#if DBG

NTSTATUS
USBH_GetClassGlobalDebugRegistryParameters(
    );

VOID
UsbhInfo(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_ShowPortState(
    IN USHORT PortNumber,
    IN PPORT_STATE PortState
    );

#define DEBUG_LOG

#define USBH_ASSERT(exp) \
    if (!(exp)) { \
        USBH_Assert( #exp, __FILE__, __LINE__, NULL );\
    }

VOID
USBH_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );
#else
#define USBH_ASSERT(exp)
#define UsbhInfo(de)
#endif

#ifdef DEBUG_LOG
VOID
USBH_LogInit(
    );

VOID
USBH_LogFree(
    );

#define LOGENTRY(mask, sig, info1, info2, info3) \
    USBH_Debug_LogEntry(mask, sig,               \
                        (ULONG_PTR)info1,        \
                        (ULONG_PTR)info2,        \
                        (ULONG_PTR)info3)

VOID
USBH_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
    );

#else
#define LOGENTRY(mask, sig, info1, info2, info3)
#define USBH_LogInit()
#define USBH_LogFree()
#endif

// last workitem will let the shutdown code continue
// !! do not reference the devicExtension beyond this point
// if event is signaled
#define USBH_DEC_PENDING_IO_COUNT(de) \
    LOGENTRY(LOG_PNP, "PEN-", de, &de->PendingRequestEvent, de->PendingRequestCount); \
    if (InterlockedDecrement(&de->PendingRequestCount) == 0) {\
        USBH_ASSERT(de->HubFlags & HUBFLAG_DEVICE_STOPPING); \
        LOGENTRY(LOG_PNP, "hWAK", de, &de->PendingRequestEvent, de->PendingRequestCount); \
        KeSetEvent(&de->PendingRequestEvent, 1, FALSE); \
    }

#define USBH_INC_PENDING_IO_COUNT(de) \
    {\
    LOGENTRY(LOG_PNP, "PEN+", de, &de->PendingRequestEvent, de->PendingRequestCount); \
    InterlockedIncrement(&de->PendingRequestCount);\
    }

PPORT_DATA
USBH_PortDataDataFromPdo(
    PDEVICE_EXTENSION_HUB HubDevExt,
    PDEVICE_OBJECT Pdo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\sync.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    SYNC.C

Abstract:

    This module contains Synchronous calls for USB Hub driver

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    04-01-96 : created
    10-27-96 : jd modified to use a single transact function for calls to usb stack

--*/
#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"
#include <stdio.h>

// delay after usb reset (in milliseconds), spec calls for 10ms
ULONG USBH_PostResetDelay = 10;

//
// expect string descriptor header on list of supported languages
//
#define HEADER

#define DEADMAN_TIMER
#define DEADMAN_TIMEOUT     5000     //timeout in ms
                                     //use a 5 second timeout

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_SyncSubmitUrb)
#pragma alloc_text(PAGE, UsbhWait)
#pragma alloc_text(PAGE, USBH_SyncGetRootHubPdo)
#pragma alloc_text(PAGE, USBH_FdoSyncSubmitUrb)
#pragma alloc_text(PAGE, USBH_Transact)
#pragma alloc_text(PAGE, USBH_SyncGetPortStatus)
#pragma alloc_text(PAGE, USBH_SyncGetHubStatus)
#pragma alloc_text(PAGE, USBH_SyncClearHubStatus)
#pragma alloc_text(PAGE, USBH_SyncClearPortStatus)
#pragma alloc_text(PAGE, USBH_SyncPowerOnPort)
#pragma alloc_text(PAGE, USBH_SyncPowerOnPorts)
#pragma alloc_text(PAGE, USBH_SyncSuspendPort)
#pragma alloc_text(PAGE, USBH_SyncDisablePort)
#pragma alloc_text(PAGE, USBH_SyncEnablePort)
#pragma alloc_text(PAGE, USBH_SyncPowerOffPort)
#pragma alloc_text(PAGE, USBH_SyncResumePort)
#pragma alloc_text(PAGE, USBH_SyncResetPort)
#pragma alloc_text(PAGE, USBH_SyncResetDevice)
#pragma alloc_text(PAGE, USBH_SyncGetDeviceConfigurationDescriptor)
#pragma alloc_text(PAGE, USBH_GetConfigurationDescriptor)
#pragma alloc_text(PAGE, USBH_GetDeviceDescriptor)
#pragma alloc_text(PAGE, USBH_GetDeviceQualifierDescriptor)
#pragma alloc_text(PAGE, USBH_SyncGetHubDescriptor)
#pragma alloc_text(PAGE, USBH_GetSerialNumberString)
#pragma alloc_text(PAGE, USBH_SyncGetStatus)
#pragma alloc_text(PAGE, USBH_SyncGetStringDescriptor)
#pragma alloc_text(PAGE, USBH_SyncFeatureRequest)
#pragma alloc_text(PAGE, USBH_CheckDeviceLanguage)
#endif
#endif


VOID
UsbhWait(
    IN ULONG MiliSeconds)
 /* ++
  *
  * Descriptor:
  *
  * This causes the thread execution delayed for ulMiliSeconds.
  *
  * Argument:
  *
  * Mili-seconds to delay.
  *
  * Return:
  *
  * VOID
  *
  * -- */
{
    LARGE_INTEGER time;
    ULONG timerIncerent;

    USBH_KdPrint((2,"'Wait for %d ms\n", MiliSeconds));

    //
    // work only when LowPart is not overflown.
    //
    USBH_ASSERT(21474 > MiliSeconds);

    //
    // wait ulMiliSeconds( 10000 100ns unit)
    //
    timerIncerent = KeQueryTimeIncrement() - 1;

    time.HighPart = -1;
    // round up to the next highest timer increment
    time.LowPart = -1 * (10000 * MiliSeconds + timerIncerent);
    KeDelayExecutionThread(KernelMode, FALSE, &time);

    USBH_KdPrint((2,"'Wait done\n"));

    return;
}

#ifdef DEADMAN_TIMER
VOID
UsbhTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PHUB_TIMEOUT_CONTEXT hubTimeoutContext = DeferredContext;
    BOOLEAN complete, status;
    KIRQL irql;

    KeAcquireSpinLock(&hubTimeoutContext->TimeoutSpin, &irql);
    complete = hubTimeoutContext->Complete;
    LOGENTRY(LOG_PNP, "dpTO", hubTimeoutContext->Irp, 0, complete);
    KeReleaseSpinLock(&hubTimeoutContext->TimeoutSpin, irql);

    if (!complete) {

        LOGENTRY(LOG_PNP, "TOca", hubTimeoutContext->Irp, 0, complete);
        IoCancelIrp(hubTimeoutContext->Irp);

    }

    //OK to free it
    KeSetEvent(&hubTimeoutContext->Event, 1, FALSE);
}


NTSTATUS
USBH_SyncIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PHUB_TIMEOUT_CONTEXT hubTimeoutContext = Context;
    KIRQL irql;
    BOOLEAN cancelled;

    KeAcquireSpinLock(&hubTimeoutContext->TimeoutSpin, &irql);

    LOGENTRY(LOG_PNP, "klTO", hubTimeoutContext->Irp, 0, Context);
    hubTimeoutContext->Complete = TRUE;
    cancelled = KeCancelTimer(&hubTimeoutContext->TimeoutTimer);

    KeReleaseSpinLock(&hubTimeoutContext->TimeoutSpin, irql);

    // see if the timer was in the queue, if it was then it is safe to free
    // it

    if (cancelled) {
        // safe to free it
        KeSetEvent(&hubTimeoutContext->Event, 1, FALSE);
    }

    return STATUS_SUCCESS;
}

#endif /* DEADMAN_TIMER */


NTSTATUS
USBH_SyncSubmitUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb)
 /* ++
  *
  * Routine Description:
  *
  * Passes a URB to the USBD class driver, and wait for return.
  *
  * Arguments:
  *
  * pDeviceObject - the hub device pUrb - pointer to the URB to send to USBD
  *
  * Return Value:
  *
  * STATUS_SUCCESS if successful, STATUS_UNSUCCESSFUL otherwise
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    BOOLEAN haveTimer = FALSE;
    PHUB_TIMEOUT_CONTEXT hubTimeoutContext = NULL;

    USBH_KdPrint((2,"'enter USBH_SyncSubmitUrb\n"));

    PAGED_CODE();

    //
    // null out device handle in case we are the root hub
    Urb->UrbHeader.UsbdDeviceHandle = NULL;

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                                         IOCTL_INTERNAL_USB_SUBMIT_URB,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("CallUsbd build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    nextStack->Parameters.Others.Argument1 = Urb;

#ifdef DEADMAN_TIMER
    hubTimeoutContext = UsbhExAllocatePool(NonPagedPool,
                                           sizeof(*hubTimeoutContext));
    if (hubTimeoutContext) {
        LARGE_INTEGER dueTime;

        hubTimeoutContext->Irp = irp;
        hubTimeoutContext->Complete = FALSE;

        KeInitializeEvent(&hubTimeoutContext->Event, NotificationEvent, FALSE);
        KeInitializeSpinLock(&hubTimeoutContext->TimeoutSpin);
        KeInitializeTimer(&hubTimeoutContext->TimeoutTimer);
        KeInitializeDpc(&hubTimeoutContext->TimeoutDpc,
                        UsbhTimeoutDPC,
                        hubTimeoutContext);

        dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

        KeSetTimer(&hubTimeoutContext->TimeoutTimer,
                   dueTime,
                   &hubTimeoutContext->TimeoutDpc);

        haveTimer = TRUE;

        IoSetCompletionRoutine(irp,
                           USBH_SyncIrp_Complete,
                           // always pass FDO to completion routine
                           hubTimeoutContext,
                           TRUE,
                           TRUE,
                           TRUE);
    }
#endif


    USBH_KdPrint((2,"'calling USBD\n"));

    LOGENTRY(LOG_PNP, "ssUR", irp, 0, Urb);
    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

#ifdef DEADMAN_TIMER
    // the completion routine should have canceled the timer
    // so we should never find it in the queue
    //
    // remove our timeoutDPC from the queue
    //
    if (haveTimer) {
        USBH_ASSERT(KeCancelTimer(&hubTimeoutContext->TimeoutTimer) == FALSE);
        KeWaitForSingleObject(&hubTimeoutContext->Event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        LOGENTRY(LOG_PNP, "frTO", irp, 0, Urb);
        UsbhExFreePool(hubTimeoutContext);
    }
#endif /* DEADMAN_TIMER */

    USBH_KdPrint((2,"'URB status = %x status = %x irp status %x\n",
                  Urb->UrbHeader.Status, status, ioStatus.Status));

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncSubmitUrb (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncGetRootHubPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PDEVICE_OBJECT *RootHubPdo,
    IN OUT PDEVICE_OBJECT *TopOfHcdStackDeviceObject,
    IN OUT PULONG Count
    )
 /* ++
  *
  * Routine Description:
  *
  *     call pdo to get the root hub PDO for our fastpath to the
  *         usb stack.
  *     if Count is non-null then return th ehub count, otherwise return
  *         the root hub PDO
  * Arguments:
  *
  * Return Value:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncSubmitUrb\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( Count == NULL ?
                                          IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO :
                                          IOCTL_INTERNAL_USB_GET_HUB_COUNT,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("USBH_SyncGetRootHubPdo build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    if (Count == NULL) {
        nextStack->Parameters.Others.Argument1 = RootHubPdo;
        nextStack->Parameters.Others.Argument2 = TopOfHcdStackDeviceObject;
    } else {
        nextStack->Parameters.Others.Argument1 = Count;
    }

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetRootHubPdo (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncGetControllerInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG Ioctl
    )
 /* ++
  *
  * Routine Description:
  *
  *     call pdo to get the root hub PDO for our fastpath to the
  *         usb stack.
  *     if Count is non-null then return th ehub count, otherwise return
  *         the root hub PDO
  * Arguments:
  *
  * Return Value:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetControllerName\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("USBH_SyncGetControllerName build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = Buffer;
    nextStack->Parameters.Others.Argument2 = ULongToPtr(BufferLength);

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetHubName (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncGetHubName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
 /* ++
  *
  * Routine Description:
  *
  *     call pdo to get the root hub PDO for our fastpath to the
  *         usb stack.
  *     if Count is non-null then return th ehub count, otherwise return
  *         the root hub PDO
  * Arguments:
  *
  * Return Value:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetHubName\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( IOCTL_INTERNAL_USB_GET_HUB_NAME,
                                         DeviceObject,
                                         Buffer,
                                         BufferLength,
                                         Buffer,
                                         BufferLength,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("USBH_SyncGetHubName build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetHubName (%x)\n", ntStatus));

    return ntStatus;
}



NTSTATUS
USBH_FdoSyncSubmitUrb(
    IN PDEVICE_OBJECT HubDeviceObject,
    IN PURB Urb)
 /* ++
  *
  * Routine Description:
  *
  * Arguments:
  *
  * Return Value:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;
    PDEVICE_EXTENSION_FDO deviceExtensionFdo;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_FdoSyncSubmitUrb\n"));

    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) HubDeviceObject->DeviceExtension;
    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) HubDeviceObject->DeviceExtension;
    USBH_ASSERT(EXTENSION_TYPE_HUB == deviceExtensionHeader->ExtensionType ||
           EXTENSION_TYPE_PARENT == deviceExtensionHeader->ExtensionType );


    ntStatus = USBH_SyncSubmitUrb(deviceExtensionFdo->TopOfStackDeviceObject, Urb);

    USBH_KdPrint((2,"'return from USBH_FdoSyncSubmitUrb %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_Transact(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    IN BOOLEAN DataOutput,
    IN USHORT Function,
    IN UCHAR RequestType,
    IN UCHAR Request,
    IN USHORT Feature,
    IN USHORT Port,
    OUT PULONG BytesTransferred)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUCHAR transferBuffer = NULL;
    ULONG transferFlags;
    ULONG localDataBuferLength;
#if DBG || defined(DEBUG_LOG)
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
#endif

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter USBH_Transact\n"));
    USBH_ASSERT(DeviceExtensionHub);

    // round DataTransferLength
    localDataBuferLength = DataBufferLength+sizeof(ULONG);
    // make sure we are dword aligned
    localDataBuferLength &= 0xFFFFFFFC;
    USBH_ASSERT(localDataBuferLength >= DataBufferLength);
    //
    // Allocate a transaction buffer and Urb from the non-paged pool
    //

    transferBuffer = UsbhExAllocatePool(NonPagedPool, localDataBuferLength );
    urb = UsbhExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

    if (transferBuffer && urb) {
        USBH_KdPrint((2,"'Transact transfer buffer = %x urb = %x\n",
            transferBuffer, urb));

        transferFlags = 0;

        if (DataOutput) {
            // copy output data to transfer buffer
            if (DataBufferLength) {
                RtlCopyMemory(transferBuffer,
                              DataBuffer,
                              DataBufferLength);
            }

            transferFlags = USBD_TRANSFER_DIRECTION_OUT;

        } else {
            // zero the input buffer

            if (DataBufferLength) {
                RtlZeroMemory(DataBuffer,
                              DataBufferLength);
            }

            transferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
        }

        UsbhBuildVendorClassUrb(urb,
                                NULL,
                                Function,
                                transferFlags,
                                RequestType,
                                Request,
                                Feature,
                                Port,
                                DataBufferLength,
                                DataBufferLength ? transferBuffer : NULL);

        //
        // pass the URB to the USBD 'class driver'
        //

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject,
                                         urb);

        if (!DataOutput && DataBufferLength) {
            RtlCopyMemory(DataBuffer,
                          transferBuffer,
                          DataBufferLength);
        }

#if DBG || defined(DEBUG_LOG)
        usbdStatus = urb->UrbHeader.Status;
#endif

        UsbhExFreePool(transferBuffer);
        UsbhExFreePool(urb);
    } else {
        if (transferBuffer) {
            UsbhExFreePool(transferBuffer);
        }

        if (urb) {
            UsbhExFreePool(urb);
        }

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    LOGENTRY(LOG_PNP, "Xact", DeviceExtensionHub, usbdStatus, ntStatus);

    USBH_KdPrint((2,"'Exit USBH_Transact %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncGetPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *      PortNumber
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;

    PAGED_CODE();
    USBH_ASSERT(DeviceExtensionHub);
    ntStatus = USBH_Transact(DeviceExtensionHub,
                         DataBuffer,
                         DataBufferLength,
                         FALSE,
                         URB_FUNCTION_CLASS_OTHER,
                         REQUEST_TYPE_GET_PORT_STATUS,
                         REQUEST_GET_STATUS,
                         0,
                         PortNumber,
                         NULL);
#if DBG
    {
    PPORT_STATE portState;
    portState = (PPORT_STATE) DataBuffer;
    LOGENTRY(LOG_PNP, "pSTS", PortNumber, portState->PortChange, portState->PortStatus);
    }
#endif
    USBH_KdPrint((2,"'GetPortStatus ntStatus %x port %x state %x\n", ntStatus,
                    PortNumber, *DataBuffer));
    LOGENTRY(LOG_PNP, "pSTA", DeviceExtensionHub, PortNumber, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_SyncGetHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *      PortNumber
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PAGED_CODE();
    return USBH_Transact(DeviceExtensionHub,
                         DataBuffer,
                         DataBufferLength,
                         FALSE,
                         URB_FUNCTION_CLASS_DEVICE,
                         REQUEST_TYPE_GET_HUB_STATUS,
                         REQUEST_GET_STATUS,
                         0,
                         0,
                         NULL);
}


NTSTATUS
USBH_SyncClearHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT Feature)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *      PortNumber
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PAGED_CODE();
    return USBH_Transact(DeviceExtensionHub,
                         NULL,
                         0,
                         TRUE, // Host to Device
                         URB_FUNCTION_CLASS_DEVICE,
                         REQUEST_TYPE_SET_HUB_FEATURE,
                         REQUEST_CLEAR_FEATURE,
                         Feature,
                         0,
                         NULL);
}


NTSTATUS
USBH_SyncClearPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN USHORT Feature)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *      PortNumber
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PAGED_CODE();
    return USBH_Transact(DeviceExtensionHub,
                         NULL,
                         0,
                         TRUE,
                         URB_FUNCTION_CLASS_OTHER,
                         REQUEST_TYPE_SET_PORT_FEATURE,
                         REQUEST_CLEAR_FEATURE,
                         Feature,
                         PortNumber,
                         NULL);
}


NTSTATUS
USBH_SyncPowerOnPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN WaitForPowerGood)
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    ULONG numberOfPorts;
//    ULONG i;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncPowerOnPort pDE %x Port %x\n", DeviceExtensionHub, PortNumber));

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];
    numberOfPorts = hubDescriptor->bNumberOfPorts;
    USBH_ASSERT(PortNumber <= hubDescriptor->bNumberOfPorts);

    if (portData->PortState.PortStatus & PORT_STATUS_POWER) {
        //
        // our state flags indicate the port is already powered
        // just exit with success

        USBH_KdPrint((2,"'Exit SyncPowerOnPort port is on\n"));

        return STATUS_SUCCESS;
    }
// USB 1.1 spec change requires all ports to be powered on
// regardless of hub characteristics
#if 0
    if (HUB_IS_NOT_POWER_SWITCHED(hubDescriptor->wHubCharacteristics) &&
        !PORT_DEVICE_NOT_REMOVABLE(hubDescriptor, PortNumber)) {

        //
        // Ports always on when hub is on.
        // As soon as we power the first non-removable port mark all ports
        // as powered
        //

        //
        // mark all ports as powered
        //

        for (i=0; i<numberOfPorts; i++) {
            DeviceExtensionHub->PortData[i].PortState.PortStatus |= PORT_STATUS_POWER;
            USBH_KdPrint((1,"'POWER ON PORT --> marking port(%d) powered\n", i));
        }

        USBH_KdPrint((1,"'POWER ON PORT --> hub is not power switched\n"));

        return STATUS_SUCCESS;

    }
#endif

    //
    // Turn the power on
    //

    USBH_KdPrint((1,"'POWER ON PORT --> port(%d)\n", PortNumber));

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_POWER,
                             PortNumber,
                             NULL);


    if (NT_SUCCESS(ntStatus)) {

        // wait powerOnToPowerGood good for this hub to come up
        if (WaitForPowerGood) {
            UsbhWait(2*hubDescriptor->bPowerOnToPowerGood);
        }
#ifdef DEBUG
        USBH_KdPrint((1,"'Power On -> Power Good delay is: %d ms\n",
            2*hubDescriptor->bPowerOnToPowerGood));
#endif
        LOGENTRY(LOG_PNP, "PO2G", DeviceExtensionHub, PortNumber ,
            2*hubDescriptor->bPowerOnToPowerGood);

        //
        // mark this port as powered
        //
        portData->PortState.PortStatus |= PORT_STATUS_POWER;

// USB 1.1 spec change requires all ports to be powered on
// regardless of hub characteristics
#if 0
        if (HUB_IS_GANG_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {

            // since the hub is gang switched we need to loop thru
            // all the ports and mark them as powered

            USBH_KdPrint((1,"'POWER ON PORT --> gang switched hub\n"));

            for (i=0; i<numberOfPorts; i++) {
                PPORT_STATE portState;

                portState = &DeviceExtensionHub->PortData[i].PortState;

                // if the port is not marked powered and the power mask
                // is not set for this port (ie it is affected by gang
                // mode power switching) then  mark it as powered

                if (!(portState->PortStatus & PORT_STATUS_POWER) &&
                    !(PORT_ALWAYS_POWER_SWITCHED(hubDescriptor, i+1)))  {

                    USBH_KdPrint((1,"'POWER ON PORT --> marking port(%d) powered\n", i));

                    DeviceExtensionHub->PortData[i].PortState.PortStatus |= PORT_STATUS_POWER;
                }
            }

        }
#endif
        //
        // port power is on
        //

    }
#if DBG
      else {
         UsbhWarning(NULL,
                    "SyncPowerOnPort unsuccessful\n",
                    FALSE);
    }
#endif

    return ntStatus;
}


NTSTATUS
USBH_SyncPowerOnPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  * We will turn on the power of all ports unless this hub is not switched.
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    ULONG numberOfPorts, i;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncPowerOnPorts pDE %x\n", DeviceExtensionHub));

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);
    numberOfPorts = hubDescriptor->bNumberOfPorts;

    for (i=0; i<numberOfPorts; i++) {

// resume time perf change
        ntStatus = USBH_SyncPowerOnPort(DeviceExtensionHub,
                                        (USHORT) (i+1),
                                        FALSE);

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }
    }

    // bug 516250
    // pass FALSE to USBH_SyncPowerOnPort
    // do the power-on to power good wait here
    UsbhWait(2*hubDescriptor->bPowerOnToPowerGood);

    USBH_KdPrint((2,"'Exit SyncPowerOnPorts status %x\n", ntStatus));

    return ntStatus;
}

#if 0
NTSTATUS
USBH_SyncPowerOffPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * We will turn off the power of all ports.
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    ULONG numberOfPorts, i;

    USBH_KdPrint((2,"'Enter SyncPowerOffPorts pDE %x\n", DeviceExtensionHub));

    TEST_TRAP();

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);
    numberOfPorts = hubDescriptor->bNumberOfPorts;

    for (i=0; i<numberOfPorts; i++) {
        ntStatus = USBH_SyncPowerOffPort(DeviceExtensionHub,
                                        (USHORT) (i+1));
        if (!NT_SUCCESS(ntStatus)) {
            break;
        }
    }

    USBH_KdPrint((2,"'Exit SyncPowerOffPorts status %x\n", ntStatus));

    return ntStatus;
}
#endif

NTSTATUS
USBH_SyncSuspendPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * We will suspend the port specified on this hub
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncSuspendPort pDE %x\n", DeviceExtensionHub));


    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_SUSPEND,
                             PortNumber,
                             NULL);

    if (NT_SUCCESS(ntStatus)) {
        portData->PortState.PortStatus |= PORT_STATUS_SUSPEND;
    }

    USBH_KdPrint((2,"'Exit SyncSuspendPort  %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncDisablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncDisablePort pDE %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "DISp", DeviceExtensionHub, PortNumber , 0);

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_CLEAR_PORT_FEATURE,
                             REQUEST_CLEAR_FEATURE,
                             FEATURE_PORT_ENABLE,
                             PortNumber,
                             NULL);

    if (NT_SUCCESS(ntStatus)) {
        portData->PortState.PortStatus &= ~PORT_STATUS_ENABLE;
    }

    return ntStatus;
}


NTSTATUS
USBH_SyncEnablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncEnablePort pDE %x port %d\n", DeviceExtensionHub,
        PortNumber));

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_ENABLE,
                             PortNumber,
                             NULL);

    if (NT_SUCCESS(ntStatus)) {
        portData->PortState.PortStatus |= PORT_STATUS_ENABLE;
    }

    return ntStatus;
}


NTSTATUS
USBH_SyncPowerOffPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * We will suspend the port specified on this hub
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    ULONG numberOfPorts;

    USBH_KdPrint((2,"'Enter SyncPowerOffPort pDE %x Port %x\n", DeviceExtensionHub, PortNumber));

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];
    numberOfPorts = hubDescriptor->bNumberOfPorts;
    USBH_ASSERT(PortNumber <= hubDescriptor->bNumberOfPorts);

    //
    // Turn the power off
    //

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_CLEAR_PORT_FEATURE,
                             REQUEST_CLEAR_FEATURE,
                             FEATURE_PORT_POWER,
                             PortNumber,
                             NULL);


    if (NT_SUCCESS(ntStatus)) {

        //
        // mark this port as not powered
        //
        portData->PortState.PortStatus &= ~PORT_STATUS_POWER;

    }
#if DBG
      else {
        // hub failed the power off request
        TEST_TRAP();
    }
#endif

    return ntStatus;
}


NTSTATUS
USBH_SyncResumePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * We will resume the port by clearing Port_Feature_Suspend which transits the
  * state to Enable according to the spec.
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    KEVENT suspendEvent;
    LARGE_INTEGER dueTime;

    PAGED_CODE();

    USBH_KdPrint((2,"'Enter SyncResumePort pDE %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "rspE", DeviceExtensionHub, PortNumber, 0);

    USBH_KdPrint((2,"'***WAIT hub port resume mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->HubPortResetMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub port resume mutex done %x\n", DeviceExtensionHub));

    USBH_ASSERT(DeviceExtensionHub->Event == NULL);

    KeInitializeEvent(&suspendEvent, NotificationEvent, FALSE);
    InterlockedExchangePointer(&DeviceExtensionHub->Event, &suspendEvent);

    //
    // first clear the suspend for this port
    //

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_CLEAR_PORT_FEATURE,
                             REQUEST_CLEAR_FEATURE,
                             FEATURE_PORT_SUSPEND,
                             PortNumber,
                             NULL);

    //
    // now wait for the hub to signal us
    // that the port has resumed
    //

    dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

    LOGENTRY(LOG_PNP, "rspW", DeviceExtensionHub,
            PortNumber, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        status = KeWaitForSingleObject(
                           &suspendEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           &dueTime);

        if (status == STATUS_TIMEOUT) {
            // the resume timed out
            LOGENTRY(LOG_PNP, "rsTO", DeviceExtensionHub, PortNumber, 0);

            //
            // resume timed out return an error
            //
            InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
            LOGENTRY(LOG_PNP, "rspO", DeviceExtensionHub,
                PortNumber, ntStatus);

            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

    } else {

        // Clear the hub's event pointer for the next time if the call to
        // USBH_Transact was unsuccessful.

        InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
    }

    //
    // resume has completed
    //

    //
    // chap 11 USB 1.1 change wait 10 ms after resume is complete
    //
    UsbhWait(10);

    LOGENTRY(LOG_PNP, "rspX", DeviceExtensionHub,
            PortNumber, ntStatus);

    USBH_KdPrint((2,"'***RELEASE hub port resume mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->HubPortResetMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return ntStatus;
}


NTSTATUS
USBH_SyncResetPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * We will resume the port by clearing Port_Feature_Suspend which transits the
  * state to Enable according to the spec.
  *
    This is a synchronous function that resets the port on a usb hub.  This
    function assumes exclusive access to the hub, it sends the request and
    waits for the hub to indicate the request is complete via a change on the
    interrupt pipe.

    There is one problem -- the hub may report a connect or other status
    change and if it does it is possible that another interrupt transfer
    (listen) will not be posted to here the reset completeion.  The result
    is the infamous port reset timeout.  We handle this case by completing
    reset with an error so that it can be retried later.

  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    KEVENT resetEvent;
    LARGE_INTEGER dueTime;
    ULONG retry = 0;
    PORT_STATE portState;

    //

    PAGED_CODE();

    USBH_KdPrint((2,"'Enter SyncResetPort pDE %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "srpE", DeviceExtensionHub, PortNumber, 0);

    USBH_KdPrint((2,"'***WAIT hub port reset mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->HubPortResetMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub port reset mutex done %x\n", DeviceExtensionHub));

    USBH_ASSERT(DeviceExtensionHub->Event == NULL);

    // first verify that we have something to reset

    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    if (NT_SUCCESS(ntStatus)) {

        DBG_ONLY(USBH_ShowPortState(PortNumber,
                                    &portState));

        if (!(portState.PortStatus & PORT_STATUS_CONNECT)) {
            USBH_KdPrint((0,"'port %d has no device --> fail\n", PortNumber));
            LOGENTRY(LOG_PNP, "srpF", DeviceExtensionHub,
                PortNumber, 0);
            ntStatus = STATUS_UNSUCCESSFUL;
            goto USBH_SyncResetPortDone;
        }
    }

    DeviceExtensionHub->HubFlags |= HUBFLAG_PENDING_PORT_RESET;

USBH_SyncResetPort_Retry:

    KeInitializeEvent(&resetEvent, NotificationEvent, FALSE);
    InterlockedExchangePointer(&DeviceExtensionHub->Event, &resetEvent);

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_RESET,
                             PortNumber,
                             NULL);

    //
    // now wait for the hub to signal us
    // that the port has resumed
    //

    dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

    LOGENTRY(LOG_PNP, "srpW", DeviceExtensionHub,
            PortNumber, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        status = KeWaitForSingleObject(
                           &resetEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           &dueTime);

        if (status == STATUS_TIMEOUT) {
            // the reset timed out, get the current state of the hub port
            LOGENTRY(LOG_PNP, "srTO", DeviceExtensionHub, PortNumber, retry);

            status = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                            PortNumber,
                                            (PUCHAR) &portState,
                                            sizeof(portState));

            LOGENTRY(LOG_PNP, "srT1", PortNumber,
                portState.PortStatus, portState.PortChange);

            if (NT_SUCCESS(status) &&
                portState.PortStatus & PORT_STATUS_CONNECT) {

                // device is still connected, we may have a flaky connection
                // attempt a retry

                USBH_KdPrint((0,"'port %d failed to reset --> retry\n", PortNumber));
                if (retry < 3) {
                    retry++;
                    LOGENTRY(LOG_PNP, "rtry", DeviceExtensionHub, PortNumber, retry);

                    // we may have a weak connection -- we will retry in case
                    // it has stabilized
                    USBH_KdPrint((0,"'device still present -- retry reset\n"));
                    goto USBH_SyncResetPort_Retry;
                }
#if DBG
                  else {
                    UsbhWarning(NULL,
                                "Port RESET timed out --> this is bad\n",
                                FALSE);
                }
#endif
            }
                // nothing connected, device must have been removed
#if DBG
              else {

                USBH_KdPrint((0,"'-->device removed during reset\n"));
            }
#endif

            //
            // reset timed out return an error
            //
            InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
            LOGENTRY(LOG_PNP, "srpO", DeviceExtensionHub,
                PortNumber, ntStatus);

            ntStatus = STATUS_DEVICE_DATA_ERROR;
        } else {
            // check the port status, if this is a high speed reset then we
            // need to return an error if the connection dropped so that
            // the hub stops enumeration

            if (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) {
                status = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                                PortNumber,
                                                (PUCHAR) &portState,
                                                sizeof(portState));

                if (NT_SUCCESS(status) &&
                    !(portState.PortStatus & PORT_STATUS_CONNECT)) {

                    ntStatus = STATUS_DEVICE_DATA_ERROR;
                }
            }
        }

    } else {

        // Clear the hub's event pointer for the next time if the call to
        // USBH_Transact was unsuccessful.

        InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
    }

    //
    // Reset has completed.
    //

    //
    // Wait 10 ms after reset according to section 7.1.4.3
    // of the USB specification.
    //
    UsbhWait(USBH_PostResetDelay);

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_PORT_RESET) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
#endif

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_PORT_RESET;

USBH_SyncResetPortDone:

    LOGENTRY(LOG_PNP, "srpX", DeviceExtensionHub,
            PortNumber, ntStatus);

    USBH_KdPrint((2,"'***RELEASE hub port reset mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->HubPortResetMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return ntStatus;
}


//******************************************************************************
//
// USBH_SyncCompletionRoutine()
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
USBH_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

#ifndef USBHUB20
//******************************************************************************
//
// USBH_SyncResetDevice()
//
// This routine resets the device (actually it resets the port to which the
// device is attached).
//
// This routine runs at PASSIVE level.
//
//******************************************************************************

NTSTATUS
USBH_SyncResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_RESET_PORT;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBH_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(DeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    return ntStatus;
}
#endif


NTSTATUS
USBH_SyncGetDeviceConfigurationDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned)
 /* ++
  *
  * Description:
  *
  * DeviceObject hub/parent FDO or device/function PDO
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter SyncGetDeviceConfigurationDescriptor\n"));

    deviceExtensionHeader = DeviceObject->DeviceExtension;

    if (BytesReturned) {
        *BytesReturned = 0;
    }

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("SyncGetDeviceConfigurationDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     DataBuffer,
                                     NULL,
                                     DataBufferLength,
                                     NULL);

        switch (deviceExtensionHeader->ExtensionType) {
        case EXTENSION_TYPE_HUB:
        case EXTENSION_TYPE_PARENT:
            ntStatus = USBH_FdoSyncSubmitUrb(DeviceObject, urb);
            break;
        default:
            ntStatus = USBH_SyncSubmitUrb(DeviceObject, urb);
        }

        if (BytesReturned) {
            *BytesReturned =
                urb->UrbControlDescriptorRequest.TransferBufferLength;
        }

    } else {
        USBH_KdBreak(("SyncGetDeviceConfigurationDescriptor fail alloc memory\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb != NULL) {
        UsbhExFreePool(urb);
    }
    return ntStatus;
}


NTSTATUS
USBH_GetConfigurationDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR *ConfigurationDescriptor
    )
 /* ++
  *
  * Description:
  *
  * ConfigurationDescriptor - filled in with a pointer to the config
  *     descriptor or NULL if an error.
  *
  * DeviceObject hub/parent FDO or device/function PDO
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    ULONG bufferLength, bytesReturned;
    PUCHAR buffer = NULL;
    NTSTATUS ntStatus;

    PAGED_CODE();
    // some versions of the philips hub ignore
    // the low byte of the requested data length

    bufferLength = 255;

USBH_GetConfigurationDescriptor_Retry:

    buffer = UsbhExAllocatePool(NonPagedPool, bufferLength);

    if (buffer) {

        ntStatus =
        USBH_SyncGetDeviceConfigurationDescriptor(
            DeviceObject,
            buffer,
            bufferLength,
            &bytesReturned);

        //
        // if the device returns no data report an error
        //
        if (bytesReturned < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(ntStatus)) {
            *ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR) buffer;

            if ((*ConfigurationDescriptor)->wTotalLength > bufferLength) {
                bufferLength = (*ConfigurationDescriptor)->wTotalLength;
                UsbhExFreePool(buffer);
                buffer = NULL;
                *ConfigurationDescriptor = NULL;
                goto USBH_GetConfigurationDescriptor_Retry;
            }
        }
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {
        if (bytesReturned < (*ConfigurationDescriptor)->wTotalLength) {
            USBH_KdBreak(("device returned truncated config descriptor!!!\n"))
            // device returned trucated config descriptor
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }
    }

    if (!NT_SUCCESS(ntStatus)) {
        //
        // something went wrong return no descriptor data
        //

        if (buffer) {
            UsbhExFreePool(buffer);
            buffer = NULL;
        }
        *ConfigurationDescriptor = NULL;
    }

    USBH_ASSERT((PUCHAR) (*ConfigurationDescriptor) == buffer);

    return ntStatus;
}


NTSTATUS
USBH_SyncGetStringDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    IN UCHAR Index,
    IN USHORT LangId,
    IN OUT PUSB_STRING_DESCRIPTOR Buffer,
    IN ULONG BufferLength,
    IN PULONG BytesReturned,
    IN BOOLEAN ExpectHeader
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetStringDescriptor\n"));

    //
    // Allocate an Urb .
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("USBH_SyncGetStringDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     Index,
                                     LangId,
                                     Buffer,
                                     NULL,
                                     BufferLength,
                                     NULL);

        ntStatus = USBH_SyncSubmitUrb(DevicePDO, urb);

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength > BufferLength) {

            USBH_KdBreak(("Invalid length returned in USBH_SyncGetStringDescriptor, possible buffer overrun\n"));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(ntStatus) && BytesReturned) {
            *BytesReturned =
                urb->UrbControlDescriptorRequest.TransferBufferLength;
        }

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength != Buffer->bLength &&
            ExpectHeader) {

            USBH_KdBreak(("Bogus Descriptor from devce xfer buf %d descriptor %d\n",
                urb->UrbControlDescriptorRequest.TransferBufferLength,
                Buffer->bLength));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        USBH_KdPrint((2,"'GetDeviceDescriptor, string descriptor = %x\n",
                Buffer));

        UsbhExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_CheckDeviceLanguage(
    IN PDEVICE_OBJECT DevicePDO,
    IN LANGID LanguageId
    )
 /* ++
  *
  * Description:
  *
  * queries the device for a supported language id -- if the device supports
  * the language then the index for this language is returned .
  *
  * DevicePDO - device object to call with urb request
  *
  * LanguageId -
  *
  * Return:
  *
  * success if a particular language is is supported by a device
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PUSHORT supportedLangId;
    ULONG numLangIds, i;
    ULONG length;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_CheckDeviceLanguage\n"));

    usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {
        //
        // first get the array of supported languages
        //
        ntStatus = USBH_SyncGetStringDescriptor(DevicePDO,
                                                0, //index 0
                                                0, //langid 0
                                                usbString,
                                                MAXIMUM_USB_STRING_LENGTH,
                                                &length,
#ifdef HEADER
                                                TRUE);
#else
                                                FALSE);
#endif /* HEADER */

        //
        // now check for the requested language in the array of supported
        // languages
        //

        //
        // NOTE: this seems a bit much -- we should be able to just ask for
        // the string with a given language id and expect it to fail but since
        // the array of supported languages is part of the USB spec we may as
        // well check it.
        //

        if (NT_SUCCESS(ntStatus)) {

#ifdef HEADER
            if (length < 2) {
                numLangIds = 0;
            } else {
                // subtract size of header
                numLangIds = (length - 2)/2;
            }
            supportedLangId = (PUSHORT) &usbString->bString;
#else
            numLangIds = length/2;
            supportedLangId = (PUSHORT) usbString;
#endif /* HEADER */

            USBH_KdPrint((2,"'NumLangIds = %d\n", numLangIds));

#if DBG
            for (i=0; i<numLangIds; i++) {
                USBH_KdPrint((2,"'LangId = %x\n", *supportedLangId));
                supportedLangId++;
            }

#ifdef HEADER
            supportedLangId = (PUSHORT) &usbString->bString;
#else
            supportedLangId = (PUSHORT) usbString;
#endif /* HEADER */
#endif /* DBG */

            ntStatus = STATUS_NOT_SUPPORTED;
            for (i=0; i<numLangIds; i++) {
                if (*supportedLangId == LanguageId) {

                    ntStatus = STATUS_SUCCESS;
                    break;
                }
                supportedLangId++;
            }
        }

        UsbhExFreePool(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("'Language %x -- not supported by this device = %x\n",
            LanguageId));
    }
#endif

    return ntStatus;

}


NTSTATUS
USBH_GetSerialNumberString(
    IN PDEVICE_OBJECT DevicePDO,
    IN OUT PWCHAR *SerialNumberBuffer,
    IN OUT PUSHORT SerialNumberBufferLength,
    IN LANGID LanguageId,
    IN UCHAR StringIndex
    )
 /* ++
  *
  * Description:
  *
  * queries the device for the serial number string then allocates a buffer
  * just big enough to hold it.
  *
  * *SerialNumberBuffer is null if an error occurs, otherwise it is filled in
  *  with a pointer to the NULL terminated UNICODE serial number for the device
  *
  * DeviceObject - deviceobject to call with urb request
  *
  * LanguageId - 16 bit language id
  *
  * StringIndex - USB string Index to fetch
  *
  * Return:
  *
  * NTSTATUS code
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PVOID tmp;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetSerialNumberString\n"));

    *SerialNumberBuffer = NULL;
    *SerialNumberBufferLength = 0;

    usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {

        ntStatus = USBH_CheckDeviceLanguage(DevicePDO,
                                            LanguageId);

        if (NT_SUCCESS(ntStatus)) {
            //
            // this device supports our language,
            // go ahead and try to get the serial number
            //

            ntStatus = USBH_SyncGetStringDescriptor(DevicePDO,
                                                    StringIndex, //index
                                                    LanguageId, //langid
                                                    usbString,
                                                    MAXIMUM_USB_STRING_LENGTH,
                                                    NULL,
                                                    TRUE);

            if (NT_SUCCESS(ntStatus)) {

                //
                // device returned a string!!!
                //

                USBH_KdPrint((2,"'device returned serial number string = %x\n",
                    usbString));

                //
                // allocate a buffer and copy the string to it
                //
                // NOTE: must use stock alloc function because
                // PnP frees this string.

                tmp = UsbhExAllocatePool(PagedPool, usbString->bLength);
                if (tmp) {
                    USBH_KdPrint((2,"'SN = %x \n", tmp));
                    RtlZeroMemory(tmp, usbString->bLength);
                    RtlCopyMemory(tmp,
                                  &usbString->bString,
                                  usbString->bLength-2);
                    *SerialNumberBuffer = tmp;
                    *SerialNumberBufferLength = usbString->bLength;
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        UsbhExFreePool(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_SyncGetStatus(
    IN PDEVICE_OBJECT HubFDO,
    IN OUT PUSHORT StatusBits,
    IN USHORT function,
    IN USHORT Index
    )
 /* ++
  *
  * Description:
  *
  * HubFDO - device object for hub (FDO)
  * function - (targets a device, interface or endpoint)
  * Index - wIndex value
  *
  *
  * Return:
  *
  *     ntStatus
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    USHORT tmpStatusBits;

    PAGED_CODE();

    USBH_KdPrint((2,"'enter USBH_SyncGetStatus\n"));

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool,
                 sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetStatus fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb) {

        UsbBuildGetStatusRequest(urb,
                                 function,
                                 Index,
                                 &tmpStatusBits,
                                 NULL,
                                 NULL);

        ntStatus = USBH_FdoSyncSubmitUrb(HubFDO, urb);

        *StatusBits = tmpStatusBits;

        UsbhExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
USBH_GetDeviceDescriptor(
    IN PDEVICE_OBJECT HubFDO,
    OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor
    )
 /* ++
  *
  * Description:
  *
  * Get our configuration info.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetDeviceDescriptor\n"));

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetDeviceDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     DeviceDescriptor,
                                     NULL,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     NULL);

        ntStatus = USBH_FdoSyncSubmitUrb(HubFDO, urb);

        UsbhExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
USBH_GetDeviceQualifierDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    OUT PUSB_DEVICE_QUALIFIER_DESCRIPTOR DeviceQualifierDescriptor
    )
 /* ++
  *
  * Description:
  *
  * Get the USB_DEVICE_QUALIFIER_DESCRIPTOR for the device.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetDeviceQualifierDescriptor\n"));

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetDeviceQualifierDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     DeviceQualifierDescriptor,
                                     NULL,
                                     sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR),
                                     NULL);

        ntStatus = USBH_SyncSubmitUrb(DevicePDO, urb);

        UsbhExFreePool(urb);
    }

    return ntStatus;
}


VOID
USBH_SyncRefreshPortAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  * -- */
{
    PUSB_EXTHUB_INFORMATION_0 extHubInfo;
    PPORT_DATA p;
    ULONG numberOfPorts, i;
    NTSTATUS localStatus;

    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

    // get extended hub info if any
    extHubInfo = UsbhExAllocatePool(NonPagedPool, sizeof(*extHubInfo));
    if (extHubInfo != NULL) {
        NTSTATUS localStatus;
        // get extended hub info
        localStatus = USBHUB_GetExtendedHubInfo(DeviceExtensionHub, extHubInfo);
        if (!NT_SUCCESS(localStatus)) {
            UsbhExFreePool(extHubInfo);
            extHubInfo = NULL;
        }
    }

    p = DeviceExtensionHub->PortData;
    for (i=0; extHubInfo && i<numberOfPorts; i++, p++) {
        p->PortAttributes = extHubInfo->Port[i].PortAttributes;
    }

    if (extHubInfo) {
        UsbhExFreePool(extHubInfo);
    }
}


NTSTATUS
USBH_SyncGetHubDescriptor(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  * Get hub descriptor. If successful, we have allocated memory for the hub
  * descriptor and have a the pointer to the memory recorded in the device
  * extension. The memory also has the info filled. An array of port_data is
  * also allocated and a pointer to the array recorded in the device
  * extension.
  *
  * Arguments:
  *
  * pDeviceObject - the hub device
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus;
    ULONG numBytes;
    PUSB_HUB_DESCRIPTOR hubDescriptor = NULL;
    PPORT_DATA portData;
    ULONG numberOfPorts;
    PDEVICE_OBJECT deviceObject;
    USHORT descriptorTypeAndIndex = 0x0000;
    PUSB_EXTHUB_INFORMATION_0 extHubInfo;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetHubDescriptor\n"));

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    // get extended hub info if any
    extHubInfo = UsbhExAllocatePool(NonPagedPool, sizeof(*extHubInfo));
    if (extHubInfo != NULL) {
        NTSTATUS localStatus;
        // get extended hub info
        localStatus = USBHUB_GetExtendedHubInfo(DeviceExtensionHub, extHubInfo);
        if (!NT_SUCCESS(localStatus)) {
            UsbhExFreePool(extHubInfo);
            extHubInfo = NULL;
        }
    }

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    numBytes = sizeof(USB_HUB_DESCRIPTOR);

USBH_SyncGetHubDescriptor_Retry2:

    hubDescriptor = UsbhExAllocatePool(NonPagedPool, numBytes);

    if (hubDescriptor) {

USBH_SyncGetHubDescriptor_Retry:

        ntStatus = USBH_Transact(DeviceExtensionHub,
                                 (PUCHAR) hubDescriptor,
                                 numBytes,
                                 FALSE, // input
                                 URB_FUNCTION_CLASS_DEVICE,
                                 REQUEST_TYPE_GET_HUB_DESCRIPTOR,
                                 REQUEST_GET_DESCRIPTOR,
                                 descriptorTypeAndIndex,
                                 0,
                                 NULL);

        if (!NT_SUCCESS(ntStatus) && descriptorTypeAndIndex == 0) {
            descriptorTypeAndIndex = 0x2900;
            goto USBH_SyncGetHubDescriptor_Retry;
        } else {

            if (hubDescriptor->bDescriptorLength > numBytes) {
                numBytes = hubDescriptor->bDescriptorLength;
                UsbhExFreePool(hubDescriptor);
                goto USBH_SyncGetHubDescriptor_Retry2;
            }

        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(ntStatus)) {
        PPORT_DATA p;
        ULONG i;

        //
        // So, we have obtained hub descriptor. Now prepare port data
        //

        numberOfPorts = (ULONG) hubDescriptor->bNumberOfPorts;

        USBH_KdPrint((2,"'GetHubDescriptor %x Hub has %d ports\n", hubDescriptor, numberOfPorts));

        if (DeviceExtensionHub->PortData) {
            // we already have port data, re-init the flags
            p = portData = DeviceExtensionHub->PortData;
            for (i=0; i<numberOfPorts; i++, p++) {
                p->PortState.PortStatus = 0;
                p->PortState.PortChange = 0;
                if (extHubInfo != NULL) {
                    p->PortAttributes = extHubInfo->Port[i].PortAttributes;
                } else {
                    p->PortAttributes = 0;
                }

                // In the case of hub start after stop, we want ConnectionStatus
                // to accurately reflect the status of the port, depending on
                // if there is a device connected or not.  Note that QBR
                // used to do this but this broke the UI in the case of
                // overcurrent, bandwidth error, etc., so now we do this here.

                if (p->DeviceObject) {
                    p->ConnectionStatus = DeviceConnected;
                } else {
                    p->ConnectionStatus = NoDeviceConnected;
                }
            }
        } else {

            // Weird.  Test found a case where if they had DriverVerifier
            // fault injection turned on we bugcheck in the following call.
            // We bugchecked because we were asking for zero bytes, so it
            // is somehow possible to end up here with ntStatus == STATUS_SUCCESS
            // and numberOfPorts == 0.  So, we have to guard for that here.

            if (numberOfPorts) {
                portData = UsbhExAllocatePool(NonPagedPool,
                                sizeof(PORT_DATA) * numberOfPorts);
            } else {
                portData = NULL;
            }

            if (portData) {
                RtlZeroMemory(portData, sizeof(PORT_DATA) * numberOfPorts);
                p = portData;
                for (i=0; i<numberOfPorts; i++, p++) {
                    p->ConnectionStatus = NoDeviceConnected;

                    if (extHubInfo != NULL) {
                        p->PortAttributes = extHubInfo->Port[i].PortAttributes;
                    }
                }
            }
        }

        if (NULL == portData) {
            USBH_KdBreak(("GetHubDescriptor alloc port_data failed\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    if (NT_SUCCESS(ntStatus)) {
        //
        // Remember our HubDescriptor and PortData
        //
        DeviceExtensionHub->HubDescriptor = hubDescriptor;
        DeviceExtensionHub->PortData = portData;
    } else {
        if (hubDescriptor) {
            UsbhExFreePool(hubDescriptor);
        }
    }

    if (extHubInfo != NULL) {
        UsbhExFreePool(extHubInfo);
    }

    USBH_KdPrint((2,"'Exit GetHubDescriptor %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncFeatureRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT FeatureSelector,
    IN USHORT Index,
    IN USHORT Target,
    IN BOOLEAN ClearFeature
    )
 /* ++
  *
  * Description:
  *
  * DeviceObject - may be either a device PDO or the TopOfDeviceStack for the
  *         hub
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_SyncFeatureRequest\n"));

    //
    // Allocate an Urb .
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("USBH_SyncFeatureRequest fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (urb) {
        USHORT op;
        //
        // got the urb no try to get descriptor data
        //

        if (ClearFeature) {
            switch(Target) {
            case TO_USB_DEVICE:
                op = URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE;
                break;

            case TO_USB_INTERFACE:
                op = URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE;
                break;

            case TO_USB_ENDPOINT:
                op = URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;
                break;
            }
        } else {
            switch(Target) {
            case TO_USB_DEVICE:
                op = URB_FUNCTION_SET_FEATURE_TO_DEVICE;
                break;

            case TO_USB_INTERFACE:
                op = URB_FUNCTION_SET_FEATURE_TO_INTERFACE;
                break;

            case TO_USB_ENDPOINT:
                op = URB_FUNCTION_SET_FEATURE_TO_ENDPOINT;
                break;
            }
        }

        UsbBuildFeatureRequest(urb,
                               op,
                               FeatureSelector,
                               Index,
                               NULL);

        ntStatus = USBH_SyncSubmitUrb(DeviceObject, urb);

        UsbhExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\usbhub.c ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:

    USBHUB.C

Abstract:

    This module contains code for the hub to function as a
    device on the USB. All USBH_Fdo functions live here.

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    02-02-96 : created
    10-31-06 : jd, use worker thread to process change indications

--*/

#include <wdm.h>
#include <windef.h>
#include <ks.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wdmguid.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"
#include <stdio.h>


#define ESD_RECOVERY_TIMEOUT    5000    // Timeout in ms (5 sec)
#define ESD_RESET_TIMEOUT       5000


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_ChangeIndicationWorker)
#pragma alloc_text(PAGE, USBH_ProcessHubStateChange)
// #pragma alloc_text(PAGE, USBH_ProcessPortStateChange)
#pragma alloc_text(PAGE, USBH_GetNameFromPdo)
//#pragma alloc_text(PAGE, USBH_MakeName)
//#pragma alloc_text(PAGE, USBH_GenerateDeviceName)
#pragma alloc_text(PAGE, USBH_FdoStartDevice)
#pragma alloc_text(PAGE, USBH_QueryCapabilities)
#pragma alloc_text(PAGE, USBH_FdoHubStartDevice)
// #pragma alloc_text(PAGE, UsbhFdoCleanup)
#pragma alloc_text(PAGE, USBH_FdoStopDevice)
#pragma alloc_text(PAGE, USBH_FdoRemoveDevice)
#pragma alloc_text(PAGE, USBH_FdoQueryBusRelations)
#pragma alloc_text(PAGE, USBH_HubIsBusPowered)
#pragma alloc_text(PAGE, USBH_HubESDRecoveryWorker)
#pragma alloc_text(PAGE, USBH_RegQueryDeviceIgnoreHWSerNumFlag)
#pragma alloc_text(PAGE, USBH_RegQueryGenericUSBDeviceString)
#pragma alloc_text(PAGE, USBH_DeviceIs2xDualMode)

// Win98 breaks if we have an INIT segment
//#pragma alloc_text(INIT, DriverEntry )
#endif
#endif

#ifdef WMI_SUPPORT

#define NUM_WMI_SUPPORTED_GUIDS     3

WMIGUIDREGINFO USB_WmiGuidList[NUM_WMI_SUPPORTED_GUIDS];

extern WMIGUIDREGINFO USB_PortWmiGuidList[];

#endif /* WMI_SUPPORT */


PWCHAR GenericUSBDeviceString = NULL;


NTSTATUS
USBH_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

	This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PWCHAR tmpStr;

    USBH_KdPrint((2,"'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
        *(PVOID*)EntryContext = *(PVOID*)ValueData;
        break;
    case REG_BINARY:
        RtlCopyMemory(EntryContext, ValueData, ValueLength);
        break;
    case REG_SZ:
        if (ValueLength) {
            tmpStr = UsbhExAllocatePool(PagedPool, ValueLength);
            if (tmpStr) {
                RtlZeroMemory(tmpStr, ValueLength);
                RtlCopyMemory(tmpStr, ValueData, ValueLength);
                *(PWCHAR *)EntryContext = tmpStr;
            } else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}


NTSTATUS
USBH_RegQueryUSBGlobalSelectiveSuspend(
    IN OUT PBOOLEAN DisableSelectiveSuspend
    )
/*++

Routine Description:

    See if selective suspend is glabllay disabled

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb  = L"usb";
    ULONG disableSS;
#define G_DISABLE_SS_KEY                L"DisableSelectiveSuspend"


    PAGED_CODE();

    disableSS = 0;
    *DisableSelectiveSuspend = FALSE;      // Default is enabled.

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = G_DISABLE_SS_KEY;
    QueryTable[0].EntryContext = &disableSS;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &disableSS;
    QueryTable[0].DefaultLength = sizeof(disableSS);

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    *DisableSelectiveSuspend = disableSS ? TRUE : FALSE;

    USBH_KdPrint((1,"'USB\\DisableSelectiveSuspend = 0x%x\n",
        *DisableSelectiveSuspend));

    return ntStatus;
}


NTSTATUS
USBH_RegQueryDeviceIgnoreHWSerNumFlag(
    IN USHORT idVendor,
    IN USHORT idProduct,
    IN OUT PBOOLEAN IgnoreHWSerNumFlag
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usbstr = L"usbflags";
    WCHAR buffer[sizeof(WCHAR) * 128];
    WCHAR tmplate[] = L"IgnoreHWSerNum%04x%04x";

    PAGED_CODE();

    *IgnoreHWSerNumFlag = FALSE;    // Default is don't ignore.

    swprintf(buffer, tmplate, idVendor, idProduct);

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = buffer;
    QueryTable[0].EntryContext = IgnoreHWSerNumFlag;
    QueryTable[0].DefaultType = 0;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                usbstr,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    return ntStatus;
}


NTSTATUS
USBH_RegQueryGenericUSBDeviceString(
    IN OUT PWCHAR *GenericUSBDeviceString
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usbstr = L"usbflags";
    PWCHAR valuename = L"GenericUSBDeviceString";

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = valuename;
    QueryTable[0].EntryContext = GenericUSBDeviceString;
    QueryTable[0].DefaultType = 0;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                usbstr,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    return ntStatus;
}


//
// Make the DriverEntry discardable
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING UniRegistryPath)
 /* ++ Routine Description:
  *
  * Installable driver initialization entry point. We will remember the pointer
  * to our DeviceObject.
  *
  * Arguments:
  *
  * pDriverObject - pointer to driver object pustRegisterPath - pointer to a
  * unicode string representing the path to driver specific key in the
  * registry.
  *
  * Return Values:
  *
  * STATUS_SUCCESS - if successful
  * STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS status, ntStatus = STATUS_SUCCESS;
    PUNICODE_STRING registryPath = &UsbhRegistryPath;

    USBH_KdPrint((2,"'enter DriverEntry\n"));

    USBH_LogInit();

    UsbhDriverObject = DriverObject;  // remember ourselves
    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] =
        DriverObject->MajorFunction[IRP_MJ_CLOSE] =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = USBH_HubDispatch;

    DriverObject->DriverUnload = USBH_DriverUnload;
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE) USBH_AddDevice;

    DriverObject->MajorFunction[IRP_MJ_PNP] = USBH_HubDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = USBH_HubDispatch;


     //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length = UniRegistryPath->Length;
    registryPath->Buffer = ExAllocatePoolWithTag(
                              PagedPool,
                              registryPath->MaximumLength,
                              USBHUB_HEAP_TAG);

    if (!registryPath->Buffer) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        USBH_LogFree();
        goto DriverEntry_Exit;
    } else {

        RtlZeroMemory (registryPath->Buffer, registryPath->MaximumLength);

        RtlMoveMemory (registryPath->Buffer,
                       UniRegistryPath->Buffer,
                       UniRegistryPath->Length);

#ifdef WMI_SUPPORT

        // These are the GUIDs that we support for the HUB.

        USB_WmiGuidList[0].Guid = (LPCGUID)&GUID_USB_WMI_STD_DATA;
        USB_WmiGuidList[0].InstanceCount = 1;
        USB_WmiGuidList[0].Flags = 0;

        USB_WmiGuidList[1].Guid = (LPCGUID)&GUID_USB_WMI_STD_NOTIFICATION;
        USB_WmiGuidList[1].InstanceCount = 1;
        USB_WmiGuidList[1].Flags = 0;

        // NB: GUID_POWER_DEVICE_ENABLE MUST be last because we only support
        // it for the Root Hub, and we omit the last one in the list if not
        // the Root Hub.

        USB_WmiGuidList[2].Guid = (LPCGUID)&GUID_POWER_DEVICE_ENABLE;
        USB_WmiGuidList[2].InstanceCount = 1;
        USB_WmiGuidList[2].Flags = 0;

        // These are the GUIDs that we support for the PORT PDOs.

        USB_PortWmiGuidList[0].Guid = (LPCGUID)&MSDeviceUI_FirmwareRevision_GUID;
        USB_PortWmiGuidList[0].InstanceCount = 1;
        USB_PortWmiGuidList[0].Flags = 0;

#endif /* WMI_SUPPORT */
    }

    USBH_RegQueryGenericUSBDeviceString(&GenericUSBDeviceString);

DriverEntry_Exit:

    USBH_KdPrint((2,"' exit DriverEntry %x\n", ntStatus));
    return ntStatus;
}


#if DBG
VOID
USBH_ShowPortState(
    IN USHORT PortNumber,
    IN PPORT_STATE PortState)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * None
  *
  * -- */
{
    USBH_KdPrint((2,"' Port state for port %x status = %x change = %x\n", PortNumber,
        PortState->PortStatus,  PortState->PortChange));

    if (PortState->PortStatus & PORT_STATUS_CONNECT) {
        USBH_KdPrint((2,"'PORT_STATUS_CONNECT\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_ENABLE) {
        USBH_KdPrint((2,"'PORT_STATUS_ENABLE\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_SUSPEND) {
        USBH_KdPrint((2,"'PORT_STATUS_SUSPEND\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_OVER_CURRENT) {
        USBH_KdPrint((2,"'PORT_STATUS_OVER_CURRENT\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_RESET) {
        USBH_KdPrint((2,"'PORT_STATUS_RESET\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_POWER) {
        USBH_KdPrint((2,"'PORT_STATUS_POWER\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_LOW_SPEED) {
        USBH_KdPrint((2,"'PORT_STATUS_LOW_SPEED\n"));
    }


    if (PortState->PortChange & PORT_STATUS_CONNECT) {
        USBH_KdPrint((2,"'PORT_CHANGE_CONNECT\n"));
    }

    if (PortState->PortChange & PORT_STATUS_ENABLE) {
        USBH_KdPrint((2,"'PORT_CHANGE_ENABLE\n"));
    }

    if (PortState->PortChange & PORT_STATUS_SUSPEND) {
        USBH_KdPrint((2,"'PORT_CHANGE_SUSPEND\n"));
    }

    if (PortState->PortChange & PORT_STATUS_OVER_CURRENT) {
        USBH_KdPrint((2,"'PORT_CHANGE_OVER_CURRENT\n"));
    }

    if (PortState->PortChange & PORT_STATUS_RESET) {
        USBH_KdPrint((2,"'PORT_CHANGE_RESET\n"));
    }

    if (PortState->PortChange & PORT_STATUS_POWER) {
        USBH_KdPrint((2,"'PORT_CHANGE_POWER\n"));
    }

    if (PortState->PortChange & PORT_STATUS_LOW_SPEED) {
        USBH_KdPrint((2,"'PORT_CHANGE_LOW_SPEED\n"));
    }

    return;
}
#endif

VOID
USBH_CompleteIrp(
     IN PIRP Irp,
     IN NTSTATUS NtStatus)
 /* ++
  *
  * Description:
  *
  * This function complete the specified Irp with no priority boost. It also
  * sets up the IoStatusBlock.
  *
  * Arguments:
  *
  * Irp - the Irp to be completed by us NtStatus - the status code we want to
  * return
  *
  * Return:
  *
  * None
  *
  * -- */
{
    Irp->IoStatus.Status = NtStatus;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;
}


NTSTATUS
USBH_PassIrp(
    IN PIRP Irp,
    IN PDEVICE_OBJECT NextDeviceObject)
 /* ++
  *
  * Description:
  *
  * This function pass the Irp to lower level driver.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;

    USBH_KdPrint((2,"'PassIrp\n"));

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(NextDeviceObject, Irp);

    USBH_KdPrint((2,"'Exit PassIrp\n"));

    return ntStatus;
}


NTSTATUS
USBH_FdoDispatch(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp)
 /* ++
  *
  * Description:
  *
  * All external Irps on FDO come here.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the extension of the Fdo pIrp - the request
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;
    BOOLEAN bDoCheckHubIdle = FALSE;

    USBH_KdPrint((2,"'FdoDispatch DeviceExtension %x Irp %x\n", DeviceExtensionHub, Irp));
    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    LOGENTRY(LOG_PNP, "hIRP", DeviceExtensionHub,
        ioStackLocation->MajorFunction, ioStackLocation->MinorFunction);
    //
    // the called functions will complete the irp if necessary
    //

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:

        USBH_KdPrint((2,"'IRP_MJ_CREATE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_CLOSE:

        USBH_KdPrint((2,"'IRP_MJ_CLOSE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_DEVICE_CONTROL:

        {
        ULONG ioControlCode;

        USBH_KdPrint((2,"'Hub FDO IRP_MJ_DEVICE_CONTROL\n"));

        // If this hub is currently Selective Suspended, then we need to
        // power up the hub first before sending any IOCTL requests along to it.
        // Make sure hub has been started, though.

        if (DeviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
            (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

            bDoCheckHubIdle = TRUE;
            USBH_HubSetD0(DeviceExtensionHub);
        }

        ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
        ntStatus = STATUS_DEVICE_BUSY;

        switch (ioControlCode) {
        case IOCTL_USB_GET_NODE_INFORMATION:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeInformation(DeviceExtensionHub,
                                                        Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionDriverKeyName(DeviceExtensionHub,
                                                        Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_INFORMATION:
            // note, when rev all internal apps we can remove this
            // code
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionInformation(DeviceExtensionHub,
                                                                  Irp,
                                                                  FALSE);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;
        // EX api returns speed
        case IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX:
            // note, when rev all internal apps we can remove this
            // code
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionInformation(DeviceExtensionHub,
                                                                  Irp,
                                                                  TRUE);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES:
            // note, when rev all internal apps we can remove this
            // code
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionAttributes(DeviceExtensionHub,
                                                                   Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_NAME:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeName(DeviceExtensionHub,
                                                 Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetDescriptorForPDO(DeviceExtensionHub,
                                                         Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_HUB_CAPABILITIES:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetHubCapabilities(DeviceExtensionHub,
                                                        Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_KS_PROPERTY:
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_USB_HUB_CYCLE_PORT:

            ntStatus = USBH_IoctlCycleHubPort(DeviceExtensionHub,
                                              Irp);
            break;

        default:

            ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->RootHubPdo);

        }

        if (bDoCheckHubIdle) {
            USBH_CheckHubIdle(DeviceExtensionHub);
        }
        }
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        USBH_KdPrint((2,"'InternlDeviceControl IOCTL unknown pass on\n"));
        ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->TopOfStackDeviceObject);

        break;

    case IRP_MJ_PNP:

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));
        ntStatus = USBH_FdoPnP(DeviceExtensionHub, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));
        ntStatus = USBH_FdoPower(DeviceExtensionHub, Irp, ioStackLocation->MinorFunction);
        break;

#ifdef WMI_SUPPORT
    case IRP_MJ_SYSTEM_CONTROL:
        USBH_KdPrint((2,"'IRP_MJ_SYSTEM_CONTROL\n"));
        ntStatus =
            USBH_SystemControl ((PDEVICE_EXTENSION_FDO) DeviceExtensionHub, Irp);
        break;
#endif

    default:
        //
        // Unknown Irp -- pass on
        //
        USBH_KdBreak(("Unknown Irp for fdo %x Irp_Mj %x\n",
                  deviceObject, ioStackLocation->MajorFunction));
        ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->TopOfStackDeviceObject);
        break;
    }

//USBH_FdoDispatch_Done:

    USBH_KdPrint((2,"' exit USBH_FdoDispatch Object %x Status %x\n",
                  deviceObject, ntStatus));

    //
    // always return a status code
    //

    return ntStatus;
}


NTSTATUS
USBH_HubDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
 /* ++
  *
  * Routine Description:
  *
  *     This is the dispatch routine for all Irps passed to the hub driver.
  *     It is here that we determine if the call was passed throug the FDO
  *     for the hub itself or a PDO owned by the hub.
  *
  * Arguments:
  *
  * Return Value:
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;

    //
    // Get the pointer to the device extension.
    //

    //
    // examine the extension
    //

    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    switch(deviceExtensionHeader->ExtensionType) {
    case EXTENSION_TYPE_HUB:
        ntStatus = USBH_FdoDispatch((PDEVICE_EXTENSION_HUB) deviceExtensionHeader, Irp);
        break;

    case EXTENSION_TYPE_PORT:
        ntStatus = USBH_PdoDispatch((PDEVICE_EXTENSION_PORT) deviceExtensionHeader, Irp);
        break;

    case EXTENSION_TYPE_PARENT:
        ntStatus = USBH_ParentDispatch((PDEVICE_EXTENSION_PARENT) deviceExtensionHeader, Irp);
        break;

    case EXTENSION_TYPE_FUNCTION:
        ntStatus = USBH_FunctionPdoDispatch((PDEVICE_EXTENSION_FUNCTION) deviceExtensionHeader, Irp);
        break;

    default:
        USBH_KdBreak(("bad extension type\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}


VOID
USBH_DriverUnload(
    IN PDRIVER_OBJECT DriverObject)
 /* ++
  *
  * Description:
  *
  * This function will clean up all resources we allocated.
  *
  * Arguments:
  *
  * pDriverObject - Ourselves
  *
  * Return:
  *
  * None
  *
  * -- */
{
    PUNICODE_STRING registryPath = &UsbhRegistryPath;

    USBH_KdPrint((1, "'USBHUB.SYS unload\n"));

    USBH_LogFree();

    if (registryPath->Buffer) {
        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    if (GenericUSBDeviceString) {
        UsbhExFreePool(GenericUSBDeviceString);
        GenericUSBDeviceString = NULL;
    }

    // assert here that all PDOs for this hub have been removed

    return;
}


NTSTATUS
USBH_AbortInterruptPipe(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *     Abort our pending transfer on the interrupt
  *     pipe.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PURB urb;

    USBH_KdPrint((2,"'Enter AbortInterruptPipe pExt=%x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "ABRT", DeviceExtensionHub, 0,  0);

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {
        urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = DeviceExtensionHub->PipeInformation.PipeHandle;

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject, urb);

        //
        // wait on the abort event
        //

        //
        // timeout here?
        LOGENTRY(LOG_PNP, "hWAT", DeviceExtensionHub,
                        &DeviceExtensionHub->AbortEvent, ntStatus);

        if (NT_SUCCESS(ntStatus)) {
            status = KeWaitForSingleObject(
                           &DeviceExtensionHub->AbortEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           NULL);
        }

        UsbhExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBH_KdPrint((2,"'Exit AbortInterruptPipe %x\n", ntStatus));

    return ntStatus;
}


#if 0
NTSTATUS
USBH_GetHubConfigurationDescriptor(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  * Get our configuration info.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG numBytes;              // transfer length
    PUCHAR buffer;                // a pointer to the transfer buffer
    PDEVICE_OBJECT deviceObject;

    USBH_KdPrint((2,"'enter GetConfigurationDescriptor\n"));

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    USBH_ASSERT(DeviceExtensionHub->ConfigurationDescriptor == NULL);

    //
    // Most likely a Hub has 1 configuration, 1 interface and 1 endpoint
    // possibly follwed by the hub descriptor, try to get it on the first
    // pass
    //
    numBytes = sizeof(USB_CONFIGURATION_DESCRIPTOR) +
        sizeof(USB_INTERFACE_DESCRIPTOR) +
        sizeof(USB_ENDPOINT_DESCRIPTOR) +
        sizeof(USB_HUB_DESCRIPTOR);

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetConfigurationDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    if (NT_SUCCESS(ntStatus)) {

        //
        // got the urb no try to get descriptor data
        //

USBH_GetHubConfigurationDescriptor_Retry:

        buffer = (PUCHAR) UsbhExAllocatePool(NonPagedPool, numBytes);

        if (buffer != NULL) {
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         buffer,
                                         NULL,
                                         numBytes,
                                         NULL);

            ntStatus = USBH_FdoSyncSubmitUrb(deviceObject, urb);
        } else {
            USBH_KdBreak(("GetConfigurationDescriptor fail alloc memory\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(ntStatus)) {

            UsbhExFreePool(buffer);
            USBH_KdPrint((2,"'GetConfigurationDescriptor fail calling Usbd code %x\n",
                ntStatus));

        } else {

            if (((PUSB_CONFIGURATION_DESCRIPTOR) buffer)->wTotalLength > numBytes) {
                //
                // should only hit this if the hub has > 7 ports
                //
                UsbhExFreePool(buffer);
                USBH_KdBreak(("GetConfigurationDescriptor 2nd try\n"));
                goto USBH_GetHubConfigurationDescriptor_Retry;

            } else {
                //
                // success
                //
                DeviceExtensionHub->ConfigurationDescriptor =
                    (PUSB_CONFIGURATION_DESCRIPTOR) buffer;

            }

        }
    }
    //
    // Free the Urb and first buffer for descriptors
    //
    if (urb != NULL) {
        UsbhExFreePool(urb);
    }
    return ntStatus;
}
#endif


BOOLEAN
IsBitSet(
    PVOID Bitmap,
    ULONG PortNumber)
 /* ++
  *
  * Description:
  *
  * Check if a bit is set given a string of bytes.
  *
  * Arguments:
  *
  * pul - the string of bitmap ulPortNumber - the bit location to check for the
  * port
  *
  * Return:
  *
  * TRUE - if the corresponding bit is set. FALSE - otherwise
  *
  * -- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PUCHAR l = (PUCHAR) Bitmap;

    dwordOffset = PortNumber / 8;
    bitOffset = PortNumber % 8;

    return ((l[dwordOffset] & (1 << bitOffset)) ? TRUE : FALSE);
}


NTSTATUS
USBH_OpenConfiguration(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *     Configure the USB hub device.
  *
  * Argument:
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    USBD_INTERFACE_LIST_ENTRY interfaceList[2];

    USBH_KdPrint((2,"'Enter OpenConfiguration\n"));

    //
    // I do not believe it is legal to have a hub with any other
    // interfaces.
    //
    // This code will locate the 'HUB' interface and configure
    // the device as if this were the only interface.
    //

    //
    // find the hub interface
    //

    if ((DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) &&
        !IS_ROOT_HUB(DeviceExtensionHub)) {
        // 2.0 hubs may have multiple interfaces
        // one for per port TTs
        // one for a global TT
        // these are diferentiated by the bportocol field we attempt
        // to select the multi-TT version by default
        //

        USBH_KdPrint((1,"'Configure 2.0 hub %x\n",
            DeviceExtensionHub->ConfigurationDescriptor));

        // find a Multi TT interface
        interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                    (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    USB_DEVICE_CLASS_HUB, // hub class
                    -1, // subclass, don't care
                    2); // multi TT protocol

        if (interfaceDescriptor != NULL) {
            USBH_KdPrint((1,"'USB 2.0 hub - Multi TT\n"));

            DeviceExtensionHub->HubFlags |= HUBFLAG_USB20_MULTI_TT;

        } else {
            // locate the single TT protocol, may be zero or 1
            interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                    (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    USB_DEVICE_CLASS_HUB, // hub class
                    -1, // subclass, don't care
                    1); // single TT protocol

            if (interfaceDescriptor == NULL) {
                // locate the single TT protocol
                interfaceDescriptor =
                    USBD_ParseConfigurationDescriptorEx(
                        (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                        (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                        -1, //interface, don't care
                        -1, //alt setting, don't care
                        USB_DEVICE_CLASS_HUB, // hub class
                        -1, // subclass, don't care
                        0); // single TT protocol
            }

            if (interfaceDescriptor != NULL) {
                USBH_KdPrint((1,"'USB 2.0 hub - Single TT\n"));
            }
        }
    } else {
        // just do what we always did to be safe
        interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                    (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    USB_DEVICE_CLASS_HUB, // hub class
                    -1, // subclass, don't care
                    -1); // protocol, don't care
    }

    if (interfaceDescriptor == NULL ||
        interfaceDescriptor->bInterfaceClass != USB_DEVICE_CLASS_HUB) {
        USBH_KdBreak(("OpenConfiguration interface not found\n"));
        return STATUS_UNSUCCESSFUL;
    }

    interfaceList[0].InterfaceDescriptor =
        interfaceDescriptor;

    // terminate the list
    interfaceList[1].InterfaceDescriptor =
        NULL;

    urb = USBD_CreateConfigurationRequestEx(DeviceExtensionHub->ConfigurationDescriptor,
                                            &interfaceList[0]);

    if (NULL == urb) {
        USBH_KdBreak(("OpenConfiguration aloc Urb failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject, urb);

    if (NT_SUCCESS(ntStatus)) {
        PUSBD_INTERFACE_INFORMATION interface;

        //
        // interface we selected
        //

        interface =  interfaceList[0].Interface;

        //
        // Save the pipe handle for the Interrupt pipe
        //
        DeviceExtensionHub->PipeInformation =
            interface->Pipes[0];
        DeviceExtensionHub->Configuration =
            urb->UrbSelectConfiguration.ConfigurationHandle;
    }

    ExFreePool(urb);

    USBH_KdPrint((2,"'Exit OpenConfiguration PipeInfo %x\n", DeviceExtensionHub->PipeInformation));

    return ntStatus;
}


NTSTATUS
USBH_CloseConfiguration(
    IN PDEVICE_EXTENSION_FDO DeviceExtensionFdo
    )
 /* ++
  *
  * Description:
  *
  * Close our confiuration on USB to prepare for removal of ourselves. Before
  * this is called, the InterruptTransfer should have been removed by
  * USBH_AbortInterruptPipe.
  *
  * Argument:
  *
  * DeviceExtensionHub - pointer to the FDO extension
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb;

    USBH_KdPrint((2,"'Enter CloseConfiguration\n"));
    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_SELECT_CONFIGURATION));
    if (NULL == urb) {
        USBH_KdBreak(("OpenConfiguration aloc Urb failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    urb->UrbHeader.Length = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb->UrbHeader.Function = URB_FUNCTION_SELECT_CONFIGURATION;

    urb->UrbSelectConfiguration.ConfigurationDescriptor = NULL;

    ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionFdo->FunctionalDeviceObject, urb);

    UsbhExFreePool(urb);

    USBH_KdPrint((2,"'Exit CloseConfiguration %x\n", ntStatus));
    return ntStatus;
}


NTSTATUS
USBH_SubmitInterruptTransfer(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * To submit a listen down for Status Change interrupt transfer. When the
  * transfer is completed, the USBH_ChangeIndication will be called.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the hub we are listening
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    PIRP irp;
    PURB urb;
    CHAR stackSize;

    USBH_KdPrint((2,"'Enter Submit IntTrans\n"));

    irp = DeviceExtensionHub->Irp;

    USBH_ASSERT(NULL != irp);

    // Synchronize with FdoPower.  Don't let the IRP slip through if FdoPower
    // has already set the HUBFLAG_DEVICE_LOW_POWER flag.
    //
    // It is ok to allow this through in the REMOVE case
    // (i.e. HUBFLAG_DEVICE_STOPPING is set) because the IRP will need to
    // be submitted so that it can be aborted by USBH_FdoCleanup.

    if (DeviceExtensionHub->HubFlags & HUBFLAG_DEVICE_LOW_POWER) {

        irp = NULL;
    }

    if (!irp) {
        ntStatus = STATUS_INVALID_DEVICE_STATE;
        LOGENTRY(LOG_PNP, "Int!", DeviceExtensionHub,
            DeviceExtensionHub->HubFlags, 0);
        goto SubmitIntTrans_Exit;
    }

    urb = &DeviceExtensionHub->Urb;

    USBH_ASSERT(NULL != urb);
    USBH_ASSERT(sizeof(*urb) >= sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    //
    // Fill in Urb header
    //

    LOGENTRY(LOG_PNP, "Int>", DeviceExtensionHub, urb, irp);

    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb->UrbHeader.Function =
        URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb->UrbHeader.UsbdDeviceHandle = NULL;

    //
    // Fill in Urb body
    //
    urb->UrbBulkOrInterruptTransfer.PipeHandle = DeviceExtensionHub->PipeInformation.PipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
        DeviceExtensionHub->TransferBufferLength;
    urb->UrbBulkOrInterruptTransfer.TransferBuffer = DeviceExtensionHub->TransferBuffer;
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    stackSize = DeviceExtensionHub->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(irp,    // Irp
                           USBH_ChangeIndication,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    //
    // Call the USB stack
    //

    //
    // reset the abort event to not-signaled
    //

    KeResetEvent(&DeviceExtensionHub->AbortEvent);

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, irp);

    //
    // completion routine will handle errors.
    //

SubmitIntTrans_Exit:

    USBH_KdPrint((2,"'Exit SubmitIntTrans %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_QueryCapsComplete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * This is a call back when the listen of Interrupt control completes.
  *
  * Arguments:
  *
  * pDeviceObject - should be NULL in our case pIrp - the Irp that is completed
  * for the interrupt transfer. pContext - context value for this Irp.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    NTSTATUS ntStatus;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;

    deviceExtensionHub = Context;
    ntStatus = Irp->IoStatus.Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //cause we said 'invoke on success'
    USBH_ASSERT(NT_SUCCESS(ntStatus));

    ioStack = IoGetCurrentIrpStackLocation(Irp);
    deviceCapabilities = ioStack->Parameters.DeviceCapabilities.Capabilities;
    USBH_ASSERT(ioStack != NULL);
    USBH_ASSERT(ioStack->MajorFunction == IRP_MJ_PNP);
    USBH_ASSERT(ioStack->MinorFunction == IRP_MN_QUERY_CAPABILITIES);
    deviceCapabilities->SurpriseRemovalOK = TRUE;

    USBH_KdPrint((1,"'Setting SurpriseRemovalOK to TRUE\n"));

    return ntStatus;
}


NTSTATUS
USBH_HRPPCancelComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PLONG  lock = (PLONG) Context;

    if (InterlockedExchange(lock, 3) == 1) {

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
USBH_HubResetParentPort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Resets the hub parent port.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    LARGE_INTEGER dueTime;
    LONG lock;

    USBH_KdPrint((1,"'Reset Hub Parent Port, Hub DevExt: %x, PDO: %x\n",
        DeviceExtensionHub, DeviceExtensionHub->PhysicalDeviceObject));

    LOGENTRY(LOG_PNP, "HRPP", DeviceExtensionHub,
        DeviceExtensionHub->TopOfStackDeviceObject,
        DeviceExtensionHub->RootHubPdo);

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                DeviceExtensionHub->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    lock = 0;

    IoSetCompletionRoutine(
        irp,
        USBH_HRPPCancelComplete,
        &lock,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        dueTime.QuadPart = -10000 * ESD_RESET_TIMEOUT;

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       &dueTime);

        if (status == STATUS_TIMEOUT) {

            LOGENTRY(LOG_PNP, "HRPX", DeviceExtensionHub,
                DeviceExtensionHub->TopOfStackDeviceObject,
                DeviceExtensionHub->RootHubPdo);

            USBH_KdPrint((1,"'Reset Hub Parent Port timed out!\n"));

            if (InterlockedExchange(&lock, 1) == 0) {

                //
                // We got it to the IRP before it was completed. We can cancel
                // the IRP without fear of losing it, as the completion routine
                // won't let go of the IRP until we say so.
                //
                IoCancelIrp(irp);

                //
                // Release the completion routine. If it already got there,
                // then we need to complete it ourselves. Otherwise we got
                // through IoCancelIrp before the IRP completed entirely.
                //
                if (InterlockedExchange(&lock, 2) == 3) {

                    //
                    // Mark it pending because we switched threads.
                    //
                    IoMarkIrpPending(irp);
                    IoCompleteRequest(irp, IO_NO_INCREMENT);
                }
            }

            KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

            // Return STATUS_TIMEOUT
            ioStatus.Status = status;
        }

    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    return ntStatus;
}


VOID
USBH_HubESDRecoveryDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PHUB_ESD_RECOVERY_CONTEXT hubESDRecoveryContext = DeferredContext;
    PDEVICE_EXTENSION_HUB deviceExtensionHub =
                            hubESDRecoveryContext->DeviceExtensionHub;
    PUSBH_HUB_ESD_RECOVERY_WORK_ITEM workItemHubESDRecovery;

    USBH_KdPrint((1,"'Hub ESD Recovery DPC\n"));

    UsbhExFreePool(hubESDRecoveryContext);

    InterlockedExchange(&deviceExtensionHub->InESDRecovery, 0);

    if (!(deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING)) {
        //
        // Schedule a work item to process this.
        //
        workItemHubESDRecovery = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_HUB_ESD_RECOVERY_WORK_ITEM));

        if (workItemHubESDRecovery) {

            workItemHubESDRecovery->DeviceExtensionHub = deviceExtensionHub;

            ExInitializeWorkItem(&workItemHubESDRecovery->WorkQueueItem,
                                 USBH_HubESDRecoveryWorker,
                                 workItemHubESDRecovery);

            LOGENTRY(LOG_PNP, "hESD", deviceExtensionHub,
                &workItemHubESDRecovery->WorkQueueItem, 0);

            ExQueueWorkItem(&workItemHubESDRecovery->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_HubESDRecoveryWorker()
            // Don't try to access the WorkItem after it is queued.

        } else {
            USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        }

    } else {
        USBH_KdPrint((1,"'Hub stopping, nothing to do\n"));

        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    }
}


NTSTATUS
USBH_ScheduleESDRecovery(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * Schedules the timer event to handle a hub ESD failure.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PHUB_ESD_RECOVERY_CONTEXT hubESDRecoveryContext = NULL;
    LARGE_INTEGER dueTime;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // Only do this for external hubs.

    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        USBH_KdPrint((1,"'RootHub failed\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (InterlockedExchange(&DeviceExtensionHub->InESDRecovery, 1) == 1) {

        // We already have a timer event scheduled for this.  Don't reschedule.

    } else {

        USBH_KdPrint((1,"'Schedule ESD Recovery\n"));

        LOGENTRY(LOG_PNP, "ESDs", DeviceExtensionHub,
            DeviceExtensionHub->HubFlags, 0);

        hubESDRecoveryContext = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(*hubESDRecoveryContext));

        if (hubESDRecoveryContext) {

            hubESDRecoveryContext->DeviceExtensionHub = DeviceExtensionHub;

            KeInitializeTimer(&hubESDRecoveryContext->TimeoutTimer);
            KeInitializeDpc(&hubESDRecoveryContext->TimeoutDpc,
                            USBH_HubESDRecoveryDPC,
                            hubESDRecoveryContext);

            dueTime.QuadPart = -10000 * ESD_RECOVERY_TIMEOUT;

            KeSetTimer(&hubESDRecoveryContext->TimeoutTimer,
                       dueTime,
                       &hubESDRecoveryContext->TimeoutDpc);

            USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);

            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_HubESDRecoverySetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus, status;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;

    ntStatus = IoStatus->Status;

    if (NT_SUCCESS(ntStatus)) {

        // Hub is now powered back on and fully recovered.  Now find the
        // devices attached to the hub.

        deviceExtensionHub->HubFlags &=
            ~(HUBFLAG_HUB_HAS_LOST_BRAINS | HUBFLAG_HUB_FAILURE);

        // Don't allow selective suspend while post-ESD enumeration is
        // pending.

        deviceExtensionHub->HubFlags |= HUBFLAG_POST_ESD_ENUM_PENDING;

        USBH_IoInvalidateDeviceRelations(deviceExtensionHub->PhysicalDeviceObject,
                                         BusRelations);

        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

    } else {

        // Setting hub parent port to D0 failed, we are likely still
        // experiencing ESD.  Reschedule the ESD recovery.

        status = USBH_ScheduleESDRecovery(deviceExtensionHub);

        if (status == STATUS_SUCCESS) {
            // Remove extra pending count bump
            USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_HubESDRecoverySetD3Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent, 1, FALSE);

    ntStatus = IoStatus->Status;

    return ntStatus;
}


VOID
USBH_HubESDRecoveryWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a hub ESD failure.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_HUB_ESD_RECOVERY_WORK_ITEM workItemHubESDRecovery;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_EXTENSION_PORT hubParentDeviceExtensionPort;
    POWER_STATE powerState;
    PORT_STATE portState;
    NTSTATUS ntStatus, status;

    PAGED_CODE();

    workItemHubESDRecovery = Context;
    deviceExtensionHub = workItemHubESDRecovery->DeviceExtensionHub;

    UsbhExFreePool(workItemHubESDRecovery);

    USBH_KdPrint((1,"'Hub ESD Recovery Worker\n"));

    // NB: Because I now check for HUBFLAG_DEVICE_STOPPING in
    // USBH_HubESDRecoveryDPC, some of the following sanity checking might
    // not be necessary, but I'll leave it in anyway to be safe.

    // In the case where there are nested hubs, the hub device extension
    // for one of the downstream hubs might be invalid by the time this
    // workitem is called.  Check for that here.

    if (deviceExtensionHub->ExtensionType != EXTENSION_TYPE_HUB) {
        USBH_KdPrint((1,"'Downstream hub already removed, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // If the hub has been physically removed from the bus, then we have
    // nothing to do here.

    if (!deviceExtensionHub->PhysicalDeviceObject) {
        USBH_KdPrint((1,"'Hub has been removed (no PDO), nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    hubParentDeviceExtensionPort = deviceExtensionHub->PhysicalDeviceObject->DeviceExtension;

    LOGENTRY(LOG_PNP, "ESDw", deviceExtensionHub,
        hubParentDeviceExtensionPort->PortPdoFlags, deviceExtensionHub->HubFlags);

//    USBH_KdPrint((1,"'Hub parent port PortPdoFlags: %x\n",
//        hubParentDeviceExtensionPort->PortPdoFlags));

    // We definitely need the following check, so don't remove this.

    if (hubParentDeviceExtensionPort->PortPdoFlags &
        (PORTPDO_DELETED_PDO | PORTPDO_DELETE_PENDING) ||
        !(hubParentDeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB)) {

        USBH_KdPrint((1,"'Hub has been removed, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // Be sure that the hub hasn't stopped or set to a low power state before
    // this workitem had a chance to run.

    if (deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) {

        USBH_KdPrint((1,"'Hub has is stopping or in low power, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // One last sanity check.  Check the port status for the parent port
    // of this hub and be sure that a device is still connected.

    ntStatus = USBH_SyncGetPortStatus(
                hubParentDeviceExtensionPort->DeviceExtensionHub,
                hubParentDeviceExtensionPort->PortNumber,
                (PUCHAR) &portState,
                sizeof(portState));

    if (!NT_SUCCESS(ntStatus) ||
        !(portState.PortStatus & PORT_STATUS_CONNECT)) {

        USBH_KdPrint((1,"'Hub device has been physically disconnected, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // Reset the parent port for this hub.

    ntStatus = USBH_HubResetParentPort(deviceExtensionHub);

    USBH_KdPrint((1,"'USBH_HubResetParentPort returned %x\n", ntStatus));

    if (ntStatus == STATUS_INVALID_PARAMETER) {

        // Looks like we lost the port PDO somewhere along the way.
        // (Call to USBH_ResetDevice from USBH_RestoreDevice failed.)
        // Bail out of this ESD recovery, and the user will have to
        // unplug/replug the hub to get it back.  Maybe we can revisit
        // this later.

        USBH_KdPrint((1,"'Lost hub PDO during reset, bail\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    if (ntStatus == STATUS_TIMEOUT) {

        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    if (NT_SUCCESS(ntStatus)) {

        KEVENT event;

        // On Memphis we must tell power management that the hub is in D3.
        // (It thinks that the hub is in D0 because it does not know that
        // resetting the hub's parent port causes the hub to lose power.
        //
        // We need to do this on Memphis because power management appears to
        // track the power state of devices and will suppress sending a power
        // request to a device if it thinks that the device is already in that
        // power state.  Under NT they don't seem to care and will send the
        // request along anyway.

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        powerState.DeviceState = PowerDeviceD3;

        // "Power down" the hub.
        ntStatus = PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                                     IRP_MN_SET_POWER,
                                     powerState,
                                     USBH_HubESDRecoverySetD3Completion,
                                     &event,
                                     NULL);

        USBH_ASSERT(ntStatus == STATUS_PENDING);
        if (ntStatus == STATUS_PENDING) {

            USBH_KdPrint((2,"'Wait for single object\n"));

            status = KeWaitForSingleObject(&event,
                                           Suspended,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
        }

        deviceExtensionHub->CurrentPowerState = PowerDeviceD3;

        powerState.DeviceState = PowerDeviceD0;

        // Power up the hub.
        ntStatus = PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                                     IRP_MN_SET_POWER,
                                     powerState,
                                     USBH_HubESDRecoverySetD0Completion,
                                     deviceExtensionHub,
                                     NULL);

        if (ntStatus != STATUS_PENDING) {
            // Power IRP request was not successful.  Reschedule the recovery
            // so that we can try again later.

            status = USBH_ScheduleESDRecovery(deviceExtensionHub);

            if (status == STATUS_SUCCESS) {
                // Remove extra pending count bump
                USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
            }
        }

    } else {
        // Reset hub parent port failed, we are likely still experiencing ESD.
        // Reschedule the ESD recovery.

        status = USBH_ScheduleESDRecovery(deviceExtensionHub);

        if (status == STATUS_SUCCESS) {
            // Remove extra pending count bump
            USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        }
    }
}


NTSTATUS
USBH_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * This is a call back when the listen of Interrupt control completes.
  *
  * Arguments:
  *
  * pDeviceObject - should be NULL in our case pIrp - the Irp that is completed
  * for the interrupt transfer. pContext - context value for this Irp.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PURB urb;                  // the Urb assocaited with this Irp
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSBH_WORK_ITEM workItem;
    BOOLEAN requestReset = FALSE;
    USHORT portNumber, numberOfPorts;

    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) Context; // the context is
                                                          // DeviceExtensionHub
    urb = &deviceExtensionHub->Urb;

    USBH_KdPrint((2,"'ChangeIndication Irp status %x  URB status = %x\n",
        Irp->IoStatus.Status, urb->UrbHeader.Status));

    LOGENTRY(LOG_PNP, "chID", deviceExtensionHub, urb, Irp);

    if (NT_ERROR(Irp->IoStatus.Status) ||
        USBD_ERROR(urb->UrbHeader.Status) ||
        (deviceExtensionHub->HubFlags & (HUBFLAG_HUB_FAILURE |
                                         HUBFLAG_DEVICE_STOPPING)) ||
        urb->UrbHeader.Status == USBD_STATUS_CANCELED) {
        requestReset = TRUE;
        deviceExtensionHub->ErrorCount++;

        //
        // An error has occurred submitting the interrupt
        // transfer, possible causes:

        //
        // 1. the interrupt pipe is stalled
        // 2. the hub is experiencing a temporary problem
        // 3. the hub is messed up and we need to reset it
        // 4. we are stopping the device
        // 5. the hub has been removed from the bus
        //
        // In any case we will need to take some action.

        //
        // if an abort event is waiting signal it
        //
        LOGENTRY(LOG_PNP, "cERR", deviceExtensionHub,
            &deviceExtensionHub->AbortEvent, deviceExtensionHub->ErrorCount);

        if ((deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) ||
            deviceExtensionHub->ErrorCount > USBH_MAX_ERRORS ||
            (deviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) ||
            Irp->IoStatus.Status == STATUS_DELETE_PENDING) {
            //
            // shutting down the hub, do not schedule any more
            // work items while in this state.
            //
            USBH_KdPrint((2,"'ChangeIndication, device stopping or hub failure\n"));

#if DBG
            if (deviceExtensionHub->ErrorCount > USBH_MAX_ERRORS) {

                // we may ideed have a hub failure, more liekly
                // the device was just unplugged, if the hub has
                // failed we should pick this up when we try to
                // do control tranfers to it.

                LOGENTRY(LOG_PNP, "xERR", deviceExtensionHub,
                    0, deviceExtensionHub->ErrorCount);
            }
#endif

            // Set the AbortEvent after checking the HubFlags, not before.
            // As soon as the AbortEvent is set the thread waiting on it may
            // run and cause the HubFlags to change.
            //
            KeSetEvent(&deviceExtensionHub->AbortEvent,
                       1,
                       FALSE);

            goto USBH_ChangeIndication_Done;
        }

        // Set the AbortEvent after checking the HubFlags, not before.
        //
        KeSetEvent(&deviceExtensionHub->AbortEvent,
                   1,
                   FALSE);

    } else {
        // reset error count on successful
        // transfer
         LOGENTRY(LOG_PNP, "zERR", deviceExtensionHub,
            0, deviceExtensionHub->ErrorCount);

        deviceExtensionHub->ErrorCount = 0;
    }


    USBH_KdPrint((2,"'Enter ChangeIndication Transfer %x \n",
                  deviceExtensionHub->TransferBuffer));
#if DBG
    {
    ULONG i;
    for (i=0; i< deviceExtensionHub->TransferBufferLength; i++) {
        USBH_KdPrint((2,"'TransferBuffer[%d] = %x\n", i,
                       deviceExtensionHub->TransferBuffer[i]));
    }
    }
#endif

    //
    // Schedule a work item to process this change
    //
    workItem = UsbhExAllocatePool(NonPagedPool, sizeof(USBH_WORK_ITEM)+
                    deviceExtensionHub->TransferBufferLength);

    if (workItem) {
        NTSTATUS status;

        workItem->Flags = 0;
        if (requestReset) {
            workItem->Flags = USBH_WKFLAG_REQUEST_RESET;
        }

         // i-friend, indicate we have a workitem pendingf=
        {
        LONG cWKPendingCount;

        cWKPendingCount = InterlockedIncrement(
                &deviceExtensionHub->ChangeIndicationWorkitemPending);

        // Prevent hub from powering down or being removed if there is a
        // ChangeIndicationAckChange pending.

        if (cWKPendingCount == 1) {
            KeResetEvent(&deviceExtensionHub->CWKEvent);
        }
        }

        workItem->DeviceExtensionHub = deviceExtensionHub;

        USBH_ASSERT(deviceExtensionHub->WorkItemToQueue == NULL);
        deviceExtensionHub->WorkItemToQueue = workItem;

        RtlCopyMemory(&workItem->Data[0], deviceExtensionHub->TransferBuffer,
            deviceExtensionHub->TransferBufferLength);

        ExInitializeWorkItem(&workItem->WorkQueueItem,
                             USBH_ChangeIndicationWorker,
                             workItem);

        // now process the change, this will signal any waiting
        // reset or resume withoutr reqireing a work item

        LOGENTRY(LOG_PNP, "cITM", deviceExtensionHub,
            &workItem->WorkQueueItem, 0);

        numberOfPorts = deviceExtensionHub->HubDescriptor->bNumberOfPorts;
        for (portNumber = 0; portNumber <= numberOfPorts; portNumber++) {
            if (IsBitSet(&workItem->Data[0],
                         portNumber)) {
                break;
            }
        }

        // If none of the bits for the ports were set in the loop above
        // (i.e. we can't find a change on any of the ports), then just
        // assume port zero and USBH_ChangeIndicationQueryChange will
        // handle accordingly.

        if (portNumber > numberOfPorts) {
            portNumber = 0;
        }

        status = USBH_ChangeIndicationQueryChange(
            deviceExtensionHub,
            Irp,
            urb,
            portNumber);

        if (NT_ERROR(status)) {
            HUB_FAILURE(deviceExtensionHub);
        }

    }

#if DBG
      else {
        LOGENTRY(LOG_PNP, "XMEM", deviceExtensionHub, 0, 0);
        UsbhWarning(NULL,
                    "Memory allocation error in USBH_ChangeIndication, cannot process hub changes.\n",
                    FALSE);
    }
#endif

USBH_ChangeIndication_Done:

    //
    // keep the irp
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
USBH_ChangeIndicationQueryChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port
    )
 /* ++
  *
  * Description:
  *
  *     Queries what changed, ie checks the port to see what changed
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    CHAR stackSize;
    PUSBH_WORK_ITEM workItem;
    LONG cWKPendingCount;

    LOGENTRY(LOG_PNP, "QCH>", DeviceExtensionHub, Urb, Port);

    // bump the io count now this represents pending workitem
    // we will queue on completion of this irp
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (Port == 0) {

        //
        // if we have a hub status change just queue our
        // workitem and get out
        //
        USBH_ASSERT(DeviceExtensionHub->WorkItemToQueue != NULL);
        workItem = DeviceExtensionHub->WorkItemToQueue;
        DeviceExtensionHub->WorkItemToQueue = NULL;

        LOGENTRY(LOG_PNP, "qIT2", DeviceExtensionHub,
                &workItem->WorkQueueItem, 0);

        ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);


        return ntStatus;
    }

    Urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    Urb->UrbHeader.Function = URB_FUNCTION_CLASS_OTHER;

    //
    // Fill in Urb body
    //

    UsbhBuildVendorClassUrb(Urb,
                            NULL,
                            URB_FUNCTION_CLASS_OTHER,
                            USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK,
                            REQUEST_TYPE_GET_PORT_STATUS,
                            REQUEST_GET_STATUS,
                            0,
                            Port,
                            sizeof(DeviceExtensionHub->PortStateBuffer),
                            &DeviceExtensionHub->PortStateBuffer);

    DeviceExtensionHub->ResetPortNumber = Port;

    stackSize = DeviceExtensionHub->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(Irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(Irp,    // Irp
                           USBH_ChangeIndicationProcessChange,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, Irp);

    return ntStatus;

}


NTSTATUS
USBH_ChangeIndicationProcessChange(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  *     Take some action based on change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PPORT_STATE currentPortState;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PUSBH_WORK_ITEM workItem;
    PURB urb;
    NTSTATUS status;
    USHORT wFeatureSelector;
    LONG cWKPendingCount;

    deviceExtensionHub = Context;
    currentPortState = &(deviceExtensionHub->PortStateBuffer);
    urb = &deviceExtensionHub->Urb;

    LOGENTRY(LOG_PNP, "PCHc", deviceExtensionHub,
            *((PULONG)currentPortState), Irp);

    if ((NT_SUCCESS(Irp->IoStatus.Status) ||
         USBD_SUCCESS(urb->UrbHeader.Status)) &&
         (currentPortState->PortChange & PORT_STATUS_RESET ||
          currentPortState->PortChange & PORT_STATUS_ENABLE)) {

        //
        // bit 4 RESET completed
        //

        // no workitem
        LOGENTRY(LOG_PNP, "nITM", deviceExtensionHub,
            0, 0);
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

        UsbhExFreePool(deviceExtensionHub->WorkItemToQueue);
        deviceExtensionHub->WorkItemToQueue = NULL;

        //
        // Signal the PNP thread that a the reset has completed
        //
        // once we do this we can get antother change indication
        // so we free the workitem first.
        //

        LOGENTRY(LOG_PNP, "RESc", deviceExtensionHub,
            deviceExtensionHub->ResetPortNumber, 0);

        if (currentPortState->PortChange & PORT_STATUS_RESET) {
            wFeatureSelector = FEATURE_C_PORT_RESET;
        } else {
            wFeatureSelector = FEATURE_C_PORT_ENABLE;
        }

        status = USBH_ChangeIndicationAckChange(
                    deviceExtensionHub,
                    Irp,
                    urb,
                    (USHORT)deviceExtensionHub->ResetPortNumber,
                    wFeatureSelector);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

//    if (deviceExtensionHub->HubFlags & HUBFLAG_PENDING_PORT_RESET) {
//        USBH_KdPrint((0,"'port change broke reset\n"));
//        TEST_TRAP();
//    }

    //
    // now queue the workitem to finish the processing
    //

    USBH_ASSERT(deviceExtensionHub->WorkItemToQueue != NULL);
    workItem = deviceExtensionHub->WorkItemToQueue;
    deviceExtensionHub->WorkItemToQueue = NULL;

    LOGENTRY(LOG_PNP, "qITM", deviceExtensionHub,
            &workItem->WorkQueueItem, 0);

    ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
USBH_ChangeIndicationAckChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port,
    IN USHORT FeatureSelector
    )
 /* ++
  *
  * Description:
  *
  *     Ack a reset change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    CHAR stackSize;

    LOGENTRY(LOG_PNP, "ACH>", DeviceExtensionHub, FeatureSelector, Port);

    Urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    Urb->UrbHeader.Function = URB_FUNCTION_CLASS_OTHER;

    //
    // Fill in Urb body
    //

    UsbhBuildVendorClassUrb(Urb,
                            NULL,
                            URB_FUNCTION_CLASS_OTHER,
                            USBD_TRANSFER_DIRECTION_OUT | USBD_SHORT_TRANSFER_OK,
                            REQUEST_TYPE_SET_PORT_FEATURE,
                            REQUEST_CLEAR_FEATURE,
                            FeatureSelector,
                            Port,
                            0,
                            NULL);

    stackSize = DeviceExtensionHub->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(Irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(Irp,    // Irp
                           USBH_ChangeIndicationAckChangeComplete,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, Irp);

    return ntStatus;

}


NTSTATUS
USBH_ChangeIndicationAckChangeComplete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  *     ack a reset change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PPORT_STATE currentPortState;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PPORT_STATE hubExtensionPortState;
    PURB urb;
    PKEVENT resetEvent;
    LONG pendingWorkitem = 0;

    deviceExtensionHub = Context;
    currentPortState = &(deviceExtensionHub->PortStateBuffer);
    urb = &deviceExtensionHub->Urb;

    LOGENTRY(LOG_PNP, "aCHc", deviceExtensionHub,
            *((PULONG)currentPortState), Irp);

    hubExtensionPortState =
        &(deviceExtensionHub->PortData + deviceExtensionHub->ResetPortNumber - 1)->PortState;

    *hubExtensionPortState = *currentPortState;

    resetEvent = InterlockedExchangePointer(&deviceExtensionHub->Event, NULL);

    if (resetEvent) {

        LOGENTRY(LOG_PNP, "WAKr", deviceExtensionHub, resetEvent, 0);
        KeSetEvent(resetEvent,
                   1,
                   FALSE);
    }

    USBH_SubmitInterruptTransfer(deviceExtensionHub);

    pendingWorkitem = InterlockedDecrement(
                        &deviceExtensionHub->ChangeIndicationWorkitemPending);

    // If USBH_FdoPower or USBH_FdoCleanup is waiting on this
    // ChangeIndicationAckChangeComplete, then signal the thread
    // that it may now continue.

    if (!pendingWorkitem) {
        KeSetEvent(&deviceExtensionHub->CWKEvent, 1, FALSE);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}


VOID
USBH_ChangeIndicationWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to process a change indication from the hub. we process
  * the URB here and if necessary re-submit the interrupt transfer.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    ULONG numberOfPorts;      // total ports on this hub
    ULONG portNumber;  // port that has status change
    PDEVICE_EXTENSION_HUB DeviceExtensionHub;
    PUSBH_WORK_ITEM workItem;
    ULONG state;
    //LONG ioCount;
    BOOLEAN newTransfer = FALSE;
    PDEVICE_EXTENSION_PORT hubParentDeviceExtensionPort;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PPORT_DATA p;
    ULONG i;
    PORT_STATE portState;
    LONG pendingWorkitem = 0;

    PAGED_CODE();
    USBH_ASSERT(sizeof(state) == sizeof(HUB_STATE));
    USBH_ASSERT(sizeof(state) == sizeof(PORT_STATE));

    workItem = Context;
    DeviceExtensionHub = workItem->DeviceExtensionHub;

    LOGENTRY(LOG_PNP, "cWK+", DeviceExtensionHub, Context, 0);

    USBH_KdPrint((2,"'Enter ChangeIndicationWorker %x\n", DeviceExtensionHub));

    // lock access to the hub ports

    // pending count inc'ed when work item was schedued
    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", DeviceExtensionHub));
    KeWaitForSingleObject(&DeviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", DeviceExtensionHub));

    //
    // device is stopping, perform no processing
    // of the change request.
    //

    if (DeviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) {
        // set the abort event since we will not be
        // submitting another transfer
        KeSetEvent(&DeviceExtensionHub->AbortEvent,
                   1,
                   FALSE);
        goto USBH_ChangeIndicationWorker_Exit;
    }

    // Check for hub ESD failure.
    // Make sure that this is an external hub.

    if (DeviceExtensionHub->ErrorCount &&
        DeviceExtensionHub->PhysicalDeviceObject != DeviceExtensionHub->RootHubPdo) {

        hubParentDeviceExtensionPort =
                DeviceExtensionHub->PhysicalDeviceObject->DeviceExtension;

        if (hubParentDeviceExtensionPort->PortPdoFlags & PORTPDO_USB_SUSPEND) {

            // Hub likely failed during power up.  Don't do recovery here.
            // The Peracom hub (TI chipset) generally fails the first power
            // up if one of its downstream devices caused the wake, but the
            // next power up (from set S0 request) is successful.  Performing
            // ESD recovery at this time interferes with this.

            goto USBH_CIW_NoESD;
        }

        // if hub backpointer is null then this device is removed, attempt
        // no ESD crap here.

        if (hubParentDeviceExtensionPort->DeviceExtensionHub == NULL) {
            goto USBH_CIW_NoESD;
        }

        // See if we can differentiate between hub removal and ESD.
        // Check the upstream port status.

        ntStatus = USBH_SyncGetPortStatus(
                    hubParentDeviceExtensionPort->DeviceExtensionHub,
                    hubParentDeviceExtensionPort->PortNumber,
                    (PUCHAR) &portState,
                    sizeof(portState));

//        if (!NT_SUCCESS(ntStatus) ||
//            portState.PortStatus & PORT_STATUS_CONNECT) {

        if (NT_SUCCESS(ntStatus) &&
            portState.PortStatus & PORT_STATUS_CONNECT) {

            // ESD
            USBH_KdPrint((1,"'Looks like ESD event (hub failure)\n"));

            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_HAS_LOST_BRAINS)) {

                DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_HAS_LOST_BRAINS;

                LOGENTRY(LOG_PNP, "ESD!", DeviceExtensionHub,
                    0, DeviceExtensionHub->ErrorCount);

#if DBG
                UsbhWarning(NULL,
                    "ESD or hub failure occurred, attempting recovery.\n",
                    FALSE);
#endif

                numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
                USBH_ASSERT(DeviceExtensionHub->PortData != NULL);
                p = DeviceExtensionHub->PortData;
                for (i=0; i<numberOfPorts; i++, p++) {

                    if (p->DeviceObject) {
                        USBH_KdPrint((1,"'Marking PDO %x for removal\n", p->DeviceObject));

                        deviceExtensionPort = p->DeviceObject->DeviceExtension;
                        deviceExtensionPort->PortPdoFlags |= PORTPDO_DELETE_PENDING;
                    }
//
// Note that we hold onto the hub's reference to the device object here.
// We need to do this for the case where a hub fails, and the downstream device
// had open references to it (open files on USB storage device).  In this case
// PnP won't send the remove to the device until the files have been closed, and
// we need the reference to the device object in the hub device extension so
// that we can properly cleanup after the device in USBH_FdoCleanup when the
// hub is removed.  If we do not do this then we will fault in
// USBH_PdoRemoveDevice when trying to dereference the pointer to the hub
// device extension that this device in connected to because the hub is long
// gone by then.
//
//                    p->DeviceObject = NULL;

                    p->ConnectionStatus = NoDeviceConnected;
                }

                // Tell PnP that there are no devices on this hub.
                // FdoQueryBusRelations will return zero devices for this hub
                // if the HUBFLAG_HUB_HAS_LOST_BRAINS is set.

                USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                                 BusRelations);

                // Start timer to start workitem to reset hub and attempt recovery.

                USBH_ScheduleESDRecovery(DeviceExtensionHub);

                goto USBH_ChangeIndicationWorker_Exit;
            }

        } else {
            // No ESD, hub was removed.
            LOGENTRY(LOG_PNP, "HubY", DeviceExtensionHub,
                DeviceExtensionHub->HubFlags, 0);
            USBH_KdPrint((1,"'Looks like hub was removed\n"));

            DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_GONE;
            // set the abort event since we will not be
            // submitting another transfer (parent hub may already be
            // selectively suspended)
            KeSetEvent(&DeviceExtensionHub->AbortEvent,
                       1,
                       FALSE);
            goto USBH_ChangeIndicationWorker_Exit;
        }
    }

USBH_CIW_NoESD:

    //
    // request reset flag is set indicating that the device
    // needs some attention
    //


    if (workItem->Flags & USBH_WKFLAG_REQUEST_RESET) {
        // reset the hub
        LOGENTRY(LOG_PNP, "rrST", DeviceExtensionHub, Context, 0);
        USBH_ResetHub(DeviceExtensionHub);

        // re-submit the interrupt transfer
        newTransfer = TRUE;
        goto USBH_ChangeIndicationWorker_Exit;
    }


#if DBG
    {
    ULONG i;
    for (i=0; i< DeviceExtensionHub->TransferBufferLength; i++) {
        USBH_KdPrint((2,"'Data[%d] = %x\n", i,
                       workItem->Data[i]));
    }
    }
#endif

    //
    // Check to see what has changed
    //

    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
    for (portNumber = 0; portNumber <= numberOfPorts; portNumber++) {
        if (IsBitSet( &workItem->Data[0],
                     portNumber)) {
            break;
        }
    }

#if 0
    //
    // Work around for Philips hub bug. This should be temporary because it
    // will cost extraneous
    // CPU cycles for spec conformant external hubs. Remove the code for
    // formal build.
    //
#pragma message( "!!!!! Workaround for Philips external hub Vid==0471 && Rev==0030 !!!!!")
    if ((0x0471 == DeviceExtensionHub->DeviceDescriptor.idVendor) &&
    // (0x0101 == DeviceExtensionHub->DeviceDescriptor.idProduct) &&
        (0x0030 == DeviceExtensionHub->DeviceDescriptor.bcdDevice)) {
        //
        // This phillips external hub reports port status-change shift by 1
        // bit
        //
        USBH_KdBreak(("Shift By One hack fo philips hub\n"));
        portNumber--;
    }
#endif          /* PHILIPS_HACK_ENABLED */
    if (portNumber > numberOfPorts) {
        USBH_KdPrint((2,"'StatusChangeIndication nothing has changed\n"));

        //
        // nothing to do here
        // put the listen back down and get out.
        //

        newTransfer = TRUE;
        goto USBH_ChangeIndicationWorker_Exit;
    }

    USBH_KdPrint((2,"'Port number %x changed (0 indicates hub)\n", portNumber));
    LOGENTRY(LOG_PNP, "pCHG", DeviceExtensionHub, Context, portNumber);

    if (portNumber != 0)  {
        ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                          (USHORT)portNumber,
                                          (PUCHAR) &state,
                                          sizeof(state));
    } else {
        ntStatus = USBH_SyncGetHubStatus(DeviceExtensionHub,
                                         (PUCHAR) &state,
                                         sizeof(state));
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("ChangeIndication GetStatus failed code %x\n", ntStatus));

        //
        // an error occured getting the status for the port
        // put the listen back down and get out
        //
        // this condition may be temoprary in which case the
        // listen will cause us to retry

        DeviceExtensionHub->ErrorCount++;
        if (DeviceExtensionHub->ErrorCount > USBH_MAX_ERRORS) {
            HUB_FAILURE(DeviceExtensionHub);
        } else {
            newTransfer = TRUE;
        }
        goto USBH_ChangeIndicationWorker_Exit;
    }
    //
    // no error
    // process the status change
    //

    USBH_KdPrint((2,"'Process State = %x\n", state));

    if (portNumber != 0) {
        USBH_ProcessPortStateChange((PPORT_STATE)&state, (USHORT)portNumber, DeviceExtensionHub);
    } else {
        USBH_ProcessHubStateChange((PHUB_STATE)&state, DeviceExtensionHub);
    }

    newTransfer = TRUE;

USBH_ChangeIndicationWorker_Exit:

    UsbhExFreePool(workItem);

    //
    // The stopping thread can be signaled even though there is a transfer irp
    // pending.  because of this the stopping thread also waits on the
    // AbortEvent for the pending transfer.
    //

    if (newTransfer) {
        //
        // Put our listen transfer back down now that
        // we have acknowledged the change.
        //
        // NOTE: This could result in another work item being queued,
        // but only if the device stopping flag clear.
        USBH_SubmitInterruptTransfer(DeviceExtensionHub);
    }

    //
    // allow others to access the ports
    //
    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    //
    // the pending count can only go to zero if the stopping flag has been set
    //
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    pendingWorkitem = InterlockedDecrement(
                        &DeviceExtensionHub->ChangeIndicationWorkitemPending);

    // If USBH_FdoPower or USBH_FdoCleanup is waiting on this
    // ChangeIndicationWorker, then signal the thread that it
    // may now continue.

    if (!pendingWorkitem) {
        KeSetEvent(&DeviceExtensionHub->CWKEvent, 1, FALSE);
    }

    if (!pendingWorkitem &&
        DeviceExtensionHub->HubFlags & HUBFLAG_NEED_IDLE_CHECK) {

        USBH_CheckHubIdle(DeviceExtensionHub);
    }

    LOGENTRY(LOG_PNP, "cWK-", DeviceExtensionHub, Context, 0);
    USBH_KdPrint((2,"'Exit ChangeIndicationWorker\n"));
}


VOID
USBH_ProcessHubStateChange(
    IN PHUB_STATE CurrentHubState,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *         Process a hub change indictaion from a hub
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    //
    // process hub status
    //
    PHUB_STATE hubExtensionState;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    ULONG statusBit;
    PPORT_DATA p;
    ULONG numberOfPorts, i;

    PAGED_CODE();
    if (CurrentHubState->HubChange & HUB_STATUS_LOCAL_POWER) {
        TEST_TRAP();
        USBH_KdPrint((2,"'StatusIndication hub local power changed\n"));
        statusBit = CurrentHubState->HubStatus & HUB_STATUS_LOCAL_POWER;
        hubExtensionState = &DeviceExtensionHub->HubState;
        USBH_KdPrint((2,"'Hub local power bit was %d is %d\n", \
             hubExtensionState->HubStatus & HUB_STATUS_LOCAL_POWER, statusBit));

        //
        // update our record
        //
        hubExtensionState->HubStatus &= ~HUB_STATUS_LOCAL_POWER;
        hubExtensionState->HubStatus |= statusBit;

        //
        // ack the change
        //
        USBH_SyncClearHubStatus(DeviceExtensionHub,
                                FEATURE_C_HUB_LOCAL_POWER);

        //
        // jd
        // What further action should be taken here?
        //

    } else if (CurrentHubState->HubChange & HUB_STATUS_OVER_CURRENT) {

        USBH_KdPrint(( 1, "Hub is reporting overcurrent\n"));
#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
        statusBit = CurrentHubState->HubStatus & HUB_STATUS_OVER_CURRENT;
        hubExtensionState = &DeviceExtensionHub->HubState;
        USBH_KdPrint((2,"'Hub over current bit was %d is %d\n",
            hubExtensionState->HubStatus & HUB_STATUS_OVER_CURRENT, statusBit));

        //
        // update our record
        //
        hubExtensionState->HubStatus &= ~HUB_STATUS_OVER_CURRENT;
        hubExtensionState->HubStatus |= statusBit;

        //
        // set the ack status change
        //
        USBH_SyncClearHubStatus(DeviceExtensionHub,
                                FEATURE_C_HUB_OVER_CURRENT);

        //
        // We have a global overcurrent condition for the hub itself
        // chances are the entire hub has lost it -- we will mark the
        // hub as failed
        //
        if (hubExtensionState->HubStatus & HUB_STATUS_OVER_CURRENT) {

            USBH_KdPrint(( 1, "Hub disabled by overcurrent --> this is bad\n"));

            USBH_WriteFailReason(
                DeviceExtensionHub->PhysicalDeviceObject,
                USBH_FAILREASON_HUB_OVERCURRENT);

            HUB_FAILURE(DeviceExtensionHub);

            numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
            USBH_ASSERT(DeviceExtensionHub->PortData != NULL);
            p = DeviceExtensionHub->PortData;
            for (i=0; i<numberOfPorts; i++, p++) {

                if (p->DeviceObject) {
                    USBH_KdPrint((1,"'Marking PDO %x for removal\n", p->DeviceObject));

                    deviceExtensionPort = p->DeviceObject->DeviceExtension;
                    deviceExtensionPort->PortPdoFlags |= PORTPDO_DELETE_PENDING;
                }
//
// Note that we hold onto the hub's reference to the device object here.
// We need to do this for the case where a hub fails, and the downstream device
// had open references to it (open files on USB storage device).  In this case
// PnP won't send the remove to the device until the files have been closed, and
// we need the reference to the device object in the hub device extension so
// that we can properly cleanup after the device in USBH_FdoCleanup when the
// hub is removed.  If we do not do this then we will fault in
// USBH_PdoRemoveDevice when trying to dereference the pointer to the hub
// device extension that this device in connected to because the hub is long
// gone by then.
//
//                    p->DeviceObject = NULL;

                p->ConnectionStatus = NoDeviceConnected;
            }

            // Tell PnP that there are no devices on this hub.
            // FdoQueryBusRelations will return zero devices for this hub
            // if the HUBFLAG_HUB_HAS_LOST_BRAINS is set.

            USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                             BusRelations);

            // Try to recover the hub.
            USBH_ScheduleESDRecovery(DeviceExtensionHub);
        }

    } else {
        USBH_KdBreak(("Unrecognized hub change code %x\n", CurrentHubState->HubChange));
    }
}


NTSTATUS
USBH_FlushPortChange(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
//    PPORT_DATA portData;
    PORT_STATE portState;

    ASSERT_HUB(DeviceExtensionHub);

//    portData = &deviceExtensionHub->PortData[
//                    DeviceExtensionPort->PortNumber - 1];

    LOGENTRY(LOG_PNP, "Pfls", DeviceExtensionPort,
                DeviceExtensionHub,
                DeviceExtensionPort->PortNumber);
    USBH_KdPrint((1,"'USBH_FlushPortChange, port number %x\n",
        DeviceExtensionPort->PortNumber));

    //
    // we need to refresh the port data since it was lost on the stop
    //

    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    LOGENTRY(LOG_PNP, "PfST", DeviceExtensionPort,
                portState.PortChange,
                portState.PortStatus);

    if (NT_SUCCESS(ntStatus) &&
        portState.PortChange & PORT_STATUS_CONNECT) {

        LOGENTRY(LOG_PNP, "PfCL", DeviceExtensionPort,
                DeviceExtensionPort->PortNumber,
                ntStatus);

        ntStatus = USBH_SyncClearPortStatus(DeviceExtensionHub,
                                            DeviceExtensionPort->PortNumber,
                                            FEATURE_C_PORT_CONNECT);
    }

    return ntStatus;
}


VOID
USBH_ProcessPortStateChange(
    IN PPORT_STATE CurrentPortState,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *         Process a port change indication from the hub
  *
  *         this code assumes that only one change bit is set at a time
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    //
    // this code assumes that only one change bit is set at a time
    //

    PPORT_STATE hubExtensionPortState;
    USHORT statusBit;
    PPORT_DATA portData;
    BOOLEAN validConnectChange = TRUE;
    PDEVICE_EXTENSION_PORT deviceExtensionPort = NULL;
    PIRP irp;
    PIRP hubWaitWake = NULL;
    KIRQL irql;
    LONG pendingPortWWs;
    PWCHAR sernumbuf;
    PKEVENT suspendEvent;
#ifdef EARLY_RESOURCE_RELEASE
    PVOID deviceData;
#endif

    // Can't acquire (cancel) spin locks in paged code!
    // TODO:  isolate the pieces of code that require the spin lock into helper
    // functions
    // PAGED_CODE();
    USBH_ASSERT(DeviceExtensionHub->PortData != NULL);
    hubExtensionPortState = &(DeviceExtensionHub->PortData + PortNumber - 1)->PortState;

    USBH_KdPrint((2,"'USBH_ProcessPortStateChange for Port %x Old Dword %x\n", PortNumber, *(ULONG *) hubExtensionPortState));
    LOGENTRY(LOG_PNP, "PSCn", DeviceExtensionHub,
        CurrentPortState->PortStatus, CurrentPortState->PortChange);

    if (CurrentPortState->PortChange & PORT_STATUS_CONNECT) {
        //
        // bit 0, connect status change
        //
        USHORT oldStatusBit;

        USBH_KdPrint((2,"'Status Indication port connect changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_CONNECT;
        oldStatusBit = hubExtensionPortState->PortStatus & PORT_STATUS_CONNECT;

        USBH_KdPrint((2,"'Port connect was %x is %x\n", oldStatusBit, statusBit));

        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //

        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_CONNECT);


        //
        // If the conn status stays the same, clear the change. Otherwise,
        // tell to reenumerate.
        // A disconn->conn->disconn sequence is neglegible.
        // A conn->discconn->conn is considered only possible with the same
        // device.
        //

        USBH_ASSERT(PortNumber > 0);
        portData = &DeviceExtensionHub->PortData[PortNumber-1];

        if (!(oldStatusBit ^ statusBit)) {

            // we should only see this in the case where
            // the hub has lost power
            USBH_KdPrint((1,"'status change but nothing has changed\n"));


            LOGENTRY(LOG_PNP, "Pchg", DeviceExtensionHub,
                    PortNumber, validConnectChange);
        }

        if (portData->DeviceObject) {

            deviceExtensionPort = portData->DeviceObject->DeviceExtension;

            if (deviceExtensionPort->PortPdoFlags & PORTPDO_OVERCURRENT) {
                USBH_KdPrint((1,"'port overcurrent detected\n"));
                validConnectChange = FALSE;
                LOGENTRY(LOG_PNP, "Povr", DeviceExtensionHub,
                    PortNumber, validConnectChange);
            }

        }

        if (validConnectChange) {
            // we have a valid port connect status change
            LOGENTRY(LOG_PNP, "CONc", DeviceExtensionHub, PortNumber, 0);

            //
            // Notify PnP to enumerate this PDO for the device
            // that has arrived or left
            //

            // if a pdo exists for this port we must delete it since the
            // device may arrive agian before we get to QueryBusRelations

            if (portData->DeviceObject) {

                //
                // see if the PDO has not been started if so we can ignore
                // connect change on this port since the device will have to be
                // reset.
                //
                deviceExtensionPort =
                    portData->DeviceObject->DeviceExtension;

                if (!(deviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET)) {
                    PDEVICE_OBJECT pdo;

                    pdo = portData->DeviceObject;
                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;

                    LOGENTRY(LOG_PNP, "pd2", pdo, 0, 0);
                    // legacy flags
                    DeviceExtensionHub->HubFlags |= HUBFLAG_CHILD_DELETES_PENDING;

                    if (pdo) {
                        // place the removed PDO on our list
                        InsertTailList(&DeviceExtensionHub->DeletePdoList,
                                       &PDO_EXT(pdo)->DeletePdoLink);
                    }
                    // Prevent double free of SerialNumberBuffer in
                    // USBH_FdoQueryBusRelations.

                    sernumbuf = InterlockedExchangePointer(
                                    &deviceExtensionPort->SerialNumberBuffer,
                                    NULL);

                    if (sernumbuf) {
                        UsbhExFreePool(sernumbuf);
                    }

#ifdef EARLY_RESOURCE_RELEASE

                    //
                    // Remove the device data now to free
                    // up the bus resources.
                    //

                    deviceData = InterlockedExchangePointer(
                                    &deviceExtensionPort->DeviceData,
                                    NULL);

                    if (deviceData) {
#ifdef USB2
                        USBD_RemoveDeviceEx(DeviceExtensionHub,
                                            deviceData,
                                            DeviceExtensionHub->RootHubPdo,
                                            0);
#else
                        USBD_RemoveDevice(deviceData,
                                          DeviceExtensionHub->RootHubPdo,
                                          0);
#endif

                        USBH_SyncDisablePort(DeviceExtensionHub,
                                             PortNumber);
                    }

#endif  // EARLY_RESOURCE_RELEASE

                }
            }

            USBH_KdPrint((2,"'Notify BusCheck by FDO extension %x\n", DeviceExtensionHub));

            USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                             BusRelations);

            USBH_KdPrint((2,"'StatusIndication Conn Changed port %x\n", PortNumber));
        }


    } else if (CurrentPortState->PortChange & PORT_STATUS_RESET) {

        //
        // bit 4 RESET completed
        //

        //
        // we simply ack the change and signal the PnP thread that is
        // waiting.
        //

        USBH_KdPrint((2,"'Status Indication port reset changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_RESET;
        USBH_KdPrint((2,"'Port reset was %x is %x\n",
                hubExtensionPortState->PortStatus & PORT_STATUS_RESET, statusBit));

        // port status will not be enabled if the device failed
#if DBG
        if (!(CurrentPortState->PortStatus & PORT_STATUS_ENABLE)) {
            USBH_KdPrint((1, "'Device failed after reset\n"));
        }
#endif
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //
        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_RESET);

        //
        // Signal the PNP thread that a the reset has completed
        //
        LOGENTRY(LOG_PNP, "RESp", DeviceExtensionHub, PortNumber, 0);

    } else if (CurrentPortState->PortChange & PORT_STATUS_ENABLE) {

        //
        // ways to hit this code:
        // 1. frame babble causes the port to be disabled
        // 2. overcurrent causes a port disable



        // bit 1 port has been enabled
        USBH_KdPrint((2,"'Status Indication port enable changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_ENABLE;
        USBH_KdPrint((2,"'Port enable was %x is %x\n",
               hubExtensionPortState->PortStatus & PORT_STATUS_ENABLE,
               statusBit));

        //
        // update our record
        //
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //

        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_ENABLE);

        LOGENTRY(LOG_PNP, "ENAc", DeviceExtensionHub, PortNumber, 0);

    } else if (CurrentPortState->PortChange & PORT_STATUS_SUSPEND) {
        //
        // bit 2 suspend changed
        //

        USBH_KdPrint((2,"'Status Indication port suspend changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_SUSPEND;
        USBH_KdPrint((2,"'Port suspend was %x is %x\n",
              hubExtensionPortState->PortStatus & PORT_STATUS_SUSPEND,
              statusBit));

        //
        // update our record
        //
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //
        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_SUSPEND);

        LOGENTRY(LOG_PNP, "SUSc", DeviceExtensionHub, PortNumber, 0);

        suspendEvent = InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);

        if (suspendEvent) {

            LOGENTRY(LOG_PNP, "WAKs", DeviceExtensionHub, PortNumber, 0);
            KeSetEvent(suspendEvent,
                       1,
                       FALSE);

        }

        // Complete the WW IRP, if any, for this port.
        //
        // Note that we only want to do this for the selective suspend case
        // and not the general resume case.  (We don't want to be completing
        // port WW IRPs while the system is suspending just because someone
        // moved the mouse.)
        //
        // Note also that in our current Selective Suspend implementation,
        // this code is not really even necessary because we only suspend
        // when the entire bus can suspend, which includes the root hub,
        // and if the root hub is suspended then the bus is reawoken by
        // USBPORT completing the WW IRP for the root hub.  This code here
        // is only used if a child device indicates resume signalling while
        // the parent hub is powered and fully operational.

        USBH_ASSERT(PortNumber > 0);
        portData = &DeviceExtensionHub->PortData[PortNumber-1];
        if (portData->DeviceObject) {
            deviceExtensionPort = portData->DeviceObject->DeviceExtension;
        }

        if (deviceExtensionPort && deviceExtensionPort->IdleNotificationIrp) {

            IoAcquireCancelSpinLock(&irql);
            irp = deviceExtensionPort->WaitWakeIrp;
            deviceExtensionPort->WaitWakeIrp = NULL;
            // signal the waitwake irp if we have one
            if (irp) {

                USBH_KdPrint((1,"'Signaling WaitWake IRP (%x) (resume signalling)\n", irp));
                LOGENTRY(LOG_PNP, "rsWW", deviceExtensionPort,
                    deviceExtensionPort->DeviceState, DeviceExtensionHub->HubFlags);

                IoSetCancelRoutine(irp, NULL);

                deviceExtensionPort->PortPdoFlags &=
                    ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                pendingPortWWs =
                    InterlockedDecrement(&DeviceExtensionHub->NumberPortWakeIrps);

                if (0 == pendingPortWWs && DeviceExtensionHub->PendingWakeIrp) {
                    hubWaitWake = DeviceExtensionHub->PendingWakeIrp;
                    DeviceExtensionHub->PendingWakeIrp = NULL;
                }
                IoReleaseCancelSpinLock(irql);

                //
                // If there are no more outstanding WW irps, we need to cancel the WW
                // to the hub.
                //
                if (hubWaitWake) {
                    USBH_HubCancelWakeIrp(DeviceExtensionHub, hubWaitWake);
                }

                USBH_CompletePowerIrp(DeviceExtensionHub, irp, STATUS_SUCCESS);

            } else {
                IoReleaseCancelSpinLock(irql);
            }
        }

    } else if (CurrentPortState->PortChange & PORT_STATUS_OVER_CURRENT) {
        //
        // bit 3
        //


        USBH_KdPrint((2,"'Status Indication port over current changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_OVER_CURRENT;
        USBH_KdPrint((2,"'Port over current was %x is %x\n",
             hubExtensionPortState->PortStatus & PORT_STATUS_OVER_CURRENT,
             statusBit));

        //
        // update our record
        //
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //
        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_OVER_CURRENT);

        LOGENTRY(LOG_PNP, "OVRc", DeviceExtensionHub, PortNumber, 0);

        // The hub has reported overcurrent contion on the port, we will note
        // this for the PDO.  note that if a true overcurrent condition has occurred
        // the port should be disabled and powered off as well.

        // for some reason the NEC controller will report an overcurrent
        // condition if the MS USB mouse is plugged in during boot
        //

        if (!(hubExtensionPortState->PortStatus & PORT_STATUS_POWER)) {

            USBH_ASSERT(PortNumber > 0);
            portData = &DeviceExtensionHub->PortData[PortNumber-1];

            USBH_KdPrint((1,"'warning: overcurrent detected for port %d\n",
                PortNumber));

            USBH_SyncRefreshPortAttributes(DeviceExtensionHub);

            // ignore overcurrent on CC ports
            if (!(portData->PortAttributes &
                  USB_PORTATTR_NO_OVERCURRENT_UI)) {

                if (portData->DeviceObject != NULL) {

                    deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                    //xxx ?? IoInvalidateDeviceRelations?

                    // ignore overcurrent on CC ports
                    deviceExtensionPort->PortPdoFlags |= PORTPDO_OVERCURRENT;
                    UsbhWarning(NULL,
                               "port disabled/off due to overcurrent\n",
                                FALSE);

                    USBH_InvalidatePortDeviceState(
                            DeviceExtensionHub,
                            UsbhGetConnectionStatus(deviceExtensionPort),
                            deviceExtensionPort->PortNumber);
                 } else {
                    // NOTE: for some reason the NEC controller on Toshiba laptops
                    // does this.

                    USBH_KdPrint((1,"'warning: port has no device attached! %d\n",
                        PortNumber));

                    USBH_InvalidatePortDeviceState(
                            DeviceExtensionHub,
                            DeviceCausedOvercurrent,
                            PortNumber);
                }
            }

        }

    } else {
        LOGENTRY(LOG_PNP, "???c", DeviceExtensionHub, PortNumber, 0);
        USBH_KdBreak(("Unknown chnage bit, ignore\n"));
    }

    USBH_KdPrint((2,"'Exit ProcessPortState\n"));
}

NTSTATUS
USBH_GetNameFromPdo(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString
    )
/*++

Routine Description:

    Returns the device name for the give instance of the HCD

Arguments:

    DeviceObject -

    DeviceNameUnicodeString - ptr to unicode string to initialize
                    with device name.

Return Value:

    NT status code

--*/
{
    ULONG actualSize;
    NTSTATUS ntStatus;

    PAGED_CODE();
    ntStatus=IoGetDeviceProperty(PdoDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 0,
                                 NULL,
                                 &actualSize);

    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

        DeviceNameUnicodeString->Length=(USHORT)actualSize-sizeof(UNICODE_NULL);
        DeviceNameUnicodeString->MaximumLength=(USHORT)actualSize;
        //
        // Must use ExAllocatePool directly here because we call
        // RtlFreeUnicode string to free the buffer
        //
        DeviceNameUnicodeString->Buffer =
            ExAllocatePoolWithTag(PagedPool, actualSize, USBHUB_HEAP_TAG);
        if (!DeviceNameUnicodeString->Buffer) {
            ntStatus=STATUS_INSUFFICIENT_RESOURCES;
        } else {

            ntStatus=IoGetDeviceProperty(PdoDeviceObject,
                                         DevicePropertyPhysicalDeviceObjectName,
                                         actualSize,
                                         DeviceNameUnicodeString->Buffer,
                                         &actualSize);

            if (!NT_SUCCESS(ntStatus)) {
                ExFreePool(DeviceNameUnicodeString->Buffer);
            } else {

                // now strip off the "\Device\"
                RtlCopyMemory(DeviceNameUnicodeString->Buffer,
                              DeviceNameUnicodeString->Buffer+8,
                              actualSize-8*sizeof(WCHAR));
                DeviceNameUnicodeString->Length -= 16;
            }
        }
    } else {
        ntStatus=STATUS_INSUFFICIENT_RESOURCES;
    }

    USBH_KdPrint((2,"'USBH_GetNameFromPdo = %x\n", ntStatus));

    return(ntStatus);
}

#if 0
NTSTATUS
USBH_MakeName(
    PDEVICE_OBJECT PdoDeviceObject,
    ULONG NameLength,
    PWCHAR Name,
    PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    Creates a hub name unicode string from uncode 'Name' string passed in
    and the unique name associated with the Pdo.

Arguments:

    PdoDeviceObject - a PDO

    NameLength - length (in bytes) of 'Name' unicode string,
                including NULL.

    Name - NULL terminated unicode string suffix

Return Value:

    None

--*/
{
    UNICODE_STRING keyUnicodeString;
    NTSTATUS ntStatus;
    PWCHAR buffer;
    USHORT length;

    PAGED_CODE();
    //
    // get the name from the Pdo
    //

    ntStatus = USBH_GetNameFromPdo(PdoDeviceObject,
                                   &keyUnicodeString);


    USBH_ASSERT(NameLength > 0);

    if (NT_SUCCESS(ntStatus)) {
        // ok we have the unique name, now we
        // need to allocate a buffer big enough
        // for it plus the 'Name' string

        // keyname + prefix + NULL (Namelength includes NULL)
        length = keyUnicodeString.Length +
                (USHORT) NameLength;

        //
        // Must use normal api so that caller can use RtlFreeUnicodeString
        //

        buffer = ExAllocatePool(PagedPool, length, USBHUB_HEAP_TAG);

        if (buffer) {
            RtlCopyMemory(buffer, Name, NameLength);

            RtlInitUnicodeString(UnicodeString,
                                 buffer);

            UnicodeString->MaximumLength = length;

            USBH_ASSERT(*(buffer+((NameLength/2)-1)) == NULL);

            ntStatus = RtlAppendUnicodeStringToString(UnicodeString,
                                                      &keyUnicodeString);
            USBH_KdPrint((2,"'USBH_MakeName = key string = %x %x\n", &keyUnicodeString,
                    UnicodeString));

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            TEST_TRAP();
        }

        RtlFreeUnicodeString(&keyUnicodeString);

    }

    return ntStatus;
}

NTSTATUS
USBH_GenerateDeviceName(
    PDEVICE_OBJECT PdoDeviceObject,
    PUNICODE_STRING DeviceNameUnicodeString,
    PUNICODE_STRING DeviceLinkUnicodeString,
    PUNICODE_STRING NameUnicodeString
    )
/*++

Routine Description:

    Generates device name strings for use with IoCreateDevice and
    IoCreateSymbolicLink.

Arguments:

    PdoDeviceObject - a PDO

    DeviceNameUnicodeString

    DeviceLinkUnicodeString -

    NameUnicodeString

Return Value:

    NT Status code.

--*/
{
    WCHAR deviceLink[]  = L"\\DosDevices\\";
    WCHAR deviceName[]  = L"\\Device\\";
    WCHAR name[]  = L"";
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN gotDevname = FALSE, gotName = FALSE, gotLinkname = FALSE;

    PAGED_CODE();

    if (DeviceNameUnicodeString) {
        ntStatus = USBH_MakeName(PdoDeviceObject,
                                 sizeof(deviceName),
                                 deviceName,
                                 DeviceNameUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
            gotDevname = TRUE;
        }
    }

    if (DeviceLinkUnicodeString && NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_MakeName(PdoDeviceObject,
                                 sizeof(deviceLink),
                                 deviceLink,
                                 DeviceLinkUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
            gotLinkname = TRUE;
        }
    }

    if (NameUnicodeString && NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_MakeName(PdoDeviceObject,
                                 sizeof(name),
                                 name,
                                 NameUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
            gotName = TRUE;
        }
    }

    if (!NT_SUCCESS(ntStatus)) {

        //
        // cleanup all the strings if we fail
        //

        // an error here is most likely a bug
        USBH_KdTrap(("failed to generate Hub device name\n"));

        if (gotDevname) {
            RtlFreeUnicodeString(DeviceNameUnicodeString);
        }

        if (gotLinkname) {
            RtlFreeUnicodeString(DeviceLinkUnicodeString);
        }

        if (gotName) {
            RtlFreeUnicodeString(NameUnicodeString);
        }
    }

    USBH_KdPrint((2,"'USBH_GenerateDeviceName = %x\n", ntStatus));

    return ntStatus;
}
#endif


NTSTATUS
USBH_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject)
 /* ++ Description:
  *
  * Called whenever the hub driver is loaded to control a device.
  * Possible reasons:
  * 1. a hub was attached to the USB
  * 2. we where loaded as the generic parent for a composite device
  * 3. we were loaded as a configuring driver.
  *
  * Arguments:
  *
  * PhysicalDeviceObject - Parent device object PDO created to handle us.
  * DriverObject - Store the pointer to the object representing us.
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL, rootHubPdo = NULL, dummyPdo = NULL;
    PDEVICE_OBJECT topOfStackDeviceObject = NULL;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;  // pointer to our device
                                               // extension
    USBH_KdPrint((2,"'Enter AddDevice\n"));
    LOGENTRY(LOG_PNP, "hADD", PhysicalDeviceObject, 0, 0);

#if DBG
    USBH_GetClassGlobalDebugRegistryParameters();
#endif

    //
    // Create a new hub on the USB
    //
    //

    USBH_KdBreak(("Add Device for hub\n"));

    if (NT_SUCCESS(ntStatus)) {

        USBH_ASSERT(sizeof(DEVICE_EXTENSION_HUB) >= sizeof(DEVICE_EXTENSION_PARENT));
        ntStatus = IoCreateDevice(DriverObject,    // our driver object
                                  sizeof(DEVICE_EXTENSION_HUB), // extension size for us
                                  NULL,  // name for this device
                                  FILE_DEVICE_USB_HUB,  // HUB type
                                  FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                  FALSE,            // Not exclusive
                                  &deviceObject);   // Our device object

        if (NT_SUCCESS(ntStatus)) {

            deviceExtensionHub = (PDEVICE_EXTENSION_HUB) deviceObject->DeviceExtension;
            deviceExtensionHub->ExtensionType = EXTENSION_TYPE_HUB;
        }
    }

    if (NT_SUCCESS(ntStatus)) {
        topOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
        if (!topOfStackDeviceObject) {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(ntStatus)) {

        // Initialize the rest of the hub device extension

        deviceExtensionHub->FunctionalDeviceObject = deviceObject;
        deviceExtensionHub->PhysicalDeviceObject = PhysicalDeviceObject;

        deviceExtensionHub->TopOfStackDeviceObject = topOfStackDeviceObject;
        USBH_KdPrint((2,"'stack device object stack size = %x\n",
                deviceExtensionHub->TopOfStackDeviceObject->StackSize));

        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

#ifdef WMI_SUPPORT
        {

        PWMILIB_CONTEXT wmiLibInfo;
        extern WMIGUIDREGINFO USB_WmiGuidList[NUM_WMI_SUPPORTED_GUIDS];

        wmiLibInfo = &deviceExtensionHub->WmiLibInfo;

        wmiLibInfo->GuidCount = sizeof (USB_WmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
        ASSERT(NUM_WMI_SUPPORTED_GUIDS == wmiLibInfo->GuidCount);

        // Omit the last GUID in the list if this is not a Root Hub.

        USBH_SyncGetRootHubPdo(deviceExtensionHub->TopOfStackDeviceObject,
                               &rootHubPdo,
                               &dummyPdo,
                               NULL);

        if (rootHubPdo != PhysicalDeviceObject) {

            // Dump the last WMI GUID.
            wmiLibInfo->GuidCount--;
        }

        wmiLibInfo->GuidList = USB_WmiGuidList;
        wmiLibInfo->QueryWmiRegInfo = USBH_QueryWmiRegInfo;
        wmiLibInfo->QueryWmiDataBlock = USBH_QueryWmiDataBlock;
        wmiLibInfo->SetWmiDataBlock = USBH_SetWmiDataBlock;
        wmiLibInfo->SetWmiDataItem = NULL;
        wmiLibInfo->ExecuteWmiMethod = USBH_ExecuteWmiMethod;
        wmiLibInfo->WmiFunctionControl = NULL;

        IoWMIRegistrationControl(deviceObject,
                                 WMIREG_ACTION_REGISTER
                                 );
        }
#endif

    } else {
        // failed to create device object or symbolic link
        TEST_TRAP();
        if (deviceObject) {
            IoDeleteDevice(deviceObject);
        }
    }

    USBH_KdPrint((2,"'AddDevice return %x\n", ntStatus));

    return ntStatus;
}


#if DBG

NTSTATUS
USBH_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWCHAR usb = L"usb";
#define DEBUG_LEVEL                     L"debuglevel"
#define DEBUG_WIN9X                     L"debugWin9x"
    extern ULONG USBH_W98_Debug_Trace;

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL;
    QueryTable[0].EntryContext = &USBH_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &USBH_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(USBH_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = USBH_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X;
    QueryTable[1].EntryContext = &USBH_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &USBH_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(USBH_W98_Debug_Trace);

    //
    // Stop
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         USBH_KdPrint((1, "'Debug Trace Level Set: (%d)\n", USBH_Debug_Trace_Level));

        if (USBH_W98_Debug_Trace) {
            USBH_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            USBH_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }

        if (USBH_Debug_Trace_Level > 0) {
            ULONG UHCD_Debug_Asserts = 1;
        }
    }

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#endif

#if 0
NTSTATUS
USBH_FdoStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++ Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_START_DEVICE). We will
  * initialize the hub and ready all ports.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus;

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);
    LOGENTRY(LOG_PNP, "STRT", DeviceExtensionHub, 0, 0);

    ntStatus = USBH_FdoHubStartDevice(DeviceExtensionHub,
                                      Irp);

    return ntStatus;
}
#endif

// keep gen parent for .NET and SP1
// since we no longer use the hub as parent we will always treat
// the device as a hub

NTSTATUS
USBH_FdoStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++ Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_START_DEVICE). We will
  * initialize the hub and ready all ports.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PDEVICE_EXTENSION_PARENT parent;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter StartDevice\n"));
    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    LOGENTRY(LOG_PNP, "STRT", DeviceExtensionHub, 0, 0);
    //
    // collect some inforantion from the device, like the root hub
    // pdo for our fast-path
    //

    DeviceExtensionHub->RootHubPdo = NULL;
    ntStatus =
        USBH_SyncGetRootHubPdo(DeviceExtensionHub->TopOfStackDeviceObject,
                               &DeviceExtensionHub->RootHubPdo,
                               &DeviceExtensionHub->TopOfHcdStackDeviceObject,
                               NULL);

    if (!NT_SUCCESS(ntStatus)) {
        KeInitializeEvent(&DeviceExtensionHub->PnpStartEvent, NotificationEvent, FALSE);

        USBH_KdPrint((2,"'Set PnPIrp Completion Routine\n"));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                               USBH_HubPnPIrp_Complete,
                               // always pass FDO to completion routine
                               DeviceExtensionHub,
                               TRUE,
                               TRUE,
                               TRUE);

        status = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                              Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&DeviceExtensionHub->PnpStartEvent,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        //
        // complete the start Irp now since we pended it with
        // our completion handler.
        //

        LOGENTRY(LOG_PNP, "STR!", DeviceExtensionHub, 0, ntStatus);
        USBH_CompleteIrp(Irp, ntStatus);

    } else if (DeviceExtensionHub->RootHubPdo != NULL) {
        // stack reports a root hub PDO then this
        // is a hub
        ntStatus = USBH_FdoHubStartDevice(DeviceExtensionHub,
                                          Irp);
    } else {
        //
        // if no root hub PDO then we are being loaded
        // as a configuring parent driver.
        //

        DeviceExtensionHub->ExtensionType = EXTENSION_TYPE_PARENT;

        //
        // Initialize this parent
        //
        parent = (PDEVICE_EXTENSION_PARENT) DeviceExtensionHub;

        parent->PowerIrp = NULL;
        parent->PendingWakeIrp = NULL;
        parent->NumberFunctionWakeIrps = 0;
        parent->FunctionCount = 0;
        parent->FunctionList.Next = NULL;
        parent->ParentFlags = 0;
        parent->NeedCleanup = FALSE;
        parent->ConfigurationDescriptor = NULL;
        KeInitializeSpinLock (&parent->ParentSpinLock);

        //
        // Start it.
        //
        ntStatus = USBH_ParentFdoStartDevice(parent, Irp, TRUE);

    }

    return ntStatus;
}



VOID
USBH_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_QueryCapabilities\n"));

    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        USBH_KdTrap(("Allocate Irp failed\n"));
        return;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBH_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    USBH_ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;
    //this is different from the latest version of busdd.doc
    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    // IrpAssert: Initialize these fields in the DeviceCapabilities structure
    // before passing down.

    RtlZeroMemory(nextStack->Parameters.DeviceCapabilities.Capabilities,
        sizeof(DEVICE_CAPABILITIES));
    nextStack->Parameters.DeviceCapabilities.Capabilities->Address = -1;
    nextStack->Parameters.DeviceCapabilities.Capabilities->UINumber = -1;
    nextStack->Parameters.DeviceCapabilities.Capabilities->Version = 1;
    nextStack->Parameters.DeviceCapabilities.Capabilities->Size =
        sizeof(DEVICE_CAPABILITIES);

    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

    USBH_KdPrint((2,"'ntStatus from IoCallDriver to hub PDO = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
//        TEST_TRAP();

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdTrap(("Query capabilities failed!\n"));
    }

    IoFreeIrp(irp);
}

BOOLEAN
USBH_HubIsBusPowered(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  *     TRUE if the hub is bus powered
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT power, statusBits;
    BOOLEAN busPowered;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter HubIsBusPowered\n"));

    // read the power bits from the config descriptor
    power = ConfigurationDescriptor->bmAttributes &
                USB_CONFIG_POWERED_MASK;

    //
    // now attempt to get the status bits from the device
    //
    ntStatus = USBH_SyncGetStatus(DeviceObject,
                                  &statusBits,
                                  URB_FUNCTION_GET_STATUS_FROM_DEVICE,
                                  0);

    if (NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'hub status bits %x\n", statusBits));

        busPowered = !(statusBits & USB_GETSTATUS_SELF_POWERED);

    } else {
        USBH_KdBreak(("device failed get status %x, power bits = %x\n",
                ntStatus, power));

        //
        // device failed get_status, fall back to the values in the
        // config descriptor.
        //

        busPowered = power == USB_CONFIG_BUS_POWERED;
    }

    return busPowered;
}


NTSTATUS
USBH_PnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_FDO deviceExtension;

    USBH_KdPrint((2,"'enter USBH_PnPIrp_Complete\n"));

    deviceExtension = Context;

    // kenray sez we should be calling IoMarkIrpPending
    // from our completion routine.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBH_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    USBH_ASSERT(irpStack->MinorFunction == IRP_MN_START_DEVICE);

    USBH_KdPrint((2,"'IRP_MN_START_DEVICE (fdo), completion routine\n"));

    //bugbug this is broken but they won't let us fix it
    // signal the start device dispatch to finsh
    KeSetEvent(&deviceExtension->PnpStartEvent,
               1,
               FALSE);

    // defer completion
    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    Irp->IoStatus.Status = ntStatus;

    USBH_KdPrint((2,"'exit USH_PnPIrp_Complete %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_HubPnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;

    USBH_KdPrint((2,"'enter USBH_HubPnPIrp_Complete\n"));

    deviceExtensionHub = Context;

    // kenray sez we should be calling IoMarkIrpPending
    // from our completion routine.
    //

// No. Since this IRP is completed synchronously (on the same thread that
// created it), we should not do this.
//
//    if (Irp->PendingReturned) {
//        IoMarkIrpPending(Irp);
//    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBH_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    USBH_ASSERT(irpStack->MinorFunction == IRP_MN_START_DEVICE);

    USBH_KdPrint((2,"'IRP_MN_START_DEVICE (fdo), completion routine\n"));

    //bugbug this is broken but they won't let us fix it
    // signal the start device dispatch to finsh
    KeSetEvent(&deviceExtensionHub->PnpStartEvent,
               1,
               FALSE);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        deviceExtensionHub->HubFlags |= HUBFLAG_HUB_FAILURE;
    }
    // defer completion
    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    Irp->IoStatus.Status = ntStatus;

    USBH_KdPrint((2,"'exit USH_HubPnPIrp_Complete %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_FdoHubStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp)
 /* ++ Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_START_DEVICE). We will
  * initialize the hub and ready all ports.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS status, ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_PORT hubParentDeviceExtensionPort;
    PPORT_DATA portData;
    DEVICE_CAPABILITIES deviceCapabilities;
    ULONG hubCount = 0, p;
    LONG i;
#if DBG
    BOOLEAN bWakeSupported = FALSE;
#endif

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter Hub StartDevice\n"));
    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);
    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    //
    // New hub
    //
    LOGENTRY(LOG_PNP, "hSTR", DeviceExtensionHub, 0, 0);

    //
    // initailize allocated structures to NULL;
    //

    DeviceExtensionHub->HubDescriptor = NULL;
    DeviceExtensionHub->Irp = NULL;
    DeviceExtensionHub->TransferBuffer = NULL;
    DeviceExtensionHub->ConfigurationDescriptor = NULL;
    // transition to zero signals the event
    DeviceExtensionHub->PendingRequestCount = 1;
    DeviceExtensionHub->HubFlags = 0;
    DeviceExtensionHub->PendingWakeIrp = NULL;
    DeviceExtensionHub->NumberPortWakeIrps = 0;
    DeviceExtensionHub->PendingIdleIrp = NULL;
    DeviceExtensionHub->ChangeIndicationWorkitemPending = 0;
    // Although this is only used for the Root Hub, we initialize for all hubs.
    DeviceExtensionHub->CurrentSystemPowerState = PowerSystemWorking;

    KeInitializeEvent(&DeviceExtensionHub->PnpStartEvent, NotificationEvent, FALSE);

    KeInitializeSpinLock (&DeviceExtensionHub->CheckIdleSpinLock);
    InitializeListHead(&DeviceExtensionHub->DeletePdoList);

    USBH_KdPrint((2,"'Set PnPIrp Completion Routine\n"));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           USBH_HubPnPIrp_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionHub,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                          Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&DeviceExtensionHub->PnpStartEvent,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    DeviceExtensionHub->RootHubPdo = NULL;
    ntStatus =
        USBH_SyncGetRootHubPdo(DeviceExtensionHub->TopOfStackDeviceObject,
                               &DeviceExtensionHub->RootHubPdo,
                               &DeviceExtensionHub->TopOfHcdStackDeviceObject,
                               NULL);
    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_SyncGetRootHubPdo fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }
    // init our failreason

    USBH_WriteFailReason(
            DeviceExtensionHub->PhysicalDeviceObject,
            USBH_FAILREASON_HUB_GENERAL_FAILURE);


    if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) {

        ntStatus = STATUS_UNSUCCESSFUL;
        USBH_KdBreak(("Hub Start Failure\n"));

        goto USBH_StartDeviceDone;
    }

    // assume device supports wakeup by default
    DeviceExtensionHub->HubFlags |= HUBFLAG_SUPPORT_WAKEUP;
    {
        NTSTATUS status;
        ULONG disableWakeup = 0;
        WCHAR USBH_RemoteWakeupKey[] = L"DisableRemoteWakeup";

        status =
            USBD_GetPdoRegistryParameter(DeviceExtensionHub->PhysicalDeviceObject,
                                         &disableWakeup,
                                         sizeof(disableWakeup),
                                         USBH_RemoteWakeupKey,
                                         sizeof(USBH_RemoteWakeupKey));

        if (NT_SUCCESS(status) && disableWakeup) {
            DeviceExtensionHub->HubFlags &= ~HUBFLAG_SUPPORT_WAKEUP;
            USBH_KdPrint((1, "'Warning: remote wakeup disabled in registry\n"));
        }
    }

    DeviceExtensionHub->CurrentPowerState = PowerDeviceD0;

    KeInitializeEvent(&DeviceExtensionHub->AbortEvent, NotificationEvent,
        TRUE);

    // initial state is not signaled
    KeInitializeEvent(&DeviceExtensionHub->PendingRequestEvent, NotificationEvent,
        FALSE);

    KeInitializeEvent(&DeviceExtensionHub->SubmitIdleEvent, NotificationEvent,
        FALSE);

    // This one defaults to signalled.
    KeInitializeEvent(&DeviceExtensionHub->CWKEvent, NotificationEvent,
        TRUE);

    KeInitializeSemaphore(&DeviceExtensionHub->HubMutex, 1, 1);
    KeInitializeSemaphore(&DeviceExtensionHub->HubPortResetMutex, 1, 1);
    KeInitializeSemaphore(&DeviceExtensionHub->ResetDeviceMutex, 1, 1);

    USBH_ASSERT(DeviceExtensionHub->RootHubPdo);

    USBH_SyncGetRootHubPdo(DeviceExtensionHub->TopOfStackDeviceObject,
                           NULL,
                           NULL,
                           &hubCount);

#ifdef USB2

    ntStatus = USBHUB_GetBusInterface(DeviceExtensionHub->RootHubPdo,
                                      &DeviceExtensionHub->BusIf);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBHUB_GetBusInterface fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    ntStatus = USBHUB_GetBusInterfaceUSBDI(DeviceExtensionHub->TopOfStackDeviceObject,
                                           &DeviceExtensionHub->UsbdiBusIf);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBHUB_GetBusInterfaceUSBDI fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    USBH_InitializeUSB2Hub(DeviceExtensionHub);

#endif

    USBH_KdPrint((2,"'Hub Count is %d\n", hubCount));
    //
    // allow no more than five physical hubs plus the root
    // (7.1.16)
    //
#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_HUB_COUNT) {
        hubCount = 7;
    }
#endif
    if (hubCount > 6) {

        USBH_WriteFailReason(
            DeviceExtensionHub->PhysicalDeviceObject,
            USBH_FAILREASON_MAXHUBS_CONNECTED);

        USBH_KdPrint((1,"'StartDevice: hubs are stacked too deep (%x)\n", hubCount - 1));

        hubParentDeviceExtensionPort = DeviceExtensionHub->PhysicalDeviceObject->DeviceExtension;
        portData = &hubParentDeviceExtensionPort->DeviceExtensionHub->PortData[hubParentDeviceExtensionPort->PortNumber-1];

        portData->ConnectionStatus = DeviceHubNestedTooDeeply;
// Don't clear the hub's reference to this PDO because we will just try to
// create a new one when QDR is called and we see that there is still a device
// connected to the port.
//        portData->DeviceObject = NULL;

        // generate a WMI event so UI can inform the user
        USBH_PdoEvent(hubParentDeviceExtensionPort->DeviceExtensionHub,
                      hubParentDeviceExtensionPort->PortNumber);

        // We fail the hub here but don't return an error so that the device
        // is not removed and the UI can display an error message about it.

        HUB_FAILURE(DeviceExtensionHub);
    }

    // Initialize DeviceCapabilities structure in case USBH_QueryCapabilities
    // is unsuccessful.

    RtlZeroMemory(&deviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    USBH_QueryCapabilities(DeviceExtensionHub->TopOfStackDeviceObject,
                           &deviceCapabilities);
    //
    // save the system state mapping
    //

    for (i = 0 ; i< PowerSystemMaximum ; i++) {
        DeviceExtensionHub->DeviceState[i] = PowerDeviceD3;
    }

    RtlCopyMemory(&DeviceExtensionHub->DeviceState[0],
                  &deviceCapabilities.DeviceState[0],
                  sizeof(deviceCapabilities.DeviceState));

    DeviceExtensionHub->SystemWake = deviceCapabilities.SystemWake;
    DeviceExtensionHub->DeviceWake = deviceCapabilities.DeviceWake;

#if DBG
    USBH_KdPrint((1,"'>>>>>> Hub DeviceCaps\n"));
    USBH_KdPrint((1,"'SystemWake = (%d)\n", DeviceExtensionHub->SystemWake));
    USBH_KdPrint((1,"'DeviceWake = (D%d)\n",
        DeviceExtensionHub->DeviceWake-1));

    for (i=PowerSystemUnspecified; i< PowerSystemHibernate; i++) {

        USBH_KdPrint((1,"'Device State Map: sysstate %d = devstate 0x%x\n", i,
             DeviceExtensionHub->DeviceState[i]));
    }
    USBH_KdBreak(("'>>>>>> Hub DeviceCaps\n"));

    // Spit out message on the debugger indicating whether the Root Hub
    // will support wake, according to the mapping table.

    if (IS_ROOT_HUB(DeviceExtensionHub)) {

        USBH_KdPrint((1,"'\n\tWake support summary for USB Root Hub:\n\n"));

        if (DeviceExtensionHub->SystemWake <= PowerSystemWorking) {
            USBH_KdPrint((1,"'USB Root Hub can't wake machine because SystemWake does not support it.\n"));
        } else {
            for (i = PowerSystemSleeping1, bWakeSupported = FALSE; i <= DeviceExtensionHub->SystemWake; i++) {
                if (DeviceExtensionHub->DeviceState[i] != PowerDeviceUnspecified &&
                    DeviceExtensionHub->DeviceState[i] <= DeviceExtensionHub->DeviceWake) {

                    bWakeSupported = TRUE;
                    USBH_KdPrint((1,"'USB Root Hub can wake machine from S%x (maps to D%x).\n",
                        i - 1, DeviceExtensionHub->DeviceState[i] - 1));
                }
            }

            if (!bWakeSupported) {
                USBH_KdPrint((1,"'USB Root Hub can't wake machine because DeviceState table does not support it.\n"));
            }
        }
    }
#endif

    //
    // get our device descriptor
    //
    ntStatus = USBH_GetDeviceDescriptor(DeviceExtensionHub->FunctionalDeviceObject,
                                        &DeviceExtensionHub->DeviceDescriptor);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_GetHubDeviceDescriptor fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    ntStatus = USBH_GetConfigurationDescriptor(DeviceExtensionHub->FunctionalDeviceObject,
                                               &DeviceExtensionHub->ConfigurationDescriptor);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("Hub StartDevice USBH_GetConfigurationDescriptor fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    //
    // Get Hub specific descriptor.
    //
    // port data array allocated by this function
    //

    ntStatus = USBH_SyncGetHubDescriptor(DeviceExtensionHub);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_GetHubDescriptor fail code %x\n", ntStatus));
        goto USBH_StartDeviceDone;
    }

    if (USBH_HubIsBusPowered(DeviceExtensionHub->FunctionalDeviceObject,
                             DeviceExtensionHub->ConfigurationDescriptor)) {

        // we have 500 mA to work with
        DeviceExtensionHub->MaximumPowerPerPort = 100;

        //
        // The amount of current a bus powered hub will draw (mA)
        // should be calculated as follows:
        //
        // NumberOfExternalPorts * 100 + HubCntrolCurrent +
        // power required for embeded functions
        //
        // this value cannot exceed 500 ma, the hub config
        // descriptor should report this value but in most cases
        // does not so we set it to the worst case value to insure
        // that a bus powered hub cannot be connected to another
        // bus powered hub.

        UsbhInfo(DeviceExtensionHub);

        DeviceExtensionHub->ConfigurationDescriptor->MaxPower = 250;

    } else {
        // self powered hub can supply 500 mA per port
        DeviceExtensionHub->MaximumPowerPerPort = 500;

        UsbhInfo(DeviceExtensionHub);
    }

    USBH_KdPrint((2,"'per port power for hub = %d\n", DeviceExtensionHub->MaximumPowerPerPort));

    //
    // attempt to configure the device
    //

    ntStatus = USBH_OpenConfiguration(DeviceExtensionHub);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_OpenConfiguration fail code %x\n", ntStatus));
        goto USBH_StartDeviceDone;
    }

    // if this is a usb 2 hub

    if (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) {
        ntStatus = USBD_InitUsb2Hub(DeviceExtensionHub);
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice failed USB 2.0 init %x\n", ntStatus));
        goto USBH_StartDeviceDone;
    }

    //
    // Allocate a permanent Irp for this hub
    //

    DeviceExtensionHub->Irp =
        IoAllocateIrp(DeviceExtensionHub->FunctionalDeviceObject->StackSize, FALSE);

    USBH_KdPrint((2,"'StartDevice AllocateIrp Irp %x StackSize %d\n",
                   DeviceExtensionHub->Irp, DeviceExtensionHub->FunctionalDeviceObject->StackSize));

    if (NULL == DeviceExtensionHub->Irp) {
        USBH_KdBreak(("StartDevice failed to alloc Irp\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_StartDeviceDone;
    }

    //
    // Allocate a transfer buffer which together with the permanent Irp and
    // Urb
    // for the hub will be use to do InterruptTransfer.
    //

    DeviceExtensionHub->TransferBufferLength =
        DeviceExtensionHub->PipeInformation.MaximumPacketSize;

    DeviceExtensionHub->TransferBuffer = UsbhExAllocatePool(NonPagedPool,
                 DeviceExtensionHub->TransferBufferLength);

    if (NULL == DeviceExtensionHub->TransferBuffer) {
        USBH_KdBreak(("StartDevice fail alloc TransferBuffer\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_StartDeviceDone;
    }

    USBH_KdPrint((2,"'StartDevice TransferBuffer %x size %x\n",
                  DeviceExtensionHub->TransferBuffer,
                  DeviceExtensionHub->PipeInformation.MaximumPacketSize));

    //
    // Power on all down stream ports.
    // Be it ganged powered, individual powered or none switched
    //

    ntStatus = USBH_SyncPowerOnPorts(DeviceExtensionHub);

#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_SyncPowerOnPorts fail code %x\n", ntStatus));
    }
#endif

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_HUB) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
#endif


USBH_StartDeviceDone:

    if (NT_SUCCESS(ntStatus)) {
        //
        // So we are started.
        //

        DeviceExtensionHub->HubFlags |= HUBFLAG_NEED_CLEANUP;

        //
        // first clear any status changes the hub may be asserting
        //

        for (p=1; p<= DeviceExtensionHub->HubDescriptor->bNumberOfPorts; p++) {
            USBH_SyncClearPortStatus(DeviceExtensionHub,
                                     (USHORT)p,
                                     FEATURE_C_PORT_CONNECT);
        }

        //
        // Tell the OS that this PDO can have kids.
        //
//
// Workaround for PnP bug #406381 - RC3SS: Bluescreen failure when
//                                  installing/deinstalling communication ports
//
//===== Assigned by santoshj on 09/23/99 10:27:20 to kenray =====
// This is a race condition between IopInitializeSystemDrivers and
// IoInvalidateDeviceRelations. The real fix is too big a change at this
// stage of the product and has potential of exposing other problems. This
// problem can be solved if USBHUB does not invalidate device relations on
// every start which is redundant anyway (and also exposes this bug).
//
//        USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
//                                         BusRelations);

        //
        // Start polling the hub
        //
#ifdef NEW_START
        // establish callback to start the hub

        if (IS_ROOT_HUB(DeviceExtensionHub)) {
            USBD_RegisterRhHubCallBack(DeviceExtensionHub);
        } else {
            DeviceExtensionHub->HubFlags |= HUBFLAG_OK_TO_ENUMERATE;
            USBH_SubmitInterruptTransfer(DeviceExtensionHub);
        }

#else
        USBH_SubmitInterruptTransfer(DeviceExtensionHub);
#endif

    } else {

        //
        // clean up allocated structures
        //

        USBH_KdBreak(("USBH_FdoStartDevice_Error\n"));
        LOGENTRY(LOG_PNP, "STR!", DeviceExtensionHub, 0, 0);

        if (DeviceExtensionHub->HubDescriptor) {
            UsbhExFreePool(DeviceExtensionHub->HubDescriptor);
            DeviceExtensionHub->HubDescriptor = NULL;
        }
        if (DeviceExtensionHub->Irp) {
            IoFreeIrp(DeviceExtensionHub->Irp);
            DeviceExtensionHub->Irp = NULL;
        }
        if (DeviceExtensionHub->TransferBuffer) {
            UsbhExFreePool(DeviceExtensionHub->TransferBuffer);
            DeviceExtensionHub->TransferBuffer = NULL;
        }
        if (DeviceExtensionHub->ConfigurationDescriptor) {
            UsbhExFreePool(DeviceExtensionHub->ConfigurationDescriptor);
            DeviceExtensionHub->ConfigurationDescriptor = NULL;
        }

    }

    //
    // complete the start Irp now since we pended it with
    // our completion handler.
    //

    LOGENTRY(LOG_PNP, "STRc", DeviceExtensionHub, 0, ntStatus);
    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


VOID
UsbhFdoCleanup(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This routine is called to shut down the hub.
  *
  * All we do here is abort or pending interrupt transfer and wait for it to
  * complete and fre up memeory resources
  *
  * Argument:
  *
  * DeviceExtensionHub - This is a a hub device extension.
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;
    USHORT p, numberOfPorts;
    KIRQL irql;
    PIRP wWIrp = NULL;
    PIRP hubIdleIrp = NULL;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;
    PVOID deviceData;
    NTSTATUS status, ntStatus;
    BOOLEAN bRet;

    // Can't acquire (cancel) spin locks in paged code!
    // TODO:  isolate the pieces of code that require the spin lock into helper
    // functions
    // PAGED_CODE();
    USBH_KdPrint((2,"'UsbhFdoCleanup Fdo extension %x\n", DeviceExtensionHub));

    LOGENTRY(LOG_PNP, "fdoC", DeviceExtensionHub,0,
        DeviceExtensionHub->HubFlags);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    USBD_UnRegisterRhHubCallBack(DeviceExtensionHub);

    //
    // set our stop flag so that ChangeIndication does not submit
    // any more transfers or queue more workitems, important to do
    // this before we send the abort.
    //

    DeviceExtensionHub->HubFlags |= HUBFLAG_DEVICE_STOPPING;


    // If there is a ChangeIndicationWorkitem pending, then we
    // must wait for that to complete.

    if (DeviceExtensionHub->ChangeIndicationWorkitemPending) {

        USBH_KdPrint((2,"'Wait for single object\n"));


        ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->CWKEvent,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    LOGENTRY(LOG_PNP, "fdoX", DeviceExtensionHub, deviceObject,
        DeviceExtensionHub->HubFlags);

    // wait for any idle irps to be submitted before attepting to cancel
    if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        LOGENTRY(LOG_PNP, "fdIW", DeviceExtensionHub,0,
            DeviceExtensionHub->HubFlags);

        ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->SubmitIdleEvent,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    //
    // dump our wake request
    //
    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionHub->PendingWakeIrp) {
        LOGENTRY(LOG_PNP, "CwkI", DeviceExtensionHub, 0,
            DeviceExtensionHub->PendingWakeIrp);
        USBH_ASSERT(DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP);

        wWIrp = DeviceExtensionHub->PendingWakeIrp;
        DeviceExtensionHub->PendingWakeIrp = NULL;
    }

    if (DeviceExtensionHub->PendingIdleIrp) {
        hubIdleIrp = DeviceExtensionHub->PendingIdleIrp;
        DeviceExtensionHub->PendingIdleIrp = NULL;
    }

    IoReleaseCancelSpinLock(irql);

    if (wWIrp) {
        USBH_HubCancelWakeIrp(DeviceExtensionHub, wWIrp);
    }

    USBH_HubCompletePortWakeIrps(DeviceExtensionHub, STATUS_DELETE_PENDING);

    if (hubIdleIrp) {
        USBH_HubCancelIdleIrp(DeviceExtensionHub, hubIdleIrp);
    }

    //
    // wait for all work items to finish...
    //  the event is not signaled if a work item is pending
    //
    // this code takes care of work items that may have been queued
    // before the ShutDown flag was set.
    // note: no additional work items will be queued once the
    // HUBFLAG_DEVICE_STOPPING flag is set.
    //

    if (InterlockedDecrement(&DeviceExtensionHub->PendingRequestCount) > 0) {
        //
        // need to wait
        //

        LOGENTRY(LOG_PNP, "hWAT", DeviceExtensionHub,
            &DeviceExtensionHub->PendingRequestEvent,
            DeviceExtensionHub->PendingRequestCount);

        status = KeWaitForSingleObject(
                       &DeviceExtensionHub->PendingRequestEvent,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        LOGENTRY(LOG_PNP, "hwat", DeviceExtensionHub,
            &DeviceExtensionHub->PendingRequestEvent,
            DeviceExtensionHub->PendingRequestCount);

    }

    USBH_KdPrint((2,"'Work Items Finished %x\n", DeviceExtensionHub));

    USBH_ASSERT(DeviceExtensionHub->PendingRequestCount == 0);

    //
    // now cancel any outstanding transfers
    //

    if (DeviceExtensionHub->Irp) {

        status = USBH_AbortInterruptPipe(DeviceExtensionHub);

        // If the ABORT_PIPE request failed then we should cancel
        // the Interrupt IRP before freeing it, otherwise we are likely
        // freeing the IRP while it is still in use.

        if (!NT_SUCCESS(status)) {
            bRet = IoCancelIrp(DeviceExtensionHub->Irp);

            // Only wait on the abort event if the IRP was actually
            // cancelled.

            if (bRet) {
            LOGENTRY(LOG_PNP, "aWAT", DeviceExtensionHub,
                    &DeviceExtensionHub->AbortEvent,  0);

            status = KeWaitForSingleObject(
                       &DeviceExtensionHub->AbortEvent,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
            }
        }

        IoFreeIrp(DeviceExtensionHub->Irp);
        DeviceExtensionHub->Irp = NULL;
    }

    USBH_KdPrint((2,"'Abort Finished %x\n", DeviceExtensionHub));

    //
    // disable the ports in case we are re-started
    //
    USBH_ASSERT(DeviceExtensionHub->HubDescriptor != NULL);
    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
    portData = DeviceExtensionHub->PortData;

    if (portData) {
        for (p = 1;
             p <= numberOfPorts;
             p++, portData++) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            //
            // do this after we abort are interrupt pipe,
            // it doesn't matter if it fails.
            //

            LOGENTRY(LOG_PNP, "offP", DeviceExtensionHub,
                p,  portData->DeviceObject);

            //
            // check our PDOs -- if this is a remove then we should have
            // none -- otherwise this is a stop.
            //

            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;

                //
                // it is possible that the PDO was never actually started
                // if this is the case then the PDO won't be marked for reset
                // we mark it here and free up the associated bus resources

                IoAcquireCancelSpinLock(&irql);

                if (deviceExtensionPort->IdleNotificationIrp) {
                    idleIrp = deviceExtensionPort->IdleNotificationIrp;
                    deviceExtensionPort->IdleNotificationIrp = NULL;
                    deviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

                    if (idleIrp->Cancel) {
                        idleIrp = NULL;
                    }

                    if (idleIrp) {
                        IoSetCancelRoutine(idleIrp, NULL);
                    }
                }

                if (deviceExtensionPort->WaitWakeIrp) {

                    waitWakeIrp = deviceExtensionPort->WaitWakeIrp;
                    deviceExtensionPort->WaitWakeIrp = NULL;
                    deviceExtensionPort->PortPdoFlags &=
                        ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                    if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                        waitWakeIrp = NULL;

                        // Must decrement pending request count here because
                        // we don't complete the IRP below and USBH_WaitWakeCancel
                        // won't either because we have cleared the IRP pointer
                        // in the device extension above.

                        USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
                    }

                    UsbhWarning(deviceExtensionPort,
                    "Device Driver did not cancel wait_wake irp on stop/remove\n",
                    FALSE);
                }

                //
                // Finally, release the cancel spin lock
                //
                IoReleaseCancelSpinLock(irql);

                if (idleIrp) {
                    idleIrp->IoStatus.Status = STATUS_CANCELLED;
                    IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
                }

                if (waitWakeIrp) {
                    USBH_CompletePowerIrp(DeviceExtensionHub, waitWakeIrp,
                        STATUS_CANCELLED);
                }

                if (!(deviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET)) {
                    USBH_KdPrint((1,
                        "'do %x was never started, marking for reset\n",
                            portData->DeviceObject));

                    deviceData = InterlockedExchangePointer(
                                    &deviceExtensionPort->DeviceData,
                                    NULL);

                    if (deviceData) {
#ifdef USB2
                       USBD_RemoveDeviceEx(DeviceExtensionHub,
                                           deviceData,
                                           deviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                           0);
#else
                       USBD_RemoveDevice(deviceData,
                                         deviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                         0);
#endif
                    }

                    deviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
                }
            }

            USBH_SyncDisablePort(DeviceExtensionHub, p);
        }
    }

    //
    // Clean up buffers
    //

    if (DeviceExtensionHub->TransferBuffer) {
        UsbhExFreePool(DeviceExtensionHub->TransferBuffer);
    }

    if (DeviceExtensionHub->HubDescriptor) {
        UsbhExFreePool(DeviceExtensionHub->HubDescriptor);
    }

    if (DeviceExtensionHub->ConfigurationDescriptor) {
        UsbhExFreePool(DeviceExtensionHub->ConfigurationDescriptor);
    }

    //
    // NOTE: we do not free the per port data (PortData) because
    // we will need it if we start up agian
    //

    DeviceExtensionHub->TransferBuffer = NULL;
    DeviceExtensionHub->Irp = NULL;
    DeviceExtensionHub->ConfigurationDescriptor =
        (PVOID) DeviceExtensionHub->HubDescriptor = NULL;

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_NEED_CLEANUP;

    return;
}


NTSTATUS
USBH_FdoStopDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_STOP_DEVICE).
  *
  * Argument:
  *
  * DeviceExtensionHub -
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    NTSTATUS ntStatus;

    PAGED_CODE();
    USBH_KdPrint((2,"'FdoStopDevice Fdo extension %x\n", DeviceExtensionHub));

    LOGENTRY(LOG_PNP, "hSTP", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);

    // walk thru our list of PDOs and verify that stop was passed down
    // for each one
    {
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    portData = DeviceExtensionHub->PortData;

    // NOTE:
    // if we get a stop as a result of an error during stop
    // then we may not have allocated portdata or a HubDescriptor

    if (portData &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (nextPortNumber = 1;
             nextPortNumber <= numberOfPorts;
             nextPortNumber++, portData++) {

            LOGENTRY(LOG_PNP, "chkS", DeviceExtensionHub,
                nextPortNumber,  portData->DeviceObject);

            USBH_KdPrint((2,"'portdata %x, do %x\n", portData, portData->DeviceObject));

            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                //
                // port is still started, print a warning
                //
                LOGENTRY(LOG_PNP, "chk1", DeviceExtensionHub,
                    nextPortNumber,  deviceExtensionPort->PortPdoFlags);

                if (deviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) {
                    USBH_KdPrint((1,
                        "'client driver failed to pass the stop IRP\n"));

                    // remove it now
                    USBH_PdoStopDevice(deviceExtensionPort, Irp);
                }
            }
        }
    }
    }


    if (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP) {
        (VOID) UsbhFdoCleanup(DeviceExtensionHub);
    }

    //
    // note that some hub structures are free at this point
    //

    if (DeviceExtensionHub->Configuration) {
        (VOID) USBH_CloseConfiguration((PDEVICE_EXTENSION_FDO) DeviceExtensionHub);
        DeviceExtensionHub->Configuration = NULL;
    }

    // note that we are stopped
    DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_STOPPED;

    //
    // And we need to pass this message on to lower level driver
    //
    ntStatus = USBH_PassIrp(Irp,
                            DeviceExtensionHub->TopOfStackDeviceObject);

    return ntStatus;
}


VOID
USBH_FdoSurpriseRemoveDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Handle surprise remove.  If we get a surprise remove then PnP will know
  * that all of our children are gone (same as a QBR) and remove them before
  * removing us.
  * Therefore we mark the devices as no longer present so that we process the
  * remove properly when we get if for the PDO
  *
  * Argument:
  *
  * DeviceExtensionHub - This is a hub device extension. pIrp - the request
  *
  * Return:
  *
  * This call is non-falable, no status is returned
  * -- */
{
    PPORT_DATA pd;
    USHORT portNumber;
    USHORT numberOfPorts;

    pd = DeviceExtensionHub->PortData;

    if (pd &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (portNumber = 1;
             portNumber <= numberOfPorts;
             portNumber++, pd++) {

            LOGENTRY(LOG_PNP, "chsX", DeviceExtensionHub,
                portNumber,  pd->DeviceObject);

            USBH_KdPrint((2,"'portdata %x, do %x\n", pd, pd->DeviceObject));

            if (pd->DeviceObject != NULL) {
                LOGENTRY(LOG_PNP, "chs", DeviceExtensionHub,
                    portNumber,  PDO_EXT(pd->DeviceObject));

                // we no longer track this device, it is gone
                //
                PDO_EXT(pd->DeviceObject)->PortPdoFlags |= PORTPDO_DELETE_PENDING;
                PDO_EXT(pd->DeviceObject)->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;

                pd->DeviceObject = NULL;
                pd->ConnectionStatus = NoDeviceConnected;

                // note that we leave the device handle in the port extension
                // this will be removed when the remove_device meassage is
                // processed for the PDO
            }
        }
    } else {
        // I would like to  know the circumstances where
        // either of these are NULL
        TEST_TRAP();
    }

}



NTSTATUS
USBH_FdoRemoveDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE).
  *
  * Argument:
  *
  * DeviceExtensionHub - This is a hub device extension. pIrp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();
    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;
    USBH_KdPrint((2,"'FdoRemoveDevice Fdo %x\n", deviceObject));
    LOGENTRY(LOG_PNP, "hREM", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);

    // walk thru our list of PDOs and verify that remove was passed down
    // for each one
    {
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    portData = DeviceExtensionHub->PortData;

    //
    // hub descriptor will be null if the hub is already stopped
    //

    if (portData &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (nextPortNumber = 1;
             nextPortNumber <= numberOfPorts;
             nextPortNumber++, portData++) {

            LOGENTRY(LOG_PNP, "chkX", DeviceExtensionHub,
                nextPortNumber,  portData->DeviceObject);

            USBH_KdPrint((2,"'portdata %x, do %x\n", portData, portData->DeviceObject));

            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                //
                // port is still started, print a warning
                //

                // vinma, jdunn:
                // there is one legitimate case for this code being hit.
                // If the hub FDO is being removed the the child devices are
                // still present (like during setup). The child PDOs may or may
                // not have been sent a remove by PNP.
                //
                // In the case of setup PnP sends the remove to the children
                // then to the FDO.
                //
                // In the case of a surprise remove for the hub the child PDOs
                // are marked NOT 'PDO_PNPFLAG_DEVICE_PRESENT' when the
                // IRP_MN_SURPRISE_REMOVE is handled.
                //

                LOGENTRY(LOG_PNP, "chk2", DeviceExtensionHub,
                    nextPortNumber,  deviceExtensionPort->PortPdoFlags);

                // device is considered gone
                portData->DeviceObject = NULL;
                portData->ConnectionStatus = NoDeviceConnected;

                // this will cause the PDO to be deleted
                deviceExtensionPort->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;

                // if the parent receives a remove IRP,
                // it subsequently deletes its children.
                USBH_PdoRemoveDevice(deviceExtensionPort,
                                     DeviceExtensionHub,
                                     Irp);

            }
        }
    }
    }

    //
    // see if we need cleanup
    //
    if (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP) {
        UsbhFdoCleanup(DeviceExtensionHub);
    }

    //
    // free the per port data now
    //
    if (DeviceExtensionHub->PortData) {
        UsbhExFreePool(DeviceExtensionHub->PortData);
        DeviceExtensionHub->PortData = NULL;
    }


#ifdef WMI_SUPPORT
    // de-register with WMI
    IoWMIRegistrationControl(deviceObject,
                             WMIREG_ACTION_DEREGISTER);

#endif

    //
    // And we need to pass this message on to lower level driver
    //

    ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->TopOfStackDeviceObject);

    //
    // Detach FDO from PDO
    //
    IoDetachDevice(DeviceExtensionHub->TopOfStackDeviceObject);

    // delete FDO
    LOGENTRY(LOG_PNP, "hXXX", DeviceExtensionHub, 0, 0);

    IoDeleteDevice(deviceObject);

    return ntStatus;
}


BOOLEAN
USBH_DeviceIs2xDualMode(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  * This function determines if the device is a 2.x compliant dual-mode device.
  *
  * Arguments:
  *
  * DeviceExtensionPort
  *
  * Return:
  *
  * BOOLEAN indicating whether the given device is a 2.x compliant dual-mode
  * device or not.
  *
  * -- */
{
    USB_DEVICE_QUALIFIER_DESCRIPTOR DeviceQualifierDescriptor;
    NTSTATUS ntStatus;
    BOOLEAN bDeviceIs2xDualMode = FALSE;

    if (DeviceExtensionPort->DeviceDescriptor.bcdUSB >= 0x0200) {

        ntStatus = USBH_GetDeviceQualifierDescriptor(
                        DeviceExtensionPort->PortPhysicalDeviceObject,
                        &DeviceQualifierDescriptor);

        if (NT_SUCCESS(ntStatus) &&
            DeviceQualifierDescriptor.bcdUSB >= 0x0200) {

            bDeviceIs2xDualMode = TRUE;
        }
    }

    return bDeviceIs2xDualMode;
}


PDEVICE_EXTENSION_HUB
USBH_GetRootHubDevExt(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function gets the DevExt for the RootHub upstream of the given
  * DeviceExtensionHub
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * DeviceExtensionHub for the RootHub FDO.
  *
  * -- */
{
    PDEVICE_OBJECT rootHubPdo, rootHubFdo;
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    PDRIVER_OBJECT hubDriver;

    hubDriver = DeviceExtensionHub->FunctionalDeviceObject->DriverObject;

    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        rootHubDevExt = DeviceExtensionHub;
    } else {
        rootHubPdo = DeviceExtensionHub->RootHubPdo;
        do {
            rootHubFdo = rootHubPdo->AttachedDevice;
            rootHubPdo = rootHubFdo;
        } while (rootHubFdo->DriverObject != hubDriver);

        rootHubDevExt = rootHubFdo->DeviceExtension;
    }

    USBH_ASSERT(rootHubDevExt &&
                rootHubDevExt->ExtensionType == EXTENSION_TYPE_HUB);

    return rootHubDevExt;
}


NTSTATUS
USBH_FdoQueryBusRelations(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to Bus_Reference_Next_Device, Bus_Query_Bus_Check,
  * //Bus_Query_Id: Bus_Id, HardwareIDs, CompatibleIDs and InstanceID.
  *
  * Arguments:
  *
  * DeviceExtensionHub - should be the FDO we created for ourselves pIrp - the
  * Irp
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION ioStack;
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    //BOOLEAN IsLowSpeed;
    USHORT portStatus;
    PDEVICE_RELATIONS deviceRelations = NULL;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PWCHAR sernumbuf;
#ifdef EARLY_RESOURCE_RELEASE
    PVOID deviceData;
#endif

    PAGED_CODE();

    USBH_KdPrint((1, "'Query Bus Relations (HUB) %x\n",
        DeviceExtensionHub->PhysicalDeviceObject));
    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'FdoQueryBusRelations %x\n", ioStack->Parameters.QueryDeviceRelations.Type));
    LOGENTRY(LOG_PNP, "QBR+", DeviceExtensionHub, 0, 0);

    USBH_ASSERT(ioStack->Parameters.QueryDeviceRelations.Type == BusRelations);

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        // Hub device has not been started yet.  Fail the IRP.

        UsbhWarning(NULL,
                   "Hub device not started in FdoQueryBusRelations\n",
                    FALSE);

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto USBH_FdoQueryBusRelations_Done2;
    }

    if (!DeviceExtensionHub->HubDescriptor) {
        // Sometimes HubDescriptor is NULL when running Test's
        // "Rebalance" test.

        UsbhWarning(NULL,
                   "NULL HubDescriptor in FdoQueryBusRelations\n",
                    FALSE);

        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBH_FdoQueryBusRelations_Done2;
    }

    USBH_KdPrint((2,"'FdoQueryBusRelations enumerate device\n"));
#ifdef NEW_START
    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_OK_TO_ENUMERATE)) {

        USBH_KdPrint((1,"'Defer enumeration\n"));


        ntStatus = STATUS_SUCCESS;
        goto USBH_FdoQueryBusRelations_Done2;
    }
#endif

    //
    // It should be Function device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    // Sometimes during rebalance we will receive a QBR for a hub while one
    // of the devices attached to hub is being restored.  This will cause us to
    // toss the PDO for that port because GetPortStatus for that port will show
    // that there is no device connected.  So, we synchronize with ResetDevice
    // here.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    deviceRelations = ExAllocatePoolWithTag(
        PagedPool, sizeof(*deviceRelations) + (numberOfPorts - 1) *
        sizeof(PDEVICE_OBJECT), USBHUB_HEAP_TAG);

    if (deviceRelations == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_FdoQueryBusRelations_Done;
    }

USBH_FdoQueryBusRelations_Start:

    deviceRelations->Count = 0;

    if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_HAS_LOST_BRAINS) {

        // If we are trying to recover from ESD failure, then just tell PnP
        // that there are no devices.

        USBH_KdPrint((1,"'FdoQueryBusRelations: ESD recovery, returning no devices\n"));

        ntStatus = STATUS_SUCCESS;
        goto USBH_FdoQueryBusRelations_Done;
    }

    // Allow selective suspend once again if we were suppressing it waiting
    // for post-ESD enumeration to occur.

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_POST_ESD_ENUM_PENDING;

    //
    // This is the first call for enumeration
    //
    //
    // Find a ready device on our ports
    //

    portData = DeviceExtensionHub->PortData;
    for (nextPortNumber = 1;
         nextPortNumber <= numberOfPorts;
         nextPortNumber++, portData++) {

        //
        // This query is redundant since we go here due to a change
        // indication from the hub, however since we check all
        // ports it will allow us to process another change may occur after
        // the first one but before we get to this routine.

        DBG_ONLY(USBH_ShowPortState( nextPortNumber,
                                     &portData->PortState));

        //
        // don't bother to query the hub if it has failed
        //
        if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE)) {
            ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                              nextPortNumber,
                                              (PUCHAR) &portData->PortState,
                                              sizeof(portData->PortState));

            LOGENTRY(LOG_PNP, "nwPS", nextPortNumber,
                portData->PortState.PortStatus,
                portData->PortState.PortChange);

            if (NT_SUCCESS(ntStatus)) {
                //
                // mark the port status as connected if we show
                // overcurrent on this port, this will prevent us
                // from tossing the PDO.
                // Since the port is powered off we can't really
                // know if anything is connected.
                //

                if (portData->DeviceObject) {

                    deviceExtensionPort =
                        portData->DeviceObject->DeviceExtension;

                    if (deviceExtensionPort->PortPdoFlags &
                         PORTPDO_OVERCURRENT) {

                        LOGENTRY(LOG_PNP, "mOVR", deviceExtensionPort, 0, 0);
                        portData->PortState.PortStatus |= PORT_STATUS_CONNECT;
                    } else if (!(deviceExtensionPort->PortPdoFlags &
                                 PORTPDO_DELETE_PENDING)) {
//                      We now handle resetting ConnectionStatus in
//                      USBH_ResetPortOvercurrent.
//                        portData->ConnectionStatus = DeviceConnected;
                        USBH_ASSERT(portData->ConnectionStatus != NoDeviceConnected);
                    }
                }
            } else {
                //
                // NOTE (Doron Holan, 12/21/00):
                // Setting the failure bit here will mean that ntStatus will not
                // be touched again until the loop has exited and this function
                // will complete this request with an error.
                //
                // Perhaps it would be more clear if we broke out of the loop
                // here instead of starting over.
                //
                USBH_KdPrint((2,"'SyncGetPortStatus failed %x\n", ntStatus));
                HUB_FAILURE(DeviceExtensionHub);

                goto USBH_FdoQueryBusRelations_Start;
            }

            DBG_ONLY(USBH_ShowPortState( nextPortNumber,
                                         &portData->PortState));
        }

        //
        // do we have a device on this port?
        //
        if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) {
            // if the hub has failed just return what we know about
            deviceObject = portData->DeviceObject;
        } else if (portData->PortState.PortStatus & PORT_STATUS_CONNECT) {
            // Yes,
            // did we already know about this device?

            //
            // check to see if the pdo is an orphan, if so toss the PDO
            //

            deviceObject = portData->DeviceObject;

            if (portData->DeviceObject) {
                // Yes,
                // return the old PDO
                deviceObject = portData->DeviceObject;
                ObReferenceObject(deviceObject);
                deviceObject->Flags |= DO_POWER_PAGABLE;
                deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                deviceRelations->Objects[deviceRelations->Count] = deviceObject;
                deviceRelations->Count++;

                deviceExtensionPort = deviceObject->DeviceExtension;
                deviceExtensionPort->PortPdoFlags &= ~PORTPDO_USB_SUSPEND;

                LOGENTRY(LOG_PNP, "PDO1", DeviceExtensionHub, deviceObject
                        , deviceRelations->Count);

                USBH_KdPrint((2,"'DoBusExtension Enum Return old device on port %x PDO=%x\n", \
                              nextPortNumber, portData->DeviceObject));

            } else {
                NTSTATUS status;
                // No
                // This means we have a new device on the bus

                //
                // wait 100ms  for port device power to stablize before
                // we assert Reset.
                //
                UsbhWait(100);

                // USB 1.1 make sure we get speed of device after reset
                status = USBH_SyncResetPort(DeviceExtensionHub, nextPortNumber);

                // failure of reset is normal on USB 2.0 so we must ignore it.
                if ((DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) &&
                    !NT_SUCCESS(status)) {

                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;

                    continue;
                }

                if (NT_SUCCESS(status)) {
                    // get the speed of the device

                    status = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                                    nextPortNumber,
                                                    (PUCHAR) &portData->PortState,
                                                     sizeof(portData->PortState));

                    LOGENTRY(LOG_PNP, "gps1", nextPortNumber,
                        portData->PortState.PortChange,
                        portData->PortState.PortStatus);

//                    createDevice now figures out if it is low speed
//                    IsLowSpeed = (portData->PortState.PortStatus &
//                                   PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;

                    portStatus = portData->PortState.PortStatus;
                }


                if (NT_SUCCESS(status)) {

                    ULONG count = 0;

                    // reset completed
                    //
                    // A successful return has the PortData->DeviceObject set
                    //

                    //
                    // we will make three attempts to enumerate this device
                    //
                    for(;;) {

                        status = USBH_CreateDevice(DeviceExtensionHub,
                                                   nextPortNumber,
                                                   portStatus,
                                                   count);

                        if (!NT_SUCCESS(status)) {

                            count++;
                            USBH_KdPrint((1,"'Enumeration Failed count = %d, %x\n",
                                count, status));
#if DBG
                            if (count == 1) {
                                UsbhWarning(NULL,
                                            "USB device failed first enumeration attempt\n",
                                            (BOOLEAN)((USBH_Debug_Trace_Level >= 3) ? TRUE : FALSE));

                            }
#endif
                            UsbhWait(500);

                            if (count >= USBH_MAX_ENUMERATION_ATTEMPTS) {
                                USBH_KdBreak(("Max tries exceeded\n"));
                                break;
                            }

                            if (portData->DeviceObject) {
                                //
                                // clean up the device object we created
                                //
                                IoDeleteDevice(portData->DeviceObject);
                                portData->DeviceObject = NULL;
                                portData->ConnectionStatus = NoDeviceConnected;

                            }

                            //
                            // enumeration failed, reset the port and try again
                            //
                            USBH_SyncResetPort(DeviceExtensionHub, nextPortNumber);

                        } else {
                            // enumeration success

                            // If this is a high-speed capable 2.x device
                            // connected to a legacy 1.x hub, then inform
                            // the UI.

                            if (portData->DeviceObject) {

                                deviceExtensionPort =
                                    portData->DeviceObject->DeviceExtension;

                                if (!(deviceExtensionPort->PortPdoFlags &
                                     PORTPDO_LOW_SPEED_DEVICE) &&
                                    !(deviceExtensionPort->PortPdoFlags &
                                     PORTPDO_HIGH_SPEED_DEVICE) &&
                                    !(DeviceExtensionHub->HubFlags &
                                      HUBFLAG_USB20_HUB)) {

                                    // We have a device in full-speed mode
                                    // connected to a 1.x hub.  Determine if
                                    // the device is high-speed capable.

                                    if (USBH_DeviceIs2xDualMode(deviceExtensionPort)) {

                                        deviceExtensionPort->PortPdoFlags |=
                                            PORTPDO_USB20_DEVICE_IN_LEGACY_HUB;

                                        USBH_KdPrint((1,"'USB 2.x dual-mode device connected to legacy hub (%x)\n", deviceExtensionPort));

                                        // Generate a WMI event so UI can inform
                                        // the user.
                                        USBH_PdoEvent(DeviceExtensionHub,
                                                      nextPortNumber);
                                    }
                                }
                            }
                            break;
                        }
                    }
                } else {
                    // unable to reset the port

#if DBG
                    USBH_SyncGetPortStatus(DeviceExtensionHub,
                                           nextPortNumber,
                                           (PUCHAR) &portData->PortState,
                                           sizeof(portData->PortState));

                    LOGENTRY(LOG_PNP, "gps2", nextPortNumber,
                        portData->PortState.PortChange,
                        portData->PortState.PortStatus);
#endif

                    // we will assume this is due to a jittery
                    // connection
                    USBH_KdPrint((0,"'Unable to reset port %d\n",
                              nextPortNumber));
                }

                if (NT_SUCCESS(status)) {
                    //
                    // A successful return from CreateDevice the
                    // PortData->DeviceObject
                    // set.
                    //
                    USBH_ASSERT(portData->DeviceObject != NULL);
                    deviceObject = portData->DeviceObject;
                    ObReferenceObject(deviceObject);
                    deviceRelations->Objects[deviceRelations->Count] = deviceObject;
                    deviceObject->Flags |= DO_POWER_PAGABLE;
                    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                    deviceRelations->Count++;

                    deviceExtensionPort = deviceObject->DeviceExtension;
                    portData->ConnectionStatus = DeviceConnected;

                    LOGENTRY(LOG_PNP, "PDO2", DeviceExtensionHub, deviceObject
                        , deviceRelations->Count);

                    USBH_KdPrint((2,"'DoBusExtension Enum Return device on port %x\n",
                        nextPortNumber));
                } else {
                    USBH_KdBreak(("ResetPort or CreateDevice failed, disable port\n"));

                    UsbhWarning(NULL,
                                "Device Failed Enumeration\n",
                                FALSE);

                    portData->ConnectionStatus = DeviceFailedEnumeration;

                    // generate a WMI event so UI can inform the user
                    USBH_PdoEvent(DeviceExtensionHub, nextPortNumber);

                    // failed to initialize the device
                    // disable the port here.
                    status = USBH_SyncDisablePort(DeviceExtensionHub,
                                nextPortNumber);

                    if (NT_ERROR(status)) {
                        HUB_FAILURE(DeviceExtensionHub);
                    }

                    //
                    // return the deviceObject even for errors
                    // so that PnP knows there is something on the
                    // bus.
                    //

                    deviceObject = portData->DeviceObject;
                    //
                    // NOTE: we won't have a device object if we failed to reset
                    // the port
                    //
                    if (deviceObject) {
                        ObReferenceObject(deviceObject);
                        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                        deviceRelations->Objects[deviceRelations->Count] = deviceObject;
                        deviceRelations->Count++;
                        deviceExtensionPort = deviceObject->DeviceExtension;


                        LOGENTRY(LOG_PNP, "PDO3", DeviceExtensionHub, deviceObject
                        , deviceRelations->Count);
                    }
                }
            }
        } else {
            //
            // No,
            // There is no device on this port now
            //

            // if there was a device here mark the PDO as delete pending
            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                deviceExtensionPort->PortPdoFlags |= PORTPDO_DELETE_PENDING;

                // pnp will no longer see this device as present
                deviceExtensionPort->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;

                // Prevent double free of SerialNumberBuffer in
                // USBH_ProcessPortStateChange.

                sernumbuf = InterlockedExchangePointer(
                                &deviceExtensionPort->SerialNumberBuffer,
                                NULL);

                if (sernumbuf) {
                    UsbhExFreePool(sernumbuf);
                }

#ifdef EARLY_RESOURCE_RELEASE

                //
                // Remove the device data now to free
                // up the bus resources.
                //

                deviceData = InterlockedExchangePointer(
                                &deviceExtensionPort->DeviceData,
                                NULL);

                if (deviceData) {
#ifdef USB2
                    USBD_RemoveDeviceEx(DeviceExtensionHub,
                                        deviceData,
                                        DeviceExtensionHub->RootHubPdo,
                                        0);
#else
                    USBD_RemoveDevice(deviceData,
                                      DeviceExtensionHub->RootHubPdo,
                                      0);
#endif

                    USBH_SyncDisablePort(DeviceExtensionHub,
                                         nextPortNumber);
                }

#endif // EARLY_RESOURCE_RELEASE

            }

            // indicate no device
            portData->DeviceObject = NULL;
            portData->ConnectionStatus = NoDeviceConnected;
        }
    }                           /* for */

USBH_FdoQueryBusRelations_Done:
    LOGENTRY(LOG_PNP, "QBR-", DeviceExtensionHub, 0, 0);

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

USBH_FdoQueryBusRelations_Done2:

    Irp->IoStatus.Status = ntStatus;

    if (NT_SUCCESS(ntStatus)) {
        USHORT p, n=0, c=0;
        PPORT_DATA pd;

        // we may return NULL relations on success
        if (deviceRelations != NULL &&
            deviceRelations->Count) {

            USBH_KdPrint((1, "'Query Bus Relations (HUB) %x passed on\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            // we have crafted device relations, set the PnP flags
            // to indicate that PnP now knows about these PDOs
            if (DeviceExtensionHub->HubDescriptor) {
                n = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
            }

            pd = DeviceExtensionHub->PortData;
            for (p = 1;
                 pd && p <= n;
                 p++, pd++) {

                if (pd->DeviceObject) {
                     PDO_EXT(pd->DeviceObject)->PnPFlags |= PDO_PNPFLAG_DEVICE_PRESENT;
                     c++;
                }
            }

            // we should be reporing all PDOs
            USBH_ASSERT(c == deviceRelations->Count);
        } else {
            // retrning NULL relations or zero count, any PDO previously reported will
            // be lost -- PnP will consider them removed
            USBH_KdPrint((1, "'Query Bus Relations (HUB) %x passed on (NULL)\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            pd = DeviceExtensionHub->PortData;
            for (p = 1;
                 pd && p <= n;
                 p++, pd++) {

                if (pd->DeviceObject) {
                    TEST_TRAP();
                    PDO_EXT(pd->DeviceObject)->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;
                }
            }
        }

        Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

        // flush the deleted PDO list, as soon as we return no
        // error PNP will realize these are gone.
        {
        PDEVICE_EXTENSION_PORT dePort;
        PLIST_ENTRY listEntry;

        while (!IsListEmpty(&DeviceExtensionHub->DeletePdoList)) {
            listEntry = RemoveHeadList(&DeviceExtensionHub->DeletePdoList);
            dePort = CONTAINING_RECORD(listEntry, DEVICE_EXTENSION_PORT,
                            DeletePdoLink);
            dePort->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;
        }
        }

        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
    } else {
        // returning error and no relations
        // PnP will interpret an error with no relations as a NOOP
        // all devices will still be present

        USHORT p, n=0;
        PPORT_DATA pd;
        DEVICE_EXTENSION_PORT portDevExt;

        // we are reporting that everything is gone
        // mark the PDOs as gone now.

        if (DeviceExtensionHub->HubDescriptor) {
            n = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
        }

        Irp->IoStatus.Information=0;

        if (deviceRelations != NULL) {
            ExFreePool(deviceRelations);
            deviceRelations = NULL;
        }

        USBH_CompleteIrp(Irp, ntStatus);
    }

    return ntStatus;
}


NTSTATUS
USBH_FdoPnP(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN UCHAR MinorFunction)
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    BOOLEAN bDoCheckHubIdle = FALSE;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;
    USBH_KdPrint((2,"'PnP Power Fdo %x minor %x\n", deviceObject, MinorFunction));

    // If this hub is currently Selective Suspended, then we need to
    // power up the hub first before sending any PnP requests along to it.
    // Make sure hub has been started, though.
    // Actually, in the case where a hub has been started, stopped, and now
    // restarted, we want to power up the parent hub to handle the restart.

    // Actually, we really don't need to resume for some PnP IRPS.  Handle
    // those special cases here.

    if (DeviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (DeviceExtensionHub->HubFlags &
         (HUBFLAG_NEED_CLEANUP | HUBFLAG_HUB_STOPPED)) &&
         !(MinorFunction == IRP_MN_QUERY_DEVICE_RELATIONS &&
         irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation)) {

        bDoCheckHubIdle = TRUE;
        USBH_HubSetD0(DeviceExtensionHub);
    }


    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_START_DEVICE Fdo %x\n", deviceObject));
        bDoCheckHubIdle = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_FdoStartDevice(DeviceExtensionHub, Irp);
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_STOP_DEVICE Fdo %x", deviceObject));
        bDoCheckHubIdle = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_FdoStopDevice(DeviceExtensionHub, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_REMOVE_DEVICE Fdo %x\n", deviceObject));
        bDoCheckHubIdle = FALSE;
        DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_GONE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_FdoRemoveDevice(DeviceExtensionHub, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        switch (irpStack->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:

            bDoCheckHubIdle = TRUE;
            ASSERT(!( DeviceExtensionHub->HubFlags & HUBFLAG_HUB_BUSY));
            DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_BUSY;
            ntStatus = USBH_FdoQueryBusRelations(DeviceExtensionHub, Irp);
            DeviceExtensionHub->HubFlags &= ~HUBFLAG_HUB_BUSY;

            break;

        case TargetDeviceRelation:
            //
            // this one gets passed on
            //
            USBH_KdPrint((1, "'Query Relations, TargetDeviceRelation(HUB) %x\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionHub->TopOfStackDeviceObject);
            break;

        default:

            USBH_KdPrint((1, "'Query Relations ? (HUB) %x complete\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionHub->TopOfStackDeviceObject);

        }
        break;

     case IRP_MN_QUERY_CAPABILITIES:
        USBH_KdPrint((2,"'IRP_MN_QUERY_CAPABILITIES on fdo %x  %x\n",
                      deviceObject, MinorFunction));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,    // Irp
                           USBH_QueryCapsComplete,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           FALSE,    // invoke on error
                           FALSE);   // invoke on cancel
        ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, Irp);
        break;

        //
        // or pass the Irp down
        //

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) {
            USBH_KdPrint((2,"'reporting failed hub\n"));
            Irp->IoStatus.Information
                |= PNP_DEVICE_FAILED;
            LOGENTRY(LOG_PNP, "pnpS", DeviceExtensionHub,
                Irp->IoStatus.Information, 0);
            // note that (at least on memphis) this will result in
            // a stop message being sent to the device.
        }
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        USBH_KdPrint((1,"'IRP_MN_SURPRISE_REMOVAL on fdo %x\n", deviceObject));
        USBH_FdoSurpriseRemoveDevice(DeviceExtensionHub,
                                     Irp);
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        Irp->IoStatus.Status = STATUS_SUCCESS;

        // Fall through

    default:
        USBH_KdPrint((2,"'PnP request on fdo %x  %x\n",
                      deviceObject, MinorFunction));

        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
        break;
    }

    if (bDoCheckHubIdle) {
        USBH_CheckHubIdle(DeviceExtensionHub);
    }

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_CHILD_DELETES_PENDING;

    USBH_KdPrint((2,"'FdoPnP exit %x\n", ntStatus));
    return ntStatus;
}


NTSTATUS
USBH_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBH_ResetInterruptPipe(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;

    USBH_KdPrint((2,"'Reset Pipe\n"));

    urb = UsbhExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle =
            DeviceExtensionHub->PipeInformation.PipeHandle;

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject,
                                         urb);

        UsbhExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // if the reset pipe request is successful,
    // reset our error counter
    //
    if (NT_SUCCESS(ntStatus)) {
        DeviceExtensionHub->ErrorCount = 0;
        LOGENTRY(LOG_PNP, "rZER", DeviceExtensionHub, ntStatus, 0);
    }

    LOGENTRY(LOG_PNP, "rPIP", DeviceExtensionHub, ntStatus,
                DeviceExtensionHub->ErrorCount);

    return ntStatus;
}


NTSTATUS
USBH_GetPortStatus(
    IN IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PULONG PortStatus
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    USBH_KdPrint((2,"'enter USBH_GetPortStatus\n"));

    *PortStatus = 0;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                DeviceExtensionHub->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    USBH_ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    USBH_KdPrint((2,"'calling USBD port status api\n"));

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                            irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2, "'Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    USBH_KdPrint((2,"'Port status = %x\n", *PortStatus));

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'USBH_GetPortStatus (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_EnableParentPort(
    IN IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    USBH_KdPrint((2,"'enter USBH_EnablePort\n"));

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_ENABLE_PORT,
                DeviceExtensionHub->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    USBH_KdPrint((2,"'calling USBD enable port api\n"));

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                            irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2, "'Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    LOGENTRY(LOG_PNP, "hEPP", DeviceExtensionHub, ntStatus,  0);
    USBH_KdPrint((2,"'USBH_EnablePort (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_ResetHub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    ULONG portStatus;

    //
    // Check the port state, if it is disabled we will need
    // to re-enable it
    //
    ntStatus = USBH_GetPortStatus(DeviceExtensionHub, &portStatus);

    if (NT_SUCCESS(ntStatus) &&
        !(portStatus & USBD_PORT_ENABLED) &&
        (portStatus & USBD_PORT_CONNECTED)) {
        //
        // port is disabled, attempt reset
        //
        LOGENTRY(LOG_PNP, "rEPP", DeviceExtensionHub, portStatus,
            DeviceExtensionHub->ErrorCount);
        USBH_EnableParentPort(DeviceExtensionHub);
    }

    //
    // now attempt to reset the stalled pipe, this will clear the stall
    // on the device as well.
    //

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_ResetInterruptPipe(DeviceExtensionHub);
    }

    //
    // send the feature command to clear endpoint stall
    //

    return ntStatus;
}

#if 0
NTSTATUS
USBH_WriteRegistryKeyString (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UNICODE_STRING keyName;

    PAGED_CODE();


    RtlInitUnicodeString(&keyName, KeyNameString);

    ntStatus = ZwSetValueKey(Handle,
                    &keyName,
                    0,
                    REG_SZ,
                    Data,
                    DataLength);

    return ntStatus;
}
#endif

NTSTATUS
USBH_WriteRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN ULONG Data
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UNICODE_STRING keyName;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName, KeyNameString);

    ntStatus = ZwSetValueKey(Handle,
                    &keyName,
                    0,
                    REG_DWORD,
                    &Data,
                    sizeof(ULONG));

    return ntStatus;
}


NTSTATUS
USBH_WriteFailReason(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG FailReason
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    WCHAR USBH_FailReasonKey[] = L"FailReasonID";

    PAGED_CODE();
    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    if (NT_SUCCESS(ntStatus)) {

        USBH_WriteRegistryKeyValue(handle,
                                    USBH_FailReasonKey,
                                    sizeof(USBH_FailReasonKey),
                                    FailReason);

        ZwClose(handle);
    }

    return ntStatus;
}


#if 0 // NOT USED
NTSTATUS
USBH_WriteFailReasonString(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR FailReasonString,
    IN ULONG FailReasonStringLength
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    WCHAR USBH_FailReasonKey[] = L"FailReasonString";

    PAGED_CODE();
    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    if (NT_SUCCESS(ntStatus)) {

        USBH_WriteRegistryKeyString(handle,
                                    USBH_FailReasonKey,
                                    sizeof(USBH_FailReasonKey),
                                    FailReasonString,
                                    FailReasonStringLength);

        ZwClose(handle);
    }

    return ntStatus;
}
#endif


NTSTATUS
USBH_InvalidatePortDeviceState(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USB_CONNECTION_STATUS ConnectStatus,
    IN USHORT PortNumber
    )
/*++

Routine Description:

    This function updates the connection status for a
    port. It inavlidates the PDO if there is one, writes
    a failreason to the registry and triggers a WMI event.

    Invalidating the PDO should trigger a Q_PNP_DEVICE_STATE

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG failReason = 0;
    PPORT_DATA portData;

    USBH_ASSERT(DeviceExtensionHub != NULL);

    portData = &DeviceExtensionHub->PortData[PortNumber-1];
    portData->ConnectionStatus = ConnectStatus;

    //
    // figure out if we have a failreason we can write
    // to the registry
    //

    switch(ConnectStatus) {
    case DeviceConnected:
        // this will reset the failreasonId
        break;

    case DeviceFailedEnumeration:
        failReason = USBH_FAILREASON_ENUM_FAILED;
        break;

    case DeviceGeneralFailure:
        failReason = USBH_FAILREASON_GEN_DEVICE_FAILURE;
        break;

    case DeviceCausedOvercurrent:
        failReason = USBH_FAILREASON_PORT_OVERCURRENT;
        break;

    case DeviceNotEnoughPower:
        failReason = USBH_FAILREASON_NOT_ENOUGH_POWER;
        break;

    default:
        TEST_TRAP();
    }

    if (failReason) {
        // this writes a code to the registry so that win98 devman
        // can display an error message

        if (portData->DeviceObject) {
            USBH_WriteFailReason(portData->DeviceObject,
                                 failReason);
        }
    }

    // generate a WMI event so UI can inform the user
    USBH_PdoEvent(DeviceExtensionHub, PortNumber);

    //
    // Invalidate the state of the PDO -- this should
    // trigger a Q_PNP_DEVICE_STATE
    //

    if (portData->DeviceObject) {
        IoInvalidateDeviceState(portData->DeviceObject);
    }

    return ntStatus;
}

// JD <New>

PDEVICE_EXTENSION_PORT
PdoExt(
    PDEVICE_OBJECT DeviceObject
    )
{
    USBH_ASSERT(DeviceObject);

    if (DeviceObject == NULL) {
        return (PDEVICE_EXTENSION_PORT) -1;
    } else {
        return (PDEVICE_EXTENSION_PORT) DeviceObject->DeviceExtension;
    }
}

#if 0
PPORT_DATA
USBH_PortDataDataFromPdo(
    PDEVICE_EXTENSION_HUB HubDevExt,
    PDEVICE_OBJECT Pdo
    )
{
    PPORT_DATA portData;

    USBH_ASSERT(Pdo);

    portData = &HubDevExt->PortData[PDO_EXT(Pdo)->PortNumber - 1];

    return portData;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\pnppower.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PNPPOWER.C

Abstract:

    This module contains functions to access registry.

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    4-2-96 : created

--*/

#include <wdm.h>
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#include <ksdrmhlp.h>
#endif
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include <initguid.h>
#include <wdmguid.h>
#include <ntddstor.h>   // Needed for IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER
#include "usbhub.h"


#define BANDWIDTH_TIMEOUT   1000     // Timeout in ms (1 sec)


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_BuildDeviceID)
#pragma alloc_text(PAGE, USBH_BuildHardwareIDs)
#pragma alloc_text(PAGE, USBH_BuildCompatibleIDs)
#pragma alloc_text(PAGE, USBH_BuildInstanceID)
#pragma alloc_text(PAGE, USBH_ProcessDeviceInformation)
#pragma alloc_text(PAGE, USBH_ValidateSerialNumberString)
#pragma alloc_text(PAGE, USBH_CreateDevice)
#pragma alloc_text(PAGE, USBH_PdoQueryId)
#pragma alloc_text(PAGE, USBH_PdoPnP)
#pragma alloc_text(PAGE, USBH_PdoQueryCapabilities)
#pragma alloc_text(PAGE, USBH_PdoQueryDeviceText)
#pragma alloc_text(PAGE, USBH_CheckDeviceIDUnique)
#pragma alloc_text(PAGE, USBH_GetPdoRegistryParameter)
#pragma alloc_text(PAGE, USBH_OsVendorCodeQueryRoutine)
#pragma alloc_text(PAGE, USBH_GetMsOsVendorCode)
#pragma alloc_text(PAGE, USBH_GetMsOsFeatureDescriptor)
#pragma alloc_text(PAGE, USBH_InstallExtPropDesc)
#pragma alloc_text(PAGE, USBH_InstallExtPropDescSections)
#pragma alloc_text(PAGE, USBH_GetExtConfigDesc)
#pragma alloc_text(PAGE, USBH_ValidateExtConfigDesc)
#ifdef DRM_SUPPORT
#pragma alloc_text(PAGE, USBH_PdoSetContentId)
#endif
#endif
#endif

//
// The macro and the array make conversion from hex to strings easy for building DeviceId etc.
//

#define NibbleToHex( byte ) ((UCHAR)Nibble[byte])
CHAR Nibble[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

#define NibbleToHexW( byte ) (NibbleW[byte])
WCHAR NibbleW[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

#ifdef WMI_SUPPORT
#define NUM_PORT_WMI_SUPPORTED_GUIDS    1

WMIGUIDREGINFO USB_PortWmiGuidList[NUM_PORT_WMI_SUPPORTED_GUIDS];
#endif /* WMI_SUPPORT */


WCHAR VidPidRevString[] = L"USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn&Mi_nn";
WCHAR VidPidString[] = L"USB\\Vid_nnnn&Pid_nnnn&Mi_nn";


USB_CONNECTION_STATUS
UsbhGetConnectionStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /*
  * Description:
  *
  *     returns the connection status for a PDO
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB   deviceExtensionHub;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_DEVICE_ENUM_ERROR) {
        return DeviceFailedEnumeration;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_NOT_ENOUGH_POWER) {
        return DeviceNotEnoughPower;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_DEVICE_FAILED) {
        return DeviceGeneralFailure;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_OVERCURRENT) {
        return DeviceCausedOvercurrent;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_NO_BANDWIDTH) {
        return DeviceNotEnoughBandwidth;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_USB20_DEVICE_IN_LEGACY_HUB) {
        return DeviceInLegacyHub;
    }

    // otherwise just return "device connected"
    return DeviceConnected;

}


VOID
USBH_BandwidthTimeoutWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a bandwidth timeout.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_BANDWIDTH_TIMEOUT_WORK_ITEM   workItemBandwidthTimeout;
    PDEVICE_EXTENSION_PORT              deviceExtensionPort;
    PDEVICE_EXTENSION_HUB               deHub;


    workItemBandwidthTimeout = Context;
    deviceExtensionPort = workItemBandwidthTimeout->DeviceExtensionPort;

    USBH_KdPrint((2,"'Bandwidth timeout\n"));
    // note that deHub may be null if the bandwidth error occurs
    // during device start.  We introduced a bug when we nulled out
    // the baclpointer to the hub.  The 'fix' is to use the hubExtsave pointer
    // the backpointer that is always set even after soft remove.
    //
    // However this code is still broken in that it references a hub that
    // may or may not be there.  All we are doing here is restoring the
    // original 'brokeness'.


    deHub = deviceExtensionPort->DeviceExtensionHub;
    if (deHub == NULL) {
        // use alternate pointer
        deHub = deviceExtensionPort->HubExtSave;
    }


    USBH_PdoEvent(deHub,
                  deviceExtensionPort->PortNumber);

    UsbhExFreePool(workItemBandwidthTimeout);
}


VOID
USBH_PortTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PPORT_TIMEOUT_CONTEXT portTimeoutContext = DeferredContext;
    PDEVICE_EXTENSION_PORT deviceExtensionPort =
                                portTimeoutContext->DeviceExtensionPort;
    BOOLEAN cancelFlag;
    PUSBH_BANDWIDTH_TIMEOUT_WORK_ITEM workItemBandwidthTimeout;

    USBH_KdPrint((2,"'BANDWIDTH_TIMEOUT\n"));

    // Take SpinLock here so that main routine won't write CancelFlag
    // in the timeout context while we free the timeout context.

    KeAcquireSpinLockAtDpcLevel(&deviceExtensionPort->PortSpinLock);

    cancelFlag = portTimeoutContext->CancelFlag;
    deviceExtensionPort->PortTimeoutContext = NULL;

    KeReleaseSpinLockFromDpcLevel(&deviceExtensionPort->PortSpinLock);

    UsbhExFreePool(portTimeoutContext);

    if (!cancelFlag) {
        //
        // Schedule a work item to process this.
        //
        workItemBandwidthTimeout = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_BANDWIDTH_TIMEOUT_WORK_ITEM));

        if (workItemBandwidthTimeout) {

            workItemBandwidthTimeout->DeviceExtensionPort = deviceExtensionPort;

            ExInitializeWorkItem(&workItemBandwidthTimeout->WorkQueueItem,
                                 USBH_BandwidthTimeoutWorker,
                                 workItemBandwidthTimeout);

            LOGENTRY(LOG_PNP, "bERR", deviceExtensionPort,
                &workItemBandwidthTimeout->WorkQueueItem, 0);

            ExQueueWorkItem(&workItemBandwidthTimeout->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_BandwidthTimeoutWorker()
            // Don't try to access the WorkItem after it is queued.
        }
    }
}


NTSTATUS
USBH_SelectConfigOrInterface_Complete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  *     Take some action based on change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort = Context;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = NULL;
    PPORT_DATA portData = NULL;
    NTSTATUS ntStatus;
    PURB urb;
    PIO_STACK_LOCATION ioStackLocation;
    PPORT_TIMEOUT_CONTEXT portTimeoutContext = NULL;
    LARGE_INTEGER dueTime;
    KIRQL irql;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;
    if (deviceExtensionHub) {
        portData = &deviceExtensionHub->PortData[deviceExtensionPort->PortNumber - 1];
    }

    ntStatus = Irp->IoStatus.Status;
    if (ntStatus == STATUS_SUCCESS) {
        //
        // "Cancel" timer.
        //
        // Take SpinLock here so that DPC routine won't free
        // the timeout context while we write the CancelFlag
        // in the timeout context.
        //
        KeAcquireSpinLock(&deviceExtensionPort->PortSpinLock, &irql);

        if (deviceExtensionPort->PortTimeoutContext) {
            USBH_KdPrint((2,"'Bandwidth allocation successful, cancelling timeout\n"));

            portTimeoutContext = deviceExtensionPort->PortTimeoutContext;
            portTimeoutContext->CancelFlag = TRUE;

            if (KeCancelTimer(&portTimeoutContext->TimeoutTimer)) {
                //
                // We cancelled the timer before it could run.  Free the context.
                //
                UsbhExFreePool(portTimeoutContext);
                deviceExtensionPort->PortTimeoutContext = NULL;
            }
        }

        KeReleaseSpinLock(&deviceExtensionPort->PortSpinLock, irql);

        // clear the error
        deviceExtensionPort->PortPdoFlags &=
               ~(PORTPDO_DEVICE_FAILED | PORTPDO_NO_BANDWIDTH);

        // Don't stomp connection status for a hub that is nested too
        // deeply.

        if (portData &&
            portData->ConnectionStatus != DeviceHubNestedTooDeeply) {

            portData->ConnectionStatus = DeviceConnected;
        }

    } else {
        // extract the URB
        ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
        urb = ioStackLocation->Parameters.Others.Argument1;

        if (urb->UrbHeader.Status == USBD_STATUS_NO_BANDWIDTH) {

            deviceExtensionPort->RequestedBandwidth = 0;

            if (urb->UrbHeader.Function == URB_FUNCTION_SELECT_INTERFACE) {
                USBH_CalculateInterfaceBandwidth(
                    deviceExtensionPort,
                    &urb->UrbSelectInterface.Interface,
                    &deviceExtensionPort->RequestedBandwidth);
            } else if (urb->UrbHeader.Function ==
                       URB_FUNCTION_SELECT_CONFIGURATION){
                // we need to walk through the config
                // and get all the interfcaces
                PUCHAR pch, end;
                PUSBD_INTERFACE_INFORMATION iface;

                end = (PUCHAR) urb;
                end += urb->UrbHeader.Length;
                pch = (PUCHAR) &urb->UrbSelectConfiguration.Interface;
                iface = (PUSBD_INTERFACE_INFORMATION) pch;

                while (pch < end) {
                    USBH_CalculateInterfaceBandwidth(
                        deviceExtensionPort,
                        iface,
                        &deviceExtensionPort->RequestedBandwidth);

                    pch += iface->Length;
                    iface = (PUSBD_INTERFACE_INFORMATION) pch;
                }

            } else {
                // did we miss something?
                TEST_TRAP();
            }

            deviceExtensionPort->PortPdoFlags |=
                PORTPDO_NO_BANDWIDTH;

            if (portData) {
                portData->ConnectionStatus = DeviceNotEnoughBandwidth;
            }

            if (!deviceExtensionPort->PortTimeoutContext) {
                USBH_KdPrint((2,"'Start bandwidth timeout\n"));
                portTimeoutContext = UsbhExAllocatePool(NonPagedPool,
                                        sizeof(*portTimeoutContext));

                if (portTimeoutContext) {

                    portTimeoutContext->CancelFlag = FALSE;

                    // Maintain links between the device extension and the
                    // timeout context.
                    deviceExtensionPort->PortTimeoutContext = portTimeoutContext;
                    portTimeoutContext->DeviceExtensionPort = deviceExtensionPort;

                    KeInitializeTimer(&portTimeoutContext->TimeoutTimer);
                    KeInitializeDpc(&portTimeoutContext->TimeoutDpc,
                                    USBH_PortTimeoutDPC,
                                    portTimeoutContext);
                }

            }
#if DBG
             else {
                USBH_KdPrint((2,"'Reset bandwidth timeout\n"));
            }
#endif

            dueTime.QuadPart = -10000 * BANDWIDTH_TIMEOUT;

            // Take spinlock here in case DPC routine fires and deallocates
            // the timer context before we have had the chance to reset the
            // timer (in the case where we are resetting an existing timer).

            KeAcquireSpinLock(&deviceExtensionPort->PortSpinLock, &irql);

            portTimeoutContext = deviceExtensionPort->PortTimeoutContext;
            if (portTimeoutContext) {
                KeSetTimer(&portTimeoutContext->TimeoutTimer,
                           dueTime,
                           &portTimeoutContext->TimeoutDpc);
            }

            KeReleaseSpinLock(&deviceExtensionPort->PortSpinLock, irql);

        }
    }

    return ntStatus;
}


NTSTATUS
USBH_PdoUrbFilter(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PURB urb;
    USHORT function;
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;

    USBH_KdPrint((2,"'USBH_PdoUrbFilter DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    LOGENTRY(LOG_PNP, "pURB", DeviceExtensionPort, deviceExtensionHub,
        deviceExtensionHub->HubFlags);

    portData = &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    urb = ioStackLocation->Parameters.Others.Argument1;

#if DBG
    if (!(DeviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) &&
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET)) {
        UsbhWarning(DeviceExtensionPort,
           "Device Driver is sending requests before passing start irp\n, Please rev your driver.\n",
           TRUE);
    }
#endif

    //
    // in some cases we will need to fail bus requests here.
    //

//    if (DeviceExtensionPort->DeviceState != PowerDeviceD0) {
//        // fail any call that is sent to a PDO for a suspended device
//        UsbhWarning(DeviceExtensionPort,
//                    "Device Driver is sending requests while in low power state!\n",
//                    TRUE);
//        ntStatus = STATUS_INVALID_PARAMETER;
//    }
#if DBG
    if (DeviceExtensionPort->DeviceState != PowerDeviceD0) {
        USBH_KdPrint((1, "'URB request, device not in D0\n"));
    }
#endif

    if (DeviceExtensionPort->PortPdoFlags & (PORTPDO_DEVICE_FAILED | PORTPDO_RESET_PENDING)) {
        USBH_KdPrint((1, "'failing request to failed PDO\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    // check for error, if we have one, bail
    if (!NT_SUCCESS(ntStatus)) {
        urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
        USBH_CompleteIrp(Irp, ntStatus);
        goto USBH_PdoUrbFilter_Done;
    }

    // check the command code code the URB

    function = urb->UrbHeader.Function;

    LOGENTRY(LOG_PNP, "URB+", DeviceExtensionPort,
                function,
                urb);

    switch(function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:

        if (urb->UrbSelectConfiguration.ConfigurationDescriptor != NULL) {
            LONG powerRequired;

            // validate the descriptor passed to us before we
            // attempt to refernce it

            {
            PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
            USBD_STATUS usbdStatus;

            configurationDescriptor =
                urb->UrbSelectConfiguration.ConfigurationDescriptor;

            if (!USBH_ValidateConfigurationDescriptor(
                    configurationDescriptor,
                    &usbdStatus)) {

                urb->UrbHeader.Status =
                    usbdStatus;
                ntStatus = STATUS_INVALID_PARAMETER;
                USBH_CompleteIrp(Irp, ntStatus);

                goto USBH_PdoUrbFilter_Done;
            }
            }

            //
            // make sure there is enough power on this port
            //

            DeviceExtensionPort->PowerRequested =
                powerRequired =
                    ((LONG)urb->UrbSelectConfiguration.ConfigurationDescriptor->MaxPower)*2;

#if DBG
            if (UsbhPnpTest & PNP_TEST_FAIL_DEV_POWER) {
                powerRequired = 99999;
            }
#endif
            USBH_KdPrint((2,"'request power: avail = %d Need = %d\n",
                    deviceExtensionHub->MaximumPowerPerPort, powerRequired));

            if (deviceExtensionHub->MaximumPowerPerPort < powerRequired) {
                USBH_KdPrint((1, "'**insufficient power for device\n"));

                // not enough power for this device

                // mark the PDO
                DeviceExtensionPort->PortPdoFlags |=
                    PORTPDO_NOT_ENOUGH_POWER;

                USBH_InvalidatePortDeviceState(
                        deviceExtensionHub,
                        UsbhGetConnectionStatus(DeviceExtensionPort),
                        DeviceExtensionPort->PortNumber);

                ntStatus = STATUS_INVALID_PARAMETER;
                USBH_CompleteIrp(Irp, ntStatus);

                goto USBH_PdoUrbFilter_Done;
            }
        }

        // check for BW failure

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                           USBH_SelectConfigOrInterface_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionPort,
                           TRUE,
                           TRUE,
                           TRUE);

        ntStatus = IoCallDriver(deviceExtensionHub->TopOfHcdStackDeviceObject, Irp);
        goto USBH_PdoUrbFilter_Done;
        break;

    case URB_FUNCTION_SELECT_INTERFACE:
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                           USBH_SelectConfigOrInterface_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionPort,
                           TRUE,
                           TRUE,
                           TRUE);

        ntStatus = IoCallDriver(deviceExtensionHub->TopOfHcdStackDeviceObject, Irp);
        goto USBH_PdoUrbFilter_Done;
        break;

    //
    // we could fail everything provided we abort
    // all the drivers pipes.
    //
    // fail any transfers if delete is pending
    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
    case URB_FUNCTION_ISOCH_TRANSFER:

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
            USBH_KdPrint((2,"'failing request with STATUS_DELETE_PENDING\n"));
            ntStatus = STATUS_DELETE_PENDING;

            urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
            USBH_CompleteIrp(Irp, ntStatus);
            goto USBH_PdoUrbFilter_Done;
        }
        break;

    case URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR:

        LOGENTRY(LOG_PNP, "MSOS", DeviceExtensionPort,
            DeviceExtensionPort->PortPdoFlags, 0);
        USBH_KdPrint((1,"'URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR\n"));

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
            USBH_KdPrint((1,"'GET_MS_FEATURE_DESC: failing request with STATUS_DELETE_PENDING\n"));
            ntStatus = STATUS_DELETE_PENDING;

            urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
            USBH_CompleteIrp(Irp, ntStatus);
            goto USBH_PdoUrbFilter_Done;
        }
#ifndef USBHUB20
        ntStatus = USBH_GetMsOsFeatureDescriptor(
                       deviceObject,
                       urb->UrbOSFeatureDescriptorRequest.Recipient,
                       urb->UrbOSFeatureDescriptorRequest.InterfaceNumber,
                       urb->UrbOSFeatureDescriptorRequest.MS_FeatureDescriptorIndex,
                       urb->UrbOSFeatureDescriptorRequest.TransferBuffer,
                       urb->UrbOSFeatureDescriptorRequest.TransferBufferLength,
                       &urb->UrbOSFeatureDescriptorRequest.TransferBufferLength);
#endif
        if (NT_SUCCESS(ntStatus))
        {
            urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        }
        else
        {
            // arbitrary URB error status...
            //
            urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
        }

        USBH_CompleteIrp(Irp, ntStatus);
        goto USBH_PdoUrbFilter_Done;
        break;

    default:
        // just pass thru
        break;
    }

    ntStatus = USBH_PassIrp(Irp,
                            deviceExtensionHub->TopOfHcdStackDeviceObject);


USBH_PdoUrbFilter_Done:

    return ntStatus;
}


PWCHAR
USBH_BuildDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build bus Id wide string for the PDO based on the Vendor Id
  * and Product Id. We allocate memory for the string which will be attached
  * to the PDO. L"USB\\Vid_nnnn&Pid_nnnn(&Mi_nn)\0"
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO
  *
  * Return:
  *
  * the pointer to the wide string if successful NULL - otherwise
  *
  * -- */
{
    PWCHAR pwch, p, vid, pid, mi;
    ULONG need;

    PAGED_CODE();

#ifdef USBHUB20
    if (IsHubClass) {
        return USBH_BuildHubDeviceID(IdVendor,
                                     IdProduct,
                                     MiId);
    }
#endif
    USBH_KdPrint((2,"'DeviceId VendorId %04x ProductId %04x interface %04x\n",
        IdVendor, IdProduct, MiId));

    // allow for extra NULL
    need = sizeof(VidPidString) + 2;

    USBH_KdPrint((2,"'allocate %d bytes for device id string\n", need));

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    pwch = ExAllocatePoolWithTag(PagedPool, need, USBHUB_HEAP_TAG);
    if (NULL == pwch)
        return NULL;

    RtlZeroMemory(pwch, need);

    p = pwch;

    // BUILD
    // USB\\Vid_nnnn&Pid_nnnn(&Mi_nn){NULL}

    RtlCopyMemory(p, VidPidString, sizeof(VidPidString));

    // now update the id fields
    vid = p + 8;
    pid = p + 17;
    mi = p + 25;

    *vid = NibbleToHex(IdVendor >> 12);
    *(vid+1) = NibbleToHex((IdVendor >> 8) & 0x000f);
    *(vid+2) = NibbleToHex((IdVendor >> 4) & 0x000f);
    *(vid+3) =  NibbleToHex(IdVendor & 0x000f);

    *pid = NibbleToHex(IdProduct >> 12);
    *(pid+1) = NibbleToHex((IdProduct >> 8) & 0x000f);
    *(pid+2) = NibbleToHex((IdProduct >> 4) & 0x000f);
    *(pid+3) = NibbleToHex(IdProduct & 0x000f);

    if (MiId == -1) {
        p = p + 21;
        *p = (WCHAR)NULL;
        p++;
        *p = (WCHAR)NULL;
    } else {
        *mi = NibbleToHex(MiId >> 4);
        *(mi+1) = NibbleToHex(MiId & 0x000f);
    }

    USBH_KdPrint((2,"'Device id string = 0x%x\n", pwch));

    return pwch;
}


PWCHAR
USBH_BuildHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    )
 /* ++
  *
  * Description:
  *
  * This function build HardwareIDs wide multi-string for the PDO based on the
  * Vendor Id, Product Id and Revision Id. We allocate memory for the
  * multi-string which will be attached to the PDO.
  * L"USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn\0USB\\Vid_nnnn&Pid_nnnn\0\0"
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO
  *
  * Return:
  *
  * the pointer to the wide multi-string if successful NULL - otherwise
  *
  * -- */
{
    PWCHAR pwch, p, vid, pid, rev, mi;
    ULONG need;

    PAGED_CODE();

#ifdef USBHUB20
    if (IsHubClass) {
        return USBH_BuildHubHardwareIDs(
                IdVendor,
                IdProduct,
                BcdDevice,
                MiId);
    }
#endif // USBHUB20

    USBH_KdPrint((2,"'HardwareIDs VendorId %04x ProductId %04x Revision %04x interface %04x\n",
        IdVendor, IdProduct, BcdDevice, MiId));

    // allow for extra NULL
    need = sizeof(VidPidRevString) + sizeof(VidPidString) + 2;

    USBH_KdPrint((2,"'allocate %d bytes for id string\n", need));

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    pwch = ExAllocatePoolWithTag(PagedPool, need, USBHUB_HEAP_TAG);
    if (NULL == pwch)
        return NULL;

    RtlZeroMemory(pwch, need);

    // build two strings in to buffer:
    // USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn&Mi_nn{NULL}
    // USB\\Vid_nnnn&Pid_nnnn&Mi_nn{NULL}{NULL}

    // BUILD
    // USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn&(Mi_nn){NULL}

    RtlCopyMemory(pwch, VidPidRevString, sizeof(VidPidRevString));

    p = pwch;
    // now update the id fields
    vid = p + 8;
    pid = p + 17;
    rev = p + 26;
    mi = p + 34;

    *vid = NibbleToHex(IdVendor >> 12);
    *(vid+1) = NibbleToHex((IdVendor >> 8) & 0x000f);
    *(vid+2) = NibbleToHex((IdVendor >> 4) & 0x000f);
    *(vid+3) =  NibbleToHex(IdVendor & 0x000f);

    *pid = NibbleToHex(IdProduct >> 12);
    *(pid+1) = NibbleToHex((IdProduct >> 8) & 0x000f);
    *(pid+2) = NibbleToHex((IdProduct >> 4) & 0x000f);
    *(pid+3) = NibbleToHex(IdProduct & 0x000f);

    *rev = BcdNibbleToAscii(BcdDevice >> 12);
    *(rev+1) = BcdNibbleToAscii((BcdDevice >> 8) & 0x000f);
    *(rev+2) = BcdNibbleToAscii((BcdDevice >> 4) & 0x000f);
    *(rev+3) = BcdNibbleToAscii(BcdDevice & 0x000f);

    if (MiId == -1) {
        p = p + 30;
        *p = (WCHAR)NULL;
        p++;
    } else {
        p = p + 37;
        *mi = NibbleToHex(MiId >> 4);
        *(mi+1) = NibbleToHex(MiId & 0x000f);
    }

    // BUILD
    // USB\\Vid_nnnn&Pid_nnnn(&Mi_nn){NULL}

    RtlCopyMemory(p, VidPidString, sizeof(VidPidString));

    // now update the id fields
    vid = p + 8;
    pid = p + 17;
    mi = p + 25;

    *vid = NibbleToHex(IdVendor >> 12);
    *(vid+1) = NibbleToHex((IdVendor >> 8) & 0x000f);
    *(vid+2) = NibbleToHex((IdVendor >> 4) & 0x000f);
    *(vid+3) =  NibbleToHex(IdVendor & 0x000f);

    *pid = NibbleToHex(IdProduct >> 12);
    *(pid+1) = NibbleToHex((IdProduct >> 8) & 0x000f);
    *(pid+2) = NibbleToHex((IdProduct >> 4) & 0x000f);
    *(pid+3) = NibbleToHex(IdProduct & 0x000f);

    if (MiId == -1) {
        p = p + 21;
        *p = (WCHAR)NULL;
        p++;
        *p = (WCHAR)NULL;
    } else {
        *mi = NibbleToHex(MiId >> 4);
        *(mi+1) = NibbleToHex(MiId & 0x000f);
    }

    USBH_KdPrint((2,"'HW id string = 0x%x\n", pwch));

    return pwch;
}


#if 0

PWCHAR
USBH_BuildCompatibleIDs(
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build compatible Ids wide multi-string for the PDO based on
  * the Class and Subclass Ids. We allocate memory for the string which will
  * be attached to the PDO.
  * L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
  * L"USB\\Class_nn&SubClass_nn\0"
  * L"USB\Class_nn\0"
  * L"USB\COMPOSITE\0"
  * L"\0"
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO
  *
  * Return:
  *
  * the pointer to the multi-string if successful NULL - otherwise
  *
  *
  * -- */
{
    PWCHAR pwch, pwch1;
    ULONG ulBytes;
    ULONG ulTotal;
    BOOLEAN ControlerIsHS = FALSE;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter BuildCompatibleIDs\n"));

#ifdef USBHUB20
    ControlerIsHS = TRUE;
#endif
// if this is a high speed controller (USB2) then we must
// generate a different set of compat ids to be backward
// compatible with the goatpack
    if (Class == USB_DEVICE_CLASS_HUB &&
        ControlerIsHS) {
        return USBH_BuildHubCompatibleIDs(
                Class,
                SubClass,
                Protocol,
                DeviceClass,
                DeviceIsHighSpeed);
    }
//#endif

    STRLEN(ulBytes, pwchUsbSlash);
    ulTotal = ulBytes * 3;      // 3 sets of L"USB\\"
    if (DeviceClass) {
        STRLEN(ulBytes, pwchDevClass);
        ulTotal += ulBytes * 3;     // 3 sets of L"DevClass_"
        STRLEN(ulBytes, pwchComposite);
        ulTotal += ulBytes;         // "USB\COMPOSITE"
    } else {
        STRLEN(ulBytes, pwchClass);
        ulTotal += ulBytes * 3;     // 3 sets of L"Class_"
    }
    STRLEN(ulBytes, pwchSubClass);
    ulTotal += ulBytes * 2;     // 2 sets of L"SubClass_"
    STRLEN(ulBytes, pwchProt);
    ulTotal += ulBytes;         // 1 set of L"Prot_"
    ulTotal += sizeof(WCHAR) * (2 * 6 + 3 + 5);   // 6 sets of 2 digits, 3 '&'s,
                                            // and 5 nulls
    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    pwch = ExAllocatePoolWithTag(PagedPool, ulTotal, USBHUB_HEAP_TAG);
    if (NULL == pwch)
        return NULL;

    USBH_KdPrint((2,"'Interface Class %02x SubClass %02x Protocol %02x\n",
                  Class, SubClass, Protocol));

    //
    // First string
    //
    STRCPY(pwch, pwchUsbSlash);

    //
    // ClassId
    //
    if (DeviceClass) {
        STRCAT(pwch, pwchDevClass);
    } else {
        STRCAT(pwch, pwchClass);
    }
    APPEND(pwch, NibbleToHex((Class) >> 4));
    APPEND(pwch, NibbleToHex((Class) & 0x0f));
    APPEND(pwch, '&');

    //
    // SubClassId
    //
    STRCAT(pwch, pwchSubClass);
    APPEND(pwch, NibbleToHex((SubClass) >> 4));
    APPEND(pwch, NibbleToHex((SubClass) & 0x0f));
    APPEND(pwch, '&');

    //
    // DeviceProtocol
    //
    STRCAT(pwch, pwchProt);
    APPEND(pwch, NibbleToHex((Protocol) >> 4));
    APPEND(pwch, NibbleToHex((Protocol) & 0x0f));

    //
    // Second string
    //
    STRLEN(ulBytes, pwch);
    pwch1 = &pwch[ulBytes / 2 + 1]; // second string
    STRCPY(pwch1, pwchUsbSlash);

    //
    // ClassId
    //
    if (DeviceClass) {
        STRCAT(pwch1, pwchDevClass);
    } else {
        STRCAT(pwch1, pwchClass);
    }
    APPEND(pwch1, NibbleToHex((Class) >> 4));
    APPEND(pwch1, NibbleToHex((Class) & 0x0f));
    APPEND(pwch1, '&');

    //
    // SubClassId
    //
    STRCAT(pwch1, pwchSubClass);
    APPEND(pwch1, NibbleToHex((SubClass) >> 4));
    APPEND(pwch1, NibbleToHex((SubClass) & 0x0f));

    //
    // Third string USB\Class_nn
    //
    STRLEN(ulBytes, pwch1);
    pwch1 = &pwch1[ulBytes / 2 + 1];    // third string
    STRCPY(pwch1, pwchUsbSlash);

    //
    // Class Id
    //
    if (DeviceClass) {
        STRCAT(pwch1, pwchDevClass);
    } else {
        STRCAT(pwch1, pwchClass);
    }
    APPEND(pwch1, NibbleToHex((Class) >> 4));
    APPEND(pwch1, NibbleToHex((Class) & 0x0f));

    //
    // Third string
    //
    // STRLEN( ulBytes, pwch1 );
    // pwch1 = &pwch1[ulBytes /2 + 1];       // third string
    // STRCPY( pwch1, pwchUsbSlash );

    //
    // ClassId
    //
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceClass)>>4));
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceClass) & 0x0f));

    //
    // SubClassId
    //
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceSubClass) >>
    // 4));
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceSubClass)
    // &0x0f));

    if (DeviceClass) {
        STRLEN(ulBytes, pwch1);
        pwch1 = &pwch1[ulBytes / 2 + 1];
        STRCPY(pwch1, pwchComposite);
    }

    //
    // double null termination
    //

    APPEND(pwch1, 0);

    return pwch;
}

#else

typedef struct _DEVCLASS_COMAPTIBLE_IDS
{
    // L"USB\\DevClass_nn&SubClass_nn&Prot_nn\0"
    //
    WCHAR   ClassStr1[sizeof(L"USB\\DevClass_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex1[2];
    WCHAR   SubClassStr1[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex1[2];
    WCHAR   Prot1[sizeof(L"&Prot_")/sizeof(WCHAR)-1];
    WCHAR   ProtHex1[2];
    WCHAR   Null1[1];

    // L"USB\\DevClass_nn&SubClass_nn\0"
    //
    WCHAR   DevClassStr2[sizeof(L"USB\\DevClass_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex2[2];
    WCHAR   SubClassStr2[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex2[2];
    WCHAR   Null2[1];

    // L"USB\\DevClass_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr3[sizeof(L"USB\\DevClass_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex3[2];
    WCHAR   Null3[1];

    // L"USB\\COMPOSITE\0"
    //
    WCHAR   CompositeStr[sizeof(L"USB\\COMPOSITE")/sizeof(WCHAR)-1];
    WCHAR   Null4[1];

    WCHAR   DoubleNull[1];

} DEVCLASS_COMAPTIBLE_IDS, *PDEVCLASS_COMAPTIBLE_IDS;


typedef struct _CLASS_COMAPTIBLE_IDS
{
    // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
    //
    WCHAR   ClassStr1[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex1[2];
    WCHAR   SubClassStr1[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex1[2];
    WCHAR   Prot1[sizeof(L"&Prot_")/sizeof(WCHAR)-1];
    WCHAR   ProtHex1[2];
    WCHAR   Null1[1];

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr2[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex2[2];
    WCHAR   SubClassStr2[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex2[2];
    WCHAR   Null2[1];

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr3[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex3[2];
    WCHAR   Null3[1];

    WCHAR   DoubleNull[1];

} CLASS_COMAPTIBLE_IDS, *PCLASS_COMAPTIBLE_IDS;


static DEVCLASS_COMAPTIBLE_IDS DevClassCompatibleIDs =
{
    // L"USB\\DevClass_nn&SubClass_nn&Prot_nn\0"
    //
    {'U','S','B','\\','D','e','v','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {'&','P','r','o','t','_'},
    {'n','n'},
    {0},

    // L"USB\\DevClass_nn&SubClass_nn\0"
    //
    {'U','S','B','\\','D','e','v','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\DevClass_nn\0"
    //
    {'U','S','B','\\','D','e','v','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\COMPOSITE\0"
    //
    {'U','S','B','\\','C','O','M','P','O','S','I','T','E'},
    {0},

    {0}
};

static CLASS_COMAPTIBLE_IDS ClassCompatibleIDs =
{
    // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {'&','P','r','o','t','_'},
    {'n','n'},
    {0},

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\Class_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    {0}
};

PWCHAR
USBH_BuildCompatibleIDs(
    IN PUCHAR   CompatibleID,
    IN PUCHAR   SubCompatibleID,
    IN UCHAR    Class,
    IN UCHAR    SubClass,
    IN UCHAR    Protocol,
    IN BOOLEAN  DeviceClass,
    IN BOOLEAN  DeviceIsHighSpeed
    )
{
    ULONG   ulTotal;
    PWCHAR  pwch;

    WCHAR   ClassHi     = NibbleToHexW((Class) >> 4);
    WCHAR   ClassLo     = NibbleToHexW((Class) & 0x0f);
    WCHAR   SubClassHi  = NibbleToHexW((SubClass) >> 4);
    WCHAR   SubClassLo  = NibbleToHexW((SubClass) & 0x0f);
    WCHAR   ProtocolHi  = NibbleToHexW((Protocol) >> 4);
    WCHAR   ProtocolLo  = NibbleToHexW((Protocol) & 0x0f);

    BOOLEAN ControlerIsHS = FALSE;

    PAGED_CODE();

#ifdef USBHUB20
    ControlerIsHS = TRUE;
#endif
// if this is a high speed controller (USB2) then we must
// generate a different set of compat ids to be backward
// compatible with the goatpack
    if (Class == USB_DEVICE_CLASS_HUB &&
        ControlerIsHS) {
        return USBH_BuildHubCompatibleIDs(
                Class,
                SubClass,
                Protocol,
                DeviceClass,
                DeviceIsHighSpeed);
    }
//#endif

    if (DeviceClass)
    {
        ulTotal = sizeof(DEVCLASS_COMAPTIBLE_IDS);
    }
    else
    {
        ulTotal = sizeof(CLASS_COMAPTIBLE_IDS);

        if (SubCompatibleID[0] != 0)
        {
            ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx&MS_SUBCOMP_xxxxxxxx");
        }

        if (CompatibleID[0] != 0)
        {
            ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx");
        }
    }

    pwch = ExAllocatePoolWithTag(PagedPool, ulTotal, USBHUB_HEAP_TAG);

    if (pwch)
    {
        if (DeviceClass)
        {
            PDEVCLASS_COMAPTIBLE_IDS pDevClassIds;

            pDevClassIds = (PDEVCLASS_COMAPTIBLE_IDS)pwch;

            // Copy over the constant set of strings:
            // L"USB\\DevClass_nn&SubClass_nn&Prot_nn\0"
            // L"USB\\DevClass_nn&SubClass_nn\0"
            // L"USB\\DevClass_nn&SubClass_nn\0"
            // L"USB\\COMPOSITE\0"
            //
            RtlCopyMemory(pDevClassIds,
                          &DevClassCompatibleIDs,
                          sizeof(DEVCLASS_COMAPTIBLE_IDS));

            // Fill in the 'nn' blanks
            //
            pDevClassIds->ClassHex1[0] =
            pDevClassIds->ClassHex2[0] =
            pDevClassIds->ClassHex3[0] = ClassHi;

            pDevClassIds->ClassHex1[1] =
            pDevClassIds->ClassHex2[1] =
            pDevClassIds->ClassHex3[1] = ClassLo;

            pDevClassIds->SubClassHex1[0] =
            pDevClassIds->SubClassHex2[0] = SubClassHi;

            pDevClassIds->SubClassHex1[1] =
            pDevClassIds->SubClassHex2[1] = SubClassLo;

            pDevClassIds->ProtHex1[0] = ProtocolHi;

            pDevClassIds->ProtHex1[1] = ProtocolLo;
        }
        else
        {
            PCLASS_COMAPTIBLE_IDS   pClassIds;
            PWCHAR                  pwchTmp;
            ULONG                   i;

            pwchTmp = pwch;

            if (SubCompatibleID[0] != 0)
            {
                RtlCopyMemory(pwchTmp,
                              L"USB\\MS_COMP_",
                              sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

                (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

                for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
                {
                    *pwchTmp++ = (WCHAR)CompatibleID[i];
                }

                RtlCopyMemory(pwchTmp,
                              L"&MS_SUBCOMP_",
                              sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR));

                (PUCHAR)pwchTmp += sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR);

                for (i = 0; i < 8 && SubCompatibleID[i] != 0; i++)
                {
                    *pwchTmp++ = (WCHAR)SubCompatibleID[i];
                }

                *pwchTmp++ = '\0';
            }

            if (CompatibleID[0] != 0)
            {
                RtlCopyMemory(pwchTmp,
                              L"USB\\MS_COMP_",
                              sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

                (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

                for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
                {
                    *pwchTmp++ = (WCHAR)CompatibleID[i];
                }

                *pwchTmp++ = '\0';
            }

            pClassIds = (PCLASS_COMAPTIBLE_IDS)pwchTmp;

            // Copy over the constant set of strings:
            // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
            // L"USB\\Class_nn&SubClass_nn\0"
            // L"USB\\Class_nn\0"
            //
            RtlCopyMemory(pClassIds,
                          &ClassCompatibleIDs,
                          sizeof(CLASS_COMAPTIBLE_IDS));

            // Fill in the 'nn' blanks
            //
            pClassIds->ClassHex1[0] =
            pClassIds->ClassHex2[0] =
            pClassIds->ClassHex3[0] = ClassHi;

            pClassIds->ClassHex1[1] =
            pClassIds->ClassHex2[1] =
            pClassIds->ClassHex3[1] = ClassLo;

            pClassIds->SubClassHex1[0] =
            pClassIds->SubClassHex2[0] = SubClassHi;

            pClassIds->SubClassHex1[1] =
            pClassIds->SubClassHex2[1] = SubClassLo;

            pClassIds->ProtHex1[0] = ProtocolHi;

            pClassIds->ProtHex1[1] = ProtocolLo;
        }
    }

    return pwch;
}

#endif


PWCHAR
USB_MakeId(
    PWCHAR IdString,
    PWCHAR Buffer,
    PULONG Length,
    USHORT NullCount,
    USHORT Digits,
    USHORT HexId
    )
/*
    given a wide Id string like "FOOnnnn\0"
    add the HexId value to nnnn as hex
    this string is appended to the buffer passed in

    eg
    in  : FOOnnnn\0 , 0x123A
    out : FOO123A\0
*/
{
#define NIBBLE_TO_HEX( byte ) ((WCHAR)Nibble[byte])
    const UCHAR Nibble[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
        'B', 'C', 'D', 'E', 'F'};

    PWCHAR tmp, id;
    PUCHAR p;
    SIZE_T siz, idLen;

    idLen = wcslen(IdString)*sizeof(WCHAR);
    siz = idLen+(USHORT)*Length+(NullCount*sizeof(WCHAR));
    tmp = ExAllocatePoolWithTag(PagedPool, siz, USBHUB_HEAP_TAG);
    if (tmp == NULL) {
        *Length = 0;
    } else {
        // this takes care of the nulls
        RtlZeroMemory(tmp, siz);
        RtlCopyMemory(tmp, Buffer, *Length);
        p = (PUCHAR) tmp;
        p += *Length;
        RtlCopyMemory(p, IdString, idLen);
        id = (PWCHAR) p;
        *Length = (ULONG)siz;

        // now convert the vaules
        while (*id != (WCHAR)'n' && Digits) {
            id++;
        }

        switch(Digits) {
        case 2:
            *(id) = NIBBLE_TO_HEX((HexId >> 4) & 0x000f);
            *(id+1) =  NIBBLE_TO_HEX(HexId & 0x000f);
            break;
        case 4:
            *(id) = NIBBLE_TO_HEX(HexId >> 12);
            *(id+1) = NIBBLE_TO_HEX((HexId >> 8) & 0x000f);
            *(id+2) = NIBBLE_TO_HEX((HexId >> 4) & 0x000f);
            *(id+3) =  NIBBLE_TO_HEX(HexId & 0x000f);
            break;
        }


    }

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return tmp;
}



PWCHAR
USBH_BuildHubDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build bus Id wide string for the PDO based on the Vendor Id
  *
      USB\HUB_Vid_nnnn&Pid_nnnn\0
  *
  *
  * -- */
{
    PWCHAR id;
    ULONG length;

    id = NULL;
    length = 0;

    id = USB_MakeId(
                   L"USB\\HUB_VID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,  // 4 digits
                   IdVendor);

    id = USB_MakeId(
                   L"&PID_nnnn\0",
                   id,
                   &length,
                   1,  // add a null
                   4,  // 4 digits
                   IdProduct);


    return(id);
}


PWCHAR
USBH_BuildHubHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId
    )
 /* ++
  *
  * Description:
  *
  * This function build HardwareIDs wide multi-string for the PDO based on the
  * Vendor Id, Product Id and Revision Id.
  *

    USB\HUB_Vid_nnnn&Pid_nnnn&Rev_nnnn\0
    USB\HUB_Vid_nnnn&Pid_nnnn\0
    \0


  * -- */
{
    PWCHAR id;
    ULONG length;

    id = NULL;
    length = 0;

    // USB\HUB_VID_nnnn&PID_nnnn&REV_nnnn\0

    id = USB_MakeId(
                   L"USB\\HUB_VID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,  // 4 digits
                   IdVendor);

    id = USB_MakeId(
                   L"&PID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,
                   IdProduct);

    id = USB_MakeId(
                   L"&REV_nnnn\0",
                   id,
                   &length,
                   1,  // add a null
                   4,
                   BcdDevice);

    // USB\HUB_VID_nnnn&PID_nnnn\0

    id = USB_MakeId(
                   L"USB\\HUB_VID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,  // 4 digits
                   IdVendor);

    id = USB_MakeId(
                   L"&PID_nnnn\0",
                   id,
                   &length,
                   2,  // 2 nulls
                   4,
                   IdProduct);

    return(id);
}


PWCHAR
USBH_BuildHubCompatibleIDs(
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build compatible Ids wide multi-string for the PDO based on
  * the Class and Subclass Ids.
  *
  * This function builds the compatible ids specifically for s USB hub attached
  * to a USB 2.0 host controller

  // build the following set of ids

  L"USB\\HubClass&SubClass_nn&Prot_nn\0"
  L"USB\\HubClass&SubClass_nn\0"
  L"USB\\HubClass\0"
  L"\0"

  * -- */
{
    PWCHAR id;
    ULONG length;

    id = NULL;
    length = 0;

    // "USB\\HubClass&SubClass_nn&Prot_nn\0"

    id = USB_MakeId(
                   L"USB\\HubClass&SubClass_nn\0",
                   id,
                   &length,
                   0,
                   2,  // 2 digits
                   SubClass);

    id = USB_MakeId(
                   L"&Prot_nn\0",
                   id,
                   &length,
                   1,  // add null
                   2,  // 2 digits
                   Protocol);

    // "USB\\HubClass&SubClass_nn\0"

    id = USB_MakeId(
                   L"USB\\HubClass&SubClass_nn\0",
                   id,
                   &length,
                   1,
                   2,  // 2 digits
                   SubClass);

    // "USB\\HubClass\0\0"

    id = USB_MakeId(
                   L"USB\\HubClass\0",
                   id,
                   &length,
                   2,  // 2 nulls
                   0,
                   0);

    return(id);
}

//#endif //USB2_BP


PWCHAR
USBH_BuildInstanceID(
    IN PWCHAR UniqueIdString,
    IN ULONG Length
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * returns a pointer to a copy of our unicode unique id string
  * or NULL if error.
  *
  *
  * -- */
{
    PWCHAR uniqueIdString;

    PAGED_CODE();
    USBH_KdPrint((2,"'BuildInstanceID %x\n",
                    UniqueIdString));

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    uniqueIdString = ExAllocatePoolWithTag(PagedPool,
                                           Length,
                                           USBHUB_HEAP_TAG);

    if (NULL != uniqueIdString) {
        RtlCopyMemory(uniqueIdString,
                      UniqueIdString,
                      Length);

    }

    return uniqueIdString;
}


NTSTATUS
USBH_ProcessDeviceInformation(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    BOOLEAN multiConfig = FALSE;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_ProcessDeviceInformation\n"));

    USBH_ASSERT(EXTENSION_TYPE_PORT == DeviceExtensionPort->ExtensionType);

    RtlZeroMemory(&DeviceExtensionPort->InterfaceDescriptor,
                  sizeof(DeviceExtensionPort->InterfaceDescriptor));

    USBH_KdPrint((2,"'numConfigs = %d\n",
        DeviceExtensionPort->DeviceDescriptor.bNumConfigurations));
    USBH_KdPrint((2,"'vendor id = %x\n",
        DeviceExtensionPort->DeviceDescriptor.idVendor));
    USBH_KdPrint((2,"'product id = %x\n",
        DeviceExtensionPort->DeviceDescriptor.idProduct));
    USBH_KdPrint((2,"'revision id = %x\n",
        DeviceExtensionPort->DeviceDescriptor.bcdDevice));

    //
    // assume the device is not a hub
    //
    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_IS_HUB;

    if (DeviceExtensionPort->DeviceDescriptor.bNumConfigurations > 1) {
        //
        // Multi config device, ignore muktiple interfaces
        // ie don't load the generic parent
        //
        // we get the wakeup caps from the first config
        //
        USBH_KdPrint((0,"Detected multiple configurations\n"));
        multiConfig = TRUE;
    }

    //
    // we need to get the whole configuration descriptor and parse it
    //

    ntStatus =
        USBH_GetConfigurationDescriptor(DeviceExtensionPort->PortPhysicalDeviceObject,
                                        &configurationDescriptor);


    if (NT_SUCCESS(ntStatus)) {

        // now parse out the config

        USBH_ASSERT(configurationDescriptor);

        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_REMOTE_WAKEUP_SUPPORTED;
        if (configurationDescriptor->bmAttributes &
                USB_CONFIG_REMOTE_WAKEUP) {
            DeviceExtensionPort->PortPdoFlags |=
                PORTPDO_REMOTE_WAKEUP_SUPPORTED;
        }

#ifndef MULTI_FUNCTION_SUPPORT
        //
        // In Detroit we only support one interface
        //
        configurationDescriptor->bNumInterfaces = 1;
#endif

        if ((configurationDescriptor->bNumInterfaces > 1) &&
            !multiConfig &&
            (DeviceExtensionPort->DeviceDescriptor.bDeviceClass == 0)) {

            //
            // device has multiple interfaces
            // for now we use the first one we find
            //

            // set up the interface descriptor for this
            // port to be the generic parent driver

            DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_IS_PARENT;

            USBH_KdBreak(("USB device has Multiple Interfaces\n"));

        } else {

            //
            // not a composite device
            // call USBD to locate the interface descriptor
            //
            // there can be only one.

            interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    configurationDescriptor,
                    configurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    -1, // class don'care
                    -1, // subclass, don't care
                    -1); // protocol, don't care



            if (interfaceDescriptor) {
                DeviceExtensionPort->InterfaceDescriptor = *interfaceDescriptor;
                //
                // see if this is a hub
                //

                if (interfaceDescriptor->bInterfaceClass ==
                    USB_DEVICE_CLASS_HUB) {
                    DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_IS_HUB;
                    // all hubs must support remote wakeup (ie at least propigate
                    // resume signalling

                    DeviceExtensionPort->PortPdoFlags |=
                        PORTPDO_REMOTE_WAKEUP_SUPPORTED;
                }

            } else {
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (configurationDescriptor) {
        UsbhExFreePool(configurationDescriptor);
    }

    return ntStatus;
}


BOOLEAN
USBH_ValidateSerialNumberString(
    PWCHAR DeviceId
    )

/*++

Routine Description:

    This routine stolen from ntos\io\pnpenum.c, IopFixupDeviceId, and modified
    accordingly.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device instance string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PWCHAR p;

    PAGED_CODE();

    for (p = DeviceId; *p; p++) {
        if ((*p < L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
USBH_CheckDeviceIDUnique(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT IDVendor,
    IN USHORT IDProduct,
    IN PWCHAR SerialNumberBuffer,
    IN USHORT SerialNumberBufferLength
    )
 /* ++
  *
  * Description:
  *
  * This function determines if the ID for a device on a hub is unique.
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * IDVendor
  * IDProduct
  * SerialNumberBuffer
  * SerialNumberBufferLength
  *
  * Return:
  *
  * BOOLEAN indicating whether device ID is unique or not.
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    BOOLEAN bDeviceIDUnique = TRUE;
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (childDeviceExtensionPort->DeviceDescriptor.idVendor == IDVendor &&
                childDeviceExtensionPort->DeviceDescriptor.idProduct == IDProduct &&
                childDeviceExtensionPort->SerialNumberBufferLength == SerialNumberBufferLength &&
                childDeviceExtensionPort->SerialNumberBuffer != NULL &&
                RtlCompareMemory(childDeviceExtensionPort->SerialNumberBuffer,
                                 SerialNumberBuffer,
                                 SerialNumberBufferLength) == SerialNumberBufferLength) {

                bDeviceIDUnique = FALSE;
                break;
            }
        }
    }

    return bDeviceIDUnique;
}


NTSTATUS
USBH_CreateDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN USHORT PortStatus,
    IN ULONG RetryIteration
    )
 /* ++
  *
  * Description:
  *
  * This is called when there is a new deviced connected, and enabled(via
  * reset). We will call USBD_CreateDevice and USBD_InitializDevice so that
  * it get an address and Device Descriptor. A PDO s also created for this
  * connected device and to record some relevant information such as
  * pDeviceData, puchPath and DeviceDescriptor.
  *
  * Arguments:
  *
  * pDeviceExtensionHub - the hub FDO extension that has a new connected port
  * ulPortNumber - the port that has a device connected. IsLowSpeed - to
  * indicate if the attached device is a low speed one
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PDEVICE_OBJECT deviceObjectPort = NULL;     // Initialize to NULL in case
                                                // USBD_MakePdoName fails.
    PDEVICE_EXTENSION_PORT deviceExtensionPort = NULL;
    BOOLEAN fNeedResetBeforeSetAddress = TRUE;
    UNICODE_STRING uniqueIdUnicodeString;
    ULONG nameIndex = 0;
    UNICODE_STRING pdoNameUnicodeString;
    BOOLEAN bDiagnosticMode = FALSE;
    BOOLEAN bIgnoreHWSerialNumber = FALSE;
    PWCHAR sernumbuf = NULL;
    BOOLEAN isLowSpeed, isHighSpeed;
    PVOID deviceData;

    PAGED_CODE();
    USBH_KdPrint((2,"'CreateDevice for port %x\n", PortNumber));

    isLowSpeed = (PortStatus & PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;
    isHighSpeed = (PortStatus & PORT_STATUS_HIGH_SPEED) ? TRUE : FALSE;


    //
    // First create a PDO for the connected device
    //

    do {
#ifdef USB2
        ntStatus = USBD_MakePdoNameEx(DeviceExtensionHub,
                                     &pdoNameUnicodeString,
                                     nameIndex);
#else
        ntStatus = USBD_MakePdoName(&pdoNameUnicodeString,
                                     nameIndex);
#endif

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = IoCreateDevice(UsbhDriverObject,    // Driver Object
                                      sizeof(DEVICE_EXTENSION_PORT),    // Device Extension size
                                      //NULL, // Device name
                                      &pdoNameUnicodeString,
                                      FILE_DEVICE_UNKNOWN,  // Device Type
                                                            // should look device
                                                            // class
                                      0,// Device Chars
                                      FALSE,    // Exclusive
                                      &deviceObjectPort);  // Bus Device Object
            if (!NT_SUCCESS(ntStatus)) {
                RtlFreeUnicodeString(&pdoNameUnicodeString);
            }
        }
        nameIndex++;

    } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'IoCreateDevice for port %x fail\n", PortNumber));
        USBH_ASSERT(deviceObjectPort == NULL);
        goto USBH_CreateDevice_Done;
    }

    // use the stack size from the top of the HCD stack
    deviceObjectPort->StackSize = DeviceExtensionHub->TopOfHcdStackDeviceObject->StackSize;
    USBH_KdPrint((2,"'CreatePdo StackSize=%d\n", deviceObjectPort->StackSize));

    //
    // Init port extension fields
    //
    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) deviceObjectPort->DeviceExtension;
    RtlZeroMemory(deviceExtensionPort, sizeof(DEVICE_EXTENSION_PORT));

    //
    // Init port extension fields
    //

    // don't need the name anymore
    RtlFreeUnicodeString(&pdoNameUnicodeString);

    deviceExtensionPort->ExtensionType = EXTENSION_TYPE_PORT;
    deviceExtensionPort->PortPhysicalDeviceObject = deviceObjectPort;
    deviceExtensionPort->HubExtSave =
        deviceExtensionPort->DeviceExtensionHub = DeviceExtensionHub;
    deviceExtensionPort->PortNumber = PortNumber;
    deviceExtensionPort->DeviceState = PowerDeviceD0;
    if (isLowSpeed) {
        deviceExtensionPort->PortPdoFlags = PORTPDO_LOW_SPEED_DEVICE;
        USBH_ASSERT(isHighSpeed == FALSE);
    } else if (isHighSpeed) {
        deviceExtensionPort->PortPdoFlags = PORTPDO_HIGH_SPEED_DEVICE;
        USBH_ASSERT(isLowSpeed == FALSE);
    }

    KeInitializeSpinLock(&deviceExtensionPort->PortSpinLock);

    //
    // Build a unicode unique id
    //

    USBH_ASSERT(PortNumber < 1000 && PortNumber > 0);


    RtlInitUnicodeString(&uniqueIdUnicodeString,
                         &deviceExtensionPort->UniqueIdString[0]);

    uniqueIdUnicodeString.MaximumLength =
        sizeof(deviceExtensionPort->UniqueIdString);

    ntStatus = RtlIntegerToUnicodeString((ULONG) PortNumber,
                                         10,
                                         &uniqueIdUnicodeString);

    deviceObjectPort->Flags |= DO_POWER_PAGABLE;
    deviceObjectPort->Flags &= ~DO_DEVICE_INITIALIZING;

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("AddDevice for port %x fail %x -- failed to create unique id\n", PortNumber, ntStatus));
        goto USBH_CreateDevice_Done;
    }

    //
    // call usbd to create device for this connection
    //
#ifdef USB2
    ntStatus = USBD_CreateDeviceEx(DeviceExtensionHub,
                                   &deviceExtensionPort->DeviceData,
                                   deviceObjectPort,
                                   DeviceExtensionHub->RootHubPdo,
                                   0, // optional default endpoint0 max packet
                                      // size
                                   &deviceExtensionPort->DeviceHackFlags,
                                   PortStatus,
                                   PortNumber);
#else
    ntStatus = USBD_CreateDevice(&deviceExtensionPort->DeviceData,
                                  DeviceExtensionHub->RootHubPdo,
                                  isLowSpeed,
                                  0, // optional default endpoint0 max packet
                                     // size
                                  &deviceExtensionPort->DeviceHackFlags);
                                                    // flag to indicate if
                                                    // we need a second
                                                    // reset
#endif

    if (!NT_SUCCESS(ntStatus)) {
        ENUMLOG(&DeviceExtensionHub->UsbdiBusIf,
            USBDTAG_HUB, 'cdf!', ntStatus, 0);
        USBH_KdBreak(("AddDevice for port %x fail %x\n", PortNumber, ntStatus));
        goto USBH_CreateDevice_Done;
    }
    //
    // some early versions of USB firmware could not handle the premature
    // termination of a control command.
    //
    if (fNeedResetBeforeSetAddress) {
        USBH_KdPrint((2,"'NeedResetBeforeSetAddress\n"));
        ntStatus = USBH_SyncResetPort(DeviceExtensionHub, PortNumber);
        if (!NT_SUCCESS(ntStatus)) {
           USBH_KdBreak(("Failure on second reset %x fail %x\n", PortNumber, ntStatus));
           goto USBH_CreateDevice_Done;
        }

        // For some reason, the amount of time between the GetDescriptor request
        // and the SetAddress request decreased when we switched from the older
        // monolithic UHCD.SYS to the new USBUHCI.SYS miniport.  And apparently,
        // there have been found at least two devices that were dependent on
        // the longer delay.  According to GlenS who looked at one of these
        // devices on the CATC, delta time was ~80ms with UHCD.SYS and ~35ms
        // with USBUHCI.SYS.  So, Glen found that by inserting a 50ms delay
        // here, it allows at least one of these devices to now enumerate
        // properly.  For performance reasons, we have decided to only insert
        // this delay if a previous enumeration retry has failed, so as not
        // to impact the enumeration time of all devices.

        if (RetryIteration) {
            UsbhWait(50);
        }
    }

#ifdef USB2
    ntStatus = USBD_InitializeDeviceEx(DeviceExtensionHub,
                                     deviceExtensionPort->DeviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     &deviceExtensionPort->DeviceDescriptor,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     &deviceExtensionPort->ConfigDescriptor,
                                     sizeof(USB_CONFIGURATION_DESCRIPTOR)
                                     );
#else
    ntStatus = USBD_InitializeDevice(deviceExtensionPort->DeviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     &deviceExtensionPort->DeviceDescriptor,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     &deviceExtensionPort->ConfigDescriptor,
                                     sizeof(USB_CONFIGURATION_DESCRIPTOR)
                                     );
#endif

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'InitDevice for port %x fail %x\n", PortNumber, ntStatus));
        // InitializeDevice frees the DeviceData structure on failure
        deviceExtensionPort->DeviceData = NULL;
        goto USBH_CreateDevice_Done;
    }

    // See if we are supposed to ignore the hardware serial number for
    // this device.

    status = USBH_RegQueryDeviceIgnoreHWSerNumFlag(
                    deviceExtensionPort->DeviceDescriptor.idVendor,
                    deviceExtensionPort->DeviceDescriptor.idProduct,
                    &bIgnoreHWSerialNumber);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
        // Flag was not there, don't ignore hardware serial number.
        bIgnoreHWSerialNumber = FALSE;
    }

    if (bIgnoreHWSerialNumber) {

        USBH_KdPrint((1,"'Ignoring HW serial number for device Vid_%04x/Pid_%04x\n",
            deviceExtensionPort->DeviceDescriptor.idVendor,
            deviceExtensionPort->DeviceDescriptor.idProduct));

        // Use the same flag that USBD gives us.  According to JD, though,
        // USBD uses this flag globally (e.g. set for all devices).

        deviceExtensionPort->DeviceHackFlags |= USBD_DEVHACK_DISABLE_SN;
    }

// if we can get the core spec changed to stipulate that this serial number
// to the device then we can use it instead of the port number.

    //
    // see if we have a serial number
    //
    if (deviceExtensionPort->DeviceDescriptor.iSerialNumber &&
        !(deviceExtensionPort->DeviceHackFlags & USBD_DEVHACK_DISABLE_SN)) {
#if DBG
        NTSTATUS localStatus;
#endif
        //
        // Wow, we have a device with a serial number
        // we will attempt to get the string and use it for a
        // unique id
        //
        USBH_KdPrint((1, "'Device is reporting a serial number string\n"));

        //
        // lets get that serial number
        //

        InterlockedExchangePointer(&deviceExtensionPort->SerialNumberBuffer,
                                   NULL);

#if DBG
        localStatus =
#endif
        // For now we always look for the serial number in English.

        USBH_GetSerialNumberString(deviceExtensionPort->PortPhysicalDeviceObject,
                                   &sernumbuf,
                                   &deviceExtensionPort->SerialNumberBufferLength,
                                   0x0409, // good'ol american english
                                   deviceExtensionPort->DeviceDescriptor.iSerialNumber);

        if (sernumbuf == NULL) {
            USBH_ASSERT(localStatus != STATUS_SUCCESS);
            UsbhWarning(deviceExtensionPort,
                        "Device reported a serial number string but failed the request for it\n",
                        FALSE);
        } else if (!USBH_ValidateSerialNumberString(sernumbuf)) {

            // Sigh.  The "Visioneer Strobe Pro USB" returns a bogus serial #
            // string so we need to check for that here.  If we return this
            // bogus string to PnP we blue screen.

            UsbhWarning(deviceExtensionPort,
                        "Device reported an invalid serial number string!\n",
                        FALSE);

            UsbhExFreePool(sernumbuf);
            sernumbuf = NULL;
        }

        // Check for like devices with duplicate serial numbers connected
        // to the same hub.

        if (sernumbuf &&
            !USBH_CheckDeviceIDUnique(
                DeviceExtensionHub,
                deviceExtensionPort->DeviceDescriptor.idVendor,
                deviceExtensionPort->DeviceDescriptor.idProduct,
                sernumbuf,
                deviceExtensionPort->SerialNumberBufferLength)) {

            UsbhWarning(deviceExtensionPort,
                        "Like devices with identical serial numbers connected to same hub!\n",
                        TRUE);

            UsbhExFreePool(sernumbuf);
            sernumbuf = NULL;
        }

        InterlockedExchangePointer(&deviceExtensionPort->SerialNumberBuffer,
                                   sernumbuf);
    }

    //
    // Skip serial number generation if we are in diagnostic mode.
    // (e.g. The Vid and Pid are each 0xFFFF.)
    //
    bDiagnosticMode =
        (deviceExtensionPort->DeviceDescriptor.idVendor == 0xFFFF &&
         deviceExtensionPort->DeviceDescriptor.idProduct == 0xFFFF) ? TRUE : FALSE;

    // **
    //
    // Query the device
    // 1. check for multiple interfaces (ie composite device)
    // 2. check for multiple configs (ie need configuring parent)
    // 3. check single interface device -- ie just load driver
    //

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_ProcessDeviceInformation(deviceExtensionPort);
        // compute our capabilities we will retiurn to PnP
        USBH_PdoSetCapabilities(deviceExtensionPort);
    }


//#ifdef MAX_DEBUG
//    ntStatus = STATUS_DEVICE_DATA_ERROR;
//#endif
    //
    // Note: Device will be removed when REMOVE MESSAGE is sent to the PDO
    //
    //ntStatus = STATUS_DEVICE_DATA_ERROR;
#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        // error occurred querying the device config descriptor
        USBH_KdBreak(("Get Config Descriptors Failed %x\n", ntStatus));
    }
#endif

USBH_CreateDevice_Done:

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_ENUM) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
#endif

#ifdef TEST_2X_UI
    if (deviceExtensionPort->DeviceDescriptor.idVendor == 0x045E) {
        // Set the 2.x device flag for MS devices when testing the UI.
        deviceExtensionPort->PortPdoFlags |= PORTPDO_HIGH_SPEED_DEVICE;
    }
#endif

    if (!NT_SUCCESS(ntStatus) && deviceExtensionPort) {
#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
        deviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_ENUM_ERROR;

        // remove the deviceData structure now

        deviceData = InterlockedExchangePointer(
                        &deviceExtensionPort->DeviceData,
                        NULL);

        if (deviceData) {
#ifdef USB2
            USBD_RemoveDeviceEx(DeviceExtensionHub,
                                deviceData,
                                DeviceExtensionHub->RootHubPdo,
                                0);
#else
            USBD_RemoveDevice(deviceData,
                              DeviceExtensionHub->RootHubPdo,
                              0);
#endif
        }

        sernumbuf = InterlockedExchangePointer(
                        &deviceExtensionPort->SerialNumberBuffer, NULL);

        if (sernumbuf) {
            UsbhExFreePool(sernumbuf);
        }
    }

    //
    // Note that we keep the PDO until the
    // device is physically disconnected
    // from the bus.
    //

    // According to NT pnp spec this pdo should remain

    USBH_ASSERT(DeviceExtensionHub->PortData[PortNumber - 1].DeviceObject == NULL);
    DeviceExtensionHub->PortData[PortNumber - 1].DeviceObject = deviceObjectPort;

    USBH_KdPrint((2,"'Exit CreateDevice PDO=%x\n", deviceObjectPort));

    return ntStatus;
}


PWCHAR
GetString(PWCHAR pwc, BOOLEAN MultiSZ)
{
    PWCHAR  psz, p;
    ULONG   Size;

    psz=pwc;
    while (*psz!='\0' || (MultiSZ && *(psz+1)!='\0')) {
        psz++;
    }

    Size=(ULONG)((psz-pwc+1+(MultiSZ ? 1: 0))*sizeof(*pwc));

    // We use pool here because these pointers are passed
    // to the PnP code who is responsible for freeing them
    if ((p=ExAllocatePoolWithTag(PagedPool, Size, USBHUB_HEAP_TAG))!=NULL) {
        RtlCopyMemory(p, pwc, Size);
    }

    return(p);
}


NTSTATUS
USBH_PdoQueryId(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IRP_MJ_PNP, IRP_MN_QUERY_ID.
  *
  * Arguments:
  *
  * DeviceExtensionPort - should be the PDO we created for the port device Irp
  * - the Irp
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION ioStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'IRP_MN_QUERY_ID Pdo extension=%x\n", DeviceExtensionPort));

    //
    // It should be physical device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_PORT == DeviceExtensionPort->ExtensionType);

#ifndef USBHUB20
    // Do the MS OS Descriptor stuff the first time around
    //
    if (!(DeviceExtensionPort->PortPdoFlags & PORTPDO_OS_STRING_DESC_REQUESTED))
    {
        PMS_EXT_CONFIG_DESC msExtConfigDesc;

        msExtConfigDesc = NULL;

        // Try to get the MS OS Descriptor Vendor Code from the device.  Do
        // this before any MS OS Descriptor requests.
        //
        USBH_GetMsOsVendorCode(DeviceExtensionPort->PortPhysicalDeviceObject);

        // Don't do the MS OS Descriptor stuff the next time around
        //
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_OS_STRING_DESC_REQUESTED;

        // Try to get an Extended Configuration Descriptor from the device.
        //
        msExtConfigDesc = USBH_GetExtConfigDesc(DeviceExtensionPort->PortPhysicalDeviceObject);

        // If we got an Extended Configuration Descriptor from the device, make
        // sure it is valid.
        //
        if (msExtConfigDesc &&
            USBH_ValidateExtConfigDesc(msExtConfigDesc,
                                       &DeviceExtensionPort->ConfigDescriptor)) {

            // If the Extended Configuration Descriptor contains a single
            // function which spans the all of the interfaces of the device,
            // then do not treat the device as a composite device and use the
            // Compatible and SubCompatible IDs optionally contained in the
            // descriptor.
            //
            if (msExtConfigDesc->Header.bCount == 1 &&
                msExtConfigDesc->Function[0].bFirstInterfaceNumber == 0 &&
                msExtConfigDesc->Function[0].bInterfaceCount ==
                DeviceExtensionPort->ConfigDescriptor.bNumInterfaces)
            {
                RtlCopyMemory(DeviceExtensionPort->CompatibleID,
                              msExtConfigDesc->Function[0].CompatibleID,
                              sizeof(DeviceExtensionPort->CompatibleID));

                RtlCopyMemory(DeviceExtensionPort->SubCompatibleID,
                              msExtConfigDesc->Function[0].SubCompatibleID,
                              sizeof(DeviceExtensionPort->SubCompatibleID));

                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_IS_PARENT;
            }
        }

        if (msExtConfigDesc)
        {
            UsbhExFreePool(msExtConfigDesc);
        }
    }
#endif

    switch (ioStack->Parameters.QueryId.IdType) {
    case BusQueryDeviceID:
        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR) {
            Irp->IoStatus.Information=
                (ULONG_PTR)
                USBH_BuildDeviceID(0,
                                   0,
                                   -1,
                                   FALSE);
        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR)
                USBH_BuildDeviceID(DeviceExtensionPort->DeviceDescriptor.idVendor,
                                   DeviceExtensionPort->DeviceDescriptor.idProduct,
                                   -1,
                                   DeviceExtensionPort->DeviceDescriptor.bDeviceClass
                                       == USB_DEVICE_CLASS_HUB ? TRUE : FALSE);
        }

        break;

    case BusQueryHardwareIDs:

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR) {
            Irp->IoStatus.Information=(ULONG_PTR)GetString(L"USB\\UNKNOWN\0", TRUE);
        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR)
                USBH_BuildHardwareIDs(DeviceExtensionPort->DeviceDescriptor.idVendor,
                                      DeviceExtensionPort->DeviceDescriptor.idProduct,
                                      DeviceExtensionPort->DeviceDescriptor.bcdDevice,
                                      -1,
                                      DeviceExtensionPort->DeviceDescriptor.bDeviceClass
                                       == USB_DEVICE_CLASS_HUB ? TRUE : FALSE);
        }

        break;

    case BusQueryCompatibleIDs:

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR) {
            Irp->IoStatus.Information=(ULONG_PTR)GetString(L"USB\\UNKNOWN\0", TRUE);
        } else if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_PARENT) {
            //Irp->IoStatus.Information=(ULONG)GetString(L"USB\\COMPOSITE\0", TRUE);
            Irp->IoStatus.Information =
                (ULONG_PTR) USBH_BuildCompatibleIDs(
                    DeviceExtensionPort->CompatibleID,
                    DeviceExtensionPort->SubCompatibleID,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceSubClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceProtocol,
                    TRUE,
                    DeviceExtensionPort->PortPdoFlags & PORTPDO_HIGH_SPEED_DEVICE ?
                        TRUE : FALSE);
        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR) USBH_BuildCompatibleIDs(
                    DeviceExtensionPort->CompatibleID,
                    DeviceExtensionPort->SubCompatibleID,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceSubClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceProtocol,
                    FALSE,
                    DeviceExtensionPort->PortPdoFlags & PORTPDO_HIGH_SPEED_DEVICE ?
                        TRUE : FALSE);
        }

        break;

    case BusQueryInstanceID:

        if (DeviceExtensionPort->SerialNumberBuffer) {
            PWCHAR tmp;
            ULONG length;
            //
            // allocate a buffer and copy the string to it
            //
            // NOTE: must use stock alloc function because
            // PnP frees this string.

            length = DeviceExtensionPort->SerialNumberBufferLength;
            tmp = ExAllocatePoolWithTag(PagedPool, length, USBHUB_HEAP_TAG);
            if (tmp) {
                RtlCopyMemory(tmp,
                              DeviceExtensionPort->SerialNumberBuffer,
                              length);
            }

            Irp->IoStatus.Information = (ULONG_PTR) tmp;

#if DBG
            {
            PUCHAR pch, sn;
            PWCHAR pwch;
            pch = sn = ExAllocatePoolWithTag(PagedPool, 500, USBHUB_HEAP_TAG);

            if (sn) {
                pwch = (PWCHAR) tmp;
                while(*pwch) {
                    *pch = (UCHAR) *pwch;
                    pch++;
                    pwch++;
                    if (pch-sn > 499) {
                        break;
                    }
                }
                *pch='\0';
                USBH_KdPrint((1, "'using device supplied serial number\n"));
                USBH_KdPrint((1, "'SN = :%s:\n", sn));

                ExFreePool(sn);
            }
            }
#endif

        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR) USBH_BuildInstanceID(&DeviceExtensionPort->UniqueIdString[0],
                                             sizeof(DeviceExtensionPort->UniqueIdString));
        }
        break;

    default:
        USBH_KdBreak(("PdoBusExtension Unknown BusQueryId\n"));
        // IrpAssert: Must not change Irp->IoStatus.Status for bogus IdTypes,
        // so return original status here.
        return Irp->IoStatus.Status;
    }

    if (Irp->IoStatus.Information == 0) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_PdoStopDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;
    PVOID deviceData;

    USBH_KdPrint((1,
        "'Stopping PDO %x\n",
        DeviceExtensionPort->PortPhysicalDeviceObject));

    LOGENTRY(LOG_PNP, "Spdo", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {
        idleIrp = DeviceExtensionPort->IdleNotificationIrp;
        DeviceExtensionPort->IdleNotificationIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

        if (idleIrp->Cancel) {
            idleIrp = NULL;
        }

        if (idleIrp) {
            IoSetCancelRoutine(idleIrp, NULL);
        }

        LOGENTRY(LOG_PNP, "IdSX", 0, DeviceExtensionPort, idleIrp);
        USBH_KdPrint((1,"'PDO %x stopping, failing idle notification request IRP %x\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject, idleIrp));
    }

    if (DeviceExtensionPort->WaitWakeIrp) {

        waitWakeIrp = DeviceExtensionPort->WaitWakeIrp;
        DeviceExtensionPort->WaitWakeIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &=
            ~PORTPDO_REMOTE_WAKEUP_ENABLED;

        if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
            waitWakeIrp = NULL;

            // Must decrement pending request count here because
            // we don't complete the IRP below and USBH_WaitWakeCancel
            // won't either because we have cleared the IRP pointer
            // in the device extension above.

            USBH_DEC_PENDING_IO_COUNT(DeviceExtensionPort->DeviceExtensionHub);
        }

        USBH_KdPrint((1,
        "'Completing Wake Irp for PDO %x with STATUS_CANCELLED\n",
            DeviceExtensionPort->PortPhysicalDeviceObject));

        LOGENTRY(LOG_PNP, "kilW", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

        // JOES: Should we decrement portwakeirps for the hub and cancel
        // hub's WW IRP if zero?
    }

    //
    // Finally, release the cancel spin lock
    //
    IoReleaseCancelSpinLock(irql);

    if (idleIrp) {
        idleIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
    }

    if (waitWakeIrp) {

        USBH_ASSERT(DeviceExtensionPort->DeviceExtensionHub);

        USBH_CompletePowerIrp(DeviceExtensionPort->DeviceExtensionHub,
                              waitWakeIrp,
                              STATUS_CANCELLED);
    }

    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_STARTED;
    //
    // indicate that we will need a reset if we start up again.
    //
    DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
    RtlCopyMemory(&DeviceExtensionPort->OldDeviceDescriptor,
                  &DeviceExtensionPort->DeviceDescriptor,
                  sizeof(DeviceExtensionPort->DeviceDescriptor));
    //
    // remove the device data now to free
    // up the bus resources
    //

    deviceData = InterlockedExchangePointer(
                    &DeviceExtensionPort->DeviceData,
                    NULL);

    if (deviceData) {
#ifdef USB2
       ntStatus = USBD_RemoveDeviceEx(DeviceExtensionPort->DeviceExtensionHub,
                                    deviceData,
                                    DeviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                    0);
#else
       ntStatus = USBD_RemoveDevice(deviceData,
                                    DeviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                    0);
#endif

       USBH_SyncDisablePort(DeviceExtensionPort->DeviceExtensionHub,
                            DeviceExtensionPort->PortNumber);
    }

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK) {
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_SYM_LINK;
        ntStatus = USBH_SymbolicLink(FALSE,
                                     DeviceExtensionPort,
                                     NULL);
#if DBG
        if (!NT_SUCCESS(ntStatus)) {
            USBH_KdBreak(("StopDevice  USBH_SymbolicLink failed = %x\n",
                           ntStatus));
        }
#endif
    }

    return ntStatus;
}

NTSTATUS
USBH_PdoStartDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    LPGUID lpGuid;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    USBH_KdPrint((1,
        "'Starting PDO %x VID %x PID %x\n", deviceObject,
            DeviceExtensionPort->DeviceDescriptor.idVendor,
            DeviceExtensionPort->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "Tpdo", DeviceExtensionPort,
            DeviceExtensionPort->PortPhysicalDeviceObject,
            0);

    if (DeviceExtensionPort->DeviceExtensionHub == NULL &&
        DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
        // if DeviceExtensionHub is NULL then this is a
        // restart after remove we need to reset the
        // backpointer to the owning hub in this case
        DeviceExtensionPort->DeviceExtensionHub =
            DeviceExtensionPort->HubExtSave;

    }
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    if (deviceExtensionHub) {

        ENUMLOG(&deviceExtensionHub->UsbdiBusIf,
                    USBDTAG_HUB, 'pdoS',
                    (ULONG_PTR) DeviceExtensionPort->PortPhysicalDeviceObject,
                    DeviceExtensionPort->PortNumber);

        USBHUB_SetDeviceHandleData(deviceExtensionHub,
                                   DeviceExtensionPort->PortPhysicalDeviceObject,
                                   DeviceExtensionPort->DeviceData);


    }
#if DBG
    if (USBH_Debug_Flags & USBH_DEBUGFLAG_BREAK_PDO_START) {
        TEST_TRAP();
    }
#endif
    //
    // create a symbolic link
    //
    ntStatus = STATUS_SUCCESS;

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
        lpGuid = (LPGUID)&GUID_CLASS_USBHUB;
    } else {
        lpGuid = (LPGUID)&GUID_CLASS_USB_DEVICE;
    }

    ntStatus = USBH_SymbolicLink(TRUE,
                                 DeviceExtensionPort,
                                 lpGuid);
    if (NT_SUCCESS(ntStatus)) {
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_SYM_LINK;
    }
#if DBG
      else {
        USBH_KdBreak(("StartDevice  USBH_SymbolicLink failed = %x\n",
                       ntStatus));
    }
#endif

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
        ntStatus = USBH_RestoreDevice(DeviceExtensionPort, FALSE);
        //
        // note: we will fail the start if we could not
        // restore the device.
        //
    }

    DeviceExtensionPort->DeviceState = PowerDeviceD0;
    DeviceExtensionPort->PortPdoFlags |= PORTPDO_STARTED;

#ifdef WMI_SUPPORT
    if (NT_SUCCESS(ntStatus) &&
        !(DeviceExtensionPort->PortPdoFlags & PORTPDO_WMI_REGISTERED)) {

        PWMILIB_CONTEXT wmiLibInfo;

        wmiLibInfo = &DeviceExtensionPort->WmiLibInfo;

        wmiLibInfo->GuidCount = sizeof (USB_PortWmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
        ASSERT(NUM_PORT_WMI_SUPPORTED_GUIDS == wmiLibInfo->GuidCount);

        wmiLibInfo->GuidList = USB_PortWmiGuidList;
        wmiLibInfo->QueryWmiRegInfo = USBH_PortQueryWmiRegInfo;
        wmiLibInfo->QueryWmiDataBlock = USBH_PortQueryWmiDataBlock;
        wmiLibInfo->SetWmiDataBlock = NULL;
        wmiLibInfo->SetWmiDataItem = NULL;
        wmiLibInfo->ExecuteWmiMethod = NULL;
        wmiLibInfo->WmiFunctionControl = NULL;

        IoWMIRegistrationControl(DeviceExtensionPort->PortPhysicalDeviceObject,
                                 WMIREG_ACTION_REGISTER
                                 );

        DeviceExtensionPort->PortPdoFlags |= PORTPDO_WMI_REGISTERED;
    }
#endif

    return ntStatus;

}


NTSTATUS
USBH_PdoRemoveDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PWCHAR sernumbuf;
    KIRQL irql;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;
    PVOID deviceData;

    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    USBH_KdPrint((1,
        "'Removing PDO %x\n",
        DeviceExtensionPort->PortPhysicalDeviceObject));

    LOGENTRY(LOG_PNP, "Rpdo", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

    // **
    // no references to hub after first remove is processed
    // if we have access to the parent at the time of
    // remove this is passed to us as a parameter
    DeviceExtensionPort->DeviceExtensionHub = NULL;

    if (DeviceExtensionHub) {
        ENUMLOG(&DeviceExtensionHub->UsbdiBusIf,
                        USBDTAG_HUB, 'pdoR',
                        (ULONG_PTR) DeviceExtensionPort->PortPhysicalDeviceObject,
                        DeviceExtensionPort->PortNumber);

    }

    // **
    // if we have access to the hub and it is not in D0 then we will
    // power it.
    //
    // In the case where a device was removed with handles still open,
    // we will receive the remove request at a later time.  Be sure that
    // the hub is not selectively suspended in this case.

    if (DeviceExtensionHub &&
        DeviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        USBH_HubSetD0(DeviceExtensionHub);
    }

// ***
    // **
    // cancel any notifocation irp that may be pending
    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {
        idleIrp = DeviceExtensionPort->IdleNotificationIrp;
        DeviceExtensionPort->IdleNotificationIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

        if (idleIrp->Cancel) {
            idleIrp = NULL;
        }

        if (idleIrp) {
            IoSetCancelRoutine(idleIrp, NULL);
        }

        LOGENTRY(LOG_PNP, "IdRX", 0, DeviceExtensionPort, idleIrp);
        USBH_KdPrint((1,"'PDO %x being removed, failing idle notification request IRP %x\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject, idleIrp));
    }

    // **
    // Kill any wake irps for this PDO now
    if (DeviceExtensionPort->WaitWakeIrp) {

        waitWakeIrp = DeviceExtensionPort->WaitWakeIrp;
        DeviceExtensionPort->WaitWakeIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &=
            ~PORTPDO_REMOTE_WAKEUP_ENABLED;


        if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
            waitWakeIrp = NULL;

            USBH_ASSERT(DeviceExtensionHub);
            // Must decrement pending request count here because
            // we don't complete the IRP below and USBH_WaitWakeCancel
            // won't either because we have cleared the IRP pointer
            // in the device extension above.

            USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
        }

        USBH_KdPrint((1,
        "'Completing Wake Irp for PDO %x with STATUS_CANCELLED\n",
            DeviceExtensionPort->PortPhysicalDeviceObject));

        LOGENTRY(LOG_PNP, "kilR", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

        // JOES: Should we decrement portwakeirps for the hub and cancel
        // hub's WW IRP if zero?
    }

    //
    // Finally, release the cancel spin lock
    //
    IoReleaseCancelSpinLock(irql);
//***

    if (idleIrp) {
        idleIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
    }

    if (waitWakeIrp) {

        USBH_ASSERT(DeviceExtensionHub);

        USBH_CompletePowerIrp(DeviceExtensionHub,
                              waitWakeIrp,
                              STATUS_CANCELLED);
    }

    //
    // This PDO will need reset if this is a soft-remove from
    // device manager. In this case the PDO will not actually
    // be deleted.
    //
    DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK) {
        ntStatus = USBH_SymbolicLink(FALSE,
                                     DeviceExtensionPort,
                                     NULL);
        if (NT_SUCCESS(ntStatus)) {
            DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_SYM_LINK;
        }
#if DBG
          else {
            USBH_KdBreak(("RemoveDevice  USBH_SymbolicLink failed = %x\n",
                           ntStatus));
        }
#endif
    }

    deviceData = InterlockedExchangePointer(
                    &DeviceExtensionPort->DeviceData,
                    NULL);

    LOGENTRY(LOG_PNP, "RMdd", DeviceExtensionPort,
                deviceData, DeviceExtensionHub);

    if (deviceData) {

        //
        // DeviceData should have been deleted when the hub was removed
        //

        USBH_ASSERT(DeviceExtensionHub != NULL);
#ifdef USB2
        ntStatus = USBD_RemoveDeviceEx(DeviceExtensionHub,
                                     deviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     0);
#else
        ntStatus = USBD_RemoveDevice(deviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     0);
#endif

        // note the special case:
        // if our port data structure still points to this PDO then
        // we need to disable the port (the device is still listening on
        // the address we just freed.
        // otherwise we just leave the port alone -- the device has been
        // replaced with another one.

        if (DeviceExtensionHub->PortData != NULL &&
            (DeviceExtensionHub->PortData[
                DeviceExtensionPort->PortNumber - 1].DeviceObject == deviceObject)) {

            USBH_SyncDisablePort(DeviceExtensionHub,
                                 DeviceExtensionPort->PortNumber);
        }
    }


    // Failure cases:
    //      USBD_RemoveDevice
    //      USBH_SymbolicLink
    // Do we really want to leak a devobj here?
    LOGENTRY(LOG_PNP, "RRR", deviceObject, 0, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        PPORT_DATA portData = NULL;
        //
        // update our record in the Hub extension
        //

        LOGENTRY(LOG_PNP, "rpdo", deviceObject, 0, 0);

        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_STARTED;

        if (DeviceExtensionHub &&
            DeviceExtensionHub->PortData != NULL) {

            portData =
                &DeviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];


            // port data should be valid for this port
            USBH_ASSERT(portData);

            // jdunn vinma
            // legacy 'ESD' flag
            //
            // We get here if the PDO is removed either because the FDO is
            // removed or the device was reported gone.
            //
            // if this flag is set the hub will loose its reference to this
            // PDO
            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
                PDEVICE_OBJECT pdo;

                pdo = portData->DeviceObject;

                LOGENTRY(LOG_PNP, "pd1", pdo, 0, 0);

                // do we still have a reference to the PDO in the hub?
                // if so loose it now.
                // This cannot happen in the FDO remove case because we delete
                // the PDO reference from port data. This only happens in the
                // case where PNP removes the device.
                if (pdo) {

                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;
                    // two cases to be concerned with, either PNP knows about
                    // this PDO or it does not
                    if (PDO_EXT(pdo)->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT) {
                        // PnP still knows about this device, ie it thinks it
                        // is present and is sending a non-remove remove. We
                        // will need to notify PnP that it is gone.
                        //
                        InsertTailList(&DeviceExtensionHub->DeletePdoList,
                                       &PDO_EXT(pdo)->DeletePdoLink);
                    } else {
                        // we should only get here in the case where we have
                        // told PNP the device is gone but for some reason
                        // we kept a ref to the PDO.  This should probably be
                        // investigated.

                        TEST_TRAP();
                    }

                }
            }

        }


        // When is a remove really a remove?
        // We must determine if deleting the PDO is the approprite
        //
        // if PnP thinks the device is gone then we can delete it
        if (!(DeviceExtensionPort->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT)) {

            LOGENTRY(LOG_PNP, "Dpdo",
                deviceObject, portData, 0);

            // we should only delete one time, this flag indicates the
            // 'deleted' state so that we can process other irps approriatly
            USBH_ASSERT(!(DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETED_PDO));

            DeviceExtensionPort->PortPdoFlags |= PORTPDO_DELETED_PDO;

            // perform one time delete operations

            //
            // Free the device serial number string.  Only do this if we
            // are deleting the device.
            //

            sernumbuf = InterlockedExchangePointer(
                            &DeviceExtensionPort->SerialNumberBuffer,
                            NULL);

                if (sernumbuf) {
                    UsbhExFreePool(sernumbuf);
                }


#ifdef WMI_SUPPORT
            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_WMI_REGISTERED) {
                // de-register with WMI
                IoWMIRegistrationControl(deviceObject,
                                         WMIREG_ACTION_DEREGISTER);

                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_WMI_REGISTERED;
            }
#endif


            // this is the last step of a successful removal, any transfers
            // that may be pening will be flushed out by this routine. After
            // this point the driver may unload.

            if (DeviceExtensionHub) {
                USBHUB_FlushAllTransfers(DeviceExtensionHub);
            }

            USBH_KdPrint((1,
                "'Deleting PDO %x\n",
                 deviceObject));

            LOGENTRY(LOG_PNP, "Xpdo",
                deviceObject, 0, 0);

            IoDeleteDevice(deviceObject);

            // jdunn vinma.
            // The hub driver should have no references to this object.
        }
    }

    if (DeviceExtensionHub) {
        USBH_CheckHubIdle(DeviceExtensionHub);
    }

    return ntStatus;
}

VOID
USBH_PdoSetCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  *  Init the internal capabilities structure for the PDO that we
  *  will return on a query capabilities IRP.
  * Argument:
  *
  * Return:
  *
  *   none
  *
  * -- */
{
    PDEVICE_CAPABILITIES deviceCapabilities;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    SYSTEM_POWER_STATE i;

    PAGED_CODE();

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT(deviceExtensionHub);

    USBH_KdPrint((2,"'PdoQueryCapabilities \n"));

    //
    // Get the packet.
    //
    deviceCapabilities = &DeviceExtensionPort->DevCaps;

    //
    // Set the capabilities.
    //
    deviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    deviceCapabilities->Version = 1;

    deviceCapabilities->Address = DeviceExtensionPort->PortNumber;
    deviceCapabilities->Removable = TRUE;
    if (DeviceExtensionPort->SerialNumberBuffer) {
        deviceCapabilities->UniqueID = TRUE;
    } else {
        deviceCapabilities->UniqueID = FALSE;
    }
    deviceCapabilities->RawDeviceOK = FALSE;

    //
    // fill in the the device state capabilities from the
    // table we saved from the pdo.
    //

    RtlCopyMemory(&deviceCapabilities->DeviceState[0],
                  &deviceExtensionHub->DeviceState[0],
                  sizeof(deviceExtensionHub->DeviceState));

    deviceCapabilities->SystemWake = deviceExtensionHub->SystemWake;
    deviceCapabilities->DeviceWake = deviceExtensionHub->DeviceWake;

    deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;

    //
    // deepest device state we can wake up the system with,
    // set to PowerDeviceD0 if wakeup not supported
    // by the device
    //
    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_REMOTE_WAKEUP_SUPPORTED) {
        deviceCapabilities->DeviceWake = PowerDeviceD2;
        deviceCapabilities->WakeFromD2 = TRUE;
        deviceCapabilities->WakeFromD1 = TRUE;
        deviceCapabilities->WakeFromD0 = TRUE;
        deviceCapabilities->DeviceD2 = TRUE;
        deviceCapabilities->DeviceD1 = TRUE;

        for (i=PowerSystemSleeping1; i<=PowerSystemHibernate; i++) {
            if (i > deviceCapabilities->SystemWake) {
                deviceCapabilities->DeviceState[i] = PowerDeviceD3;
            } else {
                deviceCapabilities->DeviceState[i] = PowerDeviceD2;
            }
        }

    } else {
        deviceCapabilities->DeviceWake = PowerDeviceD0;

        for (i=PowerSystemSleeping1; i<=PowerSystemHibernate; i++) {
            deviceCapabilities->DeviceState[i] = PowerDeviceD3;
        }
    }

    return;
}


NTSTATUS
USBH_PdoQueryCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES).
  * Supposedly, this is a message forwarded by port device Fdo.
  *
  * Argument:
  *
  * DeviceExtensionPort - This is a a Pdo extension we created for the port
  * device. Irp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;
    SYSTEM_POWER_STATE i;
    USHORT sizeSave;
    USHORT versionSave;

    PAGED_CODE();
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'PdoQueryCapabilities Pdo %x\n", deviceObject));

    //
    // Get the packet.
    //
    deviceCapabilities = ioStack->
        Parameters.DeviceCapabilities.Capabilities;

    // size and length are passed in
    // we should not modify these, all
    // others we set as appropriate for
    // USB (see DDK)

    // save values pased in
    sizeSave = deviceCapabilities->Size;
    versionSave = deviceCapabilities->Version;

    //
    // Set the capabilities.
    //
    RtlCopyMemory(deviceCapabilities,
                  &DeviceExtensionPort->DevCaps,
                  sizeof(*deviceCapabilities));

    // restore saved values
    deviceCapabilities->Size = sizeSave;
    deviceCapabilities->Version = versionSave;


#if DBG
    if (deviceCapabilities->SurpriseRemovalOK) {
        UsbhWarning(DeviceExtensionPort,
                    "QUERY_CAPS called with SurpriseRemovalOK = TRUE\n",
                    FALSE);
    }
#endif

#if DBG
    {
        ULONG i;
        USBH_KdPrint((1, "'HUB PDO: Device Caps\n"));
        USBH_KdPrint(
            (1, "'UniqueId = %d Removable = %d SurpriseOK = %d RawDeviceOK = %x\n",
            deviceCapabilities->UniqueID,
            deviceCapabilities->Removable,
            deviceCapabilities->SurpriseRemovalOK,
            deviceCapabilities->RawDeviceOK));

        USBH_KdPrint((1, "'Device State Map:\n"));

        for (i=0; i< PowerSystemHibernate; i++) {
            USBH_KdPrint((1, "'-->S%d = D%d\n", i-1,
                 deviceCapabilities->DeviceState[i]-1));
        }
    }
#endif

    return (STATUS_SUCCESS);
}


NTSTATUS
USBH_PdoPnP(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN PBOOLEAN CompleteIrp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    LPGUID lpGuid;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;

    PAGED_CODE();

    // this flag will cause the request to be complete,
    // if we wish to pass it on the we set the flag to FALSE.
    *CompleteIrp = TRUE;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    USBH_KdPrint((2,"'PnP Power Pdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_START_DEVICE Pdo %x", deviceObject));
        ntStatus = USBH_PdoStartDevice(DeviceExtensionPort, Irp);
#if 0
        USBH_PdoStartDevice

        USBH_KdPrint((1,
            "'Starting PDO %x VID %x PID %x\n", deviceObject,
                DeviceExtensionPort->DeviceDescriptor.idVendor,
                DeviceExtensionPort->DeviceDescriptor.idProduct));

        LOGENTRY(LOG_PNP, "Tpdo", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                0);

        if (DeviceExtensionPort->DeviceExtensionHub == NULL &&
            DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
            // if DeviceExtensionHub is NULL then this is a
            // restart after remove we need to reset the
            // backpointer to the owning hub in this case
            DeviceExtensionPort->DeviceExtensionHub =
                DeviceExtensionPort->HubExtSave;

        }
        deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
        if (deviceExtensionHub) {
            ENUMLOG(&deviceExtensionHub->UsbdiBusIf,
                        USBDTAG_HUB, 'pdoS',
                        (ULONG_PTR) DeviceExtensionPort->PortPhysicalDeviceObject,
                        DeviceExtensionPort->PortNumber);
        }
#if DBG
        if (USBH_Debug_Flags & USBH_DEBUGFLAG_BREAK_PDO_START) {
            TEST_TRAP();
        }
#endif
        //
        // create a symbolic link
        //
        ntStatus = STATUS_SUCCESS;

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
            lpGuid = (LPGUID)&GUID_CLASS_USBHUB;
        } else {
            lpGuid = (LPGUID)&GUID_CLASS_USB_DEVICE;
        }

        ntStatus = USBH_SymbolicLink(TRUE,
                                     DeviceExtensionPort,
                                     lpGuid);
        if (NT_SUCCESS(ntStatus)) {
            DeviceExtensionPort->PortPdoFlags |= PORTPDO_SYM_LINK;
        }
#if DBG
          else {
            USBH_KdBreak(("StartDevice  USBH_SymbolicLink failed = %x\n",
                           ntStatus));
        }
#endif

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
            ntStatus = USBH_RestoreDevice(DeviceExtensionPort, FALSE);
            //
            // note: we will fail the start if we could not
            // restore the device.
            //
        }

        DeviceExtensionPort->DeviceState = PowerDeviceD0;
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_STARTED;

#ifdef WMI_SUPPORT
        if (NT_SUCCESS(ntStatus) &&
            !(DeviceExtensionPort->PortPdoFlags & PORTPDO_WMI_REGISTERED)) {

            PWMILIB_CONTEXT wmiLibInfo;

            wmiLibInfo = &DeviceExtensionPort->WmiLibInfo;

            wmiLibInfo->GuidCount = sizeof (USB_PortWmiGuidList) /
                                     sizeof (WMIGUIDREGINFO);
            ASSERT(NUM_PORT_WMI_SUPPORTED_GUIDS == wmiLibInfo->GuidCount);

            wmiLibInfo->GuidList = USB_PortWmiGuidList;
            wmiLibInfo->QueryWmiRegInfo = USBH_PortQueryWmiRegInfo;
            wmiLibInfo->QueryWmiDataBlock = USBH_PortQueryWmiDataBlock;
            wmiLibInfo->SetWmiDataBlock = NULL;
            wmiLibInfo->SetWmiDataItem = NULL;
            wmiLibInfo->ExecuteWmiMethod = NULL;
            wmiLibInfo->WmiFunctionControl = NULL;

            IoWMIRegistrationControl(DeviceExtensionPort->PortPhysicalDeviceObject,
                                     WMIREG_ACTION_REGISTER
                                     );

            DeviceExtensionPort->PortPdoFlags |= PORTPDO_WMI_REGISTERED;
        }
#endif
#endif
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_STOP_DEVICE Pdo %x", deviceObject));
        ntStatus = USBH_PdoStopDevice(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_REMOVE_DEVICE Pdo %x", deviceObject));
        // pass the backref to the hub, if this is the fisrt remove
        // then it will be valid. If it is a second remove the hub
        // is potentially gone
        ntStatus = USBH_PdoRemoveDevice(DeviceExtensionPort,
                                        DeviceExtensionPort->DeviceExtensionHub,
                                        Irp);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_QUERY_STOP_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_CANCEL_STOP_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_QUERY_REMOVE_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_CANCEL_REMOVE_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        USBH_KdPrint((1,"'IRP_MN_SURPRISE_REMOVAL Pdo %x\n", deviceObject));
        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK) {
            ntStatus = USBH_SymbolicLink(FALSE,
                                         DeviceExtensionPort,
                                         NULL);
            if (NT_SUCCESS(ntStatus)) {
                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_SYM_LINK;
            }
#if DBG
            else {
                USBH_KdBreak(("SurpriseRemove: USBH_SymbolicLink failed = %x\n",
                               ntStatus));
            }
#endif
        }

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        USBH_KdPrint((1,"'IRP_MN_QUERY_PNP_DEVICE_STATE Pdo %x\n", deviceObject));
        if (DeviceExtensionPort->PortPdoFlags &
            (PORTPDO_DEVICE_ENUM_ERROR |
             PORTPDO_DEVICE_FAILED |
             PORTPDO_NOT_ENOUGH_POWER |
             PORTPDO_OVERCURRENT)) {
            Irp->IoStatus.Information
                |= PNP_DEVICE_FAILED;
        }

        LOGENTRY(LOG_PNP, "pnpS", DeviceExtensionPort,
                 DeviceExtensionPort->PortPhysicalDeviceObject,
                 Irp->IoStatus.Information);

        USBH_KdPrint((1,"'IRP_MN_QUERY_PNP_DEVICE_STATE Pdo %x -- state: %x\n",
            deviceObject,
            Irp->IoStatus.Information));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        USBH_KdPrint((2,"'IRP_MN_QUERY_CAPABILITIES Pdo %x\n", deviceObject));
        ntStatus = USBH_PdoQueryCapabilities(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:
        USBH_KdPrint((2,"'IRP_MN_QUERY_DEVICE_TEXT Pdo %x\n", deviceObject));
        ntStatus = USBH_PdoQueryDeviceText(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_QUERY_ID:
        USBH_KdPrint((2,"'IRP_MN_QUERY_ID Pdo %x\n", deviceObject));
        ntStatus = USBH_PdoQueryId(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        // Adrian says that once PnP sends this IRP, the PDO is valid for
        // PnP functions like IoGetDeviceProperty, etc.
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_VALID_FOR_PNP_FUNCTION;
#ifndef USBHUB20
        // And since we know that the PDO is valid and the DevNode now exists,
        // this would also be a good time to handle the MS ExtPropDesc.
        //
        USBH_InstallExtPropDesc(deviceObject);
#endif
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_INTERFACE:
        // forward the Q_INTERFACE to the root hub PDO
        {
        PIO_STACK_LOCATION irpStack;

        *CompleteIrp = FALSE;
        // set the Interface specific data to the device handle

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
               &USB_BUS_INTERFACE_USBDI_GUID,
               sizeof(GUID)) == sizeof(GUID)) {
            irpStack->Parameters.QueryInterface.InterfaceSpecificData =
                DeviceExtensionPort->DeviceData;
        }

        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionPort->DeviceExtensionHub->RootHubPdo);
        }
        break;

    case  IRP_MN_QUERY_BUS_INFORMATION:
        {
        // return the standard USB GUID
        PPNP_BUS_INFORMATION busInfo;

        USBH_KdPrint((1,"'IRP_MN_QUERY_BUS_INFORMATION Pdo %x\n", deviceObject));

        busInfo = ExAllocatePoolWithTag(PagedPool, sizeof(PNP_BUS_INFORMATION), USBHUB_HEAP_TAG);

        if (busInfo == NULL) {
           ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            busInfo->BusTypeGuid = GUID_BUS_TYPE_USB;
            busInfo->LegacyBusType = PNPBus;
            busInfo->BusNumber = 0;
            Irp->IoStatus.Information = (ULONG_PTR) busInfo;
            ntStatus = STATUS_SUCCESS;
        }
        }

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        // this is a leaf node, we return the status passed
        // to us unless it is a call to TargetRelations
        USBH_KdPrint((2,"'IRP_MN_QUERY_DEVICE_RELATIONS Pdo %x type = %d\n",
            deviceObject,irpStack->Parameters.QueryDeviceRelations.Type));

        if (irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation) {

            PDEVICE_RELATIONS deviceRelations = NULL;

            deviceRelations = ExAllocatePoolWithTag(PagedPool,
                sizeof(*deviceRelations), USBHUB_HEAP_TAG);

            if (deviceRelations == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                ObReferenceObject(DeviceExtensionPort->PortPhysicalDeviceObject);
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] =
                    DeviceExtensionPort->PortPhysicalDeviceObject;
                ntStatus = STATUS_SUCCESS;
            }

            Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

            USBH_KdPrint((1, "'Query Relations, TargetDeviceRelation (PDO) %x complete\n",
                DeviceExtensionPort->PortPhysicalDeviceObject));

        } else {
            ntStatus = Irp->IoStatus.Status;
        }
        break;

    default:
        USBH_KdBreak(("PdoPnP unknown (%d) PnP message Pdo %x\n",
                      MinorFunction, deviceObject));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
    }

    USBH_KdPrint((2,"'PdoPnP exit %x\n", ntStatus));

    return ntStatus;
}


VOID
USBH_ResetPortWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to process a port reset.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_RESET_WORK_ITEM workItemReset;

    workItemReset = Context;
    USBH_PdoIoctlResetPort(workItemReset->DeviceExtensionPort,
                           workItemReset->Irp);

    workItemReset->DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_FAILED;

    UsbhExFreePool(workItemReset);
}


BOOLEAN
USBH_DoesHubNeedWaitWake(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function determines if a hub needs a WW IRP posted (i.e. children
  * have WW IRP's posted).
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * BOOLEAN indicating whether the hub needs a WW IRP posted or not.
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    KIRQL irql;
    BOOLEAN bHubNeedsWaitWake;
    ULONG i;

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    IoAcquireCancelSpinLock(&irql);

    bHubNeedsWaitWake = FALSE;  // Assume that the hub does not need a WW IRP.

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (childDeviceExtensionPort->PortPdoFlags &
                PORTPDO_REMOTE_WAKEUP_ENABLED) {

                bHubNeedsWaitWake = TRUE;
                break;
            }
        }
    }

    IoReleaseCancelSpinLock(irql);

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return bHubNeedsWaitWake;
}


VOID
USBH_CheckHubIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function determines if a hub is ready to be idled out, and does so
  * if ready.
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    KIRQL irql;
    BOOLEAN bAllIdle, submitIdle = FALSE;
    ULONG i;

    LOGENTRY(LOG_PNP, "hCkI", DeviceExtensionHub, DeviceExtensionHub->HubFlags,
        DeviceExtensionHub->CurrentPowerState);
    USBH_KdPrint((1,"'Hub Check Idle %x\n", DeviceExtensionHub));

    KeAcquireSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, &irql);

    if (DeviceExtensionHub->HubFlags & HUBFLAG_IN_IDLE_CHECK) {
        KeReleaseSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, irql);
        return;
    }

    DeviceExtensionHub->HubFlags |= HUBFLAG_IN_IDLE_CHECK;
    KeReleaseSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, irql);

    rootHubDevExt = USBH_GetRootHubDevExt(DeviceExtensionHub);

    if (rootHubDevExt->CurrentSystemPowerState != PowerSystemWorking) {

        LOGENTRY(LOG_PNP, "hCkS", DeviceExtensionHub, DeviceExtensionHub->HubFlags,
            rootHubDevExt->CurrentSystemPowerState);
        USBH_KdPrint((1,"'CheckHubIdle: System not at S0, fail\n"));

        goto USBH_CheckHubIdleDone;
    }

#ifdef NEW_START
    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_OK_TO_ENUMERATE)) {

        USBH_KdPrint((1,"'Defer idle\n"));
        goto USBH_CheckHubIdleDone;
    }
#endif

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP) ||
        (DeviceExtensionHub->HubFlags &
         (HUBFLAG_DEVICE_STOPPING |
          HUBFLAG_HUB_GONE |
          HUBFLAG_HUB_FAILURE |
          HUBFLAG_CHILD_DELETES_PENDING |
          HUBFLAG_WW_SET_D0_PENDING |
          HUBFLAG_POST_ESD_ENUM_PENDING |
          HUBFLAG_HUB_HAS_LOST_BRAINS))) {

        LOGENTRY(LOG_PNP, "hCkN", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'CheckHubIdle: Hub not started, stopping, removed, failed, powering up, or delete pending, fail\n"));

        goto USBH_CheckHubIdleDone;
    }

    if (DeviceExtensionHub->ChangeIndicationWorkitemPending) {

        DeviceExtensionHub->HubFlags |= HUBFLAG_NEED_IDLE_CHECK;

        LOGENTRY(LOG_PNP, "hCkP", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'CheckHubIdle: ChangeIndication workitem pending, skip\n"));

        goto USBH_CheckHubIdleDone;
    }

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_NEED_IDLE_CHECK;

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    IoAcquireCancelSpinLock(&irql);

    bAllIdle = TRUE;    // Assume that everyone wants to idle.

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (!childDeviceExtensionPort->IdleNotificationIrp) {
                bAllIdle = FALSE;
                break;
            }
        }
    }

    if (bAllIdle &&
        !(DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP)) {

        // We're gonna submit the idle irp once we release the spin lock.
        DeviceExtensionHub->HubFlags |= HUBFLAG_PENDING_IDLE_IRP;
        KeResetEvent(&DeviceExtensionHub->SubmitIdleEvent);
        submitIdle = TRUE;

    }

    IoReleaseCancelSpinLock(irql);

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (bAllIdle) {

        LOGENTRY(LOG_PNP, "hCkA", DeviceExtensionHub, 0, 0);
        USBH_KdPrint((1,"'CheckHubIdle: All devices on hub %x idle!\n",
            DeviceExtensionHub));

        // And when all the child PDO's have been idled, we can now idle
        // the hub itself.
        //
        // BUGBUG: What do we do if this fails?  Do we even care?

        if (submitIdle) {
            USBH_FdoSubmitIdleRequestIrp(DeviceExtensionHub);
        }
    }

USBH_CheckHubIdleDone:

    KeAcquireSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, &irql);
    DeviceExtensionHub->HubFlags &= ~HUBFLAG_IN_IDLE_CHECK;
    KeReleaseSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, irql);

    ;
}


NTSTATUS
USBH_PortIdleNotificationRequest(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function handles a request by a USB client driver to tell us
  * that the device wants to idle (selective suspend).
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension
  * Irp - the request packet
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    PDRIVER_CANCEL oldCancelRoutine;
    NTSTATUS ntStatus = STATUS_PENDING;
    KIRQL irql;

    LOGENTRY(LOG_PNP, "IdlP", DeviceExtensionPort, Irp, 0);
    USBH_KdPrint((1,"'Idle request %x, IRP %x\n", DeviceExtensionPort, Irp));

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp != NULL) {

        IoReleaseCancelSpinLock(irql);

        LOGENTRY(LOG_PNP, "Idl2", DeviceExtensionPort, Irp, 0);
        UsbhWarning(DeviceExtensionPort,
                    "Idle IRP submitted while already one pending\n",
                    TRUE);

        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_DEVICE_BUSY;
    }

    idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
        IoGetCurrentIrpStackLocation(Irp)->\
            Parameters.DeviceIoControl.Type3InputBuffer;

    if (!idleCallbackInfo || !idleCallbackInfo->IdleCallback) {

        LOGENTRY(LOG_PNP, "Idl4", DeviceExtensionPort, Irp, 0);
        USBH_KdPrint((1,"'Idle request: No callback provided with idle IRP!\n"));
        IoReleaseCancelSpinLock(irql);

        Irp->IoStatus.Status = STATUS_NO_CALLBACK_ACTIVE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_NO_CALLBACK_ACTIVE;
    }

    //
    //  Must set cancel routine before checking Cancel flag.
    //

    oldCancelRoutine = IoSetCancelRoutine(Irp, USBH_PortIdleNotificationCancelRoutine);
    USBH_ASSERT(!oldCancelRoutine);

    if (Irp->Cancel) {
        //
        //  Irp was cancelled. Check whether cancel routine was called.
        //
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine) {
            //
            //  Cancel routine was NOT called. So complete the irp here.
            //
            LOGENTRY(LOG_PNP, "Idl3", DeviceExtensionPort, Irp, 0);
            USBH_KdPrint((1,"'Idle request: Idle IRP already cancelled, complete it here!\n"));
            IoReleaseCancelSpinLock(irql);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            ntStatus = STATUS_CANCELLED;

        } else {
            //
            //  Cancel routine was called, and it will complete the IRP
            //  as soon as we drop the spinlock.
            //  Return STATUS_PENDING so we don't touch the IRP.
            //
            LOGENTRY(LOG_PNP, "Idl5", DeviceExtensionPort, Irp, 0);
            USBH_KdPrint((1,"'Idle request: Idle IRP already cancelled, don't complete here!\n"));
            IoMarkIrpPending(Irp);
            IoReleaseCancelSpinLock(irql);

            ntStatus = STATUS_PENDING;
        }

    } else {

        // IRP was not cancelled, so keep it.

        DeviceExtensionPort->IdleNotificationIrp = Irp;
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_IDLE_NOTIFIED;
        IoMarkIrpPending(Irp);

        IoReleaseCancelSpinLock(irql);

        ntStatus = STATUS_PENDING;

        // See if we are ready to idle out this hub.

        USBH_CheckHubIdle(deviceExtensionHub);
    }

    return ntStatus;
}


#ifdef DRM_SUPPORT

NTSTATUS
USBH_PdoSetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG ContentId;
    PIO_STACK_LOCATION ioStackLocation;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_OBJECT forwardDeviceObject;
    USBD_PIPE_HANDLE hPipe;
    NTSTATUS ntStatus;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    ioStackLocation = IoGetCurrentIrpStackLocation(irp);
    deviceExtensionPort = ioStackLocation->DeviceObject->DeviceExtension;
    forwardDeviceObject = deviceExtensionPort->DeviceExtensionHub->TopOfHcdStackDeviceObject;
    hPipe = pKsProperty->Context;
    ContentId = pvData->ContentId;

    return pKsProperty->DrmForwardContentToDeviceObject(ContentId, forwardDeviceObject, hPipe);
}

#endif


NTSTATUS
USBH_PdoDispatch(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp)
 /*
  * Description:
  *
  *     This function handles calls to PDOs we have created
  *     since we are the bottom driver for the PDO it is up
  *     to us to complete the irp -- with one exception.
  *
  *     api calls to the USB stack are forwarded directly
  *     to the PDO for the root hub which is owned by the USB
  *     HC.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PURB urb;

    USBH_KdPrint((2,"'PdoDispatch DeviceExtension %x Irp %x\n", DeviceExtensionPort, Irp));
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:
        USBH_KdPrint((2,"'HUB PDO IRP_MJ_CREATE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_CLOSE:
        USBH_KdPrint((2,"'HUB PDO IRP_MJ_CLOSE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
        ULONG ioControlCode;

        USBH_KdPrint((2,"'Internal Device Control\n"));

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETED_PDO) {
#if DBG
            UsbhWarning(DeviceExtensionPort,
                "Client Device Driver is sending requests to a device that has been removed.\n",
                (BOOLEAN)((USBH_Debug_Trace_Level > 0) ? TRUE : FALSE));
#endif

            ntStatus = STATUS_DEVICE_NOT_CONNECTED;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }

// Take this out.  This breaks SyncDisablePort, AbortInterruptPipe.
//
//        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
//            ntStatus = STATUS_DELETE_PENDING;
//            USBH_CompleteIrp(Irp, ntStatus);
//            break;
//        }

        if (DeviceExtensionPort->DeviceState != PowerDeviceD0) {
#if DBG
            UsbhWarning(DeviceExtensionPort,
                "Client Device Driver is sending requests to a device in a low power state.\n",
                (BOOLEAN)((USBH_Debug_Trace_Level > 0) ? TRUE : FALSE));
#endif

            // Must use an error code here that can be mapped to Win32 in
            // rtl\generr.c

            ntStatus = STATUS_DEVICE_POWERED_OFF;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }

        ioControlCode =
            ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
        //
        // old comments:
        // **
        // The following code used to check for HUBFLAG_HUB_GONE,
        // HUBFLAG_DEVICE_STOPPING, and HUBFLAG_HUB_HAS_LOST_BRAINS also,
        // but doing so breaks the case where a hub with a downstream
        // device is disconnected or powered off and the driver for the
        // child device sends an AbortPipe request, but the driver hangs
        // waiting for the pending requests to complete which never do
        // because the USBPORT never saw the AbortPipe request.
        // **
        //
        //
        // jd new comments:
        //
        // the backref to the parent is always removed when the PDO processes
        // the remove irp so it is safe to fail APIs when DevExtHub is NULL.
        // The device handle is gone at this point so there should be no traffic
        // pending is usbport.
        //
        // there is one execption -- the GET_RRO_HUB_PDO api. we need to let
        // this one thru since the hub driver will call it from add device

        if (IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO == ioControlCode) {
            deviceExtensionHub = DeviceExtensionPort->HubExtSave;
        }

        if (!deviceExtensionHub) {
            ntStatus = STATUS_DEVICE_BUSY;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }
        USBH_ASSERT(deviceExtensionHub);

        switch (ioControlCode) {

        case IOCTL_INTERNAL_USB_GET_HUB_COUNT:

            //
            // This PDO belongs to a hub, bump the count and pass
            // on to the parent hub that this hub is connected to

            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
                PULONG count;
                //
                // bump the count and pass on to our PDO
                //
                count = ioStackLocation->Parameters.Others.Argument1;
                (*count)++;

                // bump the count for this hub and pass on to next PDO

                ntStatus = USBH_SyncGetRootHubPdo(deviceExtensionHub->TopOfStackDeviceObject,
                                                  NULL,
                                                  NULL,
                                                  count);

                USBH_CompleteIrp(Irp, ntStatus);

            } else {
                ntStatus = STATUS_INVALID_PARAMETER;
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME:
            {
            PUSB_HUB_NAME hubName;
            ULONG length;

            length = PtrToUlong( ioStackLocation->Parameters.Others.Argument2 );
            hubName = ioStackLocation->Parameters.Others.Argument1;

            ntStatus = USBHUB_GetControllerName(deviceExtensionHub,
                                                hubName,
                                                length);
            }
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
            //ntStatus = USBH_PassIrp(Irp,
            //                        deviceExtensionHub->RootHubPdo);
            {
            PUSB_BUS_NOTIFICATION busInfo;

            busInfo = ioStackLocation->Parameters.Others.Argument1;

            ntStatus = USBHUB_GetBusInfoDevice(deviceExtensionHub,
                                               DeviceExtensionPort,
                                               busInfo);
            }
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:

            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
                ntStatus = USBH_PassIrp(Irp,
                                        deviceExtensionHub->RootHubPdo);
            } else {
                //
                // if this is not a hub return NULL for the root hub pdo
                // so that the hub driver will act as parent
                //
                PDEVICE_OBJECT *rootHubPdo;
                rootHubPdo = ioStackLocation ->Parameters.Others.Argument1;

                *rootHubPdo = NULL;

                ntStatus = STATUS_SUCCESS;

                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_URB:
            //
            // note: we forward apis on from here in case a filter driver
            // was inserted above the PDO for the device.
            //

            urb = ioStackLocation->Parameters.Others.Argument1;
            urb->UrbHeader.UsbdDeviceHandle = DeviceExtensionPort->DeviceData;

            if (DeviceExtensionPort->DeviceData == NULL) {
                //ntStatus = STATUS_DEVICE_NOT_CONNECTED;
                //USBH_CompleteIrp(Irp, ntStatus);
                ENUMLOG(&deviceExtensionHub->UsbdiBusIf,
                    USBDTAG_HUB, 'dev!', 0, DeviceExtensionPort->PortNumber);
                urb->UrbHeader.UsbdDeviceHandle = (PVOID) (-1);
                ntStatus = USBH_PassIrp(Irp,
                                        deviceExtensionHub->TopOfHcdStackDeviceObject);

            } else {
                ntStatus = USBH_PdoUrbFilter(DeviceExtensionPort,
                                             Irp);
            }
            break;

        case IOCTL_INTERNAL_USB_GET_PORT_STATUS:

            ntStatus = USBH_PdoIoctlGetPortStatus(DeviceExtensionPort,
                                                  Irp);
            break;

        case IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE:

            {
            PUSB_DEVICE_HANDLE *p;

            p = ioStackLocation->Parameters.Others.Argument1;
            *p = DeviceExtensionPort->DeviceData;

            ntStatus = STATUS_SUCCESS;
            }

            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_INTERNAL_USB_RESET_PORT:

            if (DeviceExtensionPort->PortPdoFlags & (PORTPDO_RESET_PENDING |
                                                     PORTPDO_CYCLED)) {
                ntStatus = STATUS_UNSUCCESSFUL;
                USBH_CompleteIrp(Irp, ntStatus);
            } else {

                PUSBH_RESET_WORK_ITEM workItemReset;

                //
                // Schedule a work item to process this reset.
                //
                workItemReset = UsbhExAllocatePool(NonPagedPool,
                                                   sizeof(USBH_RESET_WORK_ITEM));

                if (workItemReset) {

                    DeviceExtensionPort->PortPdoFlags |= PORTPDO_RESET_PENDING;

                    workItemReset->DeviceExtensionPort = DeviceExtensionPort;
                    workItemReset->Irp = Irp;

                    ntStatus = STATUS_PENDING;
                    IoMarkIrpPending(Irp);

                    ExInitializeWorkItem(&workItemReset->WorkQueueItem,
                                         USBH_ResetPortWorker,
                                         workItemReset);

                    LOGENTRY(LOG_PNP, "rITM", DeviceExtensionPort,
                        &workItemReset->WorkQueueItem, 0);

                    ExQueueWorkItem(&workItemReset->WorkQueueItem,
                                    DelayedWorkQueue);

                    // The WorkItem is freed by USBH_ResetPortWorker()
                    // Don't try to access the WorkItem after it is queued.

                } else {
                    //
                    // could not queue the work item
                    // re-
                    // in case the condition is temporary

                    TEST_TRAP();
                    ntStatus = STATUS_UNSUCCESSFUL;
                    USBH_CompleteIrp(Irp, ntStatus);
                }
            }
            break;

        case IOCTL_INTERNAL_USB_ENABLE_PORT:

            ntStatus = USBH_PdoIoctlEnablePort(DeviceExtensionPort,
                                               Irp);
            break;

        case IOCTL_INTERNAL_USB_CYCLE_PORT:

            ntStatus = USBH_PdoIoctlCyclePort(DeviceExtensionPort,
                                              Irp);
            break;

        case IOCTL_INTERNAL_USB_GET_HUB_NAME:

            ntStatus = USBH_IoctlHubSymbolicName(DeviceExtensionPort,
                                                 Irp);

            break;

        case IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO:
            {
            PDEVICE_OBJECT *parent;
            PULONG portNumber;
            PDEVICE_OBJECT *rootHubPdo;

            // return Parents PDO
            parent = ioStackLocation->Parameters.Others.Argument1;
            if (parent) {
                *parent = deviceExtensionHub->PhysicalDeviceObject;
            }

            // return port number
            portNumber = ioStackLocation->Parameters.Others.Argument2;
            if (portNumber) {
                *portNumber = DeviceExtensionPort->PortNumber;
            }

            // return bus context (root hub pdo)
            rootHubPdo = ioStackLocation->Parameters.Others.Argument4;
            if (rootHubPdo) {
                *rootHubPdo = deviceExtensionHub->RootHubPdo;
            }

            ntStatus = STATUS_SUCCESS;

            USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:

            ntStatus = USBH_PortIdleNotificationRequest(DeviceExtensionPort, Irp);
            break;

        default:
            USBH_KdPrint((2,"'InternalDeviceControl IOCTL unknown\n"));
            ntStatus = Irp->IoStatus.Status;
            USBH_CompleteIrp(Irp, ntStatus);
        }
        break;

        }

    case IRP_MJ_DEVICE_CONTROL:
    {
        ULONG ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
        switch (ioControlCode) {

#ifdef DRM_SUPPORT

        case IOCTL_KS_PROPERTY:
            ntStatus = KsPropertyHandleDrmSetContentId(Irp, USBH_PdoSetContentId);
            USBH_CompleteIrp(Irp, ntStatus);
            break;
#endif

        case IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER:
            ntStatus = STATUS_NOT_SUPPORTED;
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        default:
            // Unknown Irp, shouldn't be here.
            USBH_KdBreak(("Unhandled IOCTL for Pdo %x IoControlCode %x\n",
                       deviceObject, ioControlCode));
            ntStatus = Irp->IoStatus.Status;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }
        break;

    }

    case IRP_MJ_PNP:
        {
        BOOLEAN completeIrp;

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));
        ntStatus =
            USBH_PdoPnP(DeviceExtensionPort,
                        Irp,
                        ioStackLocation->MinorFunction,
                        &completeIrp);
        if (completeIrp) {
            USBH_CompleteIrp(Irp, ntStatus);
        }
        }
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));
        ntStatus = USBH_PdoPower(DeviceExtensionPort, Irp, ioStackLocation->MinorFunction);
        //
        // power routines handle irp completion
        //
        break;

#ifdef WMI_SUPPORT
    case IRP_MJ_SYSTEM_CONTROL:
        USBH_KdPrint((2,"'PDO IRP_MJ_SYSTEM_CONTROL\n"));
        ntStatus =
            USBH_PortSystemControl(DeviceExtensionPort, Irp);
        break;
#endif

    default:

        USBH_KdBreak(("Unhandled Irp for Pdo %x Irp_Mj %x\n",
                       deviceObject, ioStackLocation->MajorFunction));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    }

    USBH_KdPrint((2,"' exit USBH_PdoDispatch Object %x Status %x\n",
                  deviceObject, ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_ResetDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN KeepConfiguration,
    IN ULONG RetryIteration
    )
 /* ++
  *
  * Description:
  *
  * Given a port device object re-create the USB device attached to it
  *
  * Arguments:
  *
  * DeviceExtensionHub - the hub FDO extension that has a new connected port
  * PortNumber - the port that has a device connected. IsLowSpeed - to
  *     indicate if the attached device is a low speed one
  *
  * Return:
  *
  * this function returns an error if the device could not be created or
  * if the device is different from the previous device.
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObjectPort;
    PDEVICE_EXTENSION_PORT deviceExtensionPort = NULL;
    BOOLEAN fNeedResetBeforeSetAddress = TRUE;
    PPORT_DATA portData;
    BOOLEAN isLowSpeed;
    PVOID deviceData, oldDeviceData = NULL;
    PORT_STATE portState;
    USHORT portStatus;

    PAGED_CODE();
    USBH_KdPrint((2,"'ResetDevice for port %x\n", PortNumber));

    LOGENTRY(LOG_PNP, "rst1",
                DeviceExtensionHub,
                PortNumber,
                0);

    // validate that there is actually a device still conected
    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    if (!(NT_SUCCESS(ntStatus) &&
          (portState.PortStatus & PORT_STATUS_CONNECT))) {

        // error or no device connected

        LOGENTRY(LOG_PNP, "rstx",
                DeviceExtensionHub,
                PortNumber,
                ntStatus);

        return STATUS_UNSUCCESSFUL;
    }

    // Don't allow QBR while we are resetting this device because QBR will
    // toss any PDO for a port that does not have the connect bit set,
    // and this will be the case for this device after we have reset the port
    // until we have finished resetting it.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    oldDeviceData = NULL;

    LOGENTRY(LOG_PNP, "resD", DeviceExtensionHub,
                 PortNumber,
                 KeepConfiguration);

    //
    // First get the PDO for the connected device
    //

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    deviceObjectPort = portData->DeviceObject;
    if (!deviceObjectPort) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBH_ResetDevice_Done;
    }

    deviceExtensionPort =
        (PDEVICE_EXTENSION_PORT) deviceObjectPort->DeviceExtension;

    portStatus = portData->PortState.PortStatus;
    isLowSpeed = (portData->PortState.PortStatus &
                               PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;

    LOGENTRY(LOG_PNP, "resP", DeviceExtensionHub,
                 deviceObjectPort,
                 deviceExtensionPort->DeviceData);

#if DBG
    if (KeepConfiguration) {
        USBH_ASSERT(deviceExtensionPort->DeviceData != NULL);
    }
#endif

    deviceData = InterlockedExchangePointer(
                    &deviceExtensionPort->DeviceData,
                    NULL);

    if (deviceData == NULL) {
        // device data is null if we are restoring a device associated
        // with an existing pdo (ie remove-refresh)
        oldDeviceData = NULL;
        LOGENTRY(LOG_PNP, "rstn", ntStatus, PortNumber, oldDeviceData);
    } else {

        if (deviceExtensionPort->PortPdoFlags & PORTPDO_DD_REMOVED) {
            oldDeviceData = deviceData;
            LOGENTRY(LOG_PNP, "rst0", ntStatus, PortNumber, oldDeviceData);
        } else {
#ifdef USB2
            ntStatus = USBD_RemoveDeviceEx(DeviceExtensionHub,
                                         deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         (UCHAR) (KeepConfiguration ?
                                             USBD_KEEP_DEVICE_DATA : 0));
#else
            ntStatus = USBD_RemoveDevice(deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         (UCHAR) (KeepConfiguration ?
                                             USBD_KEEP_DEVICE_DATA : 0));
#endif

            oldDeviceData = deviceData;
            LOGENTRY(LOG_PNP, "rst2", ntStatus, PortNumber, oldDeviceData);
            deviceExtensionPort->PortPdoFlags |= PORTPDO_DD_REMOVED;
        }

    }
    //
    // reset the port
    //
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_SyncResetPort(DeviceExtensionHub, PortNumber);
        LOGENTRY(LOG_PNP, "rst3", ntStatus, PortNumber, oldDeviceData);
    }

    // for USB 2 we won't know if the device is high speed until after reset
    // refresh status now
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                          PortNumber,
                                          (PUCHAR) &portData->PortState,
                                          sizeof(portData->PortState));
        portStatus = portData->PortState.PortStatus;
    }

    if (NT_SUCCESS(ntStatus)) {
        //
        // call usbd to create device for this connection
        //
#ifdef USB2
        ntStatus = USBD_CreateDeviceEx(DeviceExtensionHub,
                                       &deviceExtensionPort->DeviceData,
                                       deviceObjectPort,
                                       DeviceExtensionHub->RootHubPdo,
                                       0, // optional default endpoint0 max packet
                                          // size
                                       &deviceExtensionPort->DeviceHackFlags,
                                       portStatus,
                                       PortNumber);
#else
        ntStatus = USBD_CreateDevice(&deviceExtensionPort->DeviceData,
                                      DeviceExtensionHub->RootHubPdo,
                                      isLowSpeed,
                                      0, // optional default endpoint0 max packet
                                         // size
                                      &deviceExtensionPort->DeviceHackFlags);
                                                        // flag to indicate if
                                                        // we need a second
                                                        // reset
#endif

#if DBG
        if (UsbhPnpTest & PNP_TEST_FAIL_RESTORE) {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
#endif
        LOGENTRY(LOG_PNP, "rst4", ntStatus, PortNumber,
            deviceExtensionPort->DeviceData);
    }

    //
    // some early versions of USB firmware could not handle the premature
    // termination of a control command.
    //

    if (fNeedResetBeforeSetAddress && NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'NeedResetBeforeSetAddress\n"));
        ntStatus = USBH_SyncResetPort(DeviceExtensionHub, PortNumber);
#if DBG
        if (!NT_SUCCESS(ntStatus)) {
           USBH_KdBreak(("Failure on second reset %x fail %x\n", PortNumber, ntStatus));
        }
#endif

        // For some reason, the amount of time between the GetDescriptor request
        // and the SetAddress request decreased when we switched from the older
        // monolithic UHCD.SYS to the new USBUHCI.SYS miniport.  And apparently,
        // there have been found at least two devices that were dependent on
        // the longer delay.  According to GlenS who looked at one of these
        // devices on the CATC, delta time was ~80ms with UHCD.SYS and ~35ms
        // with USBUHCI.SYS.  So, Glen found that by inserting a 50ms delay
        // here, it allows at least one of these devices to now enumerate
        // properly.  For performance reasons, we have decided to only insert
        // this delay if a previous enumeration retry has failed, so as not
        // to impact the enumeration time of all devices.

        if (RetryIteration) {
            UsbhWait(50);
        }

        LOGENTRY(LOG_PNP, "rst5", ntStatus, PortNumber,
            deviceExtensionPort->DeviceData);
    }

    if (NT_SUCCESS(ntStatus)) {
#ifdef USB2
        ntStatus = USBD_InitializeDeviceEx(DeviceExtensionHub,
                                         deviceExtensionPort->DeviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         &deviceExtensionPort->DeviceDescriptor,
                                         sizeof(USB_DEVICE_DESCRIPTOR),
                                         &deviceExtensionPort->ConfigDescriptor,
                                         sizeof(USB_CONFIGURATION_DESCRIPTOR));
#else
        ntStatus = USBD_InitializeDevice(deviceExtensionPort->DeviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         &deviceExtensionPort->DeviceDescriptor,
                                         sizeof(USB_DEVICE_DESCRIPTOR),
                                         &deviceExtensionPort->ConfigDescriptor,
                                         sizeof(USB_CONFIGURATION_DESCRIPTOR));
#endif
        if (!NT_SUCCESS(ntStatus)) {
            // InitializeDevice frees the DeviceData structure on failure
            deviceExtensionPort->DeviceData = NULL;
        }

        LOGENTRY(LOG_PNP, "rst6", ntStatus, PortNumber,
            deviceExtensionPort->DeviceData);
    }


    if (NT_SUCCESS(ntStatus) && KeepConfiguration) {
        // device is now addressed, restore the old config if possible
#ifdef USB2
        ntStatus = USBD_RestoreDeviceEx(DeviceExtensionHub,
                                        oldDeviceData,
                                        deviceExtensionPort->DeviceData,
                                        DeviceExtensionHub->RootHubPdo);
#else
        ntStatus = USBD_RestoreDevice(oldDeviceData,
                                      deviceExtensionPort->DeviceData,
                                      DeviceExtensionHub->RootHubPdo);
#endif

        LOGENTRY(LOG_PNP, "rst7", ntStatus, PortNumber,
            oldDeviceData);

        if (!NT_SUCCESS(ntStatus)) {
            // if we fail here remove the newly created device

            deviceData = InterlockedExchangePointer(
                            &deviceExtensionPort->DeviceData,
                            NULL);

#ifdef USB2
            USBD_RemoveDeviceEx(DeviceExtensionHub,
                              deviceData,
                              DeviceExtensionHub->RootHubPdo,
                              0);
#else
            USBD_RemoveDevice(deviceData,
                              DeviceExtensionHub->RootHubPdo,
                              0);
#endif

            LOGENTRY(LOG_PNP, "rst8", ntStatus, PortNumber,
                oldDeviceData);

            USBH_SyncDisablePort(DeviceExtensionHub,
                                 PortNumber);

            ntStatus = STATUS_NO_SUCH_DEVICE;
            goto USBH_ResetDevice_Done;
        }
    }

    if (!NT_SUCCESS(ntStatus)) {

        //
        // we have a failure, device data should be freed
        //

        USBH_KdPrint((2,"'InitDevice (reset) for port %x failed %x\n",
            PortNumber, ntStatus));

        LOGENTRY(LOG_PNP, "rst!", ntStatus, PortNumber,
                oldDeviceData);

        //
        // note: oldDeviceData may be null
        //

        deviceData = InterlockedExchangePointer(
                        &deviceExtensionPort->DeviceData,
                        oldDeviceData);

        if (deviceData != NULL) {
            //
            // we need to remove the device data we created in the restore
            // attempt
            //
#ifdef USB2
            ntStatus = USBD_RemoveDeviceEx(DeviceExtensionHub,
                                         deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         0);
#else
            ntStatus = USBD_RemoveDevice(deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         FALSE);
#endif
            LOGENTRY(LOG_PNP, "rst9", ntStatus, PortNumber,
                    oldDeviceData);
        }

        //
        // disable the port, device is in a bad state
        //

        // NOTE: we don't disable the port on failed reset here
        // in case we need to retry
        //USBH_SyncDisablePort(DeviceExtensionHub,
        //                     PortNumber);

        // possibly signal the device has been removed
        //
        USBH_KdPrint((0,"'Warning: device/port reset failed\n"));

    } else {
        deviceExtensionPort->PortPdoFlags &= ~PORTPDO_DD_REMOVED;
        LOGENTRY(LOG_PNP, "rsOK", ntStatus, PortNumber,
                oldDeviceData);
    }

USBH_ResetDevice_Done:

    USBH_KdPrint((2,"'Exit Reset PDO=%x\n", deviceObjectPort));

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return ntStatus;
}


NTSTATUS
USBH_RestoreDevice(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN BOOLEAN KeepConfiguration
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * DeviceExtensionHub - the hub FDO extension that has a new connected port
  *
  * Return:
  *
  * this function returns an error if the device could not be created or
  * if the device is different from the previous device.
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PPORT_DATA portData;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    ULONG count = 0;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    ASSERT_HUB(deviceExtensionHub);

    if (!deviceExtensionHub) {
        return STATUS_UNSUCCESSFUL;
    }

    portData = &deviceExtensionHub->PortData[
                    DeviceExtensionPort->PortNumber - 1];

    LOGENTRY(LOG_PNP, "RSdv", DeviceExtensionPort,
                deviceExtensionHub,
                DeviceExtensionPort->PortNumber);

    //
    // doule check that this device did not disaaper on us

    //

    LOGENTRY(LOG_PNP, "chkD",
                DeviceExtensionPort->PortPhysicalDeviceObject,
                portData->DeviceObject,
                0);

    if (DeviceExtensionPort->PortPhysicalDeviceObject !=
        portData->DeviceObject) {
        TEST_TRAP();

        return STATUS_UNSUCCESSFUL;
    }

    //
    // we need to refresh the port data since it was lost on the stop
    //
    ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portData->PortState,
                                      sizeof(portData->PortState));

    USBH_ASSERT(DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET);

    // try the reset three times

    if (NT_SUCCESS(ntStatus)) {
        do {
            LOGENTRY(LOG_PNP, "tryR", count, ntStatus, 0);
            ntStatus = USBH_ResetDevice(deviceExtensionHub,
                                        DeviceExtensionPort->PortNumber,
                                        KeepConfiguration,
                                        count);
            count++;
            if (NT_SUCCESS(ntStatus) || ntStatus == STATUS_NO_SUCH_DEVICE) {
                break;
            }
#if DBG
            if (count == 1) {

                UsbhWarning(NULL,
                            "USB device failed first reset attempt in USBH_RestoreDevice\n",
                            (BOOLEAN)((USBH_Debug_Trace_Level >= 3) ? TRUE : FALSE));
            }
#endif

            //
            // Sometimes the MS USB speakers need a little more time.
            //
            UsbhWait(1000);

        } while (count < USBH_MAX_ENUMERATION_ATTEMPTS);
    }

    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_NEED_RESET;

    //
    // If the device could not be properly restored then do not allow any
    // requests to it.
    //
    if (ntStatus != STATUS_SUCCESS) {

        USBH_KdPrint((0,"'Warning: device/port restore failed\n"));

        LOGENTRY(LOG_PNP, "RSd!", DeviceExtensionPort,
                    deviceExtensionHub,
                    DeviceExtensionPort->PortNumber);

        DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_FAILED;
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_ENUM_ERROR;

        // Generate a WMI event so UI can inform the user.
        USBH_PdoEvent(deviceExtensionHub, DeviceExtensionPort->PortNumber);

    } else {
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_FAILED;
    }

    USBH_KdBreak(("'USBH_RestoreDevice = %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_PdoQueryDeviceText(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES).
  * Supposedly, this is a message forwarded by port device Fdo.
  *
  * Argument:
  *
  * DeviceExtensionPort - This is a a Pdo extension we created for the port
  * device. Irp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION ioStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    DEVICE_TEXT_TYPE deviceTextType;
    LANGID languageId;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PWCHAR deviceText;
    ULONG ulBytes = 0;

    PAGED_CODE();
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    deviceTextType = ioStack->
            Parameters.QueryDeviceText.DeviceTextType;

    // Validate DeviceTextType for IrpAssert

    if (deviceTextType != DeviceTextDescription &&
        deviceTextType != DeviceTextLocationInformation) {

        USBH_KdPrint((2, "'PdoQueryDeviceText called with bogus DeviceTextType\n"));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
        goto USBH_PdoQueryDeviceTextDone;
    }

    languageId = (LANGID)(ioStack->Parameters.QueryDeviceText.LocaleId >> 16);

    USBH_KdPrint((2,"'PdoQueryDeviceText Pdo %x type = %x, lang = %x locale %x\n",
            deviceObject, deviceTextType, languageId, ioStack->Parameters.QueryDeviceText.LocaleId));

    if (!languageId) {
        languageId = 0x0409;    // Use English if no language ID.
    }

    //
    // See if the device supports strings.  For non compliant device mode
    // we won't even try.
    //

    if (DeviceExtensionPort->DeviceData == NULL ||
        DeviceExtensionPort->DeviceDescriptor.iProduct == 0 ||
        (DeviceExtensionPort->DeviceHackFlags & USBD_DEVHACK_DISABLE_SN) ||
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR)) {
        // string descriptor
        USBH_KdBreak(("no product string\n", deviceObject));
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

        if (usbString) {

QDT_Retry:
            ntStatus = USBH_CheckDeviceLanguage(deviceObject,
                                                languageId);

            if (NT_SUCCESS(ntStatus)) {
                //
                // Device supports our language, get the string.
                //

                ntStatus = USBH_SyncGetStringDescriptor(deviceObject,
                                                        DeviceExtensionPort->DeviceDescriptor.iProduct, //index
                                                        languageId, //langid
                                                        usbString,
                                                        MAXIMUM_USB_STRING_LENGTH,
                                                        NULL,
                                                        TRUE);

                if (!NT_SUCCESS(ntStatus) && languageId != 0x409) {

                    // We are running a non-English flavor of the OS, but the
                    // attached USB device does not contain device text in
                    // the requested language.  Let's try again for English.

                    languageId = 0x0409;
                    goto QDT_Retry;
                }

                if (NT_SUCCESS(ntStatus) &&
                    usbString->bLength <= sizeof(UNICODE_NULL)) {

                    ntStatus = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(ntStatus)) {
                    //
                    // return the string
                    //

                    //
                    // must use stock alloc function because the caller frees the
                    // buffer
                    //
                    // note: the descriptor header is the same size as
                    // a unicode NULL so we don't have to adjust the size
                    //

                    deviceText = ExAllocatePoolWithTag(PagedPool, usbString->bLength, USBHUB_HEAP_TAG);
                    if (deviceText) {
                        RtlZeroMemory(deviceText, usbString->bLength);
                        RtlCopyMemory(deviceText, &usbString->bString[0],
                            usbString->bLength - sizeof(UNICODE_NULL));

                        Irp->IoStatus.Information = (ULONG_PTR) deviceText;

                        USBH_KdBreak(("Returning Device Text %x\n", deviceText));
                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } else if (languageId != 0x409) {

                // We are running a non-English flavor of the OS, but the
                // attached USB device does support the requested language.
                // Let's try again for English.

                languageId = 0x0409;
                goto QDT_Retry;
            }

            UsbhExFreePool(usbString);

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(ntStatus) && GenericUSBDeviceString) {
        USBH_KdPrint((2, "'No product string for devobj (%x), returning generic string\n", deviceObject));

        STRLEN(ulBytes, GenericUSBDeviceString);

        ulBytes += sizeof(UNICODE_NULL);

        deviceText = ExAllocatePoolWithTag(PagedPool, ulBytes, USBHUB_HEAP_TAG);
        if (deviceText) {
            RtlZeroMemory(deviceText, ulBytes);
            RtlCopyMemory(deviceText,
                          GenericUSBDeviceString,
                          ulBytes);
            Irp->IoStatus.Information = (ULONG_PTR) deviceText;
            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

USBH_PdoQueryDeviceTextDone:

    return ntStatus;
}

#ifdef _WIN64
#define BAD_POINTER ((PVOID)0xFFFFFFFFFFFFFFFE)
#else
#define BAD_POINTER ((PVOID)0xFFFFFFFE)
#endif
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))


NTSTATUS
USBH_SymbolicLink(
    BOOLEAN CreateFlag,
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    LPGUID lpGuid
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;


    if (CreateFlag){

        /*
         *  Create the symbolic link
         */
        ntStatus = IoRegisterDeviceInterface(
                    DeviceExtensionPort->PortPhysicalDeviceObject,
                    lpGuid,
                    NULL,
                    &DeviceExtensionPort->SymbolicLinkName);

        if (NT_SUCCESS(ntStatus)) {

            /*
             *  Now set the symbolic link for the association and store it..
             */
            //USBH_ASSERT(ISPTR(pdoExt->name));

            //
            // (lonnym): Previously, the following call was being made with
            // &DeviceExtensionPort->PdoName passed as the second parameter.
            // Code review this change, to see whether or not you still need to keep
            // this information around.
            //

            // write the symbolic name to the registry
            {
                WCHAR hubNameKey[] = L"SymbolicName";

                USBH_SetPdoRegistryParameter (
                    DeviceExtensionPort->PortPhysicalDeviceObject,
                    &hubNameKey[0],
                    sizeof(hubNameKey),
                    &DeviceExtensionPort->SymbolicLinkName.Buffer[0],
                    DeviceExtensionPort->SymbolicLinkName.Length,
                    REG_SZ,
                    PLUGPLAY_REGKEY_DEVICE);
            }

            ntStatus = IoSetDeviceInterfaceState(&DeviceExtensionPort->SymbolicLinkName, TRUE);
        }
    } else {

        /*
         *  Disable the symbolic link
         */
        if (ISPTR(DeviceExtensionPort->SymbolicLinkName.Buffer)) {
            ntStatus = IoSetDeviceInterfaceState(&DeviceExtensionPort->SymbolicLinkName, FALSE);
            ExFreePool( DeviceExtensionPort->SymbolicLinkName.Buffer );
            DeviceExtensionPort->SymbolicLinkName.Buffer = BAD_POINTER;
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    UNICODE_STRING keyNameUnicodeString;

    PAGED_CODE();

    RtlInitUnicodeString(&keyNameUnicodeString, KeyName);

    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     DevInstKeyType,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);


    if (NT_SUCCESS(ntStatus)) {
/*
        RtlInitUnicodeString(&keyName, L"DeviceFoo");
        ZwSetValueKey(handle,
                      &keyName,
                      0,
                      REG_DWORD,
                      ComplienceFlags,
                      sizeof(*ComplienceFlags));
*/

        USBH_SetRegistryKeyValue(handle,
                                 &keyNameUnicodeString,
                                 Data,
                                 DataLength,
                                 KeyType);

        ZwClose(handle);
    }

    USBH_KdPrint((3,"'USBH_SetPdoRegistryParameter status 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    PAGED_CODE();

//    InitializeObjectAttributes( &objectAttributes,
//                                KeyNameString,
//                                OBJ_CASE_INSENSITIVE,
//                                Handle,
//                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //
#if 0
    ntStatus = ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
#endif
    ntStatus = ZwSetValueKey(Handle,
                             KeyNameUnicodeString,
                             0,
                             KeyType,
                             Data,
                             DataLength);

    USBH_KdPrint((2,"' ZwSetKeyValue = 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_GetPdoRegistryParameter(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PWCHAR           ValueName,
    OUT PVOID           Data,
    IN ULONG            DataLength,
    OUT PULONG          Type,
    OUT PULONG          ActualDataLength
    )
/*++

Routine Description:

    This routines queries the data for a registry value entry associated
    with the device instance specific registry key for the PDO.

    The registry value entry would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    PhysicalDeviceObject - Yep, the PDO

    ValueName - Name of the registry value entry for which the data is requested

    Data - Buffer in which the requested data is returned

    DataLength - Length of the data buffer

    Type - (optional) The data type (e.g. REG_SZ, REG_DWORD) is returned here

    ActualDataLength - (optional) The actual length of the data is returned here
                       If this is larger than DataLength then not all of the
                       value data has been returned.

Return Value:

--*/
{
    HANDLE      handle;
    NTSTATUS    ntStatus;

    PAGED_CODE();

    ntStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_ALL,
                                       &handle);

    if (NT_SUCCESS(ntStatus))
    {
        PKEY_VALUE_PARTIAL_INFORMATION  partialInfo;
        UNICODE_STRING                  valueName;
        ULONG                           length;
        ULONG                           resultLength;

        RtlInitUnicodeString(&valueName, ValueName);

        // Size and allocate a KEY_VALUE_PARTIAL_INFORMATION structure,
        // including room for the returned value data.
        //
        length = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) +
                 DataLength;

        partialInfo = UsbhExAllocatePool(PagedPool, length);

        if (partialInfo)
        {
            // Query the value data.
            //
            ntStatus = ZwQueryValueKey(handle,
                                       &valueName,
                                       KeyValuePartialInformation,
                                       partialInfo,
                                       length,
                                       &resultLength);

            // If we got any data that is good enough
            //
            if (ntStatus == STATUS_BUFFER_OVERFLOW)
            {
                ntStatus = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(ntStatus))
            {
                // Only copy the smaller of the the requested data length or
                // the actual data length.
                //
                RtlCopyMemory(Data,
                              partialInfo->Data,
                              DataLength < partialInfo->DataLength ?
                              DataLength :
                              partialInfo->DataLength);

                // Return the value data type and actual length, if requested.
                //
                if (Type)
                {
                    *Type = partialInfo->Type;
                }

                if (ActualDataLength)
                {
                    *ActualDataLength = partialInfo->DataLength;
                }
            }

            UsbhExFreePool(partialInfo);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        ZwClose(handle);
    }

    return ntStatus;
}



NTSTATUS
USBH_OsVendorCodeQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PAGED_CODE();

    if (ValueType != REG_BINARY ||
        ValueLength != 2 * sizeof(UCHAR))
    {
        return STATUS_INVALID_PARAMETER;
    }

    ((PUCHAR)EntryContext)[0] = ((PUCHAR)ValueData)[0];
    ((PUCHAR)EntryContext)[1] = ((PUCHAR)ValueData)[1];

    return STATUS_SUCCESS;
}

#ifndef USBHUB20
VOID
USBH_GetMsOsVendorCode(
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION_PORT      deviceExtensionPort;
    WCHAR                       path[] = L"usbflags\\vvvvpppprrrr";
    USHORT                      idVendor;
    USHORT                      idProduct;
    USHORT                      bcdDevice;
    ULONG                       i;
    RTL_QUERY_REGISTRY_TABLE    paramTable[2];
    UCHAR                       osvc[2];
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    deviceExtensionPort = DeviceObject->DeviceExtension;
    USBH_ASSERT(EXTENSION_TYPE_PORT == deviceExtensionPort->ExtensionType);

    // Build the registry path string for the device
    //
    idVendor  = deviceExtensionPort->DeviceDescriptor.idVendor,
    idProduct = deviceExtensionPort->DeviceDescriptor.idProduct,
    bcdDevice = deviceExtensionPort->DeviceDescriptor.bcdDevice,

    i = sizeof("usbflags\\") - 1;

    path[i++] = NibbleToHexW(idVendor >> 12);
    path[i++] = NibbleToHexW((idVendor >> 8) & 0x000f);
    path[i++] = NibbleToHexW((idVendor >> 4) & 0x000f);
    path[i++] = NibbleToHexW(idVendor & 0x000f);

    path[i++] = NibbleToHexW(idProduct >> 12);
    path[i++] = NibbleToHexW((idProduct >> 8) & 0x000f);
    path[i++] = NibbleToHexW((idProduct >> 4) & 0x000f);
    path[i++] = NibbleToHexW(idProduct & 0x000f);

    path[i++] = NibbleToHexW(bcdDevice >> 12);
    path[i++] = NibbleToHexW((bcdDevice >> 8) & 0x000f);
    path[i++] = NibbleToHexW((bcdDevice >> 4) & 0x000f);
    path[i++] = NibbleToHexW(bcdDevice & 0x000f);

    // Check if MsOsVendorCode is already set in the registry.
    //
    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].QueryRoutine  = USBH_OsVendorCodeQueryRoutine;
    paramTable[0].Flags         = RTL_QUERY_REGISTRY_REQUIRED;
    paramTable[0].Name          = L"osvc";
    paramTable[0].EntryContext  = &osvc;

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                                      path,
                                      &paramTable[0],
                                      NULL,             // Context
                                      NULL);            // Environment

    // If the MsOsVendorCode value in the registry is valid, it indicates
    // whether or not the device supports the MS OS Descriptor request, and if
    // does, what the Vendor Code is.
    //
    if (NT_SUCCESS(ntStatus))
    {
        if (osvc[0] == 1)
        {
            deviceExtensionPort->FeatureDescVendorCode = osvc[1];

            deviceExtensionPort->PortPdoFlags |= PORTPDO_MS_VENDOR_CODE_VALID;
        }

        return;
    }

    // If we have not asked the device for the MS OS String Descriptor yet
    // do that now, but only if the device indicates that it has some other
    // string descriptors.
    //
    if (deviceExtensionPort->DeviceDescriptor.idVendor != 0 ||
        deviceExtensionPort->DeviceDescriptor.iProduct != 0 ||
        deviceExtensionPort->DeviceDescriptor.iSerialNumber != 0)
    {
        OS_STRING   osString;
        ULONG       bytesReturned;

        // Try to retrieve the MS OS String Descriptor from the device.
        //
        ntStatus = USBH_SyncGetStringDescriptor(
                       DeviceObject,
                       OS_STRING_DESCRIPTOR_INDEX,
                       0,
                       (PUSB_STRING_DESCRIPTOR)&osString,
                       sizeof(OS_STRING),
                       &bytesReturned,
                       TRUE);

        if (NT_SUCCESS(ntStatus) &&
            (bytesReturned == sizeof(OS_STRING)) &&
            (RtlCompareMemory(&osString.MicrosoftString,
                              MS_OS_STRING_SIGNATURE,
                              sizeof(osString.MicrosoftString)) ==
             sizeof(osString.MicrosoftString)))
        {
            // This device has a valid MS OS String Descriptor.
            // Let's pluck out the corresponding Vendor Code and
            // save that away in the device extension.
            //
            deviceExtensionPort->FeatureDescVendorCode = osString.bVendorCode;

            deviceExtensionPort->PortPdoFlags |= PORTPDO_MS_VENDOR_CODE_VALID;
        }
        else
        {
            // Maybe we've wedged the device by sending it our questionable
            // proprietary request.  Reset the device for good measure.
            //
            USBH_SyncResetDevice(DeviceObject);
        }
    }

    // Write the MsOsVendorCode value to the registry.  It indicates whether
    // or not the device supports the MS OS Descriptor request, and if
    // does, what the Vendor Code is.
    //
    if (deviceExtensionPort->PortPdoFlags & PORTPDO_MS_VENDOR_CODE_VALID)
    {
        osvc[0] = 1;
        osvc[1] = deviceExtensionPort->FeatureDescVendorCode;
    }
    else
    {
        osvc[0] = 0;
        osvc[1] = 0;
    }

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_CONTROL,
                                     path,
                                     L"osvc",
                                     REG_BINARY,
                                     &osvc[0],
                                     sizeof(osvc));
}


NTSTATUS
USBH_GetMsOsFeatureDescriptor(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            Interface,
    IN USHORT           Index,
    IN OUT PVOID        DataBuffer,
    IN ULONG            DataBufferLength,
    OUT PULONG          BytesReturned
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT                      deviceExtensionPort;
    USHORT                                      function;
    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *urb;
    NTSTATUS                                    ntStatus;

    PAGED_CODE();

    deviceExtensionPort = DeviceObject->DeviceExtension;
    USBH_ASSERT(EXTENSION_TYPE_PORT == deviceExtensionPort->ExtensionType);

    *BytesReturned = 0;

    // Make sure the device supports the MS OS Descriptor request
    //
    if (!(deviceExtensionPort->PortPdoFlags & PORTPDO_MS_VENDOR_CODE_VALID))
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Device, Endpoint, or Interface request?
    //
    switch (Recipient)
    {
        case 0:
            function = URB_FUNCTION_VENDOR_DEVICE;
            break;
        case 1:
            function = URB_FUNCTION_VENDOR_INTERFACE;
            break;
        case 2:
            function = URB_FUNCTION_VENDOR_ENDPOINT;
            break;
        default:
            return STATUS_INVALID_PARAMETER;
    }

    // Make sure the requested buffer length is valid
    //
    if (DataBufferLength == 0 ||
        DataBufferLength > 0xFF * 0xFFFF)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate a URB for the request
    //
    urb = UsbhExAllocatePool(NonPagedPool, sizeof(*urb));

    if (NULL == urb)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        ULONG   bytesReturned;
        UCHAR   pageNumber;

        bytesReturned = 0;

        pageNumber = 0;

        while (1)
        {
            // Initialize the URB for the current page
            //
            RtlZeroMemory(urb, sizeof(*urb));

            urb->Hdr.Length = sizeof(*urb);

            urb->Hdr.Function = function;

            urb->TransferFlags = USBD_TRANSFER_DIRECTION_IN;

            urb->TransferBufferLength = DataBufferLength < 0xFFFF ?
                                        DataBufferLength :
                                        0xFFFF;

            urb->TransferBuffer = DataBuffer;

            urb->Request = deviceExtensionPort->FeatureDescVendorCode;

            urb->Value = (Interface << 8) | pageNumber;

            urb->Index = Index;

            // Send down the URB for the current page
            //
            ntStatus = USBH_SyncSubmitUrb(DeviceObject, (PURB)urb);

            // If the request failed then we are done.
            //
            if (!NT_SUCCESS(ntStatus))
            {
                break;
            }

            (PUCHAR)DataBuffer += urb->TransferBufferLength;

            DataBufferLength   -= urb->TransferBufferLength;

            bytesReturned      += urb->TransferBufferLength;

            pageNumber++;

            // If the result was less than the max page size or there are
            // no more bytes remaining then we are done.
            //
            if (urb->TransferBufferLength < 0xFFFF ||
                DataBufferLength == 0)
            {
                *BytesReturned = bytesReturned;

                break;
            }

        }

        // Done with the URB now, free it
        //
        UsbhExFreePool(urb);
    }

    return ntStatus;
}


VOID
USBH_InstallExtPropDesc (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routines queries a device for an Extended Properties Descriptor, but
    only once the very first time for a given instance of a device.

    If the Extended Properties Descriptor and all of the Custom Property
    Sections appear valid then each Custom Property section <ValueName,
    ValueData> pair is installed in the device instance specific registry key
    for the PDO.

    The registry value entries would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    DeviceObject - The PDO

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION_PORT  deviceExtensionPort;
    static WCHAR            USBH_DidExtPropDescKey[] = L"ExtPropDescSemaphore";
    ULONG                   didExtPropDesc;
    MS_EXT_PROP_DESC_HEADER msExtPropDescHeader;
    PMS_EXT_PROP_DESC       pMsExtPropDesc;
    ULONG                   bytesReturned;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtensionPort = DeviceObject->DeviceExtension;

    // Check if the semaphore value is already set in the registry.  We only
    // care whether or not it already exists, not what data it has.
    //
    ntStatus = USBH_GetPdoRegistryParameter(DeviceObject,
                                            USBH_DidExtPropDescKey,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL);

    if (NT_SUCCESS(ntStatus))
    {
        // Already did this once for this device instance.  Don't do it again.
        //
        return;
    }

    // Set the semaphore key in the registry so that we only run the following
    // code once per device.

    didExtPropDesc = 1;

    USBH_SetPdoRegistryParameter(DeviceObject,
                                 USBH_DidExtPropDescKey,
                                 sizeof(USBH_DidExtPropDescKey),
                                 &didExtPropDesc,
                                 sizeof(didExtPropDesc),
                                 REG_DWORD,
                                 PLUGPLAY_REGKEY_DEVICE);


    RtlZeroMemory(&msExtPropDescHeader, sizeof(MS_EXT_PROP_DESC_HEADER));

    // Request just the header of the MS Extended Property Descriptor
    //
    ntStatus = USBH_GetMsOsFeatureDescriptor(
                   DeviceObject,
                   1,   // Recipient Interface
                   0,   // Interface
                   MS_EXT_PROP_DESCRIPTOR_INDEX,
                   &msExtPropDescHeader,
                   sizeof(MS_EXT_PROP_DESC_HEADER),
                   &bytesReturned);

    // Make sure the MS Extended Property Descriptor header looks ok
    //
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.dwLength >= sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.bcdVersion == MS_EXT_PROP_DESC_VER &&
        msExtPropDescHeader.wIndex == MS_EXT_PROP_DESCRIPTOR_INDEX &&
        msExtPropDescHeader.wCount > 0)
    {
        // Allocate a buffer large enough for the entire descriptor
        //
        pMsExtPropDesc = UsbhExAllocatePool(NonPagedPool,
                                            msExtPropDescHeader.dwLength);


        if (pMsExtPropDesc)
        {
            RtlZeroMemory(pMsExtPropDesc, msExtPropDescHeader.dwLength);

            // Request the entire MS Extended Property Descriptor
            //
            ntStatus = USBH_GetMsOsFeatureDescriptor(
                           DeviceObject,
                           1,   // Recipient Interface
                           0,   // Interface
                           MS_EXT_PROP_DESCRIPTOR_INDEX,
                           pMsExtPropDesc,
                           msExtPropDescHeader.dwLength,
                           &bytesReturned);

            if (NT_SUCCESS(ntStatus) &&
                bytesReturned == msExtPropDescHeader.dwLength &&
                RtlCompareMemory(&msExtPropDescHeader,
                                 pMsExtPropDesc,
                                 sizeof(MS_EXT_PROP_DESC_HEADER)) ==
                sizeof(MS_EXT_PROP_DESC_HEADER))
            {
                // MS Extended Property Descriptor retrieved ok, parse and
                // install each Custom Property Section it contains.
                //
                USBH_InstallExtPropDescSections(DeviceObject,
                                                pMsExtPropDesc);
            }

            // Done with the MS Extended Property Descriptor buffer, free it
            //
            UsbhExFreePool(pMsExtPropDesc);
        }
    }
}

VOID
USBH_InstallExtPropDescSections (
    PDEVICE_OBJECT      DeviceObject,
    PMS_EXT_PROP_DESC   pMsExtPropDesc
    )
/*++

Routine Description:

    This routines parses an Extended Properties Descriptor and validates each
    Custom Property Section contained in the Extended Properties Descriptor.

    If all of the Custom Property Sections appear valid then each Custom
    Property section <ValueName, ValueData> pair is installed in the device
    instance specific registry key for the PDO.

    The registry value entries would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    DeviceObject - The PDO

    pMsExtPropDesc - Pointer to an Extended Properties Descriptor buffer.
                     It is assumed that the header of this descriptor has
                     already been validated.

Return Value:

    None

--*/
{
    PUCHAR  p;
    PUCHAR  end;
    ULONG   pass;
    ULONG   i;

    ULONG   dwSize;
    ULONG   dwPropertyDataType;
    USHORT  wPropertyNameLength;
    PWCHAR  bPropertyName;
    ULONG   dwPropertyDataLength;
    PVOID   bPropertyData;

    NTSTATUS    ntStatus;

    PAGED_CODE();

    // Get a pointer to the end of the entire Extended Properties Descriptor
    //
    end = (PUCHAR)pMsExtPropDesc + pMsExtPropDesc->Header.dwLength;

    // First pass:  Validate each Custom Property Section
    // Second pass: Install  each Custom Property Section (if first pass ok)
    //
    for (pass = 0; pass < 2; pass++)
    {
        // Get a pointer to the first Custom Property Section
        //
        p = (PUCHAR)&pMsExtPropDesc->CustomSection[0];

        // Iterate over all of the Custom Property Sections
        //
        for (i = 0; i < pMsExtPropDesc->Header.wCount; i++)
        {
            ULONG   offset;

            // Make sure the dwSize field is in bounds
            //
            if (p + sizeof(ULONG) > end)
            {
                break;
            }

            // Extract the dwSize field and advance running offset
            //
            dwSize = *((PULONG)p);

            offset = sizeof(ULONG);

            // Make sure the entire structure is in bounds
            //
            if (p + dwSize > end)
            {
                break;
            }

            // Make sure the dwPropertyDataType field is in bounds

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

            // Extract the dwPropertyDataType field and advance running offset
            //
            dwPropertyDataType = *((PULONG)(p + offset));

            offset += sizeof(ULONG);

            // Make sure the wPropertyNameLength field is in bounds
            //
            if (dwSize < offset + sizeof(USHORT))
            {
                break;
            }

            // Extract the wPropertyNameLength field and advance running offset
            //
            wPropertyNameLength = *((PUSHORT)(p + offset));

            offset += sizeof(USHORT);

            // Make sure the bPropertyName field is in bounds
            //
            if (dwSize < offset + wPropertyNameLength)
            {
                break;
            }

            // Set the bPropertyName pointer and advance running offset
            //
            bPropertyName = (PWCHAR)(p + offset);

            offset += wPropertyNameLength;

            // Make sure the dwPropertyDataLength field is in bounds

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

            // Extract the dwPropertyDataLength field and advance running offset
            //
            dwPropertyDataLength = *((ULONG UNALIGNED*)(p + offset));

            offset += sizeof(ULONG);

            // Make sure the bPropertyData field is in bounds
            //
            if (dwSize < offset + dwPropertyDataLength)
            {
                break;
            }

            // Set the bPropertyData pointer and advance running offset
            //
            bPropertyData = p + offset;

            offset += wPropertyNameLength;


            // Make sure the dwPropertyDataType is valid
            //
            if (dwPropertyDataType < REG_SZ ||
                dwPropertyDataType > REG_MULTI_SZ)
            {
                break;
            }

            // Make sure the wPropertyNameLength is valid
            //
            if (wPropertyNameLength == 0 ||
                (wPropertyNameLength % sizeof(WCHAR)) != 0)
            {
                break;
            }

            // Make sure bPropertyName is NULL terminated
            //
            if (bPropertyName[(wPropertyNameLength / sizeof(WCHAR)) - 1] !=
                UNICODE_NULL)
            {
                break;
            }

            // Everything looks ok,
            //
            if (pass > 0)
            {
                ntStatus = USBH_SetPdoRegistryParameter(
                               DeviceObject,
                               bPropertyName,
                               wPropertyNameLength,
                               bPropertyData,
                               dwPropertyDataLength,
                               dwPropertyDataType,
                               PLUGPLAY_REGKEY_DEVICE);
            }
        }

        // Skip the second pass if we bailed out of the first pass
        //
        if (i < pMsExtPropDesc->Header.wCount)
        {
            break;
        }
    }
}


PMS_EXT_CONFIG_DESC
USBH_GetExtConfigDesc (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routines queries a device for an Extended Configuration Descriptor.

Arguments:

    DeviceObject - The PDO

Return Value:

    If successful, a pointer to the Extended Configuration Descriptor, which the
    caller must free, else NULL.

--*/
{
    MS_EXT_CONFIG_DESC_HEADER   msExtConfigDescHeader;
    PMS_EXT_CONFIG_DESC         pMsExtConfigDesc;
    ULONG                       bytesReturned;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    pMsExtConfigDesc = NULL;

    RtlZeroMemory(&msExtConfigDescHeader, sizeof(MS_EXT_CONFIG_DESC_HEADER));

    // Request just the header of the MS Extended Configuration Descriptor
    //
    ntStatus = USBH_GetMsOsFeatureDescriptor(
                   DeviceObject,
                   0,   // Recipient Device
                   0,   // Interface
                   MS_EXT_CONFIG_DESCRIPTOR_INDEX,
                   &msExtConfigDescHeader,
                   sizeof(MS_EXT_CONFIG_DESC_HEADER),
                   &bytesReturned);

    // Make sure the MS Extended Configuration Descriptor header looks ok
    //
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_CONFIG_DESC_HEADER) &&
        msExtConfigDescHeader.bcdVersion == MS_EXT_CONFIG_DESC_VER &&
        msExtConfigDescHeader.wIndex == MS_EXT_CONFIG_DESCRIPTOR_INDEX &&
        msExtConfigDescHeader.bCount > 0 &&
        msExtConfigDescHeader.dwLength == sizeof(MS_EXT_CONFIG_DESC_HEADER) +
        msExtConfigDescHeader.bCount * sizeof(MS_EXT_CONFIG_DESC_FUNCTION))

    {
        // Allocate a buffer large enough for the entire descriptor
        //
        pMsExtConfigDesc = UsbhExAllocatePool(NonPagedPool,
                                              msExtConfigDescHeader.dwLength);


        if (pMsExtConfigDesc)
        {
            RtlZeroMemory(pMsExtConfigDesc, msExtConfigDescHeader.dwLength);

            // Request the entire MS Extended Configuration Descriptor
            //
            ntStatus = USBH_GetMsOsFeatureDescriptor(
                           DeviceObject,
                           0,   // Recipient Device
                           0,   // Interface
                           MS_EXT_CONFIG_DESCRIPTOR_INDEX,
                           pMsExtConfigDesc,
                           msExtConfigDescHeader.dwLength,
                           &bytesReturned);

            if (!(NT_SUCCESS(ntStatus) &&
                  bytesReturned == msExtConfigDescHeader.dwLength &&
                  RtlCompareMemory(&msExtConfigDescHeader,
                                   pMsExtConfigDesc,
                                   sizeof(MS_EXT_CONFIG_DESC_HEADER)) ==
                  sizeof(MS_EXT_CONFIG_DESC_HEADER)))
            {
                // Something went wrong retrieving the MS Extended Configuration
                // Descriptor.  Free the buffer.

                UsbhExFreePool(pMsExtConfigDesc);

                pMsExtConfigDesc = NULL;
            }
        }
    }

    return pMsExtConfigDesc;
}

BOOLEAN
USBH_ValidateExtConfigDesc (
    IN PMS_EXT_CONFIG_DESC              MsExtConfigDesc,
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor
    )
/*++

Routine Description:

    This routines validates an Extended Configuration Descriptor.

Arguments:

    MsExtConfigDesc - The Extended Configuration Descriptor to be validated.
                      It is assumed that the header of this descriptor has
                      already been validated.

    ConfigurationDescriptor - Configuration Descriptor, assumed to already
                              validated.

Return Value:

    TRUE if the Extended Configuration Descriptor appears to be valid,
    else FALSE.

--*/
{
    UCHAR   interfacesRemaining;
    ULONG   i;
    ULONG   j;
    UCHAR   c;
    BOOLEAN gotNull;

    PAGED_CODE();

    interfacesRemaining = ConfigurationDescriptor->bNumInterfaces;

    for (i = 0; i < MsExtConfigDesc->Header.bCount; i++)
    {
        // Make sure that there is at least one interface in this function.
        //
        if (MsExtConfigDesc->Function[i].bInterfaceCount == 0)
        {
            return FALSE;
        }

        // Make sure that there are not too many interfaces in this function.
        //
        if (MsExtConfigDesc->Function[i].bInterfaceCount > interfacesRemaining)
        {
            return FALSE;
        }

        interfacesRemaining -= MsExtConfigDesc->Function[i].bInterfaceCount;

        // Make sure the no interfaces were skipped between the interfaces
        // of the previous function and the interfaces of this function.
        //
        if (i &&
            MsExtConfigDesc->Function[i-1].bFirstInterfaceNumber +
            MsExtConfigDesc->Function[i-1].bInterfaceCount !=
            MsExtConfigDesc->Function[i].bFirstInterfaceNumber)
        {
            return FALSE;
        }

        // Make sure that the CompatibleID is valid.
        // Valid characters are 'A' through 'Z', '0' through '9', and '_"
        // and null padded to the the right end of the array, but not
        // necessarily null terminated.
        //
        for (j = 0, gotNull = FALSE;
             j < sizeof(MsExtConfigDesc->Function[i].CompatibleID);
             j++)
        {
            c = MsExtConfigDesc->Function[i].CompatibleID[j];

            if (c == 0)
            {
                gotNull = TRUE;
            }
            else
            {
                if (gotNull ||
                    !((c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') ||
                      (c == '_')))
                {
                    return FALSE;
                }
            }
        }

        // Make sure that the SubCompatibleID is valid.
        // Valid characters are 'A' through 'Z', '0' through '9', and '_"
        // and null padded to the the right end of the array, but not
        // necessarily null terminated.
        //
        for (j = 0, gotNull = FALSE;
             j < sizeof(MsExtConfigDesc->Function[i].SubCompatibleID);
             j++)
        {
            c = MsExtConfigDesc->Function[i].SubCompatibleID[j];

            if (c == 0)
            {
                gotNull = TRUE;
            }
            else
            {
                if (gotNull ||
                    !((c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') ||
                      (c == '_')))
                {
                    return FALSE;
                }
            }
        }

        // Make sure that if the SubCompatibleID is non-null then the
        // CompatibleID is also non-null.
        //
        if (MsExtConfigDesc->Function[i].SubCompatibleID[0] != 0 &&
            MsExtConfigDesc->Function[i].CompatibleID[0] == 0)
        {
            return FALSE;
        }
    }

    // Make sure that all of the interfaces were consumed by functions.
    //
    if (interfacesRemaining > 0)
    {
        return FALSE;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\ioctl.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    IOCTL.H

Abstract:

    Header file for I82930 driver

Environment:

    kernel and user mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

// {0B677572-2B5B-46c7-B1F3-D140A341888C}
DEFINE_GUID(GUID_CLASS_I82930, 
0xb677572, 0x2b5b, 0x46c7, 0xb1, 0xf3, 0xd1, 0x40, 0xa3, 0x41, 0x88, 0x8c);


#define I82930_IOCTL_INDEX  0x0000

#define IOCTL_I82930_GET_DEVICE_DESCRIPTOR \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+0,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_GET_CONFIG_DESCRIPTOR \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+1,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_SET_CONFIG_DESCRIPTOR \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+2,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_GET_PIPE_INFORMATION \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+3,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_RESET_PIPE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+4,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_STALL_PIPE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+5,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_ABORT_PIPE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+6,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_RESET_DEVICE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+7,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_SELECT_ALTERNATE_INTERFACE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+8,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\hub.pnp\parent.c ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:

    PARENT.C

Abstract:

    This module contains code that manages composite devices on USB.

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include <wdmguid.h>
#include "usbhub.h"


#define COMP_RESET_TIMEOUT  3000     // Timeout in ms (3 sec)


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_ParentFdoStopDevice)
#pragma alloc_text(PAGE, USBH_ParentFdoRemoveDevice)
#pragma alloc_text(PAGE, UsbhParentFdoCleanup)
#pragma alloc_text(PAGE, USBH_ParentQueryBusRelations)
#pragma alloc_text(PAGE, USBH_ParentFdoStartDevice)
#pragma alloc_text(PAGE, USBH_FunctionPdoQueryId)
#pragma alloc_text(PAGE, USBH_FunctionPdoQueryDeviceText)
#pragma alloc_text(PAGE, USBH_FunctionPdoPnP)
#pragma alloc_text(PAGE, USBH_ParentCreateFunctionList)
#endif
#endif

VOID
UsbhParentFdoCleanup(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
 /* ++
  *
  * Description:
  *
  * This routine is called to shut down the hub.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PSINGLE_LIST_ENTRY listEntry;
    ULONG i;
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;
    KIRQL irql;
    PIRP wWIrp;

    USBH_KdPrint((2,"'UsbhParentFdoCleanup Fdo extension %x\n",
        DeviceExtensionParent));

    LOGENTRY(LOG_PNP, "pfdc", DeviceExtensionParent,
                DeviceExtensionParent->PendingWakeIrp,
                0);

    //
    // dump our wake request
    //
    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionParent->PendingWakeIrp) {
        USBH_ASSERT(DeviceExtensionParent->ParentFlags & HUBFLAG_PENDING_WAKE_IRP);

        wWIrp = DeviceExtensionParent->PendingWakeIrp;
        IoSetCancelRoutine(wWIrp, NULL);
        DeviceExtensionParent->PendingWakeIrp = NULL;
        IoReleaseCancelSpinLock(irql);

        IoCancelIrp(wWIrp);
    } else {
        IoReleaseCancelSpinLock(irql);
    }

    if (DeviceExtensionParent->ConfigurationDescriptor) {
        UsbhExFreePool(DeviceExtensionParent->ConfigurationDescriptor);
        DeviceExtensionParent->ConfigurationDescriptor = NULL;
    }

    USBH_ParentCompleteFunctionWakeIrps (DeviceExtensionParent,
                                         STATUS_DELETE_PENDING);

    do {
        listEntry = PopEntryList(&DeviceExtensionParent->FunctionList);

        LOGENTRY(LOG_PNP, "dFU1", 0, listEntry, 0);

        if (listEntry != NULL) {

            deviceExtensionFunction =
                CONTAINING_RECORD(listEntry,
                                  DEVICE_EXTENSION_FUNCTION,
                                  ListEntry);
            ASSERT_FUNCTION(deviceExtensionFunction);
            LOGENTRY(LOG_PNP, "dFUN", deviceExtensionFunction, 0, 0);

            for (i=0; i< deviceExtensionFunction->InterfaceCount; i++) {
                LOGENTRY(LOG_PNP, "dFUi", deviceExtensionFunction,
                    deviceExtensionFunction->FunctionInterfaceList[i].InterfaceInformation,
                    0);
                UsbhExFreePool(deviceExtensionFunction->FunctionInterfaceList[i].InterfaceInformation);
            }

            //
            // Sometimes the FunctionPhysicalDeviceObject == deviceExtensionFunction.
            // In other words the device object about to be deleted is the
            // same one being used.  So do not use the extions after it has been
            // deleted.
            //

            deviceObject = deviceExtensionFunction->FunctionPhysicalDeviceObject;
            deviceExtensionFunction->FunctionPhysicalDeviceObject = NULL;

            LOGENTRY(LOG_PNP, "dFUo", deviceExtensionFunction,
                    deviceObject,
                    0);

            IoDeleteDevice(deviceObject);

        }

    } while (listEntry != NULL);

    DeviceExtensionParent->NeedCleanup = FALSE;

    USBH_KdPrint((2,"'UsbhParentFdoCleanup done Fdo extension %x\n",
        DeviceExtensionParent));


    return;
}


NTSTATUS
USBH_ParentFdoRemoveDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus;

    PAGED_CODE();
    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'ParentFdoRemoveDevice Fdo %x\n", deviceObject));

    DeviceExtensionParent->ParentFlags |= HUBFLAG_DEVICE_STOPPING;

    //
    // see if we need cleanup
    //
    if (DeviceExtensionParent->NeedCleanup) {
        UsbhParentFdoCleanup(DeviceExtensionParent);
    }

#ifdef WMI_SUPPORT
    // de-register with WMI
    IoWMIRegistrationControl(deviceObject,
                             WMIREG_ACTION_DEREGISTER);

#endif

    //
    // And we need to pass this message on to lower level driver
    //

    // IrpAssert: Set IRP status before passing on.
    Irp->IoStatus.Status = STATUS_SUCCESS;

    ntStatus = USBH_PassIrp(Irp, DeviceExtensionParent->TopOfStackDeviceObject);

    //
    // Detach FDO from PDO
    //
    IoDetachDevice(DeviceExtensionParent->TopOfStackDeviceObject);

    // delete FDO of the parent
    IoDeleteDevice(deviceObject);

    return ntStatus;
}


NTSTATUS
USBH_ParentCreateFunctionList(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList,
    IN PURB Urb
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp, baseInterface;
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;
    ULONG nameIndex = 0, numberOfInterfacesThisFunction, k;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    UNICODE_STRING uniqueIdUnicodeString;

    PAGED_CODE();
    DeviceExtensionParent->FunctionCount = 0;
    tmp = interfaceList = InterfaceList;

    DeviceExtensionParent->FunctionList.Next = NULL;
    configurationDescriptor = DeviceExtensionParent->ConfigurationDescriptor;

    for (;;) {

        nameIndex = 0;

        if (interfaceList->InterfaceDescriptor) {

            //
            // interfaceList contains all the interfaces on the device
            // in sequential order.
            //
            //
            // We will create nodes based on the following criteria:
            //
            // For each interface create one function (node)
            //
            //
            // For Each group of class/subclass interface create one
            // node iff the class is audio
            //
            // This means:
            // **
            //  Class=1
            //      subclass=0
            //  Class=1
            //      subclass=0
            // creates 2 nodes
            //
            // ** we will only do this for the audio class
            // **
            //  Class=1
            //      subclass=0
            //  Class=2
            //      subclass=1
            // creates 2 nodes
            //
            // **
            //  Class=1
            //      subclass=0
            //  Class=1
            //      subclass=1
            // creates 1 node

            //
            // Create the node to represent this device
            //

            do {
                if (NT_SUCCESS(ntStatus)) {
                    ntStatus = IoCreateDevice(UsbhDriverObject,    // Driver Object
                                     sizeof(DEVICE_EXTENSION_FUNCTION),    // Device Extension size
                                     NULL, // Device name
                                     FILE_DEVICE_UNKNOWN,  // Device Type
                                                    // should look device
                                                    // class
                                     FILE_AUTOGENERATED_DEVICE_NAME,// Device Chars
                                     FALSE,    // Exclusive
                                     &deviceObject);  // Bus Device Object

                }
                nameIndex++;
            } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);


            if (!NT_SUCCESS(ntStatus)) {
                USBH_KdTrap(("IoCreateDevice for function fail\n"));
                USBH_ASSERT(deviceObject == NULL);
                deviceExtensionFunction = NULL;
                // bail on whole node
                break;
            }

            deviceObject->StackSize =
            DeviceExtensionParent->TopOfStackDeviceObject->StackSize + 1;
                USBH_KdPrint((2,"'CreateFunctionPdo StackSize=%d\n", deviceObject->StackSize));

            deviceExtensionFunction =
                    (PDEVICE_EXTENSION_FUNCTION) deviceObject->DeviceExtension;

            RtlFillMemory(deviceExtensionFunction,
                          sizeof(PDEVICE_EXTENSION_FUNCTION),
                          0);

            //
            // initialize this function extension
            //
            deviceExtensionFunction->ConfigurationHandle =
                Urb->UrbSelectConfiguration.ConfigurationHandle;

            deviceExtensionFunction->FunctionPhysicalDeviceObject =
                deviceObject;

            deviceExtensionFunction->ExtensionType =
                EXTENSION_TYPE_FUNCTION;

            deviceExtensionFunction->DeviceExtensionParent =
                DeviceExtensionParent;

            //
            // remember the base interface for this function
            //
            baseInterface = interfaceList;

            USBH_KdPrint((2,"baseInterface = %x config descr = %x\n",
                baseInterface, configurationDescriptor));

            //
            // now compile the group of interfaces that will make up
            // this function.
            //
            {
            PUSBD_INTERFACE_LIST_ENTRY interface;

            interface = interfaceList;
            interface++;

            numberOfInterfacesThisFunction = 1;
            while (interface->InterfaceDescriptor) {
                if ((interface->InterfaceDescriptor->bInterfaceClass !=
                     baseInterface->InterfaceDescriptor->bInterfaceClass) ||
                    (interface->InterfaceDescriptor->bInterfaceSubClass ==
                     baseInterface->InterfaceDescriptor->bInterfaceSubClass) ||
                    (interface->InterfaceDescriptor->bInterfaceClass !=
                     USB_DEVICE_CLASS_AUDIO)) {
                    break;
                }
                numberOfInterfacesThisFunction++;
                interface++;
            }

            USBH_ASSERT(numberOfInterfacesThisFunction <=
                USBH_MAX_FUNCTION_INTERFACES);

            }

            //
            // now we know how many interfaces we are dealing with
            //

            deviceExtensionFunction->InterfaceCount = 0;

            for (k=0; k< numberOfInterfacesThisFunction; k++) {

                PFUNCTION_INTERFACE functionInterface;

                functionInterface =
                    &deviceExtensionFunction->FunctionInterfaceList[deviceExtensionFunction->InterfaceCount];

                if (functionInterface->InterfaceInformation =
                    UsbhExAllocatePool(NonPagedPool,
                                       interfaceList->Interface->Length)) {

                    RtlCopyMemory(functionInterface->InterfaceInformation,
                                  interfaceList->Interface,
                                  interfaceList->Interface->Length);

                    functionInterface->InterfaceDescriptor
                        = interfaceList->InterfaceDescriptor;

                    //
                    // calculate the length of this interface now
                    //
                    // the length of the descriptor is the difference
                    // between the start of this interface and the
                    // start of the next one.
                    //

                    {
                    PUCHAR start, end;
                    PUSBD_INTERFACE_LIST_ENTRY tmp;

                    tmp = interfaceList;
                    tmp++;

                    end = (PUCHAR) configurationDescriptor;
                    end += configurationDescriptor->wTotalLength;

                    start = (PUCHAR) functionInterface->InterfaceDescriptor;

                    if (tmp->InterfaceDescriptor) {
                        end = (PUCHAR) tmp->InterfaceDescriptor;
                    }

                    USBH_ASSERT(end > start);
                    functionInterface->InterfaceDescriptorLength =
                        (ULONG)(end - start);
                    }

                    USBH_KdPrint((2,"functionInterface = %x\n",
                        functionInterface));

                    deviceExtensionFunction->InterfaceCount++;
                } else {
                    USBH_KdTrap(("failure to create function interface\n"));
                }

                interfaceList++;
            }

            //
            // use the interface number from our 'base' interface
            // for the unique id
            //

            RtlInitUnicodeString(&uniqueIdUnicodeString,
                     &deviceExtensionFunction->UniqueIdString[0]);

            uniqueIdUnicodeString.MaximumLength =
                     sizeof(deviceExtensionFunction->UniqueIdString);

            ntStatus = RtlIntegerToUnicodeString(
                (ULONG) baseInterface->InterfaceDescriptor->bInterfaceNumber,
                10,
                &uniqueIdUnicodeString);

            //
            // add this function to the list
            //

            DeviceExtensionParent->FunctionCount++;

            PushEntryList(&DeviceExtensionParent->FunctionList,
                          &deviceExtensionFunction->ListEntry);

            USBH_KdPrint((2,"deviceExtensionFunction = %x\n", deviceExtensionFunction));

            deviceObject->Flags |= DO_POWER_PAGABLE;
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        } else {
            // end of interface list
            break;
        }
    } /* for */

    return STATUS_SUCCESS;
}


NTSTATUS
USBH_ParentFdoStopDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus;

    PAGED_CODE();
    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'ParentFdoStopDevice Fdo %x\n", deviceObject));

    //
    // set the device to the unconfigured state
    //
    ntStatus = USBH_CloseConfiguration((PDEVICE_EXTENSION_FDO) DeviceExtensionParent);

    //
    // And we need to pass this message on to lower level driver
    //

    ntStatus = USBH_PassIrp(Irp, DeviceExtensionParent->TopOfStackDeviceObject);

    return ntStatus;
}


NTSTATUS
USBH_ParentFdoStartDevice(
    IN OUT PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN BOOLEAN NewList
    )
 /* ++ Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    LONG numberOfInterfaces, interfaceNumber, i;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    ULONG nameIndex = 0;
    DEVICE_CAPABILITIES deviceCapabilities;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter Parent StartDevice\n"));
    USBH_ASSERT(EXTENSION_TYPE_PARENT == DeviceExtensionParent->ExtensionType);


    KeInitializeEvent(&DeviceExtensionParent->PnpStartEvent, NotificationEvent, FALSE);

    USBH_KdPrint((2,"'Set PnPIrp Completion Routine\n"));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           USBH_PnPIrp_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionParent,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                 Irp);


    KeWaitForSingleObject(&DeviceExtensionParent->PnpStartEvent,
                          Suspended,
                          KernelMode,
                          FALSE,
                          NULL);

    DeviceExtensionParent->NeedCleanup = FALSE;

    // WARN STARTS OF OLD GENERIC PARENT

    UsbhWarning(NULL,
                "This device is using obsolete USB Generic Parent!\nPlease fix your INF file.\n",
                TRUE);

//    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
//    goto USBH_ParentFdoStartDevice_Done;


    // END WARN STARTS OF OLD GENERIC PARENT


    //
    // configure the device
    //

    // Initialize DeviceCapabilities structure in case USBH_QueryCapabilities
    // is unsuccessful.

    RtlZeroMemory(&deviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    USBH_QueryCapabilities(DeviceExtensionParent->TopOfStackDeviceObject,
                           &deviceCapabilities);
    //
    // save the system state mapping
    //

    RtlCopyMemory(&DeviceExtensionParent->DeviceState[0],
                  &deviceCapabilities.DeviceState[0],
                  sizeof(DeviceExtensionParent->DeviceState));

    // always enabled for wakeup
    DeviceExtensionParent->ParentFlags |= HUBFLAG_ENABLED_FOR_WAKEUP;

    DeviceExtensionParent->DeviceWake = deviceCapabilities.DeviceWake;
    DeviceExtensionParent->SystemWake = deviceCapabilities.SystemWake;
    DeviceExtensionParent->CurrentPowerState = PowerDeviceD0;

    KeInitializeSemaphore(&DeviceExtensionParent->ParentMutex, 1, 1);

    ntStatus = USBH_GetDeviceDescriptor(DeviceExtensionParent->FunctionalDeviceObject,
                                        &DeviceExtensionParent->DeviceDescriptor);

    if (!NT_SUCCESS(ntStatus)) {
        goto USBH_ParentFdoStartDevice_Done;
    }

    if (NewList) {
        ntStatus =
            USBH_GetConfigurationDescriptor(DeviceExtensionParent->FunctionalDeviceObject,
                                            &configurationDescriptor);
    } else {
        //
        // use the old config descriptor if this is a re-start
        // the reason is that our interface structures in the function
        // extension point in to this same buffer.

        configurationDescriptor =
            DeviceExtensionParent->ConfigurationDescriptor;
    }


    if (!NT_SUCCESS(ntStatus)) {
        goto USBH_ParentFdoStartDevice_Done;
    }

    DeviceExtensionParent->ConfigurationDescriptor =
        configurationDescriptor;

    // we will likely define some registry keys to guide us
    // in the configuration of the device -- the default will
    // be to select the first congiguration and the first
    // alternate interface for each interface.
    //

    USBH_KdPrint((2,"' Parent StartDevice cd = %x\n",
        configurationDescriptor));

    DeviceExtensionParent->CurrentConfig =
        configurationDescriptor->bConfigurationValue;

    //
    // Build an interface list structure, this is an array
    // of strucutres for each interface on the device.
    // We keep a pointer to the interface descriptor for each interface
    // within the configuration descriptor
    //

    numberOfInterfaces = configurationDescriptor->bNumInterfaces;

    tmp = interfaceList =
        UsbhExAllocatePool(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) *
                       (numberOfInterfaces+1));

    if (tmp == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_ParentFdoStartDevice_Done;
    }

    //
    // just grab the first alt setting we find for each interface
    //

    i = interfaceNumber = 0;

    while (i< numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                        configurationDescriptor,
                        configurationDescriptor,
                        interfaceNumber,
                        0, // assume alt setting zero here
                        -1,
                        -1,
                        -1);

        if (interfaceDescriptor) {
            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;
            i++;
        }

        interfaceNumber++;
    }

    //
    // terminate the list
    //
    interfaceList->InterfaceDescriptor = NULL;

    urb = USBD_CreateConfigurationRequestEx(configurationDescriptor,
                                            tmp);

    if (urb) {

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionParent->FunctionalDeviceObject, urb);

        if (NT_SUCCESS(ntStatus)) {
            if (NewList) {

                //
                // first time create our function list
                //

                ntStatus = USBH_ParentCreateFunctionList(
                                DeviceExtensionParent,
                                tmp,
                                urb);
            } else {

                //
                // update our function list with the new handles
                //

                PDEVICE_OBJECT deviceObject;
                PSINGLE_LIST_ENTRY listEntry;
                SINGLE_LIST_ENTRY tempList;
                ULONG i;
                PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;

                USBH_KdBreak(("re-init function list %x\n",
                        DeviceExtensionParent));

                deviceObject = DeviceExtensionParent->FunctionalDeviceObject;

                tempList.Next = NULL;
                //
                // process all entries in the function list
                //
                do {
                    listEntry = PopEntryList(&DeviceExtensionParent->FunctionList);

                    if (listEntry != NULL) {
                        PushEntryList(&tempList, listEntry);

                        deviceExtensionFunction =
                            CONTAINING_RECORD(listEntry,
                                              DEVICE_EXTENSION_FUNCTION,
                                              ListEntry);

                        USBH_KdPrint((2,"'re-init function %x\n",
                            deviceExtensionFunction));

                        deviceExtensionFunction->ConfigurationHandle =
                            urb->UrbSelectConfiguration.ConfigurationHandle;

                        for (i=0; i< deviceExtensionFunction->InterfaceCount; i++) {
                            //
                            // now we need to find the matching interface
                            // information from the new configuration request
                            // and attach it to the function

                            {
                            PUSBD_INTERFACE_INFORMATION interfaceInformation;

                            interfaceInformation =
                                deviceExtensionFunction->FunctionInterfaceList[i].InterfaceInformation;

                            interfaceList = tmp;
                            while (interfaceList->InterfaceDescriptor) {

                                PFUNCTION_INTERFACE functionInterface;

                                functionInterface =
                                     &deviceExtensionFunction->FunctionInterfaceList[i];

                                if (interfaceList->InterfaceDescriptor->bInterfaceNumber
                                     == interfaceInformation->InterfaceNumber) {

                                    USBH_KdPrint((2,
                                        "'re-init matched interface %d %x %x\n",
                                        interfaceInformation->InterfaceNumber,
                                        interfaceList,
                                        interfaceInformation));

                                    if (interfaceList->InterfaceDescriptor->bAlternateSetting !=
                                        interfaceInformation->AlternateSetting) {

                                        USBH_KdPrint((2,
                                            "'re-init no match alt interface %d %x %x\n",
                                            interfaceInformation->InterfaceNumber,
                                            interfaceList,
                                            interfaceInformation));

                                        // we have a different alt setting
                                        // switch our info to match the new
                                        // setting

                                        UsbhExFreePool(interfaceInformation);

                                        interfaceInformation =
                                            functionInterface ->InterfaceInformation =
                                            UsbhExAllocatePool(NonPagedPool,
                                                               interfaceList->Interface->Length);

                                        if (interfaceInformation) {
                                            RtlCopyMemory(interfaceInformation,
                                                          interfaceList->Interface,
                                                          interfaceList->Interface->Length);

                                            functionInterface->InterfaceDescriptor =
                                                interfaceList->InterfaceDescriptor;
                                        }
                                    } else {

                                        USBH_KdPrint((2,
                                            "'re-init matched alt interface %d %x %x\n",
                                            interfaceInformation->InterfaceNumber,
                                            interfaceList,
                                            interfaceInformation));

                                        USBH_ASSERT(interfaceList->Interface->Length ==
                                               interfaceInformation->Length);
                                        RtlCopyMemory(interfaceInformation,
                                                      interfaceList->Interface,
                                                      interfaceList->Interface->Length);
                                    }
                                    break;
                                }
                                interfaceList++;
                            }
                            }
                        }
                    }

                } while (listEntry != NULL);

                // now put the entries back
                do {
                    listEntry = PopEntryList(&tempList);
                    if (listEntry != NULL) {
                        PushEntryList(&DeviceExtensionParent->FunctionList, listEntry);
                    }
                } while (listEntry != NULL);
            }
        }

        ExFreePool(urb);

        //
        // Tell the OS that this PDO can have kids.
        //
//
// Workaround for PnP bug #406381 - RC3SS: Bluescreen failure when
//                                  installing/deinstalling communication ports
//
//===== Assigned by santoshj on 09/23/99 10:27:20 to kenray =====
// This is a race condition between IopInitializeSystemDrivers and
// IoInvalidateDeviceRelations. The real fix is too big a change at this
// stage of the product and has potential of exposing other problems. This
// problem can be solved if USBHUB does not invalidate device relations on
// every start which is redundant anyway (and also exposes this bug).
//
//        USBH_IoInvalidateDeviceRelations(DeviceExtensionParent->PhysicalDeviceObject,
//                                         BusRelations);

        DeviceExtensionParent->NeedCleanup = TRUE;

    } else {
        // failed to allocate URB
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    UsbhExFreePool(tmp);

USBH_ParentFdoStartDevice_Done:

    //
    // complete the start Irp now since we pended it with
    // our completion handler.
    //

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_ParentQueryBusRelations(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to Bus_Reference_Next_Device, Bus_Query_Bus_Check,
  * //Bus_Query_Id: Bus_Id, HardwareIDs, CompatibleIDs and InstanceID.
  *
  * Arguments:
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION ioStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_OBJECT deviceObject;
    PSINGLE_LIST_ENTRY listEntry;
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;

    PAGED_CODE();


    USBH_KdPrint((1, "'Query Bus Relations (PAR) %x\n",
        DeviceExtensionParent->PhysicalDeviceObject));

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'QueryBusRelations (parent) ext = %x\n", DeviceExtensionParent));
    USBH_KdPrint((2,"'QueryBusRelations (parent) %x\n", ioStack->Parameters.QueryDeviceRelations.Type));

    USBH_ASSERT(ioStack->Parameters.QueryDeviceRelations.Type == BusRelations);

    USBH_KdPrint((2,"'ParentQueryBusRelations enumerate device\n"));

    //
    // It should be Function device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_PARENT == DeviceExtensionParent->ExtensionType);

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    deviceRelations = ExAllocatePoolWithTag(PagedPool, sizeof(*deviceRelations) +
        (DeviceExtensionParent->FunctionCount - 1) * sizeof(PDEVICE_OBJECT),
        USBHUB_HEAP_TAG);

    if (deviceRelations == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_ParentQueryBusRelations_Done;
    }

    deviceRelations->Count = 0;

    //
    // Functions on a composite device are always present
    // we just need to return the PDO
    //

    listEntry = DeviceExtensionParent->FunctionList.Next;

    while (listEntry) {

        deviceExtensionFunction =
             CONTAINING_RECORD(listEntry,
                               DEVICE_EXTENSION_FUNCTION,
                               ListEntry);

        USBH_KdPrint((2,"'deviceExtensionFunction = %x\n", deviceExtensionFunction));

        deviceObject = deviceExtensionFunction->FunctionPhysicalDeviceObject;
        ObReferenceObject(deviceObject);
        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        deviceRelations->Objects[deviceRelations->Count] = deviceObject;
        deviceRelations->Count++;

        listEntry = listEntry->Next;
    }

USBH_ParentQueryBusRelations_Done:

    Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    USBH_KdPrint((1, "'Query Bus Relations (PAR) %x pass on\n",
        DeviceExtensionParent->PhysicalDeviceObject));

    ntStatus = USBH_PassIrp(Irp,
                            DeviceExtensionParent->TopOfStackDeviceObject);

    return ntStatus;
}


NTSTATUS
USBH_FunctionPdoQueryId(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IRP_MJ_PNP, IRP_MN_QUERY_ID.
  *
  * Arguments:
  *
  * DeviceExtensionPort - should be the PDO we created for the port device Irp
  * - the Irp
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION       ioStack;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PDEVICE_EXTENSION_PORT   deviceExtensionPort;
    PDEVICE_EXTENSION_HUB    deviceExtensionHub;
#ifdef USB2
//    ULONG                    diagnosticFlags;
#else
    PUSBD_EXTENSION          deviceExtensionUsbd;
#endif
    USHORT                   idVendor;
    USHORT                   idProduct;
    LONG                     miId;
    NTSTATUS                 ntStatus = STATUS_SUCCESS;
    BOOLEAN                  diagnosticMode;

    PAGED_CODE();
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'IRP_MN_QUERY_ID function Pdo extension=%x\n", DeviceExtensionFunction));

    //
    // It should be physical device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_FUNCTION == DeviceExtensionFunction->ExtensionType);

    // It might not be too clean to reach into the RootHubPdo USBD extension,
    // but there doesn't seem to be any other easy way to determine if diag
    // mode is on.  If diagnostic mode is on, report the VID & PID as 0xFFFF
    // so that the diagnostic driver gets loaded for each interface of the
    // device.
    //
    deviceExtensionPort = (PDEVICE_EXTENSION_PORT)deviceExtensionParent->PhysicalDeviceObject->DeviceExtension;
    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

#ifdef USB2
//    diagnosticFlags = USBD_GetHackFlags(deviceExtensionHub);
//    diagnosticMode = (BOOLEAN)(USBD_DEVHACK_SET_DIAG_ID & diagnosticFlags);
    diagnosticMode = FALSE;
#else
    deviceExtensionUsbd = ((PUSBD_EXTENSION)deviceExtensionHub->RootHubPdo->DeviceExtension)->TrueDeviceExtension;
    diagnosticMode = deviceExtensionUsbd->DiagnosticMode;
#endif

    if (diagnosticMode)
    {
        idVendor  = 0xFFFF;
        idProduct = 0xFFFF;
        miId      = -1;
    }
    else
    {
        idVendor  = deviceExtensionParent->DeviceDescriptor.idVendor;
        idProduct = deviceExtensionParent->DeviceDescriptor.idProduct;
        miId      = DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->InterfaceNumber;
    }

    switch (ioStack->Parameters.QueryId.IdType) {
    case BusQueryDeviceID:
        Irp->IoStatus.Information =
          (ULONG_PTR)
          USBH_BuildDeviceID(idVendor,
                             idProduct,
                             miId,
                             FALSE);
        break;

    case BusQueryHardwareIDs:

        Irp->IoStatus.Information =
            (ULONG_PTR)
            USBH_BuildHardwareIDs(idVendor,
                                  idProduct,
                                  deviceExtensionParent->DeviceDescriptor.bcdDevice,
                                  miId,
                                  FALSE);

        break;

    case BusQueryCompatibleIDs:
        //
        // always use first interface
        //
        Irp->IoStatus.Information =
            (ULONG_PTR) USBH_BuildCompatibleIDs(
                "",
                "",
                DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->Class,
                DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->SubClass,
                DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->Protocol,
                FALSE,
                FALSE);

        break;

    case BusQueryInstanceID:

        Irp->IoStatus.Information =
            (ULONG_PTR) USBH_BuildInstanceID(&DeviceExtensionFunction->UniqueIdString[0],
                                         sizeof(DeviceExtensionFunction->UniqueIdString));
        break;

    default:
        USBH_KdBreak(("PdoBusExtension Unknown BusQueryId\n"));
        // IrpAssert: Must not change Irp->IoStatus.Status for bogus IdTypes,
        // so return original status here.
        return Irp->IoStatus.Status;
    }

    if (Irp->IoStatus.Information == 0) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_FunctionPdoQueryDeviceText(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES).
  * Supposedly, this is a message forwarded by port device Fdo.
  *
  * Argument:
  *
  * DeviceExtensionPort - This is a a Pdo extension we created for the port
  * device. Irp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION ioStack;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    DEVICE_TEXT_TYPE deviceTextType;
    LANGID languageId;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PWCHAR deviceText;

    PAGED_CODE();
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;
    deviceExtensionPort = (PDEVICE_EXTENSION_PORT)deviceExtensionParent->PhysicalDeviceObject->DeviceExtension;
    deviceObject = deviceExtensionPort->PortPhysicalDeviceObject;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

    deviceTextType = ioStack->
            Parameters.QueryDeviceText.DeviceTextType;

    // Validate DeviceTextType for IrpAssert

    if (deviceTextType != DeviceTextDescription &&
        deviceTextType != DeviceTextLocationInformation) {

        USBH_KdPrint((2, "'PdoQueryDeviceText called with bogus DeviceTextType\n"));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
        goto USBH_FunctionPdoQueryDeviceTextDone;
    }

    // we don't care about the hiword
    //languageId = (USHORT) (ioStack->Parameters.QueryDeviceText.LocaleId >>16);
    // always specify english for now.
    languageId = 0x0409;
    USBH_KdPrint((2,"'PdoQueryDeviceText Pdo %x type = %x, lang = %x locale %x\n",
            deviceObject, deviceTextType, languageId, ioStack->Parameters.QueryDeviceText.LocaleId));

    //
    // see if the device supports strings, for non complient device mode
    // we won't even try
    //

    if (deviceExtensionPort->DeviceData == NULL ||
        deviceExtensionPort->DeviceDescriptor.iProduct == 0 ||
        (deviceExtensionPort->DeviceHackFlags & USBD_DEVHACK_DISABLE_SN) ||
        (deviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR)) {
        // string descriptor
        USBH_KdBreak(("no product string\n", deviceObject));
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

        if (usbString) {

            ntStatus = USBH_CheckDeviceLanguage(deviceObject,
                                                languageId);

            if (NT_SUCCESS(ntStatus)) {
                //
                // device supports are language, get the string
                //

                ntStatus = USBH_SyncGetStringDescriptor(deviceObject,
                                                        deviceExtensionPort->DeviceDescriptor.iProduct, //index
                                                        languageId, //langid
                                                        usbString,
                                                        MAXIMUM_USB_STRING_LENGTH,
                                                        NULL,
                                                        TRUE);

                if (NT_SUCCESS(ntStatus) &&
                    usbString->bLength <= sizeof(UNICODE_NULL)) {

                    ntStatus = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(ntStatus)) {
                    //
                    // return the string
                    //

                    //
                    // must use stock alloc function because the caller frees the
                    // buffer
                    //
                    // note: the descriptor header is the same size as
                    // a unicode NULL so we don't have to adjust the size
                    //

                    deviceText = ExAllocatePoolWithTag(PagedPool, usbString->bLength, USBHUB_HEAP_TAG);
                    if (deviceText) {
                        RtlZeroMemory(deviceText, usbString->bLength);
                        RtlCopyMemory(deviceText, &usbString->bString[0],
                            usbString->bLength - sizeof(UNICODE_NULL));

                        Irp->IoStatus.Information = (ULONG_PTR) deviceText;

                        USBH_KdBreak(("Returning Device Text %x\n", deviceText));
                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }

            UsbhExFreePool(usbString);
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

USBH_FunctionPdoQueryDeviceTextDone:

    return ntStatus;
}


NTSTATUS
USBH_FunctionPdoPnP(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN OUT PBOOLEAN IrpNeedsCompletion
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
#if DBG
    PDEVICE_OBJECT deviceObject = DeviceExtensionFunction->FunctionPhysicalDeviceObject;
#endif
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    *IrpNeedsCompletion = TRUE;

    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    USBH_KdPrint((2,"'PnP Power Pdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
// Ken says take this out
//    case IRP_MN_SURPRISE_REMOVAL:
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_START_DEVICE:
        USBH_KdPrint((1,
            "'Starting composite PDO %x\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((1,
            "'Stopping composite PDO %x\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((1,
            "'Removing composite PDO %x\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        {
        PDEVICE_CAPABILITIES deviceCapabilities;
        PIO_STACK_LOCATION ioStack;

        USBH_KdPrint((2,"'IRP_MN_QUERY_CAPABILITIES Function Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;

        ioStack = IoGetCurrentIrpStackLocation(Irp);

        deviceCapabilities = ioStack->
            Parameters.DeviceCapabilities.Capabilities;
        //
        // clone the capabilities for the parent
        //
        //

        // fill in the the device state capabilities from the
        // table we saved from the pdo.
        //

        RtlCopyMemory(&deviceCapabilities->DeviceState[0],
                      &deviceExtensionParent->DeviceState[0],
                      sizeof(deviceExtensionParent->DeviceState));

        //
        // clone the device wake capabilities for children
        // from the parent.
        //
        deviceCapabilities->DeviceWake =
            deviceExtensionParent->DeviceWake;
        deviceCapabilities->SystemWake =
            deviceExtensionParent->SystemWake;

        //
        // we will need to modify these based on information
        // returned in the power descriptor
        //

        deviceCapabilities->Removable = FALSE;
        deviceCapabilities->UniqueID = FALSE;
//      SurpriseRemovalOK is FALSE by default, and some clients (NDIS)
//      set it to true on the way down, in accordance with the DDK.
//        deviceCapabilities->SurpriseRemovalOK = FALSE;
        deviceCapabilities->RawDeviceOK = FALSE;

        }
        break;

    case IRP_MN_QUERY_ID:
        USBH_KdPrint((2,"'IRP_MN_QUERY_ID Pdo %x\n", deviceObject));
        ntStatus = USBH_FunctionPdoQueryId(DeviceExtensionFunction, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:
        USBH_KdPrint((2,"'IRP_MN_QUERY_DEVICE_TEXT Pdo %x\n", deviceObject));
        ntStatus = USBH_FunctionPdoQueryDeviceText(DeviceExtensionFunction, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        // this is a leaf node, we return the status passed
        // to us unless it is a call to TargetRelations
        if (irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation) {

            PDEVICE_RELATIONS deviceRelations = NULL;


            deviceRelations = ExAllocatePoolWithTag(PagedPool,
                sizeof(*deviceRelations), USBHUB_HEAP_TAG);

            if (deviceRelations == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                ObReferenceObject(
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject);
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] =
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject;
                ntStatus = STATUS_SUCCESS;
            }

            USBH_KdPrint((1, "'Query Target Relations (FUN) PDO %x complt\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));


            Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

        } else {
            ntStatus = Irp->IoStatus.Status;
        }
        break;

    case IRP_MN_QUERY_INTERFACE:

        USBH_KdPrint((1,"'IRP_MN_QUERY_INTERFACE, xface type: %x\n",
            irpStack->Parameters.QueryInterface.InterfaceType));

        // Pass this on to the parent.
        ntStatus = USBH_PassIrp(Irp, deviceExtensionParent->FunctionalDeviceObject);
        *IrpNeedsCompletion = FALSE;
        break;

    default:
        USBH_KdBreak(("PdoPnP unknown (%d) PnP message Pdo %x\n",
                      MinorFunction, deviceObject));
        ntStatus = Irp->IoStatus.Status;
    }

    USBH_KdPrint((2,"'FunctionPdoPnP exit %x\n", ntStatus));

    return ntStatus;
}


VOID
USBH_ParentWaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION_HEADER devExtHeader;
    PDEVICE_EXTENSION_FUNCTION function;
    PDEVICE_EXTENSION_PARENT parent;
    NTSTATUS ntStatus = STATUS_CANCELLED;
    LONG pendingChildWWs;
    PIRP parentWaitWake = NULL;

    USBH_KdPrint((1,"'Function WaitWake Irp %x cancelled\n", Irp));

    USBH_ASSERT(DeviceObject);

    devExtHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    USBH_ASSERT(devExtHeader->ExtensionType == EXTENSION_TYPE_FUNCTION);

    function = (PDEVICE_EXTENSION_FUNCTION) devExtHeader;
    parent = function->DeviceExtensionParent;

    if (Irp != function->WaitWakeIrp) {
        //
        // Nothing to do
        // This Irp has already been taken care of.
        // We are in the process of completing this IRP in
        // USBH_ParentCompleteFunctionWakeIrps.
        //
        IoReleaseCancelSpinLock(Irp->CancelIrql);

    } else {
        function->WaitWakeIrp = NULL;
        IoSetCancelRoutine(Irp, NULL);

        pendingChildWWs = InterlockedDecrement (&parent->NumberFunctionWakeIrps);
        parentWaitWake = parent->PendingWakeIrp;
        if (0 == pendingChildWWs) {
            // Set PendingWakeIrp to NULL since we cancel it below.
            parent->PendingWakeIrp = NULL;
            parent->ParentFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // If there are no more outstanding WW irps, we need to cancel the WW
        // to our parent.
        //
        if (0 == pendingChildWWs) {
            IoCancelIrp (parentWaitWake);
        } else {
            ASSERT (0 < pendingChildWWs);
        }
    }
}


NTSTATUS
USBH_FunctionPdoPower(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl Power for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
#if DBG
    PDEVICE_OBJECT deviceObject = DeviceExtensionFunction->FunctionPhysicalDeviceObject;
#endif
    PIO_STACK_LOCATION irpStack;
    USHORT feature;
    KIRQL irql;
    PIRP wWIrp;
    PIRP parentWaitWake;
    LONG pendingFunctionWWs;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PDRIVER_CANCEL oldCancel;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    USBH_KdPrint((2,"'Power Pdo %x minor %x\n", deviceObject, MinorFunction));
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    switch (MinorFunction) {

    case IRP_MN_SET_POWER:

        USBH_KdPrint((2,"'IRP_MN_SET_POWER\n"));

        //
        // we just return success here, pnp will make sure
        // all children have entred the low power state
        // before putting the parent in a low power state
        //

        //
        // send the setpower feature request here if the device
        // wants it
        //

        ntStatus = STATUS_SUCCESS;

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            USBH_KdPrint(
                (1, "'IRP_MJ_POWER PA pdo(%x) MN_SET_POWER(SystemPowerState) complt\n",
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject));

            ntStatus = STATUS_SUCCESS;
            break;

        case DevicePowerState:
            ntStatus = STATUS_SUCCESS;
            USBH_KdPrint(
                (1, "'IRP_MJ_POWER PA pdo(%x) MN_SET_POWER(DevicePowerState) complt\n",
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject));

            break;
        } // switch irpStack->Parameters.Power.Type
        break; //IRP_MN_SET_POWER

    case IRP_MN_QUERY_POWER:

        ntStatus = STATUS_SUCCESS;
        USBH_KdPrint(
            (1, "'IRP_MJ_POWER PA pdo(%x) MN_QUERY_POWER, status = %x complt\n",
            DeviceExtensionFunction->FunctionPhysicalDeviceObject, ntStatus));

        break;

    case IRP_MN_WAIT_WAKE:

        USBH_KdPrint(
            (1, "'enabling remote wakeup for USB child PDO (%x)\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        if (deviceExtensionParent->CurrentPowerState != PowerDeviceD0 ||
            deviceExtensionParent->ParentFlags & HUBFLAG_DEVICE_STOPPING) {

            LOGENTRY(LOG_PNP, "!WWp", deviceExtensionParent, 0, 0);

            UsbhWarning(NULL,
                        "Client driver should not be submitting WW IRPs at this time.\n",
                        TRUE);

            ntStatus = STATUS_INVALID_DEVICE_STATE;
            break;
        }

        IoAcquireCancelSpinLock(&irql);
        if (DeviceExtensionFunction->WaitWakeIrp != NULL) {
            ntStatus = STATUS_DEVICE_BUSY;
            IoReleaseCancelSpinLock(irql);

        } else {

            // set a cancel routine
            oldCancel = IoSetCancelRoutine(Irp, USBH_ParentWaitWakeCancel);
            USBH_ASSERT (NULL == oldCancel);

            if (Irp->Cancel) {
                TEST_TRAP();

                IoSetCancelRoutine (Irp, NULL);
                IoReleaseCancelSpinLock(irql);
                ntStatus = STATUS_CANCELLED;

            } else {

                // flag this device as "enabled for wakeup"
                DeviceExtensionFunction->WaitWakeIrp = Irp;
                pendingFunctionWWs =
                    InterlockedIncrement (&deviceExtensionParent->NumberFunctionWakeIrps);
                IoMarkIrpPending(Irp);
                IoReleaseCancelSpinLock(irql);

                //
                // now we must enable the parent PDO for wakeup
                //
                if (1 == pendingFunctionWWs) {
                    // What if this fails?
                    ntStatus = USBH_ParentSubmitWaitWakeIrp(deviceExtensionParent);
                } else {
                    ntStatus = STATUS_PENDING;
                }

                ntStatus = STATUS_PENDING;
                goto USBH_FunctionPdoPower_Done;
            }
        }

        break;

    default:
        USBH_KdBreak(("PdoPnP unknown (%d) PnP message Pdo %x\n",
                      MinorFunction, deviceObject));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
    }

    USBH_KdPrint((2,"'FunctionPdoPower exit %x\n", ntStatus));

    PoStartNextPowerIrp(Irp);
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

USBH_FunctionPdoPower_Done:

    return ntStatus;
}

NTSTATUS
USBH_ParentQCapsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Called when lower device completes Q_CAPS.
    This gives us a chance to mark the device as SurpriseRemovalOK.

Arguments:
    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES pDevCaps = irpStack->Parameters.DeviceCapabilities.Capabilities;
    NTSTATUS ntStatus;

    USBH_KdPrint((1, "'USBH_ParentQCapsComplete\n"));

    ntStatus = Irp->IoStatus.Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Set SurpriseRemoval flag to TRUE
    //
    pDevCaps->SurpriseRemovalOK = TRUE;

    return ntStatus;
}



NTSTATUS
USBH_ParentPnP(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnP for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionParent - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'PnP Fdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        USBH_KdBreak(("'IRP_MN_START_DEVICE Parent Fdo %x\n", deviceObject));
        // we get here as a result of re-start.
        // note: our parent hub already checked to see if the device is the same.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_ParentFdoStartDevice(DeviceExtensionParent, Irp, FALSE);
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_STOP_DEVICE Fdo %x\n", deviceObject));
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_ParentFdoStopDevice(DeviceExtensionParent, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_REMOVE_DEVICE Fdo %x\n", deviceObject));
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_ParentFdoRemoveDevice(DeviceExtensionParent, Irp);
        break;

//
// This one should be passed down.  Let the default case handle it.
//
//    case IRP_MN_QUERY_PNP_DEVICE_STATE:
//        USBH_KdPrint((2,"IRP_MN_QUERY_PNP_DEVICE_STATE Pdo %x\n", deviceObject));
//        ntStatus = STATUS_SUCCESS;
//        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        switch (irpStack->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:

            ntStatus = USBH_ParentQueryBusRelations(DeviceExtensionParent, Irp);
            break;

        case TargetDeviceRelation:
            //
            // this one gets passed on
            //

            USBH_KdPrint((1, "'Query Relations, TargetRelations (PAR) %x\n",
                DeviceExtensionParent->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionParent->TopOfStackDeviceObject);
            break;

        default:

            USBH_KdPrint((1, "'Query Relations (?) (PAR) %x pass on\n",
                DeviceExtensionParent->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionParent->TopOfStackDeviceObject);

        }
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        USBH_KdPrint((1, "'Query Capabilities (PAR) %x\n",
            DeviceExtensionParent->PhysicalDeviceObject));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        // Set up a completion routine to handle marking the IRP.
        IoSetCompletionRoutine(Irp,
                               USBH_ParentQCapsComplete,
                               DeviceExtensionParent,
                               TRUE,
                               TRUE,
                               TRUE);

        // Now pass down the IRP.

        ntStatus = IoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
// Ken says take this out
//    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        // IrpAssert: Must set IRP status before passing IRP down.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        // fall through

        //
        // Pass it down to Pdo to handle all other MN functions
        //
    default:
        USBH_KdPrint((2,"'Query/Cancel/Power request on parent fdo %x  %x\n",
                      deviceObject, MinorFunction));
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionParent->TopOfStackDeviceObject);
        break;
    }

    USBH_KdPrint((2,"'ParentPnP exit %x\n", ntStatus));
    return ntStatus;
}


NTSTATUS
USBH_ParentPower(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl Power for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionParent - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'Power Fdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {

    case IRP_MN_QUERY_POWER:

        USBH_KdPrint(
            (1, "'IRP_MJ_POWER PA fdo(%x) MN_QUERY_POWER\n",
            DeviceExtensionParent->FunctionalDeviceObject));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        //
        // must pass this on to our PDO
        //
        ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                Irp);

        break;

    case IRP_MN_SET_POWER:

        USBH_KdPrint(
            (1, "'IRP_MJ_POWER PA fdo(%x) MN_QUERY_POWER\n",
            DeviceExtensionParent->FunctionalDeviceObject));

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            {
            POWER_STATE powerState;

            USBH_KdPrint(
                (1, "IRP_MJ_POWER PA fdo(%x) MN_SET_POWER(SystemPowerState)\n",
                    DeviceExtensionParent->FunctionalDeviceObject));

            if (irpStack->Parameters.Power.State.SystemState ==
                PowerSystemWorking) {
                powerState.DeviceState = PowerDeviceD0;
            } else if (DeviceExtensionParent->ParentFlags &
                       HUBFLAG_ENABLED_FOR_WAKEUP) {
                //
                // based on the system power state
                // request a setting to the appropriate
                // Dx state.
                //
                powerState.DeviceState =
                    DeviceExtensionParent->DeviceState[irpStack->Parameters.Power.State.SystemState];

                //
                // These tables should have already been fixed up by the root hub
                // (usbd.sys) to not contain an entry of unspecified.
                //
                ASSERT (PowerDeviceUnspecified != powerState.DeviceState);

                USBH_KdPrint((2,"'Parent System state maps to device state 0x%x\n",
                              powerState.DeviceState));

            } else {
                TEST_TRAP();
                powerState.DeviceState = PowerDeviceD3;
            } // irpStack->Parameters.Power.State.SystemState

            //
            // only make the request if it is for a differnt power
            // state then the one we are in.
            //

            if (powerState.DeviceState !=
                DeviceExtensionParent->CurrentPowerState) {

                DeviceExtensionParent->PowerIrp = Irp;
                ntStatus = PoRequestPowerIrp(DeviceExtensionParent->PhysicalDeviceObject,
                                          IRP_MN_SET_POWER,
                                          powerState,
                                          USBH_FdoDeferPoRequestCompletion,
                                          DeviceExtensionParent,
                                          NULL);

            } else {
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                        Irp);
            }
            }
            break;

        case DevicePowerState:

            USBH_KdPrint(
                (1, "IRP_MJ_POWER PA fdo(%x) MN_SET_POWER(DevicePowerState)\n",
                    DeviceExtensionParent->FunctionalDeviceObject));

            DeviceExtensionParent->CurrentPowerState =
                    irpStack->Parameters.Power.State.DeviceState;


            LOGENTRY(LOG_PNP, "prD>", DeviceExtensionParent, DeviceExtensionParent->CurrentPowerState , 0);
            //
            // all of our pdos need to be at or below the
            // expected D-state
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoStartNextPowerIrp(Irp);
            ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                    Irp);

            USBH_KdPrint((2,"'Parent Device Power State PoCallDriver() = %x\n",
                               ntStatus));

            break;
        }

        break; // MN_SET_POWER

    default:
        USBH_KdPrint((2,"'Power request on parent not handled, fdo %x  %x\n",
                      deviceObject, MinorFunction));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                Irp);
        break;
    }

    USBH_KdPrint((2,"'ParentPnP exit %x\n", ntStatus));
    return ntStatus;
}

NTSTATUS
USBH_ParentDispatch(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Handles calls to a FDO associated with a composite device
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;

    USBH_KdPrint((2,"'FdoDispatch DeviceExtension %x Irp %x\n",
        DeviceExtensionParent, Irp));
    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    //
    // the called functions will complete the irp if necessary
    //

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:

        USBH_KdPrint((2,"'IRP_MJ_CREATE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_CLOSE:

        USBH_KdPrint((2,"'IRP_MJ_CLOSE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_DEVICE_CONTROL:
        //
        // Note: if we ever do find a reason to handle this, be sure to
        // not forward IOCTL_KS_PROPERTY / KSPROPSETID_DrmAudioStream /
        // KSPROPERTY_DRMAUDIOSTREAM_SETCONTENTID to next driver!  Otherwise
        // this might not be DRM compliant.
        //
        USBH_KdPrint((2,"'IRP_MJ_DEVICE_CONTROL\n"));
        UsbhWarning(NULL,"Should not be hitting this code\n", FALSE);
        ntStatus = STATUS_UNSUCCESSFUL;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        USBH_KdPrint((2,"'InternlDeviceControl IOCTL unknown pass on\n"));
        UsbhWarning(NULL,"Should not be hitting this code\n", FALSE);
        ntStatus = STATUS_UNSUCCESSFUL;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_PNP:

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));

        ntStatus = USBH_ParentPnP(DeviceExtensionParent, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));

        ntStatus = USBH_ParentPower(DeviceExtensionParent, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_SYSTEM_CONTROL:

        USBH_KdPrint((2,"'IRP_MJ_SYSTEM_CONTROL\n"));
#ifdef WMI_SUPPORT
        ntStatus =
            USBH_SystemControl ((PDEVICE_EXTENSION_FDO) DeviceExtensionParent, Irp);
#else
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionParent->TopOfStackDeviceObject);
#endif
        break;

    default:
        //
        // Unknown Irp -- complete with error
        //
        USBH_KdBreak(("Unknown Irp for Fdo %x Irp_Mj %x\n",
                  deviceObject, ioStackLocation->MajorFunction));
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_CompleteIrp(Irp, ntStatus);
        break;
    }

    USBH_KdPrint((2,"' exit USBH_ParentDispatch Object %x Status %x\n",
                  deviceObject, ntStatus));

    //
    // always return a status code
    //

    return ntStatus;
}


NTSTATUS
USBH_FunctionUrbFilter(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PURB urb;
    USHORT function;

    USBH_KdPrint((2,"'USBH_FunctionUrbFilter DeviceExtension %x Irp %x\n",
        DeviceExtensionFunction, Irp));

    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    LOGENTRY(LOG_PNP, "fURB", DeviceExtensionFunction, deviceExtensionParent,
        deviceExtensionParent->ParentFlags);

    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    urb = ioStackLocation->Parameters.Others.Argument1;

    // check the command code code the URB

    function = urb->UrbHeader.Function;

    if (deviceExtensionParent->CurrentPowerState !=
        PowerDeviceD0) {

        // the child devices should not be passing in urbs
        // unless th eparent is in D0

        UsbhWarning(NULL,
           "Parent Not in D0.\n",
           TRUE);

    }

    switch(function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:
        {
        //
        // if the requested config matches the current config
        // then go ahead and return the current interface
        // information for all interfaces requested.
        //
        PUSBD_INTERFACE_INFORMATION interface;

        if (urb->UrbSelectConfiguration.ConfigurationDescriptor == NULL) {
            USBH_KdBreak(("closing config on a composite device\n"));

            //
            // closing the configuration,
            // just return success.
            //

            urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
            ntStatus = STATUS_SUCCESS;
        } else {
            ULONG i;

            //
            // Normally the URB will contain only one interface.
            // the special case is audio which may contain two
            // so we have to have a check to handle this.
            //

            interface = &urb->UrbSelectConfiguration.Interface;

USBH_FunctionUrbFilter_Next:

            USBH_KdPrint((2,"'interface = %x\n",
                    interface));

            //
            // should validate the requested interface against the
            // current config.
            //
            USBH_KdBreak(("need some validation here!\n"));

            USBH_ASSERT(urb->UrbSelectConfiguration.ConfigurationDescriptor->bConfigurationValue
                    == deviceExtensionParent->CurrentConfig);

            // find the interface we are interested in
            for (i=0; i< DeviceExtensionFunction->InterfaceCount; i++) {
                PFUNCTION_INTERFACE functionInterface;

                functionInterface =
                    &DeviceExtensionFunction->FunctionInterfaceList[i];

                USBH_KdPrint((2,"'functionInterface  = %x, %x\n",
                   functionInterface, functionInterface->InterfaceInformation));

                if (functionInterface->InterfaceInformation->InterfaceNumber ==
                    interface->InterfaceNumber) {
                    break;
                }
            }

            if (i < DeviceExtensionFunction->InterfaceCount) {
                PFUNCTION_INTERFACE functionInterface;

                functionInterface =
                    &DeviceExtensionFunction->FunctionInterfaceList[i];

                if (functionInterface->InterfaceInformation->AlternateSetting !=
                    interface->AlternateSetting) {

                    PURB iUrb;
                    NTSTATUS localStatus;
                    PUSBD_INTERFACE_INFORMATION localInterface;
                    USHORT siz;

                    // client is requesting a different alternate setting
                    // we need to do a select_interface

                    siz =
                        (USHORT)(GET_SELECT_INTERFACE_REQUEST_SIZE(interface->NumberOfPipes));

                    iUrb = UsbhExAllocatePool(NonPagedPool, siz);
                    if (iUrb) {
                        localInterface = &iUrb->UrbSelectInterface.Interface;

                        iUrb->UrbSelectInterface.Hdr.Function =
                            URB_FUNCTION_SELECT_INTERFACE;
                        iUrb->UrbSelectInterface.Hdr.Length = siz;
                        iUrb->UrbSelectInterface.ConfigurationHandle =
                            DeviceExtensionFunction->ConfigurationHandle;

                        USBH_KdPrint((2,"'localInterface = %x\n",
                            localInterface));

                        RtlCopyMemory(localInterface,
                                      interface,
                                      interface->Length);

                        localStatus = USBH_SyncSubmitUrb(
                            deviceExtensionParent->TopOfStackDeviceObject,
                            iUrb);


                        UsbhExFreePool(functionInterface->InterfaceInformation);

                        functionInterface->InterfaceInformation =
                            UsbhExAllocatePool(NonPagedPool,
                                               interface->Length);

                        RtlCopyMemory(functionInterface->InterfaceInformation,
                                      localInterface,
                                      localInterface->Length);

                        UsbhExFreePool(iUrb);
                        iUrb = NULL;
                    }

                }

                USBH_ASSERT(interface->Length ==
                      functionInterface->InterfaceInformation->Length);

                RtlCopyMemory(interface,
                              functionInterface->InterfaceInformation,
                              functionInterface->InterfaceInformation->Length);

                urb->UrbSelectConfiguration.ConfigurationHandle =
                    DeviceExtensionFunction->ConfigurationHandle;

                urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
                ntStatus = STATUS_SUCCESS;
            } else {
                ntStatus = STATUS_INVALID_PARAMETER;
            }

            //
            // check for multiple interfaces e.g. audio
            //

            if (DeviceExtensionFunction->InterfaceCount > 1) {

                interface = (PUSBD_INTERFACE_INFORMATION)
                    (((PUCHAR) interface) + interface->Length);

                if ((PUCHAR)interface < (((PUCHAR) urb) +
                    urb->UrbSelectConfiguration.Hdr.Length)) {
                    goto USBH_FunctionUrbFilter_Next;
                }
            }
        }

        USBH_CompleteIrp(Irp, ntStatus);
        }

        break;

    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
        {
        PUCHAR userBuffer = NULL;
        ULONG bytesReturned;

        //
        // if we requesting the configuration descriptor then we
        // will return it based on the information in our extension.
        //
        if (urb->UrbControlDescriptorRequest.DescriptorType ==
            USB_CONFIGURATION_DESCRIPTOR_TYPE) {

            if (urb->UrbControlDescriptorRequest.TransferBufferMDL) {
                ntStatus = STATUS_INVALID_PARAMETER;
            } else {
                userBuffer =
                    urb->UrbControlDescriptorRequest.TransferBuffer;

                ntStatus = USBH_BuildFunctionConfigurationDescriptor(
                                DeviceExtensionFunction,
                                userBuffer,
                                urb->UrbControlDescriptorRequest.TransferBufferLength,
                                &bytesReturned);

                urb->UrbControlDescriptorRequest.TransferBufferLength =
                    bytesReturned;

                urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
            }

            USBH_CompleteIrp(Irp, ntStatus);

        } else {
            ntStatus = USBH_PassIrp(Irp,
                                    deviceExtensionParent->TopOfStackDeviceObject);
        }
        }
        break;

    default:
        //
        // forward the request to the parents PDO
        //
        ntStatus = USBH_PassIrp(Irp,
                                deviceExtensionParent->TopOfStackDeviceObject);
        break;
    }

    return ntStatus;
}


VOID
USBH_CancelAllIrpsInList(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
 /*
  * Description:
  *
  *     This function walks the list of devices and cancels all the queued
  *     ResetIrps in the list.
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PSINGLE_LIST_ENTRY          listEntry;
    PDEVICE_EXTENSION_FUNCTION  deviceExtensionFunction;

    listEntry = DeviceExtensionParent->FunctionList.Next;

    while (listEntry) {
        deviceExtensionFunction =
            CONTAINING_RECORD(listEntry,
                              DEVICE_EXTENSION_FUNCTION,
                              ListEntry);
        ASSERT_FUNCTION(deviceExtensionFunction);

        if (deviceExtensionFunction->ResetIrp) {
            USBH_CompleteIrp(deviceExtensionFunction->ResetIrp, STATUS_UNSUCCESSFUL);
            deviceExtensionFunction->ResetIrp = NULL;
        }

        listEntry = listEntry->Next;
    }
}


VOID
USBH_CompResetTimeoutWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a composite reset timeout.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMP_RESET_TIMEOUT_WORK_ITEM  workItemCompResetTimeout;
    PDEVICE_EXTENSION_PARENT            deviceExtensionParent;

    workItemCompResetTimeout = Context;
    deviceExtensionParent = workItemCompResetTimeout->DeviceExtensionParent;

    USBH_KdPrint((2,"'CompReset timeout\n"));
    LOGENTRY(LOG_PNP, "CRTO", deviceExtensionParent, 0, 0);

    USBH_KdPrint((2,"'*** (CRTW) WAIT parent mutex %x\n", deviceExtensionParent));
    KeWaitForSingleObject(&deviceExtensionParent->ParentMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'*** (CRTW) WAIT parent mutex done %x\n", deviceExtensionParent));

    USBH_CancelAllIrpsInList(deviceExtensionParent);

    USBH_KdPrint((2,"'*** (CRTW) RELEASE parent mutex %x\n", deviceExtensionParent));
    KeReleaseSemaphore(&deviceExtensionParent->ParentMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    UsbhExFreePool(workItemCompResetTimeout);
}


VOID
USBH_CompResetTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PCOMP_RESET_TIMEOUT_CONTEXT compResetTimeoutContext = DeferredContext;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent =
                                compResetTimeoutContext->DeviceExtensionParent;
    BOOLEAN cancelFlag;
    PUSBH_COMP_RESET_TIMEOUT_WORK_ITEM workItemCompResetTimeout;

    USBH_KdPrint((2,"'COMP_RESET_TIMEOUT\n"));

    // Take SpinLock here so that main routine won't write CancelFlag
    // in the timeout context while we free the timeout context.

    KeAcquireSpinLockAtDpcLevel(&deviceExtensionParent->ParentSpinLock);

    cancelFlag = compResetTimeoutContext->CancelFlag;
    deviceExtensionParent->CompResetTimeoutContext = NULL;

    KeReleaseSpinLockFromDpcLevel(&deviceExtensionParent->ParentSpinLock);

    UsbhExFreePool(compResetTimeoutContext);

    if (!cancelFlag) {
        //
        // Schedule a work item to process this.
        //
        workItemCompResetTimeout = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_COMP_RESET_TIMEOUT_WORK_ITEM));

        if (workItemCompResetTimeout) {

            workItemCompResetTimeout->DeviceExtensionParent = deviceExtensionParent;

            ExInitializeWorkItem(&workItemCompResetTimeout->WorkQueueItem,
                                 USBH_CompResetTimeoutWorker,
                                 workItemCompResetTimeout);

            LOGENTRY(LOG_PNP, "crER", deviceExtensionParent,
                &workItemCompResetTimeout->WorkQueueItem, 0);

            ExQueueWorkItem(&workItemCompResetTimeout->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_CompResetTimeoutWorker()
            // Don't try to access the WorkItem after it is queued.
        }
    }
}


BOOLEAN
USBH_ListReadyForReset(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
 /*
  * Description:
  *
  *     This function walks the list of devices to see if we are ready
  *     to do the actual reset.
  *
  * Arguments:
  *
  * Return:
  *
  * TRUE if we're ready, FALSE if we're not.
  *
  * -- */
{
    PSINGLE_LIST_ENTRY          listEntry;
    PDEVICE_EXTENSION_FUNCTION  deviceExtensionFunction;

    listEntry = DeviceExtensionParent->FunctionList.Next;

    while (listEntry) {
        deviceExtensionFunction =
            CONTAINING_RECORD(listEntry,
                              DEVICE_EXTENSION_FUNCTION,
                              ListEntry);
        ASSERT_FUNCTION(deviceExtensionFunction);

        if (!deviceExtensionFunction->ResetIrp)
            return FALSE;

        listEntry = listEntry->Next;
    }

    return TRUE;
}


NTSTATUS
USBH_ResetParentPort(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
/*++

Routine Description:

    Calls the parent device to reset its port.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    USBH_KdPrint((2,"'CompReset parent port\n"));
    LOGENTRY(LOG_PNP, "CRPP", DeviceExtensionParent, 0, 0);

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                DeviceExtensionParent->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    ntStatus = IoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    return ntStatus;
}


VOID
USBH_CompositeResetPortWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to process a composite port reset.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMP_RESET_WORK_ITEM  workItemCompReset;
    PSINGLE_LIST_ENTRY          listEntry;
    PDEVICE_EXTENSION_PARENT    deviceExtensionParent;
    PDEVICE_EXTENSION_FUNCTION  deviceExtensionFunction;

    USBH_KdPrint((2,"'Composite Reset Executing!\n"));

    workItemCompReset = Context;
    deviceExtensionParent = workItemCompReset->DeviceExtensionParent;

    LOGENTRY(LOG_PNP, "CRW_", deviceExtensionParent, 0, 0);

    // Send reset to parent (IoCallDriver)

    USBH_ResetParentPort(deviceExtensionParent);

    // Now, complete all Irps in list and set the Irps in the list to NULL.

    USBH_KdPrint((2,"'*** (CRW) WAIT parent mutex %x\n", deviceExtensionParent));
    KeWaitForSingleObject(&deviceExtensionParent->ParentMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'*** (CRW) WAIT parent mutex done %x\n", deviceExtensionParent));

    listEntry = deviceExtensionParent->FunctionList.Next;

    while (listEntry) {
        deviceExtensionFunction =
            CONTAINING_RECORD(listEntry,
                              DEVICE_EXTENSION_FUNCTION,
                              ListEntry);
        ASSERT_FUNCTION(deviceExtensionFunction);

        // Although ResetIrp should usually be set here, we check anyway in
        // case it had already been completed in USBH_CompleteAllIrpsInList.
        //
        if (deviceExtensionFunction->ResetIrp) {
            USBH_CompleteIrp(deviceExtensionFunction->ResetIrp, STATUS_SUCCESS);
            deviceExtensionFunction->ResetIrp = NULL;
        }

        listEntry = listEntry->Next;
    }

    USBH_KdPrint((2,"'*** (CRW) RELEASE parent mutex %x\n", deviceExtensionParent));
    KeReleaseSemaphore(&deviceExtensionParent->ParentMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    UsbhExFreePool(workItemCompReset);
}


NTSTATUS
USBH_FunctionPdoDispatch(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  *     This function handles calls to PDOs we have created
  *     since we are the bottom driver for the PDO it is up
  *     to us to complete the irp -- with one exception.
  *
  *     api calls to the USB stack are forwarded directly
  *     to the PDO for the root hub which is owned by the USB
  *     HC.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PCOMP_RESET_TIMEOUT_CONTEXT compResetTimeoutContext = NULL;
    LARGE_INTEGER dueTime;
    KIRQL irql;
    BOOLEAN bCompleteIrp;

    USBH_KdPrint((2,"'FunctionPdoDispatch DeviceExtension %x Irp %x\n",
        DeviceExtensionFunction, Irp));
    deviceObject = DeviceExtensionFunction->FunctionPhysicalDeviceObject;
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:
        USBH_KdPrint((2,"'PARENT PDO IRP_MJ_CREATE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_CLOSE:
        USBH_KdPrint((2,"'PARENT PDO IRP_MJ_CLOSE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
        ULONG ioControlCode;

        USBH_KdPrint((2,"'Internal Device Control\n"));

        if (deviceExtensionParent->ParentFlags & HUBFLAG_DEVICE_STOPPING) {
            UsbhWarning(NULL,
                "Client Device Driver is sending requests to a device that has been removed.\n",
                FALSE);

            ntStatus = STATUS_DEVICE_REMOVED;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }

        ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode) {
        case IOCTL_INTERNAL_USB_GET_PORT_STATUS:
            USBH_KdPrint((2,"'Composite GetPortStatus, pass on\n"));
            ntStatus = USBH_PassIrp(Irp, deviceExtensionParent->TopOfStackDeviceObject);
            break;

        case IOCTL_INTERNAL_USB_RESET_PORT:

            LOGENTRY(LOG_PNP, "fRES", deviceExtensionParent, 0, 0);

            USBH_KdPrint((2,"'Composite Reset Requested\n"));
            if (deviceExtensionParent->CurrentPowerState !=
                 PowerDeviceD0) {

                // the child devices should not be resetting
                // unless the parent is in D0

                UsbhWarning(NULL,
                   "Parent Not in D0.\n",
                   TRUE);

            }

            if (DeviceExtensionFunction->ResetIrp) {
                ntStatus = STATUS_UNSUCCESSFUL;
                USBH_CompleteIrp(Irp, ntStatus);
            } else {
                ntStatus = STATUS_PENDING;

                USBH_KdPrint((2,"'***WAIT parent mutex %x\n", deviceExtensionParent));
                KeWaitForSingleObject(&deviceExtensionParent->ParentMutex,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                USBH_KdPrint((2,"'***WAIT parent mutex done %x\n", deviceExtensionParent));

                DeviceExtensionFunction->ResetIrp = Irp;
                if (USBH_ListReadyForReset(deviceExtensionParent)) {

                    PUSBH_COMP_RESET_WORK_ITEM workItemCompReset;

                    //
                    // "Cancel" watchdog timer.
                    //
                    // Take SpinLock here so that DPC routine won't free
                    // the timeout context while we write the CancelFlag
                    // in the timeout context.
                    //
                    KeAcquireSpinLock(&deviceExtensionParent->ParentSpinLock,
                                        &irql);

                    if (deviceExtensionParent->CompResetTimeoutContext) {

                        compResetTimeoutContext = deviceExtensionParent->CompResetTimeoutContext;
                        compResetTimeoutContext->CancelFlag = TRUE;

                        if (KeCancelTimer(&compResetTimeoutContext->TimeoutTimer)) {
                            //
                            // We cancelled the timer before it could run.  Free the context.
                            //
                            deviceExtensionParent->CompResetTimeoutContext = NULL;
                            UsbhExFreePool(compResetTimeoutContext);
                        }
                    }

                    KeReleaseSpinLock(&deviceExtensionParent->ParentSpinLock,
                                        irql);

                    //
                    // Schedule a work item to process this reset.
                    //
                    workItemCompReset = UsbhExAllocatePool(NonPagedPool,
                                            sizeof(USBH_COMP_RESET_WORK_ITEM));

                    USBH_ASSERT(workItemCompReset);

                    if (workItemCompReset) {

                        workItemCompReset->DeviceExtensionParent = deviceExtensionParent;

                        ExInitializeWorkItem(&workItemCompReset->WorkQueueItem,
                                             USBH_CompositeResetPortWorker,
                                             workItemCompReset);

                        LOGENTRY(LOG_PNP, "rCMP", deviceExtensionParent,
                            &workItemCompReset->WorkQueueItem, 0);

                        ExQueueWorkItem(&workItemCompReset->WorkQueueItem,
                                        DelayedWorkQueue);

                        // The WorkItem is freed by USBH_CompositeResetPortWorker()
                        // Don't try to access the WorkItem after it is queued.

                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }

                } else if (!deviceExtensionParent->CompResetTimeoutContext) {
                    // Start watchdog timer if not already started.
                    //
                    // When timer expires, timer routine should
                    // complete all Irps in the list with an error
                    // and clear the Irps in the list.

                    USBH_KdPrint((2,"'Start composite port reset timeout\n"));
                    compResetTimeoutContext = UsbhExAllocatePool(NonPagedPool,
                                            sizeof(*compResetTimeoutContext));

                    USBH_ASSERT(compResetTimeoutContext);

                    if (compResetTimeoutContext) {

                        compResetTimeoutContext->CancelFlag = FALSE;

                        // Maintain links between the device extension and the
                        // timeout context.
                        deviceExtensionParent->CompResetTimeoutContext = compResetTimeoutContext;
                        compResetTimeoutContext->DeviceExtensionParent = deviceExtensionParent;

                        KeInitializeTimer(&compResetTimeoutContext->TimeoutTimer);
                        KeInitializeDpc(&compResetTimeoutContext->TimeoutDpc,
                                        USBH_CompResetTimeoutDPC,
                                        compResetTimeoutContext);

                        dueTime.QuadPart = -10000 * COMP_RESET_TIMEOUT;

                        KeSetTimer(&compResetTimeoutContext->TimeoutTimer,
                                   dueTime,
                                   &compResetTimeoutContext->TimeoutDpc);

                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (ntStatus == STATUS_PENDING) {
                    IoMarkIrpPending(Irp);
                } else {
                    USBH_CompleteIrp(Irp, ntStatus);
                }

                USBH_KdPrint((2,"'***RELEASE parent mutex %x\n", deviceExtensionParent));
                KeReleaseSemaphore(&deviceExtensionParent->ParentMutex,
                                   LOW_REALTIME_PRIORITY,
                                   1,
                                   FALSE);
            }
            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
            TEST_TRAP(); //shouldn't see this
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_URB:
            ntStatus = USBH_FunctionUrbFilter(DeviceExtensionFunction, Irp);
            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
            // this api returns some BW info that drivers
            // may need -- pass it on
            ntStatus = USBH_PassIrp(Irp, deviceExtensionParent->TopOfStackDeviceObject);
            break;

        default:
            USBH_KdPrint((2,"'InternalDeviceControl IOCTL unknown pass on\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            USBH_CompleteIrp(Irp, ntStatus);
        }
        break;

        }

    case IRP_MJ_PNP:

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));
        ntStatus = USBH_FunctionPdoPnP(DeviceExtensionFunction, Irp,
                        ioStackLocation->MinorFunction, &bCompleteIrp);

        if (bCompleteIrp) {
            USBH_CompleteIrp(Irp, ntStatus);
        }
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));
        ntStatus = USBH_FunctionPdoPower(DeviceExtensionFunction, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_SYSTEM_CONTROL:

        USBH_KdPrint((2,"'IRP_MJ_SYSTEM_CONTROL\n"));
        ntStatus = STATUS_NOT_SUPPORTED;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_DEVICE_CONTROL:
        //
        // Note: if we ever do find a reason to handle this, be sure to
        // not forward IOCTL_KS_PROPERTY / KSPROPSETID_DrmAudioStream /
        // KSPROPERTY_DRMAUDIOSTREAM_SETCONTENTID to next driver!  Otherwise
        // this might not be DRM compliant.
        //
        USBH_KdBreak(("Unhandled IRP_MJ_DEVICE_CONTROL for Pdo %x Irp_Mj %x\n",
                       deviceObject, ioStackLocation->MajorFunction));
        ntStatus = STATUS_INVALID_PARAMETER;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    default:

        // Unknown Irp, shouldn't be here.
        USBH_KdBreak(("Unhandled Irp for Pdo %x Irp_Mj %x\n",
                       deviceObject, ioStackLocation->MajorFunction));
        ntStatus = STATUS_INVALID_PARAMETER;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    }

    USBH_KdPrint((2,"' exit USBH_FunctionPdoDispatch Object %x -- Status %x\n",
                  deviceObject, ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_BuildFunctionConfigurationDescriptor(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN OUT PUCHAR Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned
    )
 /*
  * Description:
  *
  *  This function creates a configuration descriptor (with all interface &
  *  endpoints) for a give function.
  *
  * Arguments:
  *
  *     Buffer - buffer to put descriptor in
  *
  *     BufferLength - max size of this buffer.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    PVOID scratch;
    ULONG length, i;
    PUCHAR pch;

    USBH_KdPrint((2,"'USBH_BuildFunctionConfigurationDescriptor\n"));

    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    //
    // scratch area to build descriptor in
    //

    *BytesReturned = 0;

    configurationDescriptor = deviceExtensionParent->ConfigurationDescriptor;
    if (!configurationDescriptor || !configurationDescriptor->wTotalLength) {
        return STATUS_INVALID_PARAMETER;
    }

    scratch = UsbhExAllocatePool(PagedPool, configurationDescriptor->
                                 wTotalLength);

    if (scratch) {

        configurationDescriptor = scratch;
        pch = scratch;

        length = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        RtlCopyMemory(pch,
                      deviceExtensionParent->ConfigurationDescriptor,
                      length);
        pch+=length;

        //
        // now copy the interfaces
        //

        for (i=0; i< DeviceExtensionFunction->InterfaceCount; i++) {
            PFUNCTION_INTERFACE functionInterface;

            functionInterface =
                &DeviceExtensionFunction->FunctionInterfaceList[i];

            RtlCopyMemory(pch,
                          functionInterface->InterfaceDescriptor,
                          functionInterface->InterfaceDescriptorLength);


            pch+=functionInterface->InterfaceDescriptorLength;
            length+=functionInterface->InterfaceDescriptorLength;
        }

        configurationDescriptor->bNumInterfaces = (UCHAR) DeviceExtensionFunction->InterfaceCount;
        configurationDescriptor->wTotalLength = (USHORT) length;

        //
        // now copy what we can in to the user buffer
        //
        if (BufferLength >= configurationDescriptor->wTotalLength) {
            *BytesReturned = configurationDescriptor->wTotalLength;
        } else {
            *BytesReturned = BufferLength;
        }

        RtlCopyMemory(Buffer,
                      scratch,
                      *BytesReturned);

        USBH_KdBreak(("'USBH_BuildFunctionConfigurationDescriptor, buffer = %x scratch = %x\n",
            Buffer, scratch));

        UsbhExFreePool(scratch);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


VOID
USBH_ParentCompleteFunctionWakeIrps(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub
    Propagates the wake irp completion to all the function (children).

Arguments:

    DeviceObject - Pointer to the device object for the class device.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;
    PSINGLE_LIST_ENTRY listEntry;
    PIRP irp;
    KIRQL irql;
    LONG pendingFunctionWWs;
    ULONG i;
    PIRP irpArray[128];     // Limited to 127 functions in the list.

    LOGENTRY(LOG_PNP, "fWWc", DeviceExtensionParent, NtStatus, 0);

    //
    // Here we are walking the list of child PDOs, which should never change.
    // (The number of interfaces on a USB device is fixed so long as the parent
    // is here the number of children stay constant.)
    //
    // Therefore we need no protection for parent->FunctionList.
    //
    // Wrongo!  The list may not change, but the WW IRPs attributed to the
    // list can, so we must take the spinlock here.

    IoAcquireCancelSpinLock(&irql);

    listEntry = DeviceExtensionParent->FunctionList.Next;
    i = 0;

    while (listEntry) {

        deviceExtensionFunction =
             CONTAINING_RECORD(listEntry,
                               DEVICE_EXTENSION_FUNCTION,
                               ListEntry);

        irp = deviceExtensionFunction->WaitWakeIrp;
        deviceExtensionFunction->WaitWakeIrp = NULL;
        if (irp) {

            IoSetCancelRoutine(irp, NULL);

            pendingFunctionWWs =
                InterlockedDecrement(&DeviceExtensionParent->NumberFunctionWakeIrps);

            if (0 == pendingFunctionWWs) {
                LOGENTRY(LOG_PNP, "fWWx", DeviceExtensionParent,
                    DeviceExtensionParent->PendingWakeIrp, 0);
                DeviceExtensionParent->PendingWakeIrp = NULL;
                DeviceExtensionParent->ParentFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
            }

            irpArray[i++] = irp;
        }

        listEntry = listEntry->Next;
    }

    irpArray[i] = NULL;     // Terminate array

    IoReleaseCancelSpinLock(irql);

    USBH_ASSERT(DeviceExtensionParent->PendingWakeIrp == NULL);

    // Ok, we have queued all the function wake IRPs and have released the
    // cancel spinlock.  Let's complete all the IRPs.

    i = 0;

    while (irpArray[i]) {
        USBH_KdPrint((1,"'completing function WaitWake irp(%x) for PARENT VID %x, PID %x\n\n",
                        NtStatus,
                        DeviceExtensionParent->DeviceDescriptor.idVendor, \
                        DeviceExtensionParent->DeviceDescriptor.idProduct));

        irpArray[i]->IoStatus.Status = NtStatus;
        PoStartNextPowerIrp(irpArray[i]);
        IoCompleteRequest(irpArray[i], IO_NO_INCREMENT);

        i++;
    }
}


NTSTATUS
USBH_ParentPoRequestD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent = Context;

    ntStatus = IoStatus->Status;

    USBH_KdPrint((1,"'WaitWake D0 completion(%x) for PARENT VID %x, PID %x\n",
        ntStatus,
        deviceExtensionParent->DeviceDescriptor.idVendor, \
        deviceExtensionParent->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "pWD0", deviceExtensionParent,
                              deviceExtensionParent->PendingWakeIrp,
                              0);
    //
    // Device has been powered on.  Now we must complete the function that
    // caused the parent to awake.
    //
    // Since of course we cannot tell them apart we must complete all function
    // WW Irps.
    //
    USBH_ParentCompleteFunctionWakeIrps(deviceExtensionParent, STATUS_SUCCESS);

    return ntStatus;
}


NTSTATUS
USBH_ParentWaitWakeIrpCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a composite device

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent = Context;
    POWER_STATE powerState;

    ntStatus = IoStatus->Status;

    USBH_KdPrint((1,"'WaitWake completion(%x) for PARENT VID %x, PID %x\n",
        ntStatus,
        deviceExtensionParent->DeviceDescriptor.idVendor, \
        deviceExtensionParent->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "pWWc", deviceExtensionParent,
                              ntStatus,
                              0);

    // first we power our device back on

    if (NT_SUCCESS(ntStatus)) {

        powerState.DeviceState = PowerDeviceD0;

        PoRequestPowerIrp(deviceExtensionParent->PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              USBH_ParentPoRequestD0Completion,
                              deviceExtensionParent,
                              NULL);

        // USBH_ParentPoRequestD0Completion must complete the
        // wake irp
        ntStatus = STATUS_SUCCESS;
    } else {
        // complete the child wake requests with an error
        USBH_ParentCompleteFunctionWakeIrps(deviceExtensionParent,
                                            ntStatus);
    }

    return ntStatus;
}


NTSTATUS
USBH_ParentSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
/*++

Routine Description:

    called when a child Pdo is enabled for wakeup, this
    function allocates a wait wake irp and passes it to
    the parents PDO.


Arguments:

Return Value:

--*/
{
    PIRP irp;
    NTSTATUS ntStatus;
    POWER_STATE powerState;

    USBH_ASSERT (NULL == DeviceExtensionParent->PendingWakeIrp);

    LOGENTRY(LOG_PNP, "prWI", DeviceExtensionParent,
             0,
             0);

    USBH_ASSERT(DeviceExtensionParent->PendingWakeIrp == NULL);

    DeviceExtensionParent->ParentFlags |= HUBFLAG_PENDING_WAKE_IRP;
    powerState.DeviceState = DeviceExtensionParent->SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtensionParent->PhysicalDeviceObject,
                                 IRP_MN_WAIT_WAKE,
                                 powerState,
                                 USBH_ParentWaitWakeIrpCompletion,
                                 DeviceExtensionParent,
                                 &irp);

    if (ntStatus == STATUS_PENDING) {
        if (DeviceExtensionParent->ParentFlags & HUBFLAG_PENDING_WAKE_IRP) {
            DeviceExtensionParent->PendingWakeIrp = irp;
        }
    }
    USBH_KdPrint((2,
                  "'ntStatus from PoRequestPowerIrp for wait_wake to parent PDO = 0x%x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\exe\info\info.c ===
/*++

Module Name:

    INFO.C

Abstract:

    This source file contains routines for exercising the I82930.SYS
    test driver.

Environment:

    user mode

Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>
#include <usbdi.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
);

VOID ShowDeviceInfo (
    PCHAR DevicePath
);

VOID ShowInterfaceInfo (
    PUSBD_INTERFACE_INFORMATION InterfaceInfo
);

PCHAR
GetPipeType (
    USBD_PIPE_TYPE PipeType
);

PCHAR
GetPipeDirection (
    UCHAR EndpointAddress
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int argc,
    char *argv[]
)
{
    PDEVICENODE deviceNode;
    PDEVICENODE deviceNodeNext;

    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    while (deviceNode)
    {
        ShowDeviceInfo(deviceNode->DevicePath);

        deviceNodeNext = deviceNode->Next;
        GlobalFree(deviceNode);
        deviceNode = deviceNodeNext;
    }

    return 0;
}

//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// ShowDeviceInfo()
//
//*****************************************************************************

VOID ShowDeviceInfo (
    PCHAR DevicePath
)
{
    HANDLE  devHandle;
    BOOL    success;
    int     size;
    int     nBytes;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    devHandle = CreateFile(DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        printf("Unable to open device:%s\n", DevicePath);
        return;
    }
    else
    {
        printf("Device: %s\n", DevicePath);
    }

    size = sizeof(USBD_INTERFACE_INFORMATION) -
           sizeof(USBD_PIPE_INFORMATION);

    interfaceInfo = GlobalAlloc(GPTR, size);

    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_GET_PIPE_INFORMATION,
                              NULL,
                              0,
                              interfaceInfo,
                              size,
                              &nBytes,
                              NULL);

    if (success)
    {
        size = interfaceInfo->Length;

        interfaceInfo =  GlobalReAlloc(interfaceInfo,
                                       size,
                                       GMEM_MOVEABLE | GMEM_ZEROINIT);

        success = DeviceIoControl(devHandle,
                                  IOCTL_I82930_GET_PIPE_INFORMATION,
                                  NULL,
                                  0,
                                  interfaceInfo,
                                  size,
                                  &nBytes,
                                  NULL);
        if (success)
        {
            ShowInterfaceInfo(interfaceInfo);
        }
    }

    printf("\n");

    GlobalFree(interfaceInfo);

    CloseHandle(devHandle);
}

//*****************************************************************************
//
// ShowInterfaceInfo()
//
//*****************************************************************************

VOID ShowInterfaceInfo (
    PUSBD_INTERFACE_INFORMATION InterfaceInfo
)
{
    ULONG i;

    printf("*** Number Of Pipes %02.2d\n",
           InterfaceInfo->NumberOfPipes);


    for (i=0; i<InterfaceInfo->NumberOfPipes; i++)
    {
        PUSBD_PIPE_INFORMATION pipeInfo;

        pipeInfo = &InterfaceInfo->Pipes[i];

        printf("PIPE%02d :: EP address (0x%02.2x)-(%s %s) Max Packet = %02.2d bytes [%d ms]\n",
               i,
               pipeInfo->EndpointAddress,
               GetPipeType(pipeInfo->PipeType),
               GetPipeDirection(pipeInfo->EndpointAddress),
               pipeInfo->MaximumPacketSize,
               pipeInfo->PipeType == UsbdPipeTypeInterrupt ?
               pipeInfo->Interval : 0
              );

        printf("     MaximumTransferSize = 0x%x\n",
               pipeInfo->MaximumTransferSize);
    }
}

//*****************************************************************************
//
// GetPipeType()
//
//*****************************************************************************

PCHAR
GetPipeType (
    USBD_PIPE_TYPE PipeType
)
{

    switch (PipeType)
    {
        case UsbdPipeTypeControl:
            return "Control  ";             
        case UsbdPipeTypeIsochronous:
            return "Iso      ";         
        case UsbdPipeTypeBulk:
            return "Bulk     "; 
        case UsbdPipeTypeInterrupt:
            return "Interrupt";
        default:
            return "???      "; 
    }
}

//*****************************************************************************
//
// GetPipeDirection()
//
//*****************************************************************************

PCHAR
GetPipeDirection (
    UCHAR EndpointAddress
)
{
    if (USB_ENDPOINT_DIRECTION_IN(EndpointAddress))
    {
        return "in ";
    }
    else
    {
        return "out";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\exe\rw\rw.c ===
/*++

Module Name:

    RW.C

Abstract:

    This source file contains routines for exercising reads and writes
    to a USB device through the I82930.SYS test driver.

Environment:

    user mode

Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy, memcmp)


//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define NOISY(_x_) printf _x_ ;

#define RW_SUCCESS      0
#define RW_FAILED       1
#define RW_ABORTED      2
#define RW_NODEVICE     3
#define RW_BADARGS      4

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// G L O B A L S
//*****************************************************************************

ULONG   DevInstance = 1;        // set with -#  option

ULONG   InPipeNum   = 0;        // set with -i  option
ULONG   OutPipeNum  = 1;        // set with -o  option

BOOL    TestMode    = 0;        // set with -t  option
ULONG   Count       = 1;        // set with -c  option

ULONG   WriteLen    = 0;        // set with -w  option
LONG    WriteOffset = 0;        // set with -wo option
BOOL    WriteReset  = 0;        // set with -W  option
BOOL    WriteZero   = 0;

ULONG   ReadLen     = 0;        // set with -r  option
LONG    ReadOffset  = 0;        // set with -ro option
BOOL    ReadReset   = 0;        // set with -R  option
BOOL    ReadZero    = 0;

BOOL    DumpFlag    = 0;        // set with -d  option
BOOL    Verbose     = 0;        // set with -v  option

DWORD   Offset      = 0;        // set with -f  option
DWORD   OffsetHigh  = 0;        //

BOOL    StallIn     = 0;        // set with -S  option
BOOL    StallOut    = 0;        // set with -S  option

BOOL    SelectAlt   = FALSE;    // set with -A  option
UCHAR   Alternate   = 0;

BOOL    Reset       = FALSE;    // set with -Z  option

BOOL    Abort       = FALSE;    // set by CtrlHandlerRoutine
BOOL    Cancel      = FALSE;    // set by CtrlHandlerRoutine


//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

ULONG
DoReadWriteTest (
    PUCHAR  pinBuf,
    HANDLE  hRead,
    PUCHAR  poutBuf,
    HANDLE  hWrite
);

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
);

PDEVICENODE
EnumDevices (
    LPGUID  Guid
);

HANDLE
OpenDevice (
    PDEVICENODE DeviceNode
);

HANDLE
OpenDevicePipe (
    PDEVICENODE DeviceNode,
    ULONG       PipeNum
);

BOOL
CompareBuffs (
    PUCHAR  buff1,
    PUCHAR  buff2,
    ULONG   length
);

VOID
DumpBuff (
   PUCHAR   b,
   ULONG    len
);

BOOL
ResetPipe (
    HANDLE  hPipe
);

BOOL
StallPipe(
    HANDLE hPipe
);

BOOL
AbortPipe(
    HANDLE hPipe
);

BOOL
SelectAlternate(
    HANDLE hDevice,
    UCHAR  AlternateSetting
);

BOOL
ResetDevice(
    HANDLE hDevice
);

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD   dwCtrlType
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int     argc,
    char   *argv[]
)
{
    PDEVICENODE deviceNode;
    PUCHAR      pinBuf  = NULL;
    PUCHAR      poutBuf = NULL;
    HANDLE      hDevice = INVALID_HANDLE_VALUE;
    HANDLE      hRead   = INVALID_HANDLE_VALUE;
    HANDLE      hWrite  = INVALID_HANDLE_VALUE;
    ULONG       fail    = 0;
    BOOL        success;

    // Parse the command line args
    //
    if (!ParseArgs(argc, argv))
    {
        return RW_BADARGS;
    }

    // Find devices
    //
    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    if (deviceNode == NULL)
    {
        printf("No devices found!\n");
        return RW_NODEVICE;
    }

    while (deviceNode && --DevInstance)
    {
        deviceNode = deviceNode->Next;
    }

    if (deviceNode == NULL)
    {
        printf("Devices instance not found!\n");
        return RW_NODEVICE;
    }

    // Reset the device if desired
    //
    if (Reset || SelectAlt)
    {
        hDevice = OpenDevice(deviceNode);

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            if (Reset)
            {
                success = ResetDevice(hDevice);

                if (!success)
                {
                    printf("Reset device failed\n");
                    fail++;
                }
            }

            if (SelectAlt)
            {
                success = SelectAlternate(hDevice, Alternate);

                if (!success)
                {
                    printf("Select Alternate Interface failed\n");
                    fail++;
                }
            }
        }
    }

    // Set a CTRL-C / CTRL-BREAK handler
    //
    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);

    // Allocate a page aligned write buffer if we're going to do a write.
    //
    if (WriteLen)
    {
        poutBuf = VirtualAlloc(NULL,
                               WriteLen + WriteOffset,
                               MEM_COMMIT,
                               PAGE_READWRITE);
    }

    // Allocate a page aligned read buffer if we're going to do a read.
    //
    if (ReadLen)
    {
        pinBuf = VirtualAlloc(NULL,
                              ReadLen + ReadOffset,
                              MEM_COMMIT,
                              PAGE_READWRITE);
    }

    // Open the output pipe if we're going to do a write or a reset.
    //
    if (poutBuf || WriteReset || WriteZero || StallOut)
    {
        hWrite = OpenDevicePipe(deviceNode, OutPipeNum);

        // STALL the output pipe if desired
        //
        if ((hWrite != INVALID_HANDLE_VALUE) && StallOut)
        {
            success = StallPipe(hWrite);

            if (!success)
            {
                printf("Output pipe STALL failed\n");
                fail++;
            }
        }

        // Reset the output pipe if desired
        //
        if ((hWrite != INVALID_HANDLE_VALUE) && WriteReset)
        {
            success = ResetPipe(hWrite);

            if (!success)
            {
                printf("Output pipe ResetPipe failed\n");
                fail++;
            }
        }
    }

    // Open the input pipe if we're going to do a read or a reset.
    //
    if (pinBuf || ReadReset || ReadZero || StallIn)
    {
        hRead = OpenDevicePipe(deviceNode, InPipeNum);

        // STALL the input pipe if desired
        //
        if ((hRead != INVALID_HANDLE_VALUE) && StallIn)
        {
            success = StallPipe(hRead);

            if (!success)
            {
                printf("Input pipe STALL failed\n");
                fail++;
            }
        }

        // Reset the input pipe if desired
        //
        if ((hRead != INVALID_HANDLE_VALUE) && ReadReset)
        {
            success = ResetPipe(hRead);

            if (!success)
            {
                printf("Input pipe ResetPipe failed\n");
                fail++;
            }
        }
    }

    if (WriteLen && (!poutBuf || (hWrite == INVALID_HANDLE_VALUE)))
    {
        printf("Failed allocating write buffer and/or opening write pipe\n");
        fail++;
    }

    if (ReadLen  && (!pinBuf  || (hRead  == INVALID_HANDLE_VALUE)))
    {
        printf("Failed allocating read buffer and/or opening read pipe\n");
        fail++;
    }

    //
    // NOW DO THE REAL WRITE/READ TEST
    //
    if (!fail)
    {
        fail = DoReadWriteTest(pinBuf + ReadOffset,
                               hRead,
                               poutBuf + WriteOffset,
                               hWrite);
    }

    if (TestMode)
    {
        if (fail)
        {
            printf("Test failed\n");
        }
        else
        {
            printf("Test passed\n");
        }
    }

    // Close devices if needed
    //
    if (hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDevice);
        hRead = INVALID_HANDLE_VALUE;
    }

    if (hRead != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hRead);
        hRead = INVALID_HANDLE_VALUE;
    }

    if (hWrite != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hWrite);
        hWrite = INVALID_HANDLE_VALUE;
    }

    // Free read/write buffers if needed
    //
    if (pinBuf)
    {
        VirtualFree(pinBuf,
                    0,
                    MEM_RELEASE);
    }

    if (poutBuf)
    {
        VirtualFree(poutBuf,
                    0,
                    MEM_RELEASE);
    }

    if (Abort)
    {
        return RW_ABORTED;
    }
    else if (fail)
    {
        return RW_FAILED;
    }
    else
    {
        return RW_SUCCESS;
    }
}

//*****************************************************************************
//
// DoReadWriteTest()
//
// pinBuf  - Buffer to read data into from input pipe
//
// hRead   - Handle of input pipe
//
// poutBuf - Buffer to write data from to output pipe
//
// hWrite  - Handle of output pipe
//
// return value - zero if success, non-zero if failure
//
//*****************************************************************************

ULONG
DoReadWriteTest (
    PUCHAR  pinBuf,
    HANDLE  hRead,
    PUCHAR  poutBuf,
    HANDLE  hWrite
)
{
    ULONG       nBytesRead;
    ULONG       nBytesWrite;
    ULONG       i;
    ULONG       nBytes;
    BOOL        ok;
    BOOL        success;
    ULONG       fail = 0;
    HANDLE      hConsole;
    HANDLE      hEvent;
    HANDLE      waitHandles[2];
    OVERLAPPED  overlapped;
    DWORD       dwRet;
    DWORD       lastError;

    // Create an event for the overlapped struct
    //
    hEvent = CreateEvent(
                 NULL,  // pEventAttributes
                 FALSE, // bManualReset
                 FALSE, // bInitialState
                 NULL   // lpName
                 );

    overlapped.hEvent = hEvent;

    // Set the command line specified or default offset in the
    // overlapped struct
    //
    overlapped.Offset = Offset;
    overlapped.OffsetHigh = OffsetHigh;

    // The handles that we'll wait on during the overlapped I/O
    //
    hConsole = GetStdHandle(STD_INPUT_HANDLE);
    waitHandles[0] = hConsole;
    waitHandles[1] = hEvent;

    if (poutBuf)
    {
        // Put some data in the output buffer
        //
        //
        for (i=0; i<WriteLen/sizeof(USHORT); i++)
        {
            ((PUSHORT)poutBuf)[i] = (USHORT)i;
        }
    }

    // Start of main Write/Read loop
    //
    for (i=0; i<Count && !Abort && !fail; i++)
    {
        // Write to the output pipe if we have an output buffer
        // and we've opened the output pipe.
        //
        if ((poutBuf || WriteZero) && hWrite != INVALID_HANDLE_VALUE)
        {
            //
            // send the write
            //
            success = WriteFile(hWrite,
                                poutBuf,
                                WriteLen,
                                &nBytesWrite,
                                &overlapped);

            if (!success)
            {
                lastError = GetLastError();

                if (lastError != ERROR_IO_PENDING)
                {
                    printf("WriteFile failed, LastError 0x%08X\n",
                           lastError);
                    fail++;
                    break;
                }
            }

            // Wait for either the write to complete or a cancel by the user
            //
            while (TRUE)
            {
                dwRet = WaitForMultipleObjects(
                            2,
                            waitHandles,
                            FALSE,
                            INFINITE
                            );

                if (dwRet == WAIT_OBJECT_0)
                {
                    FlushConsoleInputBuffer(hConsole);
                    if (Abort)
                    {
                        if (Cancel)
                        {
                            printf("Cancelling Write!\n");
                            success = CancelIo(hWrite);
                            break;
                        }
                        else
                        {
                            printf("Aborting Write!\n");
                            success = AbortPipe(hWrite);
                            break;
                        }
                    }
                }
                else
                {
                    break;  // Write is complete
                }
            }

            success = GetOverlappedResult(hWrite,
                                          &overlapped,
                                          &nBytesWrite,
                                          FALSE);

            // Do screen I/O if we aren't in perf mode
            //
            if (!TestMode)
            {
                printf("<PIPE%02d> W (%04.4d) : request %06.6d bytes -- %06.6d bytes written\n",
                       OutPipeNum, i, WriteLen, nBytesWrite);
            }
        }

        // Read from the input pipe if we have an input buffer
        // and we've opened the input pipe.
        //
        if ((pinBuf || ReadZero) && hRead != INVALID_HANDLE_VALUE)
        {
            success = ReadFile(hRead,
                               pinBuf,
                               ReadLen,
                               &nBytesRead,
                               &overlapped);

            if (!success)
            {
                lastError = GetLastError();

                if (lastError != ERROR_IO_PENDING)
                {
                    printf("ReadFile failed, LastError 0x%08X\n",
                           lastError);
                    fail++;
                    break;
                }
            }

            // Wait for either the read to complete or a cancel by the user
            //
            while (TRUE)
            {
                dwRet = WaitForMultipleObjects(
                            2,
                            waitHandles,
                            FALSE,
                            INFINITE
                            );

                if (dwRet == WAIT_OBJECT_0)
                {
                    FlushConsoleInputBuffer(hConsole);
                    if (Abort)
                    {
                        if (Cancel)
                        {
                            printf("Cancelling Read!\n");
                            success = CancelIo(hRead);
                            break;
                        }
                        else
                        {
                            printf("Aborting Read!\n");
                            success = AbortPipe(hRead);
                            break;
                        }
                    }
                }
                else
                {
                    break;  // Read is complete
                }
            }

            success = GetOverlappedResult(hRead,
                                          &overlapped,
                                          &nBytesRead,
                                          FALSE);

            // Do screen I/O if we aren't in perf mode
            //
            if (!TestMode)
            {
                printf("<PIPE%02d> R (%04.4d) : request %06.6d bytes -- %06.6d bytes read\n",
                       InPipeNum, i, ReadLen, nBytesRead);
            }

            // Dump the read data if desired
            //
            if (DumpFlag)
            {
                DumpBuff(pinBuf, nBytesRead);
            }

            if (poutBuf)
            {
                //
                // validate the input buffer against what
                // we sent to the 82930 (loopback test)
                //
                ok = CompareBuffs(pinBuf, poutBuf,  nBytesRead);

                if (ok != 1)
                {
                    fail++;
                }
            }
        }
    }
    //
    // End of main Write/Read loop

    return fail;
}

//*****************************************************************************
//
// Usage()
//
//*****************************************************************************

void
Usage ()
{
    printf("RW.EXE\n");
    printf("usage:\n");
    printf("-#  [n] where n is the device instance to open\n");
    printf("-r  [n] where n is number of bytes to read\n");
    printf("-ro [n] where n is offset from page boundary for read buffer\n");
    printf("-R  reset the input pipe\n");
    printf("-w  [n] where n is number of bytes to write\n");
    printf("-wo [n] where n is offset from page boundary for write buffer\n");
    printf("-W  reset the output pipe\n");
    printf("-c  [n] where n is number of iterations (default = 1)\n");
    printf("-f  [n] where n is offset from current ISO frame\n");
    printf("-i  [s] where s is the input pipe  (default PIPE00)\n");
    printf("-o  [s] where s is the output pipe (default PIPE01)\n");
    printf("-t  test mode - less screen I/O with pass/fail at end of test\n");
    printf("-d  dump read data\n");
    printf("-S  STALL pipe(s) specified by -i and/or -o\n");
    printf("-A  [n] Select Alternate Interface");
    printf("-Z  Reset Device");
}

//*****************************************************************************
//
// ParseArgs()
//
//*****************************************************************************

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
)
{
    int i, j;
    BOOL in, out, stall;

    in      = FALSE;
    out     = FALSE;
    stall   = FALSE;

    if (argc < 2)
    {
        Usage();
        return FALSE;
    }

    for (i=1; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case '#':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    DevInstance = atoi(argv[i]);
                }
                break;
            case 'R':
                ReadReset = TRUE;
                break;
            case 'r':
                if (i+1 == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    switch(argv[i][2])
                    {
                        case 0:
                            ReadLen = atoi(argv[++i]);
                            if (!ReadLen)
                            {
                                ReadZero = TRUE;
                            }
                            break;
                        case 'o':
                            ReadOffset = atoi(argv[++i]) & 0x00000FFF;
                            break;
                        default:
                            Usage();
                            return FALSE;
                    }
                }
                break;
            case 'W':
                WriteReset = TRUE;
                break;
            case 'w':
                if (i+1 == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    switch(argv[i][2])
                    {
                        case 0:
                            WriteLen = atoi(argv[++i]);
                            if (!WriteLen) {
                                WriteZero = TRUE;
                            }
                            break;
                        case 'o':
                            WriteOffset = atoi(argv[++i]) & 0x00000FFF;
                            break;
                        default:
                            Usage();
                            return FALSE;
                    }
                }
                break;
            case 'c':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    Count = atoi(argv[i]);
                }
                break;
            case 'f':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    Offset = atoi(argv[i]);
                    OffsetHigh = 1;
                }
                break;
            case 't':
                TestMode = TRUE;
                break;
            case 'i':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    for (j=0; argv[i][j] && !isdigit(argv[i][j]); j++) {
                    }
                    if (argv[i][j])
                    {
                        InPipeNum = atoi(&argv[i][j]);
                        in = TRUE;
                    }
                }
                break;
            case 'o':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    for (j=0; argv[i][j] && !isdigit(argv[i][j]); j++) {
                    }
                    if (argv[i][j])
                    {
                        OutPipeNum = atoi(&argv[i][j]);
                        out = TRUE;
                    }
                }
                break;
            case 'd':
                DumpFlag = TRUE;
                break;
            case 'S':
                stall = TRUE;
                break;
            case 'A':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    SelectAlt = TRUE;
                    Alternate = (UCHAR)atoi(argv[i]);
                }
                break;
            case 'Z':
                Reset = TRUE;
                break;
            case 'v':
                Verbose = TRUE;
                break;
            default:
                Usage();
                return FALSE;
            }
        }
    }

    if (ReadZero) {
        ReadOffset = 0;
    }

    if (WriteZero) {
        WriteOffset = 0;
    }

    if (stall && in) {
        StallIn = TRUE;
    }

    if (stall && out) {
        StallOut = TRUE;
    }

    // Dump parsed args if desired for debug
    //
    if (Verbose)
    {
        printf("DevInstance: %d\n", DevInstance);

        printf("TestMode:    %d\n", TestMode);

        printf("inPipe:      PIPE%02d\n", InPipeNum);
        printf("outPipe:     PIPE%02d\n", OutPipeNum);

        printf("TestMode:    %d\n", TestMode);
        printf("Count:       %d\n", Count);

        printf("WriteLen:    %d\n", WriteLen);
        printf("WriteOffset: %d\n", WriteOffset);
        printf("WriteReset:  %d\n", WriteReset);
        printf("WriteZero:   %d\n", WriteZero);

        printf("ReadLen:     %d\n", ReadLen);
        printf("ReadOffset:  %d\n", ReadOffset);
        printf("ReadReset:   %d\n", ReadReset);
        printf("ReadZero:    %d\n", ReadZero);

        printf("DumpFlag:    %d\n", DumpFlag);
        printf("Verbose:     %d\n", Verbose);

        printf("Offset:      %d\n", Offset);
        printf("OffsetHigh:  %d\n", OffsetHigh);

        printf("StallIn:     %d\n", StallIn);
        printf("StallOut:    %d\n", StallOut);

    }

    return TRUE;
}


//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// OpenDevice()
//
//*****************************************************************************

HANDLE
OpenDevice (
    PDEVICENODE DeviceNode
)
{
    HANDLE  devHandle;

    devHandle = INVALID_HANDLE_VALUE;

    devHandle = CreateFile(DeviceNode->DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        NOISY(("Failed to open (%s) = %d\n",
               DeviceNode->DevicePath, GetLastError()));
    }

    return devHandle;
}

//*****************************************************************************
//
// OpenDevicePipe()
//
//*****************************************************************************

HANDLE
OpenDevicePipe (
    PDEVICENODE DeviceNode,
    ULONG       PipeNum
)
{
    PCHAR   devName;
    HANDLE  devHandle;

    devHandle = INVALID_HANDLE_VALUE;

    if (PipeNum <= 99)
    {
        devName = GlobalAlloc(GPTR,
                              strlen(DeviceNode->DevicePath)+sizeof("\\00"));

        if (devName)
        {
            sprintf(devName, "%s\\%02d", DeviceNode->DevicePath, PipeNum);

            if (!TestMode)
            {
                printf("DevicePath = (%s)\n", devName);
            }

            devHandle = CreateFile(devName,
                                   GENERIC_WRITE | GENERIC_READ,
                                   FILE_SHARE_WRITE | FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_FLAG_OVERLAPPED,
                                   NULL);

            if (devHandle == INVALID_HANDLE_VALUE)
            {
                NOISY(("Failed to open (%s) = %d\n",
                       devName, GetLastError()));
            }
            else
            {
                if (!TestMode)
                {
                    NOISY(("Opened successfully.\n"));
                }
            }

            GlobalFree(devName);
        }
    }

    return devHandle;
}

//*****************************************************************************
//
// CompareBuffs()
//
//*****************************************************************************

BOOL
CompareBuffs (
    PUCHAR  buff1,
    PUCHAR  buff2,
    ULONG   length
)
{
    BOOL ok = TRUE;

    if (memcmp(buff1, buff2, length))
    {
        ok = FALSE;
    }

    return ok;
}

//*****************************************************************************
//
// DumpBuff()
//
//*****************************************************************************

void
DumpBuff (
   PUCHAR   b,
   ULONG    len
)
{
    ULONG i;

    for (i=0; i<len; i++) {
        printf("%02X ", *b++);
        if (i % 16 == 15) {
            printf("\n");
        }
    }
    if (i % 16 != 0) {
        printf("\n");
    }
}

//*****************************************************************************
//
// ResetPipe()
//
//*****************************************************************************

BOOL
ResetPipe(
    HANDLE hPipe
)
{
    int nBytes;

    return DeviceIoControl(hPipe,
                           IOCTL_I82930_RESET_PIPE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// StallPipe()
//
//*****************************************************************************

BOOL
StallPipe(
    HANDLE hPipe
)
{
    int nBytes;

    return DeviceIoControl(hPipe,
                           IOCTL_I82930_STALL_PIPE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// AbortPipe()
//
//*****************************************************************************

BOOL
AbortPipe(
    HANDLE hPipe
)
{
    int nBytes;

    return DeviceIoControl(hPipe,
                           IOCTL_I82930_ABORT_PIPE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// SelectAlternate()
//
//*****************************************************************************

BOOL
SelectAlternate(
    HANDLE hDevice,
    UCHAR  AlternateSetting
)
{
    int nBytes;

    return DeviceIoControl(hDevice,
                           IOCTL_I82930_SELECT_ALTERNATE_INTERFACE,
                           &AlternateSetting,
                           sizeof(UCHAR),
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// ResetDevice()
//
//*****************************************************************************

BOOL
ResetDevice(
    HANDLE hDevice
)
{
    int nBytes;

    return DeviceIoControl(hDevice,
                           IOCTL_I82930_RESET_DEVICE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// CtrlHandlerRoutine()
//
//*****************************************************************************

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD dwCtrlType
    )
{
    BOOL handled;

    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
            Cancel = TRUE;
        case CTRL_BREAK_EVENT:
            Abort = TRUE;
            handled = TRUE;
            break;

        default:
            handled = FALSE;
            break;
    }

    return handled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\exe\config\config.c ===
/*++

Module Name:

    CONFIG.C

Abstract:

    This source file contains routines for exercising the I82930.SYS
    test driver.

Environment:

    user mode

Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>
#include <usb100.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
);

VOID ShowDeviceInfo (
    PCHAR DevicePath
);

VOID
ShowDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
ShowConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
ShowConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
ShowInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
ShowEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int argc,
    char *argv[]
)
{
    PDEVICENODE deviceNode;
    PDEVICENODE deviceNodeNext;

    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    while (deviceNode)
    {
        ShowDeviceInfo(deviceNode->DevicePath);

        deviceNodeNext = deviceNode->Next;
        GlobalFree(deviceNode);
        deviceNode = deviceNodeNext;
    }

    return 0;
}

//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// ShowDeviceInfo()
//
//*****************************************************************************

VOID ShowDeviceInfo (
    PCHAR DevicePath
)
{
    HANDLE  devHandle;
    BOOL    success;
    int     size;
    int     nBytes;
    USB_DEVICE_DESCRIPTOR           deviceDesc;
    PUSB_CONFIGURATION_DESCRIPTOR   configDesc;

    devHandle = CreateFile(DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        printf("Unable to open device:%s\n", DevicePath);
        return;
    }
    else
    {
        printf("Device: %s\n", DevicePath);
    }

    //
    // Get Device Descriptor
    //

    size = sizeof(USB_DEVICE_DESCRIPTOR);
    
    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_GET_DEVICE_DESCRIPTOR,
                              NULL,
                              0,
                              &deviceDesc,
                              size,
                              &nBytes,
                              NULL);

    if (success)
    {
        //
        // Show Device Descriptor
        //

        ShowDeviceDesc(&deviceDesc);
    }

    //
    // Get Configuration Descriptor (just the Configuration Descriptor)
    //

    size = sizeof(USB_CONFIGURATION_DESCRIPTOR);

    configDesc = GlobalAlloc(GPTR, size);

    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_GET_CONFIG_DESCRIPTOR,
                              NULL,
                              0,
                              configDesc,
                              size,
                              &nBytes,
                              NULL);

    if (success)
    {
        //
        // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
        //
        
        size = configDesc->wTotalLength;

        configDesc =  GlobalReAlloc(configDesc,
                                    size,
                                    GMEM_MOVEABLE | GMEM_ZEROINIT);

        success = DeviceIoControl(devHandle,
                                  IOCTL_I82930_GET_CONFIG_DESCRIPTOR,
                                  NULL,
                                  0,
                                  configDesc,
                                  size,
                                  &nBytes,
                                  NULL);
        if (success)
        {
            //
            // Show Configuration Descriptor
            //

            ShowConfigDesc(configDesc);
        }
    }

    printf("\n");

    GlobalFree(configDesc);

    CloseHandle(devHandle);
}

//*****************************************************************************
//
// ShowDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
ShowDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    printf("------------------\n");
    printf("Device Descriptor:\n");

    printf("bcdUSB:             0x%04X\n",
           DeviceDesc->bcdUSB);

    printf("bDeviceClass:         0x%02X\n",
           DeviceDesc->bDeviceClass);

    printf("bDeviceSubClass:      0x%02X\n",
           DeviceDesc->bDeviceSubClass);

    printf("bDeviceProtocol:      0x%02X\n",
           DeviceDesc->bDeviceProtocol);

    printf("bMaxPacketSize0:      0x%02X (%d)\n",
           DeviceDesc->bMaxPacketSize0,
           DeviceDesc->bMaxPacketSize0);

    printf("idVendor:           0x%04X\n",
           DeviceDesc->idVendor);

    printf("idProduct:          0x%04X\n",
           DeviceDesc->idProduct);

    printf("bcdDevice:          0x%04X\n",
           DeviceDesc->bcdDevice);

    printf("iManufacturer:        0x%02X\n",
           DeviceDesc->iManufacturer);

    printf("iProduct:             0x%02X\n",
           DeviceDesc->iProduct);

    printf("iSerialNumber:        0x%02X\n",
           DeviceDesc->iSerialNumber);

    printf("bNumConfigurations:   0x%02X\n",
           DeviceDesc->bNumConfigurations);

}

//*****************************************************************************
//
// ShowConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
ShowConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 ShowUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        ShowUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    ShowUnknown = TRUE;
                    break;
                }
                ShowConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    ShowUnknown = TRUE;
                    break;
                }
                ShowInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    ShowUnknown = TRUE;
                    break;
                }
                ShowEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                ShowUnknown = TRUE;
                break;
        }

        if (ShowUnknown)
        {
            // ShowUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// ShowConfigurationDescriptor()
//
//*****************************************************************************

VOID
ShowConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    printf("-------------------------\n");
    printf("Configuration Descriptor:\n");

    printf("wTotalLength:       0x%04X\n",
           ConfigDesc->wTotalLength);

    printf("bNumInterfaces:       0x%02X\n",
           ConfigDesc->bNumInterfaces);

    printf("bConfigurationValue:  0x%02X\n",
           ConfigDesc->bConfigurationValue);

    printf("iConfiguration:       0x%02X\n",
           ConfigDesc->iConfiguration);

    printf("bmAttributes:         0x%02X\n",
           ConfigDesc->bmAttributes);

    if (ConfigDesc->bmAttributes & 0x80)
    {
        printf("  Bus Powered\n");
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        printf("  Self Powered\n");
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        printf("  Remote Wakeup\n");
    }

    printf("MaxPower:             0x%02X (%d Ma)\n",
           ConfigDesc->MaxPower,
           ConfigDesc->MaxPower * 2);

}

//*****************************************************************************
//
// ShowInterfaceDescriptor()
//
//*****************************************************************************

VOID
ShowInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    printf("---------------------\n");
    printf("Interface Descriptor:\n");

    printf("bInterfaceNumber:     0x%02X\n",
           InterfaceDesc->bInterfaceNumber);

    printf("bAlternateSetting:    0x%02X\n",
           InterfaceDesc->bAlternateSetting);

    printf("bNumEndpoints:        0x%02X\n",
           InterfaceDesc->bNumEndpoints);

    printf("bInterfaceClass:      0x%02X\n",
           InterfaceDesc->bInterfaceClass);

    printf("bInterfaceSubClass:   0x%02X\n",
           InterfaceDesc->bInterfaceSubClass);

    printf("bInterfaceProtocol:   0x%02X\n",
           InterfaceDesc->bInterfaceProtocol);

    printf("iInterface:           0x%02X\n",
           InterfaceDesc->iInterface);

}

//*****************************************************************************
//
// ShowEndpointDescriptor()
//
//*****************************************************************************

VOID
ShowEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    printf("--------------------\n");
    printf("Endpoint Descriptor:\n");

    printf("bEndpointAddress:     0x%02X\n",
           EndpointDesc->bEndpointAddress);

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            printf("Transfer Type:     Control\n");
            break;

        case 0x01:
            printf("Transfer Type: Isochronous\n");
            break;

        case 0x02:
            printf("Transfer Type:        Bulk\n");
            break;

        case 0x03:
            printf("Transfer Type:   Interrupt\n");
            break;
    }

    printf("wMaxPacketSize:     0x%04X (%d)\n",
           EndpointDesc->wMaxPacketSize,
           EndpointDesc->wMaxPacketSize);

    printf("bInterval:            0x%02X\n",
           EndpointDesc->bInterval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\sys\dbg.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.H

Abstract:

    Header file for I82930 driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#if DBG
  #if defined(DEBUG_LOG)
    #undef DEBUG_LOG
  #endif
  #define DEBUG_LOG 1
#else
  #if !defined(DEBUG_LOG)
    #define DEBUG_LOG 0
  #endif
#endif


#if !DBG

#define DBGFBRK(flag)
#define DBGPRINT(level, _x_)

#else

#define DBGF_BRK_DRIVERENTRY            0x00000001
#define DBGF_BRK_UNLOAD                 0x00000002
#define DBGF_BRK_ADDDEVICE              0x00000004
#define DBGF_BRK_REMOVEDEVICE           0x00000008
#define DBGF_BRK_STARTDEVICE            0x00000010
#define DBGF_BRK_STOPDEVICE             0x00000020
#define DBGF_BRK_QUERYSTOPDEVICE        0x00000040
#define DBGF_BRK_CANCELSTOPDEVICE       0x00000080
#define DBGF_BRK_CREATE                 0x00010000
#define DBGF_BRK_CLOSE                  0x00020000
#define DBGF_BRK_READWRITE              0x00040000
#define DBGF_BRK_IOCTL                  0x00080000

#define DBGFBRK(flag) do { \
    if (I82930_DriverGlobals.DebugFlags & flag) { \
        DbgBreakPoint(); \
    } \
} while (0)

#define DBGPRINT(level, _x_) do { \
    if (level <= I82930_DriverGlobals.DebugLevel) { \
        KdPrint(("I82930: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

#if !DEBUG_LOG

#define LOGINIT()
#define LOGUNINIT()
#define LOGENTRY(tag, info1, info2, info3)

#else

#define LOGSIZE 4096

#define LOGINIT() I82930_LogInit()

#define LOGUNINIT() I82930_LogUnInit()

#define LOGENTRY(tag, info1, info2, info3) \
    I82930_LogEntry(((((tag) >> 24) & 0x000000FF) | \
                     (((tag) >>  8) & 0x0000FF00) | \
                     (((tag) <<  8) & 0x00FF0000) | \
                     (((tag) << 24) & 0xFF000000)), \
                    ((ULONG_PTR)info1),             \
                    ((ULONG_PTR)info2),             \
                    ((ULONG_PTR)info3))

#endif

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

#if DEBUG_LOG

typedef struct _I82930_LOG_ENTRY {
    ULONG       le_tag;
    ULONG_PTR   le_info1;
    ULONG_PTR   le_info2;
    ULONG_PTR   le_info3;
} I82930_LOG_ENTRY, *PI82930_LOG_ENTRY;

#endif

#if DBG || DEBUG_LOG

typedef struct _DRIVERGLOBALS
{
#if DBG
    ULONG               DebugFlags;     // DBGF_* Flags
    LONG                DebugLevel;     // Level of debug output
#endif
    PI82930_LOG_ENTRY   LogStart;       // Start of log buffer (older entries)
    PI82930_LOG_ENTRY   LogPtr;         // Current entry in log buffer
    PI82930_LOG_ENTRY   LogEnd;         // End of log buffer (newer entries)
    KSPIN_LOCK          LogSpinLock;    // Protects LogPtr

} DRIVERGLOBALS;

#endif

//*****************************************************************************
//
// G L O B A L S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG || DEBUG_LOG

DRIVERGLOBALS I82930_DriverGlobals;

#endif


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG

VOID
I82930_QueryGlobalParams (
    );

#endif

#if DEBUG_LOG

VOID
I82930_LogInit (
);

VOID
I82930_LogUnInit (
);

VOID
I82930_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
);

#endif

#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
);

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
);

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\driver\i82930\sys\i82930.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    I82930.C

Abstract:

    This source file contains the DriverEntry() and AddDevice() entry points
    for the I82930 driver and the dispatch routines which handle:

    IRP_MJ_POWER
    IRP_MJ_SYSTEM_CONTROL
    IRP_MJ_PNP

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include <initguid.h>

#include "i82930.h"
#include "ioctl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, I82930_Unload)
#pragma alloc_text(PAGE, I82930_AddDevice)
#pragma alloc_text(PAGE, I82930_Power)
#pragma alloc_text(PAGE, I82930_SystemControl)
#pragma alloc_text(PAGE, I82930_Pnp)
#pragma alloc_text(PAGE, I82930_StartDevice)
#pragma alloc_text(PAGE, I82930_StopDevice)
#pragma alloc_text(PAGE, I82930_RemoveDevice)
#pragma alloc_text(PAGE, I82930_QueryStopRemoveDevice)
#pragma alloc_text(PAGE, I82930_CancelStopRemoveDevice)
#pragma alloc_text(PAGE, I82930_QueryCapabilities)
#pragma alloc_text(PAGE, I82930_SyncPassDownIrp)
#pragma alloc_text(PAGE, I82930_SyncSendUsbRequest)
#pragma alloc_text(PAGE, I82930_GetDescriptor)
#pragma alloc_text(PAGE, I82930_SelectConfiguration)
#pragma alloc_text(PAGE, I82930_UnConfigure)
#endif

//******************************************************************************
//
// DriverEntry()
//
//******************************************************************************

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
#if DBG
    // Query the registry for global parameters
    //
    I82930_QueryGlobalParams();
#endif

    DBGPRINT(2, ("enter: DriverEntry\n"));

    DBGFBRK(DBGF_BRK_DRIVERENTRY);

    LOGINIT();

    //
    // Initialize the Driver Object with the driver's entry points
    //

    //
    // I82930.C
    //
    DriverObject->DriverUnload                          = I82930_Unload;
    DriverObject->DriverExtension->AddDevice            = I82930_AddDevice;

    //
    // OCRW.C
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = I82930_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = I82930_Close;
    DriverObject->MajorFunction[IRP_MJ_READ]            = I82930_ReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = I82930_ReadWrite;

    //
    // IOCTL.C
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = I82930_DeviceControl;

    //
    // I82930.C
    //
    DriverObject->MajorFunction[IRP_MJ_POWER]           = I82930_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = I82930_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = I82930_Pnp;

    DBGPRINT(2, ("exit:  DriverEntry\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// I82930_Unload()
//
//******************************************************************************

VOID
I82930_Unload (
    IN PDRIVER_OBJECT   DriverObject
    )
{
    DBGPRINT(2, ("enter: I82930_Unload\n"));

    LOGENTRY('UNLD', DriverObject, 0, 0);

    DBGFBRK(DBGF_BRK_UNLOAD);

    LOGUNINIT();

    DBGPRINT(2, ("exit:  I82930_Unload\n"));
}

//******************************************************************************
//
// I82930_AddDevice()
//
//******************************************************************************

NTSTATUS
I82930_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;

    DBGPRINT(2, ("enter: I82930_AddDevice\n"));

    LOGENTRY('ADDD', DriverObject, PhysicalDeviceObject, 0);

    DBGFBRK(DBGF_BRK_ADDDEVICE);

    // Create the FDO
    //
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_UNKNOWN,
                              FILE_AUTOGENERATED_DEVICE_NAME,
                              FALSE,
                              &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // Initialize the DeviceExtension
    //
    deviceExtension = deviceObject->DeviceExtension;

    // Set all DeviceExtension pointers to NULL and all variable to zero
    //
    RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

    // Remember our PDO
    //
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Attach the FDO we created to the top of the PDO stack
    //
    deviceExtension->StackDeviceObject = IoAttachDeviceToDeviceStack(
                                             deviceObject,
                                             PhysicalDeviceObject);

    // Initialize to one in AddDevice, decrement by one in REMOVE_DEVICE
    //
    deviceExtension->OpenCount = 1;

    // Initialize the event which is set when OpenCount is decremented to zero.
    //
    KeInitializeEvent(&deviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    // Set the initial system and device power states
    //
    deviceExtension->SystemPowerState = PowerSystemWorking;
    deviceExtension->DevicePowerState = PowerDeviceD0;

    deviceObject->Flags |=  DO_DIRECT_IO;
    deviceObject->Flags |=  DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DBGPRINT(2, ("exit:  I82930_AddDevice\n"));

    LOGENTRY('addd', deviceObject, deviceExtension, deviceExtension->StackDeviceObject);

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// I82930_Power()
//
// Dispatch routine which handles IRP_MJ_POWER
//
//******************************************************************************

NTSTATUS
I82930_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_Power %08X %s\n",
                 DeviceObject,
                 PowerMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('POWR', DeviceObject, Irp, irpStack->MinorFunction);

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        DBGPRINT(2, ("IRP_MN_SET_POWER %s\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     PowerSystemStateString(irpStack->Parameters.Power.State.SystemState) :
                     PowerDeviceStateString(irpStack->Parameters.Power.State.DeviceState)));
    }

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        // Handle powering the FDO down and up...
        //
        ntStatus = I82930_FdoSetPower(DeviceObject,
                                      Irp);
    }
    else
    {
        // No special processing for IRP_MN_QUERY_POWER, IRP_MN_WAIT_WAKE,
        // or IRP_MN_POWER_SEQUENCE at this time.  Just pass the request
        // down to the next lower driver now.
        //
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  I82930_Power %08X\n", ntStatus));

    LOGENTRY('powr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_FdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the FDO
//
//******************************************************************************

NTSTATUS
I82930_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    BOOLEAN                 passRequest;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: I82930_FdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('FDSP', DeviceObject, Irp, irpStack->MinorFunction);

    // Pass the request down here, unless we request a device state power
    // Irp, in which case we pass the request down in our completion routine.
    //
    passRequest = TRUE;

    if (powerType == SystemPowerState)
    {
        // Remember the current system state.
        //
        deviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (deviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(deviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(deviceExtension->CurrentPowerIrp == NULL);

            deviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         I82930_FdoSetPowerCompletion,
                                         DeviceObject,
                                         NULL);

            passRequest = FALSE;
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(deviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        // Update the current device state.
        //
        oldState.DeviceState = deviceExtension->DevicePowerState;
        deviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            // Powering down.

            DBGPRINT(2, ("FDO Powering Down\n"));

            LOGENTRY('PWRD', DeviceObject, Irp, 0);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('PWRU', DeviceObject, Irp, 0);
        }
    }

    if (passRequest)
    {
        //
        // Pass the request down to the next lower driver
        //
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  I82930_FdoSetPower %08X\n", ntStatus));

    LOGENTRY('fdsp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_FdoSetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in I82930_FdoSetPower.
//
// The purpose of this routine is to block passing down the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
I82930_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_OBJECT          fdoDeviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    fdoDeviceObject = (PDEVICE_OBJECT)Context;

    deviceExtension = fdoDeviceObject->DeviceExtension;

    ASSERT(deviceExtension->CurrentPowerIrp != NULL);

    irp = deviceExtension->CurrentPowerIrp;

    deviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("I82930_FdoSetPowerCompletion %08X %08X %s %08X\n",
                     fdoDeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('fspc', fdoDeviceObject, systemState, ntStatus);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now pass down the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    PoStartNextPowerIrp(irp);

    IoSkipCurrentIrpStackLocation(irp);

    ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                            irp);
}

//******************************************************************************
//
// I82930_SystemControl()
//
// Dispatch routine which handles IRP_MJ_SYSTEM_CONTROL
//
//******************************************************************************

NTSTATUS
I82930_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_SystemControl %2X\n", irpStack->MinorFunction));

    LOGENTRY('SYSC', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
        //
        // XXXXX Need to handle any of these?
        //

        default:
            //
            // Pass the request down to the next lower driver
            //
            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);
            break;
    }

    DBGPRINT(2, ("exit:  I82930_SystemControl %08X\n", ntStatus));

    LOGENTRY('sysc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_Pnp()
//
// Dispatch routine which handles IRP_MJ_PNP
//
//******************************************************************************

NTSTATUS
I82930_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_Pnp %s\n",
                 PnPMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('PNP ', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            ntStatus = I82930_StartDevice(DeviceObject, Irp);
            break;

        case IRP_MN_STOP_DEVICE:
            ntStatus = I82930_StopDevice(DeviceObject, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            ntStatus = I82930_RemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
            ntStatus = I82930_QueryStopRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            ntStatus = I82930_CancelStopRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            ntStatus = I82930_QueryCapabilities(DeviceObject, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            // nothing special yet, just fall through to default

        default:
            //
            // Pass the request down to the next lower driver
            //
            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);
            break;
    }

    DBGPRINT(2, ("exit:  I82930_Pnp %08X\n", ntStatus));

    LOGENTRY('pnp ', ntStatus, 0, 0);

    return ntStatus;
}


//******************************************************************************
//
// I82930_StartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
// Device specific actions:
//     Retrieve the Device Descriptor from device (first time only)
//     Retrieve the Configuration Descriptor from device (first time only)
//     Configure the device (every time)
//     Create the SymbolicLink name (first time only)
//     Enable the SymbolicLink name (every time)
//
//******************************************************************************

NTSTATUS
I82930_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PUCHAR              descriptor;
    ULONG               descriptorLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_StartDevice\n"));

    DBGFBRK(DBGF_BRK_STARTDEVICE);

    LOGENTRY('STRT', DeviceObject, Irp, 0);

    deviceExtension = DeviceObject->DeviceExtension;

    // Pass IRP_MN_START_DEVICE Irp down the stack first before we do anything.
    //
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_START_DEVICE\n"));
        goto I82930_StartDeviceDone;
    }

    //
    // If this is the first time the device as been started, retrieve the
    // Device and Configuration Descriptors from the device.
    //
    if (deviceExtension->DeviceDescriptor == NULL)
    {
        //
        // Get Device Descriptor
        //
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_DEVICE_DESCRIPTOR_TYPE,
                                        0,  // Index
                                        0,  // LanguageId
                                        2,  // RetryCount
                                        sizeof(USB_DEVICE_DESCRIPTOR),
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Device Descriptor failed\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        deviceExtension->DeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)descriptor;

        //
        // Get Configuration Descriptor (just the Configuration Descriptor)
        //
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                        0,  // Index
                                        0,  // LanguageId
                                        2,  // RetryCount
                                        sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Configuration Descriptor failed (1)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        descriptorLength = ((PUSB_CONFIGURATION_DESCRIPTOR)descriptor)->wTotalLength;

        ExFreePool(descriptor);

        if (descriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))
        {
            ntStatus = STATUS_DEVICE_DATA_ERROR;
            DBGPRINT(1, ("Get Configuration Descriptor failed (2)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        //
        // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
        //
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                        0,  // Index
                                        0,  // LanguageId
                                        2,  // RetryCount
                                        descriptorLength,
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Configuration Descriptor failed (3)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        deviceExtension->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)descriptor;

#if DBG
        DumpDeviceDesc(deviceExtension->DeviceDescriptor);
        DumpConfigDesc(deviceExtension->ConfigurationDescriptor);
#endif
    }

    // Now configure the device
    //
    ntStatus = I82930_SelectConfiguration(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Configure device failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_StartDeviceDone;
    }

    // Create the SymbolicLink name if necessary
    //
    if (deviceExtension->SymbolicLinkName.Buffer == NULL)
    {
        ntStatus = IoRegisterDeviceInterface(
                       deviceExtension->PhysicalDeviceObject,
                       (LPGUID)&GUID_CLASS_I82930,
                       NULL,
                       &deviceExtension->SymbolicLinkName);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("IoRegisterDeviceInterface failed\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }
    }

    // All set for user requests at this point
    //
    deviceExtension->AcceptingRequests = TRUE;

    // Enable the SymbolicLink name
    //
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   TRUE);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("IoSetDeviceInterfaceState failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_StartDeviceDone;
    }

I82930_StartDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_StartDevice %08X\n", ntStatus));

    LOGENTRY('strt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_StopDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_STOP_DEVICE
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// The PnP Manager only sends this IRP if a prior IRP_MN_QUERY_STOP_DEVICE
// completed successfully.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  A driver must
// not fail this IRP.  If a driver cannot release the device's hardware
// resources, it can fail a query-stop IRP, but once it succeeds the query-stop
// request it must succeed the stop request.
//
//******************************************************************************

NTSTATUS
I82930_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_StopDevice\n"));

    LOGENTRY('STOP', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_STOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Release the device resources allocated during IRP_MN_START_DEVICE
    //

    // Unconfigure the device
    //
    ntStatus = I82930_UnConfigure(DeviceObject);

    // Pass the IRP_MN_STOP_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  I82930_StopDevice %08X\n", ntStatus));

    LOGENTRY('stop', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_RemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  Drivers must not
// fail this IRP.
//
//******************************************************************************

NTSTATUS
I82930_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_RemoveDevice\n"));

    LOGENTRY('REMV', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_REMOVEDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Disable and free the SymbolicL