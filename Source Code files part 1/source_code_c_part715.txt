{
            wprintf(
                L"ERROR 0x%08lx trying to find instance to QueryUpdateStatus\n",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the  "QueryConfigurationUpdateStatus" method
    // NOTE: spWbemInput could be NULL.
    //
    {
        Status =  CfgUtilSetWmiStringParam(
                        spWbemInput,
                        L"AdapterGuid",
                        szNicGuid
                        );
        if (FAILED(Status))
        {
            wprintf(
                L"Couldn't set Adapter GUID parameter to QueryUpdateStatus\n");
            goto end;
        }

        Status =  CfgUtilSetWmiDWORDParam(
                        spWbemInput,
                        L"Generation",
                        Generation
                        );
        if (FAILED(Status))
        {
            wprintf(
                L"Couldn't set Generation parameter to QueryUpdateStatus\n");
            goto end;
        }
    }

    //
    // Call the  "QueryConfigurationUpdateStatus" method
    //
    {
        HRESULT hr;

        // wprintf(L"Going call QueryConfigurationUpdateStatus...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"QueryConfigurationUpdateStatus", // szMethodName,
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"QueryConfigurationUpdateStatus returns with failure 0x%8lx\n",
                        (UINT) hr);
            goto end;
        }
        else
        {
            // wprintf(L"QueryConfigurationUpdateStatus returns successfully\n");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod QueryConfigurationUpdateStatus had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract output params --- return code and log.
    //
    {
        DWORD dwReturnValue = 0;

        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"ReturnValue",      // <--------------------------------
                    &dwReturnValue
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read ReturnValue failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
    
        *pCompletionStatus =  (WBEMSTATUS) dwReturnValue;
    
        
        LPWSTR szLog = NULL;

        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"Log", // <-------------------------
                        &szLog
                        );
    
        if (FAILED(Status))
        {
            szLog = NULL;
        }
        
        *ppLog = szLog;

        ASSERT(Status != WBEM_S_PENDING);
    }

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}


WBEMSTATUS
NlbHostPing(
    LPCWSTR szBindString,
    UINT    Timeout, // In milliseconds.
    OUT ULONG  *pResolvedIpAddress // in network byte order.
    )
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    TRACE_INFO("->%!FUNC!(GUID=%ws)", szBindString);

    if (g_Fake)
    {
        Status = FakeNlbHostPing(szBindString, Timeout, pResolvedIpAddress);
    }
    else
    {
        Status = CfgUtilPing(szBindString, Timeout, pResolvedIpAddress);
    }

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}

WBEMSTATUS
setup_GetClusterConfiguration_input_params(
    IN LPCWSTR                              szNic,
    IN IWbemClassObjectPtr                  spWbemInput
    )
/*
    Setup the input wmi parameters for the GetClusterConfiguration method
*/
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    Status =  CfgUtilSetWmiStringParam(
                    spWbemInput,
                    L"AdapterGuid",
                    szNic
                    );
    return Status;
}


WBEMSTATUS
extract_GetClusterConfiguration_output_params(
    IN  IWbemClassObjectPtr                 spWbemOutput,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    DWORD       Generation          = 0;
    BOOL        NlbBound            = FALSE;
    BOOL        fDHCPEnabled        = FALSE;
    LPWSTR      *pszNetworkAddresses= NULL;
    UINT        NumNetworkAddresses = 0;
    BOOL        ValidNlbCfg         = FALSE;
    LPWSTR      szFriendlyName       = NULL;
    LPWSTR      szClusterName       = NULL;
    LPWSTR      szClusterNetworkAddress = NULL;
    LPWSTR      szTrafficMode       = NULL;
    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE
                TrafficMode
                 =  NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
    LPWSTR      *pszPortRules       = NULL;
    UINT        NumPortRules        = 0;
    DWORD       HostPriority        = 0;
    LPWSTR      szDedicatedNetworkAddress = NULL;
    /*
    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
                ClusterModeOnStart
                  =  NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
    */
    DWORD       ClusterModeOnStart      = CVY_HOST_STATE_STOPPED;
    BOOL        bPersistSuspendOnReboot = FALSE;
    BOOL        RemoteControlEnabled= FALSE;
    DWORD       dwHashedRemoteControlPassword = 0;

    pCfg->Clear();

    Status = CfgUtilGetWmiStringParam(
                    spWbemOutput,
                    L"FriendlyName", // <-------------------------
                    &szFriendlyName
                    );

    if (FAILED(Status))
    {
        wprintf(L"Attempt to read Friendly Name failed. Error=0x%08lx\n",
                (UINT) Status);
        szFriendlyName = NULL;
        // We don't treat this as a fatal error ...
    }

    Status = CfgUtilGetWmiDWORDParam(
                spWbemOutput,
                L"Generation",      // <--------------------------------
                &Generation
                );
    if (FAILED(Status))
    {
        wprintf(L"Attempt to read Generation failed. Error=0x%08lx\n",
             (UINT) Status);
        goto end;
    }

    Status = CfgUtilGetWmiStringArrayParam(
                spWbemOutput,
                L"NetworkAddresses", // <--------------------------------
                &pszNetworkAddresses,
                &NumNetworkAddresses
                );
    if (FAILED(Status))
    {
        wprintf(L"Attempt to read Network addresses failed. Error=0x%08lx\n",
             (UINT) Status);
        goto end;
    }

    Status = CfgUtilGetWmiBoolParam(
                    spWbemOutput,
                    L"DHCPEnabled",    // <--------------------------------
                    &fDHCPEnabled
                    );

    if (FAILED(Status))
    {
        fDHCPEnabled = FALSE;
    }

    Status = CfgUtilGetWmiBoolParam(
                    spWbemOutput,
                    L"NLBBound",    // <--------------------------------
                    &NlbBound
                    );

    if (FAILED(Status))
    {
        wprintf(L"Attempt to read NLBBound failed. Error=0x%08lx\n",
             (UINT) Status);
        goto end;
    }


    do // while false -- just to allow us to break out
    {
        ValidNlbCfg = FALSE;

        if (!NlbBound)
        {
            if (!g_Silent)
            {
                wprintf(L"NLB is UNBOUND\n");
            }
            break;
        }
    
        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"ClusterNetworkAddress", // <-------------------------
                        &szClusterNetworkAddress
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read Cluster IP failed. Error=0x%08lx\n",
                    (UINT) Status);
            break;
        }
    
        if (!g_Silent)
        {
            wprintf(L"NLB is BOUND, and the cluster address is %ws\n",
                    szClusterNetworkAddress);
        }
    
        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"ClusterName", // <-------------------------
                        &szClusterName
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read Cluster Name failed. Error=0x%08lx\n",
                    (UINT) Status);
            break;
        }
    
        //
        // Traffic mode
        //
        {
            Status = CfgUtilGetWmiStringParam(
                            spWbemOutput,
                            L"TrafficMode", // <-------------------------
                            &szTrafficMode
                            );
        
            if (FAILED(Status))
            {
                wprintf(L"Attempt to read Traffic Mode failed. Error=0x%08lx\n",
                        (UINT) Status);
                break;
            }
    
            if (!_wcsicmp(szTrafficMode, L"UNICAST"))
            {
                TrafficMode =
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
            }
            else if (!_wcsicmp(szTrafficMode, L"MULTICAST"))
            {
                TrafficMode =
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST;
            }
            else if (!_wcsicmp(szTrafficMode, L"IGMPMULTICAST"))
            {
                TrafficMode =
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST;
            }
        }
    
        // [OUT] String  PortRules[],
        Status = CfgUtilGetWmiStringArrayParam(
                    spWbemOutput,
                    L"PortRules", // <--------------------------------
                    &pszPortRules,
                    &NumPortRules
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read port rules failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
    
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"HostPriority",      // <--------------------------------
                    &HostPriority
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read HostPriority failed. Error=0x%08lx\n",
                 (UINT) Status);
            break;
        }
    
        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"DedicatedNetworkAddress", // <-------------------------
                        &szDedicatedNetworkAddress
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read dedicated IP failed. Error=0x%08lx\n",
                    (UINT) Status);
            break;
        }
        
        //
        // StartMode
        //
        {
            /*
            BOOL StartMode = FALSE;
            Status = CfgUtilGetWmiBoolParam(
                            spWbemOutput,
                            L"ClusterModeOnStart",   // <-------------------------
                            &StartMode
                            );
        
            if (FAILED(Status))
            {
                wprintf(L"Attempt to read ClusterModeOnStart failed. Error=0x%08lx\n",
                     (UINT) Status);
                break;
            }
            if (StartMode)
            {
                ClusterModeOnStart = 
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED;
            }
            else
            {
                ClusterModeOnStart = 
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
            }
            */

            Status = CfgUtilGetWmiDWORDParam(
                        spWbemOutput,
                        L"ClusterModeOnStart",      // <--------------------------------
                        &ClusterModeOnStart
                        );
            if (FAILED(Status))
            {
                wprintf(L"Attempt to read ClusterModeOnStart failed. Error=0x%08lx\n",
                     (UINT) Status);
                break;
            }

        }
    
        Status = CfgUtilGetWmiBoolParam(
                        spWbemOutput,
                        L"PersistSuspendOnReboot",   // <----------------------------
                        &bPersistSuspendOnReboot
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read PersistSuspendOnReboot failed. Error=0x%08lx\n",
                 (UINT) Status);
            break;
        }

        Status = CfgUtilGetWmiBoolParam(
                        spWbemOutput,
                        L"RemoteControlEnabled",   // <----------------------------
                        &RemoteControlEnabled
                        );
    
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read RemoteControlEnabled failed. Error=0x%08lx\n",
                 (UINT) Status);
            break;
        }


        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"HashedRemoteControlPassword",      // <-----------
                    &dwHashedRemoteControlPassword
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read dwHashedRemoteControlPassword failed. Error=0x%08lx\n",
                 (UINT) Status);
            //
            // we set this to 0 on failure, but go on.
            //
            dwHashedRemoteControlPassword = 0;
        }

        ValidNlbCfg = TRUE;

    } while (FALSE) ;
    
    //
    // Now let's set all the the parameters in Cfg
    //
    {
        (VOID) pCfg->SetFriendlyName(szFriendlyName); // OK if szFriendlyName is NULL.
        pCfg->Generation = Generation;
        pCfg->fDHCP    = fDHCPEnabled;
        pCfg->fBound    = NlbBound;
        Status = pCfg->SetNetworkAddresses(
                    (LPCWSTR*) pszNetworkAddresses,
                    NumNetworkAddresses
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to set NetworkAddresses failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
        pCfg->fValidNlbCfg  = ValidNlbCfg;
        pCfg->SetClusterName(szClusterName);
        pCfg->SetClusterNetworkAddress(szClusterNetworkAddress);
        pCfg->SetTrafficMode(TrafficMode);
        Status = pCfg->SetPortRules((LPCWSTR*)pszPortRules, NumPortRules);
        // Status = WBEM_NO_ERROR; // TODO -- change once port rules is done
        if (FAILED(Status))
        {
            wprintf(L"Attempt to set PortRules failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
        pCfg->SetHostPriority(HostPriority);
        pCfg->SetDedicatedNetworkAddress(szDedicatedNetworkAddress);
        pCfg->SetClusterModeOnStart(ClusterModeOnStart);
        pCfg->SetPersistSuspendOnReboot(bPersistSuspendOnReboot);
        pCfg->SetRemoteControlEnabled(RemoteControlEnabled);
        CfgUtilSetHashedRemoteControlPassword(
                &pCfg->NlbParams, 
                dwHashedRemoteControlPassword
                );
    }
    
end:

    delete szClusterNetworkAddress;
    delete pszNetworkAddresses;
    delete szFriendlyName;
    delete szClusterName;
    delete szTrafficMode;
    delete pszPortRules;
    delete szDedicatedNetworkAddress;

    return Status;
}

WBEMSTATUS
setup_UpdateClusterConfiguration_input_params(
    IN LPCWSTR                              szClientDescription,
    IN LPCWSTR                              szNic,
    IN PNLB_EXTENDED_CLUSTER_CONFIGURATION  pCfg,
    IN IWbemClassObjectPtr                  spWbemInput
    )
/*
    Setup the input wmi parameters for the UpdateGetClusterConfiguration method

            [IN] String  ClientDescription,
            [IN] String  AdapterGuid,
            [IN] uint32  Generation,
            [IN] Boolean PartialUpdate,

            [IN] Boolean AddDedicatedIp,
            [IN] Boolean AddClusterIps,
            [IN] Boolean CheckForAddressConflicts,

            [IN] String  NetworkAddresses[], // "10.1.1.1/255.255.255.255"
            [IN] Boolean NLBBound,
            [IN] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
            [IN] String  ClusterName,
            [IN] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
            [IN] String  PortRules[],
            [IN] uint32  HostPriority,
            [IN] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
            [IN] uint32  ClusterModeOnStart,      // 0 : STOPPED, 1 : STARTED, 2 : SUSPENDED
            [IN] Boolean PersistSuspendOnReboot,
            [IN] Boolean RemoteControlEnabled,
            [IN] String  RemoteControlPassword,
            [IN] uint32  HashedRemoteControlPassword,
*/
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    (VOID) CfgUtilSetWmiStringParam(
                    spWbemInput,
                    L"ClientDescription",
                    szClientDescription
                    );

    Status =  CfgUtilSetWmiStringParam(
                    spWbemInput,
                    L"AdapterGuid",
                    szNic
                    );
    if (FAILED(Status))
    {
        printf(
          "Setup update params: Couldn't set adapter GUID"
            " for NIC %ws\n",
            szNic
            );
        goto end;
    }

    //
    // Fill in NetworkAddresses[]
    //
    {
        LPWSTR *pszAddresses = NULL;
        UINT NumAddresses = 0;
        Status = pCfg->GetNetworkAddresses(
                        &pszAddresses,
                        &NumAddresses
                        );
        if (FAILED(Status))
        {
            printf(
              "Setup update params: couldn't extract network addresses from Cfg"
                " for NIC %ws\n",
                szNic
                );
            goto end;
        }

        //
        // Note it's ok to not specify  any IP addresses -- in which case
        // the default ip addresses will be set up.
        //
        if (pszAddresses != NULL)
        {
            Status = CfgUtilSetWmiStringArrayParam(
                        spWbemInput,
                        L"NetworkAddresses",
                        (LPCWSTR *)pszAddresses,
                        NumAddresses
                        );
            delete pszAddresses;
            pszAddresses = NULL;
        }
    }

    if (!pCfg->IsNlbBound())
    {
        //
        // NLB is not bound
        //

        Status = CfgUtilSetWmiBoolParam(spWbemInput, L"NLBBound", FALSE);
        goto end;
    }
    else if (!pCfg->IsValidNlbConfig())
    {
        printf(
            "Setup update params: NLB-specific configuration on NIC %ws is invalid\n",
            szNic
            );
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Status = CfgUtilSetWmiBoolParam(spWbemInput, L"NLBBound", TRUE);
    if (FAILED(Status))
    {
        printf("Error trying to set NLBBound parameter\n");
        goto end;
    }

    
    //
    // NLB is bound
    //


    Status = CfgUtilSetWmiBoolParam(spWbemInput, L"AddDedicatedIp",
                    pCfg->fAddDedicatedIp);
    if (FAILED(Status)) goto end;

    Status = CfgUtilSetWmiBoolParam(spWbemInput, L"AddClusterIps", 
                    pCfg->fAddClusterIps);
    if (FAILED(Status)) goto end;

    Status = CfgUtilSetWmiBoolParam(spWbemInput, L"CheckForAddressConflicts",
                    pCfg->fCheckForAddressConflicts);
    if (FAILED(Status)) goto end;


    //
    // Cluster name
    //
    {
        LPWSTR szName = NULL;
        Status = pCfg->GetClusterName(&szName);

        if (FAILED(Status))
        {
            printf(
              "Setup update params: Could not extract cluster name for NIC %ws\n",
                szNic
                );
            goto end;
        }
        CfgUtilSetWmiStringParam(spWbemInput, L"ClusterName", szName);
        delete (szName);
        szName = NULL;
    }
    
    //
    // Cluster and dedicated network addresses
    //
    {
        LPWSTR szAddress = NULL;
        Status = pCfg->GetClusterNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            printf(
           "Setup update params: Could not extract cluster address for NIC %ws\n",
                szNic
                );
            goto end;
        }
        CfgUtilSetWmiStringParam(
            spWbemInput,
            L"ClusterNetworkAddress",
            szAddress
            );
        delete (szAddress);
        szAddress = NULL;

        Status = pCfg->GetDedicatedNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            printf(
         "Setup update params: Could not extract dedicated address for NIC %ws\n",
                szNic
                );
            goto end;
        }
        CfgUtilSetWmiStringParam(
            spWbemInput,
            L"DedicatedNetworkAddress",
            szAddress
            );
        delete (szAddress);
        szAddress = NULL;
    }

    //
    // TrafficMode
    //
    {
        LPCWSTR szMode = NULL;
        switch(pCfg->GetTrafficMode())
        {
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST:
            szMode = L"UNICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST:
            szMode = L"MULTICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST:
            szMode = L"IGMPMULTICAST";
            break;
        default:
            assert(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CfgUtilSetWmiStringParam(spWbemInput, L"TrafficMode", szMode);
    }

    CfgUtilSetWmiDWORDParam(
        spWbemInput,
        L"HostPriority",
        pCfg->GetHostPriority()
        );

    /*
    if (pCfg->GetClusterModeOnStart() ==
        NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED)
    {
        CfgUtilSetWmiBoolParam(spWbemInput, L"ClusterModeOnStart", TRUE);
    }
    else
    {
        CfgUtilSetWmiBoolParam(spWbemInput, L"ClusterModeOnStart", FALSE);
    }
    */

    CfgUtilSetWmiDWORDParam(
        spWbemInput,
        L"ClusterModeOnStart",
        pCfg->GetClusterModeOnStart()
        );

    CfgUtilSetWmiBoolParam(
        spWbemInput,
        L"PersistSuspendOnReboot",
        pCfg->GetPersistSuspendOnReboot()
        );

    CfgUtilSetWmiBoolParam(
        spWbemInput,
        L"RemoteControlEnabled",
        pCfg->GetRemoteControlEnabled()
        );

    
    //
    // Set the new password or hashed-password params, if specified.
    //
    {
        // String  RemoteControlPassword,

        LPCWSTR szPwd = NULL;
        szPwd = pCfg->GetNewRemoteControlPasswordRaw();
        if (szPwd != NULL)
        {
            CfgUtilSetWmiStringParam(
                spWbemInput,
                L"RemoteControlPassword",
                szPwd
                );
        }
        else // only set the hashed pwd if szPwd is not specified.
        {
            DWORD dwHashedRemoteControlPassword;
            BOOL fRet = FALSE;

            fRet = pCfg->GetNewHashedRemoteControlPassword(
                                dwHashedRemoteControlPassword
                                );
    
            if (fRet)
            {
        
                CfgUtilSetWmiDWORDParam(
                    spWbemInput,
                    L"HashedRemoteControlPassword",
                    dwHashedRemoteControlPassword
                    );
            }
        }
    }

    //
    // String  PortRules[],
    //
    {
        LPWSTR *pszPortRules = NULL;
        UINT NumPortRules = 0;
        Status = pCfg->GetPortRules(
                        &pszPortRules,
                        &NumPortRules
                        );
        if (FAILED(Status))
        {
            printf(
              "Setup update params: couldn't extract port rules from Cfg"
                " for NIC %ws\n",
                szNic
                );
            goto end;
        }

        if (NumPortRules != 0)
        {
            Status = CfgUtilSetWmiStringArrayParam(
                        spWbemInput,
                        L"PortRules",
                        (LPCWSTR *)pszPortRules,
                        NumPortRules
                        );
            delete pszPortRules;
            pszPortRules = NULL;
        }
    }
    

    Status = WBEM_NO_ERROR;

end:

    wprintf(L"<-Setup update params returns 0x%08lx\n", (UINT) Status);

    return Status;

}


WBEMSTATUS
NlbHostGetCompatibleNics(
        PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
        OUT LPWSTR **ppszNics,  // free using delete
        OUT UINT   *pNumNics,  // free using delete
        OUT UINT   *pNumBoundToNlb
        )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;
    LPWSTR              *pszNicList = NULL;
    UINT                NumNics = 0;
    DWORD               NumBoundToNlb = 0;
    
    if (pConnInfo!=NULL)
    {
        TRACE_INFO("->%!FUNC!(Machine=%ws)", pConnInfo->szMachine);
    }
    else
    {
        TRACE_INFO("->%!FUNC! (Machine=<NULL>)");
    }


    if (g_Fake)
    {
        Status =  FakeNlbHostGetCompatibleNics(
                                pConnInfo,
                                ppszNics, 
                                pNumNics, 
                                pNumBoundToNlb
                                );
        goto end_fake;
    }

    *ppszNics = NULL;
    *pNumNics = NULL;
    *pNumBoundToNlb = NULL;

    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }
    

    //
    // Get wmi input instance to "GetCompatibleAdapterGuids" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    spWbemService,
                    L"NlbsNic",             // szClassName
                    NULL, // L"AdapterGuid",         // szParameterName
                    NULL, // szNicGuid,              // szPropertyValue
                    L"GetCompatibleAdapterGuids",    // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );

        if (FAILED(Status))
        {
            TRACE_CRIT(
             L"%!FUNC! ERROR 0x%08lx trying to get instance of GetCompatibleAdapterGuids",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the "GetClusterConfiguration" method
    // NOTE: spWbemInput could be NULL.
    //
    {
        // NOTHING TO DO HERE -- no input params...
    }

    //
    // Call the "GetCompatibleAdapterGuids" method
    //
    {
        HRESULT hr;

        TRACE_VERB(L"%!FUNC! Going get GetCompatibleAdapterGuids...");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"GetCompatibleAdapterGuids",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            TRACE_CRIT(L"%!FUNC! GetCompatibleAdapterGuids returns with failure 0x%8lx",
                        (UINT) hr);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        else
        {
            TRACE_VERB(L"GetCompatibleAdapterGuids returns successfully");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            TRACE_CRIT("%!FUNC! ExecMethod GetCompatibleAdapterGuids had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract params from the method
    //
    //   [OUT] String  AdapterGuids[],
    //   [OUT] uint32  NumBoundToNlb
    //

    Status = CfgUtilGetWmiDWORDParam(
                spWbemOutput,
                L"NumBoundToNlb",      // <--------------------------------
                &NumBoundToNlb
                );
    if (FAILED(Status))
    {
        TRACE_CRIT(L"Attempt to read NumBoundToNlb failed. Error=0x%08lx\n",
             (UINT) Status);
        NumBoundToNlb = 0;
        goto end;
    }

    Status = CfgUtilGetWmiStringArrayParam(
                spWbemOutput,
                L"AdapterGuids", // <--------------------------------
                &pszNicList,
                &NumNics
                );
    if (FAILED(Status))
    {
        TRACE_CRIT(L"%!FUNC! Attempt to read Adapter Guids failed. Error=0x%08lx",
             (UINT) Status);
        pszNicList = NULL;
        NumNics = 0;
        goto end;
    }
    

end:

    if (!FAILED(Status))
    {
        *ppszNics   = pszNicList;
        pszNicList  = NULL;
        *pNumNics   = NumNics;
        *pNumBoundToNlb  = NumBoundToNlb;
    }

    delete pszNicList;
    delete pRelPath;

end_fake:

    spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}


WBEMSTATUS
NlbHostGetMachineIdentification(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT LPWSTR *pszMachineName, // free using delete
    OUT LPWSTR *pszMachineGuid,  // free using delete -- may be null
    OUT BOOL *pfNlbMgrProviderInstalled // If nlb manager provider is installed.
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    
    if (pConnInfo!=NULL)
    {
        TRACE_INFO("->%!FUNC!(Machine=%ws)", pConnInfo->szMachine);
    }
    else
    {
        TRACE_INFO("->%!FUNC! (Machine=<NULL>)");
    }


    if (g_Fake)
    {
        Status = FakeNlbHostGetMachineIdentification(
                                pConnInfo,
                                pszMachineName,
                                pszMachineGuid,
                                pfNlbMgrProviderInstalled
                                );
        goto end;
    }

    *pszMachineName = NULL;
    *pszMachineGuid = NULL;
    *pfNlbMgrProviderInstalled  = FALSE;


    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }
    *pfNlbMgrProviderInstalled  = TRUE;
    
    
    Status =  CfgUtilGetWmiMachineName(spWbemService, pszMachineName);
    if (FAILED(Status))
    {
        *pszMachineName = NULL;
    }

end:

    spWbemService = NULL; // Smart pointer

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}


WBEMSTATUS
connect_to_server(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT IWbemServicesPtr    &spWbemService // Smart pointer
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    #define _MaxLen 256
    WCHAR NetworkResource[_MaxLen];
    LPCWSTR szMachine = L".";
    LPCWSTR szPassword = NULL;
    LPCWSTR szUserName = NULL;
    HRESULT hr;
    WCHAR rgClearPassword[128];

    //
    // Get interface to the NLB namespace on the specified machine.
    //
    if (pConnInfo!=NULL)
    {
        szMachine   = pConnInfo->szMachine;
        szPassword  = pConnInfo->szPassword;
        szUserName  = pConnInfo->szUserName;
    }

    hr = StringCbPrintf(
            NetworkResource,
            sizeof(NetworkResource),
            L"\\\\%ws\\root\\microsoftnlb",
            szMachine
            );

    if (hr != S_OK)
    {
        TRACE_CRIT(L"%!FUNC! NetworkResource truncated - %ws",
            NetworkResource);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    if (szPassword != NULL && *szPassword != 0)
    {
        //
        // A non-null, non-empty password was passed in...
        // It's encrypted, so we temporarily decrypt it here...
        // (We zero it out right before returning from this function)
        //
        BOOL fRet =  CfgUtilDecryptPassword(
                            szPassword,
                            ASIZE(rgClearPassword),
                            rgClearPassword
                            );
        if (!fRet)
        {
            TRACE_INFO("Attempt to decrypt failed -- bailing");
            Status = WBEM_E_INVALID_PARAMETER;
            goto end;
        }
        szPassword = rgClearPassword;
    }

    TRACE_INFO("%!FUNC! Connecting to NLB on %ws ...", szMachine);

    Status = CfgUtilConnectToServer(
                NetworkResource,
                szUserName, // szUser
                szPassword, // szPassword
                NULL, // szAuthority (domain)
                &spWbemService
                );

    //
    // Security BUGBUG zero out decrypted password.
    //
    if (FAILED(Status))
    {
        TRACE_CRIT(
            "%!FUNC! ERROR 0x%lx connectiong to  NLB on %ws",
            (UINT) Status,
            szMachine
            );
    }
    else
    { 
        TRACE_INFO(L"Successfully connected to NLB on %ws...", szMachine);
    }

end:

    SecureZeroMemory(rgClearPassword, sizeof(rgClearPassword));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\private.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager provider test harness

File Name:

    private.h

Abstract:

    Internal headers


History:

    04/08/01    JosephJ Created

--*/

// #define NLB_USE_MUTEX 1

#include <FWcommon.h>
#include <assert.h>
#include <objbase.h>
#include <initguid.h>
#include <strsafe.h>
#include "wlbsconfig.h"
#include "myntrtl.h"
#include "wlbsparm.h"
#include <nlberr.h>
#include <cfgutil.h>
#include <nlbclient.h>
#include "fake.h"

//
// Debugging stuff...
//
extern BOOL g_DoBreaks;
#define MyBreak(_str) ((g_DoBreaks) ? (OutputDebugString(_str),DebugBreak(),1):0)

extern BOOL g_Fake; // If true, operate in "fake mode" -- see NlbHostFake()

#define REF

#define ASSERT assert
#define ASIZE(_array) (sizeof(_array)/sizeof(_array[0]))

//
// Use this to copy to an array (not pointer) destination 
//
#define ARRAYSTRCPY(_dest, _src) \
            StringCbCopy((_dest), sizeof(_dest), (_src))

#define ARRAYSTRCAT(_dest, _src) \
            StringCbCat((_dest), sizeof(_dest), (_src))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\myntrtl.h ===
//
// These are taken from NTRTL.H. Currently including ntrtl.h causes
// errors because of a conflict with some other header file.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\inc\cfgutil.h ===
//***************************************************************************
//
//  CFGUTIL.H
// 
//  Purpose: NLB configuration-related helper utilities for:
//              -- bind/unbind of nlb
//              -- wmi client and server helper APIs
//              -- utility functions with no side effects like allocate array
//              -- wrappers around some wlbsctrl APIs -- it will dynamically
//                 load wlbsctrl and do the appropriate thing for W2K and XP.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/23/01    JosephJ Created -- used to live under nlbmgr\provider as
//                      cfgutils.h (i.e., with ending 's').
//              Lib which implements the functionality is in
//              nlbmgr\cfgutillib.
//
//***************************************************************************


typedef enum
{
    WLBS_START = 0,
    WLBS_STOP,      
    WLBS_DRAIN,      
    WLBS_SUSPEND,     
    WLBS_RESUME,       
    WLBS_PORT_ENABLE,  
    WLBS_PORT_DISABLE,  
    WLBS_PORT_DRAIN,     
    WLBS_QUERY,           
    WLBS_QUERY_PORT_STATE

} WLBS_OPERATION_CODES;


typedef struct _NLB_IP_ADDRESS_INFO
{
    WCHAR       IpAddress[WLBS_MAX_CL_IP_ADDR];
    WCHAR       SubnetMask[WLBS_MAX_CL_NET_MASK];
    
} NLB_IP_ADDRESS_INFO;


typedef struct _NLB_CLUSTER_MEMBER_INFO
{
    UINT    HostId;
    WCHAR   DedicatedIpAddress[WLBS_MAX_CL_IP_ADDR];
    WCHAR   HostName[CVY_MAX_FQDN+1];
    
} NLB_CLUSTER_MEMBER_INFO;

WBEMSTATUS
CfgUtilInitialize(BOOL fServer, BOOL fNoPing);

VOID
CfgUtilDeitialize(VOID);

//
// Gets the list of IP addresses and the friendly name for the specified NIC.
//
WBEMSTATUS
CfgUtilGetIpAddressesAndFriendlyName(
    IN  LPCWSTR szNic,
    OUT UINT    *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo, // Free using c++ delete operator.
    OUT LPWSTR *pszFriendlyName // Optional, Free using c++ delete
    );

//
// Sets the list of statically-bound IP addresses for the NIC.
// if NumIpAddresses is 0, the NIC is configured with a made-up autonet.
// (call CfgUtilSetDHCP to set a DHCP-assigned address).
//
WBEMSTATUS
CfgUtilSetStaticIpAddresses(
    IN  LPCWSTR szNic,
    IN  UINT    NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    );

//
// Sets the IP addresses for the NIC to be DHCP-assigned.
//
WBEMSTATUS
CfgUtilSetDHCP(
    IN  LPCWSTR szNic
    );


//
// Determines whether the specified nic is configured with DHCP or not.
//
WBEMSTATUS
CfgUtilGetDHCP(
    IN  LPCWSTR szNic,
    OUT BOOL    *pfDHCP
    );



//
//    Returns an array of pointers to string-version of GUIDS
//    that represent the set of alive and healthy NICS that are
//    suitable for NLB to bind to -- basically alive ethernet NICs.
//
//    Delete ppNics using the delete WCHAR[] operator. Do not
//    delete the individual strings.
//
WBEMSTATUS
CfgUtilsGetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // Optional
        );

//
// Determines whether NLB is bound to the specified NIC.
//
WBEMSTATUS
CfgUtilCheckIfNlbBound(
    IN  LPCWSTR szNic,
    OUT BOOL *pfBound
    );

//
// On success, *pfCanLock is set to TRUE IFF the NETCFG write lock
// CAN be locked at this point in time.
// WARNING: this is really just a hint, as immediately after the function
// returns the state may change.
//
WBEMSTATUS
CfgUtilGetNetcfgWriteLockState(
    OUT BOOL *pfCanLock,
    LPWSTR   *pszHeldBy // OPTIONAL, free using delete[].
    );

//
// Binds/unbinds NLB to the specified NIC.
//
WBEMSTATUS
CfgUtilChangeNlbBindState(
    IN  LPCWSTR szNic,
    IN  BOOL fBind
    );


//
// Initializes pParams using default values.
//
VOID
CfgUtilInitializeParams(
    OUT WLBS_REG_PARAMS *pParams
    );

//
// Converts the specified plain-text password into the hashed version
// and saves it in pParams.
//
DWORD
CfgUtilSetRemotePassword(
    IN WLBS_REG_PARAMS *pParams,
    IN LPCWSTR         szPassword
    
    );

//
// Gets the current NLB configuration for the specified NIC
//
WBEMSTATUS
CfgUtilGetNlbConfig(
    IN  LPCWSTR szNic,
    OUT WLBS_REG_PARAMS *pParams
    );

//
// Sets the current NLB configuration for the specified NIC. This
// includes notifying the driver if required.
//
WBEMSTATUS
CfgUtilSetNlbConfig(
    IN  LPCWSTR szNic,
    IN  WLBS_REG_PARAMS *pParams,
    IN  BOOL fJustBound
    );

//
// Just writes the current NLB configuration for the specified NIC to the
// registry. MAY BE CALLED WHEN NLB IS UNBOUND.
//
WBEMSTATUS
CfgUtilRegWriteParams(
    IN  LPCWSTR szNic,
    IN  WLBS_REG_PARAMS *pParams
    );

//
// Recommends whether the update should be performed async or sync
// Returns WBEM_S_FALSE if the update is a no op.
// Returns WBEM_INVALID_PARAMATER if the params are invalid.
//
WBEMSTATUS
CfgUtilsAnalyzeNlbUpdate(
    IN  const WLBS_REG_PARAMS *pCurrentParams, OPTIONAL
    IN  WLBS_REG_PARAMS *pNewParams,
    OUT BOOL *pfConnectivityChange
    );


//
// Verifies that the NIC GUID exists.
//
WBEMSTATUS
CfgUtilsValidateNicGuid(
    IN LPCWSTR szGuid
    );

//
// Validates a network address
//
WBEMSTATUS
CfgUtilsValidateNetworkAddress(
    IN  LPCWSTR szAddress,          // format: "10.0.0.1[/255.0.0.0]"
    OUT PUINT puIpAddress,        // in network byte order
    OUT PUINT puSubnetMask,       // in network byte order (0 if unspecified)
    OUT PUINT puDefaultSubnetMask // depends on class: 'a', 'b', 'c', 'd', 'e'
    );


WBEMSTATUS
CfgUtilControlCluster(
    IN  LPCWSTR szNic,
    IN  WLBS_OPERATION_CODES Opcode,
    IN  DWORD   Vip,
    IN  DWORD   PortNum,
    OUT DWORD * pdwHostMap,
    OUT DWORD * pdwNlbStatus  
    );

WBEMSTATUS
CfgUtilGetClusterMembers(
    IN  LPCWSTR                 szNic,
    OUT DWORD                   *pNumMembers,
    OUT NLB_CLUSTER_MEMBER_INFO **ppMembers       // free using delete[]
    );

WBEMSTATUS
CfgUtilSafeArrayFromStrings(
    IN  LPCWSTR       *pStrings,
    IN  UINT          NumStrings,
    OUT SAFEARRAY   **ppSA
    );

WBEMSTATUS
CfgUtilStringsFromSafeArray(
    IN  SAFEARRAY   *pSA,
    OUT LPWSTR     **ppStrings,
    OUT UINT        *pNumStrings
    );


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));

WBEMSTATUS
get_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    OUT LPWSTR *ppStringValue
    );


WBEMSTATUS
CfgUtilGetWmiObjectInstance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName,
    IN  LPCWSTR             szPropertyValue,
    OUT IWbemClassObjectPtr &sprefObj // smart pointer
    );

WBEMSTATUS
CfgUtilGetWmiRelPath(
    IN  IWbemClassObjectPtr spObj,
    OUT LPWSTR *            pszRelPath          // free using delete 
    );

WBEMSTATUS
CfgUtilGetWmiInputInstanceAndRelPath(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName, // NULL: return Class rel path
    IN  LPCWSTR             szPropertyValue,
    IN  LPCWSTR             szMethodName,
    OUT IWbemClassObjectPtr &spWbemInputInstance, // smart pointer
    OUT LPWSTR *           pszRelPath          // free using delete 
    );

WBEMSTATUS
CfgUtilGetWmiMachineName(
    IN  IWbemServicesPtr    spWbemServiceIF,
    OUT LPWSTR *            pszMachineName          // free using delete 
    );

WBEMSTATUS
CfgUtilGetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR *ppStringValue
);


WBEMSTATUS
CfgUtilSetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             szValue
    );


WBEMSTATUS
CfgUtilGetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR              **ppStrings,
    OUT UINT                *pNumStrings
);


WBEMSTATUS
CfgUtilSetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             *ppStrings,
    IN  UINT                NumStrings
);


WBEMSTATUS
CfgUtilGetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT DWORD              *pValue
);


WBEMSTATUS
CfgUtilSetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  DWORD               Value
);


WBEMSTATUS
CfgUtilGetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT BOOL                *pValue
);


WBEMSTATUS
CfgUtilSetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  BOOL                Value
);

WBEMSTATUS
CfgUtilConnectToServer(
    IN  LPCWSTR szNetworkResource, // \\machinename\root\microsoftnlb  \root\...
    IN  LPCWSTR szUser,   // Must be NULL for local server
    IN  LPCWSTR szPassword,   // Must be NULL for local server
    IN  LPCWSTR szAuthority,  // Must be NULL for local server
    OUT IWbemServices  **ppWbemService // deref when done.
    );

LPWSTR *
CfgUtilsAllocateStringArray(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    );

#define NLB_MAX_PORT_STRING_SIZE 128 // in WCHARS, including ending NULL

BOOL
CfgUtilsGetPortRuleString(
    IN PWLBS_PORT_RULE pPr,
    OUT LPWSTR pString         // At least NLB_MAX_PORT_STRING_SIZE wchars
    );

BOOL
CfgUtilsSetPortRuleString(
    IN LPCWSTR pString,
    OUT PWLBS_PORT_RULE pPr
    );

//
// Gets the port rules, if any, from the specfied nlb params structure
//
WBEMSTATUS
CfgUtilGetPortRules(
    IN  const WLBS_REG_PARAMS *pParams,
    OUT WLBS_PORT_RULE **ppRules,   // Free using delete
    OUT UINT           *pNumRules
    );

//
// Sets the specified port rules in the specfied nlb params structure
//
WBEMSTATUS
CfgUtilSetPortRules(
    IN WLBS_PORT_RULE *pRules,
    IN UINT           NumRules,
    IN OUT WLBS_REG_PARAMS *pParams
    );


//
// Sets the hashed version of the remote control password
//
VOID
CfgUtilSetHashedRemoteControlPassword(
    IN OUT WLBS_REG_PARAMS *pParams,
    IN DWORD dwHashedPassword
);

//
// Gets the hashed version of the remote control password
//
DWORD
CfgUtilGetHashedRemoteControlPassword(
    IN const WLBS_REG_PARAMS *pParams
);


//
// Attempts to resolve the ip address and ping the host.
//
WBEMSTATUS
CfgUtilPing(
    IN  LPCWSTR szBindString,
    IN  UINT    Timeout, // In milliseconds.
    OUT ULONG  *pResolvedIpAddress // in network byte order.
    );


BOOL
CfgUtilEncryptPassword(
    IN  LPCWSTR szPassword,
    OUT UINT    cchEncPwd,  // size in chars of szEncPwd, inc space for ending 0
    OUT LPWSTR  szEncPwd
    );

BOOL
CfgUtilDecryptPassword(
    IN  LPCWSTR szEncPwd,
    OUT UINT    cchPwd,  // size in chars of szPwd, inc space for ending 0
    OUT LPWSTR  szPwd
    );



//
// Returns TRUE if MSCS is installed, false otherwise
//
BOOL
CfgUtilIsMSCSInstalled(VOID);

// Enables SE_LOAD_DRIVER_NAME privilege
BOOL 
CfgUtils_Enable_Load_Unload_Driver_Privilege(VOID);

typedef struct _NLB_IP_ADDRESS_INFO NLB_IP_ADDRESS_INFO;

//
// This structure contains all information associated with a particular NIC
// that is relevant to NLB. This includes the IP addresses bound the NIC,
// whether or not NLB is bound to the NIC, and if NLB is bound, all 
// the NLB-specific properties.
//
class NLB_EXTENDED_CLUSTER_CONFIGURATION
{
public:

    NLB_EXTENDED_CLUSTER_CONFIGURATION(VOID)  {ZeroMemory(this, sizeof(*this));}
    ~NLB_EXTENDED_CLUSTER_CONFIGURATION()
     {
        Clear();
     };

    VOID
    Clear(VOID)
    {
        delete pIpAddressInfo;
        delete m_szFriendlyName;
        delete m_szNewRemoteControlPassword;

        ZeroMemory(this, sizeof(*this));

        CfgUtilInitializeParams(&NlbParams);
    }

    VOID
    SetDefaultNlbCluster(VOID)
    {
        CfgUtilInitializeParams(&NlbParams);
        fValidNlbCfg = TRUE;
        fBound = TRUE;
    }

    NLBERROR
    AnalyzeUpdate(
        IN  NLB_EXTENDED_CLUSTER_CONFIGURATION *pNewCfg,
        OUT BOOL *pfConnectivityChange
        );


    WBEMSTATUS
    Update(
        IN  const NLB_EXTENDED_CLUSTER_CONFIGURATION *pNewCfg
        );

    WBEMSTATUS
    SetNetworkAddresses(
        IN  LPCWSTR *pszNetworkAddresses,
        IN  UINT    NumNetworkAddresses
        );

    WBEMSTATUS
    SetNetworkAddressesSafeArray(
        IN SAFEARRAY   *pSA
        );

    VOID
    SetNetworkAddressesRaw(
        IN NLB_IP_ADDRESS_INFO *pNewInfo, // Allocated using new, can be NULL
        IN UINT NumNew
        )
        {
            delete pIpAddressInfo;
            pIpAddressInfo = pNewInfo;
            NumIpAddresses = NumNew;
        }

    WBEMSTATUS
    GetNetworkAddresses(
        OUT LPWSTR **ppszNetworkAddresses,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        );

    WBEMSTATUS
    GetNetworkAddressesSafeArray(
        OUT SAFEARRAY   **ppSA
        );
        
    WBEMSTATUS
    SetNetworkAddresPairs(
        IN  LPCWSTR *pszIpAddresses,
        IN  LPCWSTR *pszSubnetMasks,
        IN  UINT    NumNetworkAddresses
        );

    WBEMSTATUS
    GetNetworkAddressPairs(
        OUT LPWSTR **ppszIpAddresses,   // free using delete
        OUT LPWSTR **ppszIpSubnetMasks,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        );

    WBEMSTATUS
    ModifyNetworkAddress(
        IN LPCWSTR szOldNetworkAddress,  OPTIONAL
        IN LPCWSTR szNewIpAddress,  OPTIONAL
        IN LPCWSTR szNewSubnetMask  OPTIONAL
        );
    //
    // NULL, NULL: clear all network addresses
    // NULL, szNew: add
    // szOld, NULL: remove
    // szOld, szNew: replace (or add, if old doesn't exist)
    //

    WBEMSTATUS
    GetPortRules(
        OUT LPWSTR **ppszPortRules,
        OUT UINT    *pNumPortRules
        );


    WBEMSTATUS
    SetPortRules(
        IN LPCWSTR *pszPortRules,
        IN UINT    NumPortRules
        );
    
    WBEMSTATUS
    GetPortRulesSafeArray(
        OUT SAFEARRAY   **ppSA
        );

    WBEMSTATUS
    SetPortRulesSafeArray(
        IN SAFEARRAY   *pSA
        );

    UINT GetGeneration(VOID)    {return Generation;}
    BOOL IsNlbBound(VOID)       const {return fBound;}
    BOOL IsValidNlbConfig(VOID) const {return fBound && fValidNlbCfg;}
    VOID SetNlbBound(BOOL fNlbBound)       {fBound = (fNlbBound!=0);}

    WBEMSTATUS
    GetClusterName(
            OUT LPWSTR *pszName
            );

    VOID
    SetClusterName(
            IN LPCWSTR szName // NULL ok
            );

    WBEMSTATUS
    GetClusterNetworkAddress(
            OUT LPWSTR *pszAddress
            );

    VOID
    SetClusterNetworkAddress(
            IN LPCWSTR szAddress // NULL ok
            );
    
    WBEMSTATUS
    GetDedicatedNetworkAddress(
            OUT LPWSTR *pszAddress
            );

    VOID
    SetDedicatedNetworkAddress(
            IN LPCWSTR szAddress // NULL ok
            );

    typedef enum
    {
        TRAFFIC_MODE_UNICAST,
        TRAFFIC_MODE_MULTICAST,
        TRAFFIC_MODE_IGMPMULTICAST

    } TRAFFIC_MODE;

    TRAFFIC_MODE
    GetTrafficMode(
        VOID
        ) const;

    VOID
    SetTrafficMode(
        TRAFFIC_MODE Mode
        );

    UINT
    GetHostPriority(
        VOID
        );

    VOID
    SetHostPriority(
        UINT Priority
        );

    /* OBSOLETE
    typedef enum
    {
        START_MODE_STARTED,
        START_MODE_STOPPED

    } START_MODE;
    */

    DWORD
    GetClusterModeOnStart(
        VOID
        );

    VOID
    SetClusterModeOnStart(
        DWORD Mode
        );

    BOOL
    GetPersistSuspendOnReboot( 
        VOID 
        );

    VOID
    SetPersistSuspendOnReboot(
        BOOL bPersistSuspendOnReboot
        );

    BOOL
    GetRemoteControlEnabled(
        VOID
        ) const;

    VOID
    SetRemoteControlEnabled(
        BOOL fEnabled
        );

    WBEMSTATUS
    GetFriendlyName(
        OUT LPWSTR *pszFriendlyName // Free using delete
        ) const;

    WBEMSTATUS
    SetFriendlyName(
        IN LPCWSTR szFriendlyName // Saves a copy of szFriendlyName
        );
    
    LPCWSTR
    GetNewRemoteControlPasswordRaw(VOID) const
    {
        if (NewRemoteControlPasswordSet())
        {
            return m_szNewRemoteControlPassword;
        }
        else
        {
            return NULL;
        }
    }

    BOOL
    NewRemoteControlPasswordSet(
        VOID
        ) const
    {
        return GetRemoteControlEnabled() && m_fSetPassword;
    }

    WBEMSTATUS
    SetNewRemoteControlPassword(
        IN LPCWSTR szFriendlyName // Saves a copy of szRemoteControlPassword
        );
    
    VOID
    SetNewHashedRemoteControlPassword(
        DWORD dwHash
        )
    {
        delete m_szNewRemoteControlPassword;
        m_szNewRemoteControlPassword = NULL;
        m_fSetPassword = TRUE;
        m_dwNewHashedRemoteControlPassword = dwHash;
    }

    VOID
    ClearNewRemoteControlPassword(
        VOID
        )
    {
        delete m_szNewRemoteControlPassword;
        m_szNewRemoteControlPassword = NULL;
        m_fSetPassword = FALSE;
        m_dwNewHashedRemoteControlPassword = 0;
    }

    BOOL
    GetNewHashedRemoteControlPassword(
        DWORD &dwHash
        ) const
    {
        BOOL fRet = FALSE;
        if (NewRemoteControlPasswordSet())
        {
            dwHash = m_dwNewHashedRemoteControlPassword;
            fRet = TRUE;
        }
        else
        {
            dwHash = 0;
        }
        return fRet;
    }

    BOOL
    IsBlankDedicatedIp(
        VOID
        ) const;




    //
    // Following fields are public because this class started out as a
    // structure. TODO: wrap these with access methods.
    //

    BOOL            fValidNlbCfg;   // True iff all the information is valid.
    UINT            Generation;     // Generation ID of this Update.
    BOOL            fBound;         // Whether or not NLB is bound to this NIC.
    BOOL            fDHCP;          // Whether the address is DHCP assigned.


    //
    // The following three fields are used only when updating the configuration.
    // They are all set to false on reading the configuration.
    //
    BOOL            fAddDedicatedIp; // add ded ip (if present)
    BOOL            fAddClusterIps;  // add cluster vips (if bound)
    BOOL            fCheckForAddressConflicts;

    //
    // When GETTING configuration info, the following provide the full
    // list of statically configured IP addresses on the specified NIC.
    //
    // When SETTING configuration info, the following can either be zero
    // or non-zero. If zero, the set of IP addresses to be added will
    // be inferred from other fields (like cluster vip, per-port vips,
    // existing IP addresses and the three fields above).
    // If non-zero, the exact set of VIPS specified will be used.
    //
    UINT            NumIpAddresses; // Number of IP addresses bound to the NIC
    NLB_IP_ADDRESS_INFO *pIpAddressInfo; // The actual IP addresses & masks


    WLBS_REG_PARAMS  NlbParams;    // The WLBS-specific configuration

    //
    // TODO move all data stuff below here...
    //

private:

    LPCWSTR m_szFriendlyName; // Friendly name of NIC.


    //
    // IF nlb is bound AND remote control is enabled,
    // AND this field is true, we'll set the password -- either
    // m_szNewRemoteControlPassword or (if former is NULL) 
    // m_dwNewHashedRemoteControlPassword.
    //
    // Access methods:
    //  SetNewRemoteControlPassword
    //  SetNewHashedRemoteControlPassword
    //  ClearNewRemoteControlPassword
    //  GetNewRemoteControlPasswordRaw
    //  GetNewHashedRemoteControlPassword
    //
    BOOL    m_fSetPassword;
    LPCWSTR m_szNewRemoteControlPassword;
    DWORD   m_dwNewHashedRemoteControlPassword;

    
           
    //
    // Enable the following to identify places in code that do a struct
    // copy or initialization from struct.
    // TODO: clean up the maintenance of the embedded pointers during copy.
    //

#if 0
    NLB_EXTENDED_CLUSTER_CONFIGURATION(
        const  NLB_EXTENDED_CLUSTER_CONFIGURATION&
        );

    NLB_EXTENDED_CLUSTER_CONFIGURATION&
    operator = (const NLB_EXTENDED_CLUSTER_CONFIGURATION&);
#endif // 0

};

typedef NLB_EXTENDED_CLUSTER_CONFIGURATION *PNLB_EXTENDED_CLUSTER_CONFIGURATION;


//
// Class for manipulating lists of IP addresses and subnet masks.
// See provider\tests\tprov.cpp for examples of it's use.
//
class NlbIpAddressList
{
public:
    NlbIpAddressList(void)
        : m_uNum(0), m_uMax(0), m_pIpInfo(NULL)
    {
    }

    ~NlbIpAddressList()
    {
        delete[] m_pIpInfo;
        m_pIpInfo = NULL;
        m_uNum=0;
        m_uMax=0;
    }

    BOOL
    Copy(const NlbIpAddressList &refList);

    BOOL
    Validate(void); // checks that there are no dups and all valid ip/subnets

    BOOL
    Set(UINT uNew, const NLB_IP_ADDRESS_INFO *pNewInfo, UINT uExtraCount);

    //
    // Looks for the specified IP address  -- returns an internal pointer
    // to the found IP address info, if fount, otherwise NULL.
    //
    const NLB_IP_ADDRESS_INFO *
    Find(
        LPCWSTR szIp // IF NULL, returns first address
        ) const;

    VOID
    Extract(UINT &uNum, NLB_IP_ADDRESS_INFO * &pNewInfo);

    BOOL
    Modify(LPCWSTR szOldIp, LPCWSTR szNewIp, LPCWSTR szNewSubnet);

    BOOL
    Apply(UINT uNew, const NLB_IP_ADDRESS_INFO *pNewInfo);

    VOID
    Clear(VOID)
    {
        (VOID) this->Set(0, NULL, 0);
    }

    UINT
    NumAddresses(VOID)
    {
        return m_uNum;
    }

private:
    UINT                m_uNum;       // current count of valid ip addresses
    UINT                m_uMax;       // allocated ip addresses
    NLB_IP_ADDRESS_INFO *m_pIpInfo;    // allocated array.
    
    //
    // Assignment and pass-by-value aren't supported at this time.
    // Defining these as private make sure that they can't be called.
    //
    NlbIpAddressList(const NlbIpAddressList&);
    NlbIpAddressList& operator = (const NlbIpAddressList&);

    static
    BOOL
    sfn_validate_info(
        const NLB_IP_ADDRESS_INFO &Info,
        UINT &uIpAddress
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\makefile.inc ===
$(O)\nlbmprov.mof : nlbmprov.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\eventlog.h ===
#include "log_msgs.h"

#define NLBUPD_MAX_EVENTLOG_ARG_LEN         32000

// 4294967295 = 10 characters. Add 1 for NULL terminator.
#define NLBUPD_MAX_NUM_CHAR_UINT_AS_DECIMAL  11

// 0xffffffff = 10 characters. Add 1 for NULL terminator.
#define NLBUPD_NUM_CHAR_WBEMSTATUS_AS_HEX   11

extern HANDLE g_hEventLog;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#undef UNICODE
#undef _UNICODE

#include "private.h"
#include "nlbsnic.h"
#include "maindll.tmh"

void __stdcall InitializeTraceing(void);
void __stdcall DeinitializeTraceing(void);

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{4c97e0a8-c5ea-40fd-960d-7d6c987be0a6}";
CLSID CLSID_NLBSNIC;

extern BOOL g_UpdateConfigurationEnabled;

HANDLE g_hEventLog = NULL;  // Handle for the local event log 

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

    CLSIDFromString(GUIDSTRING, &CLSID_NLBSNIC);
    if (CLSID_NLBSNIC!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    if (   CWbemProviderGlue::FrameworkLogoffDLL(L"NLBSNIC")
        && NlbConfigurationUpdate::CanUnloadNow())
    {
        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
    }
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "";
    char * pModel;
    HKEY hKey1, hKey2;

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

    if(g_UpdateConfigurationEnabled && Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    CLSIDFromString(GUIDSTRING, &CLSID_NLBSNIC);
    StringFromGUID2(CLSID_NLBSNIC, wcID, ASIZE(wcID));
    wcstombs(szID, wcID, sizeof(szID));
    (void) StringCbCopy(szCLSID, sizeof(szCLSID), TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    (void) StringCbCat(szCLSID, sizeof(szCLSID), szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    CLSIDFromString(GUIDSTRING, &CLSID_NLBSNIC);
    StringFromGUID2(CLSID_NLBSNIC, wcID, ASIZE(wcID));
    wcstombs(szID, wcID, sizeof(szID));
    (void) StringCbCopy(szCLSID, sizeof(szCLSID), TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    (void) StringCbCat(szCLSID, sizeof(szCLSID), szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;
    
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:

    // TO DO: Consider adding DisableThreadLibraryCalls().

         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"NLBSNIC");

            if (bRet)
            {
                //
                // Enable WMI event tracing
                //
                WPP_INIT_TRACING(L"Microsoft\\NLB\\NLBMPROV");

                //
                // Initialize for event logging
                //
                g_hEventLog = RegisterEventSourceW(NULL, CVY_NAME);
            }


            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
            // Perform any necessary cleanup.
            MyNlbsNicSet.DelayedDeinitialize();

            //
            // Disable WMI event tracing
            //
            WPP_CLEANUP();

            //
            // Close handle to the event log
            //
            if (g_hEventLog != NULL)
            {
                (void) DeregisterEventSource(g_hEventLog);
                g_hEventLog = NULL;
            }

            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\nlbmprov.h ===
/*++

Copyright(c) 2001-2002  Microsoft Corporation

Module Name:

    nlbmprov.h

Abstract:

    NLB Manager provider - resource IDs

Author:

    karthicn, Dec 12, 2001

--*/

// Resource IDs used in logging messages to the registry

#define    IDS_PROCESING_UPDATE               200  
#define    IDS_ERROR_READING_CONFIG           201
#define    IDS_MEM_ALLOC_FAILURE              202
#define    IDS_CRIT_INTERNAL_ERROR            203
#define    IDS_ERROR_GETTING_IP               204
#define    IDS_NLB_NOT_INSTALLED              205
#define    IDS_ERROR_FINDING_NLB              206
#define    IDS_NEW_PARAMS_INCORRECT           207
#define    IDS_UNBINDING_NLB                  208
#define    IDS_UNBIND_FAILED                  209
#define    IDS_UNBIND_SUCCEEDED               210
#define    IDS_BINDING_NLB                    211
#define    IDS_BIND_FAILED                    212
#define    IDS_BIND_SUCCEEDED                 213
#define    IDS_CLUSTER_CONFIG_STABLE          214
#define    IDS_MODIFY_CLUSTER_CONFIG          215
#define    IDS_MODIFY_FAILED                  216
#define    IDS_MODIFY_SUCCEEDED               217
#define    IDS_MODIFYING_IP_ADDR              218
#define    IDS_MODIFY_IP_ADDR_FAILED          219
#define    IDS_MODIFY_IP_ADDR_SUCCEEDED       220
#define    IDS_UPDATE_FAILED                  221
#define    IDS_UPDATE_SUCCEEDED               222
#define    IDS_STOPPING_CLUSTER               223
#define    IDS_STOP_FAILED                    224
#define    IDS_STOP_SUCCEEDED                 225
#define    IDS_REMOVING_CLUSTER_IPS           226
#define    IDS_REMOVING_STATIC_IPS            227
#define    IDS_REMOVE_IP_FAILED               228
#define    IDS_REMOVE_IP_SUCCEEDED            229
#define    IDS_RR_OUT_OF_SYSTEM_RES           230
#define    IDS_RR_UNDERLYING_COM_FAILED       231
#define    IDS_RR_INIT_FAILURE                232
#define    IDS_RR_INVALID_CLUSTER_SPEC        233
#define    IDS_RR_INTERNAL_ERROR              234
#define    IDS_STARTING_UPDATE                235
#define    IDS_NETCFG_WRITELOCK_TAKEN         236
#define    IDS_NETCFG_WRITELOCK_CANTTAKE      237
#define    IDS_OTHER_UPDATE_ONGOING           238
#define    IDS_CRITICAL_RESOURCE_FAILURE      239
#define    IDS_UPDATE_NO_CHANGE               240
#define    IDS_OTHER_UPDATE_ONGOING2          241
#define    IDS_MSCS_INSTALLED                 242
#define    IDS_NLB_MGR_SHORT_CUT_STRING       243
#define    IDS_NLB_MGR_SHORT_CUT_INFO_TIP     244
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\private.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager provider test harness

File Name:

    private.h

Abstract:

    Internal headers


History:

    04/08/01    JosephJ Created

--*/

// #include "windows.h"
// #include <ntddk.h>


//
// Preceed parameters passed by reference by this...
//
#define REF

#include <FWcommon.h>
#include <assert.h>
#include <objbase.h>
#include <initguid.h>
#include <strsafe.h>
#include "wlbsconfig.h"
#include "myntrtl.h"
#include "wlbsparm.h"
#include <wlbsiocl.h>
#include <nlberr.h>
#include <cfgutil.h>
#include "updatecfg.h"
#include "eventlog.h"

//
// Debugging stuff...
//
extern BOOL g_DoBreaks;
#define MyBreak(_str) ((g_DoBreaks) ? (OutputDebugString(_str),DebugBreak(),1):0)


#define ASSERT assert


#define ASIZE(_array) (sizeof(_array)/sizeof(_array[0]))

//
// Use this to copy to an array (not pointer) destination 
//
#define ARRAYSTRCPY(_dest, _src) \
            StringCbCopy((_dest), sizeof(_dest), (_src))

#define ARRAYSTRCAT(_dest, _src) \
            StringCbCat((_dest), sizeof(_dest), (_src))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\nlbsnic.h ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   NlbsNic.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   History: Mar to Nov 2001 JosephJ re-implemented from scratch

*******************************************************************/

// Property set identification
//============================

#ifndef _NlbsNic_H_
#define _NlbsNic_H_

#define PROVIDER_NAME_NLBSNIC L"NlbsNic"

using namespace std;

class CNlbsNic : public Provider 
{
    public:
    

        // Constructor/destructor
        //=======================

        CNlbsNic(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CNlbsNic();

        BOOL DelayedInitialize(VOID);
        VOID DelayedDeinitialize(VOID);


    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

private:

    CRITICAL_SECTION    m_Lock;

    VOID mfn_Lock(VOID)     {EnterCriticalSection(&m_Lock);}
    VOID mfn_Unlock(VOID)   {LeaveCriticalSection(&m_Lock);}
    BOOL mfn_IsCallerAdmin(VOID); 

    BOOL m_fDelayedInitializationComplete;

};

extern CNlbsNic MyNlbsNicSet;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\nlbsnic.cpp ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   NlbsNic.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : Added password support.
//
// Revised by : mhakim
// Date       : 02-16-01
// Reason     : Added friendly name support.
//
// Reason     : filling out version info.  This was being not 
//              done previously in GetObject.

#include <fwcommon.h>  // This must be the first include.
#include "private.h"
#include <winsock2.h>
#include "wlbsutil.h"
#include "nlbsnic.h"
#include "nlbsnic.tmh"

// using namespace std;
// MUsingCom   com;

BOOL g_UpdateConfigurationEnabled = TRUE;

WBEMSTATUS
ProvExecStaticMethod(
           const BSTR bstrMethodName,
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvGetCompatibleAdapterGuids(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvGetClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvUpdateClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvQueryConfigurationUpdateStatus(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvControlCluster(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvGetClusterMembers(
           CInstance *pInParams,
           CInstance *pOutParams
           );

WBEMSTATUS
ProvRegisterManagementApplication(
           CInstance *pInParams,
           CInstance *pOutParams
           );
WBEMSTATUS
ProvUnregisterManagementApplication(
           CInstance *pInParams,
           CInstance *pOutParams
           );


// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
// DONE : mhakim
//===================================================================
CNlbsNic MyNlbsNicSet (PROVIDER_NAME_NLBSNIC, L"root\\microsoftnlb") ;

// Property names
//===============
const static WCHAR* cszAdapterGuid = L"AdapterGuid" ;
const static WCHAR* pDependent = L"Dependent" ;
const static WCHAR* pFriendlyName = L"FriendlyName" ;
const static WCHAR* pFullName = L"FullName" ;
const static WCHAR* pVersion = L"Version" ;

/*****************************************************************************
 *
 *  FUNCTION    :   CNlbsNic::CNlbsNic
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CNlbsNic::CNlbsNic (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
        Provider(lpwszName, lpwszNameSpace),
        m_fDelayedInitializationComplete(FALSE)
{
    HRESULT hr;

    InitializeCriticalSection(&m_Lock);

    //
    // Static Initialization of the NlbConfigurationUpdate class.
    //
    NlbConfigurationUpdate::StaticInitialize();

}

/*****************************************************************************
 *
 *  FUNCTION    :   CNlbsNic::~CNlbsNic
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CNlbsNic::~CNlbsNic ()
{
    // this->DelayedDeinitialize();

    //
    // Static Deinitialization the NlbConfigurationUpdate class.
    //
    NlbConfigurationUpdate::StaticDeinitialize();

    DeleteCriticalSection(&m_Lock);
}


BOOL
CNlbsNic::DelayedInitialize(VOID)
{
    BOOL fRet = FALSE;

    mfn_Lock();


    if (m_fDelayedInitializationComplete == FALSE)
    {
        WBEMSTATUS Status;
        Status =  CfgUtilInitialize(
                        TRUE,   // TRUE == server
                        TRUE    // TRUE == don't use ping
                        );
        if (!FAILED(Status))
        {
            m_fDelayedInitializationComplete = TRUE;
        }
    }

    fRet = m_fDelayedInitializationComplete;

    mfn_Unlock();

    return fRet;
}


VOID
CNlbsNic::DelayedDeinitialize(VOID)
{
    mfn_Lock();


    if (m_fDelayedInitializationComplete)
    {
        //
        // Prepare NlbConfigurationUpdate for deinitialization.
        //
        NlbConfigurationUpdate::PrepareForDeinitialization();

        //
        // Deinitialize the configuration utilities
        //
        CfgUtilDeitialize();

    
        m_fDelayedInitializationComplete = FALSE;
    }

    mfn_Unlock();

    return;
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must 
*                       be filled in.  If there are no instances, return 
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*                DONE: mhakim
*
*****************************************************************************/
HRESULT CNlbsNic::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/
HRESULT CNlbsNic::GetObject ( CInstance* pInstance, long lFlags )
{
    return WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CNlbsNic::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    : CNlbsNic::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CNlbsNic::PutInstance ( const CInstance &Instance, long lFlags)
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CNlbsNic::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    // Use the CInstance Get functions (for example, call 
    // GetCHString(L"Name", sTemp)) against Instance to see the key values 
    // the client requested.

    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}

BOOL g_Impersonate = TRUE;

/*****************************************************************************
*
*  FUNCTION    :    CNlbsNic::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CNlbsNic::ExecMethod ( const CInstance& Instance,
                               const BSTR bstrMethodName,
                               CInstance *pInParams,
                               CInstance *pOutParams,
                               long lFlags)
{
    // For non-static methods, use the CInstance Get functions (for example, 
    // call GetCHString(L"Name", sTemp)) against Instance to see the key 
    // values the client requested.
    HRESULT hresult = WBEM_E_PROVIDER_NOT_CAPABLE;
    BOOL    fImpersonating = FALSE;

    TRACE_INFO("-> %!FUNC!  Method Name : %ls", bstrMethodName);

    if (!DelayedInitialize())
    {
        TRACE_CRIT("%!FUNC! -- delayed initialization failed!");
        goto end;
    }


    //
    // The NLB Manager provider runs under the context of "NetworkServiceHost" and hence
    // may NOT have sufficient privileges to perform sensitive operations (like binding/
    // unbinding NLB). So, we impersonate the client in order to use the client's (potentially
    // higher) credentials to perform such operations.
    //

    hresult = CoImpersonateClient();

    // 2/13/02 JosephJ SECURITY BUGBUG: is this check for RPC_E_CALL_COMPLETE
    // ok?
    if (hresult != S_OK && hresult != RPC_E_CALL_COMPLETE)
    {
        TRACE_CRIT("%!FUNC! ERROR: CoImpersonateClient returns 0x%08lx", (UINT) hresult);
        goto end;
    }

    fImpersonating = TRUE;

    // Adding this assert since we are not sure if RPC_E_CALL_COMPLETE
    // could be a legitimate error. - KarthicN, 4/12/02.
    ASSERT(hresult != RPC_E_CALL_COMPLETE);

    // Check if caller is an administrator?
    if (mfn_IsCallerAdmin() == FALSE) 
    {
        TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, returning WBEM_E_ACCESS_DENIED");
        hresult= WBEM_E_ACCESS_DENIED;
        goto end;
    }

    if (!g_Impersonate)
    {
        // Revert to using server credentials
        CoRevertToSelf();
        fImpersonating = FALSE;
    }

    hresult = ProvExecStaticMethod(bstrMethodName, pInParams, pOutParams);


end:

    if (fImpersonating)
    {
        CoRevertToSelf();
    }

    TRACE_INFO("<- %!FUNC! return : 0x%08lx", (UINT)hresult);

    return hresult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Name        : IsCallerAdmin
// Description : This function checks if the caller is a member of the 
//               Administrators local group. Since the provider is acting on
//               behalf of the client, it is important to IMPERSONATE the client
//               BEFORE calling this function. Impersonating the client will ensure
//               that this function checks if the client (& NOT this process that 
//               runs under the identity of NetworkServiceHost) is a member of 
//               the Administrators local group.
// Arguments   : None. 
// Return Value: 
//   TRUE - Caller is a member of Administrators local group. 
//   FALSE - Caller is NOT a member of Administrators local group. 
////////////////////////////////////////////////////////////////////////////////
BOOL CNlbsNic::mfn_IsCallerAdmin(VOID) 
{
    BOOL bRet;
    PSID AdministratorsGroup; 
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    TRACE_VERB(L"->%!FUNC!");

    //
    // Allocate and Initialize SID for Administrators in the built-in system domain 
    //
    bRet = AllocateAndInitializeSid(&NtAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID, // The built-in system domain (S-1-5-32)
                                 DOMAIN_ALIAS_RID_ADMINS,     // Local group used for administration of the domain
                                 0, 0, 0, 0, 0, 0,
                                 &AdministratorsGroup); 
    if(bRet) 
    {
        //
        // Is SID enabled in the impersonation token of the calling thread ?
        //
        if (!CheckTokenMembership(NULL, // Use the Impersonation token of the calling thread
                                  AdministratorsGroup, 
                                  &bRet)) 
        {
            bRet = FALSE;
            TRACE_CRIT(L"%!FUNC! CheckTokenMembership() failed. Error : 0x%x", GetLastError()); 
        } 
        FreeSid(AdministratorsGroup); 
    }
    else
    {
        TRACE_CRIT("%!FUNC! AllocateAndInitializeSid() failed. Error : 0x%x", GetLastError()); 
    }

    TRACE_VERB(L"<-%!FUNC! Returning %ls", bRet ? L"TRUE" : L"FALSE");
    return bRet;
}


////////////////////////////////////////////////////////////////////////////////
//
// Check_Load_Unload_Driver_Privilege
//
// Purpose: This function checks if the SE_LOAD_DRIVER_NAME (= "SeLoadDriverPrivilege")
//          is enabled in the impersonation access token. If there is no impersonation 
//          access token and if the global impersonation flag is set to false (used for
//          debug purposes), then we check the primary access token.
//
////////////////////////////////////////////////////////////////////////////////

BOOL Check_Load_Unload_Driver_Privilege() 
{
    PRIVILEGE_SET   PrivilegeSet;
    DWORD  dwError;
    LUID   Luid;
    BOOL   bResult = FALSE;
    HANDLE TokenHandle = NULL;

    TRACE_INFO("->%!FUNC!");

    // Look up the LUID for "SeLoadDriverPrivilege"
    if (!LookupPrivilegeValue(NULL,                // lookup privilege on local system
                              SE_LOAD_DRIVER_NAME, // "SeLoadDriverPrivilege" : Load and unload device drivers
                              &Luid))              // receives LUID of privilege
    {
        TRACE_CRIT("%!FUNC! LookupPrivilegeValue error: %u", GetLastError()); 
        TRACE_INFO("<-%!FUNC! Returning FALSE");
        return FALSE; 
    }

    //
    // Get a handle to the impersonation access token with TOKEN_QUERY right.
    //
    // Note: If this thread is NOT impersonating, then, the following call
    //       will fail with ERROR_NO_TOKEN.
    //
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY, 
                         FALSE, // Use the credentials of the client that is being impersonated
                         &TokenHandle))
    {
        dwError = GetLastError();

        //
        // We were unable to open the impersonation access token. If it is because it doesn't 
        // exist and if the "g_Impersonate" flag is set to FALSE , then try to open the primary 
        // access token.
        // This blob is mainly to handle the case where we are intentionally NOT
        // impersonating by setting the "g_Impersonate" to FALSE. This flag was introduced 
        // mainly to easily switch between impersonating and not impersonating for debugging
        // purposes. This was needed due to the problems that we encountered when impersonating 
        // + using "NetworkServiceHost".
        // --KarthicN, May 6, 2002.
        //
        if ((dwError == ERROR_NO_TOKEN) && (g_Impersonate == FALSE)) 
        {
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_QUERY, 
                                  &TokenHandle))
            {
                TRACE_CRIT("%!FUNC! OpenProcessToken error: %u", GetLastError()); 
                TRACE_INFO("<-%!FUNC! Returning FALSE");
                return FALSE; 
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! OpenThreadToken error: %u, Global Impersonation flag = %ls", dwError, g_Impersonate ? L"TRUE" : L"FALSE"); 
            TRACE_INFO("<-%!FUNC! Returning FALSE");
            return FALSE; 
        }
    }

    PrivilegeSet.PrivilegeCount = 1;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = Luid;
    PrivilegeSet.Privilege[0].Attributes = 0;

    if (!PrivilegeCheck(TokenHandle, &PrivilegeSet, &bResult)) 
    {
        bResult = FALSE;
        TRACE_CRIT("%!FUNC! PrivilegeCheck error: %u", GetLastError()); 
    }

    CloseHandle(TokenHandle);

    TRACE_INFO(L"<-%!FUNC! Returning %ls", bResult ? L"TRUE" : L"FALSE");
    return bResult;
}


WBEMSTATUS
ProvExecStaticMethod(
           const BSTR bstrMethodName,
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*
    If bstrMethodName is one of the recognized static methods, we execute
    the method. Otherwise we return WBEM_E_PROVIDER_NOT_CAPABLE
*/
{
    WBEMSTATUS Status = WBEM_E_PROVIDER_NOT_CAPABLE;

    if (!g_UpdateConfigurationEnabled)
    {
        goto end;
    }

    if (_wcsicmp(bstrMethodName, L"GetCompatibleAdapterGuids") == 0)
    {
        Status = ProvGetCompatibleAdapterGuids(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"GetClusterConfiguration") == 0)
    {
        Status = ProvGetClusterConfiguration(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"UpdateClusterConfiguration") == 0)
    {
        //
        // NOTE:
        // One of the functions of this method is to bind/unbind NLB to the network adapter. Since this operation involves unloading 
        // and loading of the device driver, PnP apis (that are called), attempt to enable the "SeLoadDriverPrivilege" 
        // privilege in the impersonation access token. Enabling a privilege is successful only when the privilege is present, 
        // in the first place to be enabled. When the wmi client and wmi provider are in the same machine, it was observed that 
        // the "SeLoadDriverPrivilege" privilege was NOT event present in the impersonation access token of the server. This is 
        // because, only the enabled privileges of the client are passed along to the server. 
        // So, we now require that the client enable the "SeLoadDriverPrivilege" privilege in its access token before calling 
        // this method. The following call to Check_Load_Unload_Driver_Privilege() checks if "SeLoadDriverPrivilege" privilege 
        // is enabled in the impersonation access token (except if "g_Impersonate" is false). Although the PnP apis only 
        // require that this privilege be present, we have decided to elevate the requirement to this privilege being present 
        // AND enabled. This is because, if the privilege is NOT enabled, the operation to enable it may or may not succeed 
        // depending on the client's credentials. 
        // --KarthicN, May 6, 2002.
        //
        if(!Check_Load_Unload_Driver_Privilege())
        {
            TRACE_CRIT("%!FUNC! Check_Load_Unload_Driver_Privilege() failed, Returning WBEM_E_ACCESS_DENIED !!!");
            Status = WBEM_E_ACCESS_DENIED;
            goto end;
        }

        Status = ProvUpdateClusterConfiguration(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"QueryConfigurationUpdateStatus") == 0)
    {
        Status = ProvQueryConfigurationUpdateStatus(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"ControlCluster") == 0)
    {
        Status = ProvControlCluster(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"GetClusterMembers") == 0)
    {
        Status = ProvGetClusterMembers(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"RegisterManagementApplication") == 0)
    {
        Status = ProvRegisterManagementApplication(
                       pInParams,
                       pOutParams
                       );
    }
    else if (_wcsicmp(bstrMethodName, L"UnregisterManagementApplication") == 0)
    {
        Status = ProvUnregisterManagementApplication(
                       pInParams,
                       pOutParams
                       );
    }
end:

    return Status;
}


WBEMSTATUS
ProvGetCompatibleAdapterGuids(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    Implementation  of the "GetCompatibleAdapterGuids" method.

--*/
{

    LPWSTR *pszNics = NULL;
    UINT   NumNics = 0;
    UINT   NumNlbBound = 0;
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;

    /*
        [OUT] String  AdapterGuids[], // "{......}"
        [OUT] uint32  NumBoundToNlb
    */

    TRACE_VERB(L"->%!FUNC!");

    Status =  CfgUtilsGetNlbCompatibleNics(&pszNics, &NumNics, &NumNlbBound);

    if (FAILED(Status))
    {
        TRACE_CRIT("CfgUtilsGetNlbCompatibleNics returns error 0x%08lx",
                    (UINT) Status);
        pszNics = NULL;
        goto end;
    }


    //
    // Fill in AdapterGuids[]
    //
    {
        SAFEARRAY   *pSA = NULL;
        Status = CfgUtilSafeArrayFromStrings(
                    (LPCWSTR*) pszNics,
                    NumNics,
                    &pSA
                    );
        if (FAILED(Status))
        {
            pSA = NULL;
            goto end;
        }

        pOutParams->SetStringArray(
                L"AdapterGuids",
                *pSA // pass by reference
                );
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }
    pOutParams->SetDWORD(L"NumBoundToNlb", NumNlbBound);
    Status  = WBEM_NO_ERROR;


end:

    pOutParams->SetDWORD(L"ReturnValue", (DWORD) Status);

    if (pszNics != NULL)
    {
        delete pszNics;
        pszNics = NULL;
    }

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return WBEM_NO_ERROR; // real status is in the "ReturnResult" outparm.

}


WBEMSTATUS
ProvGetClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around  NlbConfigurationUpdate::GetConfiguration

--*/
{
    LPCWSTR pAdapterGuid = NULL;
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;
    CHString     sTemp;
    bool         fRet;
    NLB_EXTENDED_CLUSTER_CONFIGURATION Cfg;
    SAFEARRAY   *pSA = NULL;
    bool        fNicNotFound = FALSE;

    /*
        [IN]  String  AdapterGuid,
        [OUT] uint32  Generation,
        [OUT] String  NetworkAddresses[], // "10.1.1.1/255.0.0.0"
        [OUT] Boolean NLBBound,
        [OUT] Boolean DHCPEnabled,
        [OUT] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
        [OUT] String  ClusterName,
        [OUT] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
        [OUT] String  PortRules[],
        [OUT] uint32  HostPriority,
        [OUT] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
        [OUT] uint32  ClusterModeOnStart,      // 0 : STOPPED, 1 : STARTED, 2 : SUSPENDED
        [OUT] Boolean PersistSuspendOnReboot,
        [OUT] Boolean RemoteControlEnabled,
        [OUT] uint32  HashedRemoteControlPassword
    */

    fRet = pInParams->GetCHString( L"AdapterGuid", sTemp );
    if (!fRet)
    {
        TRACE_CRIT("->%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
    // buffer -- see operator LPCWSTR() of WString docs.
    //
    pAdapterGuid = (LPCWSTR) sTemp;

    if (pAdapterGuid == NULL || *pAdapterGuid == 0)
    {
        TRACE_CRIT("->%!FUNC!: Null of empty adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {

        TRACE_VERB(L"->%!FUNC!(Nic=%ws)", pAdapterGuid);
    }

    Status = NlbConfigurationUpdate::GetConfiguration(
                pAdapterGuid,
                &Cfg
                );

    if (FAILED(Status))
    {
       if (Status == WBEM_E_NOT_FOUND)
       {
            fNicNotFound = TRUE;
       }
       goto end;
    }

    pOutParams->SetDWORD(L"Generation", Cfg.GetGeneration());

    //
    // Fill in NetworkAddresses[]
    //
    {
        Status = Cfg.GetNetworkAddressesSafeArray(
                        &pSA
                        );
        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: couldn't extract network addresses from Cfg"
                " for NIC %ws",
                pAdapterGuid
                );
            pSA = NULL;
            goto end;
        }
        

        if (pSA!=NULL)
        {
            pOutParams->SetStringArray(
                    L"NetworkAddresses",
                    *pSA // pass by reference
                    );
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }

    //
    // Adapter Friendly Name
    //
    {
        LPWSTR szFriendlyName = NULL;
        Status = Cfg.GetFriendlyName(&szFriendlyName);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract adapter friendly name for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"FriendlyName", szFriendlyName);
        delete (szFriendlyName);
        szFriendlyName = NULL;
    }

    //
    // Set dhcp state
    //
    pOutParams->Setbool(L"DHCPEnabled", Cfg.fDHCP);

    if (!Cfg.IsNlbBound())
    {
        //
        // NLB is not bound
        //

        pOutParams->Setbool(L"NLBBound", FALSE);
        Status = WBEM_NO_ERROR;
        goto end;
    }

    //
    // NLB is bound
    //

    pOutParams->Setbool(L"NLBBound", TRUE);

    if (!Cfg.IsValidNlbConfig())
    {
        TRACE_CRIT(
            "%!FUNC!: NLB-specific configuration on NIC %ws is invalid",
            pAdapterGuid
            );
        goto end;
    }

    //
    // Cluster name
    //
    {
        LPWSTR szName = NULL;
        Status = Cfg.GetClusterName(&szName);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract cluster name for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"ClusterName", szName);
        delete (szName);
        szName = NULL;
    }
    
    //
    // Cluster and dedicated network addresses
    //
    {
        LPWSTR szAddress = NULL;
        Status = Cfg.GetClusterNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract cluster address for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"ClusterNetworkAddress", szAddress);
        delete (szAddress);
        szAddress = NULL;

        Status = Cfg.GetDedicatedNetworkAddress(&szAddress);

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: Could not extract dedicated address for NIC %ws",
                pAdapterGuid
                );
            goto end;
        }
        pOutParams->SetCHString(L"DedicatedNetworkAddress", szAddress);
        delete (szAddress);
        szAddress = NULL;
    }

    //
    // TrafficMode
    //
    {
        LPCWSTR szMode = NULL;
        switch(Cfg.GetTrafficMode())
        {
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST:
            szMode = L"UNICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST:
            szMode = L"MULTICAST";
            break;
        case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST:
            szMode = L"IGMPMULTICAST";
            break;
        default:
            assert(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        pOutParams->SetCHString(L"TrafficMode", szMode);
    }

    pOutParams->SetDWORD(L"HostPriority", Cfg.GetHostPriority());

    /*
    if (Cfg.GetClusterModeOnStart() ==
        NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED)
    {
        pOutParams->Setbool(L"ClusterModeOnStart", TRUE);
    }
    else
    {
        pOutParams->Setbool(L"ClusterModeOnStart", FALSE);
    }
    */

    pOutParams->SetDWORD(L"ClusterModeOnStart", Cfg.GetClusterModeOnStart());

    pOutParams->Setbool(L"PersistSuspendOnReboot", Cfg.GetPersistSuspendOnReboot());

    pOutParams->Setbool(L"RemoteControlEnabled", Cfg.GetRemoteControlEnabled());
    pOutParams->SetDWORD(
                    L"HashedRemoteControlPassword",
                    CfgUtilGetHashedRemoteControlPassword(&Cfg.NlbParams)
                    );
    

    //
    // [OUT] String  PortRules[],
    //
    {

        LPWSTR *pszPortRules = NULL;
        UINT NumPortRules = 0;
        pSA=NULL;
    
        Status = Cfg.GetPortRules(
                        &pszPortRules,
                        &NumPortRules
                        );
        if (FAILED(Status))
        {
            pszPortRules = NULL;
            goto end;
        }
    
        Status = CfgUtilSafeArrayFromStrings(
                    (LPCWSTR*) pszPortRules,
                    NumPortRules, // can be zero
                    &pSA
                    );

        if (FAILED(Status))
        {
            TRACE_CRIT(
                "%!FUNC!: couldn't extract port rules from Cfg"
                " for NIC %ws",
                pAdapterGuid
                );
            pSA = NULL;
            goto end;
        }

        if (pSA!=NULL)
        {
            pOutParams->SetStringArray(
                    L"PortRules",
                    *pSA // pass by reference
                    );
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }
    

    Status = WBEM_NO_ERROR;

end:

    if (FAILED(Status))
    {
        //
        // We want to reserve WBEM_NOT_FOUND for the SPECIFIC case
        // of the NIC not being found
        //
        if (Status == WBEM_E_NOT_FOUND && !fNicNotFound)
        {
            Status = WBEM_E_FAILED;
        }

        pOutParams->SetDWORD(L"ReturnValue", (DWORD) Status);

    }
    else
    {
        pOutParams->SetDWORD(L"ReturnValue", (DWORD) WBEM_NO_ERROR);
    }


    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return WBEM_NO_ERROR;

}


WBEMSTATUS
ProvUpdateClusterConfiguration(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper NlbConfigurationUpdate::UpdateConfiguration
    with some additional wrinkles:
    we selectively update the current version.

--*/
{
    LPCWSTR pAdapterGuid = NULL;
    LPCWSTR pClientDescription = L"Unspecified WMI Client"; // TODO: localize
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;
    CHString     sClientDescription;
    CHString     sAdapterGuid;
    CHString     sTemp;
    bool         fRet;
    NLB_EXTENDED_CLUSTER_CONFIGURATION Cfg;
    SAFEARRAY   *pSA = NULL;

    /*
        [IN] String  ClientDescription,
        [IN] String  AdapterGuid,
        [IN] uint32  Generation,
        [IN] Boolean PartialUpdate,
        [IN] String  NetworkAddresses[], // "10.1.1.1/255.255.255.255"
        [IN] Boolean NLBBound,
        [IN] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
        [IN] String  ClusterName,
        [IN] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
        [IN] String  PortRules[],
        [IN] uint32  HostPriority,
        [IN] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
        [IN] uint32  ClusterModeOnStart,      // 0 : STOPPED, 1 : STARTED, 2 : SUSPENDED
        [IN] Boolean PersistSuspendOnReboot,
        [IN] Boolean RemoteControlEnabled,
        [IN] String  Password,
        [OUT] uint32 NewGeneration,
        [OUT] String Log
    */

    fRet = pInParams->GetCHString( L"ClientDescription", sClientDescription);
    if (fRet)
    {
        // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
        pClientDescription = (LPCWSTR) sClientDescription;
    }

    fRet = pInParams->GetCHString( L"AdapterGuid", sAdapterGuid);
    if (!fRet)
    {
        TRACE_CRIT("->%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
    // buffer -- see operator LPCWSTR() of WString docs.
    //
    pAdapterGuid = (LPCWSTR) sAdapterGuid;

    if (pAdapterGuid == NULL || *pAdapterGuid == 0)
    {
        TRACE_CRIT("->%!FUNC!: Null of empty adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        TRACE_VERB(L"->%!FUNC!(Nic=%ws)", pAdapterGuid);
    }

    //
    // Get the current configuration
    //
    Status = NlbConfigurationUpdate::GetConfiguration(
                pAdapterGuid,
                &Cfg
                );

    if (FAILED(Status))
    {
       goto end; 
    }


    //
    // Modify the snapshot of the current configuration with whatever
    // cluster configuration information is specified in the input
    // parameters
    //
    {
        DWORD       InGeneration    = 0;
        bool        NlbBound        = FALSE;
        bool        bResult         = FALSE;
        bool        bPartialUpdate  = FALSE;
        bool        bCheckForAddressConflicts = FALSE;
    
        //
        // Determine if this is a partial or full update.
        // If partial update, we allow a subset of cluster configuration
        // parameters to be specified, but allow only a restricted set
        // of update operations.
        //
        // Disallowed partial update operations:
        //  - Transitions between bound and !bound 
        //  - Currently bound  but nlb parameters are invalid
        //
        // Some allowed partial updates:
        //  - Modifying IP address lists
        //  - Modifying cluster / dedicated addresses/subnets
        //  - Modifying existing portrules
        //  - Adding/deleting port rules
        //

        bResult = pInParams->GetDWORD(
                    L"Generation",      // <--------------------------------
                    InGeneration
                    );
        if (!bResult)
        {
            //
            // We allow generation to be unspecified.
            //
            InGeneration = 0;
        }
        else
        {
            //
            // If generation is specified,
            // we verify that the current generation matches the
            // specified generation.
            // TODO: this really must be done in the context of
            // mfn_Start update -- after we've acquired the global lock!
            //
            if (InGeneration != Cfg.GetGeneration())
            {
                    TRACE_CRIT("Partial update: input generation(%lu) != current generation(%lu)", InGeneration, Cfg.GetGeneration());
                    Status = WBEM_E_HANDLE_OUT_OF_DATE;
                    goto end;
            }
        }


        bResult = pInParams->Getbool(
                        L"CheckForAddressConflicts",    // <--------------------------------
                        bCheckForAddressConflicts
                        );
    
        if (!bResult)
        {
            TRACE_CRIT(L"Could not read CheckForAddressConflicts -- assuming FALSE\n");
            bCheckForAddressConflicts = FALSE;

        }


        bResult = pInParams->Getbool(
                        L"NLBBound",    // <--------------------------------
                        NlbBound
                        );
    
        if (!bResult)
        {
            NlbBound = Cfg.IsNlbBound();
            TRACE_CRIT(L"Could not read NLBBound -- assuming current state %d.",
                 NlbBound);
        }

        bResult = pInParams->GetStringArray(
                    L"NetworkAddresses", // <--------------------------------
                    pSA
                    );
        if (!bResult)
        {
            //
            // We set pCfg to zero addresses, which causes update to
            // use it's own defaults...
            //
            TRACE_CRIT(L"Could not read Network addresses -- using defaults");
            Status = Cfg.SetNetworkAddresses(NULL, 0);
            pSA = NULL;
        }
        else
        {
            if (pSA != NULL)
            {
                Status = Cfg.SetNetworkAddressesSafeArray(pSA);
                SafeArrayDestroy(pSA);
                pSA = NULL;
            }
        }

        if (!NlbBound)
        {
            // NLB is not to be bound -- no need to read the input params.
            Cfg.fBound = FALSE;
            Cfg.fValidNlbCfg = FALSE;
        }
        else
        {
            BOOL fNewConfig = FALSE;
            bool bAddDedicatedIp = FALSE;
            bool bAddClusterIps  = FALSE;

            if (!Cfg.fBound || Cfg.fValidNlbCfg == FALSE)
            {
                //
                // If we were previously unbound or we were bound but with
                // a bad configuration, we need to setup our
                // new cfg with good defaults
                //
                CfgUtilInitializeParams(&Cfg.NlbParams);
                Cfg.fBound = TRUE;
                Cfg.fValidNlbCfg = TRUE;
                fNewConfig = TRUE;
            }
        

            bResult = pInParams->Getbool(
                            L"AddDedicatedIp",    // <------------------------
                            bAddDedicatedIp
                            );
        
            if (!bResult)
            {
                TRACE_CRIT(L"Could not read AddDedicatedIp -- assuming TRUE\n");
                bAddDedicatedIp = TRUE;
    
            }
            Cfg.fAddDedicatedIp = (bAddDedicatedIp!=FALSE);
    
            bResult = pInParams->Getbool(
                            L"AddClusterIps",    // <-------------------------
                            bAddClusterIps
                            );
    
            if (!bResult)
            {
                TRACE_CRIT(L"Could not read AddClusterIps -- assuming TRUE\n");
                bAddClusterIps = TRUE;
    
            }
            Cfg.fAddClusterIps = (bAddClusterIps!=FALSE);
            
            bResult = pInParams->GetCHString(
                            L"ClusterNetworkAddress", // <--------------------
                            sTemp
                            );
        
            if (!bResult)
            {
                if (fNewConfig)
                {
                    //
                    // Cluster address MUST be specified for new config.
                    //
                    TRACE_CRIT(L"ERROR: Could not read Cluster IP for new config.");
                    Status =  WBEM_E_INVALID_PARAMETER;
                    goto end;
                    
                }
                TRACE_CRIT(L"Could not read Cluster IP. Keeping existing.");
            }
            else
            {
                LPCWSTR      szClusterNetworkAddress = NULL;
                szClusterNetworkAddress = (LPCWSTR) sTemp; // no copies here.
                Cfg.SetClusterNetworkAddress(szClusterNetworkAddress);
                szClusterNetworkAddress = NULL;
            }
        
            bResult = pInParams->GetCHString(
                            L"ClusterName", // <-------------------------
                            sTemp
                            );
        
            if (!bResult)
            {
                TRACE_CRIT(L"Could not read Cluster Name. Keeping existing");
            }
            else
            {
                LPCWSTR      szClusterName = NULL;
                szClusterName = (LPCWSTR) sTemp; // no copies here.
                Cfg.SetClusterName(szClusterName);
                szClusterName = NULL;
            }
        
            //
            // Traffic mode
            //
            {
                bResult = pInParams->GetCHString(
                                L"TrafficMode", // <-------------------------
                                sTemp
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read TrafficMode. Keeping existing");
                }
                else
                {
                    LPCWSTR      szTrafficMode = NULL;
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE TrafficMode
                    =  NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
                    szTrafficMode = (LPCWSTR) sTemp; // no copies here.
        
                    if (!_wcsicmp(szTrafficMode, L"UNICAST"))
                    {
                        TrafficMode =
                        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
                    }
                    else if (!_wcsicmp(szTrafficMode, L"MULTICAST"))
                    {
                        TrafficMode =
                        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST;
                    }
                    else if (!_wcsicmp(szTrafficMode, L"IGMPMULTICAST"))
                    {
                        TrafficMode =
                        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST;
                    }
                    else
                    {
                        TRACE_CRIT("Invalid TrafficMode: %ws", szTrafficMode);
                        Status =  WBEM_E_INVALID_PARAMETER;
                        goto end;
                    }

                    Cfg.SetTrafficMode(TrafficMode);
                    szTrafficMode = NULL;
                }
            }
        
            //
            //          String  PortRules[]
            //
            bResult = pInParams->GetStringArray(
                        L"PortRules", // <--------------------------------
                        pSA
                        );
            if (!bResult)
            {
                //
                // We set pCfg to zero port rules
                //
                TRACE_CRIT(L"Could not read port rules-- assuming ZERO");
                Status = Cfg.SetPortRules(NULL, 0);
                pSA = NULL;
            }
            else
            {
                if (pSA != NULL)
                {
                    LPWSTR          *pStrings=NULL;
                    UINT            NumStrings = 0;

                    Status =  CfgUtilStringsFromSafeArray(
                                    pSA,
                                    &pStrings,  // delete when done
                                    &NumStrings
                                    );
                    if (FAILED(Status))
                    {
                        pStrings=NULL;
                        TRACE_CRIT(L"Could not extract port rules");
                        goto end;
                    }
                
                    Status =  Cfg.SetPortRules(
                                    (LPCWSTR*)pStrings,
                                    NumStrings
                                    );
                
                    delete pStrings;
                    SafeArrayDestroy(pSA);
                    pSA = NULL;
                }
            }


            DWORD HostPriority = 0; 
            bResult = pInParams->GetDWORD(
                        L"HostPriority",      // <---------------------------
                        HostPriority
                        );
            if (!bResult)
            {
                TRACE_CRIT(L"Could not read HostPriority. Keeping existing");
            }
            else
            {
                Cfg.SetHostPriority(HostPriority);
            }
        
            bResult = pInParams->GetCHString(
                            L"DedicatedNetworkAddress", // <-----------------
                            sTemp
                            );
        
            if (!bResult)
            {
                TRACE_CRIT(L"Could not dedicated IP. Keeping existing");
            }
            else
            {
                LPCWSTR      szAddress = NULL;
                szAddress = (LPCWSTR) sTemp; // no copies here.
                Cfg.SetDedicatedNetworkAddress(szAddress);
                szAddress = NULL;
            }
            
            //
            // StartMode
            //
            {
                DWORD ClusterModeOnStart = FALSE;
                bResult = pInParams->GetDWORD(
                                L"ClusterModeOnStart",   // <-----------------
                                ClusterModeOnStart
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read StartMode. Keeping existing");
                }
                else
                {
                    /*
                    NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
                    ClusterModeOnStart;
                    if (StartMode)
                    {
                        ClusterModeOnStart = 
                         NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STARTED;
                    }
                    else
                    {
                        ClusterModeOnStart = 
                         NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
                    }
                    */
                    Cfg.SetClusterModeOnStart(ClusterModeOnStart);
                }
            }


            //
            // Persist Suspend on Reboot
            //
            {
                bool bPersistSuspendOnReboot;
                bResult = pInParams->Getbool(
                                L"PersistSuspendOnReboot",   // <---------------
                                bPersistSuspendOnReboot
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read PersistSuspendOnReboot. Keeping existing");
                }
                else
                {
                    Cfg.SetPersistSuspendOnReboot(bPersistSuspendOnReboot);
                }
            }

            //
            // Remote control enabled
            //
            {
                bool bRemoteControlEnabled;
                bResult = pInParams->Getbool(
                                L"RemoteControlEnabled",   // <---------------
                                bRemoteControlEnabled
                                );
            
                if (!bResult)
                {
                    TRACE_CRIT(L"Could not read RemoteControlEnabled. Keeping existing");
                }
                else
                {
                    Cfg.SetRemoteControlEnabled(bRemoteControlEnabled!=FALSE);

                    if (bRemoteControlEnabled)
                    {
                        DWORD dwPwd;
                        LPCWSTR      szPwd = NULL;
                        //
                        // Now read and set string or hashed version of password
                        // if either are specified.
                        //
                        bResult = pInParams->GetCHString(
                                L"RemoteControlPassword", // <-----------------
                                sTemp
                                );

                        if (bResult)
                        {
                            szPwd  = (LPCWSTR) sTemp; // no copies here.
                            (VOID) CfgUtilSetRemotePassword(&Cfg.NlbParams, szPwd);
                        }

                        if (szPwd == NULL)
                        {
                            //
                            // Only look for hashed pwd if the real pwd is
                            // not specified.
                            //
                            bResult = pInParams->GetDWORD(
                                    L"HashedRemoteControlPassword",   // <-----------------
                                    dwPwd
                                    );
                
                            if (bResult)
                            {          
                                CfgUtilSetHashedRemoteControlPassword(
                                    &Cfg.NlbParams,
                                    dwPwd
                                    );
                            }
                        }
                    }
                }
            }

            //
            // TODO: if PartialUpdate is specified, we need to 
            // make sure that fValidNlbCfg is already set.
            //
            Cfg.fValidNlbCfg = TRUE;
    
        } while (FALSE) ;

    }

    //
    // Call NlbConfigurationUpdate::DuUpdate to do the actual work.
    //
    UINT NewGeneration = 0;
    LPWSTR pLog = NULL;

    try
    {
    
        Status = NlbConfigurationUpdate::DoUpdate(
                    pAdapterGuid,
                    pClientDescription,
                    &Cfg,
                    &NewGeneration,
                    &pLog
                    );
    }
    catch (...)
    {
        TRACE_CRIT(L"%!FUNC! Caught exception!\n");
        ASSERT(!"Caught exception!");
        throw;
    }

    //
    // Fill out the out parameters: status new generation and log
    //
    pOutParams->SetDWORD(L"ReturnValue", (DWORD) Status);
    pOutParams->SetDWORD(L"NewGeneration", (DWORD) NewGeneration);
    if (pLog != NULL)
    {
        pOutParams->SetCHString(L"Log", pLog);
        delete pLog;
        pLog = NULL;
    }

    //
    // If we've actually called DoUpdate,
    // we always return WBEM_NO_ERROR. The return value has the
    // real result.
    //
    Status = WBEM_NO_ERROR;

end:

    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;

}


WBEMSTATUS
ProvQueryConfigurationUpdateStatus(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around NlbConfigurationUpdate::GetUpdateStatus

--*/
{
    LPCWSTR pAdapterGuid = NULL;
    WBEMSTATUS Status =  WBEM_E_PROVIDER_NOT_CAPABLE;
    CHString     sTemp;
    bool         fRet;
    DWORD       Generation = 0;

    /*
        [IN] String  AdapterGuid,
        [IN] uint32  Generation,
        [OUT] String Log
    */


    fRet = pInParams->GetCHString( L"AdapterGuid", sTemp);
    if (!fRet)
    {
        TRACE_CRIT("->%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Note: (LPCWSTR) sTemp returns an internal pointer to sTemp's char 
    // buffer -- see operator LPCWSTR() of WString docs.
    //
    pAdapterGuid = (LPCWSTR) sTemp;

    if (pAdapterGuid == NULL || *pAdapterGuid == 0)
    {
        TRACE_CRIT("->%!FUNC!: Null of empty adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        TRACE_VERB(L"->%!FUNC!(Nic=%ws)", pAdapterGuid);
    }

    fRet = pInParams->GetDWORD(
                L"Generation",      // <--------------------------------
                Generation
                );
    if (!fRet)
    {
        TRACE_CRIT("%!FUNC!: Missing generation!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Call NlbConfigurationUpdate::GetUpdateResult to do the actual work.
    //
    LPWSTR pLog = NULL;
    WBEMSTATUS CompletionStatus = WBEM_NO_ERROR;

    Status = NlbConfigurationUpdate::GetUpdateStatus(
                pAdapterGuid,
                Generation,
                FALSE,  // FALSE == Don't delete completion record
                &CompletionStatus,
                &pLog
                );

    if (!FAILED(Status))
    {
        //
        // Fill out the out parameters: status new generation and log
        //
        pOutParams->SetDWORD(L"ReturnValue", (DWORD) CompletionStatus);
        if (pLog != NULL)
        {
            pOutParams->SetCHString(L"Log", pLog);
            delete pLog;
            pLog = NULL;
        }
    }

end:

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;

}



WBEMSTATUS
ProvControlCluster(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around NlbConfigurationUpdate::ProvControlCluster

    TODO:
    Implement NlbConfigurationUpdate::ProvControlCluster,
    which should be a wrapper around around WlbsControlCluster where
    the work is actually done (WlbsControlCluster will take the
    handle to the device).

--*/
{
    LPCWSTR              szAdapterGuid, szVip;
    CHString             sAdapterGuid, sVip;
    bool                 fRet;
    DWORD                dwPort, dwRetVal, dwVip, dwHostMap, dwStatus;
    WBEMSTATUS           Status;
    WLBS_OPERATION_CODES Opcode;

    TRACE_VERB(L"->%!FUNC!");

    dwRetVal  = dwStatus = WLBS_FAILURE;
    dwHostMap = 0;
    Status    = WBEM_NO_ERROR;
    szVip     = NULL;
    dwVip     = dwPort = 0;

    // Get the Adapter GUID
    fRet = pInParams->GetCHString(L"AdapterGuid", sAdapterGuid);
    if (!fRet)
    {
        TRACE_CRIT(L"%!FUNC!: Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        szAdapterGuid = (LPCWSTR) sAdapterGuid;

        if (szAdapterGuid == NULL || *szAdapterGuid == UNICODE_NULL)
        {
            TRACE_CRIT(L"%!FUNC!: Null or empty adapter guid!");
            Status =  WBEM_E_INVALID_PARAMETER;
            goto end;
        }
    }

    // Get the operation to be performed
    DWORD dwOperation;
    fRet = pInParams->GetDWORD(L"Operation", dwOperation);
    if (!fRet)
    {
        TRACE_CRIT("%!FUNC!: Missing operation!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Opcode = (WLBS_OPERATION_CODES)dwOperation;

    // If present, get the Virtual IP Address
    fRet = pInParams->GetCHString( L"VirtualIpAddress", sVip);
    if (fRet)
    {
        szVip = (LPCWSTR) sVip;

        // Check for an empty string
        if (szVip != NULL && *szVip == UNICODE_NULL)
        {
            szVip = NULL;
        }
        
        // Check for null
        if (szVip != NULL) 
        {
            // If the VIP is "All Vip", then, fill in the numeric value 
            // directly from the macro, else use the conversion function.
            // This is 'cos INADDR_NONE, the return value of inet_addr 
            // function (called by IpAddressFromAbcdWsz) in the failure 
            // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
            if (_wcsicmp(szVip, CVY_DEF_ALL_VIP) == 0) 
            {
                dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
            }
            else 
            {
                dwVip = IpAddressFromAbcdWsz(szVip);
                if (dwVip == INADDR_NONE) 
                {
                    TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for Vip",szVip);
                    Status = WBEM_E_INVALID_PARAMETER;
                    goto end;
                }
            }
        }
    }

    // If present, Get the port number
    // The return value fRet is used in the switch statement further down, so
    // do NOT re-assign/change it
    fRet = pInParams->GetDWORD(L"Port", dwPort);

    switch(Opcode)
    {
    case WLBS_START:
    case WLBS_STOP:      
    case WLBS_DRAIN:      
    case WLBS_SUSPEND:     
    case WLBS_RESUME:       
        CfgUtilControlCluster( szAdapterGuid, Opcode, 0, 0, NULL, &dwRetVal );
        CfgUtilControlCluster( szAdapterGuid, WLBS_QUERY, 0, 0, &dwHostMap, &dwStatus );
        // Fill the out parameter: Host Map
        pOutParams->SetDWORD(L"HostMap", (DWORD) dwHostMap);
        break;

    case WLBS_PORT_ENABLE:  
    case WLBS_PORT_DISABLE:  
    case WLBS_PORT_DRAIN:     
        if ((szVip == NULL) || !fRet) 
        {
            TRACE_CRIT("%!FUNC! Virtual IP Address or Port NOT passed for port operation : 0x%x", Opcode);
            Status = WBEM_E_INVALID_PARAMETER;
            goto end;
        }
        CfgUtilControlCluster( szAdapterGuid, Opcode, dwVip, dwPort, NULL, &dwRetVal );
        CfgUtilControlCluster( szAdapterGuid, WLBS_QUERY_PORT_STATE, dwVip, dwPort, NULL, &dwStatus );
        break;

    case WLBS_QUERY:           
        CfgUtilControlCluster( szAdapterGuid, WLBS_QUERY, 0, 0, &dwHostMap, &dwStatus );
        // Fill the out parameter: Host Map
        pOutParams->SetDWORD(L"HostMap", (DWORD) dwHostMap);
        dwRetVal = WLBS_OK;
        break;

    case WLBS_QUERY_PORT_STATE:
        CfgUtilControlCluster( szAdapterGuid, WLBS_QUERY_PORT_STATE, dwVip, dwPort, NULL, &dwStatus );
        dwRetVal = WLBS_OK;
        break;

    default:
        TRACE_CRIT("%!FUNC! Invalid value (0x%x) passed for Operation",Opcode);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Fill out the out parameters: return value, cluster/port status
    //
    pOutParams->SetDWORD(L"ReturnValue", dwRetVal);
    pOutParams->SetDWORD(L"CurrentState", dwStatus);

end:

    TRACE_VERB(L"<-%!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;

}

WBEMSTATUS
ProvGetClusterMembers(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around NlbConfigurationUpdate::ProvGetClusterMembers

--*/
{    
    WBEMSTATUS              Status;
    LPCWSTR                 szAdapterGuid;
    CHString                sAdapterGuid;
    bool                    fRet;
    NLB_CLUSTER_MEMBER_INFO *pMembers = NULL;
    DWORD                   dwRetVal, dwStatus, dwNumHosts;
    LPWSTR                  *ppwszHostId            = NULL;
    LPWSTR                  *ppwszDedicatedIpAddress= NULL;
    LPWSTR                  *ppwszHostName          = NULL;

    SAFEARRAY   *pSAHostId = NULL;
    SAFEARRAY   *pSADedicatedIpAddress = NULL;
    SAFEARRAY   *pSAHostName = NULL;

    TRACE_VERB(L"->");

    dwRetVal  = dwStatus = WLBS_FAILURE;
    Status    = WBEM_NO_ERROR;

    // Get the Adapter GUID
    fRet = pInParams->GetCHString(L"AdapterGuid", sAdapterGuid);
    if (!fRet)
    {
        TRACE_CRIT(L"Missing adapter guid!");
        Status =  WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    else
    {
        szAdapterGuid = (LPCWSTR) sAdapterGuid;

        if (szAdapterGuid == NULL || *szAdapterGuid == UNICODE_NULL)
        {
            TRACE_CRIT(L"Null or empty adapter guid!");
            Status =  WBEM_E_INVALID_PARAMETER;
            goto end;
        }
    }

    dwStatus = CfgUtilGetClusterMembers(szAdapterGuid, &dwNumHosts, &pMembers);

    pOutParams->SetDWORD(L"ReturnValue", dwStatus);

    if (dwStatus != WBEM_S_NO_ERROR)
    {
        dwNumHosts = 0;
        pMembers = NULL;
        TRACE_CRIT(L"CfgUtilGetClusterMembers failed with 0x%x", dwStatus);
        goto end;
    }

    ASSERT (pMembers != NULL);

    #define MY_MAX_HOSTID_DIGITS 3
    ppwszHostId             = CfgUtilsAllocateStringArray(dwNumHosts, MY_MAX_HOSTID_DIGITS);
    ppwszDedicatedIpAddress = CfgUtilsAllocateStringArray(dwNumHosts, WLBS_MAX_CL_IP_ADDR);
    ppwszHostName           = CfgUtilsAllocateStringArray(dwNumHosts, CVY_MAX_FQDN + 1);

    if (ppwszHostId == NULL || ppwszDedicatedIpAddress == NULL || ppwszHostName == NULL)
    {
        TRACE_CRIT(L"Memory allocation failed for strings of host information");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Copy the cluster member information into the string arrays for the caller
    //
    for (int i=0; i < dwNumHosts; i++)
    {
        ASSERT (pMembers[i].HostId <= WLBS_MAX_HOSTS);

        if (pMembers[i].HostId > WLBS_MAX_HOSTS)
        {
            TRACE_CRIT(L"Illegal host id %d obatined from query to cluster", pMembers[i].HostId);
            Status = WBEM_E_FAILED;
            goto end;
        }

        _itow(pMembers[i].HostId, ppwszHostId[i], 10);

        wcsncpy(ppwszDedicatedIpAddress[i], pMembers[i].DedicatedIpAddress, WLBS_MAX_CL_IP_ADDR);
        (ppwszDedicatedIpAddress[i])[WLBS_MAX_CL_IP_ADDR - 1] = L'\0';

        wcsncpy(ppwszHostName[i], pMembers[i].HostName, CVY_MAX_FQDN + 1);
        (ppwszHostName[i])[CVY_MAX_FQDN] = L'\0';
    }    

    Status = CfgUtilSafeArrayFromStrings(
                            (LPCWSTR *) ppwszHostId,
                            dwNumHosts,
                            &pSAHostId
                            );
    if (FAILED(Status))
    {
        TRACE_CRIT(L"CfgUtilSafeArrayFromStrings for ppwszHostId failed with 0x%x", Status);
        pSAHostId = NULL;
        goto end;
    }

    Status = CfgUtilSafeArrayFromStrings(
                            (LPCWSTR *) ppwszDedicatedIpAddress,
                            dwNumHosts,
                            &pSADedicatedIpAddress
                            );
    if (FAILED(Status))
    {
        TRACE_CRIT(L"CfgUtilSafeArrayFromStrings for ppwszDedicatedIpAddress failed with 0x%x", Status);
        pSADedicatedIpAddress = NULL;
        goto end;
    }

    Status = CfgUtilSafeArrayFromStrings(
                            (LPCWSTR *) ppwszHostName,
                            dwNumHosts,
                            &pSAHostName
                            );
    if (FAILED(Status))
    {
        TRACE_CRIT(L"CfgUtilSafeArrayFromStrings for ppwszHostName failed with 0x%x", Status);
        pSAHostName = NULL;
        goto end;
    }

    if (pSAHostId != NULL)
    {
        pOutParams->SetStringArray(L"HostIds", *pSAHostId);
    }

    if (pSADedicatedIpAddress != NULL)
    {
        pOutParams->SetStringArray(L"DedicatedIpAddresses", *pSADedicatedIpAddress);
    }

    if (pSAHostName != NULL)
    {
        pOutParams->SetStringArray(L"HostNames", *pSAHostName);
    }

    //
    // Everything is cool. Reset the status in case the last call gave it some funky, non-failure value.
    //
    Status = WBEM_NO_ERROR;

end:
    if (pSAHostId != NULL)
    {
        SafeArrayDestroy(pSAHostId);
        pSAHostId = NULL;
    }

    if (pSADedicatedIpAddress != NULL)
    {
        SafeArrayDestroy(pSADedicatedIpAddress);
        pSADedicatedIpAddress = NULL;
    }

    if (pSAHostName != NULL)
    {
        SafeArrayDestroy(pSAHostName);
        pSAHostName = NULL;
    }

    if (ppwszHostId != NULL)
    {
        delete [] ppwszHostId;
        ppwszHostId = NULL;
    }

    if (ppwszDedicatedIpAddress != NULL)
    {
        delete [] ppwszDedicatedIpAddress;
        ppwszDedicatedIpAddress = NULL;
    }

    if (ppwszHostName != NULL)
    {
        delete [] ppwszHostName;
        ppwszHostName = NULL;
    }

    if (pMembers != NULL)
    {
        delete [] pMembers;
    }

    TRACE_VERB(L"<-returns 0x%08lx", (UINT) Status);

    return Status;
}


WBEMSTATUS
ProvRegisterManagementApplication(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around NlbConfigurationUpdate::ProvControlCluster

    TODO:
    Read from NLB registry location to see if a differnt GUID is already
    register -- if so fail, else set this information, else
    return failure and set the out params to the existing application
    name and company name.
    
--*/
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


WBEMSTATUS
ProvUnregisterManagementApplication(
           CInstance *pInParams,
           CInstance *pOutParams
           )
/*++

    WMI provider wrapper around NlbConfigurationUpdate::ProvControlCluster

    TODO:
    Read from NLB registry location to see if a the specified GUID is
    is registered if so remove the stuff from the registry.

--*/
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\updatecfg.cpp ===
//***************************************************************************
//
//  UPDATECFG.CPP
// 
//  Module: 
//
//  Purpose: Support for asynchronous NLB configuration updates
//           Contains the high-level code for executing and tracking the updates
//           The lower-level, NLB-specific work is implemented in 
//           CFGUTILS.CPP
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************
#include "private.h"
#include "nlbmprov.h"
#include "updatecfg.tmh"

#define NLBUPD_REG_PENDING L"PendingOperation"
#define NLBUPD_REG_COMPLETIONS L"Completions"
#define NLBUPD_MAX_LOG_LENGTH 1024 // Max length in chars of a completion log entry

//
// For debugging only -- used to cause various locations to break into
// the debugger.
//
BOOL g_DoBreaks;

//
// Static vars 
//
CRITICAL_SECTION NlbConfigurationUpdate::s_Crit;
LIST_ENTRY       NlbConfigurationUpdate::s_listCurrentUpdates;
BOOL             NlbConfigurationUpdate::s_fStaticInitialized;
BOOL             NlbConfigurationUpdate::s_fInitialized;


//
// Local utility functions.
//
WBEMSTATUS
update_cluster_config(
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg,
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfgNew
    );



VOID
CLocalLogger::Log(
    IN UINT ResourceID,
    // IN LPCWSTR FormatString,
    ...
)
{
    DWORD dwRet;
    WCHAR wszFormat[2048];
    WCHAR wszBuffer[2048];

    if (!LoadString(ghModule, ResourceID, wszFormat, ASIZE(wszFormat)-1))
    {
        TRACE_CRIT("LoadString returned 0, GetLastError() : 0x%x, Could not log message !!!", GetLastError());
        goto end;
    }

    va_list arglist;
    va_start (arglist, ResourceID);

    dwRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                          wszFormat, 
                          0, // Message Identifier - Ignored for FORMAT_MESSAGE_FROM_STRING
                          0, // Language Identifier
                          wszBuffer,
                          ASIZE(wszBuffer)-1, 
                          &arglist);
    va_end (arglist);

    if (dwRet==0)
    {
        TRACE_CRIT("FormatMessage returned error : %u, Could not log message !!!", dwRet);
        goto end;
    }

    UINT uLen = wcslen(wszBuffer)+1; // 1 for extra NULL
    if ((m_LogSize < (m_CurrentOffset+uLen)))
    {
        //
        // Not enough space -- we double the buffer + some extra
        // and copy over the old log.
        //
        UINT uNewSize =  2*m_LogSize+uLen+1024;
        WCHAR *pTmp = new WCHAR[uNewSize];

        if (pTmp == NULL)
        {
            goto end;
        }

        if (m_CurrentOffset!=0)
        {
            CopyMemory(pTmp, m_pszLog, m_CurrentOffset*sizeof(WCHAR));
            pTmp[m_CurrentOffset] = 0;
        }
        delete[] m_pszLog;
        m_pszLog = pTmp;
        m_LogSize = uNewSize;
    }

    //
    // Having made sure there is enough space, copy over the new stuff
    //
    CopyMemory(m_pszLog+m_CurrentOffset, wszBuffer, uLen*sizeof(WCHAR));
    m_CurrentOffset += (uLen-1); // -1 for ending NULL.

end:

    return;
}

VOID
NlbConfigurationUpdate::StaticInitialize(
        VOID
        )
/*++

--*/
{
    ASSERT(!s_fStaticInitialized);

    TRACE_INFO("->%!FUNC!");
    InitializeCriticalSection(&s_Crit);
    InitializeListHead(&s_listCurrentUpdates);
    s_fStaticInitialized=TRUE;
    s_fInitialized=TRUE;
    TRACE_INFO("<-%!FUNC!");
}

VOID
NlbConfigurationUpdate::StaticDeinitialize(
    VOID
    )
/*++
    Must only be called after PrepareForDeinitialization is called.
--*/
{
    TRACE_INFO("->%!FUNC!");

    ASSERT(s_fStaticInitialized);

    sfn_Lock();
    if (s_fInitialized || !IsListEmpty(&s_listCurrentUpdates))
    {
        // Shouldn't get here (this means that
        // PrepareForDeinitialization is not called first).
        //
        ASSERT(!"s_fInitialized is true or update list is not empty");
        TRACE_CRIT("!FUNC!: FATAL -- this function called prematurely!");
    }

    s_fStaticInitialized = FALSE;
    s_fInitialized = FALSE;

    sfn_Unlock();

    DeleteCriticalSection(&s_Crit);

    TRACE_INFO("<-%!FUNC!");
}


VOID
NlbConfigurationUpdate::PrepareForDeinitialization(
        VOID
        )
//
// Stop accepting new queries, wait for existing (pending) queries 
// to complete.
//
{
    TRACE_INFO("->%!FUNC!");

    //
    // Go through the list of updates, dereferencing any of them.
    //
    sfn_Lock();

    if (s_fInitialized)
    {
        TRACE_INFO("Deinitialize: Going to deref all update objects");
    
        s_fInitialized = FALSE;
    
        while (!IsListEmpty(&s_listCurrentUpdates))
        {
            LIST_ENTRY *pLink = RemoveHeadList(&s_listCurrentUpdates);
            HANDLE hThread = NULL;
            NlbConfigurationUpdate *pUpdate;
    
            pUpdate = CONTAINING_RECORD(
                        pLink,
                        NlbConfigurationUpdate,
                        m_linkUpdates
                        );
    
            hThread = pUpdate->m_hAsyncThread;
    
            if (hThread != NULL)
            {
                //
                // There is an async thread for this update object. We're going
                // to wait for it to exit. But we need to first get a duplicate
                // handle for ourself, because we're not going to be holding any
                // locks when we're doing the waiting, and we want to make sure
                // that the handle doesn't go away.
                //
                BOOL fRet;
                fRet = DuplicateHandle(
                                GetCurrentProcess(),
                                hThread,
                                GetCurrentProcess(),
                                &hThread, // overwritten with the duplicate handle
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );
                if (!fRet)
                {
                    TRACE_CRIT("Deinitialize: ERROR: couldn't duplicate handle");
                    hThread=NULL;
                }
            }
            sfn_Unlock();
    
            //
            // Wait for the async thread (if any) for this process to exit
            //
            if (hThread != NULL)
            {
                TRACE_CRIT("Deinitialize: waiting for hThread 0x%p", hThread);
                WaitForSingleObject(hThread, INFINITE);
                TRACE_CRIT("Deinitialize: done waiting for hThread 0x%p", hThread);
                CloseHandle(hThread);
            }
    
    
            TRACE_INFO(
                L"Deinitialize: Dereferencing pUpdate(Guid=%ws)",
                pUpdate->m_szNicGuid);
            pUpdate->mfn_Dereference(); // Deref ref added when adding this
                                // item to the global list.
            sfn_Lock();
        }
    }

    sfn_Unlock();

    TRACE_INFO("<-%!FUNC!");
}


BOOL
NlbConfigurationUpdate::CanUnloadNow(
        VOID
        )
{
    UINT uActiveCount = 0;

    TRACE_INFO("->%!FUNC!");

    //
    // Go through the list of updates, dereferencing any of them.
    //
    sfn_Lock();

    if (s_fInitialized)
    { 
        //
        // Walk the list and check if any updates are ongoing -- these could
        // be synchronous or async updates.
        //

        LIST_ENTRY *pLink = s_listCurrentUpdates.Flink;
        while (pLink != & s_listCurrentUpdates)
        {
            NlbConfigurationUpdate *pUpdate;
            pUpdate = CONTAINING_RECORD(
                        pLink,
                        NlbConfigurationUpdate,
                        m_linkUpdates
                        );
            if (pUpdate->m_State == ACTIVE)
            {
                uActiveCount++;
            }
            pLink = pLink->Flink;
        }

        if (uActiveCount==0)
        {
            //
            // We don't have any updates pending: we can return TRUE.
            // But we first set the can-unload flag so that no new
            // updates can be created.
            //
            // Can't do this because we can still get called after returning
            // TRUE to CanUnloadNow :-( 
            // s_fCanUnload = TRUE;
        }
    }

    sfn_Unlock();

    TRACE_INFO("<-%!FUNC!. uActiveCount=0x%lx", uActiveCount);

    return (uActiveCount==0);
}


WBEMSTATUS
NlbConfigurationUpdate::GetConfiguration(
    IN  LPCWSTR szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg // must be zero'd out
)
//
//
//
{
	
    // 2/13/02 JosephJ SECURITY BUGBUG:
    // Make sure that this function fails if user is not an admin.
    
    WBEMSTATUS Status =  WBEM_NO_ERROR;
    NlbConfigurationUpdate *pUpdate = NULL;
    BOOL  fNicNotFound = FALSE;
    TRACE_INFO(L"->%!FUNC!(Nic=%ws)", szNicGuid);


    //
    // Look for an update object for the specified NIC, creating one if 
    // required.
    //
    Status = sfn_LookupUpdate(szNicGuid, TRUE, &pUpdate); // TRUE == Create

    if (FAILED(Status))
    {
        TRACE_CRIT(
            L"DoUpdate: Error looking up update object for NIC %ws",
            szNicGuid
            );

        pUpdate = NULL;
        if (Status == WBEM_E_NOT_FOUND)            
        {
            fNicNotFound = TRUE;
        }
        goto end;
    }

    Status = pUpdate->mfn_GetCurrentClusterConfiguration(pCurrentCfg);

end:

    if (pUpdate != NULL)
    {
        //
        // Dereference the temporary reference added by sfn_LookupUpdate on
        // our behalf.
        //
        pUpdate->mfn_Dereference();
    }

    //
    // We want to return WBEM_E_NOT_FOUND ONLY if we couldn't find
    // the specific NIC -- this is used by the provider to return
    // a very specific value to the client.
    //
    if (Status == WBEM_E_NOT_FOUND && !fNicNotFound)
    {
        Status = WBEM_E_FAILED;
    }

    TRACE_INFO(L"<-%!FUNC!(Nic=%ws) returns 0x%08lx", szNicGuid, (UINT) Status);

    return Status;
}


WBEMSTATUS
NlbConfigurationUpdate::DoUpdate(
    IN  LPCWSTR szNicGuid,
    IN  LPCWSTR szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
    OUT UINT   *pGeneration,
    OUT WCHAR  **ppLog                   // free using delete operator.
)
//
// 
//
// Called to initiate update to a new cluster state on that NIC. This
// could include moving from a NLB-bound state to the NLB-unbound state.
// *pGeneration is used to reference this particular update request.
//
/*++

Return Value:
    WBEM_S_PENDING  Pending operation.

--*/
{
    WBEMSTATUS Status =  WBEM_S_PENDING;
    NlbConfigurationUpdate *pUpdate = NULL;
    BOOL            fImpersonating = TRUE; // we assume we're impersonating,
                        // but in the case of "tprov -", wmi is not involved,
                        // and we're not impersonating.

    TRACE_INFO(L"->%!FUNC!(Nic=%ws)", szNicGuid);
    *ppLog = NULL;

    //
    // Look for an update object for the specified NIC, creating one if 
    // required.
    //
    Status = sfn_LookupUpdate(szNicGuid, TRUE, &pUpdate); // TRUE == Create

    if (FAILED(Status))
    {
        TRACE_CRIT(
            L"DoUpdate: Error creating new update object for NIC %ws",
            szNicGuid
            );
        pUpdate = NULL;
        goto end;
    }

    TRACE_INFO(
        L"DoUpdate: Created/found update object 0x%p update object for NIC %ws",
        pUpdate,
        szNicGuid
        );


    BOOL fDoAsync = FALSE;

    //
    // Get exclusive permission to perform an update on this NIC.
    // If mfn_StartUpdate succeeds we MUST make sure that mfn_StopUpdate() is
    // called, either here or asynchronously (or else we'll block all subsequent
    // updates to this NIC until this process/dll is unloaded!).
    // BUGBUG -- get rid of MyBreak
    MyBreak(L"Break before calling StartUpdate.\n");
    Status = pUpdate->mfn_StartUpdate(pNewCfg, szClientDescription, &fDoAsync, ppLog);
    if (FAILED(Status))
    {
        goto end;
    }

    if (Status == WBEM_S_FALSE)
    {
        //
        //  The update is a No-Op. We return the current generation ID
        //  and switch the status to WBEM_NO_ERROR.
        //
        // WARNING/TODO: we return the value in m_OldClusterConfig.Generation,
        // because we know that this gets filled in when analyzing the update.
        // However there is a small possibility that a complete update
        // happened in *another* thead in between when we called mfn_StartUpdate
        // and now, in which case we'll be reporting the generation ID of
        // the later update.
        //
        sfn_Lock();
        if (!pUpdate->m_OldClusterConfig.fValidNlbCfg)
        {
            //
            // We could get here if some activity happened in another
            // thread which resulted in the old cluster state now being
            // invalid. It's a highly unlikely possibility.
            //
            ASSERT(!"Old cluster state invalid");
            TRACE_CRIT("old cluster state is invalid %ws", szNicGuid);
            Status = WBEM_E_CRITICAL_ERROR;
        }
        else
        {
            *pGeneration = pUpdate->m_OldClusterConfig.Generation;
            Status = WBEM_NO_ERROR;
        }
        sfn_Unlock();
        goto end;
    }


    TRACE_INFO(
        L"DoUpdate: We're cleared to update for NIC %ws",
        szNicGuid
        );

    //
    // Once we've started the update, m_Generation is the generation number 
    // assigned to this update.
    //
    *pGeneration = pUpdate->m_Generation;

    //
    // For testing purposes, force fDoAsync==FALSE;
    //
    // fDoAsync = FALSE;

    if (fDoAsync)
    {
        TRACE_INFO(
            L"DoUpdate: Initialting ASYNC update for NIC %ws",
            szNicGuid
            );

        HANDLE TokenHandle = NULL;
        HANDLE hThread = NULL;
        HRESULT hRes;

        Status = WBEM_NO_ERROR;

        do
        {
            //
            // NOTE ABOUT NLB_DUPLICATE_TOKEN:
            //       Using duplicate access token caused the following problem. In the new
            //       thread, control flows to EnablePnPPrivileges() (in base\pnp\cfgmgr32\util.c) 
            //       which calls OpenThreadToken() asking for TOKEN_ADJUST_PRIVILEGES access. 
            //       The call fails with "access denied". So, it looks like the duplicate access
            //       token has a more restrictive ACL than the original access token. 
            //       Email exchanges with Jim Cavalaris & Rob Earhart resulted in the following
            //       suggestions:
            //       1. Call OpenThreadToken() with "OpenAsSelf" set to TRUE
            //       2. Revert to Self before duplicating token
            //       #1 by itself did not solve the problem. #1 & #2 in combination solved this problem.
            //       However, it casued a different problem: Net config could not acquire the write
            //       spin lock. This may be because the duplicated token has lower privileges since 
            //       it was created in the context of the process and NOT the client.
            //       If ever we find a way around this, we should use the duplicated access token. 
            //       Using duplicate access token ensures that privileges manipulated in one (say, child) 
            //       thread will NOT affect the other (say, the parent) thread's token.
            // -- KarthicN, 4/15/02
            // 
            // In order for the new thread (that is about to be created) to impersonate
            // the client, the impersonation access token of the curren thread must
            // be attached to the new thread.
            // The first step in this process is to call OpenThreadToken() to
            // open the impersonation access token of the current thread 
            // with TOKEN_IMPERSONATE access. We need TOKEN_IMPERSONATE access so that 
            // we may later attach this token to the new thread.
            // If we go back to using the duplicate access token. acquire TOKEN_DUPLICATE access
            // here so that we may duplicate the access token and attach the duplicate to the new thread.
            //
            // By the way, to maximize the chances of success, we use the 
            // (potentially higher) credentials of the client being impersonated 
            // to open the impersonation token.
            //
            extern BOOL g_Impersonate;
            if(!g_Impersonate)
            {
                fImpersonating = FALSE;
            }
            else if (OpenThreadToken(GetCurrentThread(),
#ifdef NLB_DUPLICATE_TOKEN // NOT defined
                                TOKEN_DUPLICATE, 
#else
                                TOKEN_IMPERSONATE, 
#endif
                                FALSE, // Use the credentials of the client (being impersonated) to obtain TOKEN_IMPERSONATE access
                                &TokenHandle))
            {
                fImpersonating = TRUE;
            }
            else
            {
                TRACE_CRIT(L"%!FUNC! OpenThreadToken fails due to 0x%x",GetLastError());
                Status = WBEM_E_FAILED; 
                TokenHandle = NULL;
                break;
            }

#ifdef NLB_DUPLICATE_TOKEN // NOT defined
            HANDLE DuplicateTokenHandle = NULL;
            //
            // Before attaching the impersonation access token to the new thread, duplicate
            // it. Later, assign the duplicate access token to the new thread so that any modifications 
            // (of privileges) made to the access token will only affect the new thread. 
            // Moreover, the current thread exits immediately after resuming the new thread. 
            // If the current thread were to share (instead of giving a duplicate) access 
            // token with the new thread, we are not sure of the ramifications of the current 
            // thread exiting before the new thread.
            //
            if (fImpersonating && !DuplicateToken(TokenHandle, 
                                SecurityImpersonation, 
                                &DuplicateTokenHandle))  // The returned handle has TOKEN_IMPERSONATE & TOKEN_QUERY access
            {
                TRACE_CRIT(L"%!FUNC! DuplicateToken fails due to 0x%x",GetLastError());
                Status = WBEM_E_FAILED; 
                break;
            }

            // Close the handle to the original access token returned by OpenThreadToken()
            if (TokenHandle != NULL)
            {
                CloseHandle(TokenHandle);
                TokenHandle = DuplicateTokenHandle;
            }
#endif
            //
            // We must do this asynchronously -- start a thread that'll complete
            // the configuration update, and return PENDING.
            //
            DWORD ThreadId;

            //
            // The current thread is impersonating the client. If the new thread is created in this
            // (impersonating) context, it will only have a subset (THREAD_SET_INFORMATION, 
            // THREAD_QUERY_INFORMATION and THREAD_TERMINATE) of the usual (THREAD_ALL_ACCESS) access rights.
            // Pervasive operations (like binding NLB) performed by the new thread causes control to flow
            // into Threadpool. Threadpool needs to be able to create executive level objects 
            // which will be used for other activities in the process, It doesn't want to be creating them 
            // using the impersonation token, so it attempts to revert back to the process token.  It fails 
            // because the thread doesn't have THREAD_IMPERSONATE access to itself. (Explanation courtesy: Rob Earhart)
            // To overcome this problem, we have to revert to self when creating the thread so that it 
            // will be created with THREAD_ALL_ACCESS access rights (which includes THREAD_IMPERSONATE).
            //
            if (fImpersonating)
            {
                hRes = CoRevertToSelf();
                if (FAILED(hRes)) 
                {
                    TRACE_CRIT(L"%!FUNC! CoRevertToSelf() fails due to Error : 0x%x",HRESULT_CODE(hRes));
                    Status = WBEM_E_FAILED; 
                    break;
                }
            }

            hThread = CreateThread(
                            NULL,       // lpThreadAttributes,
                            0,          // dwStackSize,
                            s_AsyncUpdateThreadProc, // lpStartAddress,
                            pUpdate,    // lpParameter,
                            CREATE_SUSPENDED, // dwCreationFlags,
                            &ThreadId       // lpThreadId
                            );

            // Go back to impersonating the client. The current thread does not really do much
            // after this point, so, really, impersonating may not be necessary. However, for
            // consistency sake, do it.
            if (fImpersonating)
            {
                hRes = CoImpersonateClient();
                if (FAILED(hRes)) 
                {
                    TRACE_CRIT(L"%!FUNC! CoImpersonateClient() fails due to Error : 0x%x. Ignoring the failure and moving on...",HRESULT_CODE(hRes));
                }
            }

            if (hThread == NULL)
            {
                TRACE_INFO(
                    L"DoUpdate: ERROR Creating Thread. Aborting update request for Nic %ws",
                    szNicGuid
                    );
                Status = WBEM_E_FAILED; // TODO -- find better error
                break;
            }

            //
            // Attach the impersonation access token to the new thread so that it may impersonate the client
            //
            if (fImpersonating && !SetThreadToken(&hThread, TokenHandle))
            {
                TRACE_CRIT(L"%!FUNC! SetThreadToken fails due to 0x%x",GetLastError());
                Status = WBEM_E_FAILED; 
                break;
            }

            //
            // Since we've claimed the right to perform a config update on this
            // NIC we'd better not find an other update going on!
            // Save away the thread handle and id.
            //
            sfn_Lock();
            ASSERT(m_hAsyncThread == NULL);
            pUpdate->mfn_Reference(); // Add reference for async thread.
            pUpdate->m_hAsyncThread = hThread;
            pUpdate->m_AsyncThreadId = ThreadId;
            sfn_Unlock();

            //
            // The rest of the update will carry on in the context of the async
            // thread. That thread will make sure that pUpdate->mfn_StopUpdate()
            // is called so we shouldn't do it here.
            //
    
            DWORD dwRet = ResumeThread(hThread);
            if (dwRet == 0xFFFFFFFF) // this is what it says in the SDK
            {
                //
                // Aargh ... failure
                // Undo reference to this thread in pUpdate
                //
                TRACE_INFO("ERROR resuming thread for NIC %ws", szNicGuid);
                sfn_Lock();
                ASSERT(pUpdate->m_hAsyncThread == hThread);
                pUpdate->m_hAsyncThread = NULL;
                pUpdate->m_AsyncThreadId = 0;
                pUpdate->mfn_Dereference(); // Remove ref added above.
                sfn_Unlock();
                Status = WBEM_E_FAILED; // TODO -- find better error
                break;
            }

            Status = WBEM_S_PENDING;
            hThread = NULL; // Setting to NULL so that we don't call CloseHandle on it
            (VOID) pUpdate->mfn_ReleaseFirstMutex(FALSE); // FALSE == wait, don't cancel.
        }
        while(FALSE);

        // Close the handle to impersonation access token  and thread
        if (hThread != NULL) 
            CloseHandle(hThread);

        if (TokenHandle != NULL) 
            CloseHandle(TokenHandle);

		// BUGBUG -- test the failure code path...
		// 
        if (FAILED(Status)) // this doesn't include pending
        {
            //
            // We're supposed to do an async update, but can't.
            // Treat this as a failed sync update.
            //

            //
            // We must acquire the 2nd mutex and release the first.
            // This is the stage that mfn_StopUpdate expects things to be.
            //
            // BUGBUG deal with AcquireSecondMutex etc failing here...
            (VOID)pUpdate->mfn_AcquireSecondMutex();
            (VOID)pUpdate->mfn_ReleaseFirstMutex(FALSE); // FALSE == wait, don't cancel

            //
            // Signal the stop of the update process.
            // This also releases exclusive permission to do updates.
            //

            pUpdate->m_CompletionStatus = Status; // Stop update needs this to be set.
            pUpdate->mfn_StopUpdate(ppLog);
                                             
        }
        else
        {
            ASSERT(Status == WBEM_S_PENDING);
        }

    }
    else
    {
        //
        // We can do this synchronously -- call  mfn_Update here itself
        // and return the result.
        //

        //
        // We must acquire the 2nd mutex and release the first before we
        // do the update.
        // 
        //
        Status = pUpdate->mfn_AcquireSecondMutex();
        (VOID)pUpdate->mfn_ReleaseFirstMutex(FALSE); // FALSE == wait, don't cancel.
        if (FAILED(Status))
        {
            pUpdate->m_CompletionStatus = Status;
        }
        else
        {
            try
            {
                pUpdate->mfn_ReallyDoUpdate();
            }
            catch (...)
            {
                TRACE_CRIT(L"!FUNC! Caught exception!\n");
                ASSERT(!"Caught exception!");
                pUpdate->mfn_StopUpdate(ppLog);
                pUpdate->mfn_Dereference();
                throw;
            }
    
            //
            // Let's extract the result
            //
            sfn_Lock();
            Status =  pUpdate->m_CompletionStatus;
            sfn_Unlock();
        }

        ASSERT(Status != WBEM_S_PENDING);

        //
        // Signal the stop of the update process. This also releases exclusive
        // permission to do updates. So potentially other updates can start
        // happening concurrently before mfn_StopUpdate returns.
        //
        pUpdate->mfn_StopUpdate(ppLog);
    }

end:

    if (pUpdate != NULL)
    {
        //
        // Dereference the temporary reference added by sfn_LookupUpdate on
        // our behalf.
        //
        pUpdate->mfn_Dereference();
    }


    TRACE_INFO(L"<-%!FUNC!(Nic=%ws) returns 0x%08lx", szNicGuid, (UINT) Status);

    return Status;
}



//
// Constructor and distructor --  note that these are private
//
NlbConfigurationUpdate::NlbConfigurationUpdate(VOID)
//
// 
//
{
    //
    // This assumes that we don't have a parent class. We should never
    // have a parent class. 
    // BUGBUG -- remove, replace by clearing out individual members
    // in the constructor.
    //
    ZeroMemory(this, sizeof(*this));
    m_State = UNINITIALIZED;

    //
    // Note: the refcount is zero on return from the constructor.
    // The caller is expected to bump it up when it adds this entry to
    // to the list.
    //

}

NlbConfigurationUpdate::~NlbConfigurationUpdate()
//
// Status: done
//
{
    ASSERT(m_RefCount == 0);
    ASSERT(m_State!=ACTIVE);
    ASSERT(m_hAsyncThreadId == 0);

    //
    // TODO: Delete ip-address-info structures if any
    //

}

VOID
NlbConfigurationUpdate::mfn_Reference(
    VOID
    )
{
    InterlockedIncrement(&m_RefCount);
}

VOID
NlbConfigurationUpdate::mfn_Dereference(
    VOID
    )
{
    LONG l  = InterlockedDecrement(&m_RefCount);

    ASSERT(l >= 0);

    if (l == 0)
    {
        TRACE_CRIT("Deleting update instance 0x%p", (PVOID) this);
        delete this;
    }
}

VOID
NlbConfigurationUpdate::sfn_ReadLog(
    IN  HKEY hKeyLog,
    IN  UINT Generation,
    OUT LPWSTR *ppLog
    )
{
    WCHAR szValueName[128];
    WCHAR *pLog = NULL;
    LONG lRet;
    DWORD dwType;
    DWORD cbData;

    *ppLog = NULL;


    StringCbPrintf(szValueName, sizeof(szValueName), L"%d.log", Generation);

    cbData = 0;
    lRet =  RegQueryValueEx(
              hKeyLog,         // handle to key to query
              szValueName,  // address of name of value to query
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              NULL, // address of data buffer
              &cbData  // address of data buffer size
              );
    if (    (lRet == ERROR_SUCCESS)
        &&  (cbData > sizeof(WCHAR))
        &&  (dwType == REG_SZ))
    {
    	// BUGBUG -- put some limit on the accepted size of cbData -- say
    	// 4K.
        // We've got a non-null log entry...
        // Let's try to read it..
        // cbData should be a multiple of sizeof(WCHAR) but just in
        // case let's allocate a little more...
        pLog = new WCHAR[(cbData+1)/sizeof(WCHAR)];
        if (pLog == NULL)
        {
            TRACE_CRIT("Error allocating space for log");
        }
        else
        {
            lRet =  RegQueryValueEx(
                      hKeyLog,         // handle to key to query
                      szValueName,  // address of name of value to query
                      NULL,         // reserved
                      &dwType,   // address of buffer for value type
                      (LPBYTE)pLog, // address of data buffer
                      &cbData  // address of data buffer size
                      );
            if (    (lRet != ERROR_SUCCESS)
                ||  (cbData <= sizeof(WCHAR))
                ||  (dwType != REG_SZ))
            {
                // Oops -- an error this time around!
                TRACE_CRIT("Error reading log entry for gen %d", Generation);
                delete[] pLog;
                pLog = NULL;
            }
        }
    }
    else
    {
        TRACE_CRIT("Error reading log entry for Generation %lu", Generation); 
        // ignore the rror
        //
    }

    *ppLog = pLog;

}



VOID
NlbConfigurationUpdate::sfn_WriteLog(
    IN  HKEY hKeyLog,
    IN  UINT Generation,
    IN  LPCWSTR pLog,
    IN  BOOL    fAppend
    )
{
    //
    // TODO: If fAppend==TRUE, this function is a bit wasteful in its use
    // of the heap.
    //
    WCHAR szValueName[128];
    LONG lRet;
    LPWSTR pOldLog = NULL;
    LPWSTR pTmpLog = NULL;
    UINT Len = wcslen(pLog)+1; // +1 for ending NULL

    if (fAppend)
    {
        sfn_ReadLog(hKeyLog, Generation, &pOldLog);
        if (pOldLog != NULL && *pOldLog != NULL)
        {
            Len += wcslen(pOldLog);
            if (Len > NLBUPD_MAX_LOG_LENGTH)
            {
                TRACE_CRIT("sfn_WriteLog: log size exceeded");
                goto end;
            }
            pTmpLog = new WCHAR[Len];
            if (pTmpLog == NULL)
            {
                TRACE_CRIT("sfn_WriteLog: allocation failure!");
                goto end;
            }
            (void) StringCchCopy(pTmpLog, Len, pOldLog);
            (void) StringCchCat(pTmpLog, Len, pLog);
            pLog = pTmpLog;
        }
    }
    StringCbPrintf(szValueName, sizeof(szValueName), L"%d.log", Generation);

    lRet = RegSetValueEx(
            hKeyLog,           // handle to key to set value for
            szValueName,    // name of the value to set
            0,              // reserved
            REG_SZ,     // flag for value type
            (BYTE*) pLog,// address of value data
            Len*sizeof(WCHAR)  // size of value data
            );
    if (lRet != ERROR_SUCCESS)
    {
        TRACE_CRIT("Error writing log entry for generation %d", Generation);
        // We ignore this error.
    }

end:

    if (pOldLog != NULL)
    {
        delete pOldLog;
    }

    if (pTmpLog != NULL)
    {
        delete[] pTmpLog;
    }

    return;
}



VOID
NlbConfigurationUpdate::mfn_LogRawText(
    LPCWSTR szText
    )
//
// We read the current value of the log for this update, append szText
// and write back the log.
{

    TRACE_CRIT(L"LOG: %ws", szText);
    sfn_Lock();

    if (m_State!=ACTIVE)
    {
        //
        // Logging should only be performed when there is an active update
        // going on -- the log is specific to the currently active update.
        //
        TRACE_CRIT("WARNING: Attempt to log when not in ACTIVE state");
        goto end;
    }
    else
    {
        HKEY hKey = m_hCompletionKey;

        if (hKey != NULL)
        {
            sfn_WriteLog(hKey, m_Generation, szText, TRUE); // TRUE==append.
        }
    }
end:

    sfn_Unlock();
}

//
// Looks up the current update for the specific NIC.
// We don't bother to reference count because this object never
// goes away once created -- it's one per unique NIC GUID for as long as
// the DLL is loaded (may want to revisit this).
//
WBEMSTATUS
NlbConfigurationUpdate::sfn_LookupUpdate(
    IN LPCWSTR szNic,
    IN BOOL    fCreate, // Create if required
    OUT NlbConfigurationUpdate ** ppUpdate
    )
//
// 
//
{
    WBEMSTATUS Status;
    NlbConfigurationUpdate *pUpdate = NULL;

    *ppUpdate = NULL;
    //
    // With our global lock held, we'll look for an update structure
    // with the matching nic. If we find it, we'll return it, else
    // (if fCreate==TRUE) we'll create and initialize a structure and add
    // it to the list.
    //
    sfn_Lock();

    if (!s_fInitialized)
    {
        TRACE_CRIT(
            "LookupUpdate: We are Deinitializing, so we FAIL this request: %ws",
            szNic
            );
        Status = WBEM_E_NOT_AVAILABLE;
        goto end;
    }

    Status = CfgUtilsValidateNicGuid(szNic);

    if (FAILED(Status))
    {
        TRACE_CRIT(
            "LookupUpdate: Invalid GUID specified: %ws",
            szNic
            );
        goto end;
        
    }

    LIST_ENTRY *pLink = s_listCurrentUpdates.Flink;

    while (pLink != & s_listCurrentUpdates)
    {
        

        pUpdate = CONTAINING_RECORD(
                    pLink,
                    NlbConfigurationUpdate,
                    m_linkUpdates
                    );
        if (!_wcsicmp(pUpdate->m_szNicGuid, szNic))
        {
            // Found it!
            break;
        }
        pUpdate = NULL;
        pLink = pLink->Flink;
    }

    if (pUpdate==NULL && fCreate)
    {
        // Let's create one -- it does NOT add itself to the list, and
        // furthermore, its reference count is zero.
        //
        pUpdate = new NlbConfigurationUpdate();

        if (pUpdate==NULL)
        {
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        else
        {
            //
            // Complete initialization here, and place it in the list.
            //
			// BUGBUG -- use string APIs for this one.
            ARRAYSTRCPY(
                pUpdate->m_szNicGuid,
                szNic
                );
            InsertHeadList(&s_listCurrentUpdates, &pUpdate->m_linkUpdates);
            pUpdate->mfn_Reference(); // Reference for being in the list
            pUpdate->m_State = IDLE;
        }
    }
    else if (pUpdate == NULL) // Couldn't find it, fCreate==FALSE
    {
        TRACE_CRIT(
            "LookupUpdate: Could not find GUID specified: %ws",
            szNic
            );
        Status = WBEM_E_NOT_FOUND;
        goto end;
    }

    ASSERT(pUpdate!=NULL);
    pUpdate->mfn_Reference(); // Reference for caller. Caller should deref.
    *ppUpdate = pUpdate;

    Status = WBEM_NO_ERROR;

end:
    if (FAILED(Status))
    {
        ASSERT(pStatus!=NULL);
    }

    sfn_Unlock();


    return Status;
}


DWORD
WINAPI
NlbConfigurationUpdate::s_AsyncUpdateThreadProc(
    LPVOID lpParameter   // thread data
    )
/*++

--*/
{
    //
    // This thread is started only after we have exclusive right to perform
    // an update on the specified NIC. This means that mfn_StartUpdate()
    // has previously returned successfully. We need to call mfn_StopUpdate()
    // to signal the end of the update when we're done.
    //
    WBEMSTATUS Status = WBEM_NO_ERROR;

    NlbConfigurationUpdate *pUpdate = (NlbConfigurationUpdate *) lpParameter;

    TRACE_INFO(L"->%!FUNC!(Nic=%ws)",  pUpdate->m_szNicGuid);

    ASSERT(pUpdate->m_AsyncThreadId == GetCurrentThreadId());

    //
    // We must acquire the 2nd mutex before we
    // actually do the update. NOTE: the thread which called mfn_StartUpdate
    // will call mfn_ReleaseFirstMutex.
    //
    Status = pUpdate->mfn_AcquireSecondMutex();

    if (FAILED(Status))
    {
        pUpdate->m_CompletionStatus = Status;
        // TODO -- check if we should be calling stop here ...
    }
    else
    {
        //
        // Actually perform the update. mfn_ReallyDoUpate will save away the
        // status appropriately.
        //
        try
        {
            pUpdate->mfn_ReallyDoUpdate();
        }
        catch (...)
        {
            TRACE_CRIT(L"%!FUNC! Caught exception!\n");
            ASSERT(!"Caught exception!");
            pUpdate->m_CompletionStatus = WBEM_E_CRITICAL_ERROR;
        }
    }

    //
    // We're done, let's remove the reference to our thread from pUpdate.
    //
    HANDLE hThread;
    sfn_Lock();
    hThread = pUpdate->m_hAsyncThread;
    pUpdate->m_hAsyncThread = NULL;
    pUpdate->m_AsyncThreadId = 0;
    sfn_Unlock();
    ASSERT(hThread!=NULL);
    CloseHandle(hThread);

    //
    // Signal the stop of the update process. This also releases exclusive
    // permission to do updates. So potentially other updates can start
    // happening concurrently before mfn_StopUpdate returns.
    //
    {
        //
        // TODO: This is hokey. Use another technique to accomplish this
        //
        // Retrieve the log information from mfn_StopUpdate but dispose of it
        // immediately afterward. The side effect (which we want) is that
        // mfn_StopUpdate will include this log information into the event
        // that it writes to the event log.
        //
        WCHAR  *pLog = NULL;
        pUpdate->mfn_StopUpdate(&pLog);
        if (pLog != NULL)
        {
            delete pLog;
        }
    }

    TRACE_INFO(L"<-%!FUNC!(Nic=%ws)",  pUpdate->m_szNicGuid);

    //
    // Deref the ref to pUpdate added when this thread was started.
    // pUpdate may not be valid after this.
    //
    pUpdate->mfn_Dereference();

    return 0; // This return value is ignored.
}

//
// Create the specified subkey key (for r/w access) for the specified
// the specified NIC.
//
HKEY
NlbConfigurationUpdate::
sfn_RegCreateKey(
    IN  LPCWSTR szNicGuid,
    IN  LPCWSTR szSubKey,   // Optional
    IN  BOOL    fVolatile,
    OUT BOOL   *fExists
    )
// Status 
{
    WCHAR szKey[256];
    HKEY hKey = NULL;
    HKEY hKeyHistory = NULL;
    LONG lRet;
    DWORD dwDisposition;
    DWORD dwOptions = 0;
    UINT u = wcslen(szNicGuid);
    if (szSubKey != NULL)
    {
        u += wcslen(szSubKey) + 1; // 1 for the '\'.
    }

    if (u < sizeof(szKey)/sizeof(*szKey))
    {
        (void) StringCbCopy(szKey, sizeof(szKey), szNicGuid);
    }
    else
    {
        goto end;
    }

    if (szSubKey != NULL)
    {
        StringCbCat(szKey, sizeof(szKey), L"\\");
        StringCbCat(szKey, sizeof(szKey), szSubKey);
    }

    lRet = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE, // handle to an open key
            L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\ConfigurationHistory",
            0,          // reserved
            L"class",   // address of class string
            0,          // special options flag
            KEY_ALL_ACCESS,     // desired security access
            NULL,               // address of key security structure
            &hKeyHistory,       // address of buffer for opened handle
            &dwDisposition   // address of disposition value buffer
            );
    if (lRet != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! error 0x%lx creating ConfigurationKey under WLBS",
            lRet);
        hKeyHistory = NULL;
        goto end;
    }


    if (fVolatile)
    {
        dwOptions = REG_OPTION_VOLATILE;
    }
    lRet = RegCreateKeyEx(
            hKeyHistory,        // handle to an open key
            szKey,              // address of subkey name
            0,                  // reserved
            L"class",           // address of class string
            dwOptions,          // special options flag
            KEY_ALL_ACCESS,     // desired security access
            NULL,               // address of key security structure
            &hKey,              // address of buffer for opened handle
            &dwDisposition   // address of disposition value buffer
            );
    if (lRet == ERROR_SUCCESS)
    {
        if (dwDisposition == REG_CREATED_NEW_KEY)
        {
            *fExists = FALSE;
        }
        else
        {
            ASSERT(dwDisposition == REG_OPENED_EXISTING_KEY);
            *fExists = TRUE;
        }
    }
    else
    {
        TRACE_CRIT("Error creating key %ws. WinError=0x%08lx", szKey, GetLastError());
        hKey = NULL;
    }

end:

    if (hKeyHistory != NULL)
    {
        RegCloseKey(hKeyHistory);
    }

    return hKey;
}


//
// Open the specified subkey key (for r/w access) for the specified
// the specified NIC.
//
HKEY
NlbConfigurationUpdate::
sfn_RegOpenKey(
    IN  LPCWSTR szNicGuid,
    IN  LPCWSTR szSubKey
    )
{
    WCHAR szKey[1024];
    HKEY hKey = NULL;

    StringCbCopy(szKey,  sizeof(szKey),
        L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\ConfigurationHistory\\");
    
    UINT u = wcslen(szKey) + wcslen(szNicGuid);

    if (szSubKey != NULL)
    {
        u += wcslen(szSubKey) + 1; // 1 for the '\'.
    }

    if (u < sizeof(szKey)/sizeof(*szKey))
    {
        StringCbCat(szKey, sizeof(szKey), szNicGuid);
    }
    else
    {
        goto end;
    }

    if (szSubKey != NULL)
    {
        StringCbCat(szKey, sizeof(szKey), L"\\");
        StringCbCat(szKey, sizeof(szKey), szSubKey);
    }

    DWORD dwDisposition;

    LONG lRet;
    lRet = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle to an open key
            szKey,                // address of subkey name
            0,                  // reserved
            KEY_ALL_ACCESS,     // desired security access
            &hKey              // address of buffer for opened handle
            );
    if (lRet != ERROR_SUCCESS)
    {
        TRACE_CRIT("Error opening key %ws. WinError=0x%08lx", szKey, GetLastError());
        hKey = NULL;
    }

end:

    return hKey;
}


//
// Save the specified completion status to the registry.
//
WBEMSTATUS
NlbConfigurationUpdate::sfn_RegSetCompletion(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation,
    IN  WBEMSTATUS    CompletionStatus
    )
{
    WBEMSTATUS Status = WBEM_E_FAILED;
    HKEY hKey;
    BOOL fExists;

    hKey =  sfn_RegCreateKey(
                szNicGuid,
                NLBUPD_REG_COMPLETIONS, // szSubKey,
                TRUE, // TRUE == fVolatile,
                &fExists
                );

    if (hKey == NULL)
    {
        TRACE_CRIT("Error creating key for %ws", szNicGuid);
        goto end;
    }

    LONG lRet;
    WCHAR szValueName[128];
    NLB_COMPLETION_RECORD Record;

    ZeroMemory(&Record, sizeof(Record));
    Record.Version = NLB_CURRENT_COMPLETION_RECORD_VERSION;
    Record.Generation = Generation;
    Record.CompletionCode = (UINT) CompletionStatus;
    
    StringCbPrintf(szValueName, sizeof(szValueName), L"%d", Generation);

    lRet = RegSetValueEx(
            hKey,           // handle to key to set value for
            szValueName,    // name of the value to set
            0,              // reserved
            REG_BINARY,     // flag for value type
            (BYTE*) &Record,// address of value data
            sizeof(Record)  // size of value data
            );

    if (lRet == ERROR_SUCCESS)
    {

        Status = WBEM_NO_ERROR;
    }
    else
    {
        TRACE_CRIT("Error setting completion record for %ws(%lu)",
                    szNicGuid,
                    Generation
                    ); 
        goto end;
    }

end:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return Status;
}


//
// Retrieve the specified completion status from the registry.
//
WBEMSTATUS
NlbConfigurationUpdate::
sfn_RegGetCompletion(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation,
    OUT WBEMSTATUS  *pCompletionStatus,
    OUT WCHAR  **ppLog                   // free using delete operator.
    )
{
    WBEMSTATUS Status = WBEM_E_FAILED;
    HKEY hKey;
    WCHAR *pLog = NULL;

    hKey =  sfn_RegOpenKey(
                szNicGuid,
                NLBUPD_REG_COMPLETIONS // szSubKey,
                );

    if (hKey == NULL)
    {
        TRACE_CRIT("Error opening key for %ws", szNicGuid);
        goto end;
    }
    
    
    LONG lRet;
    WCHAR szValueName[128];
    DWORD dwType;
    NLB_COMPLETION_RECORD Record;
    DWORD cbData  = sizeof(Record);

    StringCbPrintf(szValueName, sizeof(szValueName), L"%d", Generation);

    lRet =  RegQueryValueEx(
              hKey,         // handle to key to query
              szValueName,  // address of name of value to query
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              (LPBYTE)&Record, // address of data buffer
              &cbData  // address of data buffer size
              );
    if (    (lRet != ERROR_SUCCESS)
        ||  (cbData != sizeof(Record)
        ||  (dwType != REG_BINARY))
        ||  (Record.Version != NLB_CURRENT_COMPLETION_RECORD_VERSION)
        ||  (Record.Generation != Generation))
    {
        // This is not a valid record!
        TRACE_CRIT("Error reading completion record for %ws(%d)",
                        szNicGuid, Generation);
        goto end;
    }

    //
    // We've got a valid completion record.
    // Let's now try to read the log for this record.
    //
    sfn_ReadLog(hKey, Generation, &pLog);

    //
    // We've got valid values -- fill out the output params...
    //
    *pCompletionStatus = (WBEMSTATUS) Record.CompletionCode;
    *ppLog = pLog; // could be NULL.
    Status = WBEM_NO_ERROR;

end:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return Status;
}


//
// Delete the specified completion status from the registry.
//
VOID
NlbConfigurationUpdate::
sfn_RegDeleteCompletion(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation
    )
{
    WBEMSTATUS Status = WBEM_E_FAILED;
    HKEY hKey;
    WCHAR pLog = NULL;

    hKey =  sfn_RegOpenKey(
                szNicGuid,
                NLBUPD_REG_COMPLETIONS // szSubKey,
                );

    if (hKey == NULL)
    {
        TRACE_CRIT("Error opening key for %ws", szNicGuid);
        goto end;
    }

    
    WCHAR szValueName[128];
    StringCbPrintf(szValueName, sizeof(szValueName), L"%d", Generation);
    RegDeleteValue(hKey, szValueName);
    StringCbPrintf(szValueName, sizeof(szValueName), L"%d.log", Generation);
    RegDeleteValue(hKey, szValueName);

end:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }
}

//
// Called to get the status of an update request, identified by
// Generation.
//
WBEMSTATUS
NlbConfigurationUpdate::GetUpdateStatus(
    IN  LPCWSTR szNicGuid,
    IN  UINT    Generation,
    IN  BOOL    fDelete,                // Delete completion record
    OUT WBEMSTATUS  *pCompletionStatus,
    OUT WCHAR  **ppLog                   // free using delete operator.
    )
//
// 
//
{
    WBEMSTATUS  Status = WBEM_E_NOT_FOUND;
    WBEMSTATUS  CompletionStatus = WBEM_NO_ERROR;

    TRACE_INFO(
        L"->%!FUNC!(Nic=%ws, Gen=%ld)",
        szNicGuid,
        Generation
        );

    //
    // We look in the registry for
    // this generation ID and return the status based on the registry
    // record
    //
    Status =  sfn_RegGetCompletion(
                    szNicGuid,
                    Generation,
                    &CompletionStatus,
                    ppLog
                    );

    if (!FAILED(Status))
    {
        if (fDelete && CompletionStatus!=WBEM_S_PENDING)
        {
            sfn_RegDeleteCompletion(
                szNicGuid,
                Generation
                );
        }
        *pCompletionStatus = CompletionStatus;
    }

    TRACE_INFO(
        L"<-%!FUNC!(Nic=%ws, Gen=%ld) returns 0x%08lx",
        szNicGuid,
        Generation,
        (UINT) Status
        );

    return Status;
}


//
// Release the machine-wide update event for this NIC, and delete any
// temporary entries in the registry that were used for this update.
//
VOID
NlbConfigurationUpdate::mfn_StopUpdate(
    OUT WCHAR **                           ppLog
    )
{
    WBEMSTATUS Status;

    if (ppLog != NULL)
    {
        *ppLog = NULL;
    }

    sfn_Lock();

    if (m_State!=ACTIVE)
    {
        ASSERT(FALSE);
        TRACE_CRIT("StopUpdate: invalid state %d", (int) m_State);
        goto end;
    }

    ASSERT(m_hAsyncThread==NULL);


    //
    // Update the completion status value for current generation
    //
    Status =  sfn_RegSetCompletion(
                    m_szNicGuid,
                    m_Generation,
                    m_CompletionStatus
                    );
    
    if (FAILED(m_CompletionStatus))
    {
    	TRACE_CRIT(L"Could not set completion for szNic=%ws, generation=%d, status=0x%x, completion-status=0x%x", m_szNicGuid, m_Generation, Status, m_CompletionStatus);
    }
    //
    // Note: mfn_ReallyDoUpdate logs the fact that it started and stopped the
    // update, so no need to do that here.
    //

    m_State = IDLE;
    ASSERT(m_hCompletionKey != NULL); // If we started, this key should be !null
    if (ppLog!=NULL)
    {
        sfn_ReadLog(m_hCompletionKey, m_Generation, ppLog);
    }
    RegCloseKey(m_hCompletionKey);

    WORD wEventType = EVENTLOG_INFORMATION_TYPE;
    if (FAILED(m_CompletionStatus))
    {
        wEventType = EVENTLOG_ERROR_TYPE;
    }

    ReportStopEvent (wEventType, ppLog);

    m_hCompletionKey = NULL;
    m_Generation = 0;

    //
    // Release the gobal config mutex for this NIC
    //
    (VOID) mfn_ReleaseSecondMutex();

end:
    sfn_Unlock();
    return;
}


WBEMSTATUS
NlbConfigurationUpdate::mfn_StartUpdate(
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
    IN  LPCWSTR                             szClientDescription,
    OUT BOOL                               *pfDoAsync,
    OUT WCHAR **                           ppLog
    )
//
// Special return values:
//    WBEM_E_ALREADY_EXISTS: another update is in progress.
//
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    BOOL fWeAcquiredLock = FALSE;
    HKEY hRootKey = NULL;
    BOOL fExists;
    CLocalLogger logger;
    UINT    NewGeneration = 0;

    TRACE_VERB(L"--> %!FUNC! Guid=%ws", m_szNicGuid);
        

    if (ppLog != NULL)
    {
        *ppLog = NULL;
    }

    sfn_Lock();

    do // while false
    {


        Status = mfn_AcquireFirstMutex();
        if (FAILED(Status))
        {
            logger.Log(IDS_OTHER_UPDATE_ONGOING);
            Status = WBEM_E_ALREADY_EXISTS;
            break;
        }

        TRACE_INFO("Got global event!");
        Status = WBEM_NO_ERROR;
        fWeAcquiredLock = TRUE;
        
        if (m_State!=IDLE)
        {
            //
            // This is a code bug. We need to see if we should recover from
            // this.
            //
            logger.Log(IDS_OTHER_UPDATE_ONGOING2);
            Status = WBEM_E_ALREADY_EXISTS;
            TRACE_CRIT("StartUpdate: invalid state %d", (int) m_State);
            break;
        }

        //
        // Create/Open the completions key for this NIC.
        //
        {
            HKEY hKey;

            hKey =  sfn_RegCreateKey(
                        m_szNicGuid,
                        NLBUPD_REG_COMPLETIONS, // szSubKey,
                        TRUE, // TRUE == fVolatile,
                        &fExists
                        );
        
            if (hKey == NULL)
            {
                TRACE_CRIT("Error creating completions key for %ws", m_szNicGuid);
                Status = WBEM_E_CRITICAL_ERROR;
                logger.Log(IDS_CRITICAL_RESOURCE_FAILURE);
                ASSERT(m_hCompletionKey == NULL);
            }
            else
            {
                m_hCompletionKey = hKey;
            }
        }
    }
    while (FALSE);


    if (!FAILED(Status))
    {
        m_State = ACTIVE;
    }

    sfn_Unlock();


    if (FAILED(Status)) goto end;

    //
    // WE HAVE NOW GAINED EXCLUSIVE ACCESS TO UPDATE THE CONFIGURATION
    //

    //
    // Creat/Open the root key for updates to the specified NIC, and determine
    // the proposed NEW generation count for the NIC. We don't actually
    // write the new generation count back to the registry unless we're
    // going to do an update. The reasons for NOT doing an update are
    // (a) some failure or (b) the update turns out to be a NO-OP.
    //
    {
        LONG lRet;
        DWORD dwType;
        DWORD dwData;
        DWORD Generation;
        hRootKey =  sfn_RegCreateKey(
                    m_szNicGuid,
                    NULL,       // NULL == root for this guid.
                    FALSE, // FALSE == Non-volatile
                    &fExists
                    );
        
        if (hRootKey==NULL)
        {
                TRACE_CRIT("CRITICAL ERROR: Couldn't set generation number for %ws", m_szNicGuid);
                Status = WBEM_E_CRITICAL_ERROR;
                logger.Log(IDS_CRITICAL_RESOURCE_FAILURE);
                goto end;
        }

        Generation = 1; // We assume generation is 1 on error reading gen.
    
        dwData = sizeof(Generation);
        lRet =  RegQueryValueEx(
                  hRootKey,         // handle to key to query
                  L"Generation",  // address of name of value to query
                  NULL,         // reserved
                  &dwType,   // address of buffer for value type
                  (LPBYTE) &Generation, // address of data buffer
                  &dwData  // address of data buffer size
                  );
        if (    lRet != ERROR_SUCCESS
            ||  dwType != REG_DWORD
            ||  dwData != sizeof(Generation))
        {
            //
            // Couldn't read the generation. Let's assume it's 
            // a starting value of 1.
            //
            TRACE_CRIT("Error reading generation for %ws; assuming its 1", m_szNicGuid);
            Generation = 1;
        }

        NewGeneration = Generation + 1;
    }

    //
    // Copy over upto NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH chars of
    // szClientDescription.
    //
    {
        ARRAYSTRCPY(m_szClientDescription, szClientDescription);
#if OBSOLETE
        UINT lClient = wcslen(szClientDescription)+1;
        if (lClient > NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH)
        {
            TRACE_CRIT("Truncating client description %ws", szClientDescription);
            lClient = NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH;
        }
        CopyMemory(
            m_szClientDescription,
            szClientDescription,
            (lClient+1)*sizeof(WCHAR) // +1 for NULL
            );
        m_szClientDescription[NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH] = 0;
#endif // OBSOLETE

    }

    //
    // Log the fact the we're received an update request from the specified
    // client.
    //
    logger.Log(IDS_PROCESING_UPDATE, NewGeneration, m_szClientDescription);

    ReportStartEvent(szClientDescription);

    // Load the current cluster configuration into
    // m_OldClusterConfig field.
    // The m_OldClusterConfig.fValidNlbCfg field is set to TRUE IFF there were
    // no errors trying to fill out the information.
    //
    if (m_OldClusterConfig.pIpAddressInfo != NULL)
    {
        delete m_OldClusterConfig.pIpAddressInfo;
    }
    // mfn_GetCurrentClusterConfiguration expects a zeroed-out structure
    // on init...
    ZeroMemory(&m_OldClusterConfig, sizeof(m_OldClusterConfig));
    Status = mfn_GetCurrentClusterConfiguration(&m_OldClusterConfig);
    if (FAILED(Status))
    {
        //
        // Ouch, couldn't read the current cluster configuration...
        //
        TRACE_CRIT(L"Cannot get current cluster config on Nic %ws", m_szNicGuid);
        logger.Log(IDS_ERROR_READING_CONFIG);

        goto end;
    }

    ASSERT(mfn_OldClusterConfig.fValidNlbCfg == TRUE);
    if (NewGeneration != (m_OldClusterConfig.Generation+1))
    {
        //
        // We should never get here, because no one should updated the
        // generation between when we read it in this function
        // and when we called mfn_GetCurrentClusterConfiguration.
        //
        TRACE_CRIT("ERROR: Generation bumped up unexpectedly for %ws", m_szNicGuid);
        logger.Log(IDS_CRIT_INTERNAL_ERROR);
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    //
    // If the new requrested state is NLB-bound, and the previous state
    // is NLB not bound, we'll check if MSCS is installed ...
    // installed on this system
    //
    if (!m_OldClusterConfig.IsNlbBound() && pNewCfg->IsNlbBound())
    {
        //
        // We're going from an unbound to bound state -- check if MSCS
        // is installed
        //
        TRACE_INFO(L"Checking if MSCS Installed...");
        if (CfgUtilIsMSCSInstalled())
        {
            TRACE_CRIT(L"Failing update request because MSCS is installed");
            logger.Log(IDS_MSCS_INSTALLED);
            Status = WBEM_E_NOT_SUPPORTED;
            goto end;
        }
        TRACE_INFO(L"MSCS doesn't appear to be installed. Moving on...");
    }

    //
    // Analyze the proposed update to see if we can do this synchronously
    // or asynchronously..
    // We also do parameter validation here.
    //
    BOOL ConnectivityChange = FALSE;
    *pfDoAsync = FALSE;
    Status = mfn_AnalyzeUpdate(
                    pNewCfg,
                    &ConnectivityChange,
                    REF logger
                    );
    if (FAILED(Status))
    {
        //
        // Ouch, we've hit some error -- probably bad params.
        //
        TRACE_CRIT(L"Cannot perform update on Nic %ws", m_szNicGuid);
        goto end;
    }
    else if (Status == WBEM_S_FALSE)
    {
        //
        // We use this success code to indicate that this is a No-op.
        // That
        //
        TRACE_CRIT(L"Update is a NOOP on Nic %ws", m_szNicGuid);
        logger.Log(IDS_UPDATE_NO_CHANGE);
        goto end;
    }

    if (ConnectivityChange)
    {
        //
        // Check if the NETCONFIG write lock is available. If not we bail ont.
        // Note that it's possible that between when we check and when we
        // actually do stuff someone else gets the netcfg lock -- touch luck
        //  -- we'll bail out later in the update process when we try
        // to get the lock.
        //
        BOOL fCanLock = FALSE;
        LPWSTR szLockedBy = NULL;
        Status = CfgUtilGetNetcfgWriteLockState(&fCanLock, &szLockedBy);
        if (!FAILED(Status) && !fCanLock)
        {
            TRACE_CRIT("%!FUNC! Someone else has netcfg write lock -- bailing");
            if (szLockedBy!=NULL)
            {
                logger.Log(IDS_NETCFG_WRITELOCK_TAKEN, szLockedBy);
                delete[] szLockedBy;
            }
            else
            {
                logger.Log(IDS_NETCFG_WRITELOCK_CANTTAKE);
            }
            Status = WBEM_E_SERVER_TOO_BUSY;
            goto end;
        }
    }

    //
    // We recommend Async if there is a connectivity change, including
    // changes in IP addresses or cluster operation modes (unicast/multicast).
    //
    *pfDoAsync = ConnectivityChange;


    //
    // Save the proposed new configuration...
    //
    Status = m_NewClusterConfig.Update(pNewCfg);
    if (FAILED(Status))
    {
        //
        // This is probably a memory allocation error.
        //
        TRACE_CRIT("Couldn't copy new config for %ws", m_szNicGuid);
        logger.Log(IDS_MEM_ALLOC_FAILURE);
        goto end;
    }


    //
    // Create volatile "PendingOperation" key
    //
    // TODO: we don't use this pending operations key currently.
    //
    #if OBSOLETE
    if (0)
    {
        HKEY hPendingKey =  sfn_RegCreateKey(
                    m_szNicGuid,
                    NLBUPD_REG_PENDING, // szSubKey,
                    TRUE, // TRUE == fVolatile,
                    &fExists
                    );
        if (hPendingKey == NULL)
        {
            // Ugh, can't create the volatile key...
            //
            TRACE_CRIT("Couldn't create pending key for %ws", m_szNicGuid);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        else if (fExists)
        {
            // Ugh, this key already exists. Currently we'll just
            // move on.
            //
            TRACE_CRIT("WARNING -- volatile pending-op key exists for %ws", m_szNicGuid);
        }
        RegCloseKey(hPendingKey);
        hPendingKey = NULL;
    }
    #endif // OBSOLETE

    //
    // Actually write the new generation count to the registry...
    //
    {
        LONG lRet;

        lRet = RegSetValueEx(
                hRootKey,           // handle to key to set value for
                L"Generation",    // name of the value to set
                0,              // reserved
                REG_DWORD,     // flag for value type
                (BYTE*) &NewGeneration,// address of value data
                sizeof(NewGeneration)  // size of value data
                );

        if (lRet !=ERROR_SUCCESS)
        {
            TRACE_CRIT("CRITICAL ERROR: Couldn't set new generation number %d for %ws", NewGeneration, m_szNicGuid);
            Status = WBEM_E_CRITICAL_ERROR;
            logger.Log(IDS_CRIT_INTERNAL_ERROR);
            goto end;
        }
    }

    //
    // The new cluster state's generation field is not filled in on entry.
    // Set it to the new generation -- whose update is under progress.
    //
    m_NewClusterConfig.Generation = NewGeneration;

    //
    // We set the completion status to pending.
    // It will be set to the final status when the update completes,
    // either asynchronously or synchronously.
    //
    m_CompletionStatus = WBEM_S_PENDING;

    Status =  sfn_RegSetCompletion(
                    m_szNicGuid,
                    NewGeneration,
                    m_CompletionStatus
                    );
 
    if (FAILED(Status))
    {
        logger.Log(IDS_CRIT_INTERNAL_ERROR);
    }
    else
    {
        LPCWSTR pLog = logger.GetStringSafe();
        //
        // We've actually succeeded --  let's update our internal active
        // generation number,  and save the local log. We must save
        // the generation first, because th
        //
        m_Generation = NewGeneration;

        if (*pLog != 0)
        {
            mfn_LogRawText(pLog);
        }

        //
        // Let's clean up an old completion record here. This is our mechanism
        // for garbage collection.
        //
        if (m_Generation > NLB_MAX_GENERATION_GAP)
        {
            UINT OldGeneration = m_Generation - NLB_MAX_GENERATION_GAP;
            (VOID) sfn_RegDeleteCompletion(m_szNicGuid, OldGeneration);
        }
    }

end:

    //
    // If required, set *ppLog to a copy of the content in locallog.
    //
    if (ppLog != NULL)
    {
        UINT uSize=0;
        LPCWSTR pLog = NULL;
        logger.ExtractLog(REF pLog, REF uSize); // size includes ending NULL
        if (uSize != 0)
        {
            LPWSTR pLogCopy = new WCHAR[uSize];
            if (pLogCopy != NULL)
            {
                CopyMemory(pLogCopy, pLog, uSize*sizeof(*pLog));
                *ppLog = pLogCopy;
            } 
        }
    }

    if (fWeAcquiredLock && (FAILED(Status) || Status == WBEM_S_FALSE))
    {
        //
        // Oops -- we acquired the lock but either had a problem
        // or there is nothing to do. Clean up.
        //
        sfn_Lock();
        ASSERT(m_State == ACTIVE);

        m_State = IDLE;

        if (m_hCompletionKey != NULL)
        {
            RegCloseKey(m_hCompletionKey);
            m_hCompletionKey = NULL;
        }
        m_Generation = 0; // This field is unused when m_State != ACTIVE;
        (void) mfn_ReleaseFirstMutex(TRUE); // TRUE == cancel, cleanup.

        sfn_Unlock();
    }

    if (hRootKey != NULL)
    {
        RegCloseKey(hRootKey);
    }

    TRACE_VERB(L"<-- %!FUNC! Guid=%ws Status= 0x%lx", m_szNicGuid, Status);

    return  Status;

}



//
// Uses various windows APIs to fill up the current extended cluster
// information for a specific nic (identified by *this)
//
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_GetCurrentClusterConfiguration(
    OUT  PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    )
//
//
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
    LPWSTR szFriendlyName = NULL;
    UINT NumIpAddresses = 0;
    BOOL fNlbBound = FALSE;
    WLBS_REG_PARAMS  NlbParams;    // The WLBS-specific configuration
    BOOL    fNlbParamsValid = FALSE;
    UINT Generation = 1;
    BOOL fDHCP = FALSE;

    //
    // Zero-out the entire structure.
    //
    pCfg->Clear();

    //
    // Get the ip address list.
    //
    Status = CfgUtilGetIpAddressesAndFriendlyName(
                m_szNicGuid,
                &NumIpAddresses,
                &pIpInfo,
                &szFriendlyName
                );

    if (FAILED(Status))
    {
        TRACE_CRIT("Error 0x%08lx getting ip address list for %ws", (UINT) Status,  m_szNicGuid);
        mfn_Log(IDS_ERROR_GETTING_IP);
        pIpInfo = NULL;
        szFriendlyName = NULL;
        goto end;
    }

    //
    // Check if NIC has DHCP enabled.
    //
    {
        Status =  CfgUtilGetDHCP(m_szNicGuid, &fDHCP);
        if (FAILED(Status))
        {
            TRACE_CRIT(L"Error 0x%x attempting to determine DHCP state for NIC %ws -- ignoring (assuming no dhcp)", 
                        (UINT) Status, m_szNicGuid);
            fDHCP = FALSE;
        }
        // we plow on...
    }

    //
    // Check if NLB is bound
    //
    Status =  CfgUtilCheckIfNlbBound(
                    m_szNicGuid,
                    &fNlbBound
                    );
    if (FAILED(Status))
    {
        if (Status ==  WBEM_E_NOT_FOUND)
        {
            //
            // This means that NLB is not INSTALLED on this NIC.
            //
            TRACE_CRIT("NLB IS NOT INSTALLED ON THIS SYSTEM");
            mfn_Log(IDS_NLB_NOT_INSTALLED);
            fNlbBound = FALSE;
            Status = WBEM_NO_ERROR;
        }
        else
        {

            TRACE_CRIT("Error 0x%08lx determining if NLB is bound to %ws", (UINT) Status,  m_szNicGuid);
            mfn_Log(IDS_ERROR_FINDING_NLB);
            goto end;
        }
    }

    if (fNlbBound)
    {
        //
        // Get the latest NLB configuration information for this NIC.
        //
        Status =  CfgUtilGetNlbConfig(
                    m_szNicGuid,
                    &NlbParams
                    );
        if (FAILED(Status))
        {
            //
            // We don't consider a catastrophic failure.
            //
            TRACE_CRIT("Error 0x%08lx reading NLB configuration for %ws", (UINT) Status,  m_szNicGuid);
            mfn_Log(IDS_ERROR_READING_CONFIG);
            Status = WBEM_NO_ERROR;
            fNlbParamsValid = FALSE;
            ZeroMemory(&NlbParams, sizeof(NlbParams));
        }
        else
        {
            fNlbParamsValid = TRUE;
        }
    }

    //
    // Get the current generation
    //
    {
        BOOL fExists=FALSE;
        HKEY hKey =  sfn_RegOpenKey(
                        m_szNicGuid,
                        NULL       // NULL == root for this guid.,
                        );
        
        Generation = 1; // We assume generation is 1 on error reading gen.

        if (hKey!=NULL)
        {
            LONG lRet;
            DWORD dwType;
            DWORD dwData;
        
            dwData = sizeof(Generation);
            lRet =  RegQueryValueEx(
                      hKey,         // handle to key to query
                      L"Generation",  // address of name of value to query
                      NULL,         // reserved
                      &dwType,   // address of buffer for value type
                      (LPBYTE) &Generation, // address of data buffer
                      &dwData  // address of data buffer size
                      );
            if (    lRet != ERROR_SUCCESS
                ||  dwType != REG_DWORD
                ||  dwData != sizeof(Generation))
            {
                //
                // Couldn't read the generation. Let's assume it's 
                // a starting value of 1.
                //
                TRACE_CRIT("Error reading generation for %ws; assuming its 0", m_szNicGuid);
                Generation = 1;
            }
            RegCloseKey(hKey);
        }
    }

    //
    // Success ... fill out pCfg
    //
    pCfg->fValidNlbCfg = fNlbParamsValid;
    pCfg->Generation = Generation;
    pCfg->fBound = fNlbBound;
    pCfg->fDHCP = fDHCP;
    pCfg->NumIpAddresses = NumIpAddresses; 
    pCfg->pIpAddressInfo = pIpInfo;
    pIpInfo = NULL;
    (VOID) pCfg->SetFriendlyName(szFriendlyName); // Copies this internally.
    if (fNlbBound)
    {
        pCfg->NlbParams = NlbParams;    // struct copy
    }


    Status = WBEM_NO_ERROR;

end:

    if (pIpInfo!=NULL)
    {
        delete pIpInfo;
    }

    if (szFriendlyName != NULL)
    {
        delete szFriendlyName;
        szFriendlyName = NULL;
    }

    if (FAILED(Status))
    {
        pCfg->fValidNlbCfg = FALSE;
    }

    return Status;

}


//
// Does the update synchronously -- this is where the meat of the update
// logic exists. It can range from a NoOp, through changing the
// fields of a single port rule, through binding NLB, setting up cluster
// parameters and adding the relevant IP addresses in TCPIP.
//
VOID
NlbConfigurationUpdate::mfn_ReallyDoUpdate(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fResetIpList = FALSE; // Whether to re-do ip addresses in the end
    BOOL fJustBound = FALSE; // whether we're binding as part of the update.
    BOOL fModeChange = FALSE; // There's been a change in operation mode.
    TRACE_INFO(L"->%!FUNC!(Nic=%ws)", m_szNicGuid);

/*
    PSEUDO CODE


    if (bound)
    {
        if (major-change, including unbind or mac-address change)
        {
            stop wlbs, set initial-state to false/suspended.
            remove all ip addresses except dedicated-ip
        }

        if (need-to-unbind)
        {
            <unbind>
        }
    }
    else // not bound
    {
        if (need to bind)
        {
            if (nlb config already exists in registry)
            {
                munge initial state to stopped,
                zap old cluster ip address.
            }
            <bind>
        }
    }

    if (need to bind)
    {
       <change cluster properties>
    }


    <add new ip list if needed>

    note: on major change, cluster is left in the stopped state,
          with initial-state=stopped

    this is so that a second round can be made just to start the hosts.
*/
    MyBreak(L"Break at start of ReallyDoUpdate.\n");

    mfn_Log(IDS_STARTING_UPDATE);

    if (m_OldClusterConfig.fBound)
    {
        BOOL fTakeOutVips = FALSE;

        //
        // We are currently bound
        //
        
        if (!m_NewClusterConfig.fBound)
        {
            //
            // We need to unbind
            //
            fTakeOutVips = TRUE;
        }
        else
        {
            BOOL fConnectivityChange = FALSE;

            //
            // We were bound and need to remain bound.
            // Determine if this is a major change or not.
            //

            Status =  CfgUtilsAnalyzeNlbUpdate(
                        &m_OldClusterConfig.NlbParams,
                        &m_NewClusterConfig.NlbParams,
                        &fConnectivityChange
                        );
            if (FAILED(Status))
            {
                if (Status == WBEM_E_INVALID_PARAMETER)
                {
                    //
                    // We'd better exit.
                    //
                    mfn_Log(IDS_NEW_PARAMS_INCORRECT);
                    goto end;
                }
                else
                {
                    //
                    // Lets try to plow on...
                    //
                    //
                    // Log
                    //
                    TRACE_CRIT("Analyze update returned error 0x%08lx, trying to continue...", (UINT)Status);
                    fConnectivityChange = TRUE;
                }
            }

            //
            // Check if there's a change in mode -- if so, we won't
            // add back IP addresses because of the potential of IP address
            // conflict.
            //
            {
                NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE tmOld, tmNew;
                tmOld = m_OldClusterConfig.GetTrafficMode();
                tmNew = m_NewClusterConfig.GetTrafficMode();
                fModeChange = (tmOld != tmNew);
            }

            fTakeOutVips = fConnectivityChange;
        }

        if (fTakeOutVips)
        {
            mfn_TakeOutVips();
            fResetIpList  = TRUE;
        }

        if (!m_NewClusterConfig.fBound)
        {
            // Unbind...
            mfn_Log(IDS_UNBINDING_NLB);
            Status =  CfgUtilChangeNlbBindState(m_szNicGuid, FALSE);
            if (FAILED(Status))
            {
                mfn_Log(IDS_UNBIND_FAILED);
            }
            else
            {
                mfn_Log(IDS_UNBIND_SUCCEEDED);
            }


            //
            // Sleep a bit to allow things to settle down after binding...
            //
            Sleep(4000);


            fResetIpList  = TRUE;
        }
    }
    else // We were previously unbound
    {
        
        if (m_NewClusterConfig.fBound)
        {
            // Before binding NLB, write the new NLB parameters to registry. This is
            // so that after the binding is completed, NLB will come up with the new 
            // NLB parameters. We are not checking the status of this operation 
            // because we are going to be doing this operation once again after the binding
            // is completed. We will fail only when the second attempt fails.
            CfgUtilRegWriteParams(m_szNicGuid, &m_NewClusterConfig.NlbParams);

            //
            // We need to bind.
            //
            // TODO: mfn_ZapUnboundSettings();
            mfn_Log(IDS_BINDING_NLB);
            Status =  CfgUtilChangeNlbBindState(m_szNicGuid, TRUE);
            if (FAILED(Status))
            {
                mfn_Log(IDS_BIND_FAILED);
            }
            else
            {
                mfn_Log(IDS_BIND_SUCCEEDED);
                fJustBound = TRUE;

                //
                // Let wait until we can read our config again...
                //
                // TODO: use constants here, see if there is a better
                // way to do this. We retry because if the NIC is
                // disconnected, we Bind returns, but GetConfig fails --
                // because the driver is not really started yet -- we need
                // to investigate why that is happening!
                //
                UINT MaxTry = 5;
                WBEMSTATUS TmpStatus = WBEM_E_CRITICAL_ERROR;
                for (UINT u=0;u<MaxTry;u++)
                {
                    //
                    // TODO: we put this in here really to work around
                    // the real problem, which is that NLB is not readyrequest
                    // right after bind completes. We need to fix that.
                    //
                    Sleep(4000);

                    // Check if the binding operation has completed by issuing a "query" to the NLB driver.
                    // This call will fail if the binding operation has NOT completed.
                    TmpStatus = CfgUtilControlCluster( m_szNicGuid, WLBS_QUERY, 0, 0, NULL, NULL );

                    if (!FAILED(TmpStatus)) break;

                    TRACE_INFO("CfgUtilControlCluster failed with %x after bind, retrying %d times", TmpStatus, (MaxTry - u));

                }
                if (FAILED(TmpStatus))
                {
                    Status = TmpStatus;
                    mfn_Log(IDS_ERROR_READING_CONFIG);
                    TRACE_CRIT("CfgUtilGetNlbConfig failed, returning %d", TmpStatus);
                }
                else
                {
                    mfn_Log(IDS_CLUSTER_CONFIG_STABLE);
                }
            }
            fResetIpList  = TRUE;
        }
    }

    if (FAILED(Status)) goto end;
    
    if (m_NewClusterConfig.fBound)
    {
        //
        // We should already be bound, so we change cluster properties
        // if required.
        //
        mfn_Log(IDS_MODIFY_CLUSTER_CONFIG);
        Status = CfgUtilSetNlbConfig(
                    m_szNicGuid,
                    &m_NewClusterConfig.NlbParams,
                    fJustBound
                    );
        if (FAILED(Status))
        {
            mfn_Log(IDS_MODIFY_FAILED);
        }
        else
        {
            mfn_Log(IDS_MODIFY_SUCCEEDED);
        }
    }

    if (FAILED(Status)) goto end;

    if (!fResetIpList)
    {
        //
        // Additionally check if there is a change in 
        // the before and after ip lists! We could get here for example of
        // we were previously unbound and remain unbound, but there is
        // a change in the set of IP addresses on the adapter.
        //

        INT NumOldAddresses = m_OldClusterConfig.NumIpAddresses;

        if ( m_NewClusterConfig.NumIpAddresses != NumOldAddresses)
        {
            fResetIpList = TRUE;
        }
        else
        {
            //
            // Check if there is a change in the list of ip addresses or
            // their order of appearance.
            //
            NLB_IP_ADDRESS_INFO *pOldIpInfo = m_OldClusterConfig.pIpAddressInfo;
            NLB_IP_ADDRESS_INFO *pNewIpInfo = m_NewClusterConfig.pIpAddressInfo;
            for (UINT u=0; u<NumOldAddresses; u++)
            {
                if (   _wcsicmp(pNewIpInfo[u].IpAddress, pOldIpInfo[u].IpAddress)
                    || _wcsicmp(pNewIpInfo[u].SubnetMask, pOldIpInfo[u].SubnetMask))
                {
                    fResetIpList = TRUE;
                    break;
                }
            }
        }
    }

    if (fResetIpList && !fModeChange)
    {

        mfn_Log(IDS_MODIFYING_IP_ADDR);

        //
        // 5/30/01 JosephJ Right after bind/unbind things are unsettled, so
        // we give things some time to stabilize.
        // TODO: Get to the bottom of this -- basically bind is returning
        // prematurely, and/or the enable/disable of the adapter is
        // having an effect that takes Tcpip some time to be able to
        // accept a change in the ip address list.
        //
        Sleep(5000);

        if (m_NewClusterConfig.NumIpAddresses!=0)
        {
            Status =  CfgUtilSetStaticIpAddresses(
                            m_szNicGuid,
                            m_NewClusterConfig.NumIpAddresses,
                            m_NewClusterConfig.pIpAddressInfo
                            );
        }
        else
        {
            Status =  CfgUtilSetDHCP(
                            m_szNicGuid
                            );
        }

        if (FAILED(Status))
        {
            mfn_Log(IDS_MODIFY_IP_ADDR_FAILED);
        }
        else
        {
            mfn_Log(IDS_MODIFY_IP_ADDR_SUCCEEDED);
        }
    }
    
end:

    if (FAILED(Status))
    {
        mfn_Log(
            IDS_UPDATE_FAILED,
            (UINT) Status
            );
    }
    else
    {
        mfn_Log(IDS_UPDATE_SUCCEEDED);
    }
    TRACE_INFO(L"<-%!FUNC!(Nic=%ws)", m_szNicGuid);
    m_CompletionStatus = Status;

}


VOID
NlbConfigurationUpdate::mfn_TakeOutVips(VOID)
{
    WBEMSTATUS Status;
    WLBS_REG_PARAMS *pParams = NULL;

    //
    // We keep the new ded ip address if possible, else the old, else nothing.
    //
    if (m_NewClusterConfig.fBound && !m_NewClusterConfig.IsBlankDedicatedIp())
    {
        pParams =  &m_NewClusterConfig.NlbParams;
    }
    else if (!m_OldClusterConfig.IsBlankDedicatedIp())
    {
        pParams =  &m_OldClusterConfig.NlbParams;
    }

    //
    // Stop the cluster.
    //
    mfn_Log(IDS_STOPPING_CLUSTER);
    Status = CfgUtilControlCluster(m_szNicGuid, WLBS_STOP, 0, 0, NULL, NULL); 
    if (FAILED(Status))
    {
        mfn_Log(IDS_STOP_FAILED, (UINT) Status);
    }
    else
    {
        mfn_Log(IDS_STOP_SUCCEEDED);
    }

    //
    // Take out all vips and add only the dedicated IP address (new if possible,
    // else old) if there is one.
    //
    if (pParams != NULL)
    {
        NLB_IP_ADDRESS_INFO IpInfo;
        ZeroMemory(&IpInfo, sizeof(IpInfo));
        StringCbCopy(IpInfo.IpAddress, sizeof(IpInfo.IpAddress), pParams->ded_ip_addr);
        StringCbCopy(IpInfo.SubnetMask, sizeof(IpInfo.SubnetMask), pParams->ded_net_mask);

        TRACE_INFO("Going to take out all addresses except dedicated address on %ws", m_szNicGuid);

        mfn_Log(IDS_REMOVING_CLUSTER_IPS);
        Status =  CfgUtilSetStaticIpAddresses(
                        m_szNicGuid,
                        1,
                        &IpInfo
                        );
    }
    else
    {
        TRACE_INFO("Going to take out ALL addresses on NIC %ws", m_szNicGuid);
        mfn_Log(IDS_REMOVING_STATIC_IPS);
        Status =  CfgUtilSetDHCP(
                        m_szNicGuid
                        );
    }

    //
    // 5/30/01 JosephJ Right after bind/unbind things are unsettled, so
    // we give things some time to stabilize.
    // TODO: Get to the bottom of this -- basically bind is returning
    // prematurely, and/or the enable/disable of the adapter is
    // having an effect that takes Tcpip some time to be able to
    // accept a change in the ip address list.
    //
    Sleep(1000);

    if (FAILED(Status))
    {
        mfn_Log(IDS_REMOVE_IP_FAILED);
    }
    else
    {
        mfn_Log(IDS_REMOVE_IP_SUCCEEDED);
    }
}


//
// Analyzes the nature of the update, mainly to decide whether or not
// we need to do the update asynchronously.
//
// Side effect: builds/modifies a list of IP addresses that need to be added on 
// the NIC. Also may munge some of the wlbsparm fields to bring them into
// canonical format.
// TODO This is duplicated from the one in cfgutils.lib -- get rid of this
// one!
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_AnalyzeUpdate(
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
    IN  BOOL *pConnectivityChange,
    IN  CLocalLogger &logger
    )
//
//    WBEM_S_FALSE -- update is a no-op.
//
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    NLBERROR nerr;

    sfn_Lock();

    nerr = m_OldClusterConfig.AnalyzeUpdate(
                pNewCfg,
                pConnectivityChange
                );

    switch(nerr)
    {

    case NLBERR_OK:
        Status = WBEM_NO_ERROR;
    break;

    case NLBERR_NO_CHANGE:
        Status = WBEM_S_FALSE;
    break;

    case NLBERR_RESOURCE_ALLOCATION_FAILURE:
        Status = WBEM_E_OUT_OF_MEMORY;
        logger.Log(IDS_RR_OUT_OF_SYSTEM_RES);
    break;

    case NLBERR_LLAPI_FAILURE:
        Status = WBEM_E_CRITICAL_ERROR;
        logger.Log(IDS_RR_UNDERLYING_COM_FAILED);
    break;


    case NLBERR_INITIALIZATION_FAILURE:
        Status = WBEM_E_CRITICAL_ERROR;
        logger.Log(IDS_RR_INIT_FAILURE);
    break;

    case NLBERR_INVALID_CLUSTER_SPECIFICATION:
        logger.Log(IDS_RR_INVALID_CLUSTER_SPEC);
        Status = WBEM_E_INVALID_PARAMETER;
    break;

    case NLBERR_INTERNAL_ERROR: // fall through...
    default:
        Status = WBEM_E_CRITICAL_ERROR;
        logger.Log(IDS_RR_INTERNAL_ERROR);
    break;

    }
    
    sfn_Unlock();

    return  Status;
}


VOID
NlbConfigurationUpdate::mfn_Log(
    UINT    Id,      // Resource ID of format,
    ...
    )
{
    DWORD   dwRet;
    WCHAR   wszFormat[NLBUPD_MAX_LOG_LENGTH];
    WCHAR   wszBuffer[NLBUPD_MAX_LOG_LENGTH];

    if (!LoadString(ghModule, Id, wszFormat, NLBUPD_MAX_LOG_LENGTH))
    {
        TRACE_CRIT("LoadString returned 0, GetLastError() : 0x%x, Could not log message !!!", GetLastError());
        return;
    }

    va_list arglist;
    va_start (arglist, Id);
    dwRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                          wszFormat, 
                          0, // Message Identifier - Ignored for FORMAT_MESSAGE_FROM_STRING
                          0, // Language Identifier
                          wszBuffer,
                          NLBUPD_MAX_LOG_LENGTH, 
                          &arglist);
    va_end (arglist);

    if (dwRet) 
    {
        mfn_LogRawText(wszBuffer);
    }
    else
    {
        TRACE_CRIT("FormatMessage returned error : %u, Could not log message !!!", dwRet);
    }
}


//
// Acquires the first global mutex, call this first.
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_AcquireFirstMutex(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    HANDLE hMtx1 = NULL;
    HANDLE hMtx2 = NULL;
    HANDLE hEvt  = NULL;
    BOOL    fMutexAcquired = FALSE;
    BOOL    fMutex1Abandoned = FALSE;
    BOOL    fMutex2Abandoned = FALSE;

    //
    // Locally open a handle to hMtx1 and acquire it.
    // This serializes access to  m_hmutex.
    //
    {
        hMtx1 = CreateMutex(
                    NULL, //  lpEventAttributes,
                    FALSE, // FALSE == not initial owner
                    NLB_CONFIGURATION_MUTEX_PREFIX
                    );
                                      
        TRACE_INFO(
            L"CreateMutex(%ws) returns 0x%p",
            NLB_CONFIGURATION_MUTEX_PREFIX,
            hMtx1
            );
    
        if (hMtx1 == NULL)
        {
            TRACE_CRIT("ERROR: CreateMutex returned NULL for Mutex1");
            goto end;
        }

        TRACE_INFO("Waiting for Mutex1...");
        DWORD dwRet = WaitForSingleObject(hMtx1, NLB_MUTEX_TIMEOUT);
        TRACE_INFO("Waiting for Mutex1 returns 0x%08lx", dwRet);
        if (dwRet == WAIT_ABANDONED)
        {
            TRACE_CRIT("WARNING: Mutex1 abandoned!");
            fMutex1Abandoned = TRUE;
        }
        else if (dwRet != WAIT_OBJECT_0)
        {
            TRACE_CRIT("Couldn't get Mutex1 -- probably busy elsewhere!");
            Status = WBEM_E_ALREADY_EXISTS;
            goto end;
        }
        fMutexAcquired = TRUE;
    }

    //
    // open handles to hMtx2 and hEvt
    //
    {
        WCHAR  M2Name[sizeof(NLB_CONFIGURATION_MUTEX_PREFIX)/sizeof(WCHAR) + NLB_GUID_LEN];
        StringCbCopy(M2Name, sizeof(M2Name), NLB_CONFIGURATION_MUTEX_PREFIX);
        StringCbCat(M2Name, sizeof(M2Name), m_szNicGuid);

        hMtx2 = CreateMutex(
                    NULL, //  lpEventAttributes,
                    FALSE, // FALSE == not initial owner
                    M2Name
                    );
                                      
        TRACE_INFO(
            L"CreateMutex(%ws) returns 0x%08p",
            M2Name,
            hMtx2
            );
    
        if (hMtx2 == NULL)
        {
            TRACE_CRIT("ERROR: CreateMutex returned NULL for Mutex2");
            goto end;
        }

        hEvt = CreateEvent(
                    NULL, //  lpEventAttributes,
                    TRUE, //  bManualReset TRUE==ManualReset
                    FALSE, // FALSE==initial state is not signaled.
                    NULL // NULL == no name
                    );
                                          
        TRACE_INFO(
            L"CreateEvent(<unnamed>) returns 0x%08p",
            hEvt
            );
        if (hEvt == NULL)
        {
            TRACE_CRIT("ERROR: CreateEvent returned NULL for unnamed hEvt");
            goto end;
        }

    }

    //
    // Acquire and immediately release 2nd mutex.
    // This is subtle but nevertherless important to do.
    // This is to ensure that there's no update pending -- some
    // other thread/process could be in the middle of an update, with
    // just hMtx2 held (not hMtx1). Since we've got hMtx1, once we do this
    // test we need not fear that hMtx2 will subsequently be taken by
    // anyone else as long as we keep hMtx1.
    //
    {
        TRACE_INFO("Waiting for Mutex2...");
        DWORD dwRet = WaitForSingleObject(hMtx2, NLB_MUTEX_TIMEOUT);
        TRACE_INFO("Waiting for Mutex2 returns 0x%08lx", dwRet);
        if (dwRet == WAIT_ABANDONED)
        {
            TRACE_CRIT("WARNING: Mutex2 abandoned!");
            fMutex2Abandoned = TRUE;
        }
        else if (dwRet != WAIT_OBJECT_0)
        {
            TRACE_CRIT("Couldn't get Mutex2 -- probably busy elsewhere!");
            Status = WBEM_E_ALREADY_EXISTS;
            goto end;
        }
        ReleaseMutex(hMtx2);

    }

    //
    // Lock s_Lock and save the 3 handles in m_hmutex. For now, fail if m_mmutex
    // contains non-NULL handles (could happen if thread died on previous 
    // invocation).
    //
    {
        sfn_Lock();
        
        if (    m_mutex.hMtx1!=NULL
            ||  m_mutex.hMtx2!=NULL
            ||  m_mutex.hEvt!=NULL
           )
        {
             TRACE_CRIT("%!FUNC! ERROR: m_mutex contains non-null handles.m1=0x%p; m2=0x%p; e=0x%p", m_mutex.hMtx1, m_mutex.hMtx2, m_mutex.hEvt);

             //
             // If we've found an abandoned mutex, we assume the saved handles
             // are abandoned and clean them up.
             //
             if (fMutex1Abandoned || fMutex2Abandoned)
             {
                TRACE_CRIT("%!FUNC! found abandoned mutex(es) so cleaning up handles in m_mutex");
                if (m_mutex.hMtx1 != NULL)
                {
                    CloseHandle(m_mutex.hMtx1);
                    m_mutex.hMtx1 = NULL;
                }
                if (m_mutex.hMtx2 != NULL)
                {
                    CloseHandle(m_mutex.hMtx2);
                    m_mutex.hMtx2 = NULL;
                }
                if (m_mutex.hEvt != NULL)
                {
                    CloseHandle(m_mutex.hEvt);
                    m_mutex.hEvt = NULL;
                }

                // We'll try to move on...
                TRACE_CRIT(L"Cleaning up state on receiving abandoned mutex and moving on...");
             }
             else
             {
             	TRACE_CRIT(L"Bailing because of bad mutex state");
             	sfn_Unlock();
                goto end;
             }
        }
        m_mutex.hMtx1 = hMtx1;
        m_mutex.hMtx2 = hMtx2;
        m_mutex.hEvt = hEvt;
        hMtx1 = NULL;
        hMtx2 = NULL;
        hEvt = NULL;

        sfn_Unlock();
    }

    Status = WBEM_NO_ERROR;

end:

    if (FAILED(Status))
    {
        if (fMutexAcquired)
        {
            ReleaseMutex(hMtx1);
        }

        if (hMtx1!=NULL)
        {
            CloseHandle(hMtx1);
            hMtx1=NULL;
        }
        if (hMtx2!=NULL)
        {
            CloseHandle(hMtx2);
            hMtx2=NULL;
        }
        if (hEvt!=NULL)
        {
            CloseHandle(hEvt);
            hEvt = NULL;
        }
    }

    return Status;
}


WBEMSTATUS
NlbConfigurationUpdate::mfn_ReleaseFirstMutex(
    BOOL fCancel
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    HANDLE hMtx1 = NULL;
    HANDLE hMtx2 = NULL;
    HANDLE hEvt  = NULL;

    //
    // Note -- this function is only called after mfn_AcquireFirstMutex,
    // which sets up the following handles. So these handles SHOULD all
    // be non-NULL -- else it's an internal fatal error (code bug).
    //
    sfn_Lock();
    hMtx1 = m_mutex.hMtx1;
    hMtx2 = m_mutex.hMtx2;
    hEvt  = m_mutex.hEvt;
    sfn_Unlock();

    if (hEvt == NULL || hMtx1==NULL || hMtx2==NULL)
    {
        ASSERT(!"NULL m_hmutex.hEvt or hMtx1 or hMtx2 unexpected!");
        TRACE_CRIT("ERROR: null hEvt or hMtx1 or hMtx2");
        goto end;
    }

    //
    // If (!fCancel) wait for event to be signalled.
    //
    if (!fCancel)
    {
        TRACE_INFO("Waiting for event 0x%p...", hEvt);
        (VOID) WaitForSingleObject(hEvt, INFINITE);
        TRACE_INFO("Done waiting for event 0x%p", hEvt);
    }

    //
    // Release first mutex and close the mutex and event handle
    //
    {
        sfn_Lock();

        if (hMtx1 != m_mutex.hMtx1 || hEvt  != m_mutex.hEvt)
        {
            ASSERT(FALSE);
            TRACE_CRIT("ERROR: %!FUNC!: hMtx1 or hEvt has changed!");
            sfn_Unlock();
            goto end;
        }

        if (fCancel)
        {
            if (hMtx2 == m_mutex.hMtx2)
            {
                m_mutex.hMtx2 = NULL;
                CloseHandle(hMtx2);
                hMtx2 = NULL;
            }
            else
            {
                ASSERT(FALSE);
                TRACE_CRIT("ERROR: %!FUNC!: hMtx2 has changed!");
            }
        }

        m_mutex.hMtx1 = NULL;
        m_mutex.hEvt = NULL;
        sfn_Unlock();

        ReleaseMutex(hMtx1);
        CloseHandle(hMtx1);
        hMtx1 = NULL;
        CloseHandle(hEvt);
        hEvt = NULL;
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}


//
// Acquire the 2nd mutex (could be called from a different thread
// than the one that called mfn_AcquireFirstMutex.
// Also signals an internal event which mfn_ReleaseFirstMutex may
// be waiting on.
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_AcquireSecondMutex(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    HANDLE hMtx1 = NULL;
    HANDLE hMtx2 = NULL;
    HANDLE hEvt  = NULL;

    //
    // Note -- this function is only called after mfn_AcquireFirstMutex,
    // which sets up the following handles. So these handles SHOULD all
    // be non-NULL -- else it's an internal fatal error (code bug).
    //
    sfn_Lock();
    hMtx1 = m_mutex.hMtx1;
    hMtx2 = m_mutex.hMtx2;
    hEvt  = m_mutex.hEvt;
    sfn_Unlock();

    if (hEvt == NULL || hMtx1==NULL || hMtx2==NULL)
    {
        ASSERT(!"NULL m_hmutex.hEvt or hMtx1 or hMtx2 unexpected!");
        TRACE_CRIT("ERROR: %!FUNC! null hEvt or hMtx1 or hMtx2");
        goto end;
    }


    //
    // Acquire 2nd mutex -- we're really guaranteed to get it immediately here
    //
    TRACE_INFO("Waiting for Mutex2...");
    DWORD dwRet = WaitForSingleObject(hMtx2, INFINITE);
    TRACE_INFO("Waiting for Mutex2 returns 0x%08lx", dwRet);
    if (dwRet == WAIT_ABANDONED)
    {
        TRACE_CRIT("WARNING: Mutex2 abandoned!");
    }

    //
    // Signal event, letting mfn_ReleaseFirstMutex know that
    // the 2nd mutex has been acquired.
    //
    SetEvent(hEvt);

    Status = WBEM_NO_ERROR;

end:

    return Status;
}


//
// Releases the second mutex.
//
WBEMSTATUS
NlbConfigurationUpdate::mfn_ReleaseSecondMutex(
    VOID
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    HANDLE hMtx2 = NULL;

    //
    // Note -- this function is only called after mfn_AcquireFirstMutex,
    // which sets up the following handles. So hMtx2
    // should be non-NULL -- else it's an internal fatal error (code bug).
    // hMtx1 and hEvt however could (typically would) be NULL.
    //
    //
    sfn_Lock();
    hMtx2 = m_mutex.hMtx2;
    m_mutex.hMtx2 = NULL;
    sfn_Unlock();

    if (hMtx2==NULL)
    {
        ASSERT(!"NULL hMtx2 unexpected!");
        TRACE_CRIT("ERROR: %!FUNC! null hMtx2");
        goto end;
    }
    //
    // Release 2nd mutex, close handle.
    // It's important to do this AFTER m_mutex.hMtx2 is cleared above.
    // Why? Because mfn_AcquireFirstMutex, after aquiring hMtx1 AND hMtx2,
    // then expects m_mutex to be all cleared.
    //
    ReleaseMutex(hMtx2);
    CloseHandle(hMtx2);
    hMtx2 = NULL;

    Status = WBEM_NO_ERROR;

end:

    return Status;
}

VOID NlbConfigurationUpdate::ReportStopEvent(
    const WORD wEventType,
    WCHAR **ppLog
    )
{
    TRACE_INFO("->");

    if (g_hEventLog == NULL)
    {
        TRACE_CRIT("Event log not opened or failed to open");
        TRACE_INFO("<-");
        return;
    }

    //
    // Log this to the system event log, WLBS source
    //
    WCHAR   wszStatus[NLBUPD_NUM_CHAR_WBEMSTATUS_AS_HEX];
    WCHAR   wszGenID[NLBUPD_MAX_NUM_CHAR_UINT_AS_DECIMAL];
    WCHAR   *pwszTruncatedLog = NULL;
    LPCWSTR pwszArg[4];

    StringCbPrintf(wszStatus, sizeof(wszStatus), L"0x%x", m_CompletionStatus);
    pwszArg[0] = wszStatus;

    StringCbPrintf(wszGenID , sizeof(wszGenID), L"%u"  , m_Generation);
    pwszArg[1] = wszGenID;

    pwszArg[2] = m_szNicGuid;

    //
    // TODO: Localize <empty> string
    //
    pwszArg[3] = L"<empty>"; // Initialize it just in case we have nothing to include
    if (ppLog != NULL)
    {
        //
        // The event log supports a max of 32K characters per argument. Take at most this much of ppLog if necessary.
        //
        UINT uiLogLen = wcslen(*ppLog);
        if (uiLogLen > NLBUPD_MAX_EVENTLOG_ARG_LEN)
        {
            TRACE_INFO(
                "NT Event argument max is %d characters and logging data contains %d. Truncate data to max",
                NLBUPD_MAX_EVENTLOG_ARG_LEN,
                uiLogLen
                );

            pwszTruncatedLog = new WCHAR[NLBUPD_MAX_EVENTLOG_ARG_LEN + 1];

            //
            // If memory allocation failed use the pre-initialized string
            //
            if (pwszTruncatedLog != NULL)
            {
                wcsncpy(pwszTruncatedLog, *ppLog, NLBUPD_MAX_EVENTLOG_ARG_LEN);
                pwszTruncatedLog[NLBUPD_MAX_EVENTLOG_ARG_LEN] = L'\0';
                pwszArg[3] = pwszTruncatedLog;
            }
            else
            {
                TRACE_CRIT("Memory allocation to hold truncated loggging data failed. Using the literal: %ls", pwszArg[3]);
            }
        }
        else
        {
            pwszArg[3] = *ppLog;
        }
    }

    //
    // Note that ReportEvent can fail. Ignore return code as we make best effort only
    //
    ReportEvent (g_hEventLog,                        // Handle to event log
                 wEventType,                         // Event type
                 0,                                  // Category
                 MSG_UPDATE_CONFIGURATION_STOP,      // MessageId
                 NULL,                               // Security identifier
                 4,                                  // Num args to event string
                 0,                                  // Size of binary data
                 pwszArg,                            // Ptr to args for event string
                 NULL);                              // Ptr to binary data

    if (pwszTruncatedLog != NULL)
    {
        delete [] pwszTruncatedLog;
    }

    TRACE_INFO("<-");
}

VOID NlbConfigurationUpdate::ReportStartEvent(
    LPCWSTR szClientDescription
    )
{
    TRACE_INFO("<-");

    if (g_hEventLog == NULL)
    {
        TRACE_CRIT("Event log not opened or failed to open");
        TRACE_INFO("<-");
        return;
    }

    //
    // Log to this to the system event log, WLBS source
    //
    WCHAR   wszGenID[NLBUPD_MAX_NUM_CHAR_UINT_AS_DECIMAL];
    LPCWSTR pwszArg[3];

    pwszArg[0] = szClientDescription;
    if (pwszArg[0] == NULL)
    {
        TRACE_INFO("No client description provided. Using empty string in NT event.");
        pwszArg[0] = L"";
    }

    StringCbPrintf(wszGenID, sizeof(wszGenID), L"%u", m_Generation);
    pwszArg[1] = wszGenID;

    pwszArg[2] = m_szNicGuid;

    //
    // Note that ReportEvent can fail. Ignore return code as we make best effort only
    //
    ReportEvent (g_hEventLog,                        // Handle to event log
                 EVENTLOG_INFORMATION_TYPE,          // Event type
                 0,                                  // Category
                 MSG_UPDATE_CONFIGURATION_START,     // MessageId
                 NULL,                               // Security identifier
                 3,                                  // Num args to event string
                 0,                                  // Size of binary data
                 pwszArg,                            // Ptr to args for event string
                 NULL);                              // Ptr to binary data

    TRACE_INFO("<-");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\updatecfg.h ===
//***************************************************************************
//
//  UPDATECFG.H
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Defines class NlbConfigurationUpdate, used for 
//           async update of NLB properties associated with a particular NIC.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************
//
// The header of a completion header stored as a REG_BINARY value in
// the registry.
//
typedef struct {
    UINT Version;
    UINT Generation;        // Redundant, used for internal consistancy check
    UINT CompletionCode;
    UINT Reserved;
} NLB_COMPLETION_RECORD, *PNLB_COMPLETION_RECORD;

#define NLB_CURRENT_COMPLETION_RECORD_VERSION  0x3d7376e2

//
// Prefix of the global event name used to control update access to the specifed
// NIC.
// Mutex1 has format: <prefix>
// Mutex2 has format: <prefix><NicGuid>
// Example mutex1 name: NLB_D6901862
// Example mutex2 name: NLB_D6901862{EBE09517-07B4-4E88-AAF1-E06F5540608B}
//
// The value "D6901862" is a random number.
//
#define NLB_CONFIGURATION_EVENT_PREFIX L"NLB_D6901862"
#define NLB_CONFIGURATION_MUTEX_PREFIX L"NLB_D6901863"

//
// Milliseconds to wait before giving up on trying to acquire the
// NLB mutex.
//
#define NLB_MUTEX_TIMEOUT 100

//
// The maximum generation difference between the oldest valid completion
// record and the current one. Records older then the oldest valid record
// are subject to pruning.
//
#define NLB_MAX_GENERATION_GAP  10

// Handle to dll - used in call to LoadString
extern HMODULE ghModule;



//
// Used for maintaining a log on the stack. 
// Usage is NOT thread-safe -- each instance must be used
// by a single thread.
// 01/01/02 JosephJ Copied over from NLBMGR.EXE (nlbmgr\exe2)
//
class CLocalLogger
{
    public:
    
        CLocalLogger(VOID)
        :  m_pszLog (NULL), m_LogSize(0), m_CurrentOffset(0)
        {
            m_Empty[0] = 0; // The empty string.
        }
        
        ~CLocalLogger()
        {
            delete[] m_pszLog;
            m_pszLog=NULL;
        }
    

        VOID
        Log(
            IN UINT ResourceID,
            ...
        );

        
    
        VOID
        ExtractLog(OUT LPCWSTR &pLog, UINT &Size)
        //
        // pLog --  set to pointer to internal buffer if there is stuff in the
        //          log, otherwise NULL.
        //
        // Size -- in chars; includes ending NULL
        //
        {
            if (m_CurrentOffset != 0)
            {
                pLog = m_pszLog;
                Size = m_CurrentOffset+1; // + 1 for ending NULL.
            }
            else
            {
                pLog = NULL;
                Size = 0;
            }
        }

        LPCWSTR
        GetStringSafe(void)
        {
            LPCWSTR szLog = NULL;
            UINT Size;
            ExtractLog(REF szLog, REF Size);
            if (szLog == NULL)
            {
                //
                // Replace NULL by a pointer to an empty string.
                //
                szLog = m_Empty;
            }

            return szLog;
        }

    private:
    
    WCHAR *m_pszLog;
    UINT m_LogSize;       // Current size of the log.
    UINT m_CurrentOffset;     // Characters left in the log.
    WCHAR m_Empty[1];  // The empty string.
};



class NlbConfigurationUpdate
{
public:
    
    //
    // Static initialization function -- call in process-attach
    //
    static
    VOID
    StaticInitialize(
        VOID
        );

    //
    // Static deinitialization function -- call in process-detach
    //
    static
    VOID
    StaticDeinitialize(
        VOID
        );
    
    //
    // Stop accepting new queries, wait for existing (pending) queries 
    // to complete.
    //
    static
    VOID
    PrepareForDeinitialization(
        VOID
        );

    //
    // Return true IFF there is no pending activity. If you return
    // TRUE, try not to start new pending activity.
    //
    static
    BOOL
    CanUnloadNow(
        VOID
        );
    
    //
    // Returns the current configuration on  the specific NIC.
    //
    static
    WBEMSTATUS
    GetConfiguration(
        IN  LPCWSTR szNicGuid,
        OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    );

    //
    // Called to initiate update to a new cluster state on that NIC. This
    // could include moving from a NLB-bound state to the NLB-unbound state.
    // *pGeneration is used to reference this particular update request.
    //
    static
    WBEMSTATUS
    DoUpdate(
        IN  LPCWSTR szNicGuid,
        IN  LPCWSTR szClientDescription,
        IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
        OUT UINT   *pGeneration,
        OUT WCHAR  **ppLog                   // free using delete operator.
    );
    /*++
        ppLog   -- will point to a NULL-terminated string which contains
        any messages to be displayed to the user. The string may contain
        embedded (WCHAR) '\n' characters to delimit lines. 

        NOTE: ppLog will be filled out properly EVEN ON FAILURE. If non-null
        it must be deleted by the caller.
    --*/


    //
    // Called to get the status of an update request, identified by
    // Generation.
    //
    static
    WBEMSTATUS
    GetUpdateStatus(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation,
        IN  BOOL    fDelete,                // Delete record if it exists
        OUT WBEMSTATUS  *pCompletionStatus,
        OUT WCHAR  **ppLog                   // free using delete operator.
        );

    static
    DWORD
    WINAPI
    s_AsyncUpdateThreadProc(
        LPVOID lpParameter   // thread data
        );

    
private:


///////////////////////////////////////////////////////////////////////////////
//
//          S T A T I C         S T U F F
//
///////////////////////////////////////////////////////////////////////////////
    //
    // A single static lock serialzes all access.
    // Use sfn_Lock and sfn_Unlock.
    //
    static
    CRITICAL_SECTION s_Crit;

    static
    BOOL
    s_fStaticInitialized; // set to true once StaticInitialize is called.

    static
    BOOL
    s_fInitialized;    // Set to true if we're in the position to 
                       // handle any *new* update requests or even queries.
                       // Will be set to false if we're in the process
                       // of de-initializing.

    //
    // Global list of current updates, one per NIC.
    //
    static
    LIST_ENTRY
    s_listCurrentUpdates;
    
    static
    VOID
    sfn_Lock(
        VOID
        )
    {
        EnterCriticalSection(&s_Crit);
    }

    static
    VOID
    sfn_Unlock(
        VOID
        )
    {
        LeaveCriticalSection(&s_Crit);
    }

    //
    // Looks up the current update for the specific NIC.
    // We don't bother to reference count because this object never
    // goes away once created -- it's one per unique NIC GUID for as long as
    // the DLL is loaded (may want to revisit this).
    //
    //
    static
    WBEMSTATUS
    sfn_LookupUpdate(
        IN  LPCWSTR szNic,
        IN  BOOL    fCreate, // Create if required
        OUT NlbConfigurationUpdate ** ppUpdate
        );

    //
    // Save the specified completion status to the registry.
    //
    static
    WBEMSTATUS
    sfn_RegSetCompletion(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation,
        IN  WBEMSTATUS    CompletionStatus
        );

    //
    // Retrieve the specified completion status from the registry.
    //
    static
    WBEMSTATUS
    sfn_RegGetCompletion(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation,
        OUT WBEMSTATUS  *pCompletionStatus,
        OUT WCHAR  **ppLog                   // free using delete operator.
        );

    //
    // Delete the specified completion status from the registry.
    //
    static
    VOID
    sfn_RegDeleteCompletion(
        IN  LPCWSTR szNicGuid,
        IN  UINT    Generation
        );

    //
    // Create the specified subkey key (for r/w access) for the specified
    // the specified NIC.
    //
    static
    HKEY
    sfn_RegCreateKey(
        IN  LPCWSTR szNicGuid,
        IN  LPCWSTR szSubKey,
        IN  BOOL    fVolatile,
        OUT BOOL   *fExists
        );

    //
    // Open the specified subkey key (for r/w access) for the specified
    // the specified NIC.
    //
    static
    HKEY
    sfn_RegOpenKey(
        IN  LPCWSTR szNicGuid,
        IN  LPCWSTR szSubKey
        );

    static
    VOID
    sfn_ReadLog(
        IN  HKEY hKeyLog,
        IN  UINT Generation,
        OUT LPWSTR *ppLog
        );


    static
    VOID
    sfn_WriteLog(
        IN  HKEY hKeyLog,
        IN  UINT Generation,
        IN  LPCWSTR pLog,
        IN  BOOL    fAppend
        );

///////////////////////////////////////////////////////////////////////////////
//
//          P E R   I N S T A N C E     S T U F F
//
///////////////////////////////////////////////////////////////////////////////

    //
    // Used in the global one-per-NIC  list of updates maintained in
    // s_listCurrentUpdates;
    //
    LIST_ENTRY m_linkUpdates;

    #define NLB_GUID_LEN 38
    #define NLB_GUID_STRING_SIZE  40 // 38 for the GUID plus trailing NULL + pad
    WCHAR   m_szNicGuid[NLB_GUID_STRING_SIZE]; // NIC's GUID in  text form

    LONG    m_RefCount;

    typedef enum
    {
        UNINITIALIZED,       // IDLE -- no ongoing updates
        IDLE,               // IDLE -- no ongoing updates
        ACTIVE              // There is an ongoing update

    } MyState;

    MyState m_State;

    //
    // Following mutexes are used to ensure that only a single concurrent
    // update can happen per NIC.
    //
    struct
    {
        HANDLE hMtx1;     // Mutex handle; Obtained 1st
        HANDLE hMtx2;     // Mutex handle; Obtained 2nd, then hMtx1 is released.
        HANDLE hEvt;       // Unnamed evt, signaled when hMtx2 is obtained.

    } m_mutex;

    //
    // The following fields are valid only when the state is ACTIVE
    //
    UINT m_Generation;      // Current generation count
    #define NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH 64
    WCHAR   m_szClientDescription[NLBUPD_MAX_CLIENT_DESCRIPTION_LENGTH+1];
    DWORD   m_AsyncThreadId; // Thread doing async config update operation.
    HANDLE  m_hAsyncThread;  // ID of above thread.
    HKEY    m_hCompletionKey; // Key to the registry where
                            // completions are stored

    //
    // A snapshot of the cluster configuration state at the start
    // of the update BUG -- can this be zeromemoried?
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION m_OldClusterConfig;

    //
    // The requested final state
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION m_NewClusterConfig;


    //
    // Completion status of the current update.
    // Could be PENDING.
    //
    WBEMSTATUS m_CompletionStatus;


    //
    // END -- of fields that are valid only when the state is ACTIVE
    //


    //
    // Constructor and destructor --  note that these are private
    // In fact, the constructor is only called from sfn_LookupUpdate
    // and the destructor from mfn_Dereference.
    //
    NlbConfigurationUpdate(VOID);
    ~NlbConfigurationUpdate();

    //
    // Try to acquire the machine-wide
    // NLB configuration update event for this NIC, and create the
    // appropriate keys in the registry to track this update.
    // NOTE: ppLog will be filled out EVEN ON FAILURE -- it should always
    // be deleted by the caller (using the delete operator) if non-NULL.
    //
    WBEMSTATUS
    mfn_StartUpdate(
        IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
        IN  LPCWSTR                            szClientDescription,
        OUT BOOL                               *pfDoAsync,
        OUT WCHAR **                           ppLog
        );

    //
    // Increment ref count. Object stays alive as long as refcount is nonzero.
    //
    VOID
    mfn_Reference(
        VOID
        );

    //
    // Decrement ref count. Object is deleted when refcount goes to zero.
    //
    VOID
    mfn_Dereference(
        VOID
        );
    //
    // Release the machine-wide update event for this NIC, and delete any
    // temporary entries in the registry that were used for this update.
    // ppLog must be deleted by caller useing the delete operator.
    //
    VOID
    mfn_StopUpdate(
        OUT WCHAR **                           ppLog
        );

    //
    // Looks up the completion record identified by Generation, for
    // specific NIC (identified by *this).
    // 
    //
    BOOL
    mfn_LookupCompletion(
        IN  UINT Generation,
        OUT PNLB_COMPLETION_RECORD *pCompletionRecord
        );

    //
    // Uses various windows APIs to fill up the current extended cluster
    // information for a specific nic (identified by *this).
    // It fills out pNewCfg.
    // The pNewCfg->field is set to TRUE IFF there were
    // no errors trying to fill out the information.
    //
    //
    WBEMSTATUS
    mfn_GetCurrentClusterConfiguration(
        OUT  PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
        );

    //
    // Analyzes the nature of the update, mainly to decide whether or not
    // we need to do the update asynchronously.
    // This also performs parameter validation.
    //
    WBEMSTATUS
    mfn_AnalyzeUpdate(
        IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewCfg,
        IN  BOOL *pDoAsync,
        IN  CLocalLogger &logger
        );

    //
    // Does the update synchronously -- this is where the meat of the update
    // logic exists. It can range from a NoOp, through changing the
    // fields of a single port rule, through binding NLB, setting up cluster
    // parameters and adding the relevant IP addresses in TCPIP.
    //
    VOID
    mfn_ReallyDoUpdate(
        VOID
        );

    VOID
    mfn_Log(
        UINT    Id,      // Resource ID of format,
        ...
        );

    VOID
    mfn_LogRawText(
        LPCWSTR szText
        );

    //
    // Stop the current cluster and take out its vips.
    //
    VOID
    mfn_TakeOutVips(
        VOID
        );

    //
    // Acquires the first global mutex, call this first.
    //
    WBEMSTATUS
    mfn_AcquireFirstMutex(
        VOID
        );

    //
    // If (fCancel) it releases the first mutex mutex and clears up handles
    //              to 2nd mutex and evt.
    // else it will wait until it receives signal that the 2nd mutex is
    // acquired, and then clears up only the 1st mutex handle.
    //
    WBEMSTATUS
    mfn_ReleaseFirstMutex(
        BOOL fCancel
        );

    //
    // Acquire the 2nd mutex (could be called from a different thread
    // than the one that called mfn_AcquireFirstMutex.
    // Also signals an internal event which mfn_ReleaseFirstMutex may
    // be waiting on.
    //
    WBEMSTATUS
    mfn_AcquireSecondMutex(
        VOID
        );

    //
    // Releases the second mutex.
    //
    WBEMSTATUS
    mfn_ReleaseSecondMutex(
        VOID
        );

    //
    // Writes an NT event when the update is stopping
    //
    VOID
    ReportStopEvent(
        const WORD wEventType,
        WCHAR **ppLog
        );

    //
    // Writes an NT event when the update is starting
    //
    VOID
    ReportStartEvent(
        LPCWSTR szClientDescription
        );
};

VOID
test_port_rule_string(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\tprov.h ===
#include "private.h"
#include "winsock2.h"
#include "nlbclient.h"
void test_tmgr(int argc, WCHAR* argv[]);

using namespace std;
extern BOOL g_Silent;

#define REF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\tprov.cpp ===
/*++ Copyright(c) 2001  Microsoft Corporation
Module Name:

    NLB Manager

File Name:

    tprov.cpp

Abstract:

    Test harness for nlb manager provider code

History:

    04/08/01    JosephJ Created

--*/

#include "tprov.h"
#include "tprov.tmh"

BOOL g_Silent = FALSE;
HANDLE g_hEventLog = NULL; // defined here to get ..\updatecf.cpp to link ok.
BOOL g_Impersonate=FALSE;
int g_nRetCode = 0; // return code for this program.
#define RETCODE_NO_ERROR 0
#define RETCODE_UPDATE_FAILED 1
#define RETCODE_NEW_CONFIG_DOESNT_MATCH 2
    
HMODULE ghModule;

void test_alignment(void);
void test_local_logger(void);
void test_encrypt_memory(void);

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    );

#define ARRAY_LENGTH(_array) (sizeof(_array)/sizeof(_array[0]))

typedef enum 
{
    DO_USAGE,
    DO_WMINICLIST,
    DO_NICLIST,
    DO_IPADDR,
    DO_NLBCFG,
    DO_NLBBIND,
    DO_UPDATE,
    DO_WMIUPDATE,
    DO_CLEANREG

} COMMAND_TYPE;

typedef enum 
{
    KW_ADAPTER_LIST,
    KW_UPDATE,
    KW_QUIT,
    KW_HELP,
    KW_ADAPTER_GUID,
    KW_NETWORK_ADDRESSES,
    KW_PARTIAL_UPDATE,
    KW_NLB_BOUND,
    KW_CLUSTER_NETWORK_ADDRESS,
    KW_CLUSTER_NAME,
    KW_TRAFFIC_MODE,
    KW_PORT_RULES,
    KW_HOST_PRIORITY,
    KW_DEDICATED_NETWORK_ADDRESS,
    KW_CLUSTER_MODE_ON_START,
    KW_PERSIST_SUSPEND_ON_REBOOT,
    KW_REMOTE_CONTROL_ENABLED,
    KW_PASSWORD,
    KW_LIST,
    KW_DOT,

    KW_MODIFY_NETWORK_ADDRESS,

    KW_IPADDR,      // test command
    KW_NLBBIND,     // test command
    KW_NLBCFG,      // test command

    KW_YES,
    KW_NO,


    //
    // Control cluster/port related
    //
    KW_CONTROL,
    KW_START,
    KW_STOP,
    KW_DRAIN_STOP,
    KW_SUSPEND,
    KW_RESUME,
    KW_ENABLE,
    KW_DISABLE,
    KW_DRAIN,
    KW_QUERY,
    KW_VIP,
    KW_PORT,



    KW_MAIN_SHELL,  // implicit keyword if no command present in cmdline.

    KW_UNKNOWN

} KEYWORD;

VOID do_usage(VOID);
VOID do_niclist(LPCWSTR szFriendlyName, LPWSTR *pszGuid);
VOID do_wminiclist(LPCWSTR szFriendlyName, LPWSTR *pszGuid);
VOID do_ipaddr(VOID);
VOID do_nlbcfg(VOID);
VOID do_nlbbind(VOID);
VOID do_update(VOID);
VOID do_wmiupdate(VOID);
VOID do_cleanreg(VOID);
void parse_main(int argc, WCHAR* argv[]);

VOID test_add_ips(LPCWSTR szNic);
VOID test_bind_nlb(LPCWSTR szNic);
VOID test_cfg_nlb(LPCWSTR szNic);
VOID test_update(LPCWSTR szMachine, LPCWSTR szNic);
void test(int argc, WCHAR* argv[]);
void test(int argc, WCHAR* argv[]);
void test_safearray(void);
VOID test_exfcfgclass(void);
void test_read_keyword(void);
VOID test_port_rule_string(VOID);
void    test_vectors(void);
void    test_maps(void);
void    test_validate_network_address(void);
void test_nlbipaddresslist(void);
void test_ioctl_alignment(void);

BOOL read_guid(LPWSTR *pszNic);
BOOL read_machinename(LPWSTR *pszNic);
BOOL read_password(VOID);
BOOL get_guid_by_friendly_name(VOID);

BOOL valid_guid(LPCWSTR szGuid);

KEYWORD
parse_args(int argc, WCHAR* argv[]);

typedef struct
{
    KEYWORD kw;
    LPCWSTR sz;

} KEYWORD_MAP;

const KEYWORD_MAP KeywordMap[] =
{
    {KW_ADAPTER_LIST,   L"AdapterList"},
    {KW_ADAPTER_LIST,   L"AL"},
    {KW_QUIT,           L"Quit"},
    {KW_QUIT,           L"Q"},
    {KW_UPDATE,         L"Update"},
    {KW_UPDATE,         L"U"},
    {KW_HELP,           L"Help"},
    {KW_HELP,           L"H"},
    {KW_HELP,           L"?"},
    {KW_ADAPTER_GUID,   L"AdapterGuid"},
    {KW_ADAPTER_GUID,   L"AG"},
    {KW_NETWORK_ADDRESSES,          L"NetworkAddresses"},
    {KW_NETWORK_ADDRESSES,          L"NA"},
    {KW_PARTIAL_UPDATE,             L"PartialUpdate"},
    {KW_PARTIAL_UPDATE,             L"PU"},
    {KW_NLB_BOUND,      L"NlbBound"},
    {KW_NLB_BOUND,      L"NB"},
    {KW_CLUSTER_NETWORK_ADDRESS,    L"ClusterNetworkAddress"},
    {KW_CLUSTER_NETWORK_ADDRESS,    L"CNA"},
    {KW_CLUSTER_NAME,   L"ClusterName"},
    {KW_CLUSTER_NAME,   L"CN"},
    {KW_TRAFFIC_MODE,   L"TrafficMode"},
    {KW_TRAFFIC_MODE,   L"TM"},
    {KW_PORT_RULES,     L"PortRules"},
    {KW_PORT_RULES,     L"PR"},
    {KW_HOST_PRIORITY,  L"HostPriority"},
    {KW_HOST_PRIORITY,  L"HP"},
    {KW_DEDICATED_NETWORK_ADDRESS,  L"DedicatedNetworkAddress"},
    {KW_DEDICATED_NETWORK_ADDRESS,  L"DNA"},
    {KW_CLUSTER_MODE_ON_START,      L"ClusterModeOnStart"},
    {KW_CLUSTER_MODE_ON_START,      L"CMOS"},
    {KW_PERSIST_SUSPEND_ON_REBOOT,  L"PersistSuspend"},
    {KW_PERSIST_SUSPEND_ON_REBOOT,  L"PS"},
    {KW_REMOTE_CONTROL_ENABLED,     L"RemoteControlEnabled"},
    {KW_REMOTE_CONTROL_ENABLED,     L"RCE"},
    {KW_PASSWORD,       L"Password"},
    {KW_PASSWORD,       L"P"},
    {KW_LIST,           L"List"},
    {KW_LIST,           L"L"},
    {KW_DOT,            L"."},

    {KW_MODIFY_NETWORK_ADDRESS, L"ModifyNetworkAddress"},
    {KW_MODIFY_NETWORK_ADDRESS, L"MNA"},

    {KW_IPADDR,         L"ipaddr"},      // test command -- only cmdline param
    {KW_NLBBIND,        L"nlbbind"},     // test command -- only cmdline param
    {KW_NLBCFG,         L"nlbcfg"},      // test command -- only cmdline param

    {KW_YES,            L"yes"},
    {KW_YES,            L"y"},
    {KW_NO,             L"no"},
    {KW_NO,             L"n"},

    //
    // Control cluster/port related
    //
    {KW_CONTROL, L"control"},
    {KW_CONTROL, L"cl"},
    {KW_START, L"start"},
    {KW_START, L"st"},
    {KW_STOP, L"stop"},
    {KW_STOP, L"sp"},
    {KW_DRAIN_STOP, L"drainstop"},
    {KW_DRAIN_STOP, L"ds"},
    {KW_SUSPEND, L"suspend"},
    {KW_SUSPEND, L"su"},
    {KW_RESUME, L"resume"},
    {KW_RESUME, L"re"},
    {KW_ENABLE, L"enable"},
    {KW_ENABLE, L"en"},
    {KW_DISABLE, L"disable"},
    {KW_DISABLE, L"di"},
    {KW_DRAIN, L"drain"},
    {KW_DRAIN, L"dn"},
    {KW_QUERY, L"query"},
    {KW_QUERY, L"qu"},
    {KW_VIP, L"vip"},
    {KW_PORT, L"port"},

    {KW_UNKNOWN, NULL} // Must be last
};

KEYWORD parse_adapter_list(VOID);
KEYWORD parse_update(VOID);
KEYWORD parse_main_help(VOID);
KEYWORD lookup_keyword(LPCWSTR szKeyword);

struct
{
    // *_LENGTH ==> doesn't include space for ending NULL

    #define MAX_MACHINE_NAME_LENGTH 256
    #define MAX_USER_NAME_LENGTH 256
    #define MAX_PASSWORD_LENGTH 256
    #define INPUT_BUFFER_LENGTH 1024
    #define NLB_MAX_FRIENDLY_NAME_LENGTH 256

    WCHAR MachineName[MAX_MACHINE_NAME_LENGTH+1];
    WCHAR UserName[MAX_USER_NAME_LENGTH+1];
    WCHAR Password[MAX_PASSWORD_LENGTH+1];
    WCHAR InputBuffer[INPUT_BUFFER_LENGTH+1];
    WCHAR AdapterGuid[NLB_GUID_STRING_SIZE];
    WCHAR FriendlyName[NLB_MAX_FRIENDLY_NAME_LENGTH+1];

    BOOL fReadPassword;
    BOOL fUseWmi;
    BOOL fLocalHost;
    BOOL fGotGuid;
    BOOL fGotFriendlyName;
    BOOL fRunOnce;

} g;
void
display_config(
    LPCWSTR szNicGuid,
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    );

void
display_port_rules(
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    );

void
display_config2(
    LPCWSTR szNicGuid,
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    );

VOID
display_ip_info(
    IN  UINT NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    );
VOID
display_ip_info2(
    IN  UINT NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    );

WBEMSTATUS
read_ip_info(
    IN  LPCWSTR             szNic,
    OUT UINT                *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo
    );


BOOL
WINAPI
MyCtrlHandlerRoutine(
  DWORD dwCtrlType   //  control signal type
)
{
    //
    // We de-initialize here so that we don't get an AV when the user types
    // CtrlC
    //
    CfgUtilDeitialize();

    return FALSE;
}



int __cdecl wmain(int argc, WCHAR* argv[], WCHAR* envp[])
{


    (void) SetConsoleCtrlHandler(
            MyCtrlHandlerRoutine,  // handler function
            TRUE // TRUE== add
            );

    //
    // Enable tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB\\TPROV");

    ghModule = GetModuleHandle(NULL);

#if 0
    test_encrypt_memory();
    // test_local_logger();
    // test_alignment();
    // test_port_rule_string();
    // test_safearray();
    // test_tmgr(argc, argv);
    // test_exfcfgclass();
    // test_vectors();
    // test_maps();
    // test_validate_network_address();
    // test_read_keyword();
    // test_nlbipaddresslist();
    // test_ioctl_alignment();
#else
    // NlbHostFake();

    //
    // Enable the "SeLoadDriverPrivilege" privilege in the process access token.
    // This is needed in the case when the server is local (ie. same machine).
    // Do NOT check for the return value since this function will fail when called 
    // as a non-admin. It is not only ok but also necessary to ignore the failure of
    // this function because: 
    // 1. We already check in the wmi provider that the caller is an administrator on
    //    the server and if the privilege is enabled. This is why it is ok to ignore 
    //    failures in this function.
    // 2. Non-admins can run nlb manager. They only need to be admins on the server.
    //    This is why it is necessary to ignore failures in this function.
    //
    CfgUtils_Enable_Load_Unload_Driver_Privilege();

    CfgUtilInitialize(
            TRUE,           // TRUE == init as server (use wlbsctrl apis if pos)
            FALSE           // FALSE == Do not disable Ping (i.e, enable ping)
            );
    NlbConfigurationUpdate::StaticInitialize();
    parse_main(argc, argv);
    NlbConfigurationUpdate::PrepareForDeinitialization();
    NlbConfigurationUpdate::StaticDeinitialize();
    CfgUtilDeitialize();
#endif

    //
    // Disable tracing
    //
    WPP_CLEANUP();

    return g_nRetCode;
}


NLB_EXTENDED_CLUSTER_CONFIGURATION MyOldCfg;
NLB_EXTENDED_CLUSTER_CONFIGURATION MyNewCfg;

VOID
display_log(WCHAR *pLog)
{
    static UINT previous_length;
    UINT current_length;
    current_length = wcslen(pLog);
    if (previous_length > current_length)
    {
        previous_length = 0;
    }

    wprintf(L"%ws", pLog+previous_length);

    previous_length = current_length;
}


LPCWSTR NicGuids[]  = {
    L"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}",
    L"{B2CD5533-5091-4F49-B80F-A07844B14209}",
    L"{EBE09517-07B4-4E88-AAF1-E06F5540608B}",
    L"{ABEA4318-5EE8-4DEC-AF3C-B4AEDE61454E}",
    L"{66A1869A-BF85-4D95-BBAB-07FA5B4449D4}",
    L"{AEEE83AF-AA48-4599-94BB-7C458D63CEED}",
    L"{D0536EEE-2CE0-4E8D-BFEC-0A608CFD81B9}"
};

UINT Trial;

void test(int argc, WCHAR* argv[])
{
    KEYWORD cmd;
    cmd = parse_args(argc, argv);

    switch(cmd)
    {
    case KW_UNKNOWN: do_usage();
         break;

    case KW_ADAPTER_LIST: do_niclist(NULL, NULL);
         break;

    case KW_IPADDR: do_ipaddr();
         break;
    case KW_NLBCFG: do_nlbcfg();
         break;
    case KW_NLBBIND: do_nlbbind();
         break;
    case KW_UPDATE: do_update();
         break;

#if 0
    case KW_WMINICLIST: do_wminiclist(NULL, NULL);
         break;
    case KW_WMIUPDATE: do_wmiupdate();
         break;
    case KW_CLEANREG: do_cleanreg();
         break;
#endif // 0
    }

    return;

}


void
display_config(
    LPCWSTR szNicGuid,
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    )
{
    LPWSTR szFriendlyName = NULL;
    if (g_Silent) return;

    WBEMSTATUS Status;

    Status = pCfg->GetFriendlyName(&szFriendlyName);

    if (FAILED(Status))
    {
        szFriendlyName = NULL;
    }
    printf(
        "\nNLB Configuration for %ws \"%ws\" %ws\n",
        szNicGuid,
        (szFriendlyName == NULL) ? L"" :  szFriendlyName,
        pCfg->fDHCP ?  L"(DHCP)" : L""
        );

    printf("\tfValidNlbCfg=%d\n", pCfg->fValidNlbCfg);
    printf("\tGeneration=%d\n", pCfg->Generation);
    printf("\tfBound=%d\n", pCfg->fBound);
    printf("\tfAddDedicatedIp=%d\n", pCfg->fAddDedicatedIp);
    
    UINT AddrCount = pCfg->NumIpAddresses;
    display_ip_info(AddrCount, pCfg->pIpAddressInfo);

    if (pCfg->fBound)
    {
        printf("\n");
        printf("\tNLB configuration:\n");
        if (pCfg->fValidNlbCfg)
        {
            printf("\t\tClusterIP: {%ws,%ws}\n",
                pCfg->NlbParams.cl_ip_addr,
                pCfg->NlbParams.cl_net_mask
                );
            printf("\t\tDedicatedIP: {%ws,%ws}\n",
                pCfg->NlbParams.ded_ip_addr,
                pCfg->NlbParams.ded_net_mask
                );
        }
        else
        {
            printf("**invalid configuration**\n");
        }
    }
    printf("\n");
    

    delete szFriendlyName;
    szFriendlyName = NULL;

    return;

}

LPCWSTR bool_string(BOOL b)
{
    return b ? L"true" : L"false";
}


void
display_config2(
    LPCWSTR szNicGuid,
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    )
{
    LPWSTR szFriendlyName = NULL;
    if (g_Silent) return;

    WBEMSTATUS Status;

    Status = pCfg->GetFriendlyName(&szFriendlyName);

    if (FAILED(Status))
    {
        szFriendlyName = NULL;
    }
    printf(
        "\nNLB Configuration for %ws \"%ws\"%ws\n",
        szNicGuid,
        (szFriendlyName == NULL) ? L"" :  szFriendlyName,
        pCfg->fDHCP ?  L" (DHCP)" : L""
        );

    // printf("    fValidNlbCfg=%d\n", pCfg->fValidNlbCfg);
    // printf("    fAddDedicatedIp=%d\n", pCfg->fAddDedicatedIp);

    printf("    Generation = %d\n", pCfg->Generation);
    wprintf(L"    NlbBound = %ws\n", bool_string(pCfg->fBound));
    
    UINT AddrCount = pCfg->NumIpAddresses;
    display_ip_info2(AddrCount, pCfg->pIpAddressInfo);

    if (pCfg->fBound)
    {
        if (pCfg->fValidNlbCfg)
        {
            LPWSTR sz = NULL;

            printf("    ClusterNetworkAddress = %ws/%ws\n",
                pCfg->NlbParams.cl_ip_addr,
                pCfg->NlbParams.cl_net_mask
                );

            // cluster_name
            Status = pCfg->GetClusterName(&sz);
            if (FAILED(Status))
            {
                sz = NULL;
            }
            else
            {
                printf("    ClusterName = %ws\n", sz);
                delete sz;
                sz = NULL;
            }

            // traffic_mode
            {
                LPCWSTR szMode = NULL;
                switch(pCfg->GetTrafficMode())
                {
                case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST:
                    szMode = L"UNICAST";
                    break;
                case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST:
                    szMode = L"MULTICAST";
                    break;
                case NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST:
                    szMode = L"IGMPMULTICAST";
                    break;
                default:
                    assert(FALSE);
                    szMode = L"*unknown mode*";
                }

                wprintf(L"    TrafficMode = %ws\n", szMode);
            }

            // port_rules
            display_port_rules(pCfg);

            // host_priority
            wprintf(L"    HostPriority = %lu\n", pCfg->GetHostPriority());

            printf("    DedicatedNetworkAddress = %ws/%ws\n",
                pCfg->NlbParams.ded_ip_addr,
                pCfg->NlbParams.ded_net_mask
                );

            // cluster_mode_on_start
            DWORD ClusterModeOnStart = pCfg->GetClusterModeOnStart();

            if (ClusterModeOnStart == CVY_HOST_STATE_STARTED)
            {
                wprintf(L"    ClusterModeOnStart = %ws\n", L"true");
            }
            else if (ClusterModeOnStart == CVY_HOST_STATE_STOPPED)
            {
                wprintf(L"    ClusterModeOnStart = %ws\n", L"false");
            }
            else // suspend
            {
                wprintf(L"    ClusterModeOnStart = %ws\n", L"suspend");
            }

            // persist_suspend_on_reboot
            if (pCfg->GetPersistSuspendOnReboot() == TRUE)
            {
                wprintf(L"    PersistSuspend = %ws\n", L"true");
            }
            else
            {
                wprintf(L"    PersistSuspend = %ws\n", L"false");
            }

            // remote_control_enabled
            wprintf(L"    RemoteControlEnabled = %ws\n",
                    bool_string(pCfg->GetRemoteControlEnabled()));

        }
        else
        {
            printf("NLB configuration is invalid\n");
        }
    }
    printf("\n");
    

    delete szFriendlyName;
    szFriendlyName = NULL;

    return;

}

void
display_port_rules(
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg
    )
{
    WBEMSTATUS Status;
    LPWSTR *pszPortRules = NULL;
    UINT NumPortRules = 0;

    Status =  pCfg->GetPortRules(&pszPortRules, &NumPortRules);

    if (FAILED(Status))
    {
        wprintf(L"    PortRules = *invalid*\n");
        pszPortRules = NULL;
        goto end;
    }

    if (NumPortRules)
    {
        wprintf(L"    PortRules =\n    {\n");
        for (UINT u=0; u<NumPortRules; u++)
        {
            wprintf(
                L"        %ws%ws\n",
                pszPortRules[u],
                u==(NumPortRules-1) ? L"" : L","
                );
        }
        wprintf(L"    }\n");
    }
    else
    {
        wprintf(L"    PortRules = {}\n");
    }

end:
    delete pszPortRules;

}

VOID
test_add_ips(LPCWSTR szNic)
//
// Go through a set of IPs on this NIC
//
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    UINT NumIpAddresses= 0;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

    while(1)
    {
        //
        // Get the current list of ip addresses
        //
        Status = CfgUtilGetIpAddressesAndFriendlyName(
                    szNic,
                    &NumIpAddresses,
                    &pIpInfo,
                    NULL // szFriendly name
                    );
    
        if (FAILED(Status))
        {
            printf("Error 0x%08lx getting ip address list for %ws\n",
                    (UINT) Status,  szNic);
            pIpInfo = NULL;
            goto end;
        }
    
        //
        //  display what we find.
        //
        display_ip_info(NumIpAddresses, pIpInfo);
        if (pIpInfo!=NULL)
        {
            delete pIpInfo;
            pIpInfo = NULL;
        }

    
        //
        // Read the list ip address and subnet masks from the input
        //
        Status = read_ip_info(szNic, &NumIpAddresses, &pIpInfo);
        if (FAILED(Status))
        {
            printf("Quitting test_add_ips\n");
            break;
        }
    
        //
        // Set the specified IPs
        //
        1 && (Status =  CfgUtilSetStaticIpAddresses(
                        szNic,
                        NumIpAddresses,
                        pIpInfo
                        ));

        if (FAILED(Status))
        { 
            printf("CfgUtilSetStaticIpAddresses failed with status 0x%08lx\n",
                    Status);
        }
        else
        {
            printf("Successfully set the specified IPs on the NIC\n");
        }

    }

end:

    if (pIpInfo != NULL)
    {
        delete pIpInfo;
    }
}

VOID
test_bind_nlb(LPCWSTR szNic)
{
    WBEMSTATUS Status;
    BOOL        fBound = FALSE;

    printf("\nRunning bind/unbind test for NIC %ws...\n\n", szNic);

    while(1)
    {
        //
        // Check NLB bind state
        //
        printf("Checking if NLB is bound...\n");
        Status =  CfgUtilCheckIfNlbBound(szNic, &fBound);
        if (FAILED(Status))
        {
            printf("CfgUtilCheckIfNlbBound fails with error 0x%08lx\n", (UINT)Status);
            break;
        }
        printf(
            "NLB is %wsbound\n\n",
            (fBound) ? L"" : L"NOT "
            );
            
    
        printf("Enter 'b' to bind, 'u' to unbind or 'q' to quit\n:");
        WCHAR Temp[32] = L"";
        while (wscanf(L" %1[buq]", Temp)!=1)
        {
            printf("Incorrect input. Try again.\n");
            if (feof(stdin))
            {
                *Temp = 'q';
                break;
            }

        }

        if (*Temp == 'b')
        {
            printf("Attempting to bind NLB...\n");
            fBound = TRUE;
        }
        else if (*Temp == 'u')
        {
            printf("Attempting to unbind NLB\n");
            fBound = FALSE;
        }
        else
        {
            printf("Quitting\n");
            break;
        }


    #if 1
        Status =  CfgUtilChangeNlbBindState(szNic, fBound);
        if (FAILED(Status))
        {
            printf("CfgUtilChangeNlbBindState fails with error %08lx\n",
                (UINT) Status);
        }
        else
        {
            printf(
                "%ws completed successfully\n",
                (fBound) ? L"Bind" : L"Unbind"
                );
        }
    #endif // 0
        printf("\n");
    
    }
}


VOID
test_cfg_nlb(LPCWSTR szNic)
{
    WBEMSTATUS Status;

    printf("\nRunning update NLB config test for NIC %ws...\n\n", szNic);

    while (1)
    {
        WLBS_REG_PARAMS Params;
        ZeroMemory(&Params, sizeof(Params));

        //
        // Read NLB config
        //
        Status =  CfgUtilGetNlbConfig(szNic, &Params);
        if (FAILED(Status))
        {
            printf("CfgUtilGetNlbConfig fails with error 0x%08lx\n", (UINT)Status);
            break;
        }

        printf("NLB configuration:\n");
        printf(
            "\tClusterIP: {%ws,%ws}\n",
            Params.cl_ip_addr,
            Params.cl_net_mask
            );
    
        //
        // Make some modifications
        //
        printf("\nEnter new {cluster-ip-addr,subnet-mask} or 'q' to quit\n:");
        while(1)
        {
            NLB_IP_ADDRESS_INFO Info;
            INT i =  wscanf(
                        L" { %15[0-9.] , %15[0-9.] }",
                        Info.IpAddress,
                        Info.SubnetMask
                        );
            if (i!=2)
            {
                WCHAR Temp[100] = L"";
                
                if (   (wscanf(L"%64ws", Temp) == 1)
                    && !_wcsicmp(Temp, L"q"))
                {
                    printf("Quitting\n");
                    goto end;
                }
                else if (feof(stdin))
                {
                    goto end;
                }
                else
                {
                    printf("Badly formed input. Try again\n");
                }
            }
            else
            {
                ARRAYSTRCPY(Params.cl_ip_addr, Info.IpAddress);
                ARRAYSTRCPY(Params.cl_net_mask, Info.SubnetMask);
                break;
            }
        }
    
        //
        // Write NLB config
        //
    #if 1
        printf("\nAttempting to update NLB configuration...\n");
        Status = CfgUtilSetNlbConfig(szNic, &Params, FALSE); // FALSE==old bind
        if (FAILED(Status))
        {
            printf("CfgUtilSetNlbConfig fails with error %08lx\n",
                (UINT) Status);
        }
        else
        {
            printf("change completed successfully\n");
        }
    #endif // 0
        printf("\n");
    }

end:
    return;
    
}

VOID
test_update(
    LPCWSTR szMachineName, // NULL == don't use wmi
    LPCWSTR szNicGuid
    )
{
    WBEMSTATUS Status;
    WCHAR  *pLog = NULL;
    WBEMSTATUS  CompletionStatus;
    UINT   Generation;
    WMI_CONNECTION_INFO  ConnInfo;
    ZeroMemory(&ConnInfo, sizeof(ConnInfo));
    ConnInfo.szMachine = szMachineName;


    printf("\nRunning high-level update NLB config test for NIC %ws...\n\n", szNicGuid);

    while(1)
    {
        BOOL fSetDefaults = FALSE;
        UINT NumIpAddresses = 0;
        NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
        BOOL fUnbind = FALSE;

        //
        // Clean up config info
        //
        if (MyOldCfg.pIpAddressInfo!=NULL)
        {
            delete MyOldCfg.pIpAddressInfo;
        }
        ZeroMemory(&MyOldCfg, sizeof(MyOldCfg));
        if (MyNewCfg.pIpAddressInfo!=NULL)
        {
            delete MyNewCfg.pIpAddressInfo;
        }
        ZeroMemory(&MyNewCfg, sizeof(MyNewCfg));
    
        printf("TEST: Going to get configuration for NIC %ws\n", szNicGuid);
    
        MyBreak(L"Break before calling GetConfiguration.\n");

        if (szMachineName==NULL)
        {

            Status = NlbConfigurationUpdate::GetConfiguration(
                        szNicGuid,
                        &MyOldCfg
                        );
        }
        else
        {
            Status = NlbHostGetConfiguration(
                        &ConnInfo,
                        szNicGuid,
                        &MyOldCfg
                        );
        }
    
        if (FAILED(Status))
        {
            goto end;
        }

        display_config(szNicGuid, &MyOldCfg);
        
        if (MyOldCfg.fBound)
        {
            printf("\nEnter 2 or more {cluster-ip-addr,subnet-mask} or none to unbind or 'q' to quit. The first entry is the dedicated-ip.\n");
            if (!MyOldCfg.fValidNlbCfg)
            {
                //
                // We're bound, but nlb params are bad. Set defaults.
                //
                fSetDefaults = TRUE;
            }
        }
        else
        {
            //
            // We're previously unbound. Set defaults.
            //
            fSetDefaults = TRUE;

            printf("\nEnter 2 or more {cluster-ip-addr,subnet-mask} or 'q' to quit. The first entry is the dedicated-ip.\n");
        }


        while(1)
        {
            //
            // Read the list ip address and subnet masks from the input
            //
            Status = read_ip_info(szNicGuid, &NumIpAddresses, &pIpInfo);
            if (FAILED(Status))
            {
                printf("Quitting\n");
                goto end;
            }

            if (NumIpAddresses < 2)
            {
                if (MyOldCfg.fBound)
                {
                    if (NumIpAddresses == 0)
                    {
                        fUnbind = TRUE;
                        break;
                    }
                    else
                    {
                        printf("Wrong number of IP addresses -- enter either 0 or >= 2.\n");
                    }
                }
                else
                {
                    printf("Wrong number of IP addresses. Enter >= 2 IP addresses.");
                }
            }
            else
            {
                //
                //  >= 2 addresses. First one is the dip and the 2nd is the vip.
                //
                break;
            }

            if (pIpInfo != NULL)
            {
                delete pIpInfo;
                pIpInfo = NULL;
            }

        }
    
        if (fUnbind)
        {
            //
            // We're to unbind.
            //

            ZeroMemory(&MyNewCfg, sizeof(MyNewCfg));
            MyNewCfg.fValidNlbCfg = TRUE;
            MyNewCfg.fBound = FALSE;

            //
            // Set the list of ip address to have present on unbind to
            // be the dedicated ip address, if there is one, otherwise zero,
            // in which case the adapter will be switched to DHCP after NLB
            // is unbound
            //

            if (MyOldCfg.NlbParams.ded_ip_addr[0]!=0)
            {
                NLB_IP_ADDRESS_INFO *pTmpIpInfo;
                pTmpIpInfo = new NLB_IP_ADDRESS_INFO;
                if (pTmpIpInfo == NULL)
                {
                    printf("TEST: allocation failure; can't add IP on unbind.\n");
                }
                else
                {
                    ARRAYSTRCPY(pTmpIpInfo->IpAddress, MyOldCfg.NlbParams.ded_ip_addr);
                    ARRAYSTRCPY(pTmpIpInfo->SubnetMask, MyOldCfg.NlbParams.ded_net_mask);
                    MyNewCfg.NumIpAddresses = 1;
                    MyNewCfg.pIpAddressInfo = pTmpIpInfo;
                }
            }

        }
        else
        {
            if (fSetDefaults)
            {
                CfgUtilInitializeParams(&MyNewCfg.NlbParams);
                MyNewCfg.fValidNlbCfg = TRUE;
                MyNewCfg.fBound = TRUE;
            }
            else
            {
                MyNewCfg = MyOldCfg; // struct copy
                ASSERT(MyNewCfg.fValidNlbCfg == TRUE);
                ASSERT(MyNewCfg.fBound == TRUE);
            }

            //
            // Now Add the dedicated and cluster IPs.
            //
            ASSERT(NumIpAddresses >= 2);
            ARRAYSTRCPY(MyNewCfg.NlbParams.ded_ip_addr, pIpInfo[0].IpAddress);
            ARRAYSTRCPY(MyNewCfg.NlbParams.ded_net_mask, pIpInfo[0].SubnetMask);
            ARRAYSTRCPY(MyNewCfg.NlbParams.cl_ip_addr, pIpInfo[1].IpAddress);
            ARRAYSTRCPY(MyNewCfg.NlbParams.cl_net_mask, pIpInfo[1].SubnetMask);
    
            //
            // If more IPs, we explicitly add the ip list, else leave it null.
            //
            if (NumIpAddresses > 2)
            {
                MyNewCfg.pIpAddressInfo = pIpInfo;
                MyNewCfg.NumIpAddresses = NumIpAddresses;
            }
            else
            {
                MyNewCfg.fAddDedicatedIp = TRUE; // says to add dedicated ip.
                MyNewCfg.pIpAddressInfo=NULL;
                MyNewCfg.NumIpAddresses=0;
                delete pIpInfo;
                pIpInfo = NULL;
            }
        }

        display_config(szNicGuid, &MyNewCfg);
    
        printf("Going to update configuration for NIC %ws\n", szNicGuid);

        MyBreak(L"Break before calling DoUpdate.\n");
    
        if (szMachineName==NULL)
        {
            Status = NlbConfigurationUpdate::DoUpdate(
                        szNicGuid,
                        L"tprov.exe",
                        &MyNewCfg,
                        &Generation,
                        &pLog
                        );
        }
        else
        {
            Status = NlbHostDoUpdate(
                        &ConnInfo,
                        szNicGuid,
                        L"tprov.exe",
                        &MyNewCfg,
                        &Generation,
                        &pLog
                        );
        }
    
        if (pLog != NULL)
        {
            display_log(pLog);
            delete pLog;
            pLog = NULL;
        }
    
        if (Status == WBEM_S_PENDING)
        {
            printf(
                "Waiting for pending operation %d...\n",
                Generation
                );
        }

        while (Status == WBEM_S_PENDING)
        {
            Sleep(1000);
    
            if (szMachineName == NULL)
            {
                Status = NlbConfigurationUpdate::GetUpdateStatus(
                            szNicGuid,
                            Generation,
                            FALSE,  // FALSE == Don't delete completion record
                            &CompletionStatus,
                            &pLog
                            );
            }
            else
            {
                Status = NlbHostGetUpdateStatus(
                            &ConnInfo,
                            szNicGuid,
                            Generation,
                            &CompletionStatus,
                            &pLog
                            );
            }
            if (pLog != NULL)
            {
                display_log(pLog);
                delete pLog;
                pLog = NULL;
            }
            if (!FAILED(Status))
            {
                Status = CompletionStatus;
            }
        }
    
        printf(
            "Final status of update %d is 0x%08lx\n",
            Generation,
            Status
            );
    }
end:
    return;
}



VOID
display_ip_info(
    IN  UINT NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    )
{
    UINT AddrCount = NumIpAddresses;
    printf("\tNumIpAddresses=%d\n", AddrCount);
    
    if (AddrCount != 0)
    {
        printf("\tAddress\t\tMask\n");
        if (pIpInfo == NULL)
        {
            printf("ERROR: IpAddressInfo is NULL!\n");
            goto end;
        }
        
        for (UINT u=0;u<AddrCount; u++)
        {
            printf(
                "\t{%-15ws, %ws}\n",
                pIpInfo[u].IpAddress,
                pIpInfo[u].SubnetMask
                );
        }
    }

end:
    return;
}

VOID
display_ip_info2(
    IN  UINT NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    )
{
    if (NumIpAddresses == 0)
    {
        wprintf(L"    NetworkAddresses = {}\n");
    }
    else
    {
        wprintf(L"    NetworkAddresses =\n    {\n");
        
        for (UINT u=0;u<NumIpAddresses; u++)
        {
            printf(
                 "        %15ws/%ws%ws\n",
                pIpInfo[u].IpAddress,
                pIpInfo[u].SubnetMask,
                (u==(NumIpAddresses-1)) ? L"" : L","
                );
        }
    
        wprintf(L"    }\n");
    }

    return;
}

WBEMSTATUS
read_ip_info(
    IN  LPCWSTR             szNic,
    OUT UINT                *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo
    )
{
    NLB_IP_ADDRESS_INFO *pIpInfo;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    #define MAX_READ_IPS 10

    printf("Enter zero or more {ip-address,subnet-mask} followed by '.'\n"
           "(or 'q' to quit)\n:");
    pIpInfo = new NLB_IP_ADDRESS_INFO[MAX_READ_IPS];

    if (pIpInfo == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }
    for (UINT Index=0; Index<MAX_READ_IPS; Index++)
    {
        NLB_IP_ADDRESS_INFO *pInfo = pIpInfo+Index;
        INT i =  wscanf(
                    //L" { %15ws , %15ws }",
                    //L"{%15ws,%15ws}",
                    //L"{%ws,%ws}",
                    //L"{%[0-9.],%[0-9.]}",
                    L" { %15[0-9.] , %15[0-9.] }",
                    pInfo->IpAddress,
                    pInfo->SubnetMask
                    );
        if (i!=2)
        {
            WCHAR Temp[100];
            if ( (wscanf(L"%64ws", Temp) == 1)
                && !_wcsicmp(Temp, L"q"))
            {
                Status = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            else if (!_wcsicmp(Temp, L"."))
            {
                break;
            }
            else  if (feof(stdin))
            {
                Status = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            else
            {
                printf("Badly formed input. Try again\n");
                Index--;
            }
        }
    }

    *pNumIpAddresses = Index;

end:

    if (FAILED(Status))
    {
        if (pIpInfo != NULL)
        {
            delete[] pIpInfo;
            pIpInfo = NULL;
        }
    }
    *ppIpInfo = pIpInfo;

    return Status;
}



VOID
do_usage(VOID)
{

wprintf(
L"\n"
L"NLBCFG host [command] [options]\n"
L"\n"
L"where\n"
L"\n"
L"    \"host\" is one of\n"
L"        machine name\n"
L"        IP address\n"
L"        fully-qualified machine name\n"
L"        .  (implies local machine, using WMI)\n"
L"        -  (implies local machine, not using WMI)\n"
L"\n"
L"    \"command\" is one of\n"
L"        adapterlist             -- list adapters compatible with NLB\n"
L"        update [adapter_guid]   -- bind or update NLB configuraiton\n"
L"        help|h                  -- display help information\n"
L"\n"
L"    \"command\" may also be one of the following, used for internal testing\n"
L"        ipaddr [adapter_guid]   -- display and change ip addresses\n"
L"        nlbbind [adapter_guid]  -- bind or unbind NLB\n"
L"        nlbcfg [adapter_guid]   -- change NLB configuration\n"
L"    \n"
L"    \"options\" has the form\n"
L"        /u domain\\user [password | *]\n"
L"\n"
L"List of abbreviated command names and their full forms\n"
L"    al      adapterlist\n"
L"    u       update\n"
L"    ?       help\n"
L"\n"
L"Examples:\n"
L"\n"
L"    NLBCFG machine1 adapterlist /u:mydomain\\myname *\n"
L"        Displays the list of NLB-compatible adapters on the machine with\n"
L"        name \"machine1\". The \"*\" indicates that the user is to be prompted\n"
L"        to enter the password.\n"
L"        \n"
L"\n"
L"    NLBCFG 10.0.0.1 update {AD4DA14D-CAAE-42DD-97E3-5355E55247C2}\n"
L"        Binds or updates the NLB configuration on a specific adapter on\n"
L"        the machine with ip address \"10.0.0.1\". The adapter is identified\n"
L"        by GUID \"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}\".\n"
L"\n"
L"    NLBCFG . update {AD4DA14D-CAAE-42DD-97E3-5355E55247C2}\n"
L"        Binds or updates the NLB configuration on a specific adapter on\n"
L"        the local machine. The adapter is identified\n"
L"        by GUID \"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}\".\n"
L"        \n"
L"    NLBCFG .\n"
L"        Opens a NLB configuration shell. This shell may be used to issue\n"
L"        NLB configuration commands to the local machine.\n"
L"\n"
);
}

VOID do_niclist(
    LPCWSTR szSrchFriendlyName, // OPTIONAL
    LPWSTR *pszFoundGuid         // OPTIONAL
    )
/*
    szSrchFriendlyName -- if non NULL, this function searches for a matching
    GUID and returns that in pszFoundGuid (which also must be NON-NULL in this
    case).

    Otherwise -- this function simply prints out the adapter list.

*/
{
    LPWSTR *pszNics = NULL;
    LPWSTR szFoundGuid = NULL;
    UINT   NumNics = 0;
    UINT   NumNlbBound = 0;
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    BOOL fDisplay = FALSE;
    BOOL fDone = FALSE; 

    if (szSrchFriendlyName==NULL)
    {
        fDisplay = TRUE;
    }
    else
    {
        fDisplay = FALSE;
        *pszFoundGuid  = NULL;
    }

    Status =  CfgUtilsGetNlbCompatibleNics(&pszNics, &NumNics, &NumNlbBound);

    if (FAILED(Status))
    {
        printf("CfgUtilsGetNlbCompatibleNics returns error 0x%08lx\n",
                    (UINT) Status);
        pszNics = NULL;
        goto end;
    }

    if (NumNics == 0)
    {
        if (fDisplay)
        {
            printf("No compatible local adapter guids.\n");
        }
    }
    else
    {
        if (fDisplay)
        {
            printf("Local Adapter Guids (D==DHCP N==NLB):\n");
        }
        for (UINT u = 0; u<NumNics && !fDone; u++)
        {

            LPCWSTR szNic           = pszNics[u];
            LPWSTR  szFriendlyName  = NULL;
            UINT NumIpAddresses= 0;
            NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
    
            //
            // Get the current list of ip addresses
            //
            Status = CfgUtilGetIpAddressesAndFriendlyName(
                        szNic,
                        &NumIpAddresses,
                        &pIpInfo,
                        &szFriendlyName
                        );
        
            if (FAILED(Status))
            {
                pIpInfo = NULL;
                szFriendlyName = NULL;
                // wprintf(L"%ws\t<null>\t<null>\n", szNic);
                wprintf(L"Error getting ip addresses for %ws\n", szNic);
            }
            else
            {
                if (fDisplay)
                {
                    LPCWSTR szCIpAddress    = L"";
                    LPCWSTR szCFriendlyName = L"";
                    LPCWSTR szNlbBound      = L" ";
                    LPCWSTR szDHCP          = L" ";
            
                    if (NumIpAddresses>0)
                    {
                        szCIpAddress =  pIpInfo[0].IpAddress;
                    }
    
                    if (szFriendlyName != NULL)
                    {
                        szCFriendlyName = szFriendlyName;
                    }

                    //
                    // Get DHCP State
                    //
                    {
                        BOOL fDHCP = FALSE;
                        Status =  CfgUtilGetDHCP(szNic, &fDHCP);
                        if (FAILED(Status))
                        {
                            printf("Error 0x%x attempting to determine DHCP state for NIC %ws",
                                        (UINT) Status, szNic);
                            szDHCP = L"?";
                        }
                        else if (fDHCP)
                        {
                            szDHCP = L"D";
                        }
                    }

                    //
                    // Check if NLB bound...
                    //
                    {
                        BOOL fBound;
                        Status =  CfgUtilCheckIfNlbBound(szNic, &fBound);
                        if (FAILED(Status))
                        {
                            fBound = FALSE;

                            if  (Status != WBEM_E_NOT_FOUND)
                            {
                                printf("CfgUtilCheckIfNlbBound fails with error 0x%08lx\n", (UINT)Status);
                                szNlbBound = L"?";
                            }
                        }

                        if (fBound)
                        {
                            szNlbBound = L"N";
                        }
                    }


                    wprintf(
                        L"%ws  %s %s %-15ws  \"%ws\"\n",
                        szNic,
                        szDHCP,
                        szNlbBound,
                        szCIpAddress,
                        szCFriendlyName
                        );
                }
                else if (szFriendlyName != NULL)
                {
                    if (!_wcsicmp(szSrchFriendlyName, szFriendlyName))
                    {
                        //
                        // Got it! Get the GUID.
                        //
                        const UINT cchLen  =  wcslen(szNic)+1;
                        szFoundGuid = new WCHAR[cchLen];
                        if (szFoundGuid == NULL)
                        {
                            printf("Allocation failure\n");
                        }
                        else
                        {
                            StringCchCopy(szFoundGuid, cchLen, szNic);
                        }
                        fDone = TRUE;
                    }
                }
            }

            if (pIpInfo != NULL)
            {
                delete pIpInfo;
                pIpInfo = NULL;
            }

            if (szFriendlyName != NULL)
            {
                delete szFriendlyName;
                szFriendlyName = NULL;
            }
        }
    }

end:

    if (pszNics != NULL)
    {
        delete pszNics;
        pszNics = NULL;
    }

    if (!fDisplay)
    {
        *pszFoundGuid  = szFoundGuid;
    }
        
}


VOID do_wminiclist(
    LPCWSTR szSrchFriendlyName, // OPTIONAL
    LPWSTR *pszFoundGuid         // OPTIONAL
    )
/*
    szSrchFriendlyName -- if non NULL, this function searches for a matching
    GUID and returns that in pszFoundGuid (which also must be NON-NULL in this
    case).

    Otherwise -- this function simply prints out the adapter list.

*/
{
    LPWSTR szMachineName = NULL;
    LPWSTR *pszNics = NULL;
    LPWSTR szFoundGuid = NULL;
    UINT   NumNics = 0;
    UINT   NumNlbBound = 0;
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    BOOL fDisplay = FALSE;
    BOOL fDone = FALSE; 
    LPWSTR szWmiMachineName = NULL;
    LPWSTR szWmiMachineGuid = NULL;
    BOOL  fNlbMgrProviderInstalled = FALSE;


    WMI_CONNECTION_INFO  ConnInfo;
    WMI_CONNECTION_INFO  *pConnInfo = NULL;
    ZeroMemory(&ConnInfo, sizeof(ConnInfo));

    if (szSrchFriendlyName==NULL)
    {
        fDisplay = TRUE;
    }
    else
    {
        fDisplay = FALSE;
        *pszFoundGuid  = NULL;
    }

    ASSERT(g.fUseWmi);

    if (!g.fLocalHost)
    {
        ConnInfo.szMachine  = g.MachineName;
        if (g.UserName[0])
        {
            ConnInfo.szUserName = g.UserName;
            ConnInfo.szPassword = g.Password;
        }
        pConnInfo           = &ConnInfo;
    }

    Status = NlbHostGetMachineIdentification(
                       pConnInfo,
                       &szWmiMachineName,
                       &szWmiMachineGuid,
                       &fNlbMgrProviderInstalled
                       );
    if (FAILED(Status))
    {
        if (Status ==  E_ACCESSDENIED)
        {
            wprintf(L"Bad user name or password connecting to NLB on %ws.\n",
                g.MachineName);
        }
        else
        {
            printf("NlbHostGetMachineIdentification returns error 0x%08lx\n",
                        (UINT) Status);
        }
       
       szWmiMachineName = NULL;
       szWmiMachineGuid = NULL;
       goto end;
    }

    if (!fNlbMgrProviderInstalled)
    {
        wprintf(L"NLB Manager is not installed on %ws.\n", g.MachineName);
        goto end;
    }

    Status =  NlbHostGetCompatibleNics(
                pConnInfo,
                &pszNics,
                &NumNics,
                &NumNlbBound
                );
    if (FAILED(Status))
    {
        if (Status ==  E_ACCESSDENIED)
        {
            wprintf(L"Bad user name or password connecting to NLB on %ws.\n",
                g.MachineName);
        }
        else
        {
            printf("NlbHostGetNlbCompatibleNics returns error 0x%08lx\n",
                        (UINT) Status);
        }
        pszNics = NULL;
        goto end;
    }

    if (NumNics == 0 && fDisplay)
    {
        printf("No compatible local adapter guids.\n");
    }
    else
    {
        BOOL fSavedSilent = g_Silent;
        g_Silent = TRUE;
        if (fDisplay)
        {
            if (szWmiMachineName != NULL)
            {
                printf("Machine Name: %ws\n", szWmiMachineName);
            }
            if (szWmiMachineGuid != NULL)
            {
                printf("Machine GUID: %ws\n", szWmiMachineGuid);
            }
            printf("Local Adapter Guids (D==DHCP N==NLB):\n", NumNlbBound);
        }

        for (UINT u=0; u<NumNics && !fDone; u++)
        {
            NLB_EXTENDED_CLUSTER_CONFIGURATION NlbCfg; // class
            LPCWSTR szNic           = pszNics[u];

            Status = NlbHostGetConfiguration(
                        pConnInfo,
                        szNic,
                        &NlbCfg
                        );

            if (FAILED(Status))
            {
                // wprintf(L"%ws\t<null>\t<null>\n", szNic);
                wprintf(L"Error reading extended configuration for %ws\n", szNic);
            }
            else
            {
                UINT NumIpAddresses= 0;
                NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
                LPWSTR  szFriendlyName  = NULL;
                LPCWSTR szCIpAddress    = L"";
                LPCWSTR szCFriendlyName = L"";
                LPWSTR *pszNetworkAddresses = NULL;
                LPCWSTR szNlbBound      = L" ";
                LPCWSTR szDHCP          = L" ";
        
                if (fDisplay)
                {
                    Status =  NlbCfg.GetNetworkAddresses(
                                    &pszNetworkAddresses,
                                    &NumIpAddresses
                                    );
    
                    if (FAILED(Status))
                    {
                        wprintf(L"Error extracting IP addresses for %ws\n", szNic);
                        NumIpAddresses = 0;
                        pszNetworkAddresses = NULL;
                    }
    
                    if (NumIpAddresses>0)
                    {
                        
                        szCIpAddress =  pszNetworkAddresses[0];
    
                        //
                        // NetworkAddresses are of the form "10.0.0.1/255.255.255.0"
                        // So we truncate this by putting a '\0' where the '/' is.
                        //
                        {
                            LPWSTR pSlash = wcsrchr(szCIpAddress, (int) '/');
                            if (pSlash != NULL)
                            {
                                *pSlash = 0;
                            }
                        }
                    }

                    if (NlbCfg.IsNlbBound())
                    {
                        szNlbBound  = L"N";
                    }

                    if (NlbCfg.fDHCP)
                    {
                        szNlbBound = L"D";
                    }
                }

                Status = NlbCfg.GetFriendlyName(
                            &szFriendlyName
                            );

                if (FAILED(Status))
                {
                    szFriendlyName = NULL;
                }

                if (fDisplay)
                {

                    if (szFriendlyName != NULL)
                    {
                        szCFriendlyName = szFriendlyName;
                    }
    
                    wprintf(
                        L"%ws %ws %ws %-15ws \"%ws\"\n",
                        szNic,
                        szDHCP,
                        szNlbBound,
                        szCIpAddress,
                        szCFriendlyName
                        );
                }
                else if (szFriendlyName != NULL)
                {
                    if (!_wcsicmp(szSrchFriendlyName, szFriendlyName))
                    {
                        //
                        // Got it! Get the GUID.
                        //
                        const UINT cchLen = wcslen(szNic)+1;
                        szFoundGuid = new WCHAR[cchLen];
                        if (szFoundGuid == NULL)
                        {
                            printf("Allocation failure\n");
                        }
                        else
                        {
                            StringCchCopy(szFoundGuid, cchLen, szNic);
                        }
                        fDone = TRUE;
                    }
                }

                if (szFriendlyName != NULL)
                {
                    delete szFriendlyName;
                    szFriendlyName = NULL;
                }

                if (pszNetworkAddresses != NULL)
                {
                    delete pszNetworkAddresses;
                    pszNetworkAddresses = NULL;
                }
            }
        }
        g_Silent = fSavedSilent;
    }

end:

    delete szMachineName;
    delete pszNics;
    delete szWmiMachineName;
    delete szWmiMachineGuid;

    if (!fDisplay)
    {
        *pszFoundGuid  = szFoundGuid;
    }
}


VOID do_ipaddr(VOID)
{
    LPWSTR szNic = NULL;

    //
    // Skip reading the GUID if we've got it from the command line.
    //
    if (!g.fGotGuid)
    {
        if (!read_guid(&szNic)) goto end;

        ARRAYSTRCPY(g.AdapterGuid, szNic);
    }

    test_add_ips(szNic);

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}


VOID do_nlbcfg(VOID)
{
    LPWSTR szNic = NULL;

    //
    // Skip reading the GUID if we've got it from the command line.
    //
    if (!g.fGotGuid)
    {
        if (!read_guid(&szNic)) goto end;

        ARRAYSTRCPY(g.AdapterGuid, szNic);
    }

    test_cfg_nlb(szNic);

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}


VOID do_nlbbind(VOID)
{
    LPWSTR szNic = NULL;

    //
    // Skip reading the GUID if we've got it from the command line.
    //
    if (!g.fGotGuid)
    {
        if (!read_guid(&szNic)) goto end;

        ARRAYSTRCPY(g.AdapterGuid, szNic);
    }
    test_bind_nlb(szNic);

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}


VOID do_update(VOID)
{
    LPWSTR szNic = NULL;

    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_update(NULL, szNic); // NULL == don't use WMI

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    
}

VOID do_wmiupdate(VOID)
{
    LPWSTR szNic = NULL;
    LPWSTR szMachineName = NULL;

    if (!read_machinename(&szMachineName))
    {
        szMachineName = NULL;
        goto end;
    }
    if (!read_guid(&szNic))
    {
        szNic = NULL;
        goto end;
    }

    test_update(szMachineName, szNic); // TRUE == use WMI

end:
    if (szNic!=NULL)
    {
        delete szNic;
    }
    if (szMachineName!=NULL)
    {
        delete szMachineName;
    }
    
}


VOID do_cleanreg(VOID)
{
   printf("Unimplemented\n");
}

BOOL read_guid(
        LPWSTR *pszNic
        )
{
    BOOL fRet = FALSE;
    BOOL fValid = FALSE;
    LPWSTR szNic = NULL;

#if 1

    WCHAR rgTemp[256];
    printf("Enter Adapter GUID: ");
    do
    {
        // if (wscanf(L" %40[-{}a-fA-F0-9]", rgTemp)==1)
        if (wscanf(L" %200ws", rgTemp) == 1)
        {
            fValid = valid_guid(rgTemp);
        }

        if (!fValid)
        {
            if (feof(stdin)) goto end;

            printf("Incorrect format. Please re-enter Adapter Guid: ");
        }
    } while (!fValid);

#else
    LPCWSTR rgTemp = L"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}";
#endif // 0


    const UINT  cchLen = wcslen(rgTemp)+1;
    szNic = new WCHAR[cchLen];

    if (szNic != NULL)
    {
        StringCchCopy(szNic, cchLen, rgTemp);
        fRet = TRUE;
    }

end:

    *pszNic = szNic;
    return fRet;
}


BOOL read_machinename(
        LPWSTR *pszMachineName
        )
{
    BOOL fRet = FALSE;
#if 0
    WCHAR rgTemp[256];
    printf("\nEnter Machine Name (or '.' for local)\n:");
    while (wscanf(L" %[a-zA-Z0-9._-]", rgTemp)!=1)
    {
        wscanf(L" %200s", rgTemp);
        printf("Incorrect format. Please try again.\n");
    }
    if (!wcscmp(rgTemp, L"."))
    {
        // convert "." to ""
        *rgTemp=0;
    }
#else
    // LPCWSTR rgTemp = L"JOSEPHJ4E";
    LPCWSTR rgTemp = L"";
#endif

    const UINT cchLen = wcslen(rgTemp)+1;
    LPWSTR szMachineName = new WCHAR[cchLen];

    if (szMachineName != NULL)
    {
        StringCchCopy(szMachineName, cchLen, rgTemp);
        fRet = TRUE;
    }

    *pszMachineName = szMachineName;
    return fRet;
}


void test_safearray(void)
{
    SAFEARRAY   *pSA;
    LPCWSTR     pInStrings[] =
       {
       L"String1",
    #if 1
       L"String2",
       L"String3",
    #endif // 0
        NULL // must be last.
       };
    LPWSTR     *pOutStrings=NULL;
    UINT NumInStrings=0;
    UINT NumOutStrings=0;
    WBEMSTATUS Status;

    //
    // Find count of strings...
    //
    for (NumInStrings=0; pInStrings[NumInStrings]!=NULL; NumInStrings++)
    {
        ;
    }

    Status = CfgUtilSafeArrayFromStrings(
                pInStrings,
                NumInStrings,
                &pSA
                );

    if (FAILED(Status))
    {
        printf("CfgUtilSafeArrayFromStrings failed with error 0x%08lx\n", (UINT)Status);
        pSA = NULL;
        goto end;
    }


    Status = CfgUtilStringsFromSafeArray(
                pSA,
                &pOutStrings,
                &NumOutStrings
                );

    if (FAILED(Status))
    {
        printf("CfgUtilStringsFromSafeArray failed with error 0x%08lx\n", (UINT)Status);
        pOutStrings = NULL;
        goto end;
    }


    //
    // Check that they match
    //
    if (NumOutStrings != NumInStrings)
    {
        printf("ERROR: NumOutStrings != NumInStrings.\n");
        goto end;
    }

    for (UINT u=0; u < NumInStrings; u++)
    {
        if (wcscmp(pInStrings[u], pOutStrings[u]))
        {
            printf("MISMATCH: %ws->%ws\n",  pInStrings[u], pOutStrings[u]);
        }
        else
        {
            printf("MATCH: %ws->%ws\n",  pInStrings[u], pOutStrings[u]);
        }
    }

end:
    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }
    if (pOutStrings!=NULL)
    {
        delete pOutStrings;
        pOutStrings = NULL;
    }
    return;
}

VOID test_exfcfgclass(void)
/*
    tests some of the methods of class  NLB_EXTENDED_CLUSTER_CONFIGURATION

    1. Initialize Cfg
    2. Set a bunch of fields
    3. display Cfg
    4. Get and set a bunch of fields on new
    5. display cfg

*/
{
    typedef enum
    {
        DO_STRINGS,
        DO_SAFEARRAY,
        DO_STRINGPAIR,
        DO_END
    } TEST_COMMAND;

    TEST_COMMAND cmd;

    printf("Test of NLB_EXTENDED_CLUSTER_CONFIGURATION methods...\n");

    UINT u1=100000L;
    // while(u1--> 0)
    {
        // g_Silent = TRUE;

    for (cmd=DO_STRINGS; cmd<DO_END; cmd=(TEST_COMMAND)((UINT)cmd + 1))
    {
    
    
        NLB_EXTENDED_CLUSTER_CONFIGURATION Cfg;
        NLB_EXTENDED_CLUSTER_CONFIGURATION NewCfg;
        WBEMSTATUS  Status = WBEM_NO_ERROR;
    
    
        CfgUtilInitializeParams(&Cfg.NlbParams);
        CfgUtilInitializeParams(&NewCfg.NlbParams);
    
    
        //
        // Set a bunch of fields in Cfg
        //
        {
            #define TPROV_NUM_ADDRESSES 2
            #define TPROV_NUM_PORTS 1
            LPCWSTR     rgszNetworkAddresses[TPROV_NUM_ADDRESSES] = {
                            L"10.0.0.1/255.0.0.0",
                            L"10.0.0.2/255.0.0.0"
                            };
            LPCWSTR     rgszIpAddresses[TPROV_NUM_ADDRESSES] = {
                            L"10.0.0.1",
                            L"10.0.0.2"
                            };
            LPCWSTR     rgszSubnetMasks[TPROV_NUM_ADDRESSES] = {
                            L"255.255.255.0",
                            L"255.255.0.0"
                            };
            LPCWSTR     rgszPortRules[TPROV_NUM_PORTS] = {
                            L"ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE priority=1"
                            };
            UINT        NumOldNetworkAddresses = TPROV_NUM_ADDRESSES;
            UINT        NumOldPortRules=TPROV_NUM_PORTS;
    
            Cfg.fValidNlbCfg = TRUE;
            Cfg.Generation = 123;
            Cfg.fBound = TRUE;
    
            if (cmd == DO_STRINGS)
            {
                Status =  Cfg.SetNetworkAddresses(
                                rgszNetworkAddresses,
                                NumOldNetworkAddresses
                                );
            }
            else if (cmd == DO_SAFEARRAY)
            {
                SAFEARRAY   *pOldSA = NULL;
                Status = CfgUtilSafeArrayFromStrings(
                            rgszNetworkAddresses,
                            NumOldNetworkAddresses,
                            &pOldSA
                            );
                if (FAILED(Status))
                {
                    printf("ERROR: couldn't create safe array!\n");
                    pOldSA = NULL;
                }
                if (pOldSA != NULL)
                {
                    Status = Cfg.SetNetworkAddressesSafeArray(pOldSA);
                    SafeArrayDestroy(pOldSA);
                    pOldSA = NULL;
        
                }
            }
            else if (cmd == DO_STRINGPAIR)
            {
    
                Status =  Cfg.SetNetworkAddresPairs(
                            rgszIpAddresses,
                            rgszSubnetMasks,
                            NumOldNetworkAddresses
                            );
            }

            Status =  Cfg.SetPortRules(rgszPortRules, NumOldPortRules);
            Cfg.SetClusterNetworkAddress(L"10.0.0.11/255.0.0.0");
            Cfg.SetDedicatedNetworkAddress(L"10.0.0.1/255.0.0.0");
            Cfg.SetTrafficMode(
                NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST
                );
            Cfg.SetHostPriority(10);
            Cfg.SetClusterModeOnStart( CVY_HOST_STATE_STOPPED );
            Cfg.SetPersistSuspendOnReboot( FALSE );
            Cfg.SetRemoteControlEnabled(TRUE);
            Cfg.fValidNlbCfg = TRUE;
        }
    
        display_config2(L"<dummy nic:old>", &Cfg);
    
        //
        // Get all the fields and push it into NewCfg;
        //
        {
            UINT        NumNetworkAddresses = 0;
            UINT        NumPortRules=0;
            LPWSTR      *pszNetworkAddresses=NULL;
            LPWSTR      *pszIpAddresses=NULL;
            LPWSTR      *pszSubnetMasks=NULL;
            LPWSTR      *pszPortRules=NULL;
            LPWSTR      szClusterAddress = NULL;
            LPWSTR      szDedicatedAddress = NULL;
            UINT        Generation=0;
            BOOL        NlbBound=FALSE;
            BOOL        ValidNlbConfig=FALSE;
            SAFEARRAY   *pSA = NULL;
            NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE
                TrafficMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
            /*
            NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
                StartMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE_STOPPED;
                */
            DWORD       StartMode = CVY_HOST_STATE_STOPPED;
            BOOL        PersistSuspendOnReboot = FALSE;
            UINT        HostPriority=0;
            BOOL        RemoteControlEnabled=FALSE;
    
            //
            // GET
            //
    
            Generation  = Cfg.GetGeneration();
            NlbBound = Cfg.IsNlbBound();
            ValidNlbConfig = Cfg.IsValidNlbConfig();
        
            if (cmd == DO_STRINGS)
            {
                Status =  Cfg.GetNetworkAddresses(
                                &pszNetworkAddresses,    
                                &NumNetworkAddresses
                                );
            }
            else if (cmd == DO_SAFEARRAY)
            {
                Status =  Cfg.GetNetworkAddressesSafeArray(&pSA);
                if (FAILED(Status))
                {
                    pSA = NULL;
                }
            }
            else if (cmd == DO_STRINGPAIR)
            {
                Status =  Cfg.GetNetworkAddressPairs(
                            &pszIpAddresses,   // free using delete
                            &pszSubnetMasks,   // free using delete
                            &NumNetworkAddresses
                            );
            }

    
            Status =  Cfg.GetPortRules(&pszPortRules, &NumPortRules);
            Status =  Cfg.GetClusterNetworkAddress(&szClusterAddress);
            Status =  Cfg.GetDedicatedNetworkAddress(&szDedicatedAddress);
            TrafficMode =     Cfg.GetTrafficMode();
            HostPriority =  Cfg.GetHostPriority();
            StartMode = Cfg.GetClusterModeOnStart();
            PersistSuspendOnReboot = Cfg.GetPersistSuspendOnReboot();
            RemoteControlEnabled = Cfg.GetRemoteControlEnabled();
    
            //
            // SET
            //
    
            NewCfg.fValidNlbCfg = ValidNlbConfig;
            NewCfg.Generation = Generation;
            NewCfg.fBound = NlbBound;
    
            if (cmd == DO_STRINGS)
            {
                Status =  NewCfg.SetNetworkAddresses(
                                (LPCWSTR*) pszNetworkAddresses,
                                NumNetworkAddresses
                                );
            }
            else if (cmd == DO_SAFEARRAY)
            {
                if (pSA != NULL)
                {
                    Status = NewCfg.SetNetworkAddressesSafeArray(pSA);
                    SafeArrayDestroy(pSA);
                    pSA = NULL;
                }
            }
            else if (cmd == DO_STRINGPAIR)
            {
                Status =  NewCfg.SetNetworkAddresPairs(
                            (LPCWSTR*) pszIpAddresses,
                            (LPCWSTR*) pszSubnetMasks,
                            NumNetworkAddresses
                            );
            }
    
            Status =  NewCfg.SetPortRules((LPCWSTR*)pszPortRules, NumPortRules);
            NewCfg.SetClusterNetworkAddress(szClusterAddress);
            NewCfg.SetDedicatedNetworkAddress(szDedicatedAddress);
            NewCfg.SetTrafficMode(TrafficMode);
            NewCfg.SetHostPriority(HostPriority);
            NewCfg.SetClusterModeOnStart(StartMode);
            NewCfg.SetPersistSuspendOnReboot(PersistSuspendOnReboot);
            NewCfg.SetRemoteControlEnabled(RemoteControlEnabled);
    
            delete (pszNetworkAddresses);
            delete (pszIpAddresses);
            delete (pszSubnetMasks);
            delete (pszPortRules);
            delete (szClusterAddress);
            delete (szDedicatedAddress);

        }
    
        display_config2(L"<dummy nic:new>", &NewCfg);
    }
    }

    printf("... end test\n");
}


#if 0
AdapterList             al
Update                  u
Quit                    q
Help                    h, ?


AdapterGuid             ag
PartialUpdate           pu
NetworkAddresses        na
NLBBound                nb
ClusterNetworkAddress   cna
ClusterName             cn
TrafficMode             tm
PortRules               pr
HostPriority            hp
DedicatedNetworkAddress dna
ClusterModeOnStart      cmos
RemoteControlEnabled    rce
Password                p
.
#endif // 0

 
BOOL read_password(
        VOID
        )
{
    BOOL fRet = TRUE;
    DWORD dwLen = 0;
    wprintf(L"Type the password for %ws: ", g.MachineName);

    fRet =  GetPassword(g.Password, ARRAY_LENGTH(g.Password)-1, &dwLen);
    if (!fRet)
    {
        printf("Error getting password!\n");
        g.Password[0] = 0;
    }

    return fRet;
}


KEYWORD
parse_args(int argc, WCHAR* argv[])
/*++
// tprov [niclist|ipaddr|nlbcfg|nlbbind]

nlbcfg machinename|-|. [command_and_parameters] [options]
machinemame                 machine name
                        OR IP address
                        OR fully-qualified machine name
-                       Indicates not to use WMI -- call lower-level functions
                        directly
.                       Connect to local machine using wmi
command_and_parameters      AdapterList
                        OR  Update [adapter_guid]
                        OR  Help
                        OR  ipaddr [adapter_guid]  (test)
                        OR  nlbbinb [adapter_guid] (test)
                        OR  nlbcfg [adapter_guid]  (test)

options                 /u domain\user [password | *]
--*/
{
    KEYWORD kw = KW_UNKNOWN;

    //
    // If no args, or one arg and that is /? or /help, we display help.
    //
    {
        BOOL fDoHelp = FALSE;

        if (argc<2)
        {
            fDoHelp = TRUE;
        }
        else if (argc == 2)
        {
            if (!_wcsicmp(argv[1], L"/?") || !wcscmp(argv[1], L"/help"))
            {
                fDoHelp = TRUE;
            }
        }

        if (fDoHelp)
        {
            kw = KW_HELP;
            goto end;
        }
    }


    argv++; // skip past program name.
    argc--;
    

    g.fReadPassword = FALSE;
    g.fGotGuid      = FALSE;
    g.fGotFriendlyName = FALSE;
    g.fRunOnce      = FALSE;
    g.fUseWmi = FALSE;
    g.fLocalHost  = FALSE;
    g.MachineName[0] = 0;
    g.UserName[0] = 0;
    g.Password[0] = 0;

#if 0
    #define MAX_MACHINE_NAME_LENGTH 256
    #define MAX_PASSWORD_LENGTH 256
    #define INPUT_BUFFER_LENGTH 256

    WCHAR MachineName[MAX_MACHINE_NAME_LENGTH+1];
    WCHAR Password[MAX_PASSWORD_LENGTH+1];
    WCHAR InputBuffer[INPUT_BUFFER_LENGTH+1];

    BOOL fUseWmi;
    BOOL fLocalHost;

#endif // 0


    //
    // Get the mandatory machine name information, which must be first.
    //
    {
        if (!_wcsicmp(*argv, L"-"))
        {
            g.fUseWmi = FALSE;
        }
        else if (!wcscmp(*argv, L"."))
        {
            g.fUseWmi = TRUE;
            g.fLocalHost  = TRUE;
        }
        else
        {
            //
            // read machine name
            //
            if (wcslen(*argv) >= ARRAY_LENGTH(g.MachineName))
            {
                wprintf(L"Machine name should be a maximum of %lu characters.\n",
                    ARRAY_LENGTH(g.MachineName)-1);
                goto end;
            }
            ARRAYSTRCPY(g.MachineName, *argv);
            g.fUseWmi = TRUE;
        }

        argv++;
        argc--;
    }



    while (argc)
    {
        if (!_wcsnicmp(*argv, L"/u:", 3))
        {
            //
            // Parse user name and password
            //
    
            LPCWSTR szUser = (*argv)+3;
            wprintf(L"OPTION USER -- User==\"%ws\"\n", szUser);
            UINT Len = wcslen(szUser);
            if (Len == 0 || Len >= ARRAY_LENGTH(g.UserName))
            {
                wprintf(L"Invalid User Name: \"%ws\"\n", szUser);
                goto end;
            }
            ARRAYSTRCPY(g.UserName, szUser);
    
            argv++;
            argc--;
    
            if (argc)
            {
                //
                // Get the password
                //
    
                LPCWSTR szPassword = *argv;
                wprintf(L"PASSWORD=\"%ws\"\n", szPassword);
                Len = wcslen(szUser);
                if (Len >= ARRAY_LENGTH(g.Password))
                {
                    wprintf(L"Pasword too long\n");
                    goto end;
                }
                if (!wcscmp(szPassword, L"*"))
                {
                    g.fReadPassword = TRUE;
                }
                else
                {
                    g.fReadPassword = FALSE;
                    ARRAYSTRCPY(g.Password, szPassword);
                }
                argv++;
                argc--;
            }
        }
        else
        {
            BOOL fNeedGuid = FALSE;

            if (g.fRunOnce)
            {
                // 
                // We've already picked up a command to execute,
                // so this is unexpected.
                //
                wprintf(L"Unexpected parameter \"%ws\"\n", *argv);
                kw = KW_UNKNOWN;
                goto end;
            }
            g.fRunOnce = TRUE;

            kw = lookup_keyword(*argv);
            switch(kw)
            {
            case KW_UPDATE:
            case KW_IPADDR:
            case KW_NLBBIND:
            case KW_NLBCFG:
                fNeedGuid = TRUE;
                break;

            case KW_ADAPTER_LIST:
            case KW_HELP:
                break;

            default:
                wprintf(L"Unexpected parameter \"%ws\"\n", *argv);
                kw = KW_UNKNOWN;
                goto end;
            }

            argv++;
            argc--;

            if (fNeedGuid)
            {
                g.fGotGuid             = FALSE;
                g.fGotFriendlyName     = FALSE;

                if (argc)
                {
                    LPCWSTR szGuid = *argv;
                    //
                    // Get the NIC GUID or friendly name
                    //
                    UINT Len = wcslen(szGuid);

                    if (!Len)
                    {
                        argv++;
                        argc--;
                        continue;
                    }

                    if (
                              Len==NLB_GUID_LEN 
                           && szGuid[0] == '{'
                           && szGuid[Len-1]=='}'
                       )
                    {
                        ARRAYSTRCPY(g.AdapterGuid, szGuid);
                        g.fGotGuid     = TRUE;
                        argv++;
                        argc--;
                    }
                    else if (szGuid[0] == '/')
                    {
                        // Treat this as an option, not friendly name.
                    }
                    else  if (   szGuid[0] != '{' // '}'
                              && Len < NLB_MAX_FRIENDLY_NAME_LENGTH)
                    {
                        //
                        // let's assume that this is a friendly name
                        //
                        // Note -- I checked and friendly name can be
                        // pretty much any printible character -- including
                        // ! etc.
                        //
                        // SO "/....." is a valid friendly name, but we
                        // treat it like an option.
                        // Also, "{....}" is a valid friendly name, but we
                        // assume it's a malformed guid.
                        // 
                        ARRAYSTRCPY(g.FriendlyName, szGuid);
                        g.fGotFriendlyName  = TRUE;
                        argv++;
                        argc--;

                    }
                    else
                    {
                        wprintf(L"Expecting Adapter GUID or frienly name, not \"%ws\"\n", szGuid);
                        kw = KW_UNKNOWN;
                        goto end;
                    }
                    
                }
            }
        }
    }

    if (kw==KW_UNKNOWN)
    {
        //
        // This means that no command was specified -- we invoke the
        // shell
        //
        kw = KW_MAIN_SHELL;
    }


#if 0
    if (!wcscmp(argv[1], L"/uipaddr"))

    if (!wcscmp(argv[1], L"ipaddr"))
    {
        ret = DO_IPADDR;
    }
    else if (!wcscmp(argv[1], L"nlbcfg"))
    {
        ret = DO_NLBCFG;
    }
    else if (!wcscmp(argv[1], L"nlbbind"))
    {
        ret = DO_NLBBIND;
    }
    else if (!wcscmp(argv[1], L"update"))
    {
        ret = DO_UPDATE;
    }
    else if (!wcscmp(argv[1], L"wmiupdate"))
    {
        ret = DO_WMIUPDATE;
    }
    else if (!wcscmp(argv[1], L"cleanreg"))
    {
        ret = DO_CLEANREG;
    }
    else
    {
        printf("ERROR: unknown argument\n");
    }
#endif // 0
end:

    return kw;
}

KEYWORD lookup_keyword(LPCWSTR szKeyword)
{
    KEYWORD kw = KW_UNKNOWN;

    const KEYWORD_MAP *pMap = KeywordMap;

    for (; pMap->sz!=NULL; pMap++)
    {
        if (!_wcsicmp(szKeyword, pMap->sz))
        {
            // printf("Matched %ws. kw=%lu\n", pMap->sz, pMap->kw);
            break;
        }
    }

    if (pMap->sz != NULL)
    {
        kw = pMap->kw;
    }

    return kw;

}

KEYWORD read_keyword(LPCWSTR szPrompt)
/*++
    If global (g.fRunOnce) is TRUE, return immediately with KW_QUIT.
    Otherwise, read and identify a keyword from a set of pre-defined keywords.
--*/
{
    KEYWORD kw = KW_UNKNOWN;

    g.InputBuffer[0] = 0;

    wprintf(L"%s", szPrompt);

    // 
    // Skip past comment characters...
    //
    while (wscanf(L" %1[;]", g.InputBuffer) == 1)
    {
        // skip rest of this line...
        WCHAR wc = 0;
        do {
            wc = getwchar();
        } while  (wc != WEOF && wc != '\n' && wc != '\r');
    }

    if (wscanf(L" %50[a-zA-Z.?]", g.InputBuffer) != 1)
    {
        //
        // Invalid input, lets try to read it all into our buffer
        //
        if (wscanf(L"%100ws", g.InputBuffer) == 1)
        {
            g.InputBuffer[0] = 0;
        }
        goto end;
    }
    
    kw = lookup_keyword(g.InputBuffer);

end:

    if (kw == KW_UNKNOWN)
    {
        if (feof(stdin))
        {
           kw = KW_QUIT; 
        }
        else
        {
            //
            // Kill all subsequent input
            //
            fseek(stdin, 0, SEEK_END);
        }
    }
    return kw;

}

void
test_read_keyword(void)
{
    KEYWORD kw;

    do
    {
        kw = read_keyword(L"test: ");

    } while (kw != KW_QUIT);

}

void parse_main(int argc, WCHAR* argv[])
{
    #define szMAIN_PROMPT L"nlbcfg: "

    KEYWORD kw;

    kw = parse_args(argc, argv);

#if 0
    wprintf(L"ARGS: MachineName   = \"%ws\"\n", g.MachineName);
    wprintf(L"ARGS: UserName      = \"%ws\"\n", g.UserName);
    wprintf(L"ARGS: Password      = \"%ws\"\n", g.Password);
    wprintf(L"ARGS: AdapterGuid   = \"%ws\"\n", g.AdapterGuid);
    wprintf(L"ARGS: fReadPassword = %lu\n", g.fReadPassword);
    wprintf(L"ARGS: fUseWmi       = %lu\n", g.fUseWmi);
    wprintf(L"ARGS: fLocalHost    = %lu\n", g.fLocalHost);
    wprintf(L"ARGS: fGotGuid     = %lu\n", g.fGotGuid);
    wprintf(L"ARGS: KEYWORD = %lu\n", (UINT) kw);
#endif // 0

    if (kw == KW_UNKNOWN || kw == KW_HELP)
    {
        if (kw == KW_HELP)
        {
            do_usage();
        }
        goto end;
    }

    //
    // If necessary, read password.
    //
    if (g.fReadPassword)
    {
        if (!read_password()) goto end;
        // wprintf(L"ARGS2: Password      = \"%ws\"\n", g.Password);
    }


    if (g.fUseWmi && !g.fLocalHost)
    {
        //
        // Let's ping the host....
        //
        WBEMSTATUS Status;
        ULONG uIpAddress;
        wprintf(L"Pinging %ws...\n", g.MachineName);
        Status =  NlbHostPing(g.MachineName, 2000, &uIpAddress);
        if (FAILED(Status))
        {
             wprintf(L"Ping failed\n");
            goto end;
        }
        else
        {
             wprintf(L"Ping succeeded\n");
        }
    }

    // kw = KW_QUIT;

    while (kw != KW_QUIT)
    {

        switch(kw)
        {
        case KW_MAIN_SHELL:
            kw = read_keyword(szMAIN_PROMPT);
            break;

        case KW_IPADDR: do_ipaddr();
             break;
        case KW_NLBCFG: do_nlbcfg();
             break;
        case KW_NLBBIND: do_nlbbind();
             break;

        case KW_ADAPTER_LIST: kw = parse_adapter_list();
            break;

        case KW_UPDATE: kw = parse_update();
            break;

        case KW_HELP:
            kw = parse_main_help();
            break;

        case KW_UNKNOWN:
        default:
            printf(
                "\"%ws\" is unexpected. Type \"help\""
                " for more information.\n",
                g.InputBuffer
                );
            kw = read_keyword(szMAIN_PROMPT);
            break;
        }
    }

end:

    return;
}

KEYWORD parse_adapter_list(VOID)
/*
    Report adapter list and read next command.
*/
{
    KEYWORD kw = KW_UNKNOWN;

    if (g.fUseWmi)
    {
        do_wminiclist(NULL, NULL);
    }
    else
    {
        do_niclist(NULL, NULL);
    }


    if (g.fRunOnce)
    {
        kw = KW_QUIT;
    }
    else
    {
        kw = read_keyword(szMAIN_PROMPT);
    }


    return kw;
}

VOID display_update_help(VOID);
VOID parse_network_addresses(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg,
        BOOL *pfModified);
VOID parse_modify_network_address(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg,
        BOOL *pfModified);
VOID parse_nlb_bound(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_cluster_network_address(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_cluster_name(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_traffic_mode(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_port_rules(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_host_priority(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_dedicated_network_address(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_cluster_mode_on_start(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_persist_suspend_on_reboot(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_remote_control_enabled(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
VOID parse_remote_password(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg);
void
parse_control(
        BOOL fWmi,
        PWMI_CONNECTION_INFO pConnInfo,
        LPCWSTR szNicGuid
        );

void
parse_query(
        BOOL fWmi,
        PWMI_CONNECTION_INFO pConnInfo,
        LPCWSTR szNicGuid
        );

KEYWORD parse_update(VOID)
#if 0
        nlbcfg> update {guid}
        Enter Adapter GUID: {guid}
        NLB Configuration for Adapter xxxx xxxx:
        Enter updated configuration, or type help for more information.
        nlbcfg update> cna=10.0.0.1/255.255.255.0
        nlbcfg update> cna=10.0.0.1/255.255.255.0
        nlbcfg update> cna=10.0.0.1/255.255.255.0
        nlbcfg update> .
        Proposed new configuration:
        .....
        Enter y to confirm:
        nlbcfg update> y
        Going to perform update
        ...
        
        ....
        complete
        Reading configuration:
        .......
        Enter updated configuration or other command.
        nlbcfg update>q
#endif // 0
{

    BOOL                fUseWmi = g.fUseWmi;
    BOOL                fLocal  = g.fLocalHost;
    LPCWSTR             szNicGuid = g.AdapterGuid;
    WBEMSTATUS          Status;
    WBEMSTATUS          CompletionStatus;
    UINT                Generation;
    WMI_CONNECTION_INFO ConnInfo;
    PWMI_CONNECTION_INFO pConnInfo = NULL;
    WCHAR               LocalName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD               dwLen=ARRAY_LENGTH(LocalName);
    BOOL                fUserSetNetworkAddresses = FALSE;
    BOOL                fModified = FALSE;
    BOOL                fCheckNewConfiguration = FALSE;

    //
    // Skip reading the GUID if we've got it from the command line.
    //
    if (!g.fGotGuid)
    {
        if (g.fGotFriendlyName)
        {
            if (!get_guid_by_friendly_name())
            {
                printf(
                   "Could not find adapter with name \"%ws\"\n",
                   g.FriendlyName
                   );
                goto end;
            }
        }
        else
        {
            LPWSTR    szNic = NULL;
            if (!read_guid(&szNic)) goto end;
            ARRAYSTRCPY(g.AdapterGuid, szNic);
            delete szNic;
            szNic=NULL;
        }

    }

    if (!GetComputerName(LocalName, &dwLen))
    {
        ARRAYSTRCPY(LocalName, L"TPROV.EXE");
    }

    ZeroMemory(&ConnInfo, sizeof(ConnInfo));

    if (fUseWmi && !fLocal)
    {
        ConnInfo.szMachine  = g.MachineName;
        if (g.UserName[0])
        {
            ConnInfo.szUserName = g.UserName;
            ConnInfo.szPassword = g.Password;
        }
        pConnInfo           = &ConnInfo;
    }

start:

    KEYWORD             kw = KW_UNKNOWN; 
    WCHAR               *pLog = NULL;
    BOOL                fSetDefaults = FALSE;
    BOOL                fUnbind = FALSE;
    BOOL                fConfigInputDone = FALSE;


    //
    // Clean up config info
    //
    MyOldCfg.Clear();
    MyNewCfg.Clear();

    MyBreak(L"Break before calling GetConfiguration.\n");

    if (!fUseWmi)
    {

        Status = NlbConfigurationUpdate::GetConfiguration(
                    szNicGuid,
                    &MyOldCfg
                    );
    }
    else
    {
        Status = NlbHostGetConfiguration(
                    pConnInfo,
                    szNicGuid,
                    &MyOldCfg
                    );
    }

    if (FAILED(Status))
    {
        wprintf(L"Could not get configuration for Adapter %ws\n", szNicGuid);
        goto end;
    }

    display_config2(szNicGuid, &MyOldCfg);
    
    //
    // 6/2002 JosephJ Following disabled because of false failures reported
    //        need to investigate further.
    //
    if (0 && fCheckNewConfiguration)
    {
        //
        // Check MyOldCfg against MyNewCfg -- report a problem if
        // they are NOT equivalent.
        //
        NLBERROR nerr;
        BOOL  fConnectivityChange = FALSE;
        nerr = MyOldCfg.AnalyzeUpdate(
                &MyNewCfg,
                &fConnectivityChange
                );

        if (nerr != NLBERR_NO_CHANGE)
        {
            wprintf(L"WARNING: New parameters may not match requested parameters\n");
            g_nRetCode =  RETCODE_NEW_CONFIG_DOESNT_MATCH;
        }
        else
        {
            wprintf(L"New parameters match requested parameters!\n");
        }
    }
    fCheckNewConfiguration = FALSE;
    
    if (MyOldCfg.fBound)
    {
        if (!MyOldCfg.fValidNlbCfg)
        {
            //
            // We're bound, but nlb params are bad. Set defaults.
            //
            wprintf(L"NLB is bound, but NLB parameters appear to be bad. Setting defaults\n");
            fSetDefaults = TRUE;
        }
    }
    else
    {
        //
        // We're previously unbound. Set defaults.
        //
        fSetDefaults = TRUE;
    }

    //
    // We setup the new configuration based on the old configuration, but
    // additionally (if required) set the NLB params to default values,
    // whether-or-not NLB is bound.
    //
    MyNewCfg.Update(&MyOldCfg); // copy

    //
    // We zap the network address list.
    // We'll pick up the old ones IF the user hasn't changed them.
    //
    MyNewCfg.SetNetworkAddresses(NULL, 0);

    if (fSetDefaults)
    {
        CfgUtilInitializeParams(&MyNewCfg.NlbParams);
        MyNewCfg.fValidNlbCfg = TRUE;
    }
    else
    {
        ASSERT(MyNewCfg.fBound == TRUE);
    }
    ASSERT(MyNewCfg.fValidNlbCfg == TRUE);

    wprintf(L"Enter updated configuration, or type help for more information.\n");

    //
    // We accept changes to the configuration in a loop.
    // We get out of the loop when the user types "." or "quit"
    //
    do
    {
        #define szUPDATE_PROMPT L"nlbcfg update> "
        kw = read_keyword(szUPDATE_PROMPT);

        switch(kw)
        {

        case KW_QUIT:
            printf("quit\n");
            fConfigInputDone = TRUE;
            break;

        case KW_DOT:
            printf("END OF CONFIG INPUT\n");
            fConfigInputDone = TRUE;
            break;


        case KW_HELP:
            display_update_help();
            break;


        case KW_NETWORK_ADDRESSES:
            fModified = FALSE;
            parse_network_addresses(&MyNewCfg, &fModified);
            if (fModified)
            {
                fUserSetNetworkAddresses = TRUE;
            }
            break;

        case KW_MODIFY_NETWORK_ADDRESS:
            fModified = FALSE;
            parse_modify_network_address(&MyNewCfg, &fModified);
            if (fModified)
            {
                fUserSetNetworkAddresses = TRUE;
            }
            break;

#if 0
        case KW_PARTIAL_UPDATE:
            printf("partial update\n");
            break;
#endif // 0

        case KW_NLB_BOUND:
            parse_nlb_bound(&MyNewCfg);
            break;

        case KW_CLUSTER_NETWORK_ADDRESS:
            parse_cluster_network_address(&MyNewCfg);
            break;

        case KW_CLUSTER_NAME:
            parse_cluster_name(&MyNewCfg);
            break;

        case KW_TRAFFIC_MODE:
            parse_traffic_mode(&MyNewCfg);
            break;

        case KW_PORT_RULES:
            parse_port_rules(&MyNewCfg);
            break;

        case KW_HOST_PRIORITY:
            parse_host_priority(&MyNewCfg);
            break;

        case KW_DEDICATED_NETWORK_ADDRESS:
            parse_dedicated_network_address(&MyNewCfg);
            break;

        case KW_CLUSTER_MODE_ON_START:
            parse_cluster_mode_on_start(&MyNewCfg);
            break;

        case KW_PERSIST_SUSPEND_ON_REBOOT:
            parse_persist_suspend_on_reboot(&MyNewCfg);
            break;

        case KW_REMOTE_CONTROL_ENABLED:
            parse_remote_control_enabled(&MyNewCfg);
            break;

        case KW_PASSWORD:
            parse_remote_password(&MyNewCfg);
            break;

        case KW_LIST:
            display_config2(szNicGuid, &MyNewCfg);
            break;

        case KW_CONTROL:
            parse_control(fUseWmi, pConnInfo, szNicGuid); // actually do op
            break;

        case KW_QUERY:
            parse_query(fUseWmi, pConnInfo, szNicGuid);
            break;
    
        case KW_UNKNOWN:
        default:
            printf("unknown command \"%ws\"!\n", g.InputBuffer);
            break;

        }

    } while (!fConfigInputDone);

    if (kw == KW_QUIT)
    {
        goto end;
    }


    if (MyOldCfg.IsNlbBound() == MyNewCfg.IsNlbBound())
    {
        if (!fUserSetNetworkAddresses)
        {
            LPWSTR *pszOldAddresses = NULL;
            UINT NumOldAddresses = 0;
            ASSERT(MyNewCfg.NumIpAddresses == 0);
            Status =  MyOldCfg.GetNetworkAddresses(
                            &pszOldAddresses,
                            &NumOldAddresses
                            );

            if (FAILED(Status))
            {
                wprintf(L"Error extracting old IP addresses\n");
                NumOldAddresses = 0;
                pszOldAddresses = NULL;
            }

            MyNewCfg.SetNetworkAddresses(
                (LPCWSTR*)pszOldAddresses,
                NumOldAddresses
                );
            delete pszOldAddresses;
            pszOldAddresses=NULL;
        }
    }
    else if (!MyNewCfg.IsNlbBound())
    {
        //
        // We're to unbind.
        //

        if (!fUserSetNetworkAddresses)
        {
            //
            // Set the list of ip address to have present on unbind to
            // be the dedicated ip address, if there is one, otherwise zero,
            // in which case the adapter will be switched to DHCP after NLB
            // is unbound
            //
    
            ASSERT(MyNewCfg.NumIpAddresses == 0);
            
            if (MyOldCfg.NlbParams.ded_ip_addr[0]!=0)
            {
                NLB_IP_ADDRESS_INFO *pIpInfo;
                pIpInfo = new NLB_IP_ADDRESS_INFO;
                if (pIpInfo == NULL)
                {
                    printf("TEST: allocation failure; can't add IP on unbind.\n");
                }
                else
                {
                    ARRAYSTRCPY(pIpInfo->IpAddress, MyOldCfg.NlbParams.ded_ip_addr);
                    ARRAYSTRCPY(pIpInfo->SubnetMask, MyOldCfg.NlbParams.ded_net_mask);
                    MyNewCfg.NumIpAddresses = 1;
                    MyNewCfg.pIpAddressInfo = pIpInfo;
                }
            }
        }
    }

    display_config2(szNicGuid, &MyNewCfg);

    kw = read_keyword(L"Begin update? ");
    while (kw!=KW_YES && kw!=KW_NO)
    {
        kw = read_keyword(L"Enter yes or no: ");
    }

    if (kw == KW_NO) goto start; // TODO: get rid of these gotos!
    
    MyBreak(L"Break before calling DoUpdate.\n");

    //
    // Set the AddDedicateIp and AddClusterIps fields.
    //
    MyNewCfg.fAddDedicatedIp = TRUE;
    MyNewCfg.fAddClusterIps = TRUE;

    if (!fUseWmi)
    {
        Status = NlbConfigurationUpdate::DoUpdate(
                    szNicGuid,
                    LocalName,
                    &MyNewCfg,
                    &Generation,
                    &pLog
                    );
    }
    else
    {
        Status = NlbHostDoUpdate(
                    pConnInfo,
                    szNicGuid,
                    LocalName,
                    &MyNewCfg,
                    &Generation,
                    &pLog
                    );
    }

    if (pLog != NULL)
    {
        display_log(pLog);
        delete pLog;
        pLog = NULL;
    }

    if (Status == WBEM_S_PENDING)
    {
        printf(
            "Waiting for pending operation %d...\n",
            Generation
            );
    }

    while (Status == WBEM_S_PENDING)
    {
        Sleep(1000);

        if (!fUseWmi)
        {
            Status = NlbConfigurationUpdate::GetUpdateStatus(
                        szNicGuid,
                        Generation,
                        FALSE,  // FALSE == Don't delete completion record
                        &CompletionStatus,
                        &pLog
                        );
        }
        else
        {
            Status = NlbHostGetUpdateStatus(
                        pConnInfo,
                        szNicGuid,
                        Generation,
                        &CompletionStatus,
                        &pLog
                        );
        }
        if (pLog != NULL)
        {
            display_log(pLog);
            delete pLog;
            pLog = NULL;
        }
        if (!FAILED(Status))
        {
            Status = CompletionStatus;
        }
    }

    printf(
        "Final status of update %d is 0x%08lx\n",
        Generation,
        Status
        );

    if (FAILED(Status))
    {
        g_nRetCode = RETCODE_UPDATE_FAILED;
    }
    else
    {
        fCheckNewConfiguration = TRUE;
        g_nRetCode = RETCODE_NO_ERROR;
    }


    goto start;

end:

    if (g.fRunOnce)
    {
        kw = KW_QUIT;
    }
    else
    {
        kw = read_keyword(szMAIN_PROMPT);
    }


    return kw;
}

VOID display_update_help(VOID)
{
    wprintf(L"\nNlbCfg update-specific commands\n");
    wprintf(L"    Help\n");
    wprintf(L"    ; <comment text>\n");
    wprintf(L"    na|NetworkAddresses         = <list of IP addresses and subnets>\n");
    wprintf(L"    nb|NlbBound                 = true | false\n");
    wprintf(L"    cn|ClusterName              = <cluster domain name>\n");
    wprintf(L"    tm|TrafficMode              = UNICAST | MULTICAST | IGMPMULTICAST\n");
    wprintf(L"    pr|PortRules                = <list of port rules>\n");
    wprintf(L"    hp|HostPriority             = <host priority>\n");
    wprintf(L"    ps|PersistSuspend           =  true | false\n");
    wprintf(L"    dna|DedicatedNetworkAddress = <dedicated IP address and subnet>\n");
    wprintf(L"    cmos|ClusterModeOnStart     =  true | false\n");
    wprintf(L"    rce|RemoteControlEnabled    = true | false\n");
    wprintf(L"    p|Password                  = <remote control password>\n");
    wprintf(L"    cl|Control start(st) | stop(sp) | drainstop(ds) | suspend(su) | resume(re) | query(qu) \n");
    wprintf(L"    cl|Control [vip=<ip-addr>] port=<port> enable(en) | disable(di) | drain(dn) | query(qu) \n");
    wprintf(L"    Query                       -- queries for cluster members\n");
    wprintf(L"    q|Quit\n");

    wprintf(L"\nExample:\n");
    wprintf(L"    ; this is a comment\n");
    wprintf(L"    NlbBound = true\n");
    wprintf(L"    nb = true     (equivalent to the above)\n");
    wprintf(L"    NetworkAddresses = {10.1.0.6/255.255.0.0, 10.1.0.66/255.255.0.0}\n");
    wprintf(L"    ClusterNetworkAddress = 10.1.0.66/255.255.0.0\n");
    wprintf(L"    ClusterName = cluster.domain.com\n");
    wprintf(L"    TrafficMode = UNICAST\n");
    wprintf(L"    PortRules =\n");
    wprintf(L"    {\n");
    wprintf(L"        ip=10.0.1.1 protocol=TCP start=80 end=288 mode=SINGLE priority=1\n");
    wprintf(L"    }\n");
    wprintf(L"    HostPriority = 1\n");
    wprintf(L"    DedicatedNetworkAddress = 10.1.0.6/255.255.0.0\n");
    wprintf(L"    ClusterModeOnStart = true\n");
    wprintf(L"    RemoteControlEnabled = false\n");
    wprintf(L"    cl start\n");
    wprintf(L"    cl vip=10.1.1.1 port=80 drain\n");
    wprintf(L"    cl port=80 disable\n");
    wprintf(L"    Query\n");
}


VOID parse_network_addresses(
        NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg,
        BOOL *pfModified
        )
#if 0

    Input format (the NetworkAddresses part has already been read)

    NetworkAddresses = {
        10.0.0.1/255.0.0.0,
        10.0.0.2/255.0.0.0,
        10.0.0.3/255.0.0.0,
        } 

#endif // 0
{
    #define MAX_INPUT_ADDRESSES 20
    LPWSTR *pszAddresses = NULL;
    UINT Count=0;

    *pfModified = FALSE;

    #define MY_MAX_NETWORK_ADDRESS_LENGTH \
    (WLBS_MAX_CL_IP_ADDR + 1 + WLBS_MAX_CL_NET_MASK)

    pszAddresses = CfgUtilsAllocateStringArray(
                        MAX_INPUT_ADDRESSES,
                        MY_MAX_NETWORK_ADDRESS_LENGTH
                        );

    if (pszAddresses == NULL)
    {
        wprintf(L"Memory Allocation Failure.\n");
        goto  end;
    }

    //
    // Look for = and open brace
    //
    if (wscanf(L" = %1[{]", g.InputBuffer) != 1) // -}-
    {
        goto end_bad_input;
    }

    //
    // Read a list of comma-separated ipaddresses/subnets
    //
    BOOL fDone = FALSE;
    while (!fDone && Count<MAX_INPUT_ADDRESSES)
    {
        LPWSTR  szAddr = pszAddresses[Count];
        WCHAR IpAddress[32];
        WCHAR SubnetMask[32];
        BOOL fGotAddr = FALSE;

        INT i =  wscanf(
                    L" %15[0-9.] / %15[0-9.] ",
                    IpAddress,
                    SubnetMask
                    );
        if (i==2)
        {
            StringCchPrintf(
                szAddr,
                MY_MAX_NETWORK_ADDRESS_LENGTH,
                L"%ws/%ws", IpAddress, SubnetMask);
            fGotAddr = TRUE;
            Count++;
        }
        else if (i==1)
        {
            wprintf(L"Missing subnet mask.\n");    
            goto end;
        }
        
        //
        // Look for , or open-brace
        //
        i = wscanf(L" %1[},]", g.InputBuffer); // -{-
        if (i == 1)
        {
            if (*g.InputBuffer == '}')  // -{-
            {
                fDone = TRUE;
            }
            else if (!fGotAddr || *g.InputBuffer != ',')
            {
                wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
                goto end;
            }
        }
        else
        {
            goto end_bad_input;
        }
    }

    //
    // We've got zero or more ip addresses. Let's set em.
    //
    WBEMSTATUS Status;
    Status = pCfg->SetNetworkAddresses((LPCWSTR*)pszAddresses, Count);
    if (FAILED(Status))
    {
        wprintf(L"Error 0x%08lx copying network addresses\n", (UINT) Status);
    }
    else
    {
        *pfModified = TRUE;
    }

#if 0
    UINT AddrCount = pCfg->NumIpAddresses;
    display_ip_info2(AddrCount, pCfg->pIpAddressInfo);
#endif // 0

    goto end;

end_bad_input:

    if (wscanf(L"% 100ws", g.InputBuffer)!=1)
    {
        *g.InputBuffer = 0;
    }
    wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);

    // fall through...

end:

    delete pszAddresses;
    pszAddresses = NULL;

    return;
}


VOID parse_modify_network_address(
        NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg,
        BOOL *pfModified
        )
#if 0

    Input format (the ModifyNetworkAddress part has already been read)

    ModifyNetworkAddress = 10.0.0.1, 10.0.0.2/255.0.0.0
    ModifyNetworkAddress = -, 10.0.0.2/255.0.0.0
    ModifyNetworkAddress = 10.0.0.1, -
    ModifyNetworkAddress = -,-

#endif // 0
{

    WCHAR rgOldAddr[32];
    WCHAR rgNewIpAddr[66];
    WCHAR rgNewSubnetMask[32];
    LPCWSTR szOldAddr = NULL;
    LPCWSTR szNewIpAddr = NULL;

    *pfModified = FALSE;
    *rgOldAddr = 0;
    *rgNewIpAddr = 0;
    *rgNewSubnetMask = 0;

    INT i =  wscanf(L" = %15[0-9.-] ,", rgOldAddr);
    if (i!=1)
    {
        goto end_bad_input;
    }

    i =  wscanf(L" %15[0-9.-]", rgNewIpAddr);
    if (i!=1)
    {
        goto end_bad_input;
    }

    if (_wcsicmp(rgNewIpAddr, L"-"))
    {
        i =  wscanf(L" / %15[0-9.]", rgNewSubnetMask);
    
        if (i!=1)
        {
            wprintf(L"Missing subnet mask.\n");    
            goto end_bad_input;
        }
        szNewIpAddr = rgNewIpAddr;
    }


    if (_wcsicmp(rgOldAddr, L"-"))
    {
        szOldAddr = rgOldAddr;
    }


    WBEMSTATUS Status;

#if 1
    Status = pCfg->ModifyNetworkAddress(szOldAddr, szNewIpAddr,rgNewSubnetMask);
#else
    {
        BOOL fRet;
        NlbIpAddressList IpList;
        fRet = IpList.Set(pCfg->NumIpAddresses, pCfg->pIpAddressInfo, 0);
        if (fRet)
        {
            fRet = IpList.Modify(szOldAddr, szNewIpAddr, rgNewSubnetMask);
        }
        if (fRet)
        {
            pCfg->SetNetworkAddressesRaw(NULL,0);
            IpList.Extract(REF pCfg->NumIpAddresses, REF pCfg->pIpAddressInfo);
            Status = WBEM_NO_ERROR;
        }
        else
        {
            Status = WBEM_E_CRITICAL_ERROR;
        }
    }
#endif
    if (Status != WBEM_NO_ERROR)
    {
        printf("pCfg->ModifyNetworkAddress returns error 0x%08lx\n",
                    Status);
    }
    *pfModified = TRUE;

    goto end;

end_bad_input:

    if (wscanf(L"% 100ws", g.InputBuffer)!=1)
    {
        *g.InputBuffer = 0;
    }
    wprintf(
      L"Invalid format. Format: [-|ip-address],[-|network-address]\n");

    // fall through...

end:

    return;
}


VOID parse_nlb_bound(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*
    NlbBound = true | false
*/
{
    BOOL NlbBound = FALSE;
    
    INT i =  wscanf(
                L" = %15s",
                g.InputBuffer
                );
    if (i==1)
    {
        if (!_wcsicmp(g.InputBuffer, L"true") || !_wcsicmp(g.InputBuffer, L"t"))
        {
            NlbBound = TRUE;
        }
        else if (!_wcsicmp(g.InputBuffer, L"false") || !_wcsicmp(g.InputBuffer, L"f"))
        {
            NlbBound = FALSE;
        }
        else
        {
            wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
            goto end;
        }
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }

    pCfg->SetNlbBound(NlbBound);

    // wprintf(L"DBG: NlbBound=%lu\n", pCfg->IsNlbBound());

end:

    return;
}


VOID parse_cluster_network_address(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*++
    ClusterNetworkAddress = 10.0.0.0/255.255.255.255
--*/
{

    WCHAR IpAddress[32];
    WCHAR SubnetMask[32];

    INT i =  wscanf(
                L" = %15[0-9.] / %15[0-9.]",
                IpAddress,
                SubnetMask
                );
    if (i==2)
    {
        StringCbPrintf(
            g.InputBuffer,
            sizeof(g.InputBuffer),
            L"%ws/%ws", IpAddress, SubnetMask);
        pCfg->SetClusterNetworkAddress(g.InputBuffer);
    }
    else if (i==1)
    {
        wprintf(L"Missing subnet mask.\n");    
        goto end;
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }
        
    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // DBG
    {
        LPWSTR szAddr = NULL;
        WBEMSTATUS Status;
        Status = pCfg->GetClusterNetworkAddress(&szAddr);
        if (FAILED(Status))
        {
            printf("Couldn't get address!\n");
        }
        else
        {
            // wprintf(L"DBG: CNA=%ws\n", szAddr);
            delete szAddr;
        }
    }

end:

    return;
}


VOID parse_cluster_name(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*++
    ClusterName = cluster.microsoft.com
--*/
{
    INT i =  wscanf(
                L" = %ws",
                g.InputBuffer
                );
    if (i==1)
    {
        pCfg->SetClusterName(g.InputBuffer);
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }
        
    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // DBG
    {
        LPWSTR szName = NULL;
        WBEMSTATUS Status;
        Status = pCfg->GetClusterName(&szName);
        if (FAILED(Status))
        {
            printf("Couldn't get name!\n");
        }
        else
        {
            // wprintf(L"DBG: CN=%ws\n", szName);
            delete szName;
        }
    }

end:

    return;
}


VOID parse_traffic_mode(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*
    TrafficMode = UNICAST | MULTICAST | IGMPMULTICAST
*/
{
    NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE TrafficMode;

    INT i =  wscanf(
                L" = %ws",
                g.InputBuffer
                );
    if (i==1)
    {


        if (!_wcsicmp(g.InputBuffer, L"UNICAST") || !_wcsicmp(g.InputBuffer, L"U"))
        {
           TrafficMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_UNICAST;
        }
        else if (!_wcsicmp(g.InputBuffer, L"MULTICAST") || !_wcsicmp(g.InputBuffer, L"M"))
        {
           TrafficMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_MULTICAST;
        }
        else if (!_wcsicmp(g.InputBuffer, L"IGMPMULTICAST") || !_wcsicmp(g.InputBuffer, L"I"))
        {
           TrafficMode=NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE_IGMPMULTICAST;
        }
        else
        {
            wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
            goto end;
        }

        pCfg->SetTrafficMode(TrafficMode);
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }
        
    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // DBG
    {
        TrafficMode = pCfg->GetTrafficMode();
        // wprintf(L"DBG: TrafficMode=%ld\n", (UINT) TrafficMode);
    }

end:

    return;
}


VOID parse_port_rules(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
{
    #define MAX_PORT_RULES 32
    LPWSTR *pszPortRules = NULL;
    UINT Count=0;


    #define MY_MAX_PORT_RULE_LENGTH 128

    pszPortRules = CfgUtilsAllocateStringArray(
                        MAX_PORT_RULES,
                        MY_MAX_PORT_RULE_LENGTH
                        );

    if (pszPortRules == NULL)
    {
        wprintf(L"Memory Allocation Failure.\n");
        goto  end;
    }

    //
    // Look for = and open brace
    //
    if (wscanf(L" = %1[{]", g.InputBuffer) != 1) // -}-
    {
        goto end_bad_input;
    }

    //
    // Read a list of comma-separated list of port rules
    //
    BOOL fDone = FALSE;
    while (!fDone && Count<MAX_PORT_RULES)
    {
        LPWSTR  szPR = pszPortRules[Count];
        BOOL fGotPR = FALSE;
        int i;

        //
        // We suck up everything until the first , or close-brace.
        //
        if (wscanf(L" %128[^},]", g.InputBuffer) == 1) // -{-
        {
            BOOL fRet = FALSE;
            WLBS_PORT_RULE Pr;
            // printf("DBG: Got \"%ws\"\n", g.InputBuffer);
            fRet = CfgUtilsSetPortRuleString(
                        g.InputBuffer,
                        &Pr
                        );
            if (fRet == FALSE)
            {
                wprintf(L"Invalid port rule: \"%ws\"\n", g.InputBuffer);
                goto end;
            }
            Count++;
            fGotPR = TRUE;
            g.InputBuffer[MY_MAX_PORT_RULE_LENGTH] = 0;
            StringCchCopy(szPR, MY_MAX_PORT_RULE_LENGTH, g.InputBuffer);
        }

        //
        // Look for , or open-brace
        //
        i = wscanf(L" %1[},]", g.InputBuffer); // -{-
        if (i == 1)
        {
            if (*g.InputBuffer == '}')  // -{-
            {
                fDone = TRUE;
            }
            else if (!fGotPR || *g.InputBuffer != ',')
            {
                wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
                goto end;
            }
        }
        else
        {
            goto end_bad_input;
        }
    }

    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    //
    // We've got zero or more port rules. Let's set em.
    //
    WBEMSTATUS Status;
    Status = pCfg->SetPortRules((LPCWSTR*)pszPortRules, Count);
    if (FAILED(Status))
    {
        wprintf(L"Error 0x%08lx copying port rules\n", (UINT) Status);
    }

    // display_port_rules(pCfg);

    goto end;

end_bad_input:

    if (wscanf(L"% 100ws", g.InputBuffer)!=1)
    {
        *g.InputBuffer = 0;
    }
    wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);

    // fall through...

end:

    delete pszPortRules;
    pszPortRules = NULL;

    return;
}


VOID parse_host_priority(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*
    HostPriority=10
*/
{
    UINT Pri = 0;
    
    INT i =  wscanf(
                L" = %lu",
                &Pri
                );
    if (i==1)
    {
        pCfg->SetHostPriority(Pri);
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }

    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // wprintf(L"DBG: HostPriority=%lu\n", pCfg->GetHostPriority());

end:

    return;
}


VOID parse_dedicated_network_address(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*++
    DedicatedNetworkAddress = 10.0.0.0/255.255.255.255
--*/
{

    WCHAR IpAddress[32];
    WCHAR SubnetMask[32];

    INT i =  wscanf(
                L" = %15[0-9.] / %15[0-9.]",
                IpAddress,
                SubnetMask
                );
    if (i==2)
    {
        StringCbPrintf(
            g.InputBuffer,
            sizeof(g.InputBuffer),
            L"%ws/%ws", IpAddress, SubnetMask);
        pCfg->SetDedicatedNetworkAddress(g.InputBuffer);
    }
    else if (i==1)
    {
        wprintf(L"Missing subnet mask.\n");    
        goto end;
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }
        
    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // DBG
    {
        LPWSTR szAddr = NULL;
        WBEMSTATUS Status;
        Status = pCfg->GetDedicatedNetworkAddress(&szAddr);
        if (FAILED(Status))
        {
            printf("Couldn't get address!\n");
        }
        else
        {
            // wprintf(L"DBG: DNA=%ws\n", szAddr);
            delete szAddr;
        }
    }

end:

    return;
}


VOID parse_cluster_mode_on_start(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
{
    
    INT i =  wscanf(
                L" = %15s",
                g.InputBuffer
                );
    if (i==1)
    {
        DWORD sm;
        if (!_wcsicmp(g.InputBuffer, L"true") || !_wcsicmp(g.InputBuffer, L"t"))
        {
            sm = CVY_HOST_STATE_STARTED;
        }
        else if (!_wcsicmp(g.InputBuffer, L"false") || !_wcsicmp(g.InputBuffer, L"f"))
        {
            sm = CVY_HOST_STATE_STOPPED;
        }
        else if (!_wcsicmp(g.InputBuffer, L"suspend") || !_wcsicmp(g.InputBuffer, L"s"))
        {
            sm = CVY_HOST_STATE_SUSPENDED;
        }
        else
        {
            wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
            goto end;
        }
        pCfg->SetClusterModeOnStart(sm);
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }

    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // wprintf(L"DBG: CMOS=%lu\n", (INT) pCfg->GetClusterModeOnStart());

end:

    return;
}

VOID parse_persist_suspend_on_reboot(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
{
    
    INT i =  wscanf(
                L" = %15s",
                g.InputBuffer
                );
    if (i==1)
    {
        BOOL ps;
        if (!_wcsicmp(g.InputBuffer, L"true") || !_wcsicmp(g.InputBuffer, L"t"))
        {
            ps = TRUE;
        }
        else if (!_wcsicmp(g.InputBuffer, L"false") || !_wcsicmp(g.InputBuffer, L"f"))
        {
            ps = FALSE;
        }
        else
        {
            wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
            goto end;
        }
        pCfg->SetPersistSuspendOnReboot(ps);
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }

    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    // wprintf(L"DBG: CMOS=%lu\n", (INT) pCfg->GetClusterModeOnStart());

end:

    return;
}

VOID parse_remote_control_enabled(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*
    RemoteControlEnabled = true | false
*/
{
    BOOL Enabled = FALSE;
    
    INT i =  wscanf(
                L" = %15s",
                g.InputBuffer
                );
    if (i==1)
    {
        if (!_wcsicmp(g.InputBuffer, L"true") || !_wcsicmp(g.InputBuffer, L"t"))
        {
            Enabled = TRUE;
        }
        else if (!_wcsicmp(g.InputBuffer, L"false") || !_wcsicmp(g.InputBuffer, L"f"))
        {
            Enabled = FALSE;
        }
        else
        {
            wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
            goto end;
        }
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }

    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

    pCfg->SetRemoteControlEnabled(Enabled);

    // wprintf(L"DBG: RemoteControlEnabled=%lu\n", pCfg->GetRemoteControlEnabled());

end:

    return;
}



VOID parse_remote_password(NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
/*
    Password=blah
*/
{
    INT i =  wscanf(
                L" = %ws",
                g.InputBuffer
                );
    if (i==1)
    {
        // TODO: This is unsuppoted.
        // pCfg->SetPassword(g.InputBuffer);
        wprintf(L"Unimplemented\n");
        goto end;
    }
    else
    {
        if (wscanf(L"% 100ws", g.InputBuffer)!=1)
        {
            *g.InputBuffer = 0;
        }
        wprintf(L"\"%ws\" unexpected.\n", g.InputBuffer);
        goto end;
    }
        
    if (!pCfg->IsNlbBound())
    {
        wprintf(L"Assuming NLB needs to be bound.\n");
        pCfg->SetNlbBound(TRUE);
    }

end:

    return;
}


KEYWORD parse_main_help(VOID)
{
    printf("Commands:\n");
    printf("    AdapterList|al    - displays a list of NLB-compatible adapters\n");
    printf("    Update|u  <guid>  - displays current configuration for the specified\n"
           "                        adapter and then accepts commands to update\n"
           "                        that configuration\n");
    printf("    Help|h|?          - displays this help message\n");
    printf("    Quit|q            - exits the NLB configuration shell\n");

    KEYWORD kw;

    if (g.fRunOnce)
    {
        kw = KW_QUIT;
    }
    else
    {
        kw = read_keyword(szMAIN_PROMPT);
    }

    return kw;
}

#if 0
parse_wmiupdate()
{
    COMMAND_TYPE Cmd;

    read_guid();

    // get config and display it 

    // read new config from stdin
    do
    {
                
        Cmd = read_keyword();

        switch(Cmd)
        {
        NETWORK_ADDRESSES:
        DOT:  // end of config change description
        ADAPTER_LIST:
        HELP:
            fQuit=TRUE;
            greak;
        }
        
    } while (!fQuit)

    return Cmd;
}
#endif // 0

BOOL valid_guid(LPCWSTR szGuid)
{
    UINT Len = wcslen(szGuid);
    if (
              Len!=NLB_GUID_LEN 
           || szGuid[0] != '{'
           || szGuid[Len-1]!='}'
       )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
/*
    Reads the password from stdin, WITHOUT echoing the password chars to 
    stdiout.

    JosephJ 6/3/01
        Taken verbatim from \nt\ds\ds\src\util\csvds.
        It was one of the dirs that showed up when I did an index search
        for "Type the password for", which is what the "net use" command
        prompts when asking for a password.

        Works like a charm.
*/
{
#define     CR              0xD
#define     BACKSPACE       0x8
#define     NULLC           '\0'
#define     NEWLINE         '\n'

    WCHAR   ch;
    PWSTR   pszBufCur = szBuffer;
    DWORD   c;
    int     err;
    DWORD   mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putchar(NEWLINE);

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}

VOID
test_port_rule_string(VOID)
{

    LPCWSTR RuleStrings[] =
                {
L"",
L"   \t \n ",
L"n=v",
L" \t \n   n=v",
L"  \t \n  n \t \n = \t \n v",
L"na=v1 nb=v2 nc=v3",
L"\t  na \t  =   \t v1   \t  nb \t \n =\t \n  v2  \t \n  nc \t  = \n  v3  ",
#if 1
L"ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE"
                                                L" priority=1",
L"ip=1.1.1.1 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=SINGLE load=80",
L"ip=1.1.1.1 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=NONE load=80",
L"ip=1.1.1.1 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=CLASSC",
L"ip=1.1.1.1 protocol=BOTH start=80 end=288 mode=DISABLED",
#endif // 0

NULL    // Must be last
                };


    for (LPCWSTR *ppRs = RuleStrings; *ppRs!=NULL; ppRs++)
    {
        LPCWSTR szRule = *ppRs;
        WCHAR szGenString[NLB_MAX_PORT_STRING_SIZE];
        printf("ORIG: %ws\n", szRule);
        WLBS_PORT_RULE Pr;
        BOOL fRet;
        fRet = CfgUtilsSetPortRuleString(
                    szRule,
                    &Pr
                    );
        if (fRet == FALSE)
        {
            printf("CfgUtilsSetPortRuleString returned FAILURE.\n");
            continue;
        }
        fRet = CfgUtilsGetPortRuleString(
                    &Pr,
                    szGenString
                    );
        if (fRet == FALSE)
        {
            printf("CfgUtilsGetPortRuleString returned FAILURE.\n");
            continue;
        }
        printf("GEN: %ws\n", szGenString);
    }
}

BOOL
get_guid_by_friendly_name(VOID)
{
    LPWSTR szGuid =  NULL;
    BOOL fRet = FALSE;

    szGuid =  L"{AD4DA14D-CAAE-42DD-97E3-5355E55247C2}";


    if (g.fUseWmi)
    {
        do_wminiclist(g.FriendlyName, &szGuid);
    }
    else
    {
        do_niclist(g.FriendlyName, &szGuid);
    }

    if (szGuid != NULL)
    {
        ARRAYSTRCPY(g.AdapterGuid, szGuid);
        // printf("FR=\"%ws\"; Guid=%ws\n", g.FriendlyName, g.AdapterGuid);
        delete szGuid; szGuid = NULL;
        fRet = TRUE;
    }
    
    return fRet;
}

void    test_vectors(void)
{
   
    vector<_bstr_t> v1;
    vector<_bstr_t> v2;
    vector<_bstr_t> *pv3 = new vector<_bstr_t>;

    WCHAR szBlah[10];
    ARRAYSTRCPY(szBlah, L"blah");

    v1.push_back(szBlah);
    v1.push_back(szBlah);

    *pv3 = v1;
    v2 = *pv3;
    delete pv3;

    for (int i = 0; i< v1.size(); i++)
    {
        LPCWSTR sz1 = v1[i];
        LPCWSTR sz2 = v2[i];
        printf("v1[%d] = 0x%p(%ws); v2[i] = 0x%p(%ws)\n", i, sz1, sz1, sz2, sz2);
        v2[i] = L"";
        sz2 = v2[i];
        printf("v1[%d] = 0x%p(%ws); v2[i] = 0x%p(%ws)\n", i, sz1, sz1, sz2, sz2);
    }

}

typedef ULONG ENGINEHANDLE;

class CInterfaceSpec
{
public:

    _bstr_t bstrGuid;
};

void    test_maps(void)
{
    ENGINEHANDLE ehA = 1;
    ENGINEHANDLE ehB = 3;
    CInterfaceSpec iSpecA;
    CInterfaceSpec iSpecB;

    iSpecA.bstrGuid = _bstr_t(L"ISpecA");
    iSpecB.bstrGuid = _bstr_t(L"ISpecB");

    map< ENGINEHANDLE, CInterfaceSpec* > mymap;

    mymap[ehA]  = &iSpecA;
    mymap[ehB]  = &iSpecB;
    printf("eh=%lu, &iSpec=0x%p, mymap[eh]=%p\n", ehA, &iSpecA, mymap[ehA]);
    printf("eh=%lu, &iSpec=0x%p, mymap[eh]=%p\n", ehB, &iSpecB, mymap[ehB]);

    map< ENGINEHANDLE, CInterfaceSpec* >::iterator iter;

    for( iter = mymap.begin();
         iter != mymap.end();
         ++iter)
    {
        CInterfaceSpec *pISpec = (*iter).second;
        ENGINEHANDLE eh =  (*iter).first;
        printf("ITER: (eh=%lu, pISpec=%p, guid=%ws)\n", eh, pISpec,
                LPCWSTR(pISpec->bstrGuid));
    }

}

void    test_validate_network_address(void)
{
    WCHAR rgAddress[256];
    UINT uIpAddress=0;
    UINT uSubnet=0;
    UINT uDefaultSubnet=0;
    WBEMSTATUS wStat;


    printf("Enter network address; 'q' to quit\n:");
    while (wscanf(L" %64ws", rgAddress)==1)
    {
        if (!_wcsicmp(rgAddress, L"q"))
        {
            break;
        }

        wStat = CfgUtilsValidateNetworkAddress(
                    rgAddress,
                    &uIpAddress,
                    &uSubnet,
                    &uDefaultSubnet
                    );

        if (wStat != WBEM_NO_ERROR)
        {
            printf("CfgUtilsValidateNetworkAddress returns error 0x%08lx\n",
                    wStat);
        }
        else
        {
            LPBYTE szI= (LPBYTE)&uIpAddress;
            LPBYTE szS= (LPBYTE)&uSubnet;
            LPBYTE szD= (LPBYTE)&uDefaultSubnet;

            printf(
             "\"%ws\" ->"
             "(%lu.%lu.%lu.%lu, %lu.%lu.%lu.%lu, %lu.%lu.%lu.%lu)\n",
              rgAddress,
              szI[0], szI[1], szI[2], szI[3],
              szS[0], szS[1], szS[2], szS[3],
              szD[0], szD[1], szD[2], szD[3]
              );

        }

        printf(":");
    }
}

VOID MapStatusToDescription(DWORD Status, _bstr_t &szDescr)
{
    struct STATUS_DESCR_MAP
    {
        DWORD    Status;
        LPCSTR   Description;
    } 

    StatusDescrMap[] =
    {  
        {WLBS_ALREADY,            "WLBS_ALREADY"},
        {WLBS_BAD_PARAMS,         "WLBS_BAD_PARAMS"},
        {WLBS_NOT_FOUND,          "WLBS_NOT_FOUND"},
        {WLBS_STOPPED,            "WLBS_STOPPED"},
        {WLBS_SUSPENDED,          "WLBS_SUSPENDED"},
        {WLBS_CONVERGING,         "WLBS_CONVERGING"},
        {WLBS_CONVERGED,          "WLBS_CONVERGED (Non-Default)"},
        {WLBS_DEFAULT,            "WLBS_DEFAULT (Converged as Default)"},
        {WLBS_BAD_PASSW,          "WLBS_BAD_PASSW"},
        {WLBS_DRAINING,           "WLBS_DRAINING"},
        {WLBS_DRAIN_STOP,         "WLBS_DRAIN_STOP"},
        {WLBS_DISCONNECTED,       "WLBS_DISCONNECTED"},
        {WLBS_FAILURE,            "WLBS_FAILURE"},
        {WLBS_REFUSED,            "WLBS_REFUSED"},
        {WLBS_OK,                 "WLBS_OK"},    
        {WLBS_IO_ERROR,           "WLBS_IO_ERROR"},
        {NLB_PORT_RULE_NOT_FOUND, "PORT_RULE_NOT_FOUND"},
        {NLB_PORT_RULE_ENABLED,   "PORT_RULE_ENABLED"},
        {NLB_PORT_RULE_DISABLED,  "PORT_RULE_DISABLED"},  
        {NLB_PORT_RULE_DRAINING,  "PORT_RULE_DRAINING"}
    };

    for (int i=0; i<sizeof(StatusDescrMap) /sizeof(StatusDescrMap[0]); i++)
    {
        if (StatusDescrMap[i].Status == Status)
        {
            szDescr = StatusDescrMap[i].Description;
            return; 
        }
    }

    //
    // Default
    //
    {
        char temp[256];
        StringCbPrintfA(temp, sizeof(temp), "Unknown (%lu)",Status);
        szDescr = temp;
    }
    return ;
}

void
parse_control(
        BOOL fWmi,
        PWMI_CONNECTION_INFO pConnInfo,
        LPCWSTR szNicGuid
        ) 
//
// control [ip=x] port=y enable/disable/drain/query/nop
// control start/stop/query/nop
//
{
    KEYWORD kw;
    BOOL fGotPort = FALSE;
    BOOL fGotIp = FALSE;
    BOOL fGotCmd = FALSE;
    KEYWORD kwCmd = KW_UNKNOWN;
    WCHAR rgIp[32];
    LPCWSTR szIp = NULL;
    DWORD dwPort = 0;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    DWORD dwOperationStatus = 0;
    DWORD dwClusterOrPortStatus = 0;
    DWORD dwHostMap = 0;
    DWORD *pdwPort = NULL;

    *rgIp=0;

    while (!fGotCmd)
    {
        kw = read_keyword(L"");
    
        switch(kw)
        {
        case KW_START:
        case KW_STOP:
        case KW_DRAIN:
        case KW_DRAIN_STOP:
        case KW_SUSPEND:
        case KW_RESUME:
        case KW_ENABLE:
        case KW_DISABLE:
        case KW_QUERY:
             fGotCmd = TRUE;
             kwCmd = kw;
             break;
    
        case KW_VIP:
            // Look for "=<ip address>", eg. "= 10.0.0.1"
            if (fGotIp)
            {
                wprintf(L"control: duplicate IP specification\n");
                goto end; // parse error
            }
            
            if (wscanf(L" = %15[0-9.]", rgIp) != 1)
            {
                wprintf(L"control: bad ip specification\n");
                goto end;
            }
            szIp = rgIp;
            fGotIp = TRUE;
            // printf("GOT IP \"%ws\"\n", rgIp);
            break;
    
        case KW_PORT:
            // Look for "=<port>", eg. " = 80"
            if (fGotPort)
            {
                wprintf(L"control: duplicate port specification\n");
                goto end; // parse error
            }
            if (wscanf(L" = %lu", &dwPort) != 1)
            {
                wprintf(L"control: bad port specification\n");
                goto end;
            }
            pdwPort = &dwPort;
            fGotPort = TRUE;
            // printf("GOT PORT %lu\n", dwPort);
            break;

        default: // parse error
            printf("control: unknown argument\n");
            goto end;
        }
    }
    
    
    //
    // Param checking
    //
    switch(kwCmd)
    {
    case KW_START: // following are adapter-wide
    case KW_STOP:
    case KW_DRAIN_STOP:
    case KW_SUSPEND:
    case KW_RESUME:
        if (fGotIp || fGotPort)
        {
            wprintf(L"control: unexpected port or ip\n");
            goto end; // parse error;
        }
        break;

    case KW_ENABLE: // following are port-specific
    case KW_DISABLE:
    case KW_DRAIN:
        if (!fGotPort)
        {
            wprintf(L"control: missing port\n");
            goto end; // parse error;
        }
        if (!fGotIp)
        {
            wprintf(L"Assuming \"All Vip\", ie. Vip=255.255.255.255\n");
            szIp = L"255.255.255.255"; // Default - "All Vip"
        }
        break;


    case KW_QUERY:
        {
            if (fGotIp && ! fGotPort)
            {
                wprintf(L"control: missing port\n");
                goto end; // parse error;
            }

            if (!fGotIp &&  fGotPort)
            {
                wprintf(L"Assuming \"All Vip\", ie. Vip=255.255.255.255\n");
                szIp = L"255.255.255.255"; // default -- all vip
            }
        }
        break;

    default:
        // we don't expect to get here.
        goto end;
    }

    //
    // Actually execute
    //
    {
        WLBS_OPERATION_CODES Op = WLBS_START;

        switch(kwCmd)
        {
        case KW_START:
            // wprintf(L"DO START\n");
            Op = WLBS_START;
            break;

        case KW_STOP:
            Op = WLBS_STOP;
            // wprintf(L"DO STOP\n");
            break;

        case KW_DRAIN_STOP:
            Op = WLBS_DRAIN;
            // wprintf(L"DO DRAIN STOP\n");
            break;

        case KW_SUSPEND:
            Op = WLBS_SUSPEND;
            // wprintf(L"DO SUSPEND\n");
            break;

        case KW_RESUME:
            // wprintf(L"DO RESUME\n");
            Op = WLBS_RESUME;
            break;

        case KW_ENABLE:
            // wprintf(L"DO ENABLE\n");
            Op = WLBS_PORT_ENABLE;
            break;

        case KW_DISABLE:
            // wprintf(L"DO DISABLE\n");
            Op = WLBS_PORT_DISABLE;
            break;

        case KW_DRAIN:
            Op = WLBS_PORT_DRAIN;
            // wprintf(L"DO DRAIN\n");
            break;

        case KW_QUERY:
            if (fGotPort)
            {
                Op = WLBS_QUERY_PORT_STATE;
            }
            else
            {
                Op = WLBS_QUERY;
            }
            // wprintf(L"DO QUERY\n");
            break;

        default:
            goto end; // don't expect to get here.
        } // end switch

#define NEWSTUFF 1
#if NEWSTUFF

        if (fWmi)
        {
            Status = NlbHostControlCluster(
                        pConnInfo, 
                        szNicGuid,
                        szIp,
                        pdwPort,
                        Op,
                        &dwOperationStatus,
                        &dwClusterOrPortStatus,
                        &dwHostMap
                        );
        }
        else // 
        {
            UINT uIp = 0;

            if (!_wcsicmp(szIp, L"255.255.255.255")) // lazy eval
            {
                uIp = 0xffffffff; // all-vip
            }
            else
            {
                Status = CfgUtilsValidateNetworkAddress(szIp, &uIp, NULL, NULL);
                if (FAILED(Status))
                {
                    printf("control: invalid Ip address\n");
                    goto end;
                }
            }

            switch(Op)
            {
                case WLBS_START:
                case WLBS_STOP:      
                case WLBS_DRAIN:      
                case WLBS_SUSPEND:     
                case WLBS_RESUME:       
                    CfgUtilControlCluster( szNicGuid, Op, 0, 0, NULL, &dwOperationStatus );
                    CfgUtilControlCluster( szNicGuid, WLBS_QUERY, 0, 0, &dwHostMap, &dwClusterOrPortStatus );
                    break;

                case WLBS_PORT_ENABLE:  
                case WLBS_PORT_DISABLE:  
                case WLBS_PORT_DRAIN:     
                    CfgUtilControlCluster( szNicGuid, Op, uIp, dwPort, NULL, &dwOperationStatus );
                    CfgUtilControlCluster( szNicGuid, WLBS_QUERY_PORT_STATE, uIp, dwPort, NULL, &dwClusterOrPortStatus );
                    break;

                case WLBS_QUERY:           
                    CfgUtilControlCluster( szNicGuid, WLBS_QUERY, 0, 0, &dwHostMap, &dwClusterOrPortStatus );
                    dwOperationStatus = WLBS_OK;
                    break;

                case WLBS_QUERY_PORT_STATE:
                default:
                    CfgUtilControlCluster( szNicGuid, WLBS_QUERY_PORT_STATE, uIp, dwPort, NULL, &dwClusterOrPortStatus );
                    dwOperationStatus = WLBS_OK;
                    break;
            }

        }

#endif //  NEWSTUFF

        if (FAILED(Status))
        {
            printf("ControlCluster returns failure 0x%08lx\n", Status);
        }
        else
        {

            _bstr_t szOperationStatusDescr, szClusterOrPortStatusStr;

            MapStatusToDescription(dwOperationStatus, szOperationStatusDescr);
            MapStatusToDescription(dwClusterOrPortStatus, szClusterOrPortStatusStr);

            printf("ControlCluster returns Operation Status   = %s\n",(LPCSTR)szOperationStatusDescr);
            printf("                       Cluster/Port State = %s\n",(LPCSTR)szClusterOrPortStatusStr);
            printf("                       Host Map           = 0x%08lx\n",dwHostMap);
        }


    }

end:
    return;
}


void
parse_query(
        BOOL fWmi,
        PWMI_CONNECTION_INFO pConnInfo,
        LPCWSTR szNicGuid
        ) 
//
// query -- list the members in the cluster
//
{
    DWORD                   dwNumMembers = 0;
    NLB_CLUSTER_MEMBER_INFO *pMembers = NULL;
    WBEMSTATUS              Status = WBEM_NO_ERROR;

    if (fWmi)
    {
        Status = NlbHostGetClusterMembers(
                    pConnInfo, 
                    szNicGuid,
                    &dwNumMembers,
                    &pMembers
                    );
    }
    else // !fWmi
    {
        Status = CfgUtilGetClusterMembers(
                    szNicGuid,
                    &dwNumMembers,
                    &pMembers
                    );
    }

    if (FAILED(Status))
    {
        printf("QueryCluster returns failure 0x%08lx\n", Status);
    }
    else
    {
        wprintf(L"HostID      DedicatedIP      HostName\n");
        wprintf(L"-----------------------------------------------------\n");

        DWORD dwHost = 0;
        for (; dwHost < dwNumMembers; dwHost++)
        {
            wprintf(L"%-11d %-16ls %ls\n",
                    pMembers[dwHost].HostId,
                    (pMembers[dwHost].DedicatedIpAddress == NULL) ? L"" : pMembers[dwHost].DedicatedIpAddress,
                    (pMembers[dwHost].HostName == NULL) ? L"" : pMembers[dwHost].HostName
                    );
        }

        if (pMembers != NULL)
        {
            delete [] pMembers;
            pMembers = NULL;
        }
    }
}


void display_nlbipaddresslist(
        const NlbIpAddressList &IpList
        )
{
    BOOL fRet;
    NlbIpAddressList IpListCopy;
    NLB_IP_ADDRESS_INFO *pInfo=NULL;
    UINT uNum=0;

    fRet = IpListCopy.Copy(IpList);

    if (!fRet) goto end;

    IpListCopy.Extract(REF uNum, REF pInfo);

    display_ip_info2(uNum, pInfo);

end:

    delete pInfo;


    
}

void test_nlbipaddresslist(void)
{
    BOOL fRet;
    NlbIpAddressList IpList;

    typedef struct
    {
        LPCWSTR szOld;
        LPCWSTR szNew;
        LPCWSTR szMask;

    } MY_MODIFY_INFO;

    #define MY_TERMINAL ((LPCWSTR) 0x1)

    MY_MODIFY_INFO rgModInfo[] = 
    {
        {NULL},
        {NULL,L"1",L"11"},
        {NULL,L"2",L"22"},
        {NULL,L"3",L"33"},
        {L"3",L"2", L"23"},
        {L"2",L"1", L"13"},
        {L"1",L"4", L"44"},
        {L"1",L"4", L"44"},
        {L"1",L"1", L"111"},
        {L"3"},
        {L"2"},
        {L"1"},

        {MY_TERMINAL} // must be last.
    };

#if 0
    for (MY_MODIFY_INFO *pModInfo = rgModInfo;
         pModInfo->szOld != MY_TERMINAL;
         pModInfo++
         )
    {

        wprintf(
            L"TRIAL: Old=\"%ws\"  New=\"%ws\"  Mask=\"%ws\"\n",
            (pModInfo->szOld==NULL) ? L"<null>" : pModInfo->szOld,
            (pModInfo->szNew==NULL) ? L"<null>" : pModInfo->szNew,
            (pModInfo->szMask==NULL) ? L"<null>" : pModInfo->szMask
            );

        fRet = IpList.Modify(
                    pModInfo->szOld,
                    pModInfo->szNew,
                    pModInfo->szMask
                    );

        display_nlbipaddresslist(IpList);
    }
#endif // 0

    NLB_IP_ADDRESS_INFO rgOrigInfo[] = {
        {L"1", L"11"},
        {L"2", L"22"},
        {L"3", L"33"}
    };

    NLB_IP_ADDRESS_INFO rgNewInfo[] = {
        {L"5", L"155"},
        {L"4", L"144"},
        {L"3", L"133"},
        {L"2", L"122"},
    };

    #define ASIZE(_array) (sizeof(_array)/sizeof(_array[0]))

    fRet = IpList.Set(ASIZE(rgOrigInfo), rgOrigInfo, 0);
    // fRet = IpList.Set(0, NULL, 0);
    if (!fRet)
    {
        goto end;
    }
    printf("Original List (before Apply):\n");
    display_nlbipaddresslist(IpList);

    fRet = IpList.Apply(ASIZE(rgNewInfo), rgNewInfo);
    // fRet = IpList.Apply(0, NULL);
    if (!fRet)
    {
        goto end;
    }

    printf("\nNew List (after Apply):\n");
    display_nlbipaddresslist(IpList);

end:

    if (fRet)
    {
        printf("display_nlbipaddresslist Test PASSED\n");
    }
    else
    {
        printf("display_nlbipaddresslist Test FAILED\n");
    }
   
}

void test_ioctl_alignment(void)
{
//
// Just to check out the offsets of the following structures and sub-structures
// in the debugger to make sure that the packet versions are 8-byte aligned
//
//
    IOCTL_CVY_BUF               icb;
    IOCTL_COMMON_OPTIONS        ico;
    IOCTL_REMOTE_OPTIONS        iro;
    IOCTL_REMOTE_HDR            irh;
    IOCTL_LOCAL_OPTIONS         ilo;
    IOCTL_LOCAL_HDR             ilh;
    NLB_OPTIONS_PORT_RULE_STATE prs;
    NLB_OPTIONS_PACKET_FILTER   pf;
}

void    test_local_logger(void)
{
    CLocalLogger logger;
    LPCWSTR szLog = NULL;

    //
    // Warning: should match IDS_PROCESSING_UPDATE from ..\nlbmprov.h
    //
    #define    IDS_PROCESING_UPDATE               200  

    for (UINT u = 1; u<50; u++)
    {
        logger.Log(IDS_PROCESING_UPDATE, u, L"test_local_logger");
    }

    szLog = logger.GetStringSafe();
    wprintf(szLog);
}

void test_encrypt_memory(void)
{
    BOOL fRet;
    //
    // JosephJ 4/10/02 Verified the following passwords as well...
    // LPCWSTR szPwd = L"asdfasdfasdfasdfasdf asdf asdf asdfasdfasdf af a";
    // LPCWSTR szPwd = L"1";
    LPCWSTR szPwd = L"";
    //
    // LPCWSTR szPwd = L"password";
    WCHAR rgEncPwd[64];
    // WCHAR rgEncPwd[256]; (use with longest pwd above)
    WCHAR rgDecPwd[32];
    // WCHAR rgDecPwd[128]; (use with longest pwd above)

    fRet = CfgUtilEncryptPassword(szPwd, ASIZE(rgEncPwd), rgEncPwd);

    if (!fRet)
    {
        printf("CfgUtilEncryptPassword failed.\n");
        goto end;
    }
    else
    {
        wprintf(L"Encrypted pwd = \"%ws\"\n", rgEncPwd);
    }

    fRet = CfgUtilDecryptPassword(rgEncPwd, ASIZE(rgDecPwd), rgDecPwd);

    if (!fRet)
    {
        printf("CfgUtilDecryptPassword failed.\n");
        goto end;
    }
    else
    {
        wprintf(L"Decrypted pwd = \"%ws\"\n", rgDecPwd);
    }

end:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\nlbhost.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbhost.h

Abstract:

    Header file for class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created

--*/

typedef struct
{
 	LPCWSTR              szMachine;   // Must be non-NULL
 	LPCWSTR              szUserName;  // NULL == use current
 	LPCWSTR              szPassword;  // NULL == use current
    
} WMI_CONNECTION_INFO, *PWMI_CONNECTION_INFO;


typedef
VOID
(*PFN_LOGGER)(
    PVOID           Context,
    const   WCHAR * Text
    );


WBEMSTATUS
NlbHostGetConfiguration(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    );


WBEMSTATUS
NlbHostGetCompatibleNics(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT LPWSTR **ppszNics,  // free using delete
    OUT UINT   *pNumNics,  // free using delete
    OUT UINT   *pNumBoundToNlb // Optional
    );


WBEMSTATUS
NlbHostDoUpdate(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
);


WBEMSTATUS
NlbHostGetUpdateStatus(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    );

WBEMSTATUS
NlbHostPing(
    LPCWSTR szBindString,
    UINT    Timeout // In milliseconds.
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\resource.h ===
// Used by tprov.rc
//
#define IDS_HELLO                       1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\util\precomp.h ===
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <winuser.h>
#include <tchar.h>
#include <winsock2.h>

#include "wlbsparm.h"
#include <strsafe.h>
#include "wlbsutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\util\debugimpl.cpp ===
//+----------------------------------------------------------------------------
//
// File: debugimpl.cpp       
//
// Module:  Network Load Balancing
//
// Synopsis: Provide the functionality of ASSERT
//  The build enviorment does not allow to have a source file from another directory
//  Include this cpp file directly.
//  Another approach is to have a shared lib.
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   fengsun Created    8/3/98
//
//+----------------------------------------------------------------------------
#include "precomp.h"

#include "debug.h"

#include <strsafe.h>

#if ( defined(DEBUG) || defined(_DEBUG) || defined (DBG))

#ifndef MB_SERVICE_NOTIFICATION
#define MB_SERVICE_NOTIFICATION 0
#endif

static long dwAssertCount = 0;  // Avoid another assert while the messagebox is up


//+----------------------------------------------------------------------------
//
// Function:  AssertMessage
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageW(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg) 
{
    TCHAR szOutput[1024];

    //
    // Ignore return value of StringCchPrintf since it will truncate the buffer and
    // guarantees to null-terminate it for us.
    //
    (VOID) StringCchPrintf(szOutput, ASIZECCH(szOutput), TEXT("%s(%u) - %s\n"), pszFile, nLine, pszMsg);
    OutputDebugString(szOutput);

    (VOID) StringCchPrintf(szOutput, ASIZECCH(szOutput), TEXT("%s(%u) - %s\n( Press Retry to debug )"), pszFile, nLine, pszMsg);
    int nCode = IDIGNORE;

    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
        dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        WCHAR szFileName[MAX_PATH + 1];
        szFileName[0] = L'\0';   // in case of failure

        if (GetModuleFileNameW(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH ) == 0)
        {
            szFileName[0] = L'\0';
        }

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlen(szFileName);i != 0 && szFileName[i-1] != L'\\'; i--)
           ;

        WCHAR szTitle[48];
        if (StringCchCopy(szTitle, ASIZECCH(szTitle), L"Assertion Failed - ") == S_OK)
        {
            (VOID) StringCchCat(szTitle, ASIZECCH(szTitle), szFileName+i);
        }

        nCode = MessageBoxEx(NULL,szOutput,szTitle,
            MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);

        dwAssertCount--;
    }


    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
        //
        // break into the debugger .
        // Step out of this fuction to get to your ASSERT() code
        //
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\util\utils.cpp ===
#include "precomp.h"

#include <strsafe.h>
#include <locale.h>
#include "wlbsutil.h"
#include "wlbsconfig.h"
#include "debug.h"

#define MAXIPSTRLEN              20

//+----------------------------------------------------------------------------
//
// Function:  IpAddressFromAbcdWsz
//
// Synopsis:Converts caller's a.b.c.d IP address string to a network byte order IP 
//          address. 0 if formatted incorrectly.    
//
// Arguments: IN const WCHAR*  wszIpAddress - ip address in a.b.c.d unicode string
//
// Returns:   DWORD - IPAddr, return INADDR_NONE on failure
//
// History:   fengsun Created Header    12/8/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress)
{   
    CHAR    szIpAddress[MAXIPSTRLEN + 1];
    DWORD  nboIpAddr;    

    ASSERT(lstrlen(wszIpAddress) < MAXIPSTRLEN);

    WideCharToMultiByte(CP_ACP, 0, wszIpAddress, -1, 
            szIpAddress, sizeof(szIpAddress), NULL, NULL);

    nboIpAddr = inet_addr(szIpAddress);

    return(nboIpAddr);
}

//+----------------------------------------------------------------------------
//
// Function:  IpAddressToAbcdWsz
//
// Synopsis:  
//    Converts IpAddr to a string in the a.b.c.d form and returns same in 
//    caller's wszIpAddress buffer.
//
//    The caller MUST provider a buffer that is at least MAXIPSTRLEN + 1 WCHAR long.
//
// Arguments: IPAddr IpAddress - 
//            OUT WCHAR* wszIpAddress -  buffer at least MAXIPSTRLEN
//            IN const DWORD dwBufSize - size of wszIpAddress buffer in WCHARs
//
// Returns:   void 
//
// History:   fengsun Created Header    12/21/98
//            chrisdar 07-Mar-2002 - Added argument for the size of the output buffer
//
//+----------------------------------------------------------------------------
VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress,
    IN  const DWORD dwBufSize)
{
    ASSERT(wszIpAddress);

    if (dwBufSize == 0)
    {
        return;
    }
    wszIpAddress[0] = L'\0';

    LPSTR AnsiAddressString = inet_ntoa( *(struct in_addr *)&IpAddress );

    ASSERT(AnsiAddressString);

    if (AnsiAddressString == NULL)
    {
        return ; 
    }

    int iLen = MultiByteToWideChar(CP_ACP, 0, AnsiAddressString,  -1 , 
                    wszIpAddress,  dwBufSize);
    //
    // There are three states that MultiByteToWideChar can return:
    //   1) iLen == 0                       This means the call failed
    //   2) iLen > 0 when dwBufSize > 0     This means the call succeeded
    //   3) iLen > 0 when dwBufSize == 0    This means the call succeeded, but only to inform the caller of 
    //                                      the required size of the out buffer in wide chars. The buffer is not modified.
    // This last case is prevented from occuring above by an early return if dwBufSize == 0.

    //
    // Note also that an 'int' return type is used above because that is what
    // MultiByteToWideChar returns. However, the returned value is always non-negative.
    //
    ASSERT(iLen >= 0);

    DWORD dwLen = (DWORD) iLen;
    if (dwLen == 0)
    {
        //
        // In case MultiByteToWideChar modified the buffer then failed
        //
        wszIpAddress[0] = L'\0';
        return;
    }

    ASSERT(dwLen < dwBufSize);
}

/*
 * Function: GetIPAddressOctets
 * Description: Turn an IP Address string into its 4 integer components.
 * Author: shouse 7.24.00
 */
VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]) {
    DWORD dwIpAddr = IpAddressFromAbcdWsz(pszIpAddress);
    const BYTE * bp = (const BYTE *)&dwIpAddr;

    ardw[0] = (DWORD)bp[0];
    ardw[1] = (DWORD)bp[1];
    ardw[2] = (DWORD)bp[2];
    ardw[3] = (DWORD)bp[3];
}

/*
 * Function: IsValidIPAddressSubnetMaskPair
 * Description: Checks for valid IP address/netmask pairs.
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcperror.cpp
 */
BOOL IsValidMulticastIPAddress (PCWSTR szIp) {
    BOOL fNoError = TRUE;
    DWORD ardwIp[4];

    GetIPAddressOctets(szIp, ardwIp);

    if ((ardwIp[0] & 0xF0) != 0xE0)
        fNoError = FALSE;

    if (((ardwIp[0] & 0xFF) == 0xE0) &&
        ((ardwIp[1] & 0xFF) == 0x00) &&
        ((ardwIp[2] & 0xFF) == 0x00) &&
        ((ardwIp[3] & 0xFF) == 0x00))
        fNoError = FALSE;

    if (((ardwIp[0] & 0xFF) == 0xE0) &&
        ((ardwIp[1] & 0xFF) == 0x00) &&
        ((ardwIp[2] & 0xFF) == 0x00) &&
        ((ardwIp[3] & 0xFF) == 0x01))
        fNoError = FALSE;

    return fNoError;
}

/*
 * Function: IsValidIPAddressSubnetMaskPair
 * Description: Checks for valid IP address/netmask pairs.
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcperror.cpp
 */
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet) {
    BOOL fNoError = TRUE;

    DWORD dwAddr = IpAddressFromAbcdWsz(szIp);
    DWORD dwMask = IpAddressFromAbcdWsz(szSubnet);

    if (( (dwMask   | dwAddr) == 0xFFFFFFFF) // Is the host ID all 1's ?
     || (((~dwMask) & dwAddr) == 0)          // Is the host ID all 0's ?
     || ( (dwMask   & dwAddr) == 0))         // Is the network ID all 0's ?
    {
        fNoError = FALSE;
        return FALSE;
    }

    DWORD ardwNetID[4];
    DWORD ardwHostID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];

    GetIPAddressOctets(szIp, ardwIp);
    GetIPAddressOctets(szSubnet, ardwMask);

    INT nFirstByte = ardwIp[0] & 0xFF;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 0.0.0.0
        ((ardwHostID[0] == 0) &&
         (ardwHostID[1] == 0) &&
         (ardwHostID[2] == 0) &&
         (ardwHostID[3] == 0)) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
    {
        fNoError = FALSE;
    }

    return fNoError;
}

/*
 * Function: IsContiguousSubnetMask
 * Description: Makes sure the netmask is contiguous
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcputil.cpp
 */
BOOL IsContiguousSubnetMask (PCWSTR pszSubnet) {
    DWORD ardwSubnet[4];

    GetIPAddressOctets(pszSubnet, ardwSubnet);

    DWORD dwMask = (ardwSubnet[0] << 24) + (ardwSubnet[1] << 16)
        + (ardwSubnet[2] << 8) + ardwSubnet[3];
    
    
    DWORD i, dwContiguousMask;
    
    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;

    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwContiguousMask |= 1 << i;
        
        if (dwContiguousMask & dwMask)
            break;
    }
    
    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  ParamsGenerateSubnetMask
//
// Description:  
//
// Arguments: PWSTR ip                  - Input dotted decimal IP address string
//            PWSTR sub                 - Output dotted decimal subnet mask for input IP address
//            const DWORD dwMaskBufSize - Size of sub output buffer in characters
//
// Returns:   BOOL                      - TRUE if a subnet mask was generated. FALSE otherwise
//
// History: fengsun  Created Header    3/2/00
//          chrisdar 07 Mar 2002 - Added buffer size argument and tightened error checking
//
//+----------------------------------------------------------------------------
BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub, IN const DWORD dwMaskBufSize) {
    DWORD               b [4];

    ASSERT(sub != NULL);

    if (dwMaskBufSize < WLBS_MAX_DED_NET_MASK + 1)
    {
        return FALSE;
    }

    int iScan = swscanf (ip, L"%d.%d.%d.%d", b, b+1, b+2, b+3);

    //
    // If we didn't read the first octect of the IP address then we can't generate a subnet mask
    //
    if (iScan != EOF && iScan > 0)
    {
        if ((b [0] >= 1) && (b [0] <= 126)) {
            b [0] = 255;
            b [1] = 0;
            b [2] = 0;
            b [3] = 0;
        } else if ((b [0] >= 128) && (b [0] <= 191)) {
            b [0] = 255;
            b [1] = 255;
            b [2] = 0;
            b [3] = 0;
        } else if ((b [0] >= 192) && (b [0] <= 223)) {
            b [0] = 255;
            b [1] = 255;
            b [2] = 255;
            b [3] = 0;
        } else {
            b [0] = 0;
            b [1] = 0;
            b [2] = 0;
            b [3] = 0;
        }
    }
    else
    {
        b [0] = 0;
        b [1] = 0;
        b [2] = 0;
        b [3] = 0;
    }

    StringCchPrintf(sub, dwMaskBufSize, L"%d.%d.%d.%d",
              b [0], b [1], b [2], b [3]);

    return((b[0] + b[1] + b[2] + b[3]) > 0);
}

/*
 * Function: ParamsGenerateMAC
 * Description: Calculate the generated field in the structure
 * History: fengsun Created 3.27.00
 *          shouse Modified 7.12.00 
 */
//
//  TODO: This function needs to be rewritten
//      1. One of the first executable lines is 'if (!fConvertMAC) { return; }. No need to call this function in this case.
//      2. Two buffers are OUT, but all are not touched for every call. This makes the code very fragile. If it is an out
//         and the pointer is non-NULL the user should expect this function to at least set the result to "no result", e.g.,
//         empty string. But looks like calling code has made assumptions about when these OUTs are modified. The caller has
//         too much knowledge of the implementation.
//      3. Calls are made to IpAddressFromAbcdWsz but no check is made to determine if the result is INADDR_NONE.
//      4. I suspect that this code would be much clearer if there were one input string, one output string, a buf size for
//         the output string and a enum telling the function how to create the MAC (unicast, multicast or IGMP)
//
//  When rewritten, many of the checks within the 'if' branches can then be moved to the top of the function. This will clean
//  the code considerably.
//
void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               IN  const DWORD dwMACBufSize,
                               OUT WCHAR * szMulticastIP,
                               IN  const DWORD dwIPBufSize,
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP) {
    DWORD dwIp;    
    const BYTE * bp;

    //
    // Isn't this dumb? Why call this function at all if caller passes this flag in as false???
    //
    if (!fConvertMAC) return;

    /* Unicast mode. */
    if (!fMulticast) {
        ASSERT(szClusterIP != NULL);
        ASSERT(szClusterMAC != NULL);
        ASSERT(dwMACBufSize > WLBS_MAX_NETWORK_ADDR);

        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        StringCchPrintf(szClusterMAC, dwMACBufSize, L"02-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }

    /* Multicast without IGMP. */
    if (!fIGMP) {
        ASSERT(szClusterIP != NULL);
        ASSERT(szClusterMAC != NULL);
        ASSERT(dwMACBufSize > WLBS_MAX_NETWORK_ADDR);

        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        StringCchPrintf(szClusterMAC, dwMACBufSize, L"03-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }
    
    /* Multicast with IGMP. */
    if (fUseClusterIP) {
        ASSERT(szClusterIP != NULL);
        ASSERT(szMulticastIP != NULL);
        ASSERT(dwIPBufSize > WLBS_MAX_CL_IP_ADDR);

        /* 239.255.x.x */
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        dwIp = 239 + (255 << 8) + (dwIp & 0xFFFF0000);
        AbcdWszFromIpAddress(dwIp, szMulticastIP, dwIPBufSize);
    }

    //
    // The OUT buffer szMulticastIP is used here as an input. The buffer will be uninitialized if
    // fUseClusterIP == FALSE && fIGMP == TRUE && fMulticast == TRUE. That doesn't sound intentional...
    // Looks like we shouldn't get here unless fUseClusterIP == TRUE. Perhaps caller is taking care of this
    // for us, but this is fragile.
    //
    ASSERT(szClusterMAC != NULL);
    ASSERT(szMulticastIP != NULL);
    ASSERT(dwMACBufSize > WLBS_MAX_NETWORK_ADDR);
    dwIp = IpAddressFromAbcdWsz(szMulticastIP);
    bp = (const BYTE*)&dwIp;
        
    StringCchPrintf(szClusterMAC, dwMACBufSize, L"01-00-5e-%02x-%02x-%02x", (bp[1] & 0x7f), bp[2], bp[3]);
}

VOID
InitUserLocale()
{
    HMODULE h = GetModuleHandle(L"kernel32.dll");

    if(h != NULL)
    {
        typedef LANGID (WINAPI * PSET_THREAD_UI_LANGUAGE)(WORD);
        PSET_THREAD_UI_LANGUAGE pfSetThreadUILanguage = (PSET_THREAD_UI_LANGUAGE) GetProcAddress(h, "SetThreadUILanguage");

        if(pfSetThreadUILanguage != NULL)
        {
            pfSetThreadUILanguage(0);
        }
    }

    _wsetlocale(LC_ALL, L".OCP");
}

/*  Largely copied from ipconfig code : net\tcpip\commands\ipconfig\display.c */
VOID
FormatTheTime(SYSTEMTIME *pSysTime, WCHAR *TimeStr, int TimeStrLen)
{
    int Count;

    TimeStr[0] = 0;

    Count = GetDateFormat(LOCALE_USER_DEFAULT, 
                          DATE_SHORTDATE, 
                          pSysTime, 
                          NULL, 
                          TimeStr, 
                          TimeStrLen);
    if ((Count == 0) || (Count == TimeStrLen))
        return;

    TimeStr += Count-1;
    TimeStrLen -= Count;
    *TimeStr++ = L' ';
    
    Count = GetTimeFormat(LOCALE_USER_DEFAULT, 
                          0,
                          pSysTime, 
                          NULL, 
                          TimeStr, 
                          TimeStrLen);
    // If GetTimeFormat failed, overwrite the ' ' with 
    // 0 to null terminate the string
    if (Count == 0) 
    {
        *--TimeStr = 0;
    }

    return;
}

VOID
ConvertTimeToSystemTime(IN time_t Ttime, OUT WCHAR *TimeStr, IN int TimeStrLen)
{
    SYSTEMTIME SysTime;
    struct tm *pTM;

    TimeStr[0] = 0;

    _tzset();

    pTM = localtime(&Ttime);

    if (pTM == NULL) 
        return;

    SysTime.wYear = (WORD)(pTM->tm_year + 1900);
    SysTime.wMonth = (WORD)(pTM->tm_mon + 1);
    SysTime.wDayOfWeek = (WORD)(pTM->tm_wday);
    SysTime.wDay = (WORD)(pTM->tm_mday);
    SysTime.wHour = (WORD)(pTM->tm_hour);
    SysTime.wMinute = (WORD)(pTM->tm_min);
    SysTime.wSecond = (WORD)(pTM->tm_sec);
    SysTime.wMilliseconds = 0;

    FormatTheTime(&SysTime, TimeStr, TimeStrLen);

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  ConvertTimeToTimeAndDateStrings
//
// Description: Uses the specified locale to build strings for time-of-day and
//              date (short format)
//
// Arguments: time_t Ttime        - IN time to be converted
//            WCHAR *TimeOfDayStr - OUT buffer for the time-of-day string
//            int TimeOfDayStrLen - IN size of time-of-day buffer in characters
//            WCHAR *DateStr      - OUT buffer for the date string
//            int DateStrLen      - IN size of date buffer in characters
//
// Returns:   VOID
//
// History: chrisdar 25 Jul 2002
//
//+----------------------------------------------------------------------------
VOID
ConvertTimeToTimeAndDateStrings(IN time_t Ttime, OUT WCHAR *TimeOfDayStr, IN int TimeOfDayStrLen, OUT WCHAR *DateStr, IN int DateStrLen)
{
    SYSTEMTIME SysTime;
    struct tm *pTM;

    //
    // We assume that this function will not be used to determine the size of buffer required to store these strings...
    //
    ASSERT(DateStrLen > 0);
    ASSERT(TimeOfDayStrLen > 0);

    //
    // ...and that the user passed us a buffer we can populate
    //
    ASSERT(DateStr != NULL);
    ASSERT(TimeOfDayStr != NULL);

    _tzset();

    pTM = localtime(&Ttime);

    if (pTM == NULL) 
        return;

    SysTime.wYear = (WORD)(pTM->tm_year + 1900);
    SysTime.wMonth = (WORD)(pTM->tm_mon + 1);
    SysTime.wDayOfWeek = (WORD)(pTM->tm_wday);
    SysTime.wDay = (WORD)(pTM->tm_mday);
    SysTime.wHour = (WORD)(pTM->tm_hour);
    SysTime.wMinute = (WORD)(pTM->tm_min);
    SysTime.wSecond = (WORD)(pTM->tm_sec);
    SysTime.wMilliseconds = 0;

    *TimeOfDayStr = 0; // In case GetDateFormat fails. Assuming GetDateFormat doesn't touch the output buffer if the call fails.
    GetTimeFormat(LOCALE_USER_DEFAULT, 
                  0,
                  &SysTime, 
                  NULL, 
                  TimeOfDayStr, 
                  TimeOfDayStrLen);

    *DateStr = 0; // In case GetDateFormat fails. Assuming GetDateFormat doesn't touch the output buffer if the call fails.
    GetDateFormat(LOCALE_USER_DEFAULT, 
                  DATE_SHORTDATE, 
                  &SysTime, 
                  NULL, 
                  DateStr,
                  DateStrLen);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\clusterwrapper.cpp ===
#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "debug.h"
#include "wlbsiocl.h"
#include "controlwrapper.h"
#include "clusterwrapper.h"
#include "utils.h"
#include "wlbsparm.h"
#include "cluster.h"
#include "wlbsutil.h"
#include "clusterwrapper.tmh"



////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetClusterConfig
//
// Purpose: This is used to obtain the current
//          cluster configuration.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::GetClusterConfig( CClusterConfiguration& a_WlbsConfig )
{
  WLBS_REG_PARAMS WlbsParam;

  TRACE_VERB("->%!FUNC!");

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwWlbsRegRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned : 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );
  }

  a_WlbsConfig.szClusterName = WlbsParam.domain_name;
  a_WlbsConfig.szClusterIPAddress = WlbsParam.cl_ip_addr;
  a_WlbsConfig.szClusterNetworkMask = WlbsParam.cl_net_mask;
  a_WlbsConfig.szClusterMACAddress = WlbsParam.cl_mac_addr;

  a_WlbsConfig.bMulticastSupportEnable = ( WlbsParam.mcast_support != 0);
  a_WlbsConfig.bRemoteControlEnabled   = ( WlbsParam.rct_enabled != 0 );

  a_WlbsConfig.nMaxNodes               = WLBS_MAX_HOSTS;

  a_WlbsConfig.bIgmpSupport            = (WlbsParam.fIGMPSupport != FALSE);
  a_WlbsConfig.bClusterIPToMulticastIP = (WlbsParam.fIpToMCastIp != FALSE);
  a_WlbsConfig.szMulticastIPAddress    = WlbsParam.szMCastIpAddress;

  a_WlbsConfig.bBDATeamActive          = (WlbsParam.bda_teaming.active != 0);

  if (a_WlbsConfig.bBDATeamActive)
  {
      a_WlbsConfig.szBDATeamId         = WlbsParam.bda_teaming.team_id;
      a_WlbsConfig.bBDATeamMaster      = (WlbsParam.bda_teaming.master != 0);
      a_WlbsConfig.bBDAReverseHash     = (WlbsParam.bda_teaming.reverse_hash != 0);
  }

  a_WlbsConfig.bIdentityHeartbeatEnabled   = ( WlbsParam.identity_enabled != 0 );

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetNodeConfig
//
// Purpose: This function retrieves the current WLBS configuration and selects
//          only NodeSetting pertinent information. The information is passed
//          back in a CNodeConfiguration class instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::GetNodeConfig( CNodeConfiguration& a_WlbsConfig )
{
  WLBS_REG_PARAMS WlbsParam;

  TRACE_VERB("->%!FUNC!");

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwWlbsRegRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned : 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );
  }

  a_WlbsConfig.szDedicatedIPAddress = WlbsParam.ded_ip_addr;
  a_WlbsConfig.szDedicatedNetworkMask = WlbsParam.ded_net_mask;
  a_WlbsConfig.bClusterModeOnStart = ( WlbsParam.cluster_mode == CVY_HOST_STATE_STARTED );
  a_WlbsConfig.bClusterModeSuspendOnStart = ( WlbsParam.cluster_mode == CVY_HOST_STATE_SUSPENDED );
  a_WlbsConfig.bPersistSuspendOnReboot = (( WlbsParam.persisted_states & CVY_PERSIST_STATE_SUSPENDED ) != 0);
  //a_WlbsConfig.bNBTSupportEnable   = ( WlbsParam.nbt_support  != 0 );
  a_WlbsConfig.bMaskSourceMAC      = ( WlbsParam.mask_src_mac != 0 );

  a_WlbsConfig.dwNumberOfRules          = WlbsGetNumPortRules(&WlbsParam);
  a_WlbsConfig.dwCurrentVersion         = WlbsParam.alive_period;
  a_WlbsConfig.dwHostPriority           = WlbsParam.host_priority;
  a_WlbsConfig.dwAliveMsgPeriod         = WlbsParam.alive_period;
  a_WlbsConfig.dwAliveMsgTolerance      = WlbsParam.alive_tolerance;
  a_WlbsConfig.dwRemoteControlUDPPort   = WlbsParam.rct_port;
  a_WlbsConfig.dwDescriptorsPerAlloc    = WlbsParam.dscr_per_alloc;
  a_WlbsConfig.dwMaxDescriptorAllocs    = WlbsParam.max_dscr_allocs;
  a_WlbsConfig.dwFilterIcmp             = WlbsParam.filter_icmp;
  a_WlbsConfig.dwTcpDescriptorTimeout   = WlbsParam.tcp_dscr_timeout;
  a_WlbsConfig.dwIpSecDescriptorTimeout = WlbsParam.ipsec_dscr_timeout;
  a_WlbsConfig.dwNumActions             = WlbsParam.num_actions;
  a_WlbsConfig.dwNumPackets             = WlbsParam.num_packets;
  a_WlbsConfig.dwNumAliveMsgs           = WlbsParam.num_send_msgs;
  a_WlbsConfig.szDedicatedIPAddress     = WlbsParam.ded_ip_addr;
  a_WlbsConfig.dwEffectiveVersion       = WlbsGetEffectiveVersion(&WlbsParam);

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetClusterConfig
//
// Purpose: This is used to update the registry with values that originate from 
//          the MOF ClusterSetting class.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::PutClusterConfig( const CClusterConfiguration &a_WlbsConfig )
{

  WLBS_REG_PARAMS NlbRegData;

  TRACE_VERB("->%!FUNC!");

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&NlbRegData );

  if( dwWlbsRegRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned : 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );
  }

  wcsncpy
    ( 
      NlbRegData.domain_name, 
      a_WlbsConfig.szClusterName.c_str(), 
      WLBS_MAX_DOMAIN_NAME
    );

  wcsncpy
    ( 
      NlbRegData.cl_net_mask, 
      a_WlbsConfig.szClusterNetworkMask.c_str(), 
      WLBS_MAX_CL_NET_MASK
    );

  wcsncpy
    ( 
      NlbRegData.cl_ip_addr , 
      a_WlbsConfig.szClusterIPAddress.c_str(), 
      WLBS_MAX_CL_IP_ADDR
    );

  NlbRegData.mcast_support = a_WlbsConfig.bMulticastSupportEnable;
  NlbRegData.rct_enabled   = a_WlbsConfig.bRemoteControlEnabled;

  NlbRegData.fIGMPSupport = a_WlbsConfig.bIgmpSupport;
  NlbRegData.fIpToMCastIp = a_WlbsConfig.bClusterIPToMulticastIP;

  wcsncpy
    ( 
      NlbRegData.szMCastIpAddress , 
      a_WlbsConfig.szMulticastIPAddress.c_str(), 
      WLBS_MAX_CL_IP_ADDR
    );

  // Fill in BDA information, if active
  NlbRegData.bda_teaming.active =  a_WlbsConfig.bBDATeamActive;
  if (NlbRegData.bda_teaming.active)
  {
      wcsncpy
        ( 
          NlbRegData.bda_teaming.team_id, 
          a_WlbsConfig.szBDATeamId.c_str(), 
          WLBS_MAX_BDA_TEAM_ID
        );

      NlbRegData.bda_teaming.master = a_WlbsConfig.bBDATeamMaster;
      NlbRegData.bda_teaming.reverse_hash = a_WlbsConfig.bBDAReverseHash;
  }
  
  NlbRegData.identity_enabled   = a_WlbsConfig.bIdentityHeartbeatEnabled;

  dwWlbsRegRes = CWlbsCluster::WriteConfig(&NlbRegData );

  if( dwWlbsRegRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned : 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::PutNodeConfig
//
// Purpose:This is used to update the registry with values that originate from 
//         the MOF NodeSetting class.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::PutNodeConfig( const CNodeConfiguration& a_WlbsConfig )
{
  WLBS_REG_PARAMS NlbRegData;

  TRACE_VERB("->%!FUNC!");

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&NlbRegData);

  if( dwWlbsRegRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned : 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );
  }

  NlbRegData.host_priority   = a_WlbsConfig.dwHostPriority;
  NlbRegData.alive_period    = a_WlbsConfig.dwAliveMsgPeriod;
  NlbRegData.alive_tolerance = a_WlbsConfig.dwAliveMsgTolerance;

  /* Here, we need to convert the two boolean WMI properties to a single enumerated
     type describing the initial default state of the host.  Valid states include
     started, stopped and suspended.  The default initial host state is the state 
     that will be assumed by the driver if the last known state has not been configured
     as a persisted state.  That is, when the driver loads, it reads the last known
     state of the host from this registry - this is the state that the host was in 
     when NLB was unbound from the adapter.  If that state is supposed to be persisted,
     as configured by a user (see bPersistSuspendOnReboot below), then the driver will
     assume that state.  If the last known state was not configured to be persisted,
     then the driver will ignore the last known state and assume the default initial
     state configured by the user - this is the legacy NLB behavior and should continue
     to be the most common behavior. */
  if (a_WlbsConfig.bClusterModeOnStart) 
  {
      /* If the user has set the bClusterModeOnStart property, that indicates that the
         preferred intitial state of the cluster should be started.  However, if they
         have also set the bClusterModeSuspendOnStart property, we have to choose 
         whether to start or suspend - we cannot do both.  In this case, we give 
         precedence to the legacy property (bClusterModeOnStart) and start the host. */
      NlbRegData.cluster_mode = CVY_HOST_STATE_STARTED;

      if (a_WlbsConfig.bClusterModeSuspendOnStart) 
      {
          TRACE_INFO("%!FUNC! Invalid setting : Both bClusterModeOnStart & bClusterModeSuspendOnStart are set to TRUE, Ignoring bClusterModeSuspendOnStart");      
      }
  }
  else if (a_WlbsConfig.bClusterModeSuspendOnStart)
  {
      /* Otherwise, if the bClusterMode on start property was not set, but the 
         bClusterModeSuspendOnStart flag is set, this indicates a perferred intial
         state of suspended. */
      NlbRegData.cluster_mode = CVY_HOST_STATE_SUSPENDED;
  }
  else 
  {
      /* Otherwise, if both properties are reset, we stop the host. */
      NlbRegData.cluster_mode = CVY_HOST_STATE_STOPPED;
  }

  /* Persisted states are independent of default initial host states.  Persisted
     states are those which the user is requesting that the driver "remember" after
     a reboot, while the default initial host state is the state that will be 
     assumed in all cases where the driver elects not to persist a state.  For 
     instance, it makes perfect sense for an administrator to set the default 
     initial host state to started, yet ask NLB to persist suspended states.  In
     that case, if the host was stopped or started when a reboot occurred, the
     driver would re-start the host.  However, if the host was suspended at the
     time the reboot occurred, the driver would remember that and keep the host
     suspend after the reboot.  At this time, we only allow users to persist
     suspended states, which is sort of a maintenance state.  The driver can persist
     all three states, but we expose only one option to users at this time. */
  if (a_WlbsConfig.bPersistSuspendOnReboot) 
  {
      /* Each state to be persisted has its own bit in the persisted states flag register -
         Set the bit for persisting suspended states, but leave the other bits unaltered. 
         Setting this bit tells the driver to remember if the host was suspended. */
      NlbRegData.persisted_states |= CVY_PERSIST_STATE_SUSPENDED;
  }
  else
  {
      /* Each state to be persisted has its own bit in the persisted states flag register -
         Reset the bit for persisting suspended states, but leave the other bits unaltered. 
         Turning this bit off tells the driver to use the default initial host state if 
         the last known state was suspended. */
      NlbRegData.persisted_states &= ~CVY_PERSIST_STATE_SUSPENDED;
  }

//  NlbRegData.nbt_support     = a_WlbsConfig.bNBTSupportEnable;
  NlbRegData.rct_port           = a_WlbsConfig.dwRemoteControlUDPPort;
  NlbRegData.mask_src_mac       = a_WlbsConfig.bMaskSourceMAC;
  NlbRegData.dscr_per_alloc     = a_WlbsConfig.dwDescriptorsPerAlloc;
  NlbRegData.max_dscr_allocs    = a_WlbsConfig.dwMaxDescriptorAllocs;
  NlbRegData.filter_icmp        = a_WlbsConfig.dwFilterIcmp;
  NlbRegData.tcp_dscr_timeout   = a_WlbsConfig.dwTcpDescriptorTimeout;   
  NlbRegData.ipsec_dscr_timeout = a_WlbsConfig.dwIpSecDescriptorTimeout;   
  NlbRegData.num_actions        = a_WlbsConfig.dwNumActions;
  NlbRegData.num_packets        = a_WlbsConfig.dwNumPackets;
  NlbRegData.num_send_msgs      = a_WlbsConfig.dwNumAliveMsgs;

  //set dedicated IP
  wcsncpy
    ( 
      NlbRegData.ded_ip_addr, 
      a_WlbsConfig.szDedicatedIPAddress.c_str(), 
      WLBS_MAX_DED_IP_ADDR
    );

  //set dedicated mask
  wcsncpy
    ( 
      NlbRegData.ded_net_mask, 
      a_WlbsConfig.szDedicatedNetworkMask.c_str(), 
      WLBS_MAX_DED_NET_MASK
    );

  dwWlbsRegRes = CWlbsCluster::WriteConfig(&NlbRegData);

  if( dwWlbsRegRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned : 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
}



////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::Commit
//
// Purpose: This function invokes WlbsCommitChanges, which causes the driver to
//          load the current registry parameters.
//
// Return:  This function returns either WLBS_OK or WLBS_REBOOT. All other
//          Wlbs return values cause this function to throw WBEM_E_FAILED.
//
// Note:    The wlbs API currently caches the cluster and dedicated IP addreses.
//          As a result, if a user changes these values via a source external
//          to this provider, the cached values will fall out of sync. To
//          prevent this, a WlbsWriteReg is invoked to force the cache to
//          update.
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsClusterWrapper::Commit(CWlbsControlWrapper* pControl)
{

  WLBS_REG_PARAMS WlbsRegData;
  DWORD dwExtRes;


  TRACE_VERB("->%!FUNC!");

  dwExtRes = CWlbsCluster::CommitChanges(&pControl->m_WlbsControl);

  if( dwExtRes != WLBS_OK && dwExtRes != WLBS_REBOOT )
  {
    TRACE_CRIT("%!FUNC! CommitChanges returned error = 0x%x, Throwing Wlbs error exception",dwExtRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwExtRes, CmdWlbsCommitChanges );
  }

  TRACE_VERB("<-%!FUNC! return = 0x%x",dwExtRes);
  return dwExtRes;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetPassword
//
// Purpose: This function encodes the WLBS remote control password and saves 
//          it in the registry.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetPassword( LPWSTR a_szPassword )
{
  WLBS_REG_PARAMS RegData;

  TRACE_VERB("->%!FUNC!");

  DWORD dwRes = CWlbsCluster::ReadConfig(&RegData );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

  dwRes = WlbsSetRemotePassword( &RegData, a_szPassword );

  if( dwRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! WlbsSetRemotePassword returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsSetRemotePassword );
  }


  dwRes = CWlbsCluster::WriteConfig( &RegData );

  if( dwRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! WriteConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetPortRule
//
// Purpose: This function retrieves the port rule that encompasses the requested
//          port.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::GetPortRule( DWORD a_dwVip, DWORD a_dwPort, PWLBS_PORT_RULE a_pPortRule )
{

  WLBS_REG_PARAMS WlbsParam;

  TRACE_VERB("->%!FUNC!");

  DWORD dwWlbsRegRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwWlbsRegRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwWlbsRegRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwWlbsRegRes, CmdWlbsReadReg );
  }

  DWORD dwRes = WlbsGetPortRule( &WlbsParam, a_dwVip, a_dwPort, a_pPortRule );

  if( dwRes == WLBS_NOT_FOUND )
  {
      TRACE_CRIT("%!FUNC! WlbsGetPortRule returned WLBS_NOT_FOUND, Throwing com_error WBEM_E_NOT_FOUND exception");
      TRACE_VERB("<-%!FUNC!");
      throw _com_error( WBEM_E_NOT_FOUND );
  }

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! WlbsGetPortRule returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsGetPortRule );
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::EnumPortRules
//
// Purpose: This function retrieves all of the port rules of a given type. The
//          function allocates memory for the received port rules. It is up
//          to the caller to free the memory. The number of rules retrieved is
//          placed in the a_dwNumRules parameter.
//
// Note:    Setting a_FilteringMode = 0 instructs function to retrieve all the
//          port rules.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::EnumPortRules
  ( 
    WLBS_PORT_RULE** a_ppPortRule,
    LPDWORD          a_pdwNumRules,
    DWORD            a_FilteringMode
  )
{

  WLBS_PORT_RULE  AllPortRules[WLBS_MAX_RULES];
  DWORD           dwTotalNumRules = WLBS_MAX_RULES;

  TRACE_VERB("->%!FUNC!");

  ASSERT( a_ppPortRule );

  WLBS_REG_PARAMS WlbsParam;
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

  dwRes = WlbsEnumPortRules( &WlbsParam, AllPortRules, &dwTotalNumRules );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! WlbsEnumPortRules returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsEnumPortRules );
  }

  if( dwTotalNumRules == 0 ) {
      a_pdwNumRules = 0;
      TRACE_CRIT("%!FUNC! WlbsEnumPortRules returned zero port rules");
      TRACE_VERB("<-%!FUNC!");
      return;
  }

  long  nMaxSelRuleIndex = -1;
  DWORD  dwSelectedPortRules[WLBS_MAX_RULES];

  //loop through all of the port rules
  for( DWORD i = 0; i < dwTotalNumRules; i++) {
    if( a_FilteringMode == 0 || AllPortRules[i].mode == a_FilteringMode )
      dwSelectedPortRules[++nMaxSelRuleIndex] = i;
  }

  //if rule counter is less than zero, then return not found
  if( nMaxSelRuleIndex < 0 ) {
    a_pdwNumRules = 0;
    TRACE_CRIT("%!FUNC! Rule counter is less than zero");
    TRACE_VERB("<-%!FUNC!");
    return;
  }
  
  *a_ppPortRule = new WLBS_PORT_RULE[nMaxSelRuleIndex+1];

  if( !*a_ppPortRule )
  {
      TRACE_CRIT("%!FUNC! new failed, Throwing com error WBEM_E_OUT_OF_MEMORY exception");
      TRACE_VERB("<-%!FUNC!");
      throw _com_error( WBEM_E_OUT_OF_MEMORY );
  }

  PWLBS_PORT_RULE pRule = *a_ppPortRule;
  for( i = 0; i <= (DWORD)nMaxSelRuleIndex; i++ ) {
    CopyMemory( pRule++, 
                &AllPortRules[dwSelectedPortRules[i]],
                sizeof( WLBS_PORT_RULE ) );
  }

  *a_pdwNumRules = nMaxSelRuleIndex + 1;

  TRACE_VERB("<-%!FUNC!");
  return;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::RuleExists
//
// Purpose: This function checks for the existence of a rule that has start
//          and end ports that match the input values.
//
////////////////////////////////////////////////////////////////////////////////
bool CWlbsClusterWrapper::RuleExists(DWORD a_dwVip, DWORD a_dwStartPort )
{

  WLBS_REG_PARAMS WlbsParam;

  TRACE_VERB("->%!FUNC!");

  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

  WLBS_PORT_RULE PortRule;
  
  dwRes = WlbsGetPortRule( &WlbsParam, a_dwVip, a_dwStartPort, &PortRule );

  if( dwRes == WLBS_NOT_FOUND )
  {
      TRACE_VERB("<-%!FUNC! return = false");
      return false;
  }

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! WlbsGetPortRule returned error = 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsGetPortRule );
  }

  if( PortRule.start_port == a_dwStartPort )
  {
      TRACE_VERB("<-%!FUNC! return = true");
      return true;
  }

  TRACE_VERB("<-%!FUNC! return = false");
  return false;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::DeletePortRule
//
// Purpose: This function deletes the rule that contains the input port.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::DeletePortRule(DWORD a_dwVip, DWORD a_dwPort )
{

  WLBS_REG_PARAMS WlbsParam;

  TRACE_VERB("->%!FUNC!");

  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }
  
  dwRes = WlbsDeletePortRule( &WlbsParam, a_dwVip, a_dwPort );

  if( dwRes == WBEM_E_NOT_FOUND )
  {
    TRACE_CRIT("%!FUNC! WlbsDeletePortRule returned WBEM_E_NOT_FOUND, Throwing com_error WBEM_E_NOT_FOUND exception");
    TRACE_VERB("<-%!FUNC!");
    throw _com_error( WBEM_E_NOT_FOUND );
  }

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! WlbsDeletePortRule returned error = 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsDeletePortRule );
  }

  dwRes = CWlbsCluster::WriteConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned error : 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
  }
 
  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::PutPortRule
//
// Purpose: This function adds a rule.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::PutPortRule(const PWLBS_PORT_RULE a_pPortRule)
{

  WLBS_REG_PARAMS WlbsParam;

  TRACE_VERB("->%!FUNC!");

  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

  dwRes = WlbsAddPortRule( &WlbsParam, a_pPortRule );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! WlbsAddPortRule returned error : 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsAddPortRule );
  }

  dwRes = CWlbsCluster::WriteConfig(&WlbsParam );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned error : 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
  return;
}


DWORD CWlbsClusterWrapper::GetClusterIpOrIndex(CWlbsControlWrapper* pControl)
{
    return CWlbsCluster::GetClusterIpOrIndex(&pControl->m_WlbsControl);
}



////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::GetHostID
//
// Purpose: Obtain ID of the local host.
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsClusterWrapper::GetHostID()
{
    return CWlbsCluster::GetHostID();
/*
  WLBS_RESPONSE WlbsResponse;
  DWORD dwResSize = 1;

  //get the cluster and HostID
  DWORD dwRes    = WlbsQuery( CWlbsCluster::GetClusterIp(),
                              WLBS_LOCAL_HOST,
                              &WlbsResponse, 
                              &dwResSize, 
                              NULL, 
                              NULL );

  //analyze query results for errors
  switch( dwRes ) {
    case WLBS_OK:
    case WLBS_STOPPED:
    case WLBS_CONVERGING:
    case WLBS_CONVERGED:
    case WLBS_DEFAULT:
    case WLBS_DRAINING:
    case WLBS_SUSPENDED:
      break;
    default:
      throw CErrorWlbsControl( dwRes, CmdWlbsQuery );
  }

  return WlbsResponse.id;
*/
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetNodeDefaults
//
// Purpose: This routine obtains the default configuration and sets the node
//          setting properties to their defaults without affecting the other
//          values.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetNodeDefaults()
{
  WLBS_REG_PARAMS WlbsConfiguration;
  WLBS_REG_PARAMS WlbsDefaultConfiguration;

  TRACE_VERB("->%!FUNC!");

  //get current configuration
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

	//get the default configuration
  dwRes = WlbsSetDefaults(&WlbsDefaultConfiguration );

  if( dwRes != WLBS_OK ) 
  {
    TRACE_CRIT("%!FUNC! WlbsSetDefaults returned error = 0x%x, Throwing Wlbs error exception",dwRes);
    TRACE_VERB("<-%!FUNC!");
    throw CErrorWlbsControl( dwRes, CmdWlbsSetDefaults );
  }

  //modify current configuration with
	//default configuration
  WlbsConfiguration.host_priority   = WlbsDefaultConfiguration.host_priority;
  WlbsConfiguration.alive_period    = WlbsDefaultConfiguration.alive_period;
  WlbsConfiguration.alive_tolerance = WlbsDefaultConfiguration.alive_tolerance;
  WlbsConfiguration.cluster_mode    = WlbsDefaultConfiguration.cluster_mode;
  WlbsConfiguration.persisted_states= WlbsDefaultConfiguration.persisted_states;
  WlbsConfiguration.rct_port        = WlbsDefaultConfiguration.rct_port;
  WlbsConfiguration.mask_src_mac    = WlbsDefaultConfiguration.mask_src_mac;
  WlbsConfiguration.dscr_per_alloc  = WlbsDefaultConfiguration.dscr_per_alloc;
  WlbsConfiguration.max_dscr_allocs = WlbsDefaultConfiguration.max_dscr_allocs;
  WlbsConfiguration.filter_icmp     = WlbsDefaultConfiguration.filter_icmp;
  WlbsConfiguration.tcp_dscr_timeout= WlbsDefaultConfiguration.tcp_dscr_timeout;
  WlbsConfiguration.ipsec_dscr_timeout= WlbsDefaultConfiguration.ipsec_dscr_timeout;
  WlbsConfiguration.num_actions     = WlbsDefaultConfiguration.num_actions;
  WlbsConfiguration.num_packets     = WlbsDefaultConfiguration.num_packets;
  WlbsConfiguration.num_send_msgs   = WlbsDefaultConfiguration.num_send_msgs;

  //set dedicated IP
  wcsncpy
    ( 
      WlbsConfiguration.ded_ip_addr, 
      WlbsDefaultConfiguration.ded_ip_addr, 
      WLBS_MAX_DED_IP_ADDR
    );

  //set dedicated mask
  wcsncpy
    ( 
      WlbsConfiguration.ded_net_mask, 
      WlbsDefaultConfiguration.ded_net_mask, 
      WLBS_MAX_DED_NET_MASK
    );

	//write the default configuration
  dwRes = CWlbsCluster::WriteConfig(&WlbsConfiguration);

  if( dwRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetClusterDefaults
//
// Purpose: This routine obtains the default configuration and sets the cluster
//          setting properties to their defaults without affecting the other
//          values.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetClusterDefaults()
{
  WLBS_REG_PARAMS WlbsConfiguration;
  WLBS_REG_PARAMS WlbsDefaultConfiguration;

  TRACE_VERB("->%!FUNC!");

  //get current configuration
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

	//get the default configuration
  dwRes = WlbsSetDefaults(&WlbsDefaultConfiguration );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! WlbsSetDefaults returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsSetDefaults );
  }

	//modify current configuration
  wcsncpy
    ( 
      WlbsConfiguration.domain_name, 
      WlbsDefaultConfiguration.domain_name, 
      WLBS_MAX_DOMAIN_NAME
    );

  wcsncpy
    ( 
      WlbsConfiguration.cl_net_mask, 
      WlbsDefaultConfiguration.cl_net_mask, 
      WLBS_MAX_CL_NET_MASK
    );

  wcsncpy
    ( 
      WlbsConfiguration.cl_ip_addr , 
      WlbsDefaultConfiguration.cl_ip_addr, 
      WLBS_MAX_CL_IP_ADDR
    );

  WlbsConfiguration.mcast_support = WlbsDefaultConfiguration.mcast_support;
  WlbsConfiguration.rct_enabled   = WlbsDefaultConfiguration.rct_enabled;
  
  WlbsConfiguration.fIGMPSupport   = WlbsDefaultConfiguration.fIGMPSupport;
  WlbsConfiguration.fIpToMCastIp   = WlbsDefaultConfiguration.fIpToMCastIp;
  wcsncpy
    ( 
      WlbsConfiguration.szMCastIpAddress , 
      WlbsDefaultConfiguration.szMCastIpAddress, 
      WLBS_MAX_CL_IP_ADDR
    );

  // Copy over BDA values
  WlbsConfiguration.bda_teaming.active = WlbsDefaultConfiguration.bda_teaming.active;
  if (WlbsConfiguration.bda_teaming.active) 
  {
      wcsncpy
        ( 
          WlbsConfiguration.bda_teaming.team_id, 
          WlbsDefaultConfiguration.bda_teaming.team_id, 
          WLBS_MAX_BDA_TEAM_ID
        );

      WlbsConfiguration.bda_teaming.master = WlbsDefaultConfiguration.bda_teaming.master;
      WlbsConfiguration.bda_teaming.reverse_hash = WlbsDefaultConfiguration.bda_teaming.reverse_hash;
  }

  //write the default configuration
  dwRes = CWlbsCluster::WriteConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK )
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::SetPortRuleDefaults
//
// Purpose: This routine obtains the current NLB configuration and the default
//          configuration. All of the port rules are removed in the current
//          configuration and replaced by the default configuration.
//
// Note:    The routine only uses WLBS API calls to replace the current port
//          rule configuration with the default configuration. This is not 
//          the most efficient method, but it avoids making assumptions
//          about the underlying data structure.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsClusterWrapper::SetPortRuleDefaults()
{
  WLBS_REG_PARAMS WlbsConfiguration;
  WLBS_REG_PARAMS WlbsDefaultConfiguration;
  WLBS_PORT_RULE  PortRules[WLBS_MAX_RULES];
  DWORD           dwNumRules = WLBS_MAX_RULES;

  TRACE_VERB("->%!FUNC!");

  //get current configuration
  DWORD dwRes = CWlbsCluster::ReadConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::ReadConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsReadReg );
  }

	//get the default configuration
  dwRes = WlbsSetDefaults(&WlbsDefaultConfiguration );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! WlbsSetDefaults returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsSetDefaults );
  }

  //get the current port rules
  dwRes = WlbsEnumPortRules( &WlbsConfiguration,
                             PortRules,
                             &dwNumRules );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! WlbsEnumPortRules returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsEnumPortRules );
  }

  //remove all of the current port rules
  DWORD i = 0;
  for( i = 0; i < dwNumRules; i++ )
  {
    //make sure that this works as expected i.e. the indexes must be valid
    dwRes = WlbsDeletePortRule( &WlbsConfiguration, IpAddressFromAbcdWsz(PortRules[i].virtual_ip_addr), PortRules[i].start_port );

    if( dwRes != WLBS_OK ) 
    {
        TRACE_CRIT("%!FUNC! WlbsDeletePortRule returned error = 0x%x, Throwing Wlbs error exception",dwRes);
        TRACE_VERB("<-%!FUNC!");
        throw CErrorWlbsControl( dwRes, CmdWlbsDeletePortRule );
    }
  }

  //get the default port rules
  dwNumRules = WLBS_MAX_RULES;

  dwRes = WlbsEnumPortRules( &WlbsDefaultConfiguration,
                             PortRules,
                             &dwNumRules );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! WlbsEnumPortRules returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsEnumPortRules );
  }

  //add the default port rules
  for( i = 0; i < dwNumRules; i++ )
  {

    dwRes = WlbsAddPortRule( &WlbsConfiguration, &PortRules[i] );

    if( dwRes != WLBS_OK ) 
    {
        TRACE_CRIT("%!FUNC! WlbsAddPortRule returned error = 0x%x, Throwing Wlbs error exception",dwRes);
        TRACE_VERB("<-%!FUNC!");
        throw CErrorWlbsControl( dwRes, CmdWlbsAddPortRule );
    }
  }

  dwRes = CWlbsCluster::WriteConfig(&WlbsConfiguration );

  if( dwRes != WLBS_OK ) 
  {
      TRACE_CRIT("%!FUNC! CWlbsCluster::WriteConfig returned error = 0x%x, Throwing Wlbs error exception",dwRes);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRes, CmdWlbsWriteReg );
  }

  TRACE_VERB("<-%!FUNC!");
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\clusterwrapper.h ===
#include "wlbsiocl.h"
#include "wlbsparm.h"
#include "cluster.h"

class CWlbsControlWrapper;  // forward declaration
class CWlbsCluster;

struct CClusterConfiguration
{
  wstring     szClusterName;
  wstring     szClusterIPAddress;
  wstring     szClusterNetworkMask;
  wstring     szClusterMACAddress;
  long        nMaxNodes;
  bool        bMulticastSupportEnable;
  bool        bRemoteControlEnabled;
  bool        bIgmpSupport;
  bool        bClusterIPToMulticastIP;
  wstring     szMulticastIPAddress;
  bool        bBDATeamActive;
  wstring     szBDATeamId;
  bool        bBDATeamMaster;
  bool        bBDAReverseHash;
  bool        bIdentityHeartbeatEnabled;
};

struct CNodeConfiguration
{

  /* obtained from the registry */
  DWORD       dwNumberOfRules;
  DWORD       dwCurrentVersion;
  DWORD       dwHostPriority;
  wstring     szDedicatedIPAddress;
  wstring     szDedicatedNetworkMask;
  DWORD       dwAliveMsgPeriod;
  DWORD       dwAliveMsgTolerance;
  bool        bClusterModeOnStart;
  bool        bClusterModeSuspendOnStart;
  bool        bPersistSuspendOnReboot;
  //bool        bNBTSupportEnable;
  bool        bMaskSourceMAC;
  DWORD       dwRemoteControlUDPPort;
  DWORD       dwDescriptorsPerAlloc;
  DWORD       dwMaxDescriptorAllocs;
  DWORD       dwFilterIcmp;
  DWORD       dwTcpDescriptorTimeout;
  DWORD       dwIpSecDescriptorTimeout;
  DWORD       dwNumActions;
  DWORD       dwNumPackets;
  DWORD       dwNumAliveMsgs;
  DWORD       dwEffectiveVersion;
};


class CWlbsClusterWrapper : public CWlbsCluster
{
public:
    DWORD GetHostID();
    DWORD GetClusterIP() {return CWlbsCluster::GetClusterIp();}

    DWORD GetClusterIpOrIndex(CWlbsControlWrapper* pControl);

    void SetPortRuleDefaults();
    void GetPortRule( DWORD dwVip, DWORD dwStartPort, PWLBS_PORT_RULE pPortRule );
    void PutPortRule(const PWLBS_PORT_RULE a_pPortRule);
    void EnumPortRules(PWLBS_PORT_RULE* ppPortRule, DWORD* pdwNumRules, DWORD dwFilteringMode);
    void DeletePortRule(DWORD dwVip, DWORD dwStartPort);
    bool RuleExists(DWORD dwVip, DWORD dwStartPort);

    void GetClusterConfig( CClusterConfiguration& a_WlbsConfig);
    void GetNodeConfig( CNodeConfiguration& a_WlbsConfig);
    void PutClusterConfig( const CClusterConfiguration &a_WlbsConfig);
    void PutNodeConfig( const CNodeConfiguration& a_WlbsConfig );
    void SetNodeDefaults();
    void SetClusterDefaults();
    GUID GetAdapterGuid() {return CWlbsCluster::GetAdapterGuid();}



    DWORD Commit(CWlbsControlWrapper* pControl);

    void SetPassword( LPWSTR a_szPassword );



private:
    CWlbsClusterWrapper() : CWlbsCluster(0){};  // Helper class, no instance
    ~CWlbsClusterWrapper() {};  // can not delete
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\controlwrapper.cpp ===
#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "debug.h"
#include "controlwrapper.h"
#include "clusterwrapper.h"
#include "utils.h"
#include "wlbsparm.h"
#include "control.h"
#include "controlwrapper.tmh"


#define NLB_DEFAULT_TIMEOUT 10


void CWlbsControlWrapper::Initialize()
{
  TRACE_CRIT("->%!FUNC!");

  DWORD dwRet = m_WlbsControl.Initialize();

  if( dwRet != WLBS_PRESENT && dwRet != WLBS_LOCAL_ONLY)
  {
    TRACE_CRIT("%!FUNC! CWlbsControl::Initialize failed : 0x%x, Throwing Wlbs error exception", dwRet);
    TRACE_CRIT("<-%!FUNC!");
    throw CErrorWlbsControl( dwRet, CmdWlbsInit );
  }

  m_WlbsControl.WlbsTimeoutSet( WLBS_ALL_CLUSTERS, NLB_DEFAULT_TIMEOUT );

  CWlbsCluster** ppCluster;
  DWORD dwNumClusters = 0;
  
  //
  // Use the local password for local query
  //
  m_WlbsControl.EnumClusterObjects( ppCluster, &dwNumClusters);

  for (int i=0;i<dwNumClusters;i++)
  {
      m_WlbsControl.WlbsCodeSet( ppCluster[i]->GetClusterIp(), 
        ppCluster[i]->GetPassword() );
  }
  TRACE_CRIT("<-%!FUNC!");
}


void CWlbsControlWrapper::ReInitialize()
{
  TRACE_CRIT("->%!FUNC!");
  m_WlbsControl.ReInitialize();
  
  CWlbsCluster** ppCluster;
  DWORD dwNumClusters = 0;
  
  //
  // In case pasword is changed, use the local password for local query
  //
  m_WlbsControl.EnumClusterObjects( ppCluster, &dwNumClusters);

  for (int i=0;i<dwNumClusters;i++)
  {
      //
      // If the change is not commited, the driver will still has the old password
      //
      if (!ppCluster[i]->IsCommitPending())
      {
          m_WlbsControl.WlbsCodeSet( ppCluster[i]->GetClusterIp(), 
            ppCluster[i]->GetPassword() );
      }
  }
  TRACE_CRIT("<-%!FUNC!");
}


void CWlbsControlWrapper::EnumClusters(CWlbsClusterWrapper** & ppCluster, DWORD* pdwNumClusters)
{
    TRACE_VERB("->%!FUNC!");
    m_WlbsControl.EnumClusterObjects( (CWlbsCluster** &) ppCluster, pdwNumClusters);
    TRACE_VERB("<-%!FUNC!");
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Disable
//
// Purpose: Disable ALL traffic handling for the rule containing the 
//          specified port on specified host or all cluster hosts. Only rules 
//          that are set for multiple host filtering mode are affected.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Disable
  ( 
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost     ,
    WLBS_RESPONSE*  a_pResponse  , 
    DWORD&          a_dwNumHosts ,
    DWORD           a_dwVip      ,
    DWORD           a_dwPort    
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsDisable( a_dwCluster   , 
                       a_dwHost      , 
                       a_pResponse   ,
                      &dwNumHosts    ,
                       a_dwVip       ,
                       a_dwPort
                     );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsDisable failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch( dwRet ) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsDisable, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Enable
//
// Purpose:     Enable traffic handling for rule containing the 
//              specified port on specified host or all cluster hosts. Only rules 
//              that are set for multiple host filtering mode are affected.
//
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Enable
  ( 
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost     ,
    WLBS_RESPONSE* a_pResponse  , 
    DWORD&          a_dwNumHosts ,
    DWORD           a_dwVip      ,
    DWORD           a_dwPort    
  )
{
  DWORD dwRet;
  
  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsEnable( a_dwCluster , 
                      a_dwHost    , 
                      a_pResponse ,
                      &dwNumHosts ,
                      a_dwVip     ,
                      a_dwPort
                    );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsEnable failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsEnable, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Drain
//
// Purpose: Disable NEW traffic handling for rule containing the specified 
//          port on specified host or all cluster hosts. Only rules that are 
//          set for multiple host filtering mode are affected.

//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Drain
  ( 
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost     ,
    WLBS_RESPONSE* a_pResponse  , 
    DWORD&          a_dwNumHosts ,
    DWORD           a_dwVip      ,
    DWORD           a_dwPort    
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsDrain( a_dwCluster , 
                     a_dwHost    , 
                     a_pResponse ,
                     &dwNumHosts ,
                     a_dwVip     ,
                     a_dwPort
                   );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsDrain failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsDrain, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::DrainStop
//
// Purpose: Enter draining mode on specified host or all cluster hosts. 
//          New connections will not be accepted. Cluster mode will be stopped 
//          when all existing connections finish. While draining, host will 
//          participate in convergence and remain part of the cluster.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::DrainStop
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsDrainStop( a_dwCluster , 
                         a_dwHost      , 
                         a_pResponse   ,
                         &dwNumHosts 
                       );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsDrainStop failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsDrainStop, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Resume
//
// Purpose: Resume cluster operation control on specified host or all 
//          cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Resume
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsResume( 
                      a_dwCluster , 
                      a_dwHost    , 
                      a_pResponse ,
                      &dwNumHosts 
                    );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsResume failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsResume, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Start
//
// Purpose: Start cluster operations on specified host or all cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Start
  (  
    DWORD           a_dwCluster  ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsStart( a_dwCluster , 
                     a_dwHost      , 
                     a_pResponse   ,
                     &dwNumHosts 
                   );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsStart failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsStart, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Stop
//
// Purpose: Stop cluster operations on specified host or all cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Stop
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsStop( 
                    a_dwCluster , 
                    a_dwHost    , 
                    a_pResponse ,
                    &dwNumHosts 
                   );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsStop failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsStop, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Suspend
//
// Purpose: Suspend cluster operation control on specified host or 
//          all cluster hosts.
//
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Suspend
  (  
    DWORD           a_dwCluster ,
    DWORD           a_dwHost    ,
    WLBS_RESPONSE* a_pResponse , 
    DWORD&          a_dwNumHosts
  )
{
  DWORD dwRet;

  BOOL bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  DWORD dwNumHosts = a_dwNumHosts;

  TRACE_VERB("->%!FUNC!");

  dwRet = m_WlbsControl.WlbsSuspend( a_dwCluster , 
                       a_dwHost    , 
                       a_pResponse ,
                       &dwNumHosts 
                     );

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsSuspend failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch(dwRet) {

    case WLBS_INIT_ERROR:
    case WLBS_BAD_PASSW:
    case WLBS_TIMEOUT:
    case WLBS_LOCAL_ONLY:
    case WLBS_REMOTE_ONLY:
    case WLBS_IO_ERROR:
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsSuspend, bClusterWide );
      break;
  }

  a_dwNumHosts = dwNumHosts;

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsControlWrapper::Query
//
// Purpose: This invokes WlbsQuery and returns a response structure along
//          with other parameters if requested.
// 
// Errors:  The function throws CErrorWlbsControl.
//
// Return:  Status value returned by the target host
//
////////////////////////////////////////////////////////////////////////////////
DWORD CWlbsControlWrapper::Query
  ( 
    CWlbsClusterWrapper * pCluster,
    DWORD                 a_dwHost,
    WLBS_RESPONSE       * a_pResponse, 
    WLBS_RESPONSE       * a_pComputerNameResponse,
    PDWORD                a_pdwNumHosts, 
    PDWORD                a_pdwHostMap
  )
{
  TRACE_VERB("->%!FUNC!");

  DWORD dwRet;
  BOOL bClusterWide = 0;

  bClusterWide = ( a_dwHost == WLBS_ALL_HOSTS );

  // The below check is present only to take care of the
  // condition where a junk pointer was passed, but the
  // a_pdwNumHosts is set to NULL or zero. This check
  // is NOT necessitated by WlbsQuery, but by the check
  // at the end of this function where we fill in the DIP
  // into the zero-th entry of the array.
  if ((a_pdwNumHosts == NULL) || (*a_pdwNumHosts == 0))
  {
       a_pResponse = NULL;
  }

  dwRet = m_WlbsControl.WlbsQuery( 
                     (CWlbsCluster*)pCluster , 
                     a_dwHost    , 
                     a_pResponse , 
                     a_pdwNumHosts, 
                     a_pdwHostMap, 
                     NULL
                   );

  string strOut;

  //check for Winsock errors
  if( dwRet > 10000 )
  {
      TRACE_CRIT("%!FUNC! CWlbsControl::WlbsQuery failed : 0x%x, Throwing Wlbs error exception", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //check the return value and throw if an error occurred
  switch( dwRet ) {
      case WLBS_INIT_ERROR:
      case WLBS_BAD_PASSW:
      case WLBS_TIMEOUT:
      case WLBS_LOCAL_ONLY:
      case WLBS_REMOTE_ONLY:
      case WLBS_IO_ERROR:
      
      TRACE_CRIT("%!FUNC! Throwing Wlbs error exception : 0x%x", dwRet);
      TRACE_VERB("<-%!FUNC!");
      throw CErrorWlbsControl( dwRet, CmdWlbsQuery, bClusterWide );
  }

  //local queries do not return the dedicated IP
  //get the dedicated IP and fill the structure
  if(( a_dwHost == WLBS_LOCAL_HOST ) && (a_pResponse != NULL))
  {
    a_pResponse[0].address = pCluster->GetDedicatedIp();

    // If the local computer's fqdn is to be queried from the nlb driver, do it.
    if(a_pComputerNameResponse)
    {
        GUID            AdapterGuid;

        AdapterGuid = pCluster->GetAdapterGuid();

        WlbsGetSpecifiedClusterMember(&AdapterGuid, pCluster->GetHostID(), a_pComputerNameResponse);
    }
  }

  TRACE_VERB("<-%!FUNC! return = 0x%x", dwRet);
  return dwRet;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbsClusterWrapper::CheckMembership
//
// Purpose: This verifies that the local host is a member of the cluster
//          specified by the Cluster IP in the registry. At the time this
//          was written, there was a remote chance that a user can modify the
//          IP address in the registry prior to the load of this DLL.
//
//          Note, this call is only required for the Node, Cluster and linked
//          associations and should not be invoked for any of the Setting classes.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbsControlWrapper::CheckMembership()
{
// todo: make sure the host is in at least one cluster

/*
  WLBS_RESPONSE WlbsResponse;
  DWORD dwResSize = 1;

  //get the cluster and HostID
  DWORD dwRes    = pControl->Query( m_pWlbsCluster->GetClusterIp(),
                              WLBS_LOCAL_HOST,
                              &WlbsResponse, 
                              &dwResSize, 
                              NULL);

  switch( dwRes ) {
    case WLBS_SUSPENDED:
    case WLBS_STOPPED:
    case WLBS_CONVERGING:
    case WLBS_DRAINING:
    case WLBS_CONVERGED:
    case WLBS_DEFAULT:
      break;
    default:
      throw CErrorWlbsControl( dwRes, CmdWlbsQuery );
  }
*/
  // DWORD dwClusterIP;
  // GetClusterIP( &dwClusterIP );

  //if( dwClusterIP == 0 )
    //throw _com_error( WBEM_E_NOT_FOUND );

  //*******************************
  //this section does not work when the remote control is disabled
  //on the local host
  //*******************************

  //call the query function
//  dwRes = WlbsQuery( dwClusterIP, 
//                     WlbsResponse.id, 
//                     NULL, 
//                     NULL, 
//                     NULL, 
//                     NULL );

  //analyze query results for errors
//  switch( dwRes ) {
//    case WLBS_OK:
//    case WLBS_STOPPED:
//    case WLBS_CONVERGING:
//    case WLBS_CONVERGED:
//    case WLBS_DEFAULT:
//    case WLBS_DRAINING:
//    case WLBS_SUSPENDED:
//      return;
//    default:
//      throw CErrorWlbsControl( dwRes, CmdWlbsQuery );
//  }

  //*******************************
  //this section does not work when the remote control is disabled
  //on the local host
  //*******************************

}



DWORD CWlbsControlWrapper::WlbsQueryState
(
    DWORD          cluster,
    DWORD          host,
    DWORD          operation,
    PNLB_OPTIONS   pOptions,
    PWLBS_RESPONSE pResponse,
    PDWORD         pcResponses
)
{
    return m_WlbsControl.WlbsQueryState(cluster, host, operation, pOptions, pResponse, pcResponses);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    wchar_t *pwcTemp;

                    m_nCurBufSize += 256;
                    // Receive the return value in a temporary variable so that the 
                    // original pointer is not lost in the case of failure. This bug was
                    // found by prefast.
                    pwcTemp = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (pwcTemp == 0)
                        return 0; // out of memory
                    m_pTokenBuf = pwcTemp;
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\controlwrapper.h ===
#ifndef CONTROLWRAPPER_H
#define CONTROLWRAPPER_H

#include "wlbsparm.h"
#include "wlbsiocl.h"
#include "control.h"


class CWlbsControlWrapper
{
friend class CWlbsClusterWrapper;
public:
    CWlbsClusterWrapper* GetClusterFromIpOrIndex(DWORD dwClusterIpOrIndex)
    {
        return (CWlbsClusterWrapper*)m_WlbsControl.GetClusterFromIpOrIndex(
            dwClusterIpOrIndex);
    }
    void EnumClusters(CWlbsClusterWrapper** & ppCluster, DWORD* pdwNumClusters);
    void CheckMembership();

    void Initialize();
    void ReInitialize();
    DWORD Disable
      ( 
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost     ,
        WLBS_RESPONSE* a_pResponse  , 
        DWORD&          a_dwNumHosts ,
        DWORD           a_dwVip,
        DWORD           a_dwPort    
      );
    DWORD Enable
      ( 
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost     ,
        WLBS_RESPONSE* a_pResponse  , 
        DWORD&          a_dwNumHosts ,
        DWORD           a_dwVip,
        DWORD           a_dwPort    
      );
    DWORD Drain
      ( 
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost     ,
        WLBS_RESPONSE* a_pResponse  , 
        DWORD&          a_dwNumHosts ,
        DWORD           a_dwVip,
        DWORD           a_dwPort    
      );
    DWORD DrainStop
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Start
      (  
        DWORD           a_dwCluster  ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Stop
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Suspend
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Resume
      (  
        DWORD           a_dwCluster ,
        DWORD           a_dwHost    ,
        WLBS_RESPONSE* a_pResponse , 
        DWORD&          a_dwNumHosts
      );
    DWORD Query
      ( 
        CWlbsClusterWrapper* pCluster,
        DWORD           a_dwHost      ,
        WLBS_RESPONSE * a_pResponse   , 
        WLBS_RESPONSE * a_pComputerNameResponse,
        PDWORD          a_pdwNumHosts , 
        PDWORD          a_pdwHostMap 
      );

   DWORD WlbsQueryState
      (
        DWORD          cluster,
        DWORD          host,
        DWORD          operation,
        PNLB_OPTIONS   pOptions,
        PWLBS_RESPONSE pResponse,
        PDWORD         pcResponses
      );


protected:
    CWlbsControl m_WlbsControl;
};

#endif //CONTROLWRAPPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\makefile.inc ===
$(O)\wlbsprov.mof $(O)\wlbsprov.mfl: wlbsprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\wlbsprov.mof -MFL:$(O)\wlbsprov.mfl wlbsprov.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\ntrkcomm.h ===
#ifndef __provider_lib__
#define __provider_lib__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

class CWbemServices
{
protected:
	IWbemServices* m_pWbemServices;
public:
	CWbemServices(IWbemServices* );
	virtual ~CWbemServices();
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		BSTR, 
		BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) ;
		

};


class CImpersonatedProvider : public IWbemServices, public IWbemProviderInit 
{
protected:
    ULONG              m_cRef;         //Object reference count
    CWbemServices*  m_pNamespace;
 
public:
	CImpersonatedProvider(BSTR =NULL, BSTR =NULL , BSTR =NULL, IWbemContext* =NULL);
	virtual ~CImpersonatedProvider();

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
                    );

     //IWbemServices  

	  HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		const BSTR, 
		const BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) 
		{return WBEM_E_NOT_SUPPORTED;}

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(
		const BSTR,
		const BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*);
protected:
	virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
		/* [in] */ BSTR,	// Class,
		/* [in] */ long,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ BSTR ,	//ObjectPath,
        /* [in] */ long,	// lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;

	virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
		BSTR,
		BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ BSTR, // QueryLanguage,
        /* [in] */ BSTR, // Query,
        /* [in] */ long, // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,   // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR * //pResponseHandler
		) =0;
	virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
		/* [in] */ BSTR ObjectPath,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
		)=0;


	virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
		/* [in] */ IWbemClassObject __RPC_FAR *,	//pInst,
		/* [in] */ long	,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;



};

class CWbemInstanceMgr
{
	
protected:
	IWbemObjectSink* m_pSink;
	IWbemClassObject **m_ppInst;
	DWORD m_dwThreshHold;
	DWORD m_dwIndex;
public:

	CWbemInstanceMgr(
		IWbemObjectSink*,
		DWORD =50);
	virtual ~CWbemInstanceMgr();
	void Indicate(IWbemClassObject*);
	void SetStatus(
		LONG,
		HRESULT,
		BSTR, 
		IWbemClassObject*);
};



#endif // end of provlib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\genlex.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
	{
		if (!m_pSrcBuf)
			return 0;
		else
			return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
	}

    void Pushback(wchar_t)
	{
		if (m_pSrcBuf)
			--m_pSrcBuf;
	}

    /* Per Code coverate analysis, this function is never hit. However, this can not be removed since that will
       make it a non-abstract class */
    void Reset() { 
#ifdef DBG
         DebugBreak(); 
#endif
        /* m_pSrcBuf = m_pStart; */
    }
	void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class POLARITY CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\ntrkcomm.cpp ===
#include <ntrkcomm.h>
#include <objbase.h>


CWbemServices::CWbemServices(
    IWbemServices* pNamespace)
    :m_pWbemServices(NULL)
{
    m_pWbemServices = pNamespace;
    if(m_pWbemServices != NULL)
        m_pWbemServices->AddRef();
}

CWbemServices::~CWbemServices()
{
    if(m_pWbemServices != NULL)
        m_pWbemServices->Release();
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::CreateClassEnum(
  /* [in] */ BSTR Superclass,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
  ) 
{
  HRESULT hr = m_pWbemServices->CreateClassEnum(
      Superclass,
      lFlags,
      pCtx,
      ppEnum);

  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::CreateInstanceEnum(
  /* [in] */ BSTR Class,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
  HRESULT hr = m_pWbemServices->CreateInstanceEnum(
      Class,
      lFlags,
      pCtx,
      ppEnum);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::DeleteClass(
  /* [in] */ BSTR Class,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
  HRESULT hr = m_pWbemServices->DeleteClass(
      Class,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
  HRESULT hr = m_pWbemServices->DeleteInstance(
      ObjectPath,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::ExecMethod(
  BSTR strObjectPath, 
  BSTR MethodName, 
  long lFlags, 
  IWbemContext* pCtx,
    IWbemClassObject* pInParams,
  IWbemClassObject** ppOurParams, 
  IWbemCallResult** ppCallResult) 
{
  HRESULT hr = m_pWbemServices->ExecMethod(
      strObjectPath, 
      MethodName, 
      lFlags, 
      pCtx,
      pInParams,
      ppOurParams, 
      ppCallResult) ;
  return hr;  
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
  HRESULT hr = m_pWbemServices->ExecNotificationQuery(
      QueryLanguage,
      Query,
      lFlags,
      pCtx,
      ppEnum);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::ExecQuery(
  /* [in] */ BSTR QueryLanguage,
  /* [in] */ BSTR Query,
  /* [in] */ long lFlags,
  /* [in] */ IWbemContext __RPC_FAR *pCtx,
  /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
  HRESULT hr = m_pWbemServices->ExecQuery(
      QueryLanguage,
      Query,
      lFlags,
      pCtx,
      ppEnum);
  return hr;
}

HRESULT
CWbemServices::GetObject(
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    HRESULT hr = m_pWbemServices->GetObject(
        ObjectPath,
        lFlags,
        pCtx,
        ppObject,
        ppCallResult);
    return hr;
}
 
// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
  HRESULT hr = m_pWbemServices->PutClass(
      pObject,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

// CLD: 30 March 2001
// This appears to be dead code. Remove and test to see if this is true.
HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{ 

  HRESULT hr = m_pWbemServices->PutInstance(
      pInst,
      lFlags,
      pCtx,
      ppCallResult);
  return hr;
}

/*CImpersonatedProvider
*  Purpose: provide a general solution for impersonate client for 
*  Wbem providers.
*  USAGE:
*  Inherit from this class, and implement abstact virtual functions.
*  child class should implement function prefixed with "Do".
* ******************************************/
CImpersonatedProvider::CImpersonatedProvider(
    BSTR ObjectPath,
    BSTR User, 
    BSTR Password, 
    IWbemContext * pCtx)
    :m_cRef(0), m_pNamespace(NULL)
{

}
CImpersonatedProvider::~CImpersonatedProvider()
{
  if(m_pNamespace)
      delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}
STDMETHODIMP 
CImpersonatedProvider::QueryInterface(
    REFIID riid, 
    PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP 
CImpersonatedProvider::Initialize(
    LPWSTR pszUser, LONG lFlags,
    LPWSTR pszNamespace, LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;
    m_pNamespace = new CWbemServices(pNamespace); 
    if(m_pNamespace == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        lStatus = WBEM_E_FAILED;
    }
        
    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(lStatus,0);
    return hr;
}


HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoCreateInstanceEnumAsync(
                Class,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoDeleteInstanceAsync(
                ObjectPath,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::ExecMethodAsync(
    const BSTR strObjectPath,
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx,
    IWbemClassObject* pInParams,
    IWbemObjectSink* pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoExecMethodAsync(
                strObjectPath,
                MethodName,
                lFlags,
                pCtx,
                pInParams,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoExecQueryAsync(
                QueryLanguage,
                Query,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

HRESULT
CImpersonatedProvider::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoGetObjectAsync(
                ObjectPath,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;  
}

HRESULT
CImpersonatedProvider::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    HRESULT hr = CoImpersonateClient();
    if (S_OK == hr)
    {
        hr = DoPutInstanceAsync(
                pInst,
                lFlags,
                pCtx,
                pResponseHandler);
    }
    return hr;
}

// CWbemInstanceMgr
CWbemInstanceMgr::CWbemInstanceMgr(
    IWbemObjectSink* pHandler,
    DWORD dwSize)
    :m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
    m_pSink = pHandler;
    if(m_pSink != NULL)
        m_pSink->AddRef();
    m_dwThreshHold = dwSize;
    m_ppInst = new IWbemClassObject*[dwSize];
    if(m_ppInst != NULL)
    {
        for(DWORD i = 0; i < dwSize; i++)
            m_ppInst[i] = NULL;
    }
}
CWbemInstanceMgr::~CWbemInstanceMgr()
{
    if(m_ppInst != NULL)
    {
        if(m_dwIndex >0)
        {
            m_pSink->Indicate(
                m_dwIndex,
                m_ppInst);
        }

        for(DWORD i =0; i<m_dwIndex; i++)
        {
            if(m_ppInst[i] != NULL)
                (m_ppInst[i])->Release();
        }
        delete [] m_ppInst;
    }
    if(m_pSink != NULL)
        m_pSink->Release();

}

void
CWbemInstanceMgr::Indicate(IWbemClassObject* pInst)
{
    if(pInst == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    m_ppInst[m_dwIndex++] = pInst;
    pInst->AddRef();
    if(m_dwIndex == m_dwThreshHold)
    {

        SCODE  sc = m_pSink->Indicate(
            m_dwIndex,
            m_ppInst);
        if(sc != S_OK)
            throw sc;
        
        // reset state
        for(DWORD i=0; i< m_dwThreshHold; i++)
        {
            if(m_ppInst[i] != NULL)
                (m_ppInst[i])->Release();
            m_ppInst[i] = NULL;
        }
        m_dwIndex = 0;
    
    }
    return;
}

void
CWbemInstanceMgr::SetStatus(
    LONG lFlags,
    HRESULT hr,
    BSTR strParam,
    IWbemClassObject* pObjParam)
{
    m_pSink->SetStatus(
        lFlags,
        hr,
        strParam,
        pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\objpath.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <oleauto.h>
#include <genlex.h>
#include <opathlex.h>
#include "objpath.h"
#include <strsafe.h>

inline WCHAR* Macro_CloneLPWSTR(const WCHAR* x) 
{
    if (x == NULL)
    {
        return NULL;
    }

    WCHAR* pwszRet = new wchar_t[wcslen(x) + 1];
    if (pwszRet)
    {
        StringCchCopy(pwszRet, wcslen(x) + 1, x);
    }

    return pwszRet;
}

const DWORD ParsedObjectPath::m_scdwAllocNamespaceChunkSize = 2;
const DWORD ParsedObjectPath::m_scdwAllocKeysChunkSize = 2;

ParsedObjectPath::ParsedObjectPath()
{
    unsigned int i;
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 0;        // Initialize to 0, assuming m_paNamespaces allocation will fail
    m_paNamespaces = new LPWSTR[m_scdwAllocNamespaceChunkSize];

    if (NULL != m_paNamespaces)
    {
        m_dwAllocNamespaces = m_scdwAllocNamespaceChunkSize;
        for (i = 0; i < m_dwAllocNamespaces; i++)
            m_paNamespaces[i] = 0;
    }

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 0;              // Initialize to 0, assuming m_paKeys allocation will fail
    m_paKeys = new KeyRef *[m_scdwAllocKeysChunkSize];
    if (NULL != m_paKeys)
    {
        m_dwAllocKeys = m_scdwAllocKeysChunkSize;
        for (i = 0; i < m_dwAllocKeys; i++)
            m_paKeys[i] = 0;
    }
}

ParsedObjectPath::~ParsedObjectPath()
{
    delete m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        delete m_paNamespaces[dwIx];
    delete [] m_paNamespaces;
    delete m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        delete m_paKeys[dwIx];
    delete [] m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
        if (NULL == m_pClass)
            return FALSE;
    }

    return TRUE;
}

// ChrisDar 20 March 2001
// Keeping IsClass in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree except IsInstance, which is not called by any method.
BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

// ChrisDar 20 March 2001
// Keeping IsInstance in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree except IsInstance, which is not called by any method.
BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

// ChrisDar 20 March 2001
// Keeping IsObject in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree except IsInstance, which is not called by any method.
BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if (NULL == wszNamespace || 0 == *wszNamespace)
        return FALSE;

    if(0 == m_dwAllocNamespaces || m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        // Here if array is full or allocation failed previously

        DWORD dwNewAllocNamespaces = 0;
        if (0 == m_dwAllocNamespaces)
        {
            dwNewAllocNamespaces = m_scdwAllocNamespaceChunkSize;
        }
        else
        {
            dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        }

        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];

        if (paNewNamespaces == NULL)
        {
            return FALSE;
        }

        unsigned int i = 0;
        // Initialize the array to NULLs
        for (i = 0; i < dwNewAllocNamespaces; i++)
            paNewNamespaces[i] = 0;

        if (NULL != m_paNamespaces)
        {
            // Here only if we previously had an allocation success

            memcpy(paNewNamespaces, m_paNamespaces,
                   sizeof(LPWSTR) * m_dwNumNamespaces);
            delete [] m_paNamespaces;
        }
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces] = Macro_CloneLPWSTR(wszNamespace);
    if (NULL == m_paNamespaces[m_dwNumNamespaces])
        return FALSE;

    m_dwNumNamespaces++;

    return TRUE;
}

// ChrisDar 20 March 2001
// Keeping AddKeyRefEx in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree.
// ChrisDar 22 March 2001
// This really needs to be modified to return more info than pass/fail. Should reflect enums in CObjectPathParser
BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    // ChrisDar 20 March 2001
    // Notes:
    // 1. wszKeyName is allowed to be NULL. It acts as a signal to remove all existing keys,
    //    then add an unnamed key with this value. It is unclear why removing all keys is required.
    //    Perhaps this supports only one key when the key is unnamed...
    // 2. This code is riddled with places where memory allocations could screw up state. Some are
    //    "new"s while there are also calls to VariantCopy.
    // 3. VariantClear and VariantCopy have return values and they are not being checked.
    // 4. AddKeyRef can fail but it being called without checking the return value.
    // 5. Apparently pvValue must be non-NULL, but it isn't being validated before being dereferenced.
    // 6. bStatus is for the return value but it is never modified. Changed to return TRUE;.

    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        if (VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue ) == S_OK)
        {
            m_dwNumKeys = 1;
        }
        else
        {
            bStatus = FALSE;
            m_dwNumKeys = 0;
        }
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                if(m_paKeys [ dwIndex ]->m_pName != NULL)
                {
                    StringCchCopy ( m_paKeys [ dwIndex ]->m_pName , wcslen ( wszKeyName ) + 1, wszKeyName ) ;
                }
                else
                {
                    bStatus = FALSE;
                }
            }

            if (VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) != S_OK)
            {
                bStatus = FALSE;
            }

            if (VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) != S_OK)
            {
                bStatus = FALSE;
            }
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;

                if(m_paKeys [ 0 ]->m_pName != NULL)
                {
                    StringCchCopy ( m_paKeys [ 0 ]->m_pName , wcslen ( wszKeyName ) + 1, wszKeyName ) ;
                }
                else
                {
                    bStatus = FALSE;
                }

                if ( VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) == S_OK)
                {
                    m_dwNumKeys = 1 ;
                }
                else
                {
                    bStatus = FALSE;
                    m_dwNumKeys = 0 ;
                }
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_dwAllocKeys = 0;              // Initialize to 0, assuming m_paKeys allocation will fail
    m_paKeys = new KeyRef *[m_scdwAllocKeysChunkSize];

    if (NULL != m_paKeys)
    {
        m_dwAllocKeys = m_scdwAllocKeysChunkSize;
        for (unsigned int i = 0; i < m_dwAllocKeys; i++)
            m_paKeys[i] = 0;
    }
}

// ChrisDar 22 March 2001
// This really needs to be modified to return more info than pass/fail. Should reflect enums in CObjectPathParser
BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    // Unnamed keys are allowed, i.e., NULL == wszKeyName. But pvValue must be valid.
    if (NULL == pvValue)
        return FALSE;

    if(0 == m_dwAllocKeys || m_dwNumKeys == m_dwAllocKeys)
    {
        if (!IncreaseNumAllocKeys())
            return FALSE;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    if (NULL == m_paKeys[m_dwNumKeys])
        return FALSE;

    m_dwNumKeys++;
    return TRUE;
}

// ChrisDar 22 March 2001
// This really needs to be modified to return more info than pass/fail. Should reflect enums in CObjectPathParser
BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if (NULL == pAcquireRef)
        return FALSE;

    if(0 == m_dwAllocKeys || m_dwNumKeys == m_dwAllocKeys)
    {
        if (!IncreaseNumAllocKeys())
            return FALSE;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    // An unnamed key (wszKeyName is NULL) is legal, but pvValue can't be NULL.
    if (NULL == pvValue)
    {
        // Our input argument is invalid. What do we do? For now, throw a generic WBEM exception
        throw _com_error(WBEM_E_FAILED);
    }

    m_pName = Macro_CloneLPWSTR(wszKeyName);
    if (NULL != wszKeyName && NULL == m_pName)
    {
        // Memory allocation failed. We can't fail the call since we are in a constructor, so throw exception.
        throw _com_error(WBEM_E_OUT_OF_MEMORY);
    }

    VariantInit(&m_vValue);

    HRESULT hr = VariantCopy(&m_vValue, (VARIANT*)pvValue);
    if (S_OK != hr)
    {
        // What do we do? Throw WBEM exception for now.
        WBEMSTATUS ws = WBEM_E_FAILED;
        if (E_OUTOFMEMORY == hr)
            ws = WBEM_E_OUT_OF_MEMORY;
        throw _com_error(ws);
    }
}

KeyRef::~KeyRef()
{
    delete m_pName;
    // No check of return value here since we are destroying the object.
    VariantClear(&m_vValue);
}

int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    // ChrisDar 20 March 2001
    // I AM CONCERNED ABOUT THE "DELETE_ME" IN THE ARG OF CALL. #define'd IN OBJPATH.H TO "". REMOVE IT?
    // This is a confusing method. pInput must be a valid pointer. pwszPath MUST be a valid pointer initialized to NULL.
    // This method's job is to allocate a path as a string and pass it back to the caller
    // in pwszPath. It needs pInput to determine the path.

    if (NULL == pInput || pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    if (NULL == wszPath)
        return CObjectPathParser::OutOfMemory;

    StringCchCopy(wszPath, nSpace, pInput->m_pClass);

    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                StringCchCat(wszPath, nSpace, L".");
        }
        else
        {
            StringCchCat(wszPath, nSpace, L",");
        }
        if(pKey->m_pName)
            StringCchCat(wszPath, nSpace, pKey->m_pName);
        StringCchCat(wszPath, nSpace, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            StringCchCat(wszPath, nSpace, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    StringCchCat(wszPath, nSpace, L"\\");
                }
                str[0] = *pwc;
                StringCchCat(wszPath, nSpace, str);
                pwc++;
            }

            StringCchCat(wszPath, nSpace, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            StringCbPrintf(wszTemp, sizeof(wszTemp), L"%d", V_I4(&pKey->m_vValue));
            StringCchCat(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            StringCbPrintf(wszTemp, sizeof(wszTemp), L"%u", V_UI4(&pKey->m_vValue));
            StringCchCat(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            StringCbPrintf(wszTemp, sizeof(wszTemp), L"%hd", V_I2(&pKey->m_vValue));
            StringCchCat(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            StringCbPrintf(wszTemp, sizeof(wszTemp), L"%hu", V_UI2(&pKey->m_vValue));
            StringCchCat(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            StringCbPrintf(wszTemp, sizeof(wszTemp), L"%d", V_I1(&pKey->m_vValue));
            StringCchCat(wszPath, nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            StringCbPrintf(wszTemp, sizeof(wszTemp), L"%u", V_UI1(&pKey->m_vValue));
            StringCchCat(wszPath, nSpace, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.
    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        StringCchCat(wszPath, nSpace, L"=@");

    *pwszPath = wszPath;

    return CObjectPathParser::NoError;
}

// ChrisDar 20 March 2001
// Keeping GetRelativePath in code for now, but it appears to be dead code. It is not called
// by any method in the wlbs code tree.
LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    // ChrisDar 20 March 2001
    // wszFullPath is no being validated before use.
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}

void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
	m_pLexer = 0;
    delete m_pInitialIdent;
	m_pInitialIdent = 0;
    delete m_pTmpKeyRef;
	m_pTmpKeyRef = 0;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    // ChrisDar 20 March 2001
    // This method creates a ParsedObjectPath (if possible) and passes it back to the user by pointer.
    // It also ensures that the pointer is not retained within the class. It is the user's responsibiliy
    // to delete the memory. It is also the user's responsibility to ensure that pOutput is a valid
    // pointer that does not point to an existing instances of a ParsedObjectPath*. Otherwise, this method
    // could cause a memory leak, since we overwrite the pointer.
    //
    // This is an extremely dangerous way to use a private data member. Other methods use m_pOutput and
    // are currently only called by this method or a method that only this one calls. Though the methods
    // are private, anyone maintaining the code needs to know not to use this variable or these methods
    // because m_pOutput is valid only so long as this method is executing... I have changed this so that
    // m_pOutput is passed among the private methods that need it. It is cumbersome but safer.

    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================
    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return CObjectPathParser::InvalidParameter;

    // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;
    if (NULL == m_pOutput)
        return CObjectPathParser::OutOfMemory;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================
            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                m_pOutput = 0;
                return CObjectPathParser::SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];
                if (NULL == m_pOutput->m_pServer)
                {
                    delete m_pOutput;
                    m_pOutput = 0;
                    return CObjectPathParser::OutOfMemory;
                }

                StringCchCopy(m_pOutput->m_pServer, wcslen(pwcStart)+1, pwcStart);
                *pOutput = m_pOutput;
                m_pOutput = 0;

                return CObjectPathParser::NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            m_pOutput = 0;
            return CObjectPathParser::SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        if (m_pOutput->m_pServer == NULL)
        {
            delete m_pOutput;
            m_pOutput = 0;
            return CObjectPathParser::OutOfMemory;
        }

        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================
    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);
    if (m_pLexer == NULL)
    {
        delete m_pOutput;
        m_pOutput = 0;
        return CObjectPathParser::OutOfMemory;
    }

    // Go.
    // ===
    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        m_pOutput = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        m_pOutput = 0;
        return CObjectPathParser::SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            m_pOutput = 0;
            return CObjectPathParser::SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            if (NULL == m_pOutput->m_pServer)
            {
                delete m_pOutput;
                m_pOutput = 0;
                return CObjectPathParser::OutOfMemory;
            }

            StringCchCopy(m_pOutput->m_pServer, 2, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================
    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }

    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return CObjectPathParser::NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}

void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return CObjectPathParser::SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (NULL == m_pInitialIdent)
            return CObjectPathParser::OutOfMemory;

        if (!NextToken())
        {
            delete m_pInitialIdent;
			m_pInitialIdent = 0;
            return CObjectPathParser::SyntaxError;
        }

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================
        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        /* Per code coverage analysis, the functions called in this block
           are not hit, hence commenting out this block */
        ASSERT(FALSE);
        /*
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return objref();
        */
        
    }

    // If here, we had a bad starter token.
    // ====================================
    return CObjectPathParser::SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================
        return CObjectPathParser::SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return CObjectPathParser::NoError;

    return CObjectPathParser::SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return CObjectPathParser::NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return CObjectPathParser::SyntaxError;
    if (!NextToken())
        return CObjectPathParser::SyntaxError;
    return objref();
}

//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    int iStatus = CObjectPathParser::NoError;

    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        /* Per code coverage analysis, the functions called in this block
           are not hit, hence commenting out this block */
        ASSERT(FALSE);
        /*
        iStatus = ident_becomes_ns();
        if (CObjectPathParser::NoError != iStatus)
            return iStatus;

        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return objref();
        */
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        /* Per code coverage analysis, the functions called in this block
           are not hit, hence commenting out this block */
        ASSERT(FALSE);
        /*
        iStatus = ident_becomes_ns();
        if (CObjectPathParser::NoError != iStatus)
            return iStatus;

        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return CObjectPathParser::NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return CObjectPathParser::SyntaxError;
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return objref();
        */
    }

    // Else
    // ====
    iStatus = ident_becomes_class();
    if (CObjectPathParser::NoError != iStatus)
        return iStatus;

    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return CObjectPathParser::SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (NULL == m_pOutput->m_pClass)
        return CObjectPathParser::OutOfMemory;

    // On failure here, don't free memory allocated by clone above. The ::Parse method takes care of this.
    if (!NextToken())
        return CObjectPathParser::SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        if (!m_pOutput->AddNamespace(m_pLexer->GetTokenText()))
            return CObjectPathParser::OutOfMemory;

        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return ns_list_rest();
    }

    return CObjectPathParser::SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
// Per Code coverate analysis, this function is never hit 
/*
int CObjectPathParser::ident_becomes_ns()
{
    int iStatus = CObjectPathParser::NoError;

    if(!m_pOutput->AddNamespace(m_pInitialIdent))
        iStatus = CObjectPathParser::OutOfMemory;

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return iStatus;
}
*/

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;

    if (NULL == m_pOutput->m_pClass)
        return CObjectPathParser::OutOfMemory;

    return CObjectPathParser::NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.
        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return CObjectPathParser::SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return CObjectPathParser::NoError;
        }

        m_pTmpKeyRef = new KeyRef;
        if (NULL == m_pTmpKeyRef)
            return CObjectPathParser::OutOfMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        if(!m_pOutput->AddKeyRef(m_pTmpKeyRef))
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return CObjectPathParser::OutOfMemory;
        }
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return keyref_list();
    }

    return CObjectPathParser::NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return ns_list();
    }
    return CObjectPathParser::NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        wchar_t *pTokenText = m_pLexer->GetTokenText();
        if (NULL == pTokenText)
            return CObjectPathParser::SyntaxError;
        BSTR bstr = SysAllocString(pTokenText);
        if (NULL == bstr)
            return CObjectPathParser::OutOfMemory;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = bstr;
        // Keeping the original code commented out for now. Replacement is complicated
        // because several failures could have occured and those would be obscured in the
        // previous version.
//      V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
//      if (NULL == pKeyRef->m_vValue)
//          return CObjectPathParser::OutOfMemory;
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        WCHAR buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return CObjectPathParser::SyntaxError;
        StringCbCopy(buf, sizeof(buf), m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = wcstol(buf, NULL, 10);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        WCHAR buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return CObjectPathParser::SyntaxError;
        StringCbCopy(buf, sizeof(buf), m_pLexer->GetTokenText());
        long l;
        if (swscanf(buf, L"%x", &l) == EOF)
        {
            l = 0;
        }
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return CObjectPathParser::SyntaxError;
    }
    else return CObjectPathParser::SyntaxError;

    if (!NextToken())
        return CObjectPathParser::SyntaxError;

    return CObjectPathParser::NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;
    if (m_pTmpKeyRef == NULL)
    {
        return CObjectPathParser::OutOfMemory;
    }

    int nRes = propname();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (!m_pOutput->AddKeyRef(m_pTmpKeyRef))
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::OutOfMemory;
    }
    m_pTmpKeyRef = 0;

    return CObjectPathParser::NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return CObjectPathParser::SyntaxError;
        return keyref_list();
    }

    return CObjectPathParser::NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return CObjectPathParser::SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (NULL == m_pTmpKeyRef->m_pName)
        return CObjectPathParser::OutOfMemory;

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return CObjectPathParser::SyntaxError;
    }

    return CObjectPathParser::NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];

        if (pTmp)
            StringCchCopy(pTmp, wcslen(m_pClass) + 1, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================
    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    if (NULL == pRetVal)
        return NULL;

    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================
    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            StringCchCat(pRetVal, nSpace, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                StringCchCat(pRetVal, nSpace, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                StringCbPrintf(Tmp, sizeof(Tmp), L"%d", nVal);
                StringCchCat(pRetVal, nSpace, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                StringCbPrintf(Tmp, sizeof(Tmp), L"%d", nVal);
                StringCchCat(pRetVal, nSpace, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                StringCbPrintf(Tmp, sizeof(Tmp), L"%d", nVal);
                StringCchCat(pRetVal, nSpace, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                StringCbPrintf(Tmp, sizeof(Tmp), L"%d", (nVal?1:0));
                StringCchCat(pRetVal, nSpace, Tmp);
                break;

            default:
                StringCchCat(pRetVal, nSpace, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            StringCchCopy(pRetVal, nSpace, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================
    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============
    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if (wszOut == NULL)
        return NULL;

    *wszOut = 0;

    // Output
    // ======
    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) StringCchCat(wszOut, nSpace + 1, L"\\");
        StringCchCat(wszOut, nSpace + 1, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================
    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============
    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if (NULL == wszOut)
        return NULL;

    *wszOut = 0;

    // Output
    // ======
    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) StringCchCat(wszOut, nSpace + 1, L"\\");
        StringCchCat(wszOut, nSpace + 1, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IncreaseNumAllocKeys()
{
    if(0 == m_dwAllocKeys || m_dwNumKeys == m_dwAllocKeys)
    {
        // Here if array is full or allocation failed previously
        DWORD dwNewAllocKeys = 0;
        if (0 == m_dwAllocKeys)
        {
            dwNewAllocKeys = m_scdwAllocKeysChunkSize;
        }
        else
        {
            dwNewAllocKeys = m_dwAllocKeys * 2;
        }

        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (paNewKeys == NULL)
        {
            return FALSE;
        }

        unsigned int i = 0;
        // Initialize the new array to NULLs
        for (i = 0; i < dwNewAllocKeys; i++)
            paNewKeys[i] = 0;

        if (NULL != m_paKeys)
        {
            // Here only if we previously had an allocation success
            memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwNumKeys);
            delete [] m_paKeys;
        }
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\objpath.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <comdef.h>
#include <wbemprov.h>
#include <opathlex.h>

#define DELETE_ME

#ifdef DBG
#define ASSERT(x) if(!(x)) DebugBreak();
#else
#define ASSERT(x)
#endif

struct KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

struct ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    static const DWORD  m_scdwAllocNamespaceChunkSize;    // Grow m_paNamespaces in units of this quantity
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    static const DWORD  m_scdwAllocKeysChunkSize;         // Grow m_paKeys in units of this quantity
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
private:
    BOOL IncreaseNumAllocKeys();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter, OutOfMemory };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
    void Free( LPWSTR wszUnparsedPath );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\utils.h ===
void AddressToString( DWORD a_dwAddress, wstring& a_szIPAddress );

void WlbsFormatMessageWrapper
  (
    DWORD        a_dwError, 
    WLBS_COMMAND a_Command, 
    BOOL         a_bClusterWide, 
    wstring&     a_wstrMessage
  );

BOOL ClusterStatusOK(DWORD a_dwStatus);

BOOL Check_Load_Unload_Driver_Privilege();


////////////////////////////////////////////////////////////////////////////////
//
// class CErrorWlbsControl
//
// Purpose: This encapsulates all WLBS errors and descriptions.
//
//
////////////////////////////////////////////////////////////////////////////////
class CErrorWlbsControl
{
private:

  CErrorWlbsControl();
public:
	_bstr_t Description();
  DWORD   Error();

  CErrorWlbsControl( DWORD        a_dwError, 
                     WLBS_COMMAND a_CmdCommand, 
                     BOOL         a_bAllClusterCall = FALSE );

  virtual ~CErrorWlbsControl() {}
  
private:
  wstring   m_wstrDescription;
  DWORD     m_dwError;

};

inline _bstr_t CErrorWlbsControl::Description()
{
  return _bstr_t( m_wstrDescription.c_str() );
}

inline DWORD CErrorWlbsControl::Error()
{
  return m_dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_clusclussetting.h ===
#ifndef _NODENODESETTING_INCLUDED_
#define _NODENODESETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_ClusClusSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF ClusterSetting class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_ClusClusSetting : public CWlbs_Root
{
public:
  CWLBS_ClusClusSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);
  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0, IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

private:

  //methods
  void FillWbemInstance  (CWlbsClusterWrapper* pCluster,
            IWbemClassObject* a_pWbemInstance );

  void FindInstance( IWbemClassObject**      a_ppWbemInstance );

};

#endif //_NODENODESETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\utils.cpp ===
#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "debug.h"
#include "utils.h"

#include <strsafe.h>

#include "utils.tmh"


////////////////////////////////////////////////////////////////////////////////
//
// CErrorWlbsControl::CErrorWlbsControl
//
// Purpose: This object is ultimately caught and used to send WLBS error codes
//          back to the user via an __ExtendedStatus object. Strings are not
//          sent back in release mode due to localization concerns.
//
////////////////////////////////////////////////////////////////////////////////
CErrorWlbsControl::CErrorWlbsControl
  ( 
    DWORD         a_dwError, 
    WLBS_COMMAND  a_CmdCommand,
    BOOL          a_bAllClusterCall
  )
{
#ifdef DBG
    static char* pszWlbsCommand[] =
    {
    "WlbsAddPortRule",
    "WlbsAddressToName",
    "WlbsAddressToString",
    "WlbsAdjust",
    "WlbsCommitChanges",
    "WlbsDeletePortRule",
    "WlbsDestinationSet",
    "WlbsDisable",
    "WlbsDrain",
    "WlbsDrainStop",
    "WlbsEnable",
    "WlbsFormatMessage",
    "WlbsGetEffectiveVersion",
    "WlbsGetNumPortRules",
    "WlbsEnumPortRules",
    "WlbsGetPortRule",
    "WlbsInit",
    "WlbsPasswordSet",
    "WlbsPortSet",
    "WlbsQuery",
    "WlbsReadReg",
    "WlbsResolve",
    "WlbsResume",
    "WlbsSetDefaults",
    "WlbsSetRemotePassword",
    "WlbsStart",
    "WlbsStop",
    "WlbsSuspend",
    "WlbsTimeoutSet",
    "WlbsWriteReg",
    "WlbsQueryPortState"
    };

    char buf[512];

    if (a_CmdCommand <= CmdWlbsWriteReg) 
    {
        if (a_CmdCommand != CmdWlbsQuery || a_dwError != WLBS_TIMEOUT)
        {
            StringCbPrintfA(buf, sizeof(buf), "wlbsprov: %s failed, AllCluster = %d, error = %d\n", 
            pszWlbsCommand[a_CmdCommand], (int)a_bAllClusterCall, a_dwError);    
        }
    }
    else
    {
        StringCbPrintfA(buf, sizeof(buf), "wlbsprov: %d failed, AllCluster = %d, error = %d\n", 
        a_CmdCommand, (int)a_bAllClusterCall, a_dwError);    
    }

    OutputDebugStringA(buf);

#endif

    WlbsFormatMessageWrapper( a_dwError, 
                                   a_CmdCommand, 
                                   a_bAllClusterCall, 
                                   m_wstrDescription );

    m_dwError = a_dwError;

}


////////////////////////////////////////////////////////////////////////////////
//
// AddressToString
//
// Purpose: Converts a DWORD address to a wstring in dotted notation. This 
//          function wraps the WlbsAddressToString function.
//
//
////////////////////////////////////////////////////////////////////////////////
void AddressToString( DWORD a_dwAddress, wstring& a_szIPAddress )
{
  DWORD dwLenIPAddress = 32;

  WCHAR *szIPAddress = new WCHAR[dwLenIPAddress];

  if( !szIPAddress )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  try {
    for( short nTryTwice = 2; nTryTwice > 0; nTryTwice--) {

        if( ::WlbsAddressToString( a_dwAddress, szIPAddress, &dwLenIPAddress ) )
        break;

      delete [] szIPAddress;
      szIPAddress = new WCHAR[dwLenIPAddress];

      if( !szIPAddress )
        throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    if( !nTryTwice )
      throw _com_error( WBEM_E_FAILED );

    a_szIPAddress = szIPAddress;

    if ( szIPAddress ) {
      delete [] szIPAddress;
      szIPAddress = NULL;
    }

  }

  catch(...) {

    if ( szIPAddress )
      delete [] szIPAddress;

    throw;

  }
}



////////////////////////////////////////////////////////////////////////////////
//
// CWmiWlbsCluster::FormatMessage
//
// Purpose: Obtains a descriptive string associated with a WLBS return value.
//
////////////////////////////////////////////////////////////////////////////////
void WlbsFormatMessageWrapper
  (
    DWORD        a_dwError, 
    WLBS_COMMAND a_Command, 
    BOOL         a_bClusterWide, 
    wstring&     a_wstrMessage
  )
{
  DWORD dwBuffSize = 255;
  TCHAR* pszMessageBuff = new WCHAR[dwBuffSize];

  if( !pszMessageBuff )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  try {

    for( short nTryTwice = 2; nTryTwice > 0; nTryTwice-- ) {

    if( WlbsFormatMessage( a_dwError, 
                           a_Command, 
                           a_bClusterWide, 
                           pszMessageBuff, 
                           &dwBuffSize)
      ) break;

      delete [] pszMessageBuff;
      pszMessageBuff = new WCHAR[dwBuffSize];

      if( !pszMessageBuff )
        throw _com_error( WBEM_E_OUT_OF_MEMORY );

    }

    if( !nTryTwice )
      throw _com_error( WBEM_E_FAILED );

    a_wstrMessage = pszMessageBuff;
    delete [] pszMessageBuff;

  } catch (...) {

    if( pszMessageBuff )
      delete [] pszMessageBuff;

    throw;
  }

}


////////////////////////////////////////////////////////////////////////////////
//
// ClusterStatusOK
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
BOOL ClusterStatusOK(DWORD a_dwStatus)
{
  if( a_dwStatus > 0 && a_dwStatus <= WLBS_MAX_HOSTS )
    return TRUE;

  switch( a_dwStatus ) {
    case WLBS_SUSPENDED:
    case WLBS_STOPPED:
    case WLBS_DRAINING:
    case WLBS_CONVERGING:
    case WLBS_CONVERGED:
      return TRUE;
      break;
    default:
      return FALSE;
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// Check_Load_Unload_Driver_Privilege
//
// Purpose: This function checks if the SE_LOAD_DRIVER_NAME (= "SeLoadDriverPrivilege")
//          is enabled in the impersonation access token. Ofcourse, this function 
//          must be called AFTER impersonating the client. 
//
////////////////////////////////////////////////////////////////////////////////

BOOL Check_Load_Unload_Driver_Privilege() 
{
    PRIVILEGE_SET   PrivilegeSet;
    LUID   Luid;
    BOOL   bResult = FALSE;
    HANDLE TokenHandle = NULL;

    TRACE_INFO("->%!FUNC!");

    // Look up the LUID for "SeLoadDriverPrivilege"
    if (!LookupPrivilegeValue(NULL,                // lookup privilege on local system
                              SE_LOAD_DRIVER_NAME, // "SeLoadDriverPrivilege" : Load and unload device drivers
                              &Luid))              // receives LUID of privilege
    {
        TRACE_CRIT("%!FUNC! LookupPrivilegeValue error: %u", GetLastError()); 
        TRACE_INFO("<-%!FUNC! Returning FALSE");
        return FALSE; 
    }

    //
    // Get a handle to the impersonation access token with TOKEN_QUERY right.
    //
    // Note: If this thread is NOT impersonating, then, the following call
    //       will fail with ERROR_NO_TOKEN.
    //
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_QUERY, 
                         FALSE, // Use the credentials of the client that is being impersonated
                         &TokenHandle))
    {
        TRACE_CRIT("%!FUNC! OpenThreadToken error: %u", GetLastError()); 
        TRACE_INFO("<-%!FUNC! Returning FALSE");
        return FALSE; 
    }

    PrivilegeSet.PrivilegeCount = 1;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = Luid;
    PrivilegeSet.Privilege[0].Attributes = 0;

    if (!PrivilegeCheck(TokenHandle, &PrivilegeSet, &bResult)) 
    {
        bResult = FALSE;
        TRACE_CRIT("%!FUNC! PrivilegeCheck error: %u", GetLastError()); 
    }

    CloseHandle(TokenHandle);

    TRACE_INFO(L"<-%!FUNC! Returning %ls", bResult ? L"TRUE" : L"FALSE");
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_clusclussetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_ClusClusSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::CWLBS_ClusClusSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ClusClusSetting::CWLBS_ClusClusSetting(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_ClusClusSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_ClusClusSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::GetInstance
//
// Purpose:
//
// TODO: Implement later
//       Not critical
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusClusSetting::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    a_lFlags,
    IWbemContext*           a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance = NULL;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
/*
    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }
*/
    return WBEM_S_NO_ERROR;
  }

  catch(...) {

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    throw;

  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::EnumInstances
//
// Purpose: This verifies cluster existence and constructs associator.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusClusSetting::EnumInstances
  ( 
    BSTR             a_bstrClass,
    long             a_lFlags, 
    IWbemContext*    a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance    = NULL;
  HRESULT hRes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i < dwNumClusters; i++)
    {
        //spawn an instance of the associator
        SpawnInstance(MOF_CLUSCLUSSETTING::szName, &pWlbsInstance );

        FillWbemInstance(ppCluster[i], pWlbsInstance);

        //send the results back to WinMgMt
        hRes= m_pResponseHandler->Indicate( 1, &pWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( pWlbsInstance )
          pWlbsInstance->Release();
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch( _com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusClusSetting::FillWbemInstance
//
// Purpose: This constructs the wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ClusClusSetting::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance
  )
{
  namespace CCS = MOF_CLUSCLUSSETTING;

  ASSERT( a_pWbemInstance );

  ParsedObjectPath ClusSetPath;
  ParsedObjectPath ClusterPath;
  LPWSTR           szClusSetPath = NULL;
  LPWSTR           szClusterPath = NULL;

  try {

  //set the names of the classes
  if( !ClusSetPath.SetClassName( MOF_CLUSTERSETTING::szName ) )
    throw _com_error( WBEM_E_FAILED );

  if( !ClusterPath.SetClassName( MOF_CLUSTER::szName ) )
    throw _com_error( WBEM_E_FAILED );

  //Get the cluster name

  DWORD   dwClusterIpOrIndex = pCluster->GetClusterIpOrIndex(g_pWlbsControl);

  wstring wstrHostName;
  ConstructHostName( wstrHostName,  dwClusterIpOrIndex, pCluster->GetHostID());

  _variant_t vString;


  //set the keys for the node and cluster
  vString = wstrHostName.c_str();
  if( !ClusSetPath.AddKeyRef( MOF_CLUSTERSETTING::pProperties[MOF_CLUSTERSETTING::NAME],
         &vString ) )
    throw _com_error( WBEM_E_FAILED );

  wstring wstrClusterIndex;
  AddressToString( dwClusterIpOrIndex, wstrClusterIndex );
  vString = wstrClusterIndex.c_str();
  if( !ClusterPath.AddKeyRef( MOF_CLUSTER::pProperties[MOF_CLUSTER::NAME],
         &vString ) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&ClusSetPath, &szClusSetPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&ClusterPath, &szClusterPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node reference
  vString = szClusSetPath;
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( CCS::pProperties[CCS::CLUSSET] ),
      0,
      &vString,
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Cluster reference
  vString = szClusterPath;
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( CCS::pProperties[CCS::CLUSTER] ),
      0,
      &vString,
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  ClusterPath.ClearKeys();
  ClusSetPath.ClearKeys();

  if( szClusSetPath )
    delete (szClusSetPath);

  if( szClusterPath )
    delete (szClusterPath);

  } catch (...) {

    ClusterPath.ClearKeys();
    ClusSetPath.ClearKeys();

    if( szClusSetPath )
      delete (szClusSetPath);

    if( szClusterPath )
      delete (szClusterPath);

    throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_cluster.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Cluster.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "param.h"
#include "wlbsutil.h"
#include "wlbs_cluster.tmh" // for event tracing

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::CWLBS_Cluster
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_Cluster::CWLBS_Cluster( CWbemServices*   a_pNameSpace, 
                              IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_Cluster::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_Cluster( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::GetInstance
//
// Purpose: This function retrieves an instance of a MOF Cluster class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Cluster::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /*a_lFlags*/,
    IWbemContext*           a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    //get the name key property and convert to wstring
    //throws _com_error

    const WCHAR* wstrRequestedClusterName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwNumHosts  = 0;

    //check to see if the requested cluster name matches the configured value
    // The name does not have host id in it.

    DWORD dwClusterIpOrIndex = IpAddressFromAbcdWsz(wstrRequestedClusterName);
    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);

    if (pCluster == NULL)
    {
        TRACE_CRIT("%!FUNC! CWlbsControlWrapper::GetClusterFromIpOrIndex() returned NULL for dwClusterIpOrIndex = 0x%x, Throwing com_error WBEM_E_NOT_FOUND", dwClusterIpOrIndex);
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    BOOL bGetStatus = TRUE;

    //this is an optimization check
    //if WinMgMt is calling this prior to an Exec call, then this
    //routine will not perform a cluster query call since the
    //status of the cluster is not required in this case
    if (a_pIContex) {

        VARIANT v;

        VariantInit( &v );

        hRes = a_pIContex->GetValue(L"__GET_EXT_KEYS_ONLY", 0, &v);

        if ( FAILED( hRes ) ) {
            TRACE_CRIT("%!FUNC! IWbemContext::GetValue() returned error : 0x%x, Throwing com_error WBEM_E_FAILED", hRes);
            throw _com_error( WBEM_E_FAILED );
        }

        bGetStatus = FALSE;

        // CLD: Need to check return code for error
        if (S_OK != VariantClear( &v ))
        {
            TRACE_CRIT("%!FUNC! VariantClear() returned error, Throwing com_error WBEM_E_FAILED");
            throw _com_error( WBEM_E_FAILED );
        }
    }

    //call the API query function
    //dwStatus contains a cluster-wide status number
    DWORD   dwStatus = 0;
    if ( bGetStatus ) 
    {
      dwStatus = g_pWlbsControl->Query( pCluster    ,
                                            WLBS_ALL_HOSTS , 
                                            NULL           , 
                                            NULL           , 
                                            &dwNumHosts    , 
                                            NULL );

      if( !ClusterStatusOK( dwStatus ) )
      {
          TRACE_CRIT("%!FUNC! CWlbsControlWrapper::Query() returned error : 0x%x, Throwing com_error WBEM_E_FAILED",dwStatus);
          throw _com_error( WBEM_E_FAILED );
      }
    }
    
    //get the Wbem class instance
    SpawnInstance( MOF_CLUSTER::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance( pWlbsInstance, pCluster, dwStatus );
    
    //Send results to Wbem
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }
  catch(CErrorWlbsControl Err) {

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }
    
    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::EnumInstances
//
// Purpose: This function determines if the current host is in the cluster 
//          and then obtains the configuration information for the cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Cluster::EnumInstances
  ( 
    BSTR             /*a_bstrClass*/,
    long             /*a_lFlags*/, 
    IWbemContext*    a_pIContex
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      TRACE_CRIT("%!FUNC! CWlbsControlWrapper::EnumClusters() returned no clusters, Throwing com_error WBEM_E_NOT_FOUND exception");
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    BOOL bGetStatus = TRUE;

    //this is an optimization check
    //if WinMgMt is calling this prior to an Exec call, then this
    //routine will not perform a cluster query call since the
    //status of the cluster is not required in this case
      if (a_pIContex)   {

      VARIANT v;

      VariantInit( &v );

        hRes = a_pIContex->GetValue(L"__GET_EXT_KEYS_ONLY", 0, &v);

        if ( FAILED( hRes ) ) {
            TRACE_CRIT("%!FUNC! IWbemContext::GetValue() returned error : 0x%x, Throwing com_error WBEM_E_FAILED", hRes);
            throw _com_error( WBEM_E_FAILED );
        }

      bGetStatus = FALSE;

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &v ))
      {
          TRACE_CRIT("%!FUNC! VariantClear() returned error, Throwing com_error WBEM_E_FAILED");
          throw _com_error( WBEM_E_FAILED );
      }
    }
    
    for (DWORD i=0; i<dwNumClusters; i++)
    {

        //call the API query function
        //dwStatus contains a cluster-wide status number
        DWORD   dwStatus = 0;
        if ( bGetStatus ) 
        {
          DWORD dwNumHosts = 0;

          try {
              dwStatus = g_pWlbsControl->Query( ppCluster[i],
                                                WLBS_ALL_HOSTS , 
                                                NULL           , 
                                                NULL           , 
                                                &dwNumHosts    , 
                                                NULL);
          } catch (CErrorWlbsControl Err)
          {
            //
            // Skip this cluster
            //
            TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x, Skipping this cluster : 0x%x", Err.Error(),ppCluster[i]->GetClusterIP());
            continue;
          }


          if( !ClusterStatusOK( dwStatus ) )
          {
            //
            // Skip this cluster
            //
            TRACE_CRIT("%!FUNC! CWlbsControlWrapper::Query() returned error : 0x%x, Skipping this cluster : 0x%x",dwStatus,ppCluster[i]->GetClusterIP());
            continue;
          }
        }
    
        //get the Wbem class instance
        SpawnInstance( MOF_CLUSTER::szName, &pWlbsInstance );

        //Convert status to string description
        FillWbemInstance( pWlbsInstance, ppCluster[i], dwStatus );
    
        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );
        if( pWlbsInstance )
          pWlbsInstance->Release();
    }
    
    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );
    hRes = WBEM_S_NO_ERROR;
    
  }

  catch(CErrorWlbsControl Err) {

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch( _com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
    {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND ;
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    if( pWlbsInstance )
    {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    TRACE_CRIT("<-%!FUNC! Rethrowing exception");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::ExecMethod
//
// Purpose: This executes the methods associated with the MOF
//          Cluster class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Cluster::ExecMethod
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /*a_lFlags*/, 
    IWbemContext*           /*a_pIContex*/, 
    IWbemClassObject*       a_pIInParams
  )
{

  IWbemClassObject* pOutputInstance   = NULL;
  HRESULT hRes = 0;

  BSTR        strPortNumber = NULL;
  BSTR        strNumNodes   = NULL;

  VARIANT     vValue;
  CNodeConfiguration NodeConfig;

  TRACE_CRIT("->%!FUNC! a_strMethodName : %ls", a_strMethodName);

  VariantInit( &vValue  );
  
  try {
    CWlbsClusterWrapper* pCluster = NULL;
    
    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No cluster IP specified
        //
        TRACE_CRIT("%!FUNC! Cluster IP is NOT specified, Throwing com_error WBEM_E_INVALID_PARAMETER exception");
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    else
    {
        const wchar_t* wstrRequestedClusterName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

        //check to see if the requested cluster name matches the configured value
        // The name does not have host id in it.
        DWORD dwClusterIpOrIndex = IpAddressFromAbcdWsz(wstrRequestedClusterName);

        pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);
    }

    if (pCluster == NULL)
    {
        TRACE_CRIT("%!FUNC! Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    DWORD         dwNumHosts = 0;
    DWORD         dwReturnValue;
    DWORD         dwClustIP;

    strPortNumber = SysAllocString( MOF_PARAM::PORT_NUMBER );
    strNumNodes   = SysAllocString( MOF_PARAM::NUM_NODES );

    if( !strPortNumber || !strNumNodes )
    {
      TRACE_CRIT("%!FUNC! SysAllocString failed, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
      throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    dwClustIP = pCluster->GetClusterIpOrIndex(g_pWlbsControl);

    //get the output object instance
    GetMethodOutputInstance( MOF_CLUSTER::szName, 
                             a_strMethodName, 
                             &pOutputInstance);

    //*************************************************************************
    //
    //Determine and execute the MOF method
    //
    //*************************************************************************
    if( _wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DISABLE] ) == 0)  {
    
      if( !a_pIInParams )
      {
          TRACE_CRIT("%!FUNC! Input Parameters NOT specified for Method : %ls, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      // The "Disable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }
      
      //get the port number
      hRes = a_pIInParams->Get
                (  strPortNumber, 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) )
      {
          TRACE_CRIT("%!FUNC! IWbemClassObject::Get() returned error : 0x%x on %ls (Method : %ls), Throwing com_error exception", hRes, strPortNumber, a_strMethodName);
          throw _com_error( hRes );
      }

      //range checking is done by the API
      if( vValue.vt != VT_I4 ) 
      {
          TRACE_CRIT("%!FUNC! %ls (Method : %ls) type is NOT VT_I4, Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      //call Disable method
      dwReturnValue = g_pWlbsControl->Disable
                        (
                          dwClustIP,
                          WLBS_ALL_HOSTS, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          vValue.lVal
                        );

    } else if(_wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::ENABLE] ) == 0)  {

      if( !a_pIInParams )
      {
          TRACE_CRIT("%!FUNC! Input Parameters NOT specified for Method : %ls, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      // The "Enable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }
      
      //get the port number
      hRes = a_pIInParams->Get
               ( 
                 strPortNumber, 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes ) )
      {
          TRACE_CRIT("%!FUNC! IWbemClassObject::Get() returned error : 0x%x on %ls (Method : %ls), Throwing com_error exception", hRes, strPortNumber, a_strMethodName);
          throw _com_error( hRes );
      }

      //range checking is done by the API
      if( vValue.vt != VT_I4 ) 
      {
          TRACE_CRIT("%!FUNC! %ls (Method : %ls) type is NOT VT_I4, Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      //call Enable method
      dwReturnValue = g_pWlbsControl->Enable
        (
          dwClustIP,
          WLBS_ALL_HOSTS, 
          NULL, 
          dwNumHosts, 
          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
          vValue.lVal
        );

    } else if( _wcsicmp( a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DRAIN] ) == 0 )  {

      if( !a_pIInParams )
      {
          TRACE_CRIT("%!FUNC! Input Parameters NOT specified for Method : %ls, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      // The "Drain" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }
      
      //get the port number
      hRes = a_pIInParams->Get
               ( 
                 strPortNumber, 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes ) )
      {
          TRACE_CRIT("%!FUNC! IWbemClassObject::Get() returned error : 0x%x on %ls (Method : %ls), Throwing com_error exception", hRes, strPortNumber, a_strMethodName);
          throw _com_error( hRes );
      }

      //range checking is done by the API
      if( vValue.vt != VT_I4 ) 
      {
          TRACE_CRIT("%!FUNC! %ls (Method : %ls) type is NOT VT_I4, Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      //call Drain method
      dwReturnValue = g_pWlbsControl->Drain
                        (
                          dwClustIP,
                          WLBS_ALL_HOSTS, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          vValue.lVal
                        );

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::DRAINSTOP]) == 0)  {

      //call DrainStop method
      dwReturnValue = g_pWlbsControl->DrainStop(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::RESUME]   ) == 0)  {

      //call Resume method
      dwReturnValue = g_pWlbsControl->Resume(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::START]    ) == 0)  {

      //call Start method
      dwReturnValue = g_pWlbsControl->Start(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::STOP]     ) == 0)  {

      //call Stop method
      dwReturnValue = g_pWlbsControl->Stop(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_CLUSTER::pMethods[MOF_CLUSTER::SUSPEND]  ) == 0)  {

      //call Suspend method
      dwReturnValue = g_pWlbsControl->Suspend(dwClustIP, WLBS_ALL_HOSTS, NULL, dwNumHosts);

    } else {
      TRACE_CRIT("%!FUNC! Method : %ls NOT implemented, Throwing com_error WBEM_E_METHOD_NOT_IMPLEMENTED exception", a_strMethodName);
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //*************************************************************************
    //
    //Output Results
    //
    //*************************************************************************

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() returned error, Throwing com_error WBEM_E_FAILED");
        throw _com_error( WBEM_E_FAILED );
    }

    //set the return value
    vValue.vt   = VT_I4;
    vValue.lVal = static_cast<long>(dwReturnValue);
    hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);

    if( FAILED( hRes ) ) {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Put() returned error on \"ReturnValue\", Throwing com_error WBEM_E_FAILED");
        throw _com_error( hRes );
    }

    //set the number of hosts property
    vValue.vt   = VT_I4;
    vValue.lVal = static_cast<long>(dwNumHosts);
    hRes = pOutputInstance->Put(strNumNodes, 0, &vValue, 0);

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Put() returned error : 0x%x on %ls, Throwing com_error exception", hRes, strNumNodes);
        throw _com_error( hRes );
    }

    //send the results back to WinMgMt
    hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate() returned error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    m_pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);


    //*************************************************************************
    //
    //Release Resources
    //
    //*************************************************************************

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() returned error, Throwing com_error WBEM_E_FAILED");
        throw _com_error( WBEM_E_FAILED );
    }

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    IWbemClassObject* pWbemExtStat  = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception. Also, given the comment below, not sure
    // what exception we'd return...
    VariantClear( &vValue );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch( _com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);
    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    //COM Interfaces
    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //**** BSTRs ****
    if( strPortNumber ) {
      SysFreeString( strPortNumber );
      strPortNumber = NULL;
    }

    if( strNumNodes ) {
      SysFreeString( strNumNodes );
      strNumNodes = NULL;
    }

    //**** VARIANTs ****
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception
    VariantClear( &vValue );

    TRACE_CRIT("<-%!FUNC! Rethrowing exception");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Cluster::FillWbemInstance
//
// Purpose: This function copies all of the data from a cluster configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Cluster::FillWbemInstance
  ( 
          IWbemClassObject*   a_pWbemInstance, 
          CWlbsClusterWrapper* pCluster,
          const DWORD               a_dwStatus
  )
{
  namespace CLUSTER = MOF_CLUSTER;

  TRACE_VERB("->%!FUNC!");

  ASSERT( a_pWbemInstance );
  ASSERT(pCluster);

  CClusterConfiguration ClusterConfig;
  pCluster->GetClusterConfig( ClusterConfig );


  //InterconnectAddress
  wstring wstrClusterIp;
  AddressToString( pCluster->GetClusterIP(), wstrClusterIp );

  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::IPADDRESS] ),
      0                                                  ,
      &_variant_t(wstrClusterIp.c_str()),
      NULL
    );

  //Name
  wstring wstrClusterIndex;
  AddressToString( pCluster->GetClusterIpOrIndex(g_pWlbsControl), wstrClusterIndex );

  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::NAME] ),
      0                                                  ,
      &_variant_t(wstrClusterIndex.c_str()),
      NULL
    );

  //MaxNodes
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::MAXNODES] ),
      0                                                ,
      &_variant_t(ClusterConfig.nMaxNodes),
      NULL
    );

  //ClusterState
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSSTATE] ),
      0                                                ,
      &_variant_t((short)a_dwStatus),
      NULL
    );

  //CREATCLASS 
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CREATCLASS] ),
      0                                                ,
      &_variant_t(CLUSTER::szName),
      NULL
    );
  TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_guids.cpp ===
//WLBSGuids.cpp
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_cluster.h ===
#ifndef _WLBSCLUSTER_INCLUDED_
#define _WLBSCLUSTER_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_Cluster
//
// Purpose: 
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_Cluster : public CWlbs_Root
{
public:

  CWLBS_Cluster(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL
                    );

private:

  void FillWbemInstance( IWbemClassObject*   a_pWbemInstance, 
			            CWlbsClusterWrapper* pCluster,
                        const DWORD          a_dwStatus );

};

#endif _WLBSCLUSTER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_mofdata.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_MOFData.h"

#define GENERATE_VALUE_LIST
#include "WLBS_MofLists.h"

namespace MOF_CLASSES
{
  LPWSTR g_szMOFClassList[] = { MOF_CLASS_LIST };
  PCREATE g_pCreateFunc[] = 
  { CWLBS_Cluster::Create, 
    CWLBS_Node::Create, 
    CWLBS_ClusterSetting::Create,
    CWLBS_NodeSetting::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create,
    CWLBS_PortRule::Create, // For PortRuleEx
    CWLBS_ParticipatingNode::Create,
    CWLBS_NodeSetPortRule::Create,
    CWLBS_ClusClusSetting::Create,
    CWLBS_NodeNodeSetting::Create
  };
  DWORD  NumClasses = sizeof(g_szMOFClassList)/sizeof(LPWSTR);
};

//MOF_NODE namespace initialization
namespace MOF_NODE
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODE];
  LPWSTR   pProperties[] = { MOF_NODE_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_NODE_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_CLUSTER namespace initialization
namespace MOF_CLUSTER
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSTER];
  LPWSTR   pProperties[] = { MOF_CLUSTER_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_CLUSTER_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_CLUSTERSETTING namespace initialization
namespace MOF_CLUSTERSETTING
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSSET];
  LPWSTR   pProperties[] = { MOF_CLUSTERSETTING_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_CLUSTERSETTING_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_NODESETTING namespace initialization
namespace MOF_NODESETTING
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODESET];
  LPWSTR   pProperties[] = { MOF_NODESETTING_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_NODESETTING_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PORTRULE namespace initialization
namespace MOF_PORTRULE
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE];
  LPWSTR   pProperties[] = { MOF_PORTRULE_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_PORTRULE_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PRFAIL namespace initialization
namespace MOF_PRFAIL
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL];
  LPWSTR   pProperties[] = { MOF_PRFAIL_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_PRLOADBAL namespace initialization
namespace MOF_PRLOADBAL
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB];
  LPWSTR   pProperties[] = { MOF_PRLOADBAL_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_PRDIS namespace initialization
namespace MOF_PRDIS
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS];
};

// MOF_PORTRULE_EX namespace initialization
namespace MOF_PORTRULE_EX
{
  LPWSTR   szName        = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX];
  LPWSTR   pProperties[] = { MOF_PORTRULE_EX_PROPERTY_LIST };
  LPWSTR   pMethods[]    = { MOF_PORTRULE_EX_METHOD_LIST   }; 
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
  DWORD    NumMethods    = sizeof(pMethods)/sizeof(LPWSTR);
};

//MOF_PARTICIPATINGNODE namespace initialization
namespace MOF_PARTICIPATINGNODE
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PARTNODE];
  LPWSTR   pProperties[] = { MOF_PARTICIPATINGNODE_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_NODESETTINGPORTRULE namespace initialization
namespace MOF_NODESETTINGPORTRULE
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODESETPR];
  LPWSTR   pProperties[] = { MOF_NODESETTINGPORTRULE_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_CLUSCLUSSETTING namespace initialization
namespace MOF_CLUSCLUSSETTING
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::CLUSCLUSSET];
  LPWSTR   pProperties[] = { MOF_CLUSCLUSSETTING_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

//MOF_NODENODESETTING namespace initialization
namespace MOF_NODENODESETTING
{
  LPWSTR   szName = MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::NODENODESET];
  LPWSTR   pProperties[] = { MOF_NODENODESETTING_PROPERTY_LIST };
  DWORD    NumProperties = sizeof(pProperties)/sizeof(LPWSTR);
};

namespace MOF_PARAM
{
  LPWSTR PORT_NUMBER  = L"Port";
  LPWSTR HOST_ID      = L"HostID";
  LPWSTR NUM_NODES    = L"NumNodes";
  LPWSTR CLUSIP       = L"ClusterIPAddress";
  LPWSTR CLUSNETMASK  = L"ClusterNetworkMask";
  LPWSTR PASSW        = L"Password";
  LPWSTR DEDIP        = L"DedicatedIPAddress";
  LPWSTR DEDNETMASK   = L"DedicatedNetworkMask";
  LPWSTR PORTRULE     = L"PortRule";
  LPWSTR NODEPATH     = L"Node";
  LPWSTR VIP          = L"VirtualIpAddress";
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_clustersetting.h ===
#ifndef _CLUSTERSETTING_INCLUDED_
#define _CLUSTERSETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_ClusterSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node configuration class.

//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_ClusterSetting : public CWlbs_Root
{
public:

  CWLBS_ClusterSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT PutInstance( 
                       IWbemClassObject* a_pInstance,
                       long              a_lFlags            = 0,
                       IWbemContext*     a_pIContex          = NULL
                     );

  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL 
                    );

private:

  void FillWbemInstance( IWbemClassObject*   a_pWbemInstance,
		  CWlbsClusterWrapper* pCluster);

  void UpdateConfiguration( IWbemClassObject* a_pInstance,
  		    CWlbsClusterWrapper* pCluster);

};

#endif //_CLUSTERSETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_clustersetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_clustersetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"
#include "WLBS_clustersetting.tmh"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::CWLBS_ClusterSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ClusterSetting::CWLBS_ClusterSetting
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_ClusterSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_ClusterSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    wstring wstrHostName;
    
    //get the name key property and convert to wstring
    //throws _com_error
    
    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    //get the cluster
    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    
    if (pCluster == NULL)
    {
        TRACE_CRIT("%!FUNC! GetClusterFromHostName failed for Host name = %ls, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName.data());      
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    //get the Wbem class instance
    SpawnInstance( MOF_CLUSTERSETTING::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance( pWlbsInstance, pCluster );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());
    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {
    TRACE_CRIT("%!FUNC! Caught an exception");

    if( pWlbsInstance )
      pWlbsInstance->Release();

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::EnumInstances
//
// Purpose: This function obtains the clustersetting data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed. However, WLBS must be installed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance = NULL;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      TRACE_CRIT("%!FUNC! CWlbsControlWrapper::EnumClusters() returned no clusters, Throwing com_error WBEM_E_NOT_FOUND exception");
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i < dwNumClusters; i++)
    {
        //get the Wbem class instance
        SpawnInstance( MOF_CLUSTERSETTING::szName, &pWlbsInstance );

        //get the cluster configuration
        FillWbemInstance( pWlbsInstance , ppCluster[i]);

        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );

        if( pWlbsInstance ) {

          pWlbsInstance->Release();
          pWlbsInstance = NULL;

        }
    }

    

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    
    //transform Win32 error to a WBEM error
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND ;
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::PutInstance
//
// Purpose: This function updates an instance of a MOF ClusterSetting 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::PutInstance
  ( 
    IWbemClassObject* a_pInstance,
    long              /* a_lFlags */,
    IWbemContext*     /* a_pIContex */
  )
{
  HRESULT            hRes = 0;
  VARIANT            vHostName;

  TRACE_CRIT("->%!FUNC!");

  try {

    VariantInit( &vHostName );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( MOF_CLUSTERSETTING::pProperties[MOF_CLUSTERSETTING::NAME] ),
                             0,
                             &vHostName,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
      throw _com_error( hRes );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, vHostName.bstrVal);
    
    if (pCluster == NULL)
    {
      TRACE_CRIT("%!FUNC! GetClusterFromHostName failed for Host name = %ls, Throwing com_error WBEM_E_NOT_FOUND exception",vHostName.bstrVal);      
      throw _com_error( WBEM_E_NOT_FOUND );
    }


    //get the cluster IP value
    _variant_t vClusterIp;

    hRes = a_pInstance->Get( _bstr_t( MOF_CLUSTERSETTING::pProperties[MOF_CLUSTERSETTING::CLUSIPADDRESS] ),
                             0,
                             &vClusterIp,
                             NULL,
                             NULL );

    DWORD dwClusterIp = IpAddressFromAbcdWsz(vClusterIp.bstrVal);
    
    //
    // Make sure the non-zero cluster IP is unique
    //
    if (dwClusterIp != 0)
    {
        CWlbsClusterWrapper* pTmpCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIp);

        if (pTmpCluster && pCluster != pTmpCluster)
        {

            TRACE_CRIT("%!FUNC! GetClusterFromIpOrIndex failed, Dupilcate Cluster IP (%ls) found, Throwing Wlbs error WLBS_REG_ERROR exception",vClusterIp.bstrVal);

            throw CErrorWlbsControl( WLBS_REG_ERROR, CmdWlbsWriteReg );
        }
    }
    
    UpdateConfiguration( a_pInstance, pCluster );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
    {
       TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
       throw _com_error( WBEM_E_FAILED );
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
    {
       TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
       throw _com_error( WBEM_E_FAILED );
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    hRes = HResErr.Error();
  }

  catch (...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ClusterSetting::ExecMethod    
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  VARIANT           vValue;
  HRESULT           hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    VariantInit( &vValue );

    CWlbsClusterWrapper* pCluster = NULL;
    
    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No cluster IP specified
        //
        TRACE_CRIT("%!FUNC! Key (Clsuter IP) is not specified, Throwing com_error WBEM_E_INVALID_PARAMETER exception");
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    else
    {
        const wchar_t* wstrRequestedClusterName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

        pCluster = GetClusterFromHostName(g_pWlbsControl, wstrRequestedClusterName);

        if (pCluster == NULL)
        {
            TRACE_CRIT("%!FUNC! GetClusterFromHostName failed for Cluster name = %ls, Throwing com_error WBEM_E_NOT_FOUND exception",wstrRequestedClusterName);      
            throw _com_error( WBEM_E_NOT_FOUND );
        }
    }

    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_CLUSTERSETTING::pMethods[MOF_CLUSTERSETTING::SETPASS] ) == 0 )  {

      //get the password
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::PASSW ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

      if( vValue.vt != VT_BSTR )
      {
        TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"BString\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::PASSW, a_strMethodName);
        throw _com_error ( WBEM_E_INVALID_PARAMETER );
      }

      pCluster->SetPassword( vValue.bstrVal );

    } else if( _wcsicmp( a_strMethodName, MOF_CLUSTERSETTING::pMethods[MOF_CLUSTERSETTING::LDSETT] ) == 0 ) {

      //
      // NOTE:
      // NLB, if needed, calls the PnP apis to disable and re-enable the network adapter, for the new NLB settings to take 
      // effect. Since this operation involves unloading and loading of the device driver, PnP apis, attempt to enable
      // the "SeLoadDriverPrivilege" privilege in the impersonation access token. Enabling a privilege is successful only
      // when the privilege is present, in the first place to be enabled. When the wmi client and wmi provider are in the 
      // same machine, it was observed that the "SeLoadDriverPrivilege" privilege was NOT event present in the impersonation
      // access token of the server. This is because, only the enabled privileges of the client are passed along to the server. 
      // So, we now require that the client enable the "SeLoadDriverPrivilege" privilege in its access token before calling 
      // this method. The following call to Check_Load_Unload_Driver_Privilege() checks if "SeLoadDriverPrivilege" privilege 
      // is enabled in the impersonation access token. Although the PnP apis only require that this privilege be present, 
      // we have decided to elevate the requirement to this privilege being present AND enabled. This is because, if the 
      // privilege is NOT enabled, the operation to enable it may or may not succeed depending on the client's credentials. 
      // --KarthicN, May 6, 2002.
      //
      if(!Check_Load_Unload_Driver_Privilege())
      {
          TRACE_CRIT("%!FUNC! Check_Load_Unload_Driver_Privilege() failed, Throwing WBEM_E_ACCESS_DENIED exception");
          throw _com_error( WBEM_E_ACCESS_DENIED );
      }

      DWORD dwReturnValue = pCluster->Commit(g_pWlbsControl);
      
    //get the output object instance
      GetMethodOutputInstance( MOF_CLUSTERSETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      //set the return value
      vValue.vt   = VT_I4;
      vValue.lVal = static_cast<long>(dwReturnValue);
      hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);

      if( FAILED( hRes ) ) {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Put() returned error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
      }

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) ) {
          TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate() returned error : 0x%x, Throwing com_error exception", hRes);
          throw _com_error( hRes );
        }
      }

    } else if( _wcsicmp( a_strMethodName, MOF_CLUSTERSETTING::pMethods[MOF_CLUSTERSETTING::SETDEF] ) == 0 ) {
      pCluster->SetClusterDefaults();
    } else {
      TRACE_CRIT("%!FUNC! %ls method NOT implemented, Throwing WBEM_E_METHOD_NOT_IMPLEMENTED exception",a_strMethodName);
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //get the parameters
    //call the underlying API
    //set the function return parameter
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
       TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
       throw _com_error( WBEM_E_FAILED );
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    hRes = HResErr.Error();
  }

  catch ( ... ) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::FillWbemInstance
//
// Purpose: This function copies all of the data from a cluster configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ClusterSetting::FillWbemInstance( IWbemClassObject* a_pWbemInstance,
                    CWlbsClusterWrapper* pCluster)
{
  namespace CLUSTER = MOF_CLUSTERSETTING;

  TRACE_VERB("->%!FUNC!");

  ASSERT( a_pWbemInstance );
  ASSERT(pCluster );

  CClusterConfiguration ClusterConfig;

  pCluster->GetClusterConfig( ClusterConfig );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //NAME
  a_pWbemInstance->Put
    (
      
      _bstr_t( CLUSTER::pProperties[CLUSTER::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  //CLUSNAME
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSNAME] ),
      0                                                  ,
      &_variant_t(ClusterConfig.szClusterName.c_str()),
      NULL
    );

  //CLUSIPADDRESS
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSIPADDRESS] ),
      0                                                  ,
      &_variant_t(ClusterConfig.szClusterIPAddress.c_str()),
      NULL
    );

  //CLUSNETMASK
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSNETMASK] ),
      0                                                ,
      &_variant_t(ClusterConfig.szClusterNetworkMask.c_str()),
      NULL
    );

  //CLUSMAC
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSMAC] ),
      0                                                ,
      &_variant_t(ClusterConfig.szClusterMACAddress.c_str()),
      NULL
    );

  //MULTIENABLE
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::MULTIENABLE] ),
      0                                                ,
      &_variant_t(ClusterConfig.bMulticastSupportEnable),
      NULL
    );


  //REMCNTEN
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::REMCNTEN] ),
      0                                                ,
      &_variant_t(ClusterConfig.bRemoteControlEnabled),
      NULL
    );

  //IGMPSUPPORT
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::IGMPSUPPORT] ),
      0                                                ,
      &_variant_t(ClusterConfig.bIgmpSupport),
      NULL
    );
    
  //CLUSTERIPTOMULTICASTIP
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::CLUSTERIPTOMULTICASTIP] ),
      0                                                ,
      &_variant_t(ClusterConfig.bClusterIPToMulticastIP),
      NULL
    );
  //MULTICASTIPADDRESS
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::MULTICASTIPADDRESS] ),
      0                                                ,
      &_variant_t(ClusterConfig.szMulticastIPAddress.c_str()),
      NULL
    );

  //ADAPTERGUID 

  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
  
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  //BDA Team Active
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::BDATEAMACTIVE] ),
      0                                                ,
      &_variant_t(ClusterConfig.bBDATeamActive),
      NULL
    );

  if (ClusterConfig.bBDATeamActive) 
  {
      //BDA Team Id
      a_pWbemInstance->Put
        (
          _bstr_t( CLUSTER::pProperties[CLUSTER::BDATEAMID] ),
          0                                                ,
          &_variant_t(ClusterConfig.szBDATeamId.c_str()),
          NULL
        );

      //BDA Team Master
      a_pWbemInstance->Put
        (
          _bstr_t( CLUSTER::pProperties[CLUSTER::BDATEAMMASTER] ),
          0                                                ,
          &_variant_t(ClusterConfig.bBDATeamMaster),
          NULL
        );

      //BDA Reverse Hash 
      a_pWbemInstance->Put
        (
          _bstr_t( CLUSTER::pProperties[CLUSTER::BDAREVERSEHASH] ),
          0                                                ,
          &_variant_t(ClusterConfig.bBDAReverseHash),
          NULL
        );
  }

  //IDHBENAB
  a_pWbemInstance->Put
    (
      _bstr_t( CLUSTER::pProperties[CLUSTER::IDHBENAB] ),
      0                                                ,
      &_variant_t(ClusterConfig.bIdentityHeartbeatEnabled),
      NULL
    );

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ClusterSetting::UpdateConfiguration
//
// Purpose: This function updates the configuration data for a member node or a
//          potential WLBS cluster node.
//    
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ClusterSetting::UpdateConfiguration
  ( 
    IWbemClassObject* a_pInstance, 
    CWlbsClusterWrapper* pCluster
  )
{
  namespace CLUSTER = MOF_CLUSTERSETTING;

  CClusterConfiguration NewConfiguration;
  CClusterConfiguration OldConfiguration;

  TRACE_VERB("->%!FUNC!");

  pCluster->GetClusterConfig( OldConfiguration );

  //Cluster Name
  UpdateConfigProp
    ( 
      NewConfiguration.szClusterName,
      OldConfiguration.szClusterName,
      CLUSTER::pProperties[CLUSTER::CLUSNAME],
      a_pInstance 
    );

  //Cluster IP
  UpdateConfigProp
    ( 
      NewConfiguration.szClusterIPAddress,
      OldConfiguration.szClusterIPAddress,
      CLUSTER::pProperties[CLUSTER::CLUSIPADDRESS],
      a_pInstance 
    );

  //Cluster Network Mask
  UpdateConfigProp
    ( 
      NewConfiguration.szClusterNetworkMask,
      OldConfiguration.szClusterNetworkMask,
      CLUSTER::pProperties[CLUSTER::CLUSNETMASK],
      a_pInstance 
    );

  //Cluster enable remote control
  UpdateConfigProp
    ( 
      NewConfiguration.bRemoteControlEnabled,
      OldConfiguration.bRemoteControlEnabled,
      CLUSTER::pProperties[CLUSTER::REMCNTEN],
      a_pInstance 
    );

  //Cluster enable multicast support
  UpdateConfigProp
    ( 
      NewConfiguration.bMulticastSupportEnable,
      OldConfiguration.bMulticastSupportEnable,
      CLUSTER::pProperties[CLUSTER::MULTIENABLE],
      a_pInstance 
    );


  //IGMPSUPPORT
  UpdateConfigProp
    ( 
      NewConfiguration.bIgmpSupport,
      OldConfiguration.bIgmpSupport,
      CLUSTER::pProperties[CLUSTER::IGMPSUPPORT],
      a_pInstance 
    );


  //CLUSTERIPTOMULTICASTIP
  UpdateConfigProp
    ( 
      NewConfiguration.bClusterIPToMulticastIP,
      OldConfiguration.bClusterIPToMulticastIP,
      CLUSTER::pProperties[CLUSTER::CLUSTERIPTOMULTICASTIP],
      a_pInstance 
    );


  //MULTICASTIPADDRESS
  UpdateConfigProp
    ( 
      NewConfiguration.szMulticastIPAddress,
      OldConfiguration.szMulticastIPAddress,
      CLUSTER::pProperties[CLUSTER::MULTICASTIPADDRESS],
      a_pInstance 
    );

  //BDA Teaming Active ?
  UpdateConfigProp
    ( 
       NewConfiguration.bBDATeamActive,
       OldConfiguration.bBDATeamActive,
       CLUSTER::pProperties[CLUSTER::BDATEAMACTIVE],
       a_pInstance 
    );

  // Set the other BDA properties only if the "Active" property is set
  if (NewConfiguration.bBDATeamActive)
  {
      //BDA Team ID
      UpdateConfigProp
        ( 
          NewConfiguration.szBDATeamId,
          OldConfiguration.szBDATeamId,
          CLUSTER::pProperties[CLUSTER::BDATEAMID],
          a_pInstance 
        );

      //BDA Team Master
      UpdateConfigProp
        ( 
          NewConfiguration.bBDATeamMaster,
          OldConfiguration.bBDATeamMaster,
          CLUSTER::pProperties[CLUSTER::BDATEAMMASTER],
          a_pInstance 
        );

      //BDA Team Reverse Hash
      UpdateConfigProp
        ( 
          NewConfiguration.bBDAReverseHash,
          OldConfiguration.bBDAReverseHash,
          CLUSTER::pProperties[CLUSTER::BDAREVERSEHASH],
          a_pInstance 
        );

  }

  //Cluster enable identity heartbeats
  UpdateConfigProp
    ( 
      NewConfiguration.bIdentityHeartbeatEnabled,
      OldConfiguration.bIdentityHeartbeatEnabled,
      CLUSTER::pProperties[CLUSTER::IDHBENAB],
      a_pInstance 
    );

  pCluster->PutClusterConfig( NewConfiguration );
  
  TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_dllmain.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File:   WLBSMain.CPP
// 
//  Module: WLBS Instance provider code
//
//  Purpose: Contains DLL entry points.  Also containts code that controls
//           when the DLL can be unloaded by tracking the number of
//           components and sever locks as well as routines that support
//           self registration.
//
//      History:
//
//***************************************************************************

#include "WLBS_Provider.h"
#include <objbase.h>
#include "ControlWrapper.h"
#include "WLBS_DllMain.tmh" // for event tracing

#include <strsafe.h>

#define THIS_PROVIDERS_NAME L"Microsoft NLB Instance Provider"

//CLSID for provider
// {FB223274-D72E-11d2-A420-00C04F68FE28}
static const GUID CLSID_WLBSProvider = 
{ 0xfb223274, 0xd72e, 0x11d2, { 0xa4, 0x20, 0x0, 0xc0, 0x4f, 0x68, 0xfe, 0x28 } };


static HMODULE    g_hModule      = NULL; //DLL Module Handle
CWlbsControlWrapper*     g_pWlbsControl = NULL;

//Track number of objects and number of locks.
long g_cComponents  = 0;    //Count of active components
long g_cServerLocks = 0;    //Count of server locks

//***************************************************************************
//
// DllMain
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE a_hInstance,    // handle to DLL module
    DWORD     a_fdwReason,    // reason for calling function
    LPVOID    /* a_lpvReserved */   // reserved
  )
{
  
  if (a_fdwReason == DLL_PROCESS_ATTACH) {

  //set the global module handle
    g_hModule = a_hInstance;

    //
    // Enable tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB");
  }

  if (a_fdwReason == DLL_PROCESS_DETACH) {

    if( g_pWlbsControl != NULL ) {
      delete g_pWlbsControl;
    }

    //
    // Disable tracing
    //
    WPP_CLEANUP();
  }

  return TRUE;
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by OLE when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************
STDAPI DllGetClassObject(REFCLSID a_rclsid, REFIID a_riid, PPVOID a_ppv)
{
  HRESULT hr;
  CWLBSClassFactory *pWLBSFacObj;

  if ( a_rclsid != CLSID_WLBSProvider )
      return CLASS_E_CLASSNOTAVAILABLE;

  pWLBSFacObj = new CWLBSClassFactory();

  if ( pWLBSFacObj == NULL )
      return E_OUTOFMEMORY;

  hr=pWLBSFacObj->QueryInterface( a_riid, a_ppv );

  pWLBSFacObj->Release();

  return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************
STDAPI DllCanUnloadNow(void)
{
  SCODE   SCode;

  //It is OK to unload if there are no objects or locks on the 
  // class factory.
  
  SCode = (g_cComponents == 0L && g_cServerLocks == 0L) ? S_OK : S_FALSE;

  // Do not let this provider unload implicitly. The API is maintaining a
  // cache that must persist in order for proper operation.
  // return S_FALSE;

  return SCode;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
STDAPI DllRegisterServer(void)
{   
  WCHAR   wcID[128];
  WCHAR   szCLSID[128];
  WCHAR   szModule[MAX_PATH];
  const WCHAR * pName = THIS_PROVIDERS_NAME;
  const WCHAR * pThreadingModel = L"Apartment";
  HKEY    hKey1, hKey2;
  LONG    nRet;
  
  
  // Create the path.

  StringFromGUID2(CLSID_WLBSProvider, wcID, 128);
  StringCbCopy(szCLSID, sizeof(szCLSID), TEXT("Software\\classes\\CLSID\\"));
  StringCbCat(szCLSID, sizeof(szCLSID), wcID);

  // Create entries under CLSID

  nRet = RegCreateKey( HKEY_LOCAL_MACHINE, szCLSID, &hKey1 );
  nRet = RegSetValueEx( hKey1, 
                        NULL, 
                        0, 
                        REG_SZ, 
                        (BYTE *)pName, 
                        (wcslen(pName)+1) * sizeof(WCHAR) );

  nRet = RegCreateKey( hKey1, L"InprocServer32", &hKey2 );

  GetModuleFileName( g_hModule, szModule,  MAX_PATH );

  // GetModuleFileName will NOT null terminate the string if the file name was >= MAX_PATH characters
  szModule[MAX_PATH-1] = 0;

  nRet = RegSetValueEx( hKey2, 
                        NULL, 
                        0, 
                        REG_SZ, 
                        (BYTE *)szModule, 
                        (wcslen(szModule)+1) * sizeof(WCHAR) );

  nRet = RegSetValueEx( hKey2, 
                        L"ThreadingModel", 
                        0, 
                        REG_SZ, 
                        (BYTE *)pThreadingModel, 
                        (wcslen(pThreadingModel)+1) * sizeof(WCHAR) );

  nRet = RegCloseKey(hKey1);
  nRet = RegCloseKey(hKey2);

  return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
STDAPI DllUnregisterServer(void)
{
  WCHAR szCLSID[128];

  WCHAR wcID[128];
  HKEY  hKey;

  // Create the path using the CLSID

  StringFromGUID2(CLSID_WLBSProvider, wcID, 128);
  StringCbCopy(szCLSID, sizeof(szCLSID), TEXT("Software\\classes\\CLSID\\"));
  StringCbCat(szCLSID, sizeof(szCLSID), wcID);

  // First delete the InProcServer subkey.

  DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
  if(dwRet == NO_ERROR)
  {
      RegDeleteKey(hKey, L"InProcServer32");
      RegCloseKey(hKey);
  }

  dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, L"Software\\classes\\CLSID", &hKey);
  if(dwRet == NO_ERROR)
  {
      RegDeleteKey(hKey,wcID);
      RegCloseKey(hKey);
  }

  return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_moflists.h ===
//GENERATE_VALUE_LIST changes how LIST_ITEM appears when
//expanded by the preprocessor. 

//When GENERATE_VALUE_LIST is not defined,
//LIST_ITEM expands to the first column, which is utilized
//within WLBS_MOFData.h to define enumarated types that
//act as keys to their correlated arrays. 

//When GENERATE_VALUE_LIST is defined, LIST_ITEM
//expands to the second column which is utilized within
//WLBS_MOFData.cpp to initialize arrays of strings.

#ifdef GENERATE_VALUE_LIST

# ifdef LIST_ITEM
#   undef LIST_ITEM
# endif

# define LIST_ITEM(WLBS_KEY, WLBS_VALUE) WLBS_VALUE

#else

# ifdef LIST_ITEM
#   undef LIST_ITEM
# endif

# define LIST_ITEM(WLBS_KEY, WLBS_VALUE) WLBS_KEY

#endif

//The first columns represent arrays of keys and are defined in
//enumerated types. The second columns are values that are
//stored in arrays of strings. The arrays are stored within
//namespaces and are initialized in WLBS_MOFData.cpp. The 
//enumerated types are also scoped within namespaces and are
//defined in WLBS_MOFData.h.

#define MOF_NODE_PROPERTY_LIST \
  LIST_ITEM(NAME,        L"Name")                 , \
  LIST_ITEM(HOSTID,      L"HostPriority")         , \
  LIST_ITEM(IPADDRESS,   L"DedicatedIPAddress")   , \
  LIST_ITEM(STATUS,      L"StatusCode")			  , \
  LIST_ITEM(COMPUTERNAME,L"ComputerName")		  , \
  LIST_ITEM(CREATCLASS,  L"CreationClassName")

#define MOF_NODE_METHOD_LIST \
  LIST_ITEM(DISABLE,   L"Disable")  , \
  LIST_ITEM(ENABLE,    L"Enable")   , \
  LIST_ITEM(DRAIN,     L"Drain")    , \
  LIST_ITEM(DISABLE_EX,L"DisableEx"), \
  LIST_ITEM(ENABLE_EX, L"EnableEx") , \
  LIST_ITEM(DRAIN_EX,  L"DrainEx")  , \
  LIST_ITEM(DRAINSTOP, L"DrainStop"), \
  LIST_ITEM(RESUME,    L"Resume")   , \
  LIST_ITEM(START,     L"Start")    , \
  LIST_ITEM(STOP,      L"Stop")     , \
  LIST_ITEM(SUSPEND,   L"Suspend")

#define MOF_CLUSTER_PROPERTY_LIST \
  LIST_ITEM(NAME,       L"Name")                , \
  LIST_ITEM(IPADDRESS,  L"InterconnectAddress") , \
  LIST_ITEM(MAXNODES,   L"MaxNumberOfNodes")    , \
  LIST_ITEM(CLUSSTATE,  L"ClusterState")        , \
  LIST_ITEM(CREATCLASS, L"CreationClassName")   , \
  LIST_ITEM(STATUS,     L"ClusterState")

#define MOF_CLUSTER_METHOD_LIST \
  LIST_ITEM(DISABLE,   L"Disable")  , \
  LIST_ITEM(ENABLE,    L"Enable")   , \
  LIST_ITEM(DRAIN,     L"Drain")    , \
  LIST_ITEM(DRAINSTOP, L"DrainStop"), \
  LIST_ITEM(RESUME,    L"Resume")   , \
  LIST_ITEM(START,     L"Start")    , \
  LIST_ITEM(STOP,      L"Stop")     , \
  LIST_ITEM(SUSPEND,   L"Suspend")

#define MOF_CLUSTERSETTING_PROPERTY_LIST \
  LIST_ITEM(NAME,             L"Name")                    , \
  LIST_ITEM(CLUSNAME,         L"ClusterName")             , \
  LIST_ITEM(CLUSIPADDRESS,    L"ClusterIPAddress")        , \
  LIST_ITEM(CLUSNETMASK,      L"ClusterNetworkMask")      , \
  LIST_ITEM(CLUSMAC,          L"ClusterMACAddress")       , \
  LIST_ITEM(MULTIENABLE,      L"MulticastSupportEnabled") , \
  LIST_ITEM(REMCNTEN,         L"RemoteControlEnabled")    , \
  LIST_ITEM(IGMPSUPPORT,      L"IgmpSupport") , \
  LIST_ITEM(CLUSTERIPTOMULTICASTIP,      L"ClusterIPToMulticastIP") , \
  LIST_ITEM(MULTICASTIPADDRESS,      L"MulticastIPAddress") , \
  LIST_ITEM(ADAPTERGUID,      L"AdapterGuid")             , \
  LIST_ITEM(BDATEAMACTIVE,    L"BDATeamActive")           , \
  LIST_ITEM(BDATEAMID,        L"BDATeamId")               , \
  LIST_ITEM(BDATEAMMASTER,    L"BDATeamMaster")           , \
  LIST_ITEM(BDAREVERSEHASH,   L"BDAReverseHash")          , \
  LIST_ITEM(IDHBENAB,         L"IdentityHeartbeatEnabled")

#define MOF_CLUSTERSETTING_METHOD_LIST \
  LIST_ITEM(SETPASS,   L"SetPassword")              , \
  LIST_ITEM(LDSETT,    L"LoadAllSettings")          , \
  LIST_ITEM(SETDEF,    L"SetDefaults")

#define MOF_NODESETTING_PROPERTY_LIST \
  LIST_ITEM(NAME,             L"Name")                  , \
  LIST_ITEM(DEDIPADDRESS,     L"DedicatedIPAddress")    , \
  LIST_ITEM(DEDNETMASK,       L"DedicatedNetworkMask")  , \
  LIST_ITEM(NUMRULES,         L"NumberOfRules")         , \
  LIST_ITEM(HOSTPRI,          L"HostPriority")          , \
  LIST_ITEM(MSGPERIOD,        L"AliveMessagePeriod")    , \
  LIST_ITEM(MSGTOLER,         L"AliveMessageTolerance") , \
  LIST_ITEM(CLUSMODEONSTART,  L"ClusterModeOnStart")    , \
  LIST_ITEM(CLUSMODESUSPONSTART,  L"ClusterModeSuspendOnStart"), \
  LIST_ITEM(PERSISTSUSPONREBOOT,  L"PersistSuspendOnReboot"), \
  LIST_ITEM(REMOTEUDPPORT,    L"RemoteControlUDPPort")  , \
  LIST_ITEM(MASKSRCMAC,       L"MaskSourceMAC")         , \
  LIST_ITEM(DESCPERALLOC,     L"DescriptorsPerAlloc")   , \
  LIST_ITEM(MAXDESCALLOCS,    L"MaxDescriptorsPerAlloc"), \
  LIST_ITEM(FILTERICMP,       L"FilterIcmp")            , \
  LIST_ITEM(TCPDESCRIPTORTIMEOUT,  L"TcpDescriptorTimeout"),   \
  LIST_ITEM(IPSECDESCRIPTORTIMEOUT,L"IpSecDescriptorTimeout"), \
  LIST_ITEM(NUMACTIONS,       L"NumActions")            , \
  LIST_ITEM(NUMPACKETS,       L"NumPackets")            , \
  LIST_ITEM(NUMALIVEMSGS,     L"NumAliveMessages")      , \
  LIST_ITEM(ADAPTERGUID,      L"AdapterGuid")           
             

//Removed per kyrilf request 8-12-1999
//  LIST_ITEM(NBTENABLE,        L"NBTSupportEnable")    , \

#define MOF_NODESETTING_METHOD_LIST \
  LIST_ITEM(GETPORT,  L"GetPortRule")                , \
  LIST_ITEM(GETPORT_EX,L"GetPortRuleEx")             , \
  LIST_ITEM(LDSETT,   L"LoadAllSettings")            , \
  LIST_ITEM(SETDEF,   L"SetDefaults")

#define MOF_PORTRULE_PROPERTY_LIST \
  LIST_ITEM(NAME,   L"Name")      , \
  LIST_ITEM(STPORT, L"StartPort") , \
  LIST_ITEM(EDPORT, L"EndPort")   , \
  LIST_ITEM(PROT,   L"Protocol"), \
  LIST_ITEM(ADAPTERGUID, L"AdapterGuid")


#define MOF_PORTRULE_METHOD_LIST \
  LIST_ITEM(SETDEF,    L"SetDefaults")

#define MOF_PRFAIL_PROPERTY_LIST \
  LIST_ITEM(PRIO, L"Priority")

#define MOF_PRLOADBAL_PROPERTY_LIST \
  LIST_ITEM(EQLD,  L"EqualLoad")  , \
  LIST_ITEM(LDWT,  L"LoadWeight") , \
  LIST_ITEM(AFFIN, L"Affinity")

#define MOF_PORTRULE_EX_PROPERTY_LIST \
  LIST_ITEM(NAME,          L"Name")            , \
  LIST_ITEM(VIP,           L"VirtualIpAddress"), \
  LIST_ITEM(STPORT,        L"StartPort")       , \
  LIST_ITEM(EDPORT,        L"EndPort")         , \
  LIST_ITEM(PROT,          L"Protocol")        , \
  LIST_ITEM(ADAPTERGUID,   L"AdapterGuid")  , \
  LIST_ITEM(FILTERINGMODE, L"FilteringMode"), \
  LIST_ITEM(EQLD,          L"EqualLoad")    , \
  LIST_ITEM(LDWT,          L"LoadWeight")   , \
  LIST_ITEM(AFFIN,         L"Affinity")     , \
  LIST_ITEM(PRIO,          L"Priority")     , \
  LIST_ITEM(PORTSTATE,     L"PortState")

#define MOF_PORTRULE_EX_METHOD_LIST \
  LIST_ITEM(SETDEF,    L"SetDefaults")


#define MOF_PARTICIPATINGNODE_PROPERTY_LIST \
  LIST_ITEM(CLUSTER, L"Dependent")    , \
  LIST_ITEM(NODE,    L"Antecedent")

#define MOF_NODESETTINGPORTRULE_PROPERTY_LIST \
  LIST_ITEM(NODESET,  L"GroupComponent")    , \
  LIST_ITEM(PORTRULE, L"PartComponent")

#define MOF_CLUSCLUSSETTING_PROPERTY_LIST \
  LIST_ITEM(CLUSTER, L"Element")    , \
  LIST_ITEM(CLUSSET, L"Setting")

#define MOF_NODENODESETTING_PROPERTY_LIST \
  LIST_ITEM(NODE,    L"Element")    , \
  LIST_ITEM(NODESET, L"Setting")

#define MOF_CLASS_LIST \
  LIST_ITEM(CLUSTER,     L"MicrosoftNLB_Cluster")              , \
  LIST_ITEM(NODE,        L"MicrosoftNLB_Node")                 , \
  LIST_ITEM(CLUSSET,     L"MicrosoftNLB_ClusterSetting")       , \
  LIST_ITEM(NODESET,     L"MicrosoftNLB_NodeSetting")          , \
  LIST_ITEM(PORTRULE,    L"MicrosoftNLB_PortRule")             , \
  LIST_ITEM(PRFAIL,      L"MicrosoftNLB_PortRuleFailover")     , \
  LIST_ITEM(PRDIS,       L"MicrosoftNLB_PortRuleDisabled")     , \
  LIST_ITEM(PRLOADB,     L"MicrosoftNLB_PortRuleLoadbalanced") , \
  LIST_ITEM(PORTRULE_EX, L"MicrosoftNLB_PortRuleEx")           , \
  LIST_ITEM(PARTNODE,    L"MicrosoftNLB_ParticipatingNode")    , \
  LIST_ITEM(NODESETPR,   L"MicrosoftNLB_NodeSettingPortRule")  , \
  LIST_ITEM(CLUSCLUSSET, L"MicrosoftNLB_ClusterClusterSetting"), \
  LIST_ITEM(NODENODESET, L"MicrosoftNLB_NodeNodeSetting")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_node.h ===
#ifndef _WLBSNODE_INCLUDED_
#define _WLBSNODE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_Node
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_Node : public CWlbs_Root
{
public:
  CWLBS_Node(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );


  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL
                    );

  void FillWbemInstance  ( CWlbsClusterWrapper* pCluster,
  						   IWbemClassObject*    a_pWbemInstance, 
                           WLBS_RESPONSE*       a_pResponse,
                           WLBS_RESPONSE*       a_pResponseLocalComputerName);

  void FindInstance( IWbemClassObject**       a_ppWbemInstance,
                     const ParsedObjectPath*  a_pParsedPath );

  void FindAllInstances(CWlbsClusterWrapper* pCluster,
   						WLBS_RESPONSE** a_ppResponse,
					    long&     a_nNumNodes,
                        WLBS_RESPONSE*  a_pResponseLocalComputerName);

};

#endif //_WLBSNODE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_node.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Node.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"
#include <winsock.h>
#include "wlbs_node.tmh" // for event tracing

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::CWLBS_Node
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_Node::CWLBS_Node(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_Node::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_Node( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::GetInstance
//
// Purpose: Queries WLBS for desired node instance and sends results back
//          to WinMgMt.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::GetInstance
  (
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    //g_pWlbsControl->CheckConfiguration();

    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat  = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::EnumInstances
//
// Purpose: Executes a WlbsQuery and sends data back to WinMgMt.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  WLBS_RESPONSE*      pResponse         = NULL;
  HRESULT hRes = 0;

  BSTR strClassName = NULL;
  long nNumNodes = 0;
  
  //g_pWlbsControl->CheckConfiguration();
  TRACE_CRIT("->%!FUNC!");

  try {

    strClassName = SysAllocString( MOF_NODE::szName );

    if( !strClassName )
    {
        TRACE_CRIT("%!FUNC! SysAllocString failed, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
        throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsNodeClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      strClassName,  
      0,                          
      NULL,                       
      &pWlbsNodeClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
        TRACE_CRIT("%!FUNC! CWbemServices::GetObject failed with error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
       TRACE_INFO("%!FUNC! CWlbsControlWrapper::EnumClusters() returned no clusters, Throwing com_error WBEM_E_NOT_FOUND exception" );
       throw _com_error( WBEM_E_NOT_FOUND );
    }


    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {

        WLBS_RESPONSE ResponseLocalComputerName;

        ResponseLocalComputerName.options.identity.fqdn[0] = UNICODE_NULL;

        //call the API query function to find the nodes
        
        try {
            FindAllInstances(ppCluster[iCluster], &pResponse, nNumNodes, &ResponseLocalComputerName);
        } catch (CErrorWlbsControl Err)
        {
            //
            // Skip this cluster
            //
            TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x, Skipping this cluster : 0x%x", Err.Error(),ppCluster[iCluster]->GetClusterIP());
            continue;
        }
    

        //spawn an instance of the Node MOF class for each node found
        ppWlbsInstance = new IWbemClassObject *[nNumNodes];

        if( !ppWlbsInstance )
        {
            TRACE_CRIT("%!FUNC! new failed, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
            throw _com_error( WBEM_E_OUT_OF_MEMORY );
        }

        //initialize array
        ZeroMemory( ppWlbsInstance, nNumNodes * sizeof(IWbemClassObject *) );

        for(int i = 0; i < nNumNodes; i ++ ) 
        {
            hRes = pWlbsNodeClass->SpawnInstance( 0, &ppWlbsInstance[i] );

            if( FAILED( hRes ) )
            {   
                TRACE_CRIT("%!FUNC! IWbemClassObjectPtr::SpawnInstance failed : 0x%x, Throwing com_error exception", hRes);
                throw _com_error( hRes );
            }

            FillWbemInstance(ppCluster[iCluster], 
                             ppWlbsInstance[i], 
                             pResponse + i, 
                             (i == 0)  // The first entry is always the local node. So, the local computer name must be passed for the first entry.
                             ? &ResponseLocalComputerName
                             : NULL);
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( nNumNodes, ppWlbsInstance );

        if( FAILED( hRes ) ) {
            TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate failed : 0x%x, Throwing com_error exception", hRes);
            throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < nNumNodes; i++ ) {
            if( ppWlbsInstance[i] ) {
                ppWlbsInstance[i]->Release();
            }
          }
            delete [] ppWlbsInstance;
        }

        if( pResponse ) 
        delete [] pResponse;
    }

    if( strClassName )
      SysFreeString(strClassName);

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());
    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( strClassName )
      SysFreeString( strClassName );

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::ExecMethod
//
// Purpose: This executes the methods associated with the MOF
//          Node class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_Node::ExecMethod
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{

  DWORD dwNumHosts = 0;
  DWORD dwReturnValue;

  HRESULT       hRes = 0;

  _variant_t vMofResponse;
  _variant_t vReturnValue;
  _variant_t vVip, vInputPortNumber;
  CNodeConfiguration NodeConfig;
  DWORD      dwVip, dwPort;
  VARIANT    vValue;

  BSTR       strPortNumber = NULL;

  IWbemClassObject* pOutputInstance = NULL;

  TRACE_CRIT("->%!FUNC!, Method Name : %ls",a_strMethodName);

  try {

    strPortNumber = SysAllocString( MOF_PARAM::PORT_NUMBER );

    if( !strPortNumber )
    {
      TRACE_CRIT("%!FUNC! SysAllocString failed, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
      throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    //get the host ID address
    DWORD dwHostID = 0;
    DWORD dwClusterIpOrIndex = 0;
    
    dwHostID = ExtractHostID( wstring( (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal ) );
    if ((DWORD)-1 == dwHostID)
    {
        TRACE_CRIT("%!FUNC! ExtractHostId failed, Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    dwClusterIpOrIndex = ExtractClusterIP( wstring( (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal ) );
    if ((DWORD)-1 == dwClusterIpOrIndex)
    {
        TRACE_CRIT("%!FUNC! ExtractClusterIP failed, Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }
 
    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);

    if (pCluster == NULL)
    {
        TRACE_CRIT("%!FUNC! GetClusterFromIpOrIndex failed, Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }
    
    //always let the provider peform control operations on the local host
    if( dwHostID == pCluster->GetHostID() ) 
      dwHostID    = WLBS_LOCAL_HOST;
    //get the output object instance
    GetMethodOutputInstance( MOF_NODE::szName, 
                             a_strMethodName, 
                             &pOutputInstance );

    //determine and execute the MOF method
    if( _wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DISABLE] ) == 0)  {
    
      if( !a_pIInParams )
      {
        TRACE_CRIT("%!FUNC! No Input parameters passed for %ls method, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
        throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      // The "Disable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }

      //get the port number
      hRes = a_pIInParams->Get
                  (  strPortNumber, 
                     0, 
                     &vInputPortNumber, 
                     NULL, 
                     NULL
                   );

      if( FAILED( hRes ) ) {
        TRACE_CRIT("%!FUNC! Error (0x%x) trying retreive Argument %ls for method %ls, Throwing com_error exception", hRes,strPortNumber, a_strMethodName);
        throw _com_error( hRes );
      }

      //make sure the port number is not NULL
      if( vInputPortNumber.vt != VT_I4) 
      {
        TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
        throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      //call Disable method
      dwReturnValue = g_pWlbsControl->Disable
                        (
                          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                          dwHostID, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          (long)vInputPortNumber
                        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::ENABLE]   ) == 0)  {

      if( !a_pIInParams )
      {
          TRACE_CRIT("%!FUNC! No Input parameters passed for %ls method, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      // The "Enable" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }

      //get the port number
      hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vInputPortNumber, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) ) {
          TRACE_CRIT("%!FUNC! Error (0x%x) trying retreive Argument %ls for method %ls, Throwing com_error exception", hRes,strPortNumber, a_strMethodName);
          throw _com_error( hRes );
      }

      if( vInputPortNumber.vt != VT_I4) 
      {
          TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
          throw _com_error(WBEM_E_INVALID_PARAMETER);
      }

      //call Enable method
      dwReturnValue = g_pWlbsControl->Enable
        (
          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
          dwHostID, 
          NULL, 
          dwNumHosts, 
          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
          (long)vInputPortNumber
        );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAIN]    ) == 0)  {

      if( !a_pIInParams )
      {
          TRACE_CRIT("%!FUNC! No Input parameters passed for %ls method, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
      }

      // The "Drain" method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }

      //get the port number
      hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vInputPortNumber, 
                   NULL, 
                   NULL
                 );

      if( FAILED( hRes ) ) {
          TRACE_CRIT("%!FUNC! Error (0x%x) trying retreive Argument %ls for method %ls, Throwing com_error exception", hRes,strPortNumber, a_strMethodName);
          throw _com_error( hRes );
      }

      if( vInputPortNumber.vt != VT_I4) 
      {
          TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
          throw _com_error(WBEM_E_INVALID_PARAMETER);
      }

      //call Drain method
      dwReturnValue = g_pWlbsControl->Drain
                        (
                          pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                          dwHostID, 
                          NULL, 
                          dwNumHosts, 
                          IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), // "All Vip"
                          (long)vInputPortNumber
                        );

    }else if( _wcsicmp( a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DISABLE_EX] ) == 0)  {

        if( !a_pIInParams )
        {
            TRACE_CRIT("%!FUNC! No Input parameters passed for %ls method, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        // Remote operations are not allowed
        if (dwHostID != WLBS_LOCAL_HOST)
        {
            TRACE_CRIT("%!FUNC! Remote operations are NOT permitted for %ls method, Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
            throw _com_error( WBEM_E_INVALID_OPERATION );
        }

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"BString\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::VIP, a_strMethodName);
            throw _com_error ( WBEM_E_INVALID_PARAMETER );
        }

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(vValue.bstrVal, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
            if (dwVip == INADDR_NONE) 
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for Argument %ls for method %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", vValue.bstrVal, MOF_PARAM::VIP, a_strMethodName);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }

        //get the port number
        hRes = a_pIInParams->Get
                  (  strPortNumber, 
                     0, 
                     &vValue, 
                     NULL, 
                     NULL
                   );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error (0x%x) trying retreive Argument %ls for method %ls, Throwing com_error exception", hRes,strPortNumber, a_strMethodName);
            throw _com_error( hRes );
        }

        //range checking is done by the API
        if( vValue.vt != VT_I4 ) 
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        dwPort = vValue.lVal;

        //call Disable method
        dwReturnValue = g_pWlbsControl->Disable
                          (
                            pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                            dwHostID, 
                            NULL, 
                            dwNumHosts, 
                            dwVip,
                            dwPort
                          );

      } else if(_wcsicmp( a_strMethodName, MOF_NODE::pMethods[MOF_NODE::ENABLE_EX] ) == 0)  {

        if( !a_pIInParams )
        {
            TRACE_CRIT("%!FUNC! No Input parameters passed for %ls method, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        // Remote operations are not allowed
        if (dwHostID != WLBS_LOCAL_HOST)
        {
            TRACE_CRIT("%!FUNC! Remote operations are NOT permitted for %ls method, Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
            throw _com_error( WBEM_E_INVALID_OPERATION );
        }

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"string\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::VIP, a_strMethodName);
            throw _com_error ( WBEM_E_INVALID_PARAMETER );
        }

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(vValue.bstrVal, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
            if (dwVip == INADDR_NONE) 
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for Argument %ls for method %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", vValue.bstrVal, MOF_PARAM::VIP, a_strMethodName);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }

        //get the port number
        hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error (0x%x) trying retreive Argument %ls for method %ls, Throwing com_error exception", hRes,strPortNumber, a_strMethodName);
            throw _com_error( hRes );
        }

        //range checking is done by the API
        if( vValue.vt != VT_I4 ) 
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        dwPort = vValue.lVal;

        //call Enable method
        dwReturnValue = g_pWlbsControl->Enable
          (
            pCluster->GetClusterIpOrIndex(g_pWlbsControl),
            dwHostID, 
            NULL, 
            dwNumHosts, 
            dwVip,
            dwPort
          );

      } else if( _wcsicmp( a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAIN_EX] ) == 0 )  {

        if( !a_pIInParams )
        {
            TRACE_CRIT("%!FUNC! No Input parameters passed for %ls method, Throwing com_error WBEM_E_INVALID_PARAMETER exception", a_strMethodName);
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        // Remote operations are not allowed
        if (dwHostID != WLBS_LOCAL_HOST)
        {
            TRACE_CRIT("%!FUNC! Remote operations are NOT permitted for %ls method, Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
            throw _com_error( WBEM_E_INVALID_OPERATION );
        }

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"BString\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::VIP, a_strMethodName);
            throw _com_error ( WBEM_E_INVALID_PARAMETER );
        }

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(vValue.bstrVal, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
            if (dwVip == INADDR_NONE) 
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for Argument %ls for method %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", vValue.bstrVal, MOF_PARAM::VIP, a_strMethodName);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }

        //get the port number
        hRes = a_pIInParams->Get
                 ( 
                   strPortNumber, 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error (0x%x) trying retreive Argument %ls for method %ls, Throwing com_error exception", hRes,strPortNumber, a_strMethodName);
            throw _com_error( hRes );
        }

        //range checking is done by the API
        if( vValue.vt != VT_I4 ) 
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", strPortNumber, a_strMethodName);
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        dwPort = vValue.lVal;

        //call Drain method
        dwReturnValue = g_pWlbsControl->Drain
                          (
                            pCluster->GetClusterIpOrIndex(g_pWlbsControl),
                            dwHostID, 
                            NULL, 
                            dwNumHosts, 
                            dwVip,
                            dwPort
                          );

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::DRAINSTOP]) == 0)  {

      //call DrainStop method
      dwReturnValue = g_pWlbsControl->DrainStop( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::RESUME]   ) == 0)  {

      //call Resume method
      dwReturnValue = g_pWlbsControl->Resume( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::START]    ) == 0)  {

      //call Start method
      dwReturnValue = g_pWlbsControl->Start( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::STOP]     ) == 0)  {

      //call Stop method
      dwReturnValue = g_pWlbsControl->Stop( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else if(_wcsicmp(a_strMethodName, MOF_NODE::pMethods[MOF_NODE::SUSPEND]  ) == 0)  {

      //call Suspend method
      dwReturnValue = g_pWlbsControl->Suspend( pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
          dwHostID, NULL, dwNumHosts);

    } else {

      TRACE_CRIT("%!FUNC! Invalid method name : %ls, passed. Throwing com_error WBEM_E_METHOD_NOT_IMPLEMENTED exception", a_strMethodName);
      throw _com_error(WBEM_E_METHOD_NOT_IMPLEMENTED);
    }

    //set the return value
    vReturnValue = (long)dwReturnValue;
    hRes = pOutputInstance->Put( _bstr_t(L"ReturnValue"), 0, &vReturnValue, 0 );

    if( FAILED( hRes ) ) {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Put failed : 0x%x for \"ReturnValue\", Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }
    
    //send the results back to WinMgMt
    hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

    if( FAILED( hRes ) ) {
        TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate failed : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());
    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( strPortNumber ) {
      SysFreeString(strPortNumber);
      strPortNumber = NULL;
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the host's data is obtained and returned via the 
//          IWbemClassObject interface.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FindInstance

  ( 
    IWbemClassObject**       a_ppWbemInstance,
    const ParsedObjectPath*  a_pParsedPath
  )

{
  TRACE_VERB("->%!FUNC!");
  try {
    //get the key property
    //throws _com_error
    //get the name key property and convert to ANSI
    //throws _com_error
    wstring szRequestedHostName = ( *a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwClustIpOrIndex = ExtractClusterIP( szRequestedHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL )
    {
        TRACE_CRIT("%!FUNC! GetClusterFromIpOrIndex failed, Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    WLBS_RESPONSE Response;

    DWORD dwHostID = ExtractHostID( szRequestedHostName );
    if ((DWORD)-1 == dwHostID)
    {
        TRACE_CRIT("%!FUNC! ExtractHostId failed, Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    WLBS_RESPONSE    ComputerNameResponse;
    WLBS_RESPONSE * pComputerNameResponse;

    //always let the provider peform control operations on the local host
    if( dwHostID == pCluster->GetHostID() ) 
    {
        dwHostID = WLBS_LOCAL_HOST;
        pComputerNameResponse = &ComputerNameResponse;
        pComputerNameResponse->options.identity.fqdn[0] = UNICODE_NULL;
    }
    else
    {
        pComputerNameResponse = NULL;
    }

    DWORD dwNumHosts  =  1;
    //call the api query function
    g_pWlbsControl->Query( pCluster,
                           dwHostID  , 
                           &Response   , 
                           pComputerNameResponse,  // Query the local host's fqdn
                           &dwNumHosts, 
                           NULL );

    if( dwNumHosts == 0 )
    {
        TRACE_CRIT("%!FUNC! CWlbsControlWrapper::Query() returned zero hosts, Throwing com_error WBEM_E_NOT_FOUND exception");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    //if requested, fill a MOF instance structure
    if(a_ppWbemInstance) {

      //get the Wbem class instance
      SpawnInstance( MOF_NODE::szName, a_ppWbemInstance );

      //Convert status to string description
      FillWbemInstance(pCluster, *a_ppWbemInstance, &Response, pComputerNameResponse);

    }
  }
  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    if( *a_ppWbemInstance ) {

      delete *a_ppWbemInstance;
      *a_ppWbemInstance = NULL;

    }

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_VERB("<-%!FUNC!");
    throw;

  }
  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FindAllInstances
//
// Purpose: This executes a WLBS query and returns Response structures upon
//          success. It always performs a local query to get the local host
//          so that disabling remote control will not prevent it from
//          enumerating. The dedicated IP address is added to the structure
//          within the CWlbsControlWrapper::Query call.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FindAllInstances
  (
  CWlbsClusterWrapper* pCluster,
  WLBS_RESPONSE**      a_ppResponse,
 long&                 a_nNumNodes,
  WLBS_RESPONSE*       a_pResponseLocalComputerName
  )
{
  WLBS_RESPONSE Response[WLBS_MAX_HOSTS];
  WLBS_RESPONSE LocalResponse;

  TRACE_VERB("->%!FUNC!");

  ASSERT(pCluster);
  
  ZeroMemory(Response, WLBS_MAX_HOSTS * sizeof(WLBS_RESPONSE));
  DWORD dwNumHosts  =  WLBS_MAX_HOSTS;

  a_nNumNodes = 0;  //this will contain the number of nodes returned

  try {


      //get the local host
      DWORD dwLocalNode = 1;
      g_pWlbsControl->Query( pCluster,
                               WLBS_LOCAL_HOST, 
                               &LocalResponse, 
                               a_pResponseLocalComputerName, // Query the local computer's fqdn as well
                               &dwLocalNode, 
                               NULL);

      try {

          //we only want remote hosts
          if( pCluster->GetClusterIP() != 0 ) 
          {
              g_pWlbsControl->Query( pCluster,
                                     WLBS_ALL_HOSTS, 
                                     Response, 
                                     NULL,
                                     &dwNumHosts, 
                                     NULL );
          } 
          else 
          {
              dwNumHosts = 0;
          }
      } catch (CErrorWlbsControl Err) {

          TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

          dwNumHosts = 0;
          if (Err.Error() != WLBS_TIMEOUT)
          {
              TRACE_CRIT("%!FUNC! Rethrowing exception since it is NOT a WLBS_TIMEOUT");
              throw;
          }
      }

      //this wastes memory if the local node
      //has remote control enabled
      a_nNumNodes = dwNumHosts + 1;

      if( a_ppResponse ) {
          *a_ppResponse = new WLBS_RESPONSE[a_nNumNodes];

          if( !*a_ppResponse )
          {
              TRACE_CRIT("%!FUNC! new failed a_nNumNodes = 0x%x, sizeof(WLBS_RESPONSE) = 0x%x, Throwing com_error WBEM_E_OUT_OF_MEMORY exception",a_nNumNodes, sizeof(WLBS_RESPONSE));
              throw _com_error( WBEM_E_OUT_OF_MEMORY );
          }

            //copy the local host
          (*a_ppResponse)[0] = LocalResponse;

          int j = 1;
          for(DWORD i = 1; i <= dwNumHosts; i++ ) 
          {
            //do not copy the local host again should it have remote control enabled
            if( Response[i-1].id == LocalResponse.id ) 
            {
              //we received the local node twice, so we reduce the count
              //by one
              a_nNumNodes--;
              continue;
            }
            (*a_ppResponse)[j] = Response[i-1];
            j++;
          }

        }
  } catch (...) {

      TRACE_CRIT("%!FUNC! Caught an exception");

      if ( *a_ppResponse )
      {
          delete [] *a_ppResponse;
          *a_ppResponse = NULL;
      }

      TRACE_CRIT("%!FUNC! Rethrowing exception");
      TRACE_VERB("<-%!FUNC!");
      throw;
  }

  TRACE_VERB("<-%!FUNC!");
}



////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_Node::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_Node::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    WLBS_RESPONSE*   a_pResponse,   
    WLBS_RESPONSE*   a_pResponseLocalComputerName
  )
{
  namespace NODE = MOF_NODE;

  TRACE_VERB("->%!FUNC!");

  ASSERT( a_pWbemInstance );
  ASSERT( a_pResponse );

  wstring wstrHostName;

  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      a_pResponse->id );

  //HOST NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NODE::pProperties[NODE::NAME] ) ,
      0                                        ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //HOST ID
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::HOSTID] )         ,
      0                                                  ,
      &_variant_t((long)(a_pResponse->id)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //CREATCLASS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CREATCLASS] ),
      0                                            ,
      &_variant_t(NODE::szName),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //IP ADDRESS
  wstring szIPAddress;
  AddressToString( a_pResponse->address, szIPAddress );
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::IPADDRESS] ),
      0                                            ,
      &_variant_t(szIPAddress.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //STATUS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::STATUS] )         ,
      0                                                  ,
      &_variant_t((long)a_pResponse->status),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //COMPUTER NAME 
  WCHAR *szComputerName;

  if (a_pResponseLocalComputerName) {
      szComputerName = a_pResponseLocalComputerName->options.identity.fqdn;
  }
  else if (a_pResponse->options.query.flags & NLB_OPTIONS_QUERY_HOSTNAME) {
      szComputerName = a_pResponse->options.query.hostname;
  }
  else{
      szComputerName = L"";
  }
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::COMPUTERNAME] )   ,
      0                                                  ,
      &_variant_t(szComputerName),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_nodenodesetting.h ===
#ifndef _CLUSCLUSSETTING_INCLUDED_
#define _CLUSCLUSSETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_NodeNodeSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_NodeNodeSetting : public CWlbs_Root
{
public:
  CWLBS_NodeNodeSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

private:

  //methods
  void FillWbemInstance  (CWlbsClusterWrapper* pCluster,
  							IWbemClassObject* a_pWbemInstance );

  void FindInstance( IWbemClassObject**      a_ppWbemInstance );

};

#endif //_CLUSCLUSSETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_mofdata.h ===
//WLBS_MOFData.h
#ifndef _WLBSMOFDATA_INCLUDED_
#define _WLBSMOFDATA_INCLUDED_

#include "WLBS_MofLists.h"

//forward declaration
class CWlbs_Root;

typedef CWlbs_Root* (*PCREATE)(CWbemServices*   a_pNameSpace, 
                               IWbemObjectSink* a_pResponseHandler);

namespace MOF_CLASSES
{
  enum { MOF_CLASS_LIST };
  extern LPWSTR  g_szMOFClassList[];
  extern PCREATE g_pCreateFunc[];
  extern DWORD  NumClasses;
};


//MOF_NODE namespace declaration
namespace MOF_NODE
{
  enum{MOF_NODE_PROPERTY_LIST};
  enum{MOF_NODE_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_NODE_PROPERTY_LIST
#undef MOF_NODE_METHOD_LIST

//MOF_CLUSTER namespace declaration
namespace MOF_CLUSTER
{
  enum{MOF_CLUSTER_PROPERTY_LIST};
  enum{MOF_CLUSTER_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_CLUSTER_PROPERTY_LIST
#undef MOF_CLUSTER_METHOD_LIST

//MOF_CLUSTERSETTING namespace declaration
namespace MOF_CLUSTERSETTING
{
  enum{MOF_CLUSTERSETTING_PROPERTY_LIST};
  enum{MOF_CLUSTERSETTING_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_CLUSTERSETTING_PROPERTY_LIST
#undef MOF_CLUSTERSETTING_METHOD_LIST

//MOF_NODESETTING namespace declaration
namespace MOF_NODESETTING
{
  enum{MOF_NODESETTING_PROPERTY_LIST};
  enum{MOF_NODESETTING_METHOD_LIST};

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern LPWSTR pMethods[];
  extern DWORD  NumProperties;
  extern DWORD  NumMethods;

};

#undef MOF_NODESETTING_PROPERTY_LIST
#undef MOF_NODESETTING_METHOD_LIST

//MOF_PORTRULE namespace initialization
namespace MOF_PORTRULE
{
  enum { MOF_PORTRULE_PROPERTY_LIST };
  enum {MOF_PORTRULE_METHOD_LIST};

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern LPWSTR   pMethods[];
  extern DWORD    NumProperties;
  extern DWORD    NumMethods;
};

#undef MOF_PORTRULE_PROPERTY_LIST

//MOF_PRFAIL namespace initialization
namespace MOF_PRFAIL
{
  enum { MOF_PRFAIL_PROPERTY_LIST };

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern DWORD    NumProperties;
};

#undef MOF_PRFAIL_PROPERTY_LIST

//MOF_PRLOADBAL namespace initialization
namespace MOF_PRLOADBAL
{
  enum { MOF_PRLOADBAL_PROPERTY_LIST };

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern DWORD    NumProperties;
};

#undef MOF_PRLOADBAL_PROPERTY_LIST

namespace MOF_PRDIS
{
  extern LPWSTR   szName;
};

//MOF_PORTRULE_EX namespace initialization
namespace MOF_PORTRULE_EX
{
  enum { MOF_PORTRULE_EX_PROPERTY_LIST };
  enum {MOF_PORTRULE_EX_METHOD_LIST};

  extern LPWSTR   szName;
  extern LPWSTR   pProperties[];
  extern LPWSTR   pMethods[];
  extern DWORD    NumProperties;
  extern DWORD    NumMethods;
};

#undef MOF_PORTRULE_EX_PROPERTY_LIST
#undef MOF_PORTRULE_EX_METHOD_LIST

//MOF_PARTICIPATINGNODE namespace initialization
namespace MOF_PARTICIPATINGNODE
{
  enum { MOF_PARTICIPATINGNODE_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};

#undef MOF_PARTICIPATINGNODE_PROPERTY_LIST

//MOF_NODESETTINGPORTRULE namespace initialization
namespace MOF_NODESETTINGPORTRULE
{
  enum { MOF_NODESETTINGPORTRULE_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_NODESETTINGPORTRULE_PROPERTY_LIST

//MOF_CLUSCLUSSETTING namespace initialization
namespace MOF_CLUSCLUSSETTING
{
  enum { MOF_CLUSCLUSSETTING_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_CLUSCLUSSETTING_PROPERTY_LIST

//MOF_NODENODESETTING namespace initialization
namespace MOF_NODENODESETTING
{
  enum { MOF_NODENODESETTING_PROPERTY_LIST };

  extern LPWSTR szName;
  extern LPWSTR pProperties[];
  extern DWORD  NumProperties;
};
#undef MOF_NODENODESETTING_PROPERTY_LIST

//MOF_PARAM namespace declaration
namespace MOF_PARAM
{
  extern LPWSTR PORT_NUMBER;
  extern LPWSTR HOST_ID;
  extern LPWSTR NUM_NODES;
  extern LPWSTR CLUSIP;
  extern LPWSTR CLUSNETMASK;
  extern LPWSTR PASSW;
  extern LPWSTR DEDIP;
  extern LPWSTR DEDNETMASK;
  extern LPWSTR PORTRULE;
  extern LPWSTR NODEPATH;
  extern LPWSTR VIP;
};

#endif //_WLBSMOFDATA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_nodesetportrule.h ===
#ifndef _NODESETPORTRULE_INCLUDED_
#define _NODESETPORTRULE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_NodeSetPortRule
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_NodeSetPortRule : public CWlbs_Root
{
public:
  CWLBS_NodeSetPortRule(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances ( 
                          BSTR             a_bstrClass         = NULL,
                          long             a_lFlags            = 0, 
                          IWbemContext*    a_pIContex          = NULL
                        );

private:

  //methods
  void FillWbemInstance  ( CWlbsClusterWrapper* pCluster,
  						   IWbemClassObject* a_pWbemInstance, 
                           PWLBS_PORT_RULE   a_pPortRule    );

  void FindInstance( IWbemClassObject**       a_ppWbemInstance,
                     const ParsedObjectPath*  a_pParsedPath );

  //void FindAllInstances( WLBS_RESPONSE**      a_ppResponse,
	//				               long&                 a_nNumNodes );
};

#endif //_NODESETPORTRULE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_nodenodesetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeNodeSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::CWLBS_NodeNodeSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeNodeSetting::CWLBS_NodeNodeSetting(CWbemServices* a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeNodeSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_NodeNodeSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeNodeSetting::GetInstance
  (
    const ParsedObjectPath* /* a_pParsedPath */,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
    //get the node
    //FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::EnumInstances
//
// Purpose: This verifies node existence and constructs associator.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeNodeSetting::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance    = NULL;
  HRESULT hRes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i < dwNumClusters; i++)
    {
        //spawn an instance of the associator
        SpawnInstance(MOF_NODENODESETTING::szName, &pWlbsInstance );

        FillWbemInstance(ppCluster[i] , pWlbsInstance);

        //send the results back to WinMgMt
        hRes= m_pResponseHandler->Indicate( 1, &pWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( pWlbsInstance )
          pWlbsInstance->Release();
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the requested associator is returned.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeNodeSetting::FindInstance
  ( 
    IWbemClassObject**       /*a_ppWbemInstance*/
  )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeNodeSetting::FillWbemInstance
//
// Purpose: This constructs the wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeNodeSetting::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance
  )
{
  namespace NNS = MOF_NODENODESETTING;

  ASSERT( a_pWbemInstance );

  ParsedObjectPath NodeSetPath;
  ParsedObjectPath NodePath;
  LPWSTR           szNodeSetPath = NULL;
  LPWSTR           szNodePath = NULL;

  try {

  //set the names of the classes
  if( !NodeSetPath.SetClassName( MOF_NODESETTING::szName ) )
    throw _com_error( WBEM_E_FAILED );

  if( !NodePath.SetClassName( MOF_NODE::szName ) )
    throw _com_error( WBEM_E_FAILED );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //set the keys for the node and cluster
  if( !NodeSetPath.AddKeyRef( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME],
         &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );

  if( !NodePath.AddKeyRef( MOF_NODE::pProperties[MOF_NODE::NAME],
         &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&NodeSetPath, &szNodeSetPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&NodePath,    &szNodePath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node reference
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NNS::pProperties[NNS::NODESET] ),
      0,
      &_variant_t(szNodeSetPath),
      NULL
    );
  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Cluster reference
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NNS::pProperties[NNS::NODE] ),
      0,
      &_variant_t(szNodePath),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  NodePath.ClearKeys();
  NodeSetPath.ClearKeys();

  if( szNodePath )
      delete (szNodePath );
 
  if( szNodeSetPath )
    delete (szNodeSetPath);

  } catch (...) {

    NodePath.ClearKeys();
    NodeSetPath.ClearKeys();

    if( szNodePath )
      delete (szNodePath);

    if( szNodeSetPath )
      delete (szNodeSetPath);

      throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_nodesetportrule.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeSetPortRule.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::CWLBS_NodeSetPortRule
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeSetPortRule::CWLBS_NodeSetPortRule(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeSetPortRule::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_NodeSetPortRule( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetPortRule::GetInstance
  (
    const ParsedObjectPath* /* a_pParsedPath */,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::EnumInstances
//
// Purpose: Queries WLBS for desired node instances then constructs an 
//          an associator for each node found.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetPortRule::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  PWLBS_PORT_RULE      pPortRules     = NULL;
  DWORD                dwNumRules     = 0;
  HRESULT              hRes           = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      _bstr_t( MOF_NODESETTINGPORTRULE::szName ),  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }
    
    for (DWORD iCluster=0; iCluster < dwNumClusters; iCluster++)
    {

        // The "NodeSettingPortRule" class associates an instance of "NodeSetting" class
        // with an instance of "PortRule" class. The PortRule class does NOT contain
        // VIP as a property, so we do not want to return any instance of the "NodeSettingPortRule" 
        // class that associates a port rule that is specific to a vip (other than the "all vip").
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        ppCluster[iCluster]->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            continue;

        //call the API query function to find all the port rules
         ppCluster[iCluster]->EnumPortRules( &pPortRules, &dwNumRules, 0 );

         if( dwNumRules == 0 )
           continue;


        //spawn an instance of the nodesetting portrule associator
        //for each portrule found
        ppWlbsInstance = new IWbemClassObject *[dwNumRules];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, dwNumRules * sizeof(IWbemClassObject *) );

        for(DWORD i = 0; i < dwNumRules; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

        if( FAILED( hRes ) )
            throw _com_error( hRes );

        FillWbemInstance(ppCluster[iCluster], *(ppWlbsInstance + i), pPortRules + i );
        }
         //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( dwNumRules, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < dwNumRules; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
        }

        if( pPortRules ) 
          delete [] pPortRules;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for(DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for(DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( ppWlbsInstance ) {
      for(DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::FindInstance
//
// Purpose: Returns the requested associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetPortRule::FindInstance

  ( 
    IWbemClassObject**       /* a_ppWbemInstance */,
    const ParsedObjectPath*  /* a_pParsedPath */
  )

{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetPortRule::FillWbemInstance
//
// Purpose: This constructs the ParticipatingNode wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetPortRule::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    PWLBS_PORT_RULE   a_pPortRule   
  )
{
  namespace NSPR = MOF_NODESETTINGPORTRULE;

  ASSERT( a_pWbemInstance );
  ASSERT( a_pPortRule );

  ParsedObjectPath NodeSetPath;
  ParsedObjectPath PRPath;
  LPWSTR           szNodeSetPath = NULL;
  LPWSTR           szPRPath      = NULL;

  try {

  //set the names of the classes
  if( !NodeSetPath.SetClassName( MOF_NODESETTING::szName ) )
    throw _com_error( WBEM_E_FAILED );

  //determine the type of port rule to create
  switch( a_pPortRule->mode ) {
    case WLBS_SINGLE:
      if( !PRPath.SetClassName( MOF_PRFAIL::szName ) )
        throw _com_error( WBEM_E_FAILED );
      break;
    case WLBS_MULTI:
      if( !PRPath.SetClassName( MOF_PRLOADBAL::szName ) )
        throw _com_error( WBEM_E_FAILED );
      break;
    case WLBS_NEVER:
      if( !PRPath.SetClassName( MOF_PRDIS::szName ) )
        throw _com_error( WBEM_E_FAILED );
      break;
    default:
      throw _com_error( WBEM_E_FAILED );

  }

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  
  //set the keys for the node setting
  if( !NodeSetPath.AddKeyRef( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME],
               &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );

  //set the keys for the port rule
  if( !PRPath.AddKeyRef( MOF_PORTRULE::pProperties[MOF_PORTRULE::NAME],
               &_variant_t(wstrHostName.c_str())) )
    throw _com_error( WBEM_E_FAILED );

  //start port key
  if( !PRPath.AddKeyRef( MOF_PORTRULE::pProperties[MOF_PORTRULE::STPORT],
               &_variant_t((long)a_pPortRule->start_port)) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&NodeSetPath, &szNodeSetPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&PRPath,      &szPRPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node setting reference
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( NSPR::pProperties[NSPR::NODESET] ),
      0,
      &_variant_t(szNodeSetPath),
      NULL
    );
  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Port rule reference
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NSPR::pProperties[NSPR::PORTRULE] ),
      0,
      &_variant_t(szPRPath),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  NodeSetPath.ClearKeys();
  PRPath.ClearKeys();

  if( szNodeSetPath )
    delete (szNodeSetPath);

  if( szPRPath )
    delete (szPRPath);

  } catch (...) {

  NodeSetPath.ClearKeys();
  PRPath.ClearKeys();

  if( szNodeSetPath )
    delete (szNodeSetPath);

  if( szPRPath )
    delete (szPRPath);

    throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_participatingnode.h ===
#ifndef _PARTICIPATINGNODE_INCLUDED_
#define _PARTICIPATINGNODE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_ParticipatingNode
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node class.
//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_ParticipatingNode : public CWlbs_Root
{
public:
  CWLBS_ParticipatingNode(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);
  ~CWLBS_ParticipatingNode();

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

private:

  //data
  CWLBS_Node*     m_pNode;   

  //methods
  void FillWbemInstance  ( CWlbsClusterWrapper* pCluster,
  						   IWbemClassObject*   a_pWbemInstance, 
                           WLBS_RESPONSE*     a_pResponse    );

  void FindInstance( IWbemClassObject**       a_ppWbemInstance,
                     const ParsedObjectPath*  a_pParsedPath );

  //void FindAllInstances( WLBS_RESPONSE**      a_ppResponse,
	//				               long&                 a_nNumNodes );
};

#endif //_PARTICIPATINGNODE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_nodesetting.h ===
#ifndef _NODESETTING_INCLUDED_
#define _NODESETTING_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_NodeSetting
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node configuration class.

//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_NodeSetting : public CWlbs_Root
{
public:

  CWLBS_NodeSetting(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                      );

  HRESULT EnumInstances( 
                          BSTR             a_bstrClass         = NULL,
                          long             a_lFlags            = 0, 
                          IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT PutInstance( 
                       IWbemClassObject* a_pInstance,
                       long              a_lFlags            = 0,
                       IWbemContext*     a_pIContex          = NULL
                     );

  HRESULT ExecMethod( 
                      const ParsedObjectPath* a_pParsedPath  , 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags            = 0, 
                      IWbemContext*           a_pIContex          = NULL, 
                      IWbemClassObject*       a_pIInParams        = NULL 
                    );

private:

  void FillWbemInstance( CWlbsClusterWrapper* pCluster,
		IWbemClassObject*   a_pWbemInstance );

  void UpdateConfiguration(CWlbsClusterWrapper* pCluster,
  						IWbemClassObject* a_pInstance );

};

#endif //_NODESETTING_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_participatingnode.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_ParticipatingNode.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::CWLBS_ParticipatingNode
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ParticipatingNode::CWLBS_ParticipatingNode(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: CWlbs_Root( a_pNameSpace, a_pResponseHandler ), m_pNode(NULL)
{

  m_pNode    = new CWLBS_Node   ( a_pNameSpace, a_pResponseHandler );
  if( !m_pNode )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::~CWLBS_ParticipatingNode
//
// Purpose: Destructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_ParticipatingNode::~CWLBS_ParticipatingNode()
{

  if( m_pNode )
    delete m_pNode;

}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_ParticipatingNode::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  g_pWlbsControl->CheckMembership();

  CWlbs_Root* pRoot = new CWLBS_ParticipatingNode( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::GetInstance
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ParticipatingNode::GetInstance
  (
   const ParsedObjectPath* /* a_pParsedPath */,
   long                    /* a_lFlags */,
   IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT           hRes          = 0;

  try {

    //TODO: remove
    throw _com_error( WBEM_E_NOT_SUPPORTED );
/*
    //get the node
    FindInstance( &pWlbsInstance, a_pParsedPath );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {
      pWlbsInstance->Release();
      pWlbsInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );
*/
    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    if( pWlbsInstance )
      pWlbsInstance->Release();

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::EnumInstances
//
// Purpose: Queries WLBS for desired node instances then constructs an 
//          an associator for each node found.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_ParticipatingNode::EnumInstances
  ( 
    BSTR             /* a_bstrClass */,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject**   ppWlbsInstance    = NULL;
  WLBS_RESPONSE*      pResponse         = NULL;
  HRESULT              hRes              = 0;

  long nNumNodes = 0;

  try {

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      _bstr_t( MOF_PARTICIPATINGNODE::szName ),  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      throw _com_error( hRes );
    }

    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {
        //call the API query function to find the nodes
        try {
            m_pNode->FindAllInstances(ppCluster[iCluster], &pResponse, nNumNodes, NULL );
        } catch (CErrorWlbsControl Err)  {

            //
            // Skip this cluster
            //
            continue;
        }

        //spawn an instance of the participating node associator
        //for each node found
        ppWlbsInstance = new IWbemClassObject *[nNumNodes];

        if( !ppWlbsInstance )
          throw _com_error( WBEM_E_OUT_OF_MEMORY );

        //initialize array
        ZeroMemory( ppWlbsInstance, nNumNodes * sizeof(IWbemClassObject *) );

        for(int i = 0; i < nNumNodes; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

          if( FAILED( hRes ) )
            throw _com_error( hRes );

          FillWbemInstance(ppCluster[iCluster], *(ppWlbsInstance + i), pResponse + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( nNumNodes, ppWlbsInstance );

        if( FAILED( hRes ) ) {
          throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < nNumNodes; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
        }

        if( pResponse ) 
          delete [] pResponse;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    hRes = HResErr.Error();
  }

  catch(...) {

    if( ppWlbsInstance ) {
      for(int i = 0; i < nNumNodes; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pResponse ) 
      delete [] pResponse;

    throw;

  }

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::FindInstance
//
// Purpose: This routine determines if a host is within the local cluster. If
//          it is, then the requested associator is returned.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ParticipatingNode::FindInstance

  ( 
    IWbemClassObject**       /* a_ppWbemInstance */,
    const ParsedObjectPath*  /* a_pParsedPath */
  )

{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_ParticipatingNode::FillWbemInstance
//
// Purpose: This constructs the ParticipatingNode wbem associator.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_ParticipatingNode::FillWbemInstance
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pWbemInstance, 
    WLBS_RESPONSE*   a_pResponse   
  )
{
  namespace PNODE = MOF_PARTICIPATINGNODE;

  ASSERT( a_pWbemInstance );
  ASSERT( a_pResponse );


  ParsedObjectPath NodePath;
  ParsedObjectPath ClusterPath;
  LPWSTR           szNodePath    = NULL;
  LPWSTR           szClusterPath = NULL;

  try {

  //set the names of the classes
  if( !NodePath.SetClassName( MOF_NODE::szName ) )
    throw _com_error( WBEM_E_FAILED );

  if( !ClusterPath.SetClassName( MOF_CLUSTER::szName ) )
    throw _com_error( WBEM_E_FAILED );

  //Get the node name

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      a_pResponse->id );

  //Get the cluster name
  wstring wstrClusterName;
  AddressToString( pCluster->GetClusterIpOrIndex(g_pWlbsControl), wstrClusterName );

  //set the keys for the node and cluster
  if( !NodePath.AddKeyRef( MOF_NODE::pProperties[MOF_NODE::NAME],
               &_variant_t(wstrHostName.c_str()) ) )
    throw _com_error( WBEM_E_FAILED );


  if( !ClusterPath.AddKeyRef( MOF_CLUSTER::pProperties[MOF_CLUSTER::NAME],
               &_variant_t(wstrClusterName.c_str())) )
    throw _com_error( WBEM_E_FAILED );

  //convert parsed object paths to strings
  if (CObjectPathParser::Unparse(&NodePath,    &szNodePath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );
  if (CObjectPathParser::Unparse(&ClusterPath, &szClusterPath) != CObjectPathParser::NoError)
      throw _com_error( WBEM_E_FAILED );

  //Node reference
  HRESULT hRes = a_pWbemInstance->Put
    (
      
      _bstr_t( PNODE::pProperties[PNODE::NODE] ),
      0,
      &_variant_t(szNodePath),
      NULL
    );
  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //Cluster reference
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PNODE::pProperties[PNODE::CLUSTER] ),
      0,
      &_variant_t(szClusterPath),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //free resources
  ClusterPath.ClearKeys();
  NodePath.ClearKeys();

  if( szNodePath )
    delete (szNodePath);

  if( szClusterPath )
    delete (szClusterPath);

  } catch (...) {

    ClusterPath.ClearKeys();
    NodePath.ClearKeys();

    if( szNodePath )
      delete (szNodePath);

    if( szClusterPath )
      delete (szClusterPath);

    throw;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_portrule.h ===
#ifndef _PORTRULE_INCLUDED_
#define _PORTRULE_INCLUDED_

#include "WLBS_Root.h"

////////////////////////////////////////////////////////////////////////////////
//
// class CWLBS_PortRule
//
// Purpose: This class executes IWbemServices methods on behalf of the provider
//          and supports the MOF node configuration class.

//
//
////////////////////////////////////////////////////////////////////////////////
class CWLBS_PortRule : public CWlbs_Root
{
public:

  CWLBS_PortRule(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);

  static CWlbs_Root* Create(
                             CWbemServices*   a_pNameSpace, 
                             IWbemObjectSink* a_pResponseHandler
                           );

  HRESULT GetInstance( 
                       const ParsedObjectPath* a_pParsedPath,
                       long                    a_lFlags            = 0,
                       IWbemContext*           a_pIContex          = NULL
                     );

  HRESULT DeleteInstance( 
                          const ParsedObjectPath* a_pParsedPath,
                          long                    a_lFlags            = 0,
                          IWbemContext*           a_pIContex          = NULL
                        );

  HRESULT PutInstance( 
                       IWbemClassObject* a_pInstance,
                       long              a_lFlags            = 0,
                       IWbemContext*     a_pIContex          = NULL
                     );

  HRESULT EnumInstances( 
                         BSTR             a_bstrClass         = NULL,
                         long             a_lFlags            = 0, 
                         IWbemContext*    a_pIContex          = NULL
                       );

  HRESULT ExecMethod(
                      const ParsedObjectPath* a_pParsedPath, 
                      const BSTR&             a_strMethodName, 
                      long                    a_lFlags, 
                      IWbemContext*           a_pIContex, 
                      IWbemClassObject*       a_pIInParams
                    );

  static void FillWbemInstance( LPCWSTR              a_szClassName,
                                CWlbsClusterWrapper* pCluster,
                                IWbemClassObject*      a_pWbemInstance, 
                                const PWLBS_PORT_RULE& a_pPortRule );

private:

};

#endif //_PORTRULE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_nodesetting.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_NodeSetting.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"
#include <winsock.h>
#include "WLBS_NodeSetting.tmh"

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::CWLBS_NodeSetting
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_NodeSetting::CWLBS_NodeSetting
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_NodeSetting::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_NodeSetting( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::GetInstance
//
// Purpose: This function retrieves an instance of a MOF NodeSetting 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::GetInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    //get the name key property and convert to wstring
    const wchar_t* wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    DWORD dwHostID = ExtractHostID( wstrHostName );

    if (pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
    {
        TRACE_CRIT("%!FUNC! (GetClusterFromHostName (Host Name : %ls) or ExtractHostID (Host Id : %d)) failed or Host Id does NOT match, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName, dwHostID);
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    //get the Wbem class instance
    SpawnInstance( MOF_NODESETTING::szName, &pWlbsInstance );

    //Convert status to string description
    FillWbemInstance(pCluster, pWlbsInstance );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    //if( pWbemExtStat )
      //pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());
    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
    
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    if( pWlbsInstance )
      pWlbsInstance->Release();

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::EnumInstances
//
// Purpose: This function obtains the NodeSetting data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::EnumInstances
  ( 
    BSTR             /*a_bstrClass*/,
    long             /* a_lFlags */, 
    IWbemContext*    /* a_pIContex */
  )
{
  IWbemClassObject*    pWlbsInstance = NULL;
  HRESULT              hRes          = 0;

  TRACE_CRIT("->%!FUNC!");

  try {


    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      TRACE_CRIT("%!FUNC! CWlbsControlWrapper::EnumClusters() returned no clusters, Throwing com_error WBEM_E_NOT_FOUND exception");
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    for (DWORD i=0; i<dwNumClusters; i++)
    {
        //get the Wbem class instance
        SpawnInstance( MOF_NODESETTING::szName, &pWlbsInstance );

        //Convert status to string description
        FillWbemInstance(ppCluster[i], pWlbsInstance );

        //send the results back to WinMgMt
        m_pResponseHandler->Indicate( 1, &pWlbsInstance );
    }

    if( pWlbsInstance ) {

      pWlbsInstance->Release();
      pWlbsInstance = NULL;

    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());
    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
    if( hRes == ERROR_FILE_NOT_FOUND )
      hRes = WBEM_E_NOT_FOUND;
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    if( pWlbsInstance )
      pWlbsInstance->Release();

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::PutInstance
//
// Purpose: This function updates an instance of a MOF NodeSetting 
//          class. The node does not have to be a member of a cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::PutInstance
  ( 
   IWbemClassObject* a_pInstance,
   long              /* a_lFlags */,
   IWbemContext*     /* a_pIContex */
  ) 
{
  VARIANT vHostName;
  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    VariantInit( &vHostName );

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME] ),
                             0,
                             &vHostName,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
    {
      TRACE_CRIT("%!FUNC! Error trying to retreive %ls property, IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",MOF_NODESETTING::pProperties[MOF_NODESETTING::NAME], hRes);
      throw _com_error( hRes );
    }

    wstring wstrHostName( vHostName.bstrVal );
     
    DWORD dwClustIpOrIndex = ExtractClusterIP( wstrHostName );
    DWORD dwHostID = ExtractHostID( wstrHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
    {
        TRACE_CRIT("%!FUNC! (GetClusterFromIpOrIndex (Host Name : %ls) or ExtractHostID (Host Id : %d)) failed or Host Id does NOT match, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName.data(), dwHostID);
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    UpdateConfiguration(pCluster, a_pInstance );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vHostName ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    hRes = HResErr.Error();
  }

  catch (...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vHostName );

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_NodeSetting::ExecMethod    
  ( 
    const ParsedObjectPath* a_pParsedPath , 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*          /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams 
  ) 
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  IWbemClassObject* pWbemPortRule = NULL;
  HRESULT           hRes = 0;
  CNodeConfiguration NodeConfig;

  VARIANT           vValue ;

  TRACE_CRIT("->%!FUNC!");

  try {
    VariantInit( &vValue );
    
    VARIANT vHostName ;
    VariantInit( &vHostName );

    if (a_pParsedPath->m_paKeys == NULL)
    {
        // 
        // No name specified
        //
        TRACE_CRIT("%!FUNC! Key (Clsuter IP) is not specified, Throwing com_error WBEM_E_INVALID_PARAMETER exception");
        throw _com_error( WBEM_E_INVALID_PARAMETER );
    }
    wstring  wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    DWORD dwClustIpOrIndex = ExtractClusterIP( wstrHostName );
    DWORD dwHostID = ExtractHostID( wstrHostName );

    CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(dwClustIpOrIndex);

    if( pCluster == NULL || (DWORD)-1 == dwHostID || pCluster->GetHostID() != dwHostID)
    {
        TRACE_CRIT("%!FUNC! (GetClusterFromIpOrIndex (Host Name : %ls) or ExtractHostID (Host Id : %d)) failed or Host Id does NOT match, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName.data(), dwHostID);
        throw _com_error( WBEM_E_NOT_FOUND );
    }


    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::GETPORT] ) == 0 )  {
      WLBS_PORT_RULE PortRule;

      // The GetPort method does NOT take vip as a parameter, so, if there is any port rule
      // that is specific to a vip (other than the "all vip"), we fail this method.
      // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
      // see of there is any port rule that is specific to a vip
      pCluster->GetNodeConfig(NodeConfig);
      if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
      {
          TRACE_CRIT("%!FUNC! %ls method called on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName);
          throw _com_error( WBEM_E_INVALID_OPERATION );
      }

      //get the output object instance
      GetMethodOutputInstance( MOF_NODESETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      //get the Port
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::PORT_NUMBER ), 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( vValue.vt != VT_I4 )
      {
        TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::PORT_NUMBER, a_strMethodName);
        throw _com_error ( WBEM_E_INVALID_PARAMETER );
      }

      // Get the "All Vip" port rule for this vip
      pCluster->GetPortRule(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP), static_cast<DWORD>( vValue.lVal ), &PortRule );
      
      //create the appropriate port rule class
      switch( PortRule.mode ) {
        case WLBS_SINGLE:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRFAIL], pCluster, pWbemPortRule, &PortRule );
          break;

        case WLBS_MULTI:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRLOADB], pCluster, pWbemPortRule, &PortRule );
          break;

        case WLBS_NEVER:
          SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS], &pWbemPortRule  );
          CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PRDIS], pCluster, pWbemPortRule, &PortRule );
          break;
      }

      vValue.vt = VT_UNKNOWN;
      vValue.punkVal = pWbemPortRule;
      pWbemPortRule->AddRef();

      hRes = pOutputInstance->Put( _bstr_t(MOF_PARAM::PORTRULE),
                                   0,
                                   &vValue,
                                   0 );


      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vValue ))
      {
          TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
          throw _com_error( WBEM_E_FAILED );
      }

      if( FAILED( hRes ) )
      {
          TRACE_CRIT("%!FUNC! IWbemClassObject::Put() returned error : 0x%x, Throwing com_error exception", hRes);
          throw _com_error( hRes );
      }

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate() returned error : 0x%x, Throwing com_error exception", hRes);
            throw _com_error( hRes );
        }
      }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::GETPORT_EX] ) == 0 )  {
        WLBS_PORT_RULE PortRule;
        DWORD          dwPort, dwVip;

        //get the output object instance
        GetMethodOutputInstance( MOF_NODESETTING::szName, 
                                 a_strMethodName, 
                                 &pOutputInstance);

        //get the vip
        hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::VIP ), 
                 0, 
                 &vValue,  
                 NULL,  
                 NULL
               );

        if( vValue.vt != VT_BSTR )
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"BString\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::VIP, a_strMethodName);
            throw _com_error ( WBEM_E_INVALID_PARAMETER );
        }

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(vValue.bstrVal, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
            if (dwVip == INADDR_NONE)
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", vValue.bstrVal, MOF_PARAM::VIP);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }

        //get the Port
        hRes = a_pIInParams->Get
                 ( 
                   _bstr_t( MOF_PARAM::PORT_NUMBER ), 
                   0, 
                   &vValue, 
                   NULL, 
                   NULL
                 );

        if( vValue.vt != VT_I4 )
        {
            TRACE_CRIT("%!FUNC! Argument %ls for method %ls is NOT of type \"signed long\", Throwing com_error WBEM_E_INVALID_PARAMETER exception", MOF_PARAM::PORT_NUMBER, a_strMethodName);
            throw _com_error ( WBEM_E_INVALID_PARAMETER );
        }

        dwPort = vValue.lVal;

        // Get the port rule for this vip & this port
        pCluster->GetPortRule(dwVip, dwPort, &PortRule );

        //create the vip port rule class
        SpawnInstance( MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX], &pWbemPortRule  );
        CWLBS_PortRule::FillWbemInstance(MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX], pCluster, pWbemPortRule, &PortRule );

        vValue.vt = VT_UNKNOWN;
        vValue.punkVal = pWbemPortRule;
        pWbemPortRule->AddRef();

        hRes = pOutputInstance->Put( _bstr_t(MOF_PARAM::PORTRULE),
                                     0,
                                     &vValue,
                                     0 );

        VariantClear( &vValue );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
            throw _com_error( hRes );
        }

        if( pOutputInstance ) {
          hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

          if( FAILED( hRes ) )
          {
              TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate() returned error : 0x%x, Throwing com_error exception", hRes);
              throw _com_error( hRes );
          }
        }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::LDSETT] ) == 0 ) {

      //
      // NOTE:
      // NLB, if needed, calls the PnP apis to disable and re-enable the network adapter, for the new NLB settings to take 
      // effect. Since this operation involves unloading and loading of the device driver, PnP apis, attempt to enable
      // the "SeLoadDriverPrivilege" privilege in the impersonation access token. Enabling a privilege is successful only
      // when the privilege is present, in the first place to be enabled. When the wmi client and wmi provider are in the 
      // same machine, it was observed that the "SeLoadDriverPrivilege" privilege was NOT event present in the impersonation
      // access token of the server. This is because, only the enabled privileges of the client are passed along to the server. 
      // So, we now require that the client enable the "SeLoadDriverPrivilege" privilege in its access token before calling 
      // this method. The following call to Check_Load_Unload_Driver_Privilege() checks if "SeLoadDriverPrivilege" privilege 
      // is enabled in the impersonation access token. Although the PnP apis only require that this privilege be present, 
      // we have decided to elevate the requirement to this privilege being present AND enabled. This is because, if the 
      // privilege is NOT enabled, the operation to enable it may or may not succeed depending on the client's credentials. 
      // --KarthicN, May 6, 2002.
      //
      if(!Check_Load_Unload_Driver_Privilege())
      {
          TRACE_CRIT("%!FUNC! Check_Load_Unload_Driver_Privilege() failed, Throwing WBEM_E_ACCESS_DENIED exception");
          throw _com_error( WBEM_E_ACCESS_DENIED );
      }

      DWORD dwReturnValue = pCluster->Commit(g_pWlbsControl);

      vValue.vt   = VT_I4;
      vValue.lVal = static_cast<long>(dwReturnValue);

      //get the output object instance
      GetMethodOutputInstance( MOF_NODESETTING::szName, 
                               a_strMethodName, 
                               &pOutputInstance);

      hRes = pOutputInstance->Put(_bstr_t(L"ReturnValue"), 0, &vValue, 0);


      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vValue ))
      {
          TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
          throw _com_error( WBEM_E_FAILED );
      }

      if( FAILED( hRes ) )
      {
          TRACE_CRIT("%!FUNC! IWbemClassObject::Put() returned error : 0x%x, Throwing com_error exception", hRes);
          throw _com_error( hRes );
      }

      if( pOutputInstance ) {
        hRes = m_pResponseHandler->Indicate(1, &pOutputInstance);

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate() returned error : 0x%x, Throwing com_error exception", hRes);
            throw _com_error( hRes );
        }
      }

    } else if( _wcsicmp( a_strMethodName, MOF_NODESETTING::pMethods[MOF_NODESETTING::SETDEF] ) == 0 ) {
      pCluster->SetNodeDefaults();
    } else {
        TRACE_CRIT("%!FUNC! %ls method NOT implemented, Throwing WBEM_E_METHOD_NOT_IMPLEMENTED exception",a_strMethodName);
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    //send the results back to WinMgMt
    //set the return value

    //release resources
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    hRes = HResErr.Error();
  }

  catch ( ... ) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance )
      pOutputInstance->Release();

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetting::FillWbemInstance(CWlbsClusterWrapper* pCluster,
                IWbemClassObject* a_pWbemInstance )
{
  namespace NODE = MOF_NODESETTING;

  TRACE_VERB("->%!FUNC!");

  ASSERT( a_pWbemInstance );

  CNodeConfiguration NodeConfig;

  pCluster->GetNodeConfig( NodeConfig );

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID() );

  //NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DEDIPADDRESS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DEDIPADDRESS] ),
      0                                                  ,
      &_variant_t(NodeConfig.szDedicatedIPAddress.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DEDNETMASK
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DEDNETMASK] ),
      0                                                ,
      &_variant_t(NodeConfig.szDedicatedNetworkMask.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMRULES
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMRULES] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumberOfRules),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //HOSTPRI
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::HOSTPRI] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwHostPriority),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MSGPERIOD 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MSGPERIOD] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwAliveMsgPeriod),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MSGTOLER 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MSGTOLER] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwAliveMsgTolerance),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //CLUSMODEONSTART 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CLUSMODEONSTART] ),
      0                                                ,
      &_variant_t(NodeConfig.bClusterModeOnStart),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );
             

  //CLUSMODESUSPENDONSTART 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::CLUSMODESUSPONSTART] ),
      0                                                ,
      &_variant_t(NodeConfig.bClusterModeSuspendOnStart),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //PERSISTSUSPENDONREBOOT 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::PERSISTSUSPONREBOOT] ),
      0                                                ,
      &_variant_t(NodeConfig.bPersistSuspendOnReboot),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NBTENABLE 
//  hRes = a_pWbemInstance->Put
//    (
//      _bstr_t( NODE::pProperties[NODE::NBTENABLE] ),
//      0                                                ,
//      &( _variant_t( NodeConfig.bNBTSupportEnable ) )        ,
//      NULL
//    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //REMOTEUDPPORT 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::REMOTEUDPPORT] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwRemoteControlUDPPort),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MASKSRCMAC 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MASKSRCMAC] ),
      0                                                ,
      &_variant_t(NodeConfig.bMaskSourceMAC),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //DESCPERALLOC 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::DESCPERALLOC] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwDescriptorsPerAlloc),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //MAXDESCALLOCS
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::MAXDESCALLOCS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwMaxDescriptorAllocs),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //FILTERICMP
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::FILTERICMP] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwFilterIcmp),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //TCPDESCRIPTORTIMEOUT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::TCPDESCRIPTORTIMEOUT] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwTcpDescriptorTimeout),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //IPSECDESCRIPTORTIMEOUT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::IPSECDESCRIPTORTIMEOUT] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwIpSecDescriptorTimeout),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMACTIONS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMACTIONS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumActions),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMPACKETS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMPACKETS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumPackets),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //NUMALIVEMSGS 
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::NUMALIVEMSGS] ),
      0                                                ,
      &_variant_t((long)NodeConfig.dwNumAliveMsgs),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );


  //ADAPTERGUID 
  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );

  hRes = a_pWbemInstance->Put
    (
      _bstr_t( NODE::pProperties[NODE::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_NodeSetting::UpdateConfiguration
//
// Purpose: This function updates the configuration data for a member node or a
//          potential WLBS cluster node.
//    
////////////////////////////////////////////////////////////////////////////////
void CWLBS_NodeSetting::UpdateConfiguration
  ( 
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject* a_pInstance 
  )
{
  namespace NODE = MOF_NODESETTING;

  CNodeConfiguration NewConfiguration;
  CNodeConfiguration OldConfiguration;

  TRACE_VERB("->%!FUNC!");

  pCluster->GetNodeConfig( OldConfiguration );

  //Dedicated IP
  UpdateConfigProp
    ( 
      NewConfiguration.szDedicatedIPAddress,
      OldConfiguration.szDedicatedIPAddress,
      NODE::pProperties[NODE::DEDIPADDRESS],
      a_pInstance 
    );

  //Dedicate Network Mask
  UpdateConfigProp
    ( 
      NewConfiguration.szDedicatedNetworkMask,
      OldConfiguration.szDedicatedNetworkMask,
      NODE::pProperties[NODE::DEDNETMASK],
      a_pInstance 
    );

  //HostPriority
  UpdateConfigProp
    ( 
      NewConfiguration.dwHostPriority,
      OldConfiguration.dwHostPriority,
      NODE::pProperties[NODE::HOSTPRI],
      a_pInstance 
    );

  //AliveMsgPeriod
  UpdateConfigProp
    ( 
      NewConfiguration.dwAliveMsgPeriod,
      OldConfiguration.dwAliveMsgPeriod,
      NODE::pProperties[NODE::MSGPERIOD],
      a_pInstance 
    );

  //AliveMsgTolerance
  UpdateConfigProp
    ( 
      NewConfiguration.dwAliveMsgTolerance,
      OldConfiguration.dwAliveMsgTolerance,
      NODE::pProperties[NODE::MSGTOLER],
      a_pInstance 
    );

  //ClusterModeOnStart
  UpdateConfigProp
    ( 
      NewConfiguration.bClusterModeOnStart,
      OldConfiguration.bClusterModeOnStart,
      NODE::pProperties[NODE::CLUSMODEONSTART],
      a_pInstance 
    );

  //ClusterModeSuspendOnStart
  UpdateConfigProp
    ( 
      NewConfiguration.bClusterModeSuspendOnStart,
      OldConfiguration.bClusterModeSuspendOnStart,
      NODE::pProperties[NODE::CLUSMODESUSPONSTART],
      a_pInstance 
    );

  //PersistSuspendOnReboot
  UpdateConfigProp
    ( 
      NewConfiguration.bPersistSuspendOnReboot,
      OldConfiguration.bPersistSuspendOnReboot,
      NODE::pProperties[NODE::PERSISTSUSPONREBOOT],
      a_pInstance 
    );

  //NBTSupportEnable
//  UpdateConfigProp
//    ( 
//      NewConfiguration.bNBTSupportEnable,
//      OldConfiguration.bNBTSupportEnable,
//      NODE::pProperties[NODE::NBTENABLE],
//      a_pInstance 
//    );

  //RemoteControlUDPPort
  UpdateConfigProp
    ( 
      NewConfiguration.dwRemoteControlUDPPort,
      OldConfiguration.dwRemoteControlUDPPort,
      NODE::pProperties[NODE::REMOTEUDPPORT],
      a_pInstance 
    );

  //MaskSourceMAC
  UpdateConfigProp
    ( 
      NewConfiguration.bMaskSourceMAC,
      OldConfiguration.bMaskSourceMAC,
      NODE::pProperties[NODE::MASKSRCMAC],
      a_pInstance 
    );

  //DescriptorsPerAlloc
  UpdateConfigProp
    ( 
      NewConfiguration.dwDescriptorsPerAlloc,
      OldConfiguration.dwDescriptorsPerAlloc,
      NODE::pProperties[NODE::DESCPERALLOC],
      a_pInstance 
    );

  //MaxDescriptorAllocs
  UpdateConfigProp
    ( 
      NewConfiguration.dwMaxDescriptorAllocs,
      OldConfiguration.dwMaxDescriptorAllocs,
      NODE::pProperties[NODE::MAXDESCALLOCS],
      a_pInstance 
    );

  //FilterIcmp
  UpdateConfigProp
    ( 
      NewConfiguration.dwFilterIcmp,
      OldConfiguration.dwFilterIcmp,
      NODE::pProperties[NODE::FILTERICMP],
      a_pInstance 
    );

  //TcpDescriptorTimeout
  UpdateConfigProp
    ( 
      NewConfiguration.dwTcpDescriptorTimeout,
      OldConfiguration.dwTcpDescriptorTimeout,
      NODE::pProperties[NODE::TCPDESCRIPTORTIMEOUT],
      a_pInstance 
    );

  //IpSecDescriptorTimeout
  UpdateConfigProp
    ( 
      NewConfiguration.dwIpSecDescriptorTimeout,
      OldConfiguration.dwIpSecDescriptorTimeout,
      NODE::pProperties[NODE::IPSECDESCRIPTORTIMEOUT],
      a_pInstance 
    );

  //NumActions
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumActions,
      OldConfiguration.dwNumActions,
      NODE::pProperties[NODE::NUMACTIONS],
      a_pInstance 
    );

  //NumPackets
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumPackets,
      OldConfiguration.dwNumPackets,
      NODE::pProperties[NODE::NUMPACKETS],
      a_pInstance 
    );

  //NumAliveMsgs
  UpdateConfigProp
    ( 
      NewConfiguration.dwNumAliveMsgs,
      OldConfiguration.dwNumAliveMsgs,
      NODE::pProperties[NODE::NUMALIVEMSGS],
      a_pInstance 
    );

  pCluster->PutNodeConfig( NewConfiguration );
  
  TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_portrule.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_PortRule.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "wlbsutil.h"
#include <winsock.h>
#include "WLBS_PortRule.tmh"

#include <strsafe.h>

extern CWlbsControlWrapper* g_pWlbsControl;

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::CWLBS_PortRule
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWLBS_PortRule::CWLBS_PortRule
  ( 
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
: CWlbs_Root( a_pNameSpace, a_pResponseHandler )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::Create
//
// Purpose: This instantiates this class and is invoked from an array of
//          function pointers.
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root* CWLBS_PortRule::Create
  (
    CWbemServices*   a_pNameSpace, 
    IWbemObjectSink* a_pResponseHandler
  )
{

  CWlbs_Root* pRoot = new CWLBS_PortRule( a_pNameSpace, a_pResponseHandler );

  if( !pRoot )
    throw _com_error( WBEM_E_OUT_OF_MEMORY );

  return pRoot;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::ExecMethod
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::ExecMethod    
  (
    const ParsedObjectPath* a_pParsedPath, 
    const BSTR&             a_strMethodName, 
    long                    /* a_lFlags */, 
    IWbemContext*           /* a_pIContex */, 
    IWbemClassObject*       a_pIInParams
  )
{
  
  IWbemClassObject* pOutputInstance   = NULL;
  VARIANT           vValue;
  HRESULT           hRes = 0;

  TRACE_CRIT("->%!FUNC!, Method Name : %ls",a_strMethodName);
     
  try {

    VariantInit( &vValue );

    //determine the method being executed
    if( _wcsicmp( a_strMethodName, MOF_PORTRULE::pMethods[MOF_PORTRULE::SETDEF] ) == 0 )  
    {

      //get the node path
      hRes = a_pIInParams->Get
               ( 
                 _bstr_t( MOF_PARAM::NODEPATH ), 
                 0, 
                 &vValue, 
                 NULL, 
                 NULL
               );

      if( FAILED( hRes) ) 
      {
        TRACE_CRIT("%!FUNC!, Error trying to retreive Argument : %ls of method %ls, Throwing WBEM_E_FAILED exception", MOF_PARAM::NODEPATH, a_strMethodName);
        throw _com_error( WBEM_E_FAILED );
      }

      //this check may not be necessary since WMI will do some
      //parameter validation
      //if( vValue.vt != VT_BSTR )
      //  throw _com_error ( WBEM_E_INVALID_PARAMETER );

      //parse node path
      CObjectPathParser PathParser;
      ParsedObjectPath *pParsedPath = NULL;

      try {

        int nStatus = PathParser.Parse( vValue.bstrVal, &pParsedPath );
        if(nStatus != 0) {
    
          if (NULL != pParsedPath)
          {
            PathParser.Free( pParsedPath );
            pParsedPath = NULL;
          }

          TRACE_CRIT("%!FUNC!, Error (0x%x) trying to parse Argument : %ls of method %ls, Throwing WBEM_E_INVALID_PARAMETER exception",nStatus, MOF_PARAM::NODEPATH, a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );

        }

        //get the name key, which should be the only key
        if( *pParsedPath->m_paKeys == NULL )
        {
          TRACE_CRIT("%!FUNC!, Argument : %ls of method %ls does not contain key, Throwing WBEM_E_INVALID_PARAMETER exception",MOF_PARAM::NODEPATH, a_strMethodName);
          throw _com_error( WBEM_E_INVALID_PARAMETER );
        }
 
        DWORD dwReqClusterIpOrIndex = ExtractClusterIP( (*pParsedPath->m_paKeys)->m_vValue.bstrVal);
        DWORD dwReqHostID = ExtractHostID(    (*pParsedPath->m_paKeys)->m_vValue.bstrVal);
      
        CWlbsClusterWrapper* pCluster = g_pWlbsControl->GetClusterFromIpOrIndex(
                dwReqClusterIpOrIndex);

        if (pCluster == NULL || (DWORD)-1 == dwReqHostID)
        {
           TRACE_CRIT("%!FUNC! ExtractClusterIP or ExtractHostID or GetClusterFromIpOrIndex failed, Throwing com_error WBEM_E_INVALID_PARAMETER exception");
           throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        // If the instance on which this method is called is NOT of type "PortRuleEx", then, 
        // verify that we are operating in the "all vip" mode
        if (_wcsicmp(a_pParsedPath->m_pClass, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) != 0)
        {
            // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
            // so, we do not want to operate on any cluster that has a port rule
            // that is specific to a vip (other than the "all vip")
            // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
            // see of there is any port rule that is specific to a vip
            CNodeConfiguration NodeConfig;
            pCluster->GetNodeConfig(NodeConfig);
            if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
            {
                TRACE_CRIT("%!FUNC! %ls method called on %ls class on a cluster that has per-vip port rules (Must call this method on the %ls class instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_strMethodName,a_pParsedPath->m_pClass,MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]);
                throw _com_error( WBEM_E_INVALID_OPERATION );
            }
        }

        //validate host ID
        if( dwReqHostID != pCluster->GetHostID())
        {
            TRACE_CRIT("%!FUNC! Host Id validation failed, Host Id passed : 0x%x, Host Id per system : 0x%x", dwReqHostID, pCluster->GetHostID());
            throw _com_error( WBEM_E_INVALID_PARAMETER );
        }

        //invoke method
        pCluster->SetPortRuleDefaults();
      }
      catch( ... ) {

        if( pParsedPath )
        {
          PathParser.Free( pParsedPath );
          pParsedPath = NULL;
        }

        throw;
      }

    } else {
      TRACE_CRIT("%!FUNC! %ls method NOT implemented, Throwing WBEM_E_METHOD_NOT_IMPLEMENTED exception",a_strMethodName);
      throw _com_error( WBEM_E_METHOD_NOT_IMPLEMENTED );
    }

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;

  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
      pOutputInstance = NULL;
    }

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }

    hRes = HResErr.Error();
  }

  catch ( ... ) {

    TRACE_CRIT("%!FUNC! Caught an exception");
         
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    if( pOutputInstance ) {
      pOutputInstance->Release();
    }
    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);

  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::GetInstance
//
// Purpose: This function retrieves an instance of a MOF PortRule 
//          class. The node does not have to be a member of a cluster. 
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::GetInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /* a_lFlags */,
    IWbemContext*           /* a_pIContex */
  )
{
  IWbemClassObject* pWlbsInstance = NULL;
  HRESULT           hRes          = 0;

  TRACE_CRIT("->%!FUNC!");

  try {

    if( !a_pParsedPath )
    {
      TRACE_CRIT("%!FUNC! Did not pass class name & key of the instance to Get");
      throw _com_error( WBEM_E_FAILED );
    }

    wstring wstrHostName;

    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      TRACE_CRIT("%!FUNC! GetClusterFromHostName failed for Host name = %ls, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName.data());
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    DWORD dwVip, dwReqStartPort;

    // If the instance to be retreived is of type "PortRuleEx", then, retreive the vip, otherwise
    // verify that we are operating in the "all vip" mode
    if (_wcsicmp(a_pParsedPath->m_pClass, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) == 0)
    {
        WCHAR *szVip;

        // The Keys are ordered alphabetically, hence "Name", "StartPort", "VirtualIpAddress" is the order
        dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal ); 
        szVip = (*(a_pParsedPath->m_paKeys + 2))->m_vValue.bstrVal;

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(szVip, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( szVip );
            if (dwVip == INADDR_NONE) 
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for %ls for Class %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", szVip, MOF_PARAM::VIP, a_pParsedPath->m_pClass);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }
    }
    else
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
        {
            TRACE_CRIT("%!FUNC! called on Class : %ls on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_pParsedPath->m_pClass);
            throw _com_error( WBEM_E_INVALID_OPERATION );
        }

        dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );
        dwVip = IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP);
    }

    WLBS_PORT_RULE PortRule;

    pCluster->GetPortRule(dwVip, dwReqStartPort, &PortRule );

    if( (dwVip != IpAddressFromAbcdWsz(PortRule.virtual_ip_addr)) 
     || (dwReqStartPort != PortRule.start_port) )
    {
        TRACE_CRIT("%!FUNC! could not retreive port rule for vip : 0x%x & port : 0x%x, Throwing com_error WBEM_E_NOT_FOUND exception", dwVip, dwReqStartPort);
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    SpawnInstance( a_pParsedPath->m_pClass, &pWlbsInstance );
    FillWbemInstance(a_pParsedPath->m_pClass, pCluster, pWlbsInstance, &PortRule );

    //send the results back to WinMgMt
    m_pResponseHandler->Indicate( 1, &pWlbsInstance );

    if( pWlbsInstance )
      pWlbsInstance->Release();

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( pWlbsInstance )
      pWlbsInstance->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());
    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pWlbsInstance )
      pWlbsInstance->Release();

    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( pWlbsInstance )
      pWlbsInstance->Release();

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::EnumInstances
//
// Purpose: This function obtains the PortRule data for the current host.
//          The node does not have to be a member of a cluster for this 
//          to succeed. However, NLB must be installed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::EnumInstances
  ( 
    BSTR             a_bstrClass,
    long             /*a_lFlags*/, 
    IWbemContext*    /*a_pIContex*/
  )
{
  IWbemClassObject**   ppWlbsInstance = NULL;
  HRESULT              hRes           = 0;
  PWLBS_PORT_RULE      pPortRules     = NULL;
  DWORD                dwNumRules     = 0;
  CNodeConfiguration   NodeConfig;

  TRACE_CRIT("->%!FUNC!");

  try {

    DWORD dwFilteringMode;

    if( _wcsicmp( a_bstrClass, MOF_PRFAIL::szName ) == 0 ) {
      dwFilteringMode = WLBS_SINGLE;
    } else if( _wcsicmp( a_bstrClass, MOF_PRLOADBAL::szName ) == 0 ) {
      dwFilteringMode = WLBS_MULTI;
    } else if( _wcsicmp( a_bstrClass, MOF_PRDIS::szName ) == 0 ) {
      dwFilteringMode = WLBS_NEVER;
    } else if( _wcsicmp( a_bstrClass, MOF_PORTRULE_EX::szName ) == 0 ) {
      dwFilteringMode = 0;
    } else {
      TRACE_CRIT("%!FUNC! Invalid Class name : %ls, Throwing WBEM_E_NOT_FOUND exception",a_bstrClass);
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    DWORD dwNumClusters = 0;
    CWlbsClusterWrapper** ppCluster = NULL;

    g_pWlbsControl->EnumClusters(ppCluster, &dwNumClusters);
    if (dwNumClusters == 0)
    {
      TRACE_CRIT("%!FUNC! EnumClusters returned no clusters, Throwing WBEM_E_NOT_FOUND exception");
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    //declare an IWbemClassObject smart pointer
    IWbemClassObjectPtr pWlbsClass;

    //get the MOF class object
    hRes = m_pNameSpace->GetObject(
      a_bstrClass,  
      0,                          
      NULL,                       
      &pWlbsClass,            
      NULL );                      

    if( FAILED( hRes ) ) {
      TRACE_CRIT("%!FUNC! CWbemServices::GetObject failed with error : 0x%x, Throwing com_error exception", hRes);
      throw _com_error( hRes );
    }


    for (DWORD iCluster=0; iCluster<dwNumClusters; iCluster++)
    {
        // The filtering mode will NOT be zero only if the instances to be enumerated is 
        // of type "PortRule(Disabled/Failover/Loadbalanced)"
        if (dwFilteringMode != 0)
        {
            // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
            // so, we do not want to return any port rule for a cluster that has a port rule
            // that is specific to a vip (other than the "all vip")
            // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
            // see of there is any port rule that is specific to a vip
            ppCluster[iCluster]->GetNodeConfig(NodeConfig);
            if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
                continue;
        }

        //call the API query function to find the port rules

        ppCluster[iCluster]->EnumPortRules( &pPortRules, &dwNumRules, dwFilteringMode );
        if( dwNumRules == 0 ) 
            continue; // Backporting fix for Winse bug 
                      // 24751 Querying for "Intrinsic events" on a class with zero instances causes error log entry in wbemcore.log

        //spawn an instance of the MOF class for each rule found
        ppWlbsInstance = new IWbemClassObject *[dwNumRules];

        if( !ppWlbsInstance )
        {
            TRACE_CRIT("%!FUNC! new failed, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
            throw _com_error( WBEM_E_OUT_OF_MEMORY );
        }

        //initialize array
        ZeroMemory( ppWlbsInstance, dwNumRules * sizeof(IWbemClassObject *) );

        for( DWORD i = 0; i < dwNumRules; i ++ ) {
          hRes = pWlbsClass->SpawnInstance( 0, &ppWlbsInstance[i] );

          if( FAILED( hRes ) )
          {
            TRACE_CRIT("%!FUNC! IWbemClassObjectPtr::SpawnInstance failed : 0x%x, Throwing com_error exception", hRes);
            throw _com_error( hRes );
          }

          FillWbemInstance(a_bstrClass, ppCluster[iCluster], *(ppWlbsInstance + i), pPortRules + i );
        }

        //send the results back to WinMgMt
        hRes = m_pResponseHandler->Indicate( dwNumRules, ppWlbsInstance );

        if( FAILED( hRes ) ) {
            TRACE_CRIT("%!FUNC! IWbemObjectSink::Indicate failed : 0x%x, Throwing com_error exception", hRes);
            throw _com_error( hRes );
        }

        if( ppWlbsInstance ) {
          for( i = 0; i < dwNumRules; i++ ) {
            if( ppWlbsInstance[i] ) {
              ppWlbsInstance[i]->Release();
            }
          }
          delete [] ppWlbsInstance;
          ppWlbsInstance = NULL;
          dwNumRules = NULL;

        }

        if( pPortRules ) 
        {
          delete [] pPortRules;
          pPortRules = NULL;
        }
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());

    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    if( ppWlbsInstance ) {
      for( DWORD i = 0; i < dwNumRules; i++ ) {
        if( ppWlbsInstance[i] ) {
          ppWlbsInstance[i]->Release();
          ppWlbsInstance[i] = NULL;
        }
      }
      delete [] ppWlbsInstance;
    }

    if( pPortRules ) 
      delete [] pPortRules;

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::DeleteInstance
//
// Purpose: This function deletes an instance of a MOF PortRule 
//          class. The node does not have to be a member of a cluster. However,
//          WLBS must be installed for this function to succeed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::DeleteInstance
  ( 
    const ParsedObjectPath* a_pParsedPath,
    long                    /*a_lFlags*/,
    IWbemContext*           /*a_pIContex*/
  )
{

  HRESULT hRes = 0;

  TRACE_CRIT("->%!FUNC!");
  try {
    if( !a_pParsedPath )
    {
        TRACE_CRIT("%!FUNC! Did not pass class name & key of the instance to Delete");
        throw _com_error( WBEM_E_FAILED );
    }

    wstring wstrHostName;
    DWORD   dwVip, dwReqStartPort;

    wstrHostName = (*a_pParsedPath->m_paKeys)->m_vValue.bstrVal;

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      TRACE_CRIT("%!FUNC! GetClusterFromHostName failed for Host name = %ls, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName.data());
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // If the instance to be deleted is of type "PortRuleEx", then, retreive the vip, otherwise
    // verify that we are operating in the "all vip" mode
    if (_wcsicmp(a_pParsedPath->m_pClass, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) == 0)
    {
        WCHAR *szVip;

        // The Keys are ordered alphabetically, hence "Name", "StartPort", "VirtualIpAddress" is the order
        dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );
        szVip = (*(a_pParsedPath->m_paKeys + 2))->m_vValue.bstrVal;

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(szVip, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( szVip );
            if (dwVip == INADDR_NONE) 
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for %ls for Class %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", szVip, MOF_PARAM::VIP, a_pParsedPath->m_pClass);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }
    }
    else
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
        {
            TRACE_CRIT("%!FUNC! called on Class : %ls on a cluster that has per-vip port rules (Must call the \"Ex\" equivalent instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", a_pParsedPath->m_pClass);
            throw _com_error( WBEM_E_INVALID_OPERATION );
        }

        dwReqStartPort = static_cast<DWORD>( (*(a_pParsedPath->m_paKeys + 1))->m_vValue.lVal );
        dwVip = IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP);
    }

    WLBS_PORT_RULE PortRule;

    // Get the port rule for this vip & port
    pCluster->GetPortRule(dwVip, dwReqStartPort, &PortRule );

    if( (dwVip != IpAddressFromAbcdWsz(PortRule.virtual_ip_addr)) || (dwReqStartPort != PortRule.start_port) )
    {
      TRACE_CRIT("%!FUNC! could not retreive port rule for vip : 0x%x & port : 0x%x, Throwing com_error WBEM_E_NOT_FOUND exception", dwVip, dwReqStartPort);
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // Delete the port rule for this vip & port
    pCluster->DeletePortRule(dwVip, dwReqStartPort );

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());
    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    hRes = HResErr.Error();
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::PutInstance
//
// Purpose: This function updates an instance of a PortRule 
//          class. The host does not have to be a member of a cluster.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBS_PortRule::PutInstance
  ( 
    IWbemClassObject* a_pInstance,
    long              /*a_lFlags*/,
    IWbemContext*     /*a_pIContex*/
  )
{
  VARIANT vValue;
  HRESULT hRes = 0;
  namespace PR = MOF_PORTRULE_EX;

  WLBS_PORT_RULE NewRule; //the instance to put
  bool      bPortRule_Ex;
  DWORD     dwFilteringMode = 0; // Filtering Mode initialized to 0
  DWORD     dwVip;
  WCHAR     szClassName[256];

  TRACE_CRIT("->%!FUNC!");

  try {

    VariantInit( &vValue );

    //get the class name to determine port rule mode
    hRes = a_pInstance->Get( _bstr_t( L"__Class" ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
    {
      TRACE_CRIT("%!FUNC! Error trying to retreive \"__Class\" property,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception", hRes);
      throw _com_error( hRes );
    }

    StringCbCopy(szClassName, sizeof(szClassName), vValue.bstrVal);

    // If it is the extended port rule class, then, the namespaces are different
    if (_wcsicmp(szClassName, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) == 0)
    {
        bPortRule_Ex   = true;
    }
    else
    {
        bPortRule_Ex    = false;
    }

    // Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    //get the host name value
    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::NAME] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
    {
      TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::NAME],szClassName, hRes);
      throw _com_error( hRes );
    }

    wstring wstrHostName( vValue.bstrVal );

    CWlbsClusterWrapper* pCluster = GetClusterFromHostName(g_pWlbsControl, wstrHostName);
    if (pCluster == NULL)
    {
      TRACE_CRIT("%!FUNC! GetClusterFromHostName failed for Host name = %ls, Throwing com_error WBEM_E_NOT_FOUND exception",wstrHostName.data());      
      throw _com_error( WBEM_E_NOT_FOUND );
    }

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    // If the instance to be put is of type "PortRuleEx", then, retreive the vip, otherwise
    // verify that we are operating in the "all vip" mode
    if (bPortRule_Ex)
    {
        //get the vip
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::VIP] ),
                                 0,
                                 &vValue,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::VIP],szClassName, hRes);
            throw _com_error( hRes );
        }

        // If the VIP is "All Vip", then, fill in the numeric value 
        // directly from the macro, else use the conversion function.
        // This is 'cos INADDR_NONE, the return value of inet_addr 
        // function (called by IpAddressFromAbcdWsz) in the failure 
        // case, is equivalent to the numeric value of CVY_DEF_ALL_VIP
        if (_wcsicmp(vValue.bstrVal, CVY_DEF_ALL_VIP) == 0) {
            dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
        }
        else {
            dwVip = IpAddressFromAbcdWsz( vValue.bstrVal );
            if (dwVip == INADDR_NONE) 
            {
                TRACE_CRIT("%!FUNC! Invalid value (%ls) passed for %ls for Class %ls. Throwing com_error WBEM_E_INVALID_PARAMETER exception", vValue.bstrVal, MOF_PARAM::VIP, szClassName);
                throw _com_error ( WBEM_E_INVALID_PARAMETER );
            }
        }

        StringCbCopy(NewRule.virtual_ip_addr, sizeof(NewRule.virtual_ip_addr), vValue.bstrVal);

        if (S_OK != VariantClear( &vValue ))
        {
            TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
            throw _com_error( WBEM_E_FAILED );
        }

        //get the filtering mode
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::FILTERINGMODE] ),
                                 0,
                                 &vValue,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::FILTERINGMODE],szClassName, hRes);
            throw _com_error( hRes );
        }

        dwFilteringMode = static_cast<DWORD>( vValue.lVal );
    }
    else
    {
        // The "PortRule(Disabled/Failover/Loadbalanced)" classes do NOT contain the VIP property,
        // so, we do not want to operate on any cluster that has a port rule
        // that is specific to a vip (other than the "all vip")
        // The "EffectiveVersion" registry value is checked for a value of CVY_VERSION_FULL to
        // see of there is any port rule that is specific to a vip
        CNodeConfiguration NodeConfig;
        pCluster->GetNodeConfig(NodeConfig);
        if(NodeConfig.dwEffectiveVersion == CVY_VERSION_FULL)
        {
            TRACE_CRIT("%!FUNC! Attempt to put an instance of %ls class on a cluster that has per-vip port rules (Must use %ls class instead). Throwing com_error WBEM_E_INVALID_OPERATION exception", szClassName,MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]);
            throw _com_error( WBEM_E_INVALID_OPERATION );
        }

        StringCbCopy(NewRule.virtual_ip_addr, sizeof(NewRule.virtual_ip_addr), CVY_DEF_ALL_VIP);
        dwVip = CVY_ALL_VIP_NUMERIC_VALUE;
    }

    //retrieve start and end ports
    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::STPORT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::STPORT], szClassName, hRes);
        throw _com_error( hRes );
    }

    NewRule.start_port = static_cast<DWORD>( vValue.lVal );

    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::EDPORT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::EDPORT], szClassName, hRes);
        throw _com_error( hRes );
    }

    NewRule.end_port   = static_cast<DWORD>( vValue.lVal );

    //get the protocol
    hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::PROT] ),
                             0,
                             &vValue,
                             NULL,
                             NULL );

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::PROT], szClassName, hRes);
        throw _com_error( hRes );
    }

    NewRule.protocol = static_cast<DWORD>( vValue.lVal );

    if( (dwFilteringMode == WLBS_NEVER) || (_wcsicmp( szClassName, MOF_PRDIS::szName ) == 0)) {
      NewRule.mode = WLBS_NEVER;

    } else if( (dwFilteringMode == WLBS_SINGLE) || (_wcsicmp( szClassName, MOF_PRFAIL::szName ) == 0)) {
      NewRule.mode = WLBS_SINGLE;

      VARIANT vRulePriority;
      VariantInit( &vRulePriority );

      try {
        //get the rule priority
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::PRIO] ),
                                 0,
                                 &vRulePriority,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::PRIO], szClassName, hRes);
            throw _com_error( hRes );
        }

      } 
      catch( ... ) {
          TRACE_CRIT("%!FUNC! Caught an exception");

          // CLD: Need to check return code for error
          // No throw here since we are already throwing an exception.
          VariantClear( &vRulePriority );
          TRACE_CRIT("%!FUNC! Rethrowing exception");
          throw;
      }

      
      NewRule.mode_data.single.priority = static_cast<DWORD>( vRulePriority.lVal );

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &vRulePriority ))
      {
          TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
          throw _com_error( WBEM_E_FAILED );
      }

    } else if( (dwFilteringMode == WLBS_MULTI) || (_wcsicmp( szClassName, MOF_PRLOADBAL::szName ) == 0)) {
      NewRule.mode = WLBS_MULTI;

      VARIANT v;

      VariantInit( &v );

      try {
        //get the affinity
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::AFFIN] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::AFFIN], szClassName, hRes);
            throw _com_error( hRes );
        }

        NewRule.mode_data.multi.affinity = static_cast<WORD>( v.lVal );

        //get the equal load boolean
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::EQLD] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::EQLD], szClassName, hRes);
            throw _com_error( hRes );
        }

        if( v.boolVal == -1 ) {
          NewRule.mode_data.multi.equal_load = 1;
        } else {
          NewRule.mode_data.multi.equal_load = 0;
        }

        //get the load
        hRes = a_pInstance->Get( _bstr_t( PR::pProperties[PR::LDWT] ),
                                 0,
                                 &v,
                                 NULL,
                                 NULL );

        if( FAILED( hRes ) )
        {
            TRACE_CRIT("%!FUNC! Error trying to retreive %ls property of Class : %ls,IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception",PR::pProperties[PR::LDWT], szClassName, hRes);
            throw _com_error( hRes );
        }

        if( v.vt != VT_NULL )
          NewRule.mode_data.multi.load = static_cast<DWORD>( v.lVal );
        else
          NewRule.mode_data.multi.load = 0;

      } catch( ... ) {

          TRACE_CRIT("%!FUNC! Caught an exception");
          // CLD: Need to check return code for error
          // No throw here since we are already throwing an exception.
          VariantClear( &v );

          TRACE_CRIT("%!FUNC! Rethrowing exception");
          throw;
      }

      // CLD: Need to check return code for error
      if (S_OK != VariantClear( &v ))
      {
          TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
          throw _com_error( WBEM_E_FAILED );
      }
    }

    //delete the port rule but cache in case of failure
    WLBS_PORT_RULE OldRule;
    bool bOldRuleSaved = false;

    if( pCluster->RuleExists(dwVip, NewRule.start_port ) ) {
      pCluster->GetPortRule(dwVip, NewRule.start_port, &OldRule );
      bOldRuleSaved = true;

      pCluster->DeletePortRule(dwVip, NewRule.start_port );
    }

    //add the port rule, roll back if failed
    try {
      pCluster->PutPortRule( &NewRule );

    } catch(...) {
      TRACE_CRIT("%!FUNC! Caught an exception");

      if( bOldRuleSaved )
        pCluster->PutPortRule( &OldRule );

      TRACE_CRIT("%!FUNC! Rethrowing exception");
      throw;
    }

    //release resources
    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear() failed, Throwing WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    m_pResponseHandler->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );

    hRes = WBEM_S_NO_ERROR;
  }

  catch(CErrorWlbsControl Err) {

    IWbemClassObject* pWbemExtStat = NULL;

    TRACE_CRIT("%!FUNC! Caught a Wlbs exception : 0x%x", Err.Error());

    CreateExtendedStatus( m_pNameSpace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    m_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    if( pWbemExtStat )
      pWbemExtStat->Release();

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;
  }

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! Caught a com_error exception : 0x%x", HResErr.Error());
    m_pResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    hRes = HResErr.Error();
  }

  catch (...) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vValue );

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_CRIT("<-%!FUNC!");
    throw;
  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBS_PortRule::FillWbemInstance
//
// Purpose: This function copies all of the data from a node configuration
//          structure to a WBEM instance.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBS_PortRule::FillWbemInstance
  ( 
    LPCWSTR              a_szClassName,
    CWlbsClusterWrapper* pCluster,
    IWbemClassObject*      a_pWbemInstance, 
    const PWLBS_PORT_RULE& a_pPortRule
  )
{
  namespace PR = MOF_PORTRULE_EX;
  bool bPortRule_Ex;

  TRACE_VERB("->%!FUNC!, ClassName : %ls", a_szClassName);

  ASSERT( a_pWbemInstance );

  // If it is the extended port rule class, then, the namespaces are different
  if (_wcsicmp(a_szClassName, MOF_CLASSES::g_szMOFClassList[MOF_CLASSES::PORTRULE_EX]) == 0)
  {
      bPortRule_Ex = true;
  }
  else
  {
      bPortRule_Ex = false;
  }

  wstring wstrHostName;
  ConstructHostName( wstrHostName, pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
      pCluster->GetHostID());


  //NAME
  HRESULT hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::NAME] ) ,
      0                                              ,
      &_variant_t(wstrHostName.c_str()),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  // Fill in VIP if it is the extended port rule class 
  if (bPortRule_Ex) {

      hRes = a_pWbemInstance->Put
        (
          _bstr_t( PR::pProperties[PR::VIP] ) ,
          0                                              ,
          &_variant_t(a_pPortRule->virtual_ip_addr),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );
  }

  //STPORT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::STPORT] ),
      0                                                  ,
      &_variant_t(static_cast<long>(a_pPortRule->start_port)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //EDPORT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::EDPORT] ),
      0                                                ,
      &_variant_t(static_cast<long>(a_pPortRule->end_port)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //ADAPTERGUID 
  GUID AdapterGuid = pCluster->GetAdapterGuid();
  
  WCHAR szAdapterGuid[128];
  StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
  
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::ADAPTERGUID] ),
      0                                                ,
      &_variant_t(szAdapterGuid),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  //PROT
  hRes = a_pWbemInstance->Put
    (
      _bstr_t( PR::pProperties[PR::PROT] ),
      0,
      &_variant_t(static_cast<long>(a_pPortRule->protocol)),
      NULL
    );

  if( FAILED( hRes ) )
    throw _com_error( hRes );

  // If it is the extended port rule class (containing all parameters of all filtering modes), 
  // initialize them with a "don't care" value (zero). The appropriate fields (depending on filtering mode)
  // are filled in later.
  if (bPortRule_Ex) {
      hRes = a_pWbemInstance->Put ( _bstr_t( PR::pProperties[PR::EQLD] ), 0, &_variant_t(static_cast<long>(0)), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
      hRes = a_pWbemInstance->Put ( _bstr_t( PR::pProperties[PR::LDWT] ), 0, &_variant_t(static_cast<long>(0)), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
      hRes = a_pWbemInstance->Put ( _bstr_t( PR::pProperties[PR::AFFIN] ), 0, &_variant_t(static_cast<long>(0)), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
      hRes = a_pWbemInstance->Put (_bstr_t( PR::pProperties[PR::PRIO] ), 0, &_variant_t(static_cast<long>(0)), NULL);
      if( FAILED( hRes ) )
          throw _com_error( hRes );
  }

  // Fill in "Filtering Mode" if it is the Extended Port rule class
  if (bPortRule_Ex) {

      hRes = a_pWbemInstance->Put
        (
          _bstr_t( PR::pProperties[PR::FILTERINGMODE] ) ,
          0                                              ,
          &_variant_t(static_cast<long>(a_pPortRule->mode)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );
  }


  switch( a_pPortRule->mode ) {
    case WLBS_SINGLE:
      //PRIO
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PR::pProperties[PR::PRIO] ),
          0                                                ,
          &_variant_t(static_cast<long>(a_pPortRule->mode_data.single.priority)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      break;
    case WLBS_MULTI:
      //EQLD
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PR::pProperties[PR::EQLD] ),
          0                                                ,
          &_variant_t((a_pPortRule->mode_data.multi.equal_load != 0)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //LDWT
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PR::pProperties[PR::LDWT] ),
          0                                                ,
         &_variant_t(static_cast<long>(a_pPortRule->mode_data.multi.load)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      //AFFIN
      hRes = a_pWbemInstance->Put
        (
        _bstr_t( PR::pProperties[PR::AFFIN] ),
          0                                                ,
          &_variant_t(static_cast<long>(a_pPortRule->mode_data.multi.affinity)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );

      break;
    case WLBS_NEVER:
      //there are no properties
      break;
    default:
      throw _com_error( WBEM_E_FAILED );
  }

  // Fill in "PortState" if it is the Extended Port rule class
  if (bPortRule_Ex) {
      NLB_OPTIONS options;
      WLBS_RESPONSE response;
      DWORD num_responses = 1;
      DWORD status, port_state;

      options.state.port.VirtualIPAddress = WlbsResolve(a_pPortRule->virtual_ip_addr);
      options.state.port.Num = a_pPortRule->start_port;

      status = g_pWlbsControl->WlbsQueryState(pCluster->GetClusterIpOrIndex(g_pWlbsControl), 
                                              WLBS_LOCAL_HOST, 
                                              IOCTL_CVY_QUERY_PORT_STATE, 
                                              &options, 
                                              &response, 
                                              &num_responses);
      if (status != WLBS_OK) 
      {
          TRACE_CRIT("%!FUNC! WlbsQueryState returned error : 0x%x, Throwing Wlbs error exception", status);
          throw CErrorWlbsControl( status, CmdWlbsQueryPortState );
      }

      port_state = response.options.state.port.Status;

      hRes = a_pWbemInstance->Put
        (
          _bstr_t( PR::pProperties[PR::PORTSTATE] ) ,
          0                                              ,
          &_variant_t(static_cast<long>(port_state)),
          NULL
        );

      if( FAILED( hRes ) )
        throw _com_error( hRes );
  }
   
  TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_provclassfac.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File :  WLBSProvClassFac.cpp
//
//  Module: WLBS Instance provider class factory
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//	History:
//
//***************************************************************************

#include "WLBS_Provider.h"

//***************************************************************************
//
// CWLBSClassFactory::CWLBSClassFactory
// CWLBSClassFactory::~CWLBSClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************
CWLBSClassFactory::CWLBSClassFactory()
: m_cRef(1)
{
  return;
}

CWLBSClassFactory::~CWLBSClassFactory(void)
{
  return;
}

//***************************************************************************
//
// CWLBSClassFactory::QueryInterface
// CWLBSClassFactory::AddRef
// CWLBSClassFactory::Release
//
// Purpose: Standard OLE routines needed for all interfaces
//
//***************************************************************************
STDMETHODIMP CWLBSClassFactory::QueryInterface(REFIID a_riid, PPVOID a_ppv)
{
  *a_ppv = NULL;

  if (IID_IUnknown==a_riid || IID_IClassFactory==a_riid)
    *a_ppv = static_cast<IClassFactory *>(this);

  if (*a_ppv != NULL) {
    reinterpret_cast<IUnknown *>(*a_ppv)->AddRef();
    return S_OK;
  }

  return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWLBSClassFactory::AddRef(void)
{
  return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWLBSClassFactory::Release(void)
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if ( 0 == cRef )
    {
        delete this;
    }

    return cRef;

}

//***************************************************************************
//
// CWLBSClassFactory::CreateInstance
//
// Purpose: Instantiates a provider object returning an interface pointer.
//
// Parameters:
//  a_pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                    being used in an aggregation.
//  a_riid            REFIID identifying the interface the caller
//                    desires to have for the new object.
//  a_ppvObj          PPVOID in which to store the desired
//                    interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************
STDMETHODIMP CWLBSClassFactory::CreateInstance(
    LPUNKNOWN a_pUnkOuter, 
    REFIID    a_riid, 
    PPVOID    a_ppvObj
  )
{
  CWLBSProvider * pObj = NULL;
  HRESULT         hr;

  *a_ppvObj = NULL;

  // This object doesnt support aggregation.
  if (a_pUnkOuter != NULL)
      return CLASS_E_NOAGGREGATION;

  // Create the object.
  pObj = new CWLBSProvider();

  if (pObj == NULL)
      return E_OUTOFMEMORY;

  hr = pObj->QueryInterface(a_riid, a_ppvObj);

  if( FAILED(hr) ) {
    delete pObj;
    pObj = NULL;
  }

  return hr;
}

//***************************************************************************
//
// CWLBSClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************
STDMETHODIMP CWLBSClassFactory::LockServer(BOOL a_bLock)
{
  if (a_bLock)
      InterlockedIncrement(&g_cServerLocks);
  else
      InterlockedDecrement(&g_cServerLocks);

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_provider.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File:   WLBS_Provider.h
//
//  Module: WLBS instance provider main project header file
//
//  Purpose: General purpose include file.
//
//	History:
//
//  Author: drbeck
//
//***************************************************************************

#ifndef _WLBSPROVIDER_INCLUDED_
#define _WLBSPROVIDER_INCLUDED_

#include <crtdbg.h>
#include <comdef.h>
#include <iostream>
#include <memory>
#include <string>
#include <wbemprov.h>
#include <genlex.h>   //for wmi object path parser
#include <objbase.h>
#include <wlbsconfig.h> 
#include <ntrkcomm.h>

using namespace std;

#include "objpath.h"
#include "WLBS_MOFData.h"
#include "WLBS_Root.h"
#include "WLBS_Node.h"
#include "WLBS_Cluster.h"
#include "WLBS_NodeSetting.h"
#include "WLBS_ClusterSetting.h"
#include "WLBS_PortRule.h"
#include "WLBS_ParticipatingNode.h"
#include "WLBS_NodeSetPortRule.h"
#include "WLBS_ClusClusSetting.h"
#include "WLBS_NodeNodeSetting.h"

typedef LPVOID * PPVOID;

class CWLBSProvider : public CImpersonatedProvider
{
private:
	void GetClass(IWbemClassObject *a_pClassObject, wstring& a_szClass);

	void ParseObjectPath(const BSTR a_strObjectPath, ParsedObjectPath **a_pParsedObjectPath);

    HRESULT GetMOFSupportClass( LPCWSTR              a_szObjectClass, 
                                auto_ptr<CWlbs_Root> &a_pMofClass,
                                IWbemObjectSink*     a_pResponseHandler );
    BOOL IsCallerAdmin(VOID); 

public:

	CWLBSProvider( BSTR           ObjectPath = NULL, 
                 BSTR           User       = NULL, 
                 BSTR           Password   = NULL, 
                 IWbemContext  *pCtx       = NULL );

	virtual ~CWLBSProvider();

        HRESULT STDMETHODCALLTYPE DoGetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        
        HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
            {return WBEM_E_NOT_SUPPORTED;}
        

        HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
			                 BSTR,
			                 BSTR, 
			                 long, 
                       IWbemContext*,
			                 IWbemClassObject*,
			                 IWbemObjectSink* );

        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
          LPWSTR                   pszUser,
          LONG                     lFlags,
          LPWSTR                   pszNamespace,
          LPWSTR                   pszLocale,
          IWbemServices         *  pNamespace,
          IWbemContext          *  pCtx,
          IWbemProviderInitSink *  pInitSink
        );

};

typedef CWLBSProvider * PCWLBSProvider;

// This class is the class factory for CWLBSProvider objects.

class CWLBSClassFactory : public IClassFactory
{
protected:
  long           m_cRef;

public:
  CWLBSClassFactory(void);
  ~CWLBSClassFactory(void);

  //IUnknown members
  STDMETHODIMP         QueryInterface(REFIID, PPVOID);
  STDMETHODIMP_(ULONG) AddRef(void);
  STDMETHODIMP_(ULONG) Release(void);

  //IClassFactory members
  STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                           ,PPVOID);
  STDMETHODIMP         LockServer(BOOL);
};

typedef CWLBSClassFactory *PCWLBSClassFactory;
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, _uuidof(IWbemClassObject)); 
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, _uuidof(IWbemQualifierSet)); 

//Global Variables

// These variables keep track of when the module can be unloaded
extern long         g_cComponents;
extern long         g_cServerLocks;

//The one and only instance of the WLBS control class. All
//WLBS control commands are implemented via this class.
class CWlbsControlWrapper;
extern CWlbsControlWrapper* g_pWlbsControl;

// General purpose utilities.  

             
SCODE CreateInst( IWbemServices     * pNamespace, 
                  LPWSTR              pKey, 
                  long                lVal, 
                  IWbemClassObject ** pNewInst,
                  WCHAR             * pwcClassName,
                  IWbemContext      * pCtx); 

#endif //_WLBSPROVIDER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_provider.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-1999 Microsoft Corporation.
//
//  File:   WLBSProvider.CPP
//
//  Module: WLBS Instance Provider
//
//  Purpose: Defines the CWLBSProvider class.  An object of this class is
//           created by the class factory for each connection.
//
//  History:
//
////////////////////////////////////////////////////////////////////////////////
#define ENABLE_PROFILE

#include <objbase.h>
#include <process.h>
#include "WLBS_Provider.h"
#include "ClusterWrapper.h"
#include "ControlWrapper.h"
#include "utils.h"
#include "WLBS_Provider.tmh" // for event tracing

////////////////////////////////////////////////////////////////////////////////
//
//CWLBSProvider::CWLBSProvider
// CWLBSProvider::~CWLBSProvider
//
////////////////////////////////////////////////////////////////////////////////
CWLBSProvider::CWLBSProvider(
    BSTR            a_strObjectPath, 
    BSTR            a_strUser, 
    BSTR            a_strPassword, 
    IWbemContext *  a_pContex
  )
{
  m_pNamespace = NULL;
  InterlockedIncrement(&g_cComponents);

  return;
}

CWLBSProvider::~CWLBSProvider(void)
{
  InterlockedDecrement(&g_cComponents);

  return;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                      
//   CWLBSProvider::Initialize                                          
//                                                                      
//   Purpose: This is the implementation of IWbemProviderInit. The method  
//   is called by WinMgMt.                                    
//                                                                      
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::Initialize(
    LPWSTR                  a_pszUser, 
    LONG                    a_lFlags,
    LPWSTR                  a_pszNamespace, 
    LPWSTR                  a_pszLocale,
    IWbemServices         * a_pNamespace, 
    IWbemContext          * a_pCtx,
    IWbemProviderInitSink * a_pInitSink
  )
{
  TRACE_CRIT("->%!FUNC!");

  try {

    //!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      //g_pWlbsControl must be initialized when the first COM instance is invoked 
      //and it must stay alive for the lifetime of the DLL, i.e. do NOT DESTROY
      //it in the destructor of this CLASS until the API cache of the Cluster IP
      //and Password are REMOVED.

      //DO NOT INITIALIZE g_pWlbsControl in DLLMain. DLLMain is invoked with regsvr32
      //and we do not want to initialize WinSock at that time!!! This will BREAK the
      //installation process of the provider.
    //!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    HRESULT hr;

    // The CoImpersonateClient call below is required for CreateFile call to succeed
    hr = CoImpersonateClient();

    if (hr != S_OK) {
        TRACE_CRIT("%!FUNC! CoImpersonateClient() returned error : 0x%x, Throwing an exception", hr);
        throw _com_error( hr );
    }

    // Check for Admin privileges
    if (IsCallerAdmin() == FALSE) 
    {
        TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, Throwing com_error WBEM_E_ACCESS_DENIED exception");
        throw _com_error( WBEM_E_ACCESS_DENIED );
    }

    if( g_pWlbsControl == NULL ) {

      g_pWlbsControl = new CWlbsControlWrapper();

      if( g_pWlbsControl == NULL)
      {
          TRACE_CRIT("%!FUNC! new returned NULL, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
          throw _com_error( WBEM_E_OUT_OF_MEMORY );
      }

    }

    g_pWlbsControl->Initialize();

    hr = CImpersonatedProvider::Initialize
      (
        a_pszUser, 
        a_lFlags,
        a_pszNamespace, 
        a_pszLocale,
        a_pNamespace, 
        a_pCtx,
        a_pInitSink
      );
    TRACE_CRIT("<-%!FUNC! return 0x%x (returned by CImpersonatedProvider::Initialize)", hr);
    return hr;
  }

  catch (...) 
  {
    TRACE_CRIT("%!FUNC! caught an exception");

    TRACE_CRIT("<-%!FUNC! return WBEM_E_FAILED");
    return WBEM_E_FAILED;
  }
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoCreateInstanceEnumAsync(  
    BSTR                  a_strClass, 
    long                  a_lFlags, 
    IWbemContext        * a_pIContex,
    IWbemObjectSink     * a_pIResponseHandler
  )
{
  TRACE_CRIT("->%!FUNC!");

  try {
    // Check for Admin privileges
    if (IsCallerAdmin() == FALSE) 
    {
          TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, Throwing com_error WBEM_E_ACCESS_DENIED exception");
          throw _com_error( WBEM_E_ACCESS_DENIED );
    }

    ASSERT(g_pWlbsControl);

    if (g_pWlbsControl)
    {
        //
        // Re-enumerate all the clusters
        //
        g_pWlbsControl->ReInitialize();
    }
 
    auto_ptr<CWlbs_Root>  pMofClass;

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass(a_strClass, pMofClass, a_pIResponseHandler);

    //call the appropriate wrapper class GetInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->EnumInstances( a_strClass );
  
    TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
    return hRes;
  } 

  catch(_com_error HResErr ) {

    TRACE_CRIT("%!FUNC! caught 0x%x com_error exception",HResErr.Error());
    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    TRACE_CRIT("<-%!FUNC! return 0x%x", HResErr.Error());
    return HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! caught an exception");

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    TRACE_CRIT("<-%!FUNC! return WBEM_E_FAILED");
    return WBEM_E_FAILED;

  }

  TRACE_CRIT("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::GetObjectAsync
//
// Purpose: Gets an instance for a particular object path
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoGetObjectAsync(
    BSTR              a_strObjectPath,
    long              a_lFlags,
    IWbemContext    * a_pIContex,
    IWbemObjectSink * a_pIResponseHandler
  )
{
  TRACE_CRIT("->%!FUNC!");

  ParsedObjectPath* pParsedPath = NULL;

  try {
    // Check for Admin privileges
    if (IsCallerAdmin() == FALSE) 
    {
        TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, Throwing com_error WBEM_E_ACCESS_DENIED exception");
        throw _com_error( WBEM_E_ACCESS_DENIED );
    }

    ASSERT(g_pWlbsControl);

    if (g_pWlbsControl)
    {
        //
        // Re-enumerate all the clusters
        //
        g_pWlbsControl->ReInitialize();
    }

    auto_ptr<CWlbs_Root>  pMofClass;

    //parse the object path
    ParseObjectPath( a_strObjectPath, &pParsedPath );

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass( pParsedPath->m_pClass, pMofClass, a_pIResponseHandler );

    //call the appropriate wrapper class GetInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->GetInstance( pParsedPath );
  
    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
    return hRes;
  } 

  catch(_com_error HResErr) {

    TRACE_CRIT("%!FUNC! caught 0x%x com_error exception",HResErr.Error());

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    TRACE_CRIT("<-%!FUNC! return 0x%x", HResErr.Error());
    return HResErr.Error();
    
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! caught an exception");

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    TRACE_CRIT("<-%!FUNC! return WBEM_E_FAILED");

    return WBEM_E_FAILED;

  }
  TRACE_CRIT("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::DoDeleteInstanceAsync
//
// Purpose: Gets an instance from a particular object path
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoDeleteInstanceAsync(
    BSTR              a_strObjectPath,
    long              a_lFlags,
    IWbemContext    * a_pIContex,
    IWbemObjectSink * a_pIResponseHandler
  )
{
  TRACE_CRIT("->%!FUNC!");

  ParsedObjectPath* pParsedPath = NULL;

  try {
    // Check for Admin privileges
    if (IsCallerAdmin() == FALSE) 
    {
        TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, Throwing com_error WBEM_E_ACCESS_DENIED exception");
        throw _com_error( WBEM_E_ACCESS_DENIED );
    }

    ASSERT(g_pWlbsControl);

    if (g_pWlbsControl)
    {
        //
        // Re-enumerate all the clusters
        //
        g_pWlbsControl->ReInitialize();
    }

    auto_ptr<CWlbs_Root>  pMofClass;

    //parse the object path
    ParseObjectPath( a_strObjectPath, &pParsedPath );

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass( pParsedPath->m_pClass, pMofClass, a_pIResponseHandler );

    //call the appropriate wrapper class GetInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->DeleteInstance( pParsedPath );
  
    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
    return hRes;
  }

  catch(_com_error HResErr) {

    TRACE_CRIT("%!FUNC! caught 0x%x com_error exception",HResErr.Error());
    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    TRACE_CRIT("<-%!FUNC! return 0x%x", HResErr.Error());
    return HResErr.Error();
    
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! caught an exception");

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    TRACE_CRIT("<-%!FUNC! return WBEM_E_FAILED");
    return WBEM_E_FAILED;

  }
  TRACE_CRIT("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::ExecMethodAsync
//
// Purpose: Executes a MOF class method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoExecMethodAsync(
    BSTR               a_strObjectPath, 
    BSTR               a_strMethodName, 
    long               a_lFlags, 
    IWbemContext     * a_pIContex, 
    IWbemClassObject * a_pIInParams, 
    IWbemObjectSink  * a_pIResponseHandler
  )
{
  TRACE_CRIT("->%!FUNC!");

  ParsedObjectPath* pParsedPath   = NULL;

  try {
    // Check for Admin privileges
    if (IsCallerAdmin() == FALSE) 
    {
        TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, Throwing com_error WBEM_E_ACCESS_DENIED exception");
        throw _com_error( WBEM_E_ACCESS_DENIED );
    }

    ASSERT(g_pWlbsControl);

    if (g_pWlbsControl)
    {
        //
        // Re-enumerate all the clusters
        //
        g_pWlbsControl->ReInitialize();
    }
 
    //parse the object path
    auto_ptr<CWlbs_Root>  pMofClass;

    //parse the object path
    ParseObjectPath(a_strObjectPath, &pParsedPath);

    //create an instance of the appropriate MOF support class
    HRESULT hRes = GetMOFSupportClass(pParsedPath->m_pClass, pMofClass, a_pIResponseHandler);

    //execute MOF class method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->ExecMethod( pParsedPath, 
                                    a_strMethodName,
                                    0,
                                    NULL,
                                    a_pIInParams );

    if( pParsedPath )
       CObjectPathParser().Free( pParsedPath );

    TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
    return hRes;

  }

  catch(_com_error HResErr) {

    TRACE_CRIT("%!FUNC! caught 0x%x com_error exception",HResErr.Error());

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    TRACE_CRIT("<-%!FUNC! return 0x%x", HResErr.Error());
    return HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! caught an exception");

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    TRACE_CRIT("<-%!FUNC! return WBEM_E_FAILED");
    return WBEM_E_FAILED;

  }
  TRACE_CRIT("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::PutInstanceAsync
//
// Purpose: Creates or modifies an instance
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWLBSProvider::DoPutInstanceAsync
  ( 
    IWbemClassObject* a_pInst,
    long              a_lFlags,
    IWbemContext*     a_pIContex,
    IWbemObjectSink*  a_pIResponseHandler
  ) 
{
  TRACE_CRIT("->%!FUNC!");

  ParsedObjectPath* pParsedPath  = NULL;
  HRESULT hRes = 0;

  try {
    // Check for Admin privileges
    if (IsCallerAdmin() == FALSE) 
    {
        TRACE_CRIT("%!FUNC! IsCallerAdmin() returned FALSE, Throwing com_error WBEM_E_ACCESS_DENIED exception");
        throw _com_error( WBEM_E_ACCESS_DENIED );
    }

    ASSERT(g_pWlbsControl);

    if (g_pWlbsControl)
    {
        //
        // Re-enumerate all the clusters
        //
        g_pWlbsControl->ReInitialize();
    }
 
    wstring szClass;

    auto_ptr<CWlbs_Root>  pMofClass;

    //retrieve the class name
    GetClass( a_pInst, szClass );

    //create an instance of the appropriate MOF support class
    hRes = GetMOFSupportClass( szClass.c_str(), pMofClass, a_pIResponseHandler );

    //call the appropriate wrapper class PutInstance method
    if( SUCCEEDED( hRes ) && pMofClass.get() != NULL)
      hRes = pMofClass->PutInstance( a_pInst );
  
    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

  } 

  catch(_com_error HResErr) {

    TRACE_CRIT("%!FUNC! caught 0x%x com_error exception",HResErr.Error());

    a_pIResponseHandler->SetStatus(0, HResErr.Error(), NULL, NULL);

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    hRes = HResErr.Error();
  }

  catch(...) {

    TRACE_CRIT("%!FUNC! caught an exception");

    if( pParsedPath )
      CObjectPathParser().Free( pParsedPath );

    a_pIResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, NULL);

    hRes = WBEM_E_FAILED;

  }

  TRACE_CRIT("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::GetMOFSupportClass
//
// Purpose: Determines which MOF class is requested and instantiates the 
//          appropriate internal support class.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWLBSProvider::GetMOFSupportClass(
  LPCWSTR               a_szObjectClass, 
  auto_ptr<CWlbs_Root>& a_pMofClass,
  IWbemObjectSink*      a_pResponseHandler )
{

  TRACE_VERB("->%!FUNC!");
  HRESULT hRes = 0;

  try {
    for( DWORD i = 0; i < MOF_CLASSES::NumClasses; i++ ) {
      if( _wcsicmp( a_szObjectClass, MOF_CLASSES::g_szMOFClassList[i] ) == 0) {
        a_pMofClass = auto_ptr<CWlbs_Root> 
          (MOF_CLASSES::g_pCreateFunc[i]( m_pNamespace, a_pResponseHandler ));
        break;
      }
    }
  }

  catch(CErrorWlbsControl Err) {

    TRACE_VERB("%!FUNC! Caught a Wlbs exception : %ls", (PWCHAR)(Err.Description()));

    IWbemClassObject* pWbemExtStat  = NULL;

    CWlbs_Root::CreateExtendedStatus( m_pNamespace,
                          &pWbemExtStat, 
                          Err.Error(),
                          (PWCHAR)(Err.Description()) );

    a_pResponseHandler->SetStatus(0, WBEM_E_FAILED, NULL, pWbemExtStat);

    //do not return WBEM_E_FAILED, this causes a race condition
    hRes = WBEM_S_NO_ERROR;

    pWbemExtStat->Release();
  }

  TRACE_VERB("<-%!FUNC! return 0x%x", hRes);
  return hRes;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::ParseObjectPath
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
void CWLBSProvider::ParseObjectPath(
  const             BSTR a_strObjectPath, 
  ParsedObjectPath  **a_pParsedObjectPath )
{
  CObjectPathParser PathParser;

  TRACE_VERB("->%!FUNC! a_strObjectPath : %ls", a_strObjectPath);

  ASSERT( a_pParsedObjectPath );

  //make sure this is NULL
  *a_pParsedObjectPath = NULL;


  int nStatus = PathParser.Parse(a_strObjectPath,  a_pParsedObjectPath);

  if(nStatus != 0) {
    
    if( *a_pParsedObjectPath) 
      PathParser.Free( *a_pParsedObjectPath );

    TRACE_CRIT("%!FUNC! CObjectPathParser::Parse failed, Throwing com_error WBEM_E_FAILED exception");
    TRACE_VERB("<-%!FUNC!");
    throw _com_error( WBEM_E_FAILED );
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWLBSProvider::GetClass
//
// Purpose: Retrieve the class name from an IWbemClassObject.
//
////////////////////////////////////////////////////////////////////////////////
void CWLBSProvider::GetClass(
  IWbemClassObject* a_pClassObject, 
  wstring&          a_szClass )
{
  BSTR      strClassName = NULL;
  VARIANT   vClassName;
  HRESULT   hRes;

  TRACE_VERB("->%!FUNC!");

  try {

    VariantInit( &vClassName );

    strClassName = SysAllocString( L"__Class" );

    if( !strClassName )
    {
      TRACE_CRIT("%!FUNC! SysAllocString returned NULL, Throwing com_error WBEM_E_OUT_OF_MEMORY exception");
      throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    hRes = a_pClassObject->Get( strClassName,
                                0,
                                &vClassName,
                                NULL,
                                NULL);

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Get returned error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    a_szClass.assign( static_cast<LPWSTR>(vClassName.bstrVal) );

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vClassName ))
    {
        TRACE_CRIT("%!FUNC! VariantClear returned error, Throwing com_error WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }

    if( strClassName ) {
      SysFreeString( strClassName );
      strClassName = NULL;
    }

  }
  catch( ... ) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vClassName );

    if( strClassName ) {
      SysFreeString( strClassName );
      strClassName = NULL;
    }

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_VERB("<-%!FUNC!");
    throw;
  }

  TRACE_VERB("<-%!FUNC!");
}


////////////////////////////////////////////////////////////////////////////////
//
// Name        : IsCallerAdmin
// Description : This function checks if the caller is a member of the 
//               Administrators local group. Since the provider is acting on
//               behalf of the client, it is important to IMPERSONATE the client
//               BEFORE calling this function. Impersonating the client will ensure
//               that this function checks if the client (& NOT this process that 
//               runs under the identity of System(?)) is a member of the Administrators
//               local group.
// Arguments   : None. 
// Return Value: 
//   TRUE - Caller is a member of Administrators local group. 
//   FALSE - Caller is NOT a member of Administrators local group. 
////////////////////////////////////////////////////////////////////////////////
BOOL CWLBSProvider::IsCallerAdmin(VOID) 
{
    BOOL bRet;
    PSID AdministratorsGroup; 
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    TRACE_VERB(L"->%!FUNC!");

    //
    // Allocate and Initialize SID for Administrators in the built-in system domain 
    //
    bRet = AllocateAndInitializeSid(&NtAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID, // The built-in system domain (S-1-5-32)
                                 DOMAIN_ALIAS_RID_ADMINS,     // Local group used for administration of the domain
                                 0, 0, 0, 0, 0, 0,
                                 &AdministratorsGroup); 
    if(bRet) 
    {
        //
        // Is SID enabled in the impersonation token of the calling thread ?
        //
        if (!CheckTokenMembership(NULL, // Use the Impersonation token of the calling thread
                                  AdministratorsGroup, 
                                  &bRet)) 
        {
            bRet = FALSE;
            TRACE_CRIT(L"%!FUNC! CheckTokenMembership() failed. Error : 0x%x", GetLastError()); 
        } 
        FreeSid(AdministratorsGroup); 
    }
    else
    {
        TRACE_CRIT("%!FUNC! AllocateAndInitializeSid() failed. Error : 0x%x", GetLastError()); 
    }

    TRACE_VERB(L"<-%!FUNC! Returning %ls", bRet ? L"TRUE" : L"FALSE");
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_root.cpp ===
#include "WLBS_Provider.h"
#include "WLBS_Root.h"
#include "utils.h"
#include "controlwrapper.h"
#include "param.h"
#include "WLBS_Root.tmh" // for event tracing

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::CWlbs_Root
//
// Purpose: Constructor
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root::CWlbs_Root(CWbemServices*   a_pNameSpace, 
                       IWbemObjectSink* a_pResponseHandler)
: m_pNameSpace(NULL), m_pResponseHandler(NULL)
{

  //m_pNameSpace and m_pResponseHandler are initialized to NULL
  //by CWlbs_Root
  if(!a_pNameSpace || !a_pResponseHandler)
    throw _com_error( WBEM_E_INVALID_PARAMETER );

    m_pNameSpace = a_pNameSpace;

    m_pResponseHandler = a_pResponseHandler;
    m_pResponseHandler->AddRef();

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::~CWlbs_Root
//
// Purpose: Destructor
//
////////////////////////////////////////////////////////////////////////////////
CWlbs_Root::~CWlbs_Root()
{

  if( m_pNameSpace )
    m_pNameSpace = NULL;

  if( m_pResponseHandler ) {
    m_pResponseHandler->Release();
    m_pResponseHandler = NULL;
  }

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::SpawnInstance
//
// Purpose: This obtains an instance of a WBEM class.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::SpawnInstance 
  ( 
    LPCWSTR               a_szClassName, 
    IWbemClassObject**    a_ppWbemInstance 
  )
{
  HRESULT hResult;
  IWbemClassObjectPtr pWlbsClass;

  TRACE_VERB("->%!FUNC! a_szClassName : %ls", a_szClassName);

  //get the MOF class object
  hResult = m_pNameSpace->GetObject(
    _bstr_t( a_szClassName ),  
    0,                          
    NULL,                       
    &pWlbsClass,            
    NULL);                      

  if( FAILED(hResult) ) {
    TRACE_CRIT("%!FUNC! CWbemServices::GetObject failed with error : 0x%x, Throwing com_error exception", hResult);
    TRACE_VERB("<-%!FUNC!");
    throw _com_error(hResult);
  }

  //spawn an instance
  hResult = pWlbsClass->SpawnInstance( 0, a_ppWbemInstance );

  if( FAILED( hResult ) )
  {
    TRACE_CRIT("%!FUNC! IWbemClassObjectPtr::SpawnInstance failed with error : 0x%x, Throwing com_error exception", hResult);
    TRACE_VERB("<-%!FUNC!");
    throw _com_error( hResult );
  }
  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::GetMethodOutputInstance
//
// Purpose: This obtains an IWbemClassObject that is used to store the 
//          output parameters for a method call. The caller is responsible for
//          releasing the output object.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::GetMethodOutputInstance
  (
   LPCWSTR              a_szMethodClass,
   const BSTR           a_strMethodName,
   IWbemClassObject**   a_ppOutputInstance
  )
{

  IWbemClassObjectPtr pMethClass;
  IWbemClassObjectPtr pOutputClass;
  IWbemClassObjectPtr pOutParams;
  BSTR strMethodClass = NULL;

  HRESULT hResult;

  TRACE_VERB("->%!FUNC! a_szMethodClass : %ls, a_strMethodName : %ls", a_szMethodClass, a_strMethodName);

  ASSERT( a_szMethodClass );

  try {

    strMethodClass = SysAllocString( a_szMethodClass );

    if( !strMethodClass )
    {
        TRACE_CRIT("%!FUNC! SysAllocString failed for a_szMethodClass : %ls, Throwing com_error WBEM_E_OUT_OF_MEMORY exception", a_szMethodClass);
        throw _com_error( WBEM_E_OUT_OF_MEMORY );
    }

    hResult = m_pNameSpace->GetObject
      ( strMethodClass, 
        0, 
        NULL, 
        &pMethClass, 
        NULL
      );

    if( FAILED( hResult ) )
    {
        TRACE_CRIT("%!FUNC! CWbemServices::GetObject failed with error : 0x%x, Throwing com_error exception", hResult);
        throw _com_error( hResult );
    }

    hResult = pMethClass->GetMethod( a_strMethodName, 0, NULL, &pOutputClass );

    if( FAILED( hResult ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObjectPtr::GetMethod failed with error : 0x%x, Throwing com_error exception", hResult);
        throw _com_error( hResult );
    }

    hResult = pOutputClass->SpawnInstance( 0, a_ppOutputInstance );

    if( FAILED( hResult ) ) {
        TRACE_CRIT("%!FUNC! IWbemClassObjectPtr::SpawnInstance failed with error : 0x%x, Throwing com_error exception", hResult);
        throw _com_error(hResult);
    }

    if( strMethodClass ) {

      SysFreeString( strMethodClass );
      strMethodClass = NULL;

    }

  }
  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception"); 

    if( strMethodClass ) {

      SysFreeString( strMethodClass );
      strMethodClass = NULL;

    }

    TRACE_CRIT("%!FUNC! Rethrowing exception"); 
    TRACE_VERB("<-%!FUNC!");
    throw;
  }

  TRACE_VERB("<-%!FUNC!");

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::UpdateConfigProp
//
// Purpose: This extracts the propery name and value from the WBEM object and if
//          the property is not set to VT_NULL then the configuration is updated
//          else the original configuration, the Src parameter, is used.
//    
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::UpdateConfigProp
  ( 
          wstring&    a_szDest, 
    const wstring&    a_szSrc,
          LPCWSTR     a_szPropName, 
    IWbemClassObject* a_pNodeInstance 
  )
{

  HRESULT hRes        = NULL;
  
  VARIANT vNewValue;

  TRACE_VERB("->%!FUNC! (wstring version) a_szPropName : %ls",a_szPropName);

  try {
    VariantInit( &vNewValue );

    hRes = a_pNodeInstance->Get( _bstr_t( a_szPropName ),
                                  0,
                                  &vNewValue,
                                  NULL,
                                  NULL );

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    if( vNewValue.vt != VT_NULL )
      a_szDest.assign( vNewValue.bstrVal ); //update to new value
    else
      a_szDest = a_szSrc;                   //keep original value

    // CLD: Need to check return code for error
    if (S_OK != VariantClear(  &vNewValue  ))
    {
        TRACE_CRIT("%!FUNC! VariantClear failed, Throwing com_error WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }
  }
  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");
    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vNewValue );

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_VERB("<-%!FUNC!");
    throw;
  }

  TRACE_VERB("<-%!FUNC!");

}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::UpdateConfigProp
//
// Purpose: This extracts the propery name and value from the WBEM object and if
//          the property is not set to VT_NULL then the configuration is updated
//          else the original configuration, the Src parameter, is used.
//    
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::UpdateConfigProp
  ( 
    bool&              a_bDest, 
    bool               a_bSrc,
    LPCWSTR            a_szPropName, 
    IWbemClassObject*  a_pNodeInstance  
  )
{

  BSTR    strPropName = NULL;
  HRESULT hRes        = NULL;
  
  VARIANT vNewValue;

  TRACE_VERB("->%!FUNC! (bool version) a_szPropName : %ls",a_szPropName);

  try {

    VariantInit( &vNewValue );

    hRes = a_pNodeInstance->Get
      (
        _bstr_t( a_szPropName ),
        0,
        &vNewValue,
        NULL,
        NULL 
      );

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    if( vNewValue.vt != VT_NULL )
      a_bDest = (vNewValue.boolVal != 0); //update to new value
    else
      a_bDest = a_bSrc;                   //keep original value

    // CLD: Need to check return code for error
    if (S_OK != VariantClear( &vNewValue ))
    {
        TRACE_CRIT("%!FUNC! VariantClear failed, Throwing com_error WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }
    SysFreeString( strPropName );

  }
  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vNewValue );

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_VERB("<-%!FUNC!");
    throw;
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::UpdateConfigProp
//
// Purpose: This extracts the propery name and value from the WBEM object and if
//          the property is not set to VT_NULL then the configuration is updated
//          else the original configuration, the Src parameter, is used.
//    
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::UpdateConfigProp
  ( 
    DWORD&             a_dwDest, 
    DWORD              a_dwSrc,
    LPCWSTR            a_szPropName, 
    IWbemClassObject*  a_pNodeInstance 
  )
{

  HRESULT hRes = NULL;
  
  VARIANT vNewValue;

  TRACE_VERB("->%!FUNC! (dword version) a_szPropName : %ls",a_szPropName);

  try {
    VariantInit( &vNewValue );

    hRes = a_pNodeInstance->Get(  _bstr_t( a_szPropName ),
                                  0,
                                  &vNewValue,
                                  NULL,
                                  NULL );

    if( FAILED( hRes ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception", hRes);
        throw _com_error( hRes );
    }

    if( vNewValue.vt != VT_NULL )
      a_dwDest = vNewValue.lVal;
    else
      a_dwDest = a_dwSrc;

    // CLD: Need to check return code for error
    if (S_OK != VariantClear(  &vNewValue  ))
    {
        TRACE_CRIT("%!FUNC! VariantClear failed, Throwing com_error WBEM_E_FAILED exception");
        throw _com_error( WBEM_E_FAILED );
    }
  }
  catch(...) {

    TRACE_CRIT("%!FUNC! Caught an exception");

    // CLD: Need to check return code for error
    // No throw here since we are already throwing an exception.
    VariantClear( &vNewValue );

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_VERB("<-%!FUNC!");
    throw;
  }

  TRACE_VERB("<-%!FUNC!");
}

////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::CreateExtendedStatus
//
// Purpose: Spawn and fill a Wbem extended status object with error
//          information.
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::CreateExtendedStatus
  (
    CWbemServices*      a_pNameSpace,
    IWbemClassObject**  a_ppWbemInstance,
    DWORD               a_dwErrorCode,
    LPCWSTR             /*a_szDescription*/
  )
{
  HRESULT hResult;
  IWbemClassObjectPtr  pWlbsExtendedObject;

  TRACE_VERB("->%!FUNC! a_dwErrorCode : 0x%x",a_dwErrorCode);

  try {
    ASSERT(a_ppWbemInstance);
    ASSERT(a_pNameSpace );

    //this is the only routine that references
    //the MicrosoftNLB_ExtendedStatus object
    //if other routines start to use the class,
    //or if it adds additional properties, then
    //is should be added to the MOF data files
    //along with the other classes
    //get the MOF class object
    hResult = a_pNameSpace->GetObject(
      _bstr_t( L"MicrosoftNLB_ExtendedStatus" ),  
      0,                          
      NULL,                       
      &pWlbsExtendedObject,            
      NULL);                      

    if( FAILED(hResult) ) {
        TRACE_CRIT("%!FUNC! CWbemServices::GetObject failed with error : 0x%x, Throwing com_error exception", hResult);
        throw _com_error(hResult);
    }

    //spawn an instance
    hResult = pWlbsExtendedObject->SpawnInstance( 0, a_ppWbemInstance );

    if( FAILED( hResult ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObjectPtr::SpawnInstance failed with error : 0x%x, Throwing com_error exception", hResult);
        throw _com_error( hResult );
    }

    if( FAILED( hResult ) )
      throw _com_error( hResult );

    //add status code
    hResult = (*a_ppWbemInstance)->Put
    (
  
      _bstr_t( L"StatusCode" ) ,
      0                                        ,
      &( _variant_t( (long)a_dwErrorCode ) )   ,
      NULL
    );

    if( FAILED( hResult ) )
    {
        TRACE_CRIT("%!FUNC! IWbemClassObject::Get failed with error : 0x%x, Throwing com_error exception", hResult);
        throw _com_error( hResult );
    }
  }
  
  catch(...) {
    TRACE_CRIT("%!FUNC! Caught an exception");
    if( *a_ppWbemInstance )
      (*a_ppWbemInstance)->Release();

    TRACE_CRIT("%!FUNC! Rethrowing exception");
    TRACE_VERB("<-%!FUNC!");
    throw;
  }
  TRACE_VERB("<-%!FUNC!");
}




//+----------------------------------------------------------------------------
//
// Function:  CWlbs_Root::ExtractHostID
//
// Description:  Extract the Host ID from name "clusterIp:HostId"
//
// Arguments: const wstring& a_wstrName - 
//            
//
// Returns:   DWORD  - Host ID, or -1 if failed
//
// History: fengsun  Created Header    7/13/00
//
//+----------------------------------------------------------------------------
DWORD CWlbs_Root::ExtractHostID(const wstring& a_wstrName)
{
  long nColPos;

  TRACE_VERB("->%!FUNC! a_wstrName : %ls",a_wstrName.c_str());

  nColPos = a_wstrName.find( L":" );

  if (nColPos == wstring::npos)
  {
      //
      // Not found
      //

      TRACE_CRIT("%!FUNC! Invalid name : %ls, Colon(:) not found",a_wstrName.c_str());
      TRACE_VERB("<-%!FUNC! return -1");
      return (DWORD)-1;
  }

  wstring wstrHostID = a_wstrName.substr( nColPos+1, a_wstrName.size()-1 );
  DWORD dwHostId = _wtol( wstrHostID.c_str() );
  
  TRACE_VERB("<-%!FUNC! return HostId : 0x%x",dwHostId);
  return dwHostId;
}



//+----------------------------------------------------------------------------
//
// Function:  CWlbs_Root::ExtractClusterIP
//
// Description:  Extract the cluster IP address from name "clusterIp:HostId"
//
// Arguments: const wstring& a_wstrName - 
//            
//
// Returns:   DWORD - Cluster IP, or INADDR_NONE (-1) if falied
//
// History: fengsun  Created Header    7/13/00
//
//+----------------------------------------------------------------------------
DWORD CWlbs_Root::ExtractClusterIP(const wstring& a_wstrName)
{
  long nColPos;

  TRACE_VERB("->%!FUNC! a_wstrName : %ls",a_wstrName.c_str());

  nColPos = a_wstrName.find( L":" );

  if (nColPos == wstring::npos)
  {
      //
      // Not found
      //

      TRACE_CRIT("%!FUNC! Invalid name : %ls, Colon(:) not found",a_wstrName.c_str());
      TRACE_VERB("<-%!FUNC! return -1");
      return (DWORD)-1;
  }

  wstring wstrClusterIP = a_wstrName.substr( 0, nColPos );

  DWORD dwClusterIp =  WlbsResolve( wstrClusterIP.c_str() );

  TRACE_VERB("<-%!FUNC! return Cluster IP : 0x%x",dwClusterIp);
  return dwClusterIp;
}


////////////////////////////////////////////////////////////////////////////////
//
// CWlbs_Root::ConstructHostName
//
// Purpose: 
//
////////////////////////////////////////////////////////////////////////////////
void CWlbs_Root::ConstructHostName
  ( 
    wstring& a_wstrHostName, 
    DWORD    a_dwClusIP, 
    DWORD    a_dwHostID 
  )
{
  WCHAR wszHostID[40];
  
  AddressToString( a_dwClusIP, a_wstrHostName );
  a_wstrHostName += L':';
  a_wstrHostName += _ltow( a_dwHostID, wszHostID, 10 );

}



CWlbsClusterWrapper* GetClusterFromHostName(CWlbsControlWrapper* pControl, 
                                            wstring wstrHostName)
{
    DWORD dwClusterIpOrIndex = CWlbs_Root::ExtractClusterIP(wstrHostName);

    return pControl->GetClusterFromIpOrIndex(dwClusterIpOrIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\xml\test\main.cpp ===
/*
 * Filename: Main.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>
#include "msxml3.tlh"

#include <string.h>

#include "NLB_XMLDocument.h"

#include <vector>
#include <string>
#include <map>
using namespace std;

void BuildNLBCluster (NLB_Cluster & Cluster) {
    NLB_IPAddress IPAddress;
    NLB_Host      Host;
    NLB_PortRule  Rule;

    Cluster.SetName(L"Heyfoxymophandlemama");
    Cluster.SetLabel(L"That's me");

    IPAddress.Clear();

    IPAddress.SetIPAddressType(NLB_IPAddress::Primary);
    IPAddress.SetIPAddress(L"129.237.220.105");

    Cluster.SetPrimaryClusterIPAddress(IPAddress);

    IPAddress.Clear();

    IPAddress.SetIPAddressType(NLB_IPAddress::Secondary);
    IPAddress.SetIPAddress(L"129.237.120.110");
    IPAddress.SetSubnetMask(L"255.255.248.0");

    Cluster.AddSecondaryClusterIPAddress(IPAddress);

    IPAddress.Clear();

    IPAddress.SetIPAddressType(NLB_IPAddress::Secondary);
    IPAddress.SetIPAddress(L"129.237.29.1");

    Cluster.AddSecondaryClusterIPAddress(IPAddress);

    Cluster.SetClusterMode(NLB_ClusterMode::Multicast);

    Cluster.SetMACAddress(L"03-bf-0a-0b-0c-0d");

    Host.SetName(L"PEZ");

    Host.SetDNSHostname(L"shouse-laptop.ntdev.microsoft.com");

    Host.SetHostID(4);

    IPAddress.Clear();

    IPAddress.SetIPAddressType(NLB_IPAddress::Dedicated);
    IPAddress.SetIPAddress(L"192.110.32.11");

    Host.SetDedicatedIPAddress(IPAddress);

    Cluster.AddHost(Host);

    Rule.SetName(L"TheWholeNineYards");

    Rule.SetPortRange(0, 65535);

    IPAddress.Clear();

    IPAddress.SetIPAddressType(NLB_IPAddress::Virtual);
    IPAddress.SetIPAddress(L"129.237.120.110");

    Rule.SetVirtualIPAddress(IPAddress);

    Rule.SetFilteringMode(NLB_PortRuleFilteringMode::Multiple);

    Rule.AddMultipleHostFilteringLoadWeight(L"PEZ", 65);

    Rule.ChangeMultipleHostFilteringLoadWeight(L"PEZ", 80);

    Cluster.AddPortRule(Rule);
}

int __cdecl wmain (int argc, WCHAR ** argv) {
    vector<NLB_Cluster> Clusters;
    WCHAR               InFilename[MAX_PATH];
    WCHAR               OutFilename[MAX_PATH];
    bool                bValidateOnly = false;
    bool                bCreateCluster = false;
    bool                bParseFile = false;
    bool                bSaveFile = false;
    NLB_XMLDocument *   pDocument;
    NLB_XMLError        error;
    NLB_Cluster         myCluster;
    int                 arg;
    HRESULT             hr = S_OK;

    for (arg = 1; arg < argc; arg++) {
        if (argv[arg][0] == L'-') {
            if (!lstrcmpi(argv[arg] + 1, L"in")) {
                arg++;
                wcsncpy(InFilename, argv[arg], MAX_PATH);
                bParseFile = true;
            } else if (!lstrcmpi(argv[arg] + 1, L"out")) {
                arg++;
                wcsncpy(OutFilename, argv[arg], MAX_PATH);
                bSaveFile = true;
            } else if (!lstrcmpi(argv[arg] + 1, L"create")) {
                bCreateCluster = true;
            } else if (!lstrcmpi(argv[arg] + 1, L"validate")) {
                bValidateOnly = true;
            } else {
                printf("Invalid argument: %ls\n", argv[arg]);
                goto usage;
            }
                
        } else {
            printf("Invalid argument: %ls\n", argv[arg]);
            goto usage;
        }
    }

    pDocument = new NLB_XMLDocument();

    if (bParseFile) {
        if (bValidateOnly) {
            printf("\nValidating %ls...\n", InFilename);
            hr = pDocument->Validate(InFilename);
        } else {
            printf("\nParsing %ls...\n", InFilename);
            hr = pDocument->Parse(InFilename, Clusters);
        }
        
        printf("\n");
        
        if (FAILED(hr)) {
            pDocument->GetParseError(error);
            
            fprintf(stderr, "Error 0x%08x:\n\n%ls\n", error.code, error.wszReason);
            
            if (error.line > 0) fprintf(stderr, "Error on line %d, position %d in \"%ls\".\n", error.line, error.character, error.wszURL);
            
            return -1;
        } else {
            fprintf(stderr, "XML document loaded successfully...\n");
        }
        
        pDocument->Print(Clusters);
    }

    if (bCreateCluster) {
        NLB_IPAddress IPAddress;
        
        BuildNLBCluster(myCluster);
        
        Clusters.push_back(myCluster);

        myCluster.Clear();

        myCluster.SetName(L"www.msn.com");
        myCluster.SetLabel(L"Duplicate");
        
        IPAddress.SetIPAddressType(NLB_IPAddress::Primary);
        IPAddress.SetIPAddress(L"10.0.0.109");
        
        myCluster.SetPrimaryClusterIPAddress(IPAddress);

        Clusters.push_back(myCluster);
        
        pDocument->Print(Clusters);
    }
        
    if (bSaveFile) pDocument->Save(OutFilename, Clusters);

    return 0;

 usage:

    printf("Usage: %ls [-in <XML filename>] [-out <XML filename>] [-create] [-validate]\n", argv[0]);

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\wlbs_root.h ===
#ifndef _WLBSCLASSES_INCLUDED_
#define _WLBSCLASSES_INCLUDED_

#include <atlbase.h>
#include <wbemprov.h>
#include "debug.h"

//forward declarations
struct ParsedObjectPath;

////////////////////////////////////////////////////////////////////////////////
//
// class CWlbs_Root
//
// Purpose: This class servers as the base for all classes that implement 
//          specific Wbem classes. A pointer to this class is utilized
//          polymorphically within CWLBSProvider.
//
////////////////////////////////////////////////////////////////////////////////
class CWlbs_Root

{
public:
           CWlbs_Root(CWbemServices* a_pNameSpace, IWbemObjectSink* a_pResponseHandler);
  virtual ~CWlbs_Root();

	static void CreateExtendedStatus( CWbemServices*     a_pNameSpace,
                             IWbemClassObject** a_ppWbemInstance,
                             DWORD              a_dwErrorCode     = 0,
                             LPCWSTR            a_szDescription   = NULL
                           );

  HRESULT virtual GetInstance( 
                              const ParsedObjectPath* a_pParsedPath,
                              long                    a_lFlags = 0, 
                              IWbemContext*           a_pIContex = NULL) = 0;

  HRESULT virtual DeleteInstance( 
                                 const ParsedObjectPath* a_pParsedPath,
                                 long                    a_lFlags            = 0,
                                 IWbemContext*           a_pIContex          = NULL
                                )
                                {
                                  throw _com_error( WBEM_E_NOT_SUPPORTED ); 
                                  return WBEM_E_FAILED;
                                }

  HRESULT virtual PutInstance( 
                               IWbemClassObject* a_pInstance,
                               long              a_lFlags            = 0,
                               IWbemContext*     a_pIContex          = NULL
                             ) 
                              {
                               throw _com_error( WBEM_E_NOT_SUPPORTED ); 
                               return WBEM_E_FAILED;
                              }

  HRESULT virtual EnumInstances( 
                                BSTR             a_bstrClass         = NULL,
                                long             a_lFlags            = 0, 
                                IWbemContext*    a_pIContex          = NULL
                               ) = 0;

  HRESULT virtual ExecMethod( 
                             const ParsedObjectPath* a_pParsedPath  , 
                             const BSTR&             a_strMethodName, 
                             long                    a_lFlags            = 0, 
                             IWbemContext*           a_pIContex          = NULL, 
                             IWbemClassObject*       a_pIInParams        = NULL
                            )
                            {
                             throw _com_error(WBEM_E_NOT_SUPPORTED); 
                             return WBEM_E_NOT_SUPPORTED;
                            }

  void SpawnInstance ( LPCWSTR            a_szClassName, 
                       IWbemClassObject** a_ppWbemInstance );

protected:
  CWbemServices*    m_pNameSpace;
  IWbemObjectSink*  m_pResponseHandler;

  void virtual GetMethodOutputInstance( LPCWSTR             a_szMethodClass,
                                        const BSTR          a_strMethodName,
                                        IWbemClassObject**  a_ppOutputInstance);

  void UpdateConfigProp(       wstring&    a_szDest, 
                         const wstring&    a_szSrc,
                         LPCWSTR           a_szPropName, 
                         IWbemClassObject* a_pNodeInstance );

  void UpdateConfigProp( bool&             a_bDest, 
                         bool              a_bSrc,
                         LPCWSTR           a_szPropName, 
                         IWbemClassObject* a_pNodeInstance );

  void UpdateConfigProp( DWORD&            a_bDest, 
                         DWORD             a_bSrc,
                         LPCWSTR           a_szPropName, 
                         IWbemClassObject* a_pNodeInstance );

  static void ConstructHostName( wstring& a_wstrHostName, 
                          DWORD    a_dwClusIP, 
                          DWORD    a_dwHostID );

public:
  static DWORD ExtractHostID   (const wstring& a_wstrName);
  static DWORD ExtractClusterIP(const wstring& a_wstrName);

private:
  //This constructor must not be used.
  CWlbs_Root();

};

class CWlbsClusterWrapper;
class CWlbsControlWrapper;

CWlbsClusterWrapper* GetClusterFromHostName(CWlbsControlWrapper* pControl, 
                                            wstring wstrHostName);


#endif //_WLBSCLASSES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd ddk_printscan.ini ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\xml\nlb_xmldocument.cpp ===
/*
 * Filename: NLB_XMLDocument.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>
#include <msxml3.tlh>

#include "NLB_XMLDocument.h"

#define CHECKHR(x)        {hr = x; if (FAILED(hr)) {goto CleanUp;}}
#define CHECKALLOC(x)     {if (!x) {hr = E_FAIL; goto CleanUp;}}
#define SAFERELEASE(p)    {if (p) {(p)->Release(); p = NULL;}}
#define SAFEFREESTRING(p) {if (p) {SysFreeString(p); p = NULL;}}

#define NLB_XML_SCHEMA_NAME                  L"x-schema:MicrosoftNLB"
#define NLB_XML_SCHEMA_PATH                  L"MicrosoftNLB.xml"

#define NLB_XML_ELEMENT_NLB                  L"NLB"
#define NLB_XML_ELEMENT_CLUSTER              L"Cluster"
#define NLB_XML_ELEMENT_PROPERTIES           L"Properties"
#define NLB_XML_ELEMENT_HOSTS                L"Hosts"
#define NLB_XML_ELEMENT_HOST                 L"Host"
#define NLB_XML_ELEMENT_PORTRULES            L"PortRules"
#define NLB_XML_ELEMENT_PORTRULE             L"PortRule"
#define NLB_XML_ELEMENT_PRIMARY_IPADDRESS    L"PrimaryIPAddress"
#define NLB_XML_ELEMENT_SECONDARY_IPADDRESS  L"SecondaryIPAddress"
#define NLB_XML_ELEMENT_IGMPMCAST_IPADDRESS  L"IGMPMulticastIPAddress"
#define NLB_XML_ELEMENT_DEDICATED_IPADDRESS  L"DedicatedIPAddress"
#define NLB_XML_ELEMENT_CONNECTION_IPADDRESS L"ConnectionIPAddress"
#define NLB_XML_ELEMENT_VIRTUAL_IPADDRESS    L"VirtualIPAddress"
#define NLB_XML_ELEMENT_IPADDRESS            L"IPAddress"
#define NLB_XML_ELEMENT_ADDRESS              L"Address"
#define NLB_XML_ELEMENT_SUBNETMASK           L"SubnetMask"
#define NLB_XML_ELEMENT_ADAPTER              L"Adapter"
#define NLB_XML_ELEMENT_GUID                 L"GUID"
#define NLB_XML_ELEMENT_NAME                 L"Name"
#define NLB_XML_ELEMENT_DOMAINNAME           L"DomainName"
#define NLB_XML_ELEMENT_HOSTNAME             L"HostName"
#define NLB_XML_ELEMENT_NETWORKADDRESS       L"NetworkAddress"
#define NLB_XML_ELEMENT_CLUSTER_MODE         L"Mode"
#define NLB_XML_ELEMENT_REMOTE_CONTROL       L"RemoteControl"
#define NLB_XML_ELEMENT_BDA                  L"BDA"
#define NLB_XML_ELEMENT_TEAMID               L"TeamID"
#define NLB_XML_ELEMENT_HASHING              L"Hashing"
#define NLB_XML_ELEMENT_FILTERING            L"Filtering"
#define NLB_XML_ELEMENT_LOAD                 L"Load"
#define NLB_XML_ELEMENT_PRIORITY             L"Priority"
#define NLB_XML_ELEMENT_NODE                 L"Node"
#define NLB_XML_ELEMENT_INITIAL_STATE        L"InitialState"

#define NLB_XML_ATTRIBUTE_NAMESPACE          L"xmlns"
#define NLB_XML_ATTRIBUTE_NAME               L"Name"
#define NLB_XML_ATTRIBUTE_TEXT               L"Text"
#define NLB_XML_ATTRIBUTE_ENABLED            L"Enabled"
#define NLB_XML_ATTRIBUTE_MASTER             L"Master"
#define NLB_XML_ATTRIBUTE_REVERSE            L"Reverse"
#define NLB_XML_ATTRIBUTE_PASSWORD           L"Password"
#define NLB_XML_ATTRIBUTE_HOSTID             L"HostID"
#define NLB_XML_ATTRIBUTE_STATE              L"State"
#define NLB_XML_ATTRIBUTE_START              L"Start"
#define NLB_XML_ATTRIBUTE_END                L"End"
#define NLB_XML_ATTRIBUTE_PROTOCOL           L"Protocol"
#define NLB_XML_ATTRIBUTE_MODE               L"Mode"
#define NLB_XML_ATTRIBUTE_AFFINITY           L"Affinity"
#define NLB_XML_ATTRIBUTE_PRIORITY           L"Priority"
#define NLB_XML_ATTRIBUTE_WEIGHT             L"Weight"
#define NLB_XML_ATTRIBUTE_DEFAULT            L"Default"
#define NLB_XML_ATTRIBUTE_STARTED            L"Started"
#define NLB_XML_ATTRIBUTE_STOPPED            L"Stopped"
#define NLB_XML_ATTRIBUTE_SUSPENDED          L"Suspended"
#define NLB_XML_ATTRIBUTE_PERSIST_STARTED    L"PersistStarted"
#define NLB_XML_ATTRIBUTE_PERSIST_STOPPED    L"PersistStopped"
#define NLB_XML_ATTRIBUTE_PERSIST_SUSPENDED  L"PersistSuspended"

#define NLB_XML_VALUE_NLB_SCHEMA             L"x-schema:MicrosoftNLB.xml"
#define NLB_XML_VALUE_UNICAST                L"Unicast"
#define NLB_XML_VALUE_MULTICAST              L"Multicast"
#define NLB_XML_VALUE_IGMP                   L"IGMP"
#define NLB_XML_VALUE_STARTED                L"Started"
#define NLB_XML_VALUE_STOPPED                L"Stopped"
#define NLB_XML_VALUE_SUSPENDED              L"Suspended"
#define NLB_XML_VALUE_TCP                    L"TCP"
#define NLB_XML_VALUE_UDP                    L"UDP"
#define NLB_XML_VALUE_BOTH                   L"Both"
#define NLB_XML_VALUE_ENABLED                L"Enabled"
#define NLB_XML_VALUE_DISABLED               L"Disabled"
#define NLB_XML_VALUE_DRAINING               L"Draining"
#define NLB_XML_VALUE_SINGLE                 L"Single"
#define NLB_XML_VALUE_MULTIPLE               L"Multiple"
#define NLB_XML_VALUE_NONE                   L"None"
#define NLB_XML_VALUE_CLASSC                 L"ClassC"

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_XMLDocument::NLB_XMLDocument () {
	
    pDoc = NULL;
    pSchema = NULL;

    bShowErrorPopups = false;

    ZeroMemory(&ParseError, sizeof(NLB_XMLError));

    CoInitialize(NULL);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_XMLDocument::NLB_XMLDocument (bool bSilent) {
	
    pDoc = NULL;
    pSchema = NULL;

    bShowErrorPopups = !bSilent;

    ZeroMemory(&ParseError, sizeof(NLB_XMLError));

    CoInitialize(NULL);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_XMLDocument::~NLB_XMLDocument () {

    CoUninitialize();
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLDocument::GetParseError (NLB_XMLError & Error) {

    Error = ParseError;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLDocument::SetParseError (HRESULT hrCode, PWSTR pwszReason) {

    ParseError.code = hrCode;
    
    lstrcpy(ParseError.wszReason, pwszReason);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::LoadDocument (BSTR pBURL) {
    MSXML2::IXMLDOMParseError * pXMLError = NULL;
    VARIANT      vURL;
    VARIANT_BOOL vBool;
    VARIANT      vSchema;
    HRESULT      hr = S_OK;

    CHECKHR(pDoc->put_async(VARIANT_FALSE));

    VariantInit(&vURL);

    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;

    CHECKHR(CoCreateInstance(MSXML2::CLSID_XMLSchemaCache, NULL, CLSCTX_SERVER, MSXML2::IID_IXMLDOMSchemaCollection, (LPVOID*)(&pSchema)));
    
    hr = pSchema->add(NLB_XML_SCHEMA_NAME, _variant_t(NLB_XML_SCHEMA_PATH));
    
    if (hr != S_OK) {
        PWCHAR pDescr = NULL;
        IErrorInfo * pErrorInfo = NULL;
        
        if (GetErrorInfo(0, &pErrorInfo) == S_OK) {
            pErrorInfo->GetDescription(&pDescr);
            ParseError.code = hr;
            lstrcpy(ParseError.wszReason, pDescr);
        }
        
        goto CleanUp;
    }
    
    vSchema.vt = VT_DISPATCH;
    vSchema.pdispVal = pSchema;
    
    hr = pDoc->putref_schemas(vSchema);
    
    if (hr != S_OK) {
        PWCHAR pDescr = NULL;
        IErrorInfo * pErrorInfo = NULL;
        
        if (GetErrorInfo(0, &pErrorInfo) == S_OK) {
            pErrorInfo->GetDescription(&pDescr);
            ParseError.code = hr;
            lstrcpy(ParseError.wszReason, pDescr);
        }
        
        goto CleanUp;
    }
    
    CHECKHR(pDoc->load(vURL, &vBool));
    
    CheckDocumentLoad();
    
    hr = pDoc->validate(&pXMLError);
    
    if (hr != S_OK) {
        CHECKHR(pXMLError->get_errorCode(&ParseError.code));
        
        if (ParseError.code != 0) {
            BSTR pBURL;
            BSTR pBReason;
            
            CHECKHR(pXMLError->get_line(&ParseError.line));
            CHECKHR(pXMLError->get_linepos(&ParseError.character));
            
            CHECKHR(pXMLError->get_URL(&pBURL));
            lstrcpy(ParseError.wszURL, pBURL);
            
            CHECKHR(pXMLError->get_reason(&pBReason));
            lstrcpy(ParseError.wszReason, pBReason);
            
            SAFEFREESTRING(pBURL);
            SAFEFREESTRING(pBReason);
        }
        
        goto CleanUp;
    }

 CleanUp:
    SAFERELEASE(pSchema);
   
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::CheckDocumentLoad () {
    MSXML2::IXMLDOMParseError * pXMLError = NULL;
    HRESULT                     hr = S_OK;

    CHECKHR(pDoc->get_parseError(&pXMLError));

    CHECKHR(pXMLError->get_errorCode(&ParseError.code));

    if (ParseError.code != 0) {
        BSTR pBURL;
        BSTR pBReason;

        CHECKHR(pXMLError->get_line(&ParseError.line));
        CHECKHR(pXMLError->get_linepos(&ParseError.character));

        CHECKHR(pXMLError->get_URL(&pBURL));
        lstrcpy(ParseError.wszURL, pBURL);

        CHECKHR(pXMLError->get_reason(&pBReason));
        lstrcpy(ParseError.wszReason, pBReason);

        SAFEFREESTRING(pBURL);
        SAFEFREESTRING(pBReason);
    }

    if (bShowErrorPopups) {
        WCHAR reason[2048];
        WCHAR details[2048];

        if (ParseError.code != 0) {
            wsprintf(reason, L"Error 0x%08x:\n\n%ls\n", ParseError.code, ParseError.wszReason);

            if (ParseError.line > 0) {
                wsprintf(details, L"Error on line %d, position %d in \"%ls\".\n", ParseError.line, ParseError.character, ParseError.wszURL);

                lstrcat(reason, details);
            }
		
            ::MessageBox(NULL, reason, L"NLB XML Document Error", MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        } else {
            wsprintf(reason, L"XML Document successfully loaded.");

            ::MessageBox(NULL, reason, L"NLB XML Document Information", MB_APPLMODAL | MB_ICONINFORMATION | MB_OK);
        }
    }

 CleanUp:
    SAFERELEASE(pXMLError);

    return ParseError.code;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
BSTR NLB_XMLDocument::AsciiToBSTR (const char * pszName) {
    WCHAR wszString[MAX_PATH];

    ::MultiByteToWideChar(CP_ACP, 0, pszName, -1, wszString, MAX_PATH);
    
    return SysAllocString(wszString);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
CHAR * NLB_XMLDocument::BSTRToAscii (const WCHAR * pwszName) {
    CHAR szString[MAX_PATH];

    ::WideCharToMultiByte(CP_ACP, 0, pwszName, -1, szString, MAX_PATH, NULL, NULL);
    
    return _strdup(szString);
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_ClusterMode::NLB_ClusterModeType NLB_XMLDocument::StringToClusterMode (const PWCHAR pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_UNICAST)) {
        return NLB_ClusterMode::Unicast;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_MULTICAST)) {
        return NLB_ClusterMode::Multicast;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_IGMP)) {
        return NLB_ClusterMode::IGMP;
    }
	
    return NLB_ClusterMode::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
PWCHAR NLB_XMLDocument::ClusterModeToString (const NLB_ClusterMode::NLB_ClusterModeType Type) {

    switch (Type) {
    case NLB_ClusterMode::Unicast:
        return L"Unicast";
    case NLB_ClusterMode::Multicast:
        return L"Multicast";
    case NLB_ClusterMode::IGMP:
        return L"IGMP";
    }
    
    return L"Invalid";
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_HostState::NLB_HostStateType NLB_XMLDocument::StringToHostState (const PWCHAR pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_STARTED)) {
        return NLB_HostState::Started;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_STOPPED)) {
        return NLB_HostState::Stopped;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_SUSPENDED)) {
        return NLB_HostState::Suspended;
    }
	
    return NLB_HostState::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
PWCHAR NLB_XMLDocument::HostStateToString (const NLB_HostState::NLB_HostStateType Type) {

    switch (Type) {
    case NLB_HostState::Started:
        return L"Started";
    case NLB_HostState::Stopped:
        return L"Stopped";
    case NLB_HostState::Suspended:
        return L"Suspended";
    }
    
    return L"Invalid";
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_PortRuleProtocol::NLB_PortRuleProtocolType NLB_XMLDocument::StringToPortRuleProtocol (const PWCHAR pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_TCP)) {
        return NLB_PortRuleProtocol::TCP;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_UDP)) {
        return NLB_PortRuleProtocol::UDP;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_BOTH)) {
        return NLB_PortRuleProtocol::Both;
    }
	
    return NLB_PortRuleProtocol::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
PWCHAR NLB_XMLDocument::PortRuleProtocolToString (const NLB_PortRuleProtocol::NLB_PortRuleProtocolType Type) {

    switch (Type) {
    case NLB_PortRuleProtocol::TCP:
        return L"TCP";
    case NLB_PortRuleProtocol::UDP:
        return L"UDP";
    case NLB_PortRuleProtocol::Both:
        return L"Both";
    }

    return L"Invalid";
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType NLB_XMLDocument::StringToPortRuleFilteringMode (const PWCHAR pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_SINGLE)) {
        return NLB_PortRuleFilteringMode::Single;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_MULTIPLE)) {
        return NLB_PortRuleFilteringMode::Multiple;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_DISABLED)) {
        return NLB_PortRuleFilteringMode::Disabled;
    }
	
    return NLB_PortRuleFilteringMode::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
PWCHAR NLB_XMLDocument::PortRuleFilteringModeToString (const NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType Type) {

    switch (Type) {
    case NLB_PortRuleFilteringMode::Single:
        return L"Single";
    case NLB_PortRuleFilteringMode::Multiple:
        return L"Multiple";
    case NLB_PortRuleFilteringMode::Disabled:
        return L"Disabled";
    }

    return L"Invalid";
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_PortRuleAffinity::NLB_PortRuleAffinityType NLB_XMLDocument::StringToPortRuleAffinity (const PWCHAR pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_NONE)) {
        return NLB_PortRuleAffinity::None;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_SINGLE)) {
        return NLB_PortRuleAffinity::Single;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_CLASSC)) {
        return NLB_PortRuleAffinity::ClassC;
    }
	
    return NLB_PortRuleAffinity::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
PWCHAR NLB_XMLDocument::PortRuleAffinityToString (const NLB_PortRuleAffinity::NLB_PortRuleAffinityType Type) {

    switch (Type) {
    case NLB_PortRuleAffinity::None:
        return L"None";
    case NLB_PortRuleAffinity::Single:
        return L"Single";
    case NLB_PortRuleAffinity::ClassC:
        return L"ClassC";
    }
    
    return L"Invalid";
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
NLB_PortRuleState::NLB_PortRuleStateType NLB_XMLDocument::StringToPortRuleState (const PWCHAR pwszType) {

    if (!lstrcmpi(pwszType, NLB_XML_VALUE_ENABLED)) {
        return NLB_PortRuleState::Enabled;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_DISABLED)) {
        return NLB_PortRuleState::Disabled;
    } else if (!lstrcmpi(pwszType, NLB_XML_VALUE_DRAINING)) {
        return NLB_PortRuleState::Draining;
    }
	
    return NLB_PortRuleState::Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
PWCHAR NLB_XMLDocument::PortRuleStateToString (const NLB_PortRuleState::NLB_PortRuleStateType Type) {

    switch (Type) {
    case NLB_PortRuleState::Enabled:
        return L"Enabled";
    case NLB_PortRuleState::Disabled:
        return L"Disabled";
    case NLB_PortRuleState::Draining:
        return L"Draining";
    }
    
    return L"Invalid";
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::GetIntegerAttribute (MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, PULONG pValue) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    HRESULT                  hr = S_OK;
    VARIANT                  v;
    BSTR                     BAttribute = NULL;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement, (void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(pAttribute)));

    CHECKHR(pElement->getAttribute(BAttribute, &v));

    if (hr == S_FALSE)
        goto CleanUp;

    if (v.vt != VT_BSTR) {
        hr = E_FAIL;
        goto CleanUp;
    }

    *pValue = _wtoi(V_BSTR(&v));

CleanUp:
    SAFERELEASE(pElement);

    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::GetBooleanAttribute (MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, bool * pValue) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    HRESULT                  hr = S_OK;
    VARIANT                  v;
    ULONG                    value;
    BSTR                     BAttribute = NULL;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement, (void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(pAttribute)));

    CHECKHR(pElement->getAttribute(BAttribute, &v));

    if (hr == S_FALSE)
        goto CleanUp;

    if (v.vt != VT_BSTR) {
        hr = E_FAIL;
        goto CleanUp;
    }

    value = _wtoi(V_BSTR(&v));

    if (value) 
        *pValue = true;
    else 
        *pValue = false;

CleanUp:
    SAFERELEASE(pElement);

    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::GetStringAttribute (MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, PWCHAR pValue, ULONG length) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    HRESULT                  hr = S_OK;
    VARIANT                  v;
    BSTR                     BAttribute = NULL;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement, (void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(pAttribute)));

    CHECKHR(pElement->getAttribute(BAttribute, &v));

    if (hr == S_FALSE)
        goto CleanUp;

    if (v.vt != VT_BSTR) {
        hr = E_FAIL;
        goto CleanUp;
    }

    wcsncpy(pValue, V_BSTR(&v), length);

CleanUp:
    SAFERELEASE(pElement);

    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::GetNodeValue (MSXML2::IXMLDOMNode * pNode, PWCHAR pValue, ULONG length) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    VARIANT               v;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    if (!pChild) {
        hr = E_FAIL;
        goto CleanUp;
    }

    CHECKHR(pChild->get_nodeValue(&v));

    if (v.vt != VT_BSTR) {
        hr = E_FAIL;
        goto CleanUp;
    }

    wcsncpy(pValue, V_BSTR(&v), length);

CleanUp:
    SAFERELEASE(pChild);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseFiltering (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_MODE, wszString, MAX_PATH));

    if (hr == S_OK)
        pRule->SetFilteringMode(StringToPortRuleFilteringMode(wszString));
    else if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_AFFINITY, wszString, MAX_PATH));
	
    if (hr == S_OK)
        pRule->SetAffinity(StringToPortRuleAffinity(wszString));

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {

        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_LOAD)) {

            CHECKHR(ParseLoadWeights(pChild, pRule));

        } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_PRIORITY)) {

            CHECKHR(ParsePriorities(pChild, pRule));

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParsePriorities (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    ULONG                 value;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {

        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_NODE)) {

            CHECKHR(GetStringAttribute(pChild, NLB_XML_ATTRIBUTE_NAME, wszString, MAX_PATH));
            
            if (hr == S_FALSE)
                goto CleanUp;
            
            CHECKHR(GetIntegerAttribute(pChild, NLB_XML_ATTRIBUTE_PRIORITY, &value));
            
            if (hr == S_OK)
                pRule->AddSingleHostFilteringPriority(wszString, value);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseLoadWeights (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    ULONG                 value;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {

        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_NODE)) {

            CHECKHR(GetStringAttribute(pChild, NLB_XML_ATTRIBUTE_NAME, wszString, MAX_PATH));
            
            if (hr == S_FALSE)
                goto CleanUp;
            
            CHECKHR(GetIntegerAttribute(pChild, NLB_XML_ATTRIBUTE_WEIGHT, &value));
            
            if (hr == S_OK)
                pRule->AddMultipleHostFilteringLoadWeight(wszString, value);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseBidirectionalAffinity (MSXML2::IXMLDOMNode * pNode, NLB_ClusterBDASupport * pBDA) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    bool                  bValue;
    HRESULT               hr = S_OK;

    CHECKHR(GetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_MASTER, &bValue));

    if (hr == S_OK)
        pBDA->SetMaster(bValue);
    else if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {

        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_TEAMID)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pBDA->SetTeamID(wszString);            

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_HASHING)) {

            CHECKHR(GetBooleanAttribute(pChild, NLB_XML_ATTRIBUTE_REVERSE, &bValue));

            if (hr == S_OK)
                pBDA->SetReverseHashing(bValue);
            else if (hr == S_FALSE)
                goto CleanUp; 
            
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseRemoteControl (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    WCHAR   wszString[MAX_PATH];
    bool    bValue;
    HRESULT hr = S_OK;

    CHECKHR(GetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_ENABLED, &bValue));

    if (hr == S_OK)
        pCluster->SetRemoteControlSupport(bValue);
    else if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_PASSWORD, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pCluster->SetRemoteControlPassword(wszString);

 CleanUp:
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseHostState (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost) {
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    bool                  bValue;
    HRESULT               hr = S_OK;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_DEFAULT, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pHost->SetState(StringToHostState(wszString));

#if 0 /* Not supported yet. */
    CHECKHR(GetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_PERSIST_STARTED, &bValue));

    if (hr == S_OK)
        pHost->SetStatePersistence(NLB_HostState::Started, bValue);
    
    CHECKHR(GetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_PERSIST_STOPPED, &bValue));

    if (hr == S_OK)
        pHost->SetStatePersistence(NLB_HostState::Stopped, bValue);
#endif
    
    CHECKHR(GetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_PERSIST_SUSPENDED, &bValue));

    if (hr == S_OK)
        pHost->SetStatePersistence(NLB_HostState::Suspended, bValue);

 CleanUp:
    SAFERELEASE(pNext);
	
    SAFEFREESTRING(BNodeName);
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseAdapter (MSXML2::IXMLDOMNode * pNode, NLB_Adapter * pAdapter) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {
        
        CHECKHR(pChild->get_nodeName(&BNodeName));
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_GUID)) {
           
            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pAdapter->SetGUID(wszString);

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_NAME)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pAdapter->SetName(wszString);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);
	
    SAFEFREESTRING(BNodeName);
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseIPAddress (MSXML2::IXMLDOMNode * pNode, NLB_IPAddress * pIPAddress) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {
        
        CHECKHR(pChild->get_nodeName(&BNodeName));
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_ADDRESS)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pIPAddress->SetIPAddress(wszString);

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_SUBNETMASK)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));
			
            pIPAddress->SetSubnetMask(wszString);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);
	
    SAFEFREESTRING(BNodeName);
	
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParsePortRule (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    ULONG                 value1;
    ULONG                 value2;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_NAME, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pRule->SetName(wszString);
    else if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_TEXT, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pRule->SetLabel(wszString);

    CHECKHR(GetIntegerAttribute(pNode, NLB_XML_ATTRIBUTE_START, &value1));
    
    if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(GetIntegerAttribute(pNode, NLB_XML_ATTRIBUTE_END, &value2));
    
    if (hr == S_FALSE)
        goto CleanUp;

    pRule->SetPortRange(value1, value2);

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_PROTOCOL, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pRule->SetProtocol(StringToPortRuleProtocol(wszString));

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_STATE, wszString, MAX_PATH));

    if (hr == S_OK)
        pRule->SetState(StringToPortRuleState(wszString));

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {
        
        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_FILTERING)) {

            CHECKHR(ParseFiltering(pChild, pRule));

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_VIRTUAL_IPADDRESS)) {
            NLB_IPAddress IPAddress(NLB_IPAddress::Virtual);
    
            CHECKHR(pChild->get_firstChild(&pNext));

            if (pNext) {
                SAFEFREESTRING(BNodeName);

                CHECKHR(pNext->get_nodeName(&BNodeName));
                
                CHECKALLOC(BNodeName);
                
                if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {

                    CHECKHR(ParseIPAddress(pNext, &IPAddress));
                    
                    pRule->SetVirtualIPAddress(IPAddress);

                }
                
                pNext->Release();
                pNext = NULL;

                SAFEFREESTRING(BNodeName);
            }
            
        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseClusterPortRules (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {

        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_PORTRULE)) {
            NLB_PortRule PortRule;

            CHECKHR(ParsePortRule(pChild, &PortRule));

            pCluster->AddPortRule(PortRule);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseHost (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    ULONG                 value;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_NAME, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pHost->SetName(wszString);
    else if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_TEXT, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pHost->SetLabel(wszString);

    CHECKHR(GetIntegerAttribute(pNode, NLB_XML_ATTRIBUTE_HOSTID, &value));
    
    if (hr == S_OK)
        pHost->SetHostID(value);
    else if (hr == S_FALSE)
        goto CleanUp;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {
        
        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_HOSTNAME)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));
			
            pHost->SetDNSHostname(wszString);

        } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_INITIAL_STATE)) {

            CHECKHR(ParseHostState(pChild, pHost));

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_DEDICATED_IPADDRESS)) {
            NLB_IPAddress IPAddress(NLB_IPAddress::Dedicated);
            NLB_Adapter   Adapter;

            CHECKHR(pChild->get_firstChild(&pNext));

            while (pNext) {
                MSXML2::IXMLDOMNode * pTemp = NULL;

                SAFEFREESTRING(BNodeName);

                CHECKHR(pNext->get_nodeName(&BNodeName));
                
                CHECKALLOC(BNodeName);
                
                if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {

                    CHECKHR(ParseIPAddress(pNext, &IPAddress));
                    
                    pHost->SetDedicatedIPAddress(IPAddress);

                } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_ADAPTER)) {

                    CHECKHR(ParseAdapter(pNext, &Adapter));
                    
                    if (Adapter.GetName(wszString, MAX_PATH))
                        IPAddress.SetAdapterName(wszString);
                    else if (Adapter.GetGUID(wszString, MAX_PATH))
                        IPAddress.SetAdapterGUID(wszString);
                    
                    pHost->SetDedicatedIPAddress(IPAddress);

                }

                CHECKHR(pNext->get_nextSibling(&pTemp));

                pNext->Release();
                pNext = pTemp;
                pTemp = NULL;

                SAFEFREESTRING(BNodeName);
            }

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_CONNECTION_IPADDRESS)) {
            NLB_IPAddress IPAddress(NLB_IPAddress::Connection);

            CHECKHR(pChild->get_firstChild(&pNext));

            if (pNext) {
                SAFEFREESTRING(BNodeName);

                CHECKHR(pNext->get_nodeName(&BNodeName));
                
                CHECKALLOC(BNodeName);
                
                if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {

                    CHECKHR(ParseIPAddress(pNext, &IPAddress));
                    
                    pHost->SetConnectionIPAddress(IPAddress);

                }
                
                pNext->Release();
                pNext = NULL;

                SAFEFREESTRING(BNodeName);
            }

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_ADAPTER)) {
            NLB_Adapter Adapter;

            CHECKHR(ParseAdapter(pChild, &Adapter));

            if (Adapter.GetName(wszString, MAX_PATH))
                pHost->SetAdapterName(wszString);
            else if (Adapter.GetGUID(wszString, MAX_PATH))
                pHost->SetAdapterGUID(wszString);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));
        
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseClusterHosts (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {

        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_HOST)) {
            NLB_Host Host;

            CHECKHR(ParseHost(pChild, &Host));

            pCluster->AddHost(Host);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));

        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseClusterProperties (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {
        
        CHECKHR(pChild->get_nodeName(&BNodeName));
				
        CHECKALLOC(BNodeName);

        if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_PRIMARY_IPADDRESS)) {

            CHECKHR(pChild->get_firstChild(&pNext));

            if (pNext) {
                NLB_IPAddress IPAddress(NLB_IPAddress::Primary);

                SAFEFREESTRING(BNodeName);

                CHECKHR(pNext->get_nodeName(&BNodeName));
                
                CHECKALLOC(BNodeName);
                
                if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {

                    CHECKHR(ParseIPAddress(pNext, &IPAddress));
                    
                    pCluster->SetPrimaryClusterIPAddress(IPAddress);

                }
                
                pNext->Release();
                pNext = NULL;

                SAFEFREESTRING(BNodeName);
            }

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_SECONDARY_IPADDRESS)) {

            CHECKHR(pChild->get_firstChild(&pNext));

            while (pNext) {
                MSXML2::IXMLDOMNode * pTemp = NULL;
                NLB_IPAddress         IPAddress(NLB_IPAddress::Secondary);

                SAFEFREESTRING(BNodeName);

                CHECKHR(pNext->get_nodeName(&BNodeName));
                
                CHECKALLOC(BNodeName);
                
                if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {

                    CHECKHR(ParseIPAddress(pNext, &IPAddress));
                    
                    pCluster->AddSecondaryClusterIPAddress(IPAddress);

                }
                
                CHECKHR(pNext->get_nextSibling(&pTemp));

                pNext->Release();
                pNext = pTemp;
                pTemp = NULL;

                SAFEFREESTRING(BNodeName);
            }

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_IGMPMCAST_IPADDRESS)) {

            CHECKHR(pChild->get_firstChild(&pNext));

            if (pNext) {
                NLB_IPAddress IPAddress(NLB_IPAddress::IGMP);

                SAFEFREESTRING(BNodeName);

                CHECKHR(pNext->get_nodeName(&BNodeName));
                
                CHECKALLOC(BNodeName);
                
                if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_IPADDRESS)) {

                    CHECKHR(ParseIPAddress(pNext, &IPAddress));
                    
                    pCluster->SetIGMPMulticastIPAddress(IPAddress);

                }
                
                pNext->Release();
                pNext = NULL;

                SAFEFREESTRING(BNodeName);
            }

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_DOMAINNAME)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pCluster->SetDomainName(wszString);

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_NETWORKADDRESS)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pCluster->SetMACAddress(wszString);

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_CLUSTER_MODE)) {

            CHECKHR(GetNodeValue(pChild, wszString, MAX_PATH));

            pCluster->SetClusterMode(StringToClusterMode(wszString));

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_REMOTE_CONTROL)) {

            CHECKHR(ParseRemoteControl(pChild, pCluster));

        } else if (!lstrcmp(BNodeName, NLB_XML_ELEMENT_BDA)) {
            NLB_ClusterBDASupport BDA;

            CHECKHR(ParseBidirectionalAffinity(pChild, &BDA));

            pCluster->SetBidirectionalAffinitySupport(BDA);

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));
        
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::ParseCluster (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BNodeName = NULL;
    HRESULT               hr = S_OK;

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_NAME, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pCluster->SetName(wszString);
    else if (hr == S_FALSE) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_ERROR_CLUSTER_NAME_MISSING);
        SetParseError(hr, NLB_DESCR_CLUSTER_NAME_MISSING);
        goto CleanUp;
    }

    CHECKHR(GetStringAttribute(pNode, NLB_XML_ATTRIBUTE_TEXT, wszString, MAX_PATH));
    
    if (hr == S_OK)
        pCluster->SetLabel(wszString);

    CHECKHR(pNode->get_firstChild(&pChild));

    while (pChild) {
        
        CHECKHR(pChild->get_nodeName(&BNodeName));
		
        CHECKALLOC(BNodeName);

        if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_PROPERTIES)) {

            CHECKHR(ParseClusterProperties(pChild, pCluster));

        } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_HOSTS)) {

            CHECKHR(ParseClusterHosts(pChild, pCluster));

        } else if (!lstrcmpi(BNodeName, NLB_XML_ELEMENT_PORTRULES)) {

            CHECKHR(ParseClusterPortRules(pChild, pCluster));

        } else {
            hr = E_FAIL;
            goto CleanUp;
        }

        CHECKHR(pChild->get_nextSibling(&pNext));
        
        pChild->Release();
        pChild = pNext;
        pNext = NULL;

        SAFEFREESTRING(BNodeName);		
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    SAFEFREESTRING(BNodeName);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::Parse (const WCHAR * wszFileName, vector<NLB_Cluster> & Clusters) {
    MSXML2::IXMLDOMNodeList * pList = NULL;
    MSXML2::IXMLDOMNode *     pNode = NULL;
    BSTR                      BURL = NULL;
    BSTR                      BTag = NULL;
    LONG                      length;    
    LONG                      index;
    HRESULT                   hr = S_OK;

    CHECKHR(CoCreateInstance(MSXML2::CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, MSXML2::IID_IXMLDOMDocument2, (void**)&pDoc));

    CHECKALLOC(pDoc);

    CHECKALLOC((BURL = SysAllocString(wszFileName)));

    CHECKALLOC((BTag = SysAllocString(NLB_XML_ELEMENT_CLUSTER)));

    CHECKHR(LoadDocument(BURL));

    if (ParseError.code != 0) {
        hr = ParseError.code;
        goto CleanUp;
    }

    CHECKHR(pDoc->getElementsByTagName(BTag, &pList));

    CHECKALLOC(pList);

    CHECKHR(pList->get_length(&length));

    CHECKHR(pList->reset());

    for (index = 0; index < length; index++) {
        NLB_Cluster cluster;

        CHECKHR(pList->get_item(index, &pNode));
	
        CHECKALLOC(pNode);

        CHECKHR(ParseCluster(pNode, &cluster));

        Clusters.push_back(cluster);

        SAFERELEASE(pNode);
    }

 CleanUp:
    SAFERELEASE(pList);
    SAFERELEASE(pNode);
    SAFERELEASE(pDoc);

    SAFEFREESTRING(BURL);
    SAFEFREESTRING(BTag);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::Validate (const WCHAR * wszFileName) {
    MSXML2::IXMLDOMNode * pNode = NULL;
    WCHAR                 wszString[MAX_PATH];
    BSTR                  BURL = NULL;
    HRESULT               hr = S_OK;
        
    CHECKHR(CoCreateInstance(MSXML2::CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, MSXML2::IID_IXMLDOMDocument2, (void**)&pDoc));

    CHECKALLOC(pDoc);

    CHECKALLOC((BURL = SysAllocString(wszFileName)));

    CHECKHR(LoadDocument(BURL));

    if (ParseError.code != 0) {
        hr = ParseError.code;
        goto CleanUp;
    }

 CleanUp:
    SAFERELEASE(pDoc);
    SAFERELEASE(pNode);

    SAFEFREESTRING(BURL);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
void NLB_XMLDocument::Print (vector<NLB_Cluster> Clusters) {
    vector<NLB_Cluster>::iterator        icluster;
    NLB_IPAddress                        address;
    WCHAR                                wszString[MAX_PATH];
    ULONG                                value1;
    ULONG                                value2;
    bool                                 bBool;

    for (icluster = Clusters.begin(); icluster != Clusters.end(); icluster++) {
        NLB_ClusterMode::NLB_ClusterModeType mode;
        NLB_ClusterBDASupport                bda;
        vector<NLB_IPAddress>::iterator      iaddress;
        vector<NLB_IPAddress>                addressList;
        vector<NLB_Host>::iterator           ihost;
        vector<NLB_Host>                     hosts;
        vector<NLB_PortRule>::iterator       irule;
        vector<NLB_PortRule>                 rules;
        NLB_Cluster *                        pCluster = icluster;
        
        if (pCluster->GetName(wszString, MAX_PATH))
            printf("\nCluster name: %ls ", wszString);
        
        if (pCluster->GetLabel(wszString, MAX_PATH))
            printf("(%ls)", wszString);
        
        printf("\n");

        if (pCluster->GetPrimaryClusterIPAddress(address)) {
            if (address.GetIPAddress(wszString, MAX_PATH))
                printf("  Primary Cluster IP Address:       %ls\n", wszString);

            if (address.GetSubnetMask(wszString, MAX_PATH))
                printf("    Subnet Mask:                    %ls\n", wszString);
        }

        if (pCluster->GetClusterMode(mode)) {
            switch (mode) {
            case NLB_ClusterMode::Unicast:
                printf("  Cluster Mode:                     Unicast\n");
                break;
            case NLB_ClusterMode::Multicast:
                printf("  Cluster Mode:                     Multicast\n");
                break;
            case NLB_ClusterMode::IGMP:
                printf("  Cluster Mode:                     IGMP\n");
                break;
            default:
                break;
            }
        }
        
        if (pCluster->GetIGMPMulticastIPAddress(address)) {
            if (address.GetIPAddress(wszString, MAX_PATH))
                printf("  IGMP Multicast IP Address:        %ls\n", wszString);
        }

        if (pCluster->GetDomainName(wszString, MAX_PATH))
            printf("  Domain Name:                      %ls\n", wszString);
        
        if (pCluster->GetMACAddress(wszString, MAX_PATH))
            printf("  Network Address:                  %ls\n", wszString);

        if (pCluster->GetRemoteControlSupport(bBool)) {
            switch (bBool) {
            case true: 
                printf("  Remote Control:                   Enabled ");
                
                if (pCluster->GetRemoteControlPassword(wszString, MAX_PATH))
                    printf("(Password=%ls)", wszString);

                break;
            case false:
                printf("  Remote Control:                   Disabled");
                break;
            }

            printf("\n");
        }

        if (pCluster->GetSecondaryClusterIPAddressList(&addressList)) {
            printf("  Secondary Cluster IP Addresses\n");

            for (iaddress = addressList.begin(); iaddress != addressList.end(); iaddress++) {
                NLB_IPAddress * paddress = iaddress;
                
                if (paddress->GetIPAddress(wszString, MAX_PATH))
                    printf("    IP Address:                     %ls\n", wszString);
                
                if (paddress->GetSubnetMask(wszString, MAX_PATH))
                    printf("    Subnet Mask:                    %ls\n", wszString);
            }
        }

        if (pCluster->GetBidirectionalAffinitySupport(bda)) {
            printf("  Bidirectional Affinity\n");

            if (bda.GetTeamID(wszString, MAX_PATH))
                printf("    TeamID:                         %ls\n", wszString);

            if (bda.GetMaster(bBool))
                printf("    Master:                         %ls\n", (bBool) ? L"Yes" : L"No");

            if (bda.GetReverseHashing(bBool))
                printf("    Reverse hashing:                %ls\n", (bBool) ? L"Yes" : L"No");
        }

        pCluster->GetHostList(&hosts);

        for (ihost = hosts.begin(); ihost != hosts.end(); ihost++) {
            NLB_HostState::NLB_HostStateType state;
            NLB_Host *                       pHost = ihost;

            if (pHost->GetName(wszString, MAX_PATH))
                printf("\n  Host name: %ls ", wszString);
            
            if (pHost->GetLabel(wszString, MAX_PATH))
                printf("(%ls)", wszString);
            
            printf("\n");

            if (pHost->GetAdapterName(wszString, MAX_PATH))
                printf("    Adapter Name:                   %ls\n", wszString);
            else if (pHost->GetAdapterGUID(wszString, MAX_PATH))
                printf("    Adapter GUID:                   %ls\n", wszString);

            if (pHost->GetHostID(value1))
                printf("    Host ID:                        %d\n", value1);

            if (pHost->GetState(state)) {
                switch (state) {
                case NLB_HostState::Started:
                    printf("    State:                          Started\n");
                    break;
                case NLB_HostState::Stopped:
                    printf("    State:                          Stopped\n");
                    break;
                case NLB_HostState::Suspended:
                    printf("    State:                          Suspended\n");
                    break;
                default:
                    break;
                }
                
                printf("    Persisted States:               ");
                
                if (pHost->GetStatePersistence(NLB_HostState::Suspended, bBool) && bBool)
                    printf("Suspended\n");
                else 
                    printf("None\n");
                
            }

            if (pHost->GetDNSHostname(wszString, MAX_PATH))
                printf("    Hostname:                       %ls\n", wszString);
            
            if (pHost->GetDedicatedIPAddress(address)) {
                if (address.GetIPAddress(wszString, MAX_PATH))
                    printf("    Dedicated Cluster IP Address:   %ls\n", wszString);
                
                if (address.GetSubnetMask(wszString, MAX_PATH))
                    printf("      Subnet Mask:                  %ls\n", wszString);

                if (address.GetAdapterName(wszString, MAX_PATH))
                    printf("      Adapter Name:                 %ls\n", wszString);
                else if (address.GetAdapterGUID(wszString, MAX_PATH))
                    printf("      Adapter GUID:                 %ls\n", wszString);
            }

            if (pHost->GetConnectionIPAddress(address)) {
                if (address.GetIPAddress(wszString, MAX_PATH))
                    printf("    Connection Cluster IP Address:  %ls\n", wszString);
                
                if (address.GetSubnetMask(wszString, MAX_PATH))
                    printf("      Subnet Mask:                  %ls\n", wszString);
            }
        }

        pCluster->GetPortRuleList(&rules);

        for (irule = rules.begin(); irule != rules.end(); irule++) {
            NLB_PortRuleState::NLB_PortRuleStateType                 state;
            NLB_PortRuleProtocol::NLB_PortRuleProtocolType           protocol;
            NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType mode;
            NLB_PortRuleAffinity::NLB_PortRuleAffinityType           affinity;
            NLB_PortRule *                                           pRule = irule;

            if (pRule->GetName(wszString, MAX_PATH))
                printf("\n  Port rule name: %ls ", wszString);
            
            if (pRule->GetLabel(wszString, MAX_PATH))
                printf("(%ls)", wszString);
            
            printf("\n");
            
            if (pRule->GetState(state)) {
                switch (state) {
                case NLB_PortRuleState::Enabled:
                    printf("    State:                          Enabled\n");
                    break;
                case NLB_PortRuleState::Disabled:
                    printf("    State:                          Disabled\n");
                    break;
                case NLB_PortRuleState::Draining:
                    printf("    State:                          Draining\n");
                    break;
                default:
                    break;
                }
            }

            if (pRule->GetVirtualIPAddress(address)) {
                if (address.GetIPAddress(wszString, MAX_PATH))
                    printf("    Virtual IP Address:             %ls\n", wszString);
            }

            if (pRule->GetPortRange(value1, value2)) {
                printf("    Start:                          %d\n", value1);
                printf("    End:                            %d\n", value2);
            }

            if (pRule->GetProtocol(protocol)) {
                switch (protocol) {
                case NLB_PortRuleProtocol::TCP:
                    printf("    Protocol:                       TCP\n");
                    break;
                case NLB_PortRuleProtocol::UDP:
                    printf("    Protocol:                       UDP\n");
                    break;
                case NLB_PortRuleProtocol::Both:
                    printf("    Protocol:                       Both\n");
                    break;
                default:
                    break;
                }
            }

            if (pRule->GetFilteringMode(mode)) {
                switch (mode) {
                case NLB_PortRuleFilteringMode::Single:
                    printf("    Filtering Mode:                 Single\n");

                    for (ihost = hosts.begin(); ihost != hosts.end(); ihost++) {
                        NLB_Host * pHost = ihost;
                        
                        if (pHost->GetName(wszString, MAX_PATH)) {
                            if (pRule->GetSingleHostFilteringPriority(wszString, value1))
                                printf("      Priority:                     %-2u (%ls)\n", value1, wszString);  
                        }                        
                    }

                    break;
                case NLB_PortRuleFilteringMode::Multiple:
                    printf("    Filtering Mode:                 Multiple\n");

                    if (pRule->GetAffinity(affinity)) {
                        switch (affinity) {
                        case NLB_PortRuleAffinity::None:
                            printf("      Affinity:                     None\n");
                            break;
                        case NLB_PortRuleAffinity::Single:
                            printf("      Affinity:                     Single\n");
                            break;
                        case NLB_PortRuleAffinity::ClassC:
                            printf("      Affinity:                     Class C\n");
                            break;
                        default:
                            break;
                        }
                    }

                    for (ihost = hosts.begin(); ihost != hosts.end(); ihost++) {
                        NLB_Host * pHost = ihost;
                        
                        if (pHost->GetName(wszString, MAX_PATH)) {
                            if (pRule->GetMultipleHostFilteringLoadWeight(wszString, value1))
                                printf("      Load Weight:                  %-3u (%ls)\n", value1, wszString);
                        }                        
                    }

                    break;
                case NLB_PortRuleFilteringMode::Disabled:
                    printf("    Filtering Mode:                 Disabled\n");
                    break;
                default:
                    break;
                }
            }
        }
    }
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SetIntegerAttribute (MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, ULONG value) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    VARIANT                  v;
    HRESULT                  hr = S_OK;
    BSTR                     BAttribute = NULL;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement, (void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(pAttribute)));

    v.vt = VT_I4;
    V_I4(&v) = value;

    CHECKHR(pElement->setAttribute(BAttribute, v));

CleanUp:
    SAFERELEASE(pElement);

    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SetBooleanAttribute (MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, bool value) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    VARIANT                  v;
    HRESULT                  hr = S_OK;
    BSTR                     BAttribute = NULL;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement, (void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(pAttribute)));

    v.vt = VT_BOOL;
    V_BOOL(&v) = value;

    CHECKHR(pElement->setAttribute(BAttribute, v));

CleanUp:
    SAFERELEASE(pElement);

    SAFEFREESTRING(BAttribute);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SetStringAttribute (MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, PWCHAR pValue) {
    MSXML2::IXMLDOMElement * pElement = NULL;
    VARIANT                  v;
    HRESULT                  hr = S_OK;
    BSTR                     BAttribute = NULL;
    BSTR                     BValue = NULL;

    CHECKHR(pNode->QueryInterface(MSXML2::IID_IXMLDOMElement, (void**)&pElement));

    CHECKALLOC((BAttribute = SysAllocString(pAttribute)));

    CHECKALLOC((BValue = SysAllocString(pValue)));

    v.vt = VT_BSTR;
    V_BSTR(&v) = BValue;

    CHECKHR(pElement->setAttribute(BAttribute, v));

CleanUp:
    SAFERELEASE(pElement);

    SAFEFREESTRING(BAttribute);
    SAFEFREESTRING(BValue);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SetNodeValue (MSXML2::IXMLDOMNode * pNode, PWCHAR pValue) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNewChild = NULL;
    BSTR                  BValue = NULL;
    VARIANT               RefNode;
    VARIANT               v;
    HRESULT               hr = S_OK;

    CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_TEXT, NULL)));
        
    CHECKALLOC((BValue = SysAllocString(pValue)));

    v.vt = VT_BSTR;
    V_BSTR(&v) = BValue;

    CHECKHR(pChild->put_nodeValue(v));

    RefNode.vt = VT_EMPTY;
    
    CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);

    SAFEFREESTRING(BValue);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
MSXML2::IXMLDOMNode * NLB_XMLDocument::CreateNode (MSXML2::IXMLDOMDocument * pDoc, int type, PWCHAR pName) {
    MSXML2::IXMLDOMNode * pNode;
    BSTR                  BName = NULL;
    VARIANT               vtype;
    HRESULT               hr = S_OK;

    if (pName)
        CHECKALLOC((BName = SysAllocString(pName)));

    vtype.vt = VT_I4;
    V_I4(&vtype) = (int)type;

    CHECKHR(pDoc->createNode(vtype, BName, NULL, &pNode));

    SAFEFREESTRING(BName);

    return pNode;

 CleanUp:
    SAFEFREESTRING(BName);

    return NULL;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
MSXML2::IXMLDOMNode * NLB_XMLDocument::CreateNode (MSXML2::IXMLDOMDocument * pDoc, int type, PWCHAR pName, PWCHAR pValue) {
    MSXML2::IXMLDOMNode * pNode;
    HRESULT               hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, type, pName)));

    CHECKHR(SetNodeValue(pNode, pValue));

    return pNode;

 CleanUp:

    return NULL;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveRemoteControl (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pNode = NULL;
    MSXML2::IXMLDOMNode * pNewNode = NULL;
    WCHAR                 wszString[MAX_PATH];
    bool                  bBool;
    VARIANT               RefNode;
    HRESULT               hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_REMOTE_CONTROL)));

    if (pCluster->GetRemoteControlSupport(bBool))
        CHECKHR(SetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_ENABLED, bBool));

    if (pCluster->GetRemoteControlPassword(wszString, MAX_PATH)) 
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_PASSWORD, wszString));

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    
 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveHostState (MSXML2::IXMLDOMNode * pRoot, NLB_Host * pHost) {
    NLB_HostState::NLB_HostStateType State;
    MSXML2::IXMLDOMNode *            pNode = NULL;
    MSXML2::IXMLDOMNode *            pNewNode = NULL;
    bool                             bBool;
    VARIANT                          RefNode;
    HRESULT                          hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_INITIAL_STATE)));

    if (pHost->GetState(State))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_DEFAULT, HostStateToString(State)));

#if 0 /* Not supported yet. */
    if (pHost->GetStatePersistence(NLB_HostState::Started, bBool))
        CHECKHR(SetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_PERSIST_STARTED, bBool));
    
    if (pHost->GetStatePersistence(NLB_HostState::Stopped, bBool))
        CHECKHR(SetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_PERSIST_STOPPED, bBool));
#endif        
    
    if (pHost->GetStatePersistence(NLB_HostState::Suspended, bBool))
        CHECKHR(SetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_PERSIST_SUSPENDED, bBool));
    
    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    
 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveBidirectionalAffinity (MSXML2::IXMLDOMNode * pRoot, NLB_ClusterBDASupport * pBDA) {
    MSXML2::IXMLDOMNode * pNode = NULL;
    MSXML2::IXMLDOMNode * pNewNode = NULL;
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNewChild = NULL;
    WCHAR                 wszString[MAX_PATH];
    bool                  bBool;
    VARIANT               RefNode;
    HRESULT               hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_BDA)));

    if (pBDA->GetMaster(bBool))
        CHECKHR(SetBooleanAttribute(pNode, NLB_XML_ATTRIBUTE_MASTER, bBool));

    if (pBDA->GetTeamID(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_TEAMID, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pBDA->GetReverseHashing(bBool)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_HASHING)));

        CHECKHR(SetBooleanAttribute(pChild, NLB_XML_ATTRIBUTE_REVERSE, bBool));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    
 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveAdapter (MSXML2::IXMLDOMNode * pRoot, NLB_Adapter * pAdapter) {
    MSXML2::IXMLDOMNode * pNode = NULL;
    MSXML2::IXMLDOMNode * pNewNode = NULL;
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNewChild = NULL;
    WCHAR                 wszString[MAX_PATH];
    VARIANT               RefNode;
    HRESULT               hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_ADAPTER)));

    if (pAdapter->GetName(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_NAME, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    } else if (pAdapter->GetGUID(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_GUID, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    
 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveIPAddress (MSXML2::IXMLDOMNode * pRoot, NLB_IPAddress * pAddress) {
    NLB_IPAddress::NLB_IPAddressType Type;
    MSXML2::IXMLDOMNode *            pNode = NULL;
    MSXML2::IXMLDOMNode *            pNewNode = NULL;
    MSXML2::IXMLDOMNode *            pChild = NULL;
    MSXML2::IXMLDOMNode *            pNewChild = NULL;
    WCHAR                            wszString[MAX_PATH];
    VARIANT                          RefNode;
    HRESULT                          hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_IPADDRESS)));

    if (pAddress->GetIPAddress(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_ADDRESS, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pAddress->GetSubnetMask(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_SUBNETMASK, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    
 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveLoadWeights (MSXML2::IXMLDOMNode * pRoot, NLB_PortRule * pRule) {
    vector<NLB_PortRuleLoadWeight>::iterator iLoadWeight;
    vector<NLB_PortRuleLoadWeight>           LoadWeightList;
    MSXML2::IXMLDOMNode *                    pNode = NULL;
    MSXML2::IXMLDOMNode *                    pNewNode = NULL;
    MSXML2::IXMLDOMNode *                    pChild = NULL;
    MSXML2::IXMLDOMNode *                    pNewChild = NULL;
    WCHAR                                    wszString[MAX_PATH];
    ULONG                                    value;
    VARIANT                                  RefNode;
    HRESULT                                  hr = S_OK;

    if (pRule->GetMultipleHostFilteringLoadWeightList(&LoadWeightList)) {
        CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_LOAD)));

        for (iLoadWeight = LoadWeightList.begin(); iLoadWeight != LoadWeightList.end(); iLoadWeight++) {
            NLB_PortRuleLoadWeight * pLoadWeight = iLoadWeight;
            
            if (!pLoadWeight->IsValid())
                continue;

            if (!pLoadWeight->GetHost(wszString, MAX_PATH))
                continue;

            if (!pLoadWeight->GetWeight(value))
                continue;

            CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_NODE)));
            
            CHECKHR(SetStringAttribute(pChild, NLB_XML_ATTRIBUTE_NAME, wszString));

            CHECKHR(SetIntegerAttribute(pChild, NLB_XML_ATTRIBUTE_WEIGHT, value));

            RefNode.vt = VT_EMPTY;
            
            CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));
            
            SAFERELEASE(pChild);
            SAFERELEASE(pNewChild);
        }

        RefNode.vt = VT_EMPTY;
        
        CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    }

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);    

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SavePriorities (MSXML2::IXMLDOMNode * pRoot, NLB_PortRule * pRule) {
    vector<NLB_PortRulePriority>::iterator iPriority;
    vector<NLB_PortRulePriority>           PriorityList;
    MSXML2::IXMLDOMNode *                  pNode = NULL;
    MSXML2::IXMLDOMNode *                  pNewNode = NULL;
    MSXML2::IXMLDOMNode *                  pChild = NULL;
    MSXML2::IXMLDOMNode *                  pNewChild = NULL;
    WCHAR                                  wszString[MAX_PATH];
    ULONG                                  value;
    VARIANT                                RefNode;
    HRESULT                                hr = S_OK;

    if (pRule->GetSingleHostFilteringPriorityList(&PriorityList)) {
        CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_PRIORITY)));

        for (iPriority = PriorityList.begin(); iPriority != PriorityList.end(); iPriority++) {
            NLB_PortRulePriority * pPriority = iPriority;
            
            if (!pPriority->IsValid())
                continue;

            if (!pPriority->GetHost(wszString, MAX_PATH))
                continue;

            if (!pPriority->GetPriority(value))
                continue;

            CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_NODE)));
            
            CHECKHR(SetStringAttribute(pChild, NLB_XML_ATTRIBUTE_NAME, wszString));

            CHECKHR(SetIntegerAttribute(pChild, NLB_XML_ATTRIBUTE_PRIORITY, value));

            RefNode.vt = VT_EMPTY;
            
            CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));
            
            SAFERELEASE(pChild);
            SAFERELEASE(pNewChild);
        }
        
        RefNode.vt = VT_EMPTY;

        CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    }

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);    

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveFiltering (MSXML2::IXMLDOMNode * pRoot, NLB_PortRule * pRule) {
    NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType Mode;
    NLB_PortRuleAffinity::NLB_PortRuleAffinityType           Affinity;
    MSXML2::IXMLDOMNode *                                    pNode = NULL;
    MSXML2::IXMLDOMNode *                                    pNewNode = NULL;
    VARIANT                                                  RefNode;
    HRESULT                                                  hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_FILTERING)));

    if (pRule->GetFilteringMode(Mode))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_MODE, PortRuleFilteringModeToString(Mode)));

    switch (Mode) {
    case NLB_PortRuleFilteringMode::Single:

        CHECKHR(SavePriorities(pNode, pRule));

        break;
    case NLB_PortRuleFilteringMode::Multiple:

        if (pRule->GetAffinity(Affinity))
            CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_AFFINITY, PortRuleAffinityToString(Affinity)));

        CHECKHR(SaveLoadWeights(pNode, pRule));

        break;
    case NLB_PortRuleFilteringMode::Disabled:
        break;
    }

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SavePortRule (MSXML2::IXMLDOMNode * pRoot, NLB_PortRule * pRule) {
    NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType Mode;
    NLB_PortRuleProtocol::NLB_PortRuleProtocolType           Protocol;
    NLB_PortRuleState::NLB_PortRuleStateType                 State;
    MSXML2::IXMLDOMNode *                                    pNode = NULL;
    MSXML2::IXMLDOMNode *                                    pNewNode = NULL;
    MSXML2::IXMLDOMNode *                                    pChild = NULL;
    MSXML2::IXMLDOMNode *                                    pNewChild = NULL;
    WCHAR                                                    wszString[MAX_PATH];
    ULONG                                                    value1;
    ULONG                                                    value2;
    VARIANT                                                  RefNode;
    NLB_IPAddress                                            Address;
    HRESULT                                                  hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_PORTRULE)));

    if (pRule->GetName(wszString, MAX_PATH))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_NAME, wszString));

    if (pRule->GetLabel(wszString, MAX_PATH))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_TEXT, wszString));

    if (pRule->GetPortRange(value1, value2)) {
        CHECKHR(SetIntegerAttribute(pNode, NLB_XML_ATTRIBUTE_START, value1));
        CHECKHR(SetIntegerAttribute(pNode, NLB_XML_ATTRIBUTE_END, value2));
    }

    if (pRule->GetProtocol(Protocol))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_PROTOCOL, PortRuleProtocolToString(Protocol)));

    if (pRule->GetState(State))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_STATE, PortRuleStateToString(State)));

    if (pRule->GetVirtualIPAddress(Address)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_VIRTUAL_IPADDRESS)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        CHECKHR(SaveIPAddress(pChild, &Address));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pRule->GetFilteringMode(Mode))
        CHECKHR(SaveFiltering(pNode, pRule));

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveHost (MSXML2::IXMLDOMNode * pRoot, NLB_Host * pHost) {
    NLB_HostState::NLB_HostStateType State;
    MSXML2::IXMLDOMNode *            pNode = NULL;
    MSXML2::IXMLDOMNode *            pNewNode = NULL;
    MSXML2::IXMLDOMNode *            pChild = NULL;
    MSXML2::IXMLDOMNode *            pNewChild = NULL;
    WCHAR                            wszString[MAX_PATH];
    bool                             bBool;
    ULONG                            value;
    VARIANT                          RefNode;
    NLB_IPAddress                    Address;
    HRESULT                          hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_HOST)));

    if (pHost->GetName(wszString, MAX_PATH))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_NAME, wszString));

    if (pHost->GetHostID(value))
        CHECKHR(SetIntegerAttribute(pNode, NLB_XML_ATTRIBUTE_HOSTID, value));

    if (pHost->GetLabel(wszString, MAX_PATH))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_TEXT, wszString));

    if (pHost->GetDNSHostname(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_HOSTNAME, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pHost->GetAdapterName(wszString, MAX_PATH)) {
        NLB_Adapter Adapter;
        
        Adapter.SetName(wszString);
        
        CHECKHR(SaveAdapter(pNode, &Adapter));
    } else if (pHost->GetAdapterGUID(wszString, MAX_PATH)) {
        NLB_Adapter Adapter;
        
        Adapter.SetGUID(wszString);
        
        CHECKHR(SaveAdapter(pNode, &Adapter));
    }

    if (pHost->GetState(State))
        CHECKHR(SaveHostState(pNode, pHost));

    if (pHost->GetDedicatedIPAddress(Address)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_DEDICATED_IPADDRESS)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        CHECKHR(SaveIPAddress(pChild, &Address));

        if (Address.GetAdapterName(wszString, MAX_PATH)) {
            NLB_Adapter Adapter;
            
            Adapter.SetName(wszString);
            
            CHECKHR(SaveAdapter(pChild, &Adapter));
        } else if (Address.GetAdapterGUID(wszString, MAX_PATH)) {
            NLB_Adapter Adapter;
            
            Adapter.SetGUID(wszString);
            
            CHECKHR(SaveAdapter(pChild, &Adapter));
        }

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }
    
    if (pHost->GetConnectionIPAddress(Address)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_CONNECTION_IPADDRESS)));
        
        RefNode.vt = VT_EMPTY;
        
        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        CHECKHR(SaveIPAddress(pChild, &Address));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);    

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveClusterPortRules (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster) {
    vector<NLB_PortRule>::iterator iRule;
    vector<NLB_PortRule>           RuleList;
    MSXML2::IXMLDOMNode *          pNode = NULL;
    MSXML2::IXMLDOMNode *          pNewNode = NULL;
    VARIANT                        RefNode;
    HRESULT                        hr = S_OK;

    if (pCluster->GetPortRuleList(&RuleList)) {
        CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_PORTRULES)));

        for (iRule = RuleList.begin(); iRule != RuleList.end(); iRule++) {
            NLB_PortRule * pRule = iRule;
            
            if (pRule->IsValid())
                CHECKHR(SavePortRule(pNode, pRule));
        }

        RefNode.vt = VT_EMPTY;

        CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    }

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveClusterHosts (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster) {
    vector<NLB_Host>::iterator iHost;
    vector<NLB_Host>           HostList;
    MSXML2::IXMLDOMNode *      pNode = NULL;
    MSXML2::IXMLDOMNode *      pNewNode = NULL;
    VARIANT                    RefNode;
    HRESULT                    hr = S_OK;

    if (pCluster->GetHostList(&HostList)) {
        CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_HOSTS)));

        for (iHost = HostList.begin(); iHost != HostList.end(); iHost++) {
            NLB_Host * pHost = iHost;
            
            if (pHost->IsValid())
                CHECKHR(SaveHost(pNode, pHost));
        }

        RefNode.vt = VT_EMPTY;
        
        CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    }

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveClusterProperties (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster) {
    NLB_ClusterMode::NLB_ClusterModeType Mode;
    vector<NLB_IPAddress>::iterator      iAddress;
    vector<NLB_IPAddress>                AddressList;
    MSXML2::IXMLDOMNode *                pNode = NULL;
    MSXML2::IXMLDOMNode *                pNewNode = NULL;
    MSXML2::IXMLDOMNode *                pChild = NULL;
    MSXML2::IXMLDOMNode *                pNewChild = NULL;
    WCHAR                                wszString[MAX_PATH];
    bool                                 bBool;
    VARIANT                              RefNode;
    NLB_IPAddress                        Address;
    NLB_ClusterBDASupport                BDA;
    HRESULT                              hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_PROPERTIES)));

    if (pCluster->GetPrimaryClusterIPAddress(Address)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_PRIMARY_IPADDRESS)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        CHECKHR(SaveIPAddress(pChild, &Address));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pCluster->GetSecondaryClusterIPAddressList(&AddressList)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_SECONDARY_IPADDRESS)));

        for (iAddress = AddressList.begin(); iAddress != AddressList.end(); iAddress++) {
            NLB_IPAddress * pAddress = iAddress;
            
            if (pAddress->IsValid())
                CHECKHR(SaveIPAddress(pChild, pAddress));
        }

        RefNode.vt = VT_EMPTY;
        
        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pCluster->GetIGMPMulticastIPAddress(Address)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_IGMPMCAST_IPADDRESS)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        CHECKHR(SaveIPAddress(pChild, &Address));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pCluster->GetDomainName(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_DOMAINNAME, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pCluster->GetClusterMode(Mode)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_CLUSTER_MODE, ClusterModeToString(Mode))));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pCluster->GetMACAddress(wszString, MAX_PATH)) {
        CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_NETWORKADDRESS, wszString)));

        RefNode.vt = VT_EMPTY;

        CHECKHR(pNode->insertBefore(pChild, RefNode, &pNewChild));

        SAFERELEASE(pChild);
        SAFERELEASE(pNewChild);
    }

    if (pCluster->GetRemoteControlSupport(bBool))
        CHECKHR(SaveRemoteControl(pNode, pCluster));

    if (pCluster->GetBidirectionalAffinitySupport(BDA))
        CHECKHR(SaveBidirectionalAffinity(pNode, &BDA));

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));

 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);    

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::SaveCluster (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster) {
    MSXML2::IXMLDOMNode * pNode = NULL;
    MSXML2::IXMLDOMNode * pNewNode = NULL;
    WCHAR                 wszString[MAX_PATH];
    VARIANT               RefNode;
    HRESULT               hr = S_OK;

    CHECKALLOC((pNode = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_CLUSTER)));

    if (pCluster->GetName(wszString, MAX_PATH))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_NAME, wszString));

    if (pCluster->GetLabel(wszString, MAX_PATH))
        CHECKHR(SetStringAttribute(pNode, NLB_XML_ATTRIBUTE_TEXT, wszString));

    CHECKHR(SaveClusterProperties(pNode, pCluster));

    CHECKHR(SaveClusterHosts(pNode, pCluster));

    CHECKHR(SaveClusterPortRules(pNode, pCluster));

    RefNode.vt = VT_EMPTY;

    CHECKHR(pRoot->insertBefore(pNode, RefNode, &pNewNode));
    
 CleanUp:
    SAFERELEASE(pNode);
    SAFERELEASE(pNewNode);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::Save (const WCHAR * wszFileName, vector<NLB_Cluster> Clusters) {
    vector<NLB_Cluster>::iterator iCluster;
    MSXML2::IXMLDOMNode *         pRoot = NULL;
    BSTR                          BURL = NULL;
    VARIANT                       vName;
    HRESULT                       hr = S_OK;

    CHECKHR(CoCreateInstance(MSXML2::CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, MSXML2::IID_IXMLDOMDocument2, (void**)&pDoc));

    CHECKALLOC(pDoc);

    CHECKALLOC((pRoot = CreateNode(pDoc, MSXML2::NODE_ELEMENT, NLB_XML_ELEMENT_NLB)));

    CHECKHR(SetStringAttribute(pRoot, NLB_XML_ATTRIBUTE_NAMESPACE, NLB_XML_VALUE_NLB_SCHEMA));

    for (iCluster = Clusters.begin(); iCluster != Clusters.end(); iCluster++) {
        vector<NLB_Cluster>::iterator iOtherCluster;
        NLB_Cluster *                 pCluster = iCluster;
        bool                          bWrite = true;

        if (pCluster->IsValid()) {
            for (iOtherCluster = iCluster + 1; iOtherCluster != Clusters.end(); iOtherCluster++) {
                NLB_Cluster * pOtherCluster = iOtherCluster;
                WCHAR         wszOtherName[MAX_PATH];
                WCHAR         wszName[MAX_PATH];

                if (!pCluster->GetName(wszName, MAX_PATH))
                    bWrite = false;

                if (!pOtherCluster->GetName(wszOtherName, MAX_PATH))
                    bWrite = false;

                if (!lstrcmpi(wszName, wszOtherName))
                    bWrite = false;
            }

            if (bWrite)
                CHECKHR(SaveCluster(pRoot, pCluster));
        }
    }

    CHECKHR(pDoc->appendChild(pRoot, NULL));

    CHECKHR(BeautifyDocument(pRoot, 0));

    CHECKALLOC((BURL = SysAllocString(wszFileName)));

    vName.vt = VT_BSTR;
    V_BSTR(&vName) = BURL;

    CHECKHR(pDoc->save(vName));

 CleanUp:    
    SAFERELEASE(pDoc);
    SAFERELEASE(pRoot);

    SAFEFREESTRING(BURL);

    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::InsertFormatting (PWCHAR Text, MSXML2::IXMLDOMNode * pUnder, MSXML2::IXMLDOMNode * pBefore) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNewChild = NULL;
    BSTR                  BValue = NULL;
    VARIANT               RefNode;
    VARIANT               value;
    HRESULT               hr = S_OK;

    CHECKALLOC((pChild = CreateNode(pDoc, MSXML2::NODE_TEXT, NULL)));
    
    CHECKALLOC((BValue = SysAllocString(Text)));
    
    value.vt = VT_BSTR;
    V_BSTR(&value) = BValue;
    
    CHECKHR(pChild->put_nodeValue(value));
    
    RefNode.vt = VT_UNKNOWN;
    V_UNKNOWN(&RefNode) = pBefore;
    
    CHECKHR(pUnder->insertBefore(pChild, RefNode, &pNewChild));
    
 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNewChild);
    
    return hr;
}

/*
 * Method: 
 * Description: 
 * Author: 
 */
HRESULT NLB_XMLDocument::BeautifyDocument (MSXML2::IXMLDOMNode * pNode, ULONG depth) {
    MSXML2::IXMLDOMNode * pChild = NULL;
    MSXML2::IXMLDOMNode * pNext = NULL;
    MSXML2::DOMNodeType   NodeType;
    WCHAR                 wszInsertText[MAX_PATH];
    WCHAR                 wszInsertTextAtEnd[MAX_PATH];
    bool                  bLastNodeWasText = false;
    bool                  bThisNodeIsText = false;
    int                   i;
    HRESULT               hr = S_OK;

    wcscpy(wszInsertText, L"\n");

    for (i = 0; i < depth; i++)
        wcscat(wszInsertText, L"  ");

    wcscpy(wszInsertTextAtEnd, wszInsertText);

    wcscat(wszInsertText, L"  ");

    depth += 1;

    CHECKHR(pNode->get_firstChild(&pChild));

    if (pChild) {
        while (pChild) {
            CHECKHR(pChild->get_nodeType(&NodeType));
            
            bThisNodeIsText = (NodeType == MSXML2::NODE_TEXT);

            if (!bLastNodeWasText && !bThisNodeIsText)
                CHECKHR(InsertFormatting(wszInsertText, pNode, pChild));
            
            bLastNodeWasText = bThisNodeIsText;

            CHECKHR(BeautifyDocument(pChild, depth));

            CHECKHR(pChild->get_nextSibling(&pNext));

            pChild->Release();
            pChild = pNext;
            pNext = NULL;
        }

        if (!bLastNodeWasText)
            CHECKHR(InsertFormatting(wszInsertTextAtEnd, pNode, NULL));
    }

 CleanUp:
    SAFERELEASE(pChild);
    SAFERELEASE(pNext);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\dload\printscanpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\dload\fxsapi.c ===
#include "printscanpch.h"
#pragma hdrstop

#define _WINFAX_

#include <objbase.h>
#include <faxsuite.h>
#include <fxsapip.h>

#include "printscanpch.h"
#pragma hdrstop

//
// default implementations for delay loading
//

WINFAXAPI
BOOL
FaxCheckValidFaxFolder(
    IN HANDLE	hFaxHandle,
    IN LPCWSTR  lpcwstrPath
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerA(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntry
   )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationA(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationW(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationA(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationW(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetPortA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetPortA(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetRecipientsLimit(
    IN HANDLE	hFaxHandle,
    IN DWORD	dwRecipientsLimit
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetRecipientsLimit(
    IN HANDLE	hFaxHandle,
    OUT LPDWORD	lpdwRecipientsLimit
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRelease(
    IN HANDLE FaxHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL
FXSAPIInitialize(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

VOID
FXSAPIFree(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return;
}

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJob2A
(
    IN  LPCSTR                 PrinterName,
    IN  const FAX_PRINT_INFOA    *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFOA       FaxContextInfo
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJob2W
(
    IN  LPCWSTR                 PrinterName,
    IN  const FAX_PRINT_INFOW    *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFOW       FaxContextInfo
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return;
}

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrExtensionName
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetInstallType(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetQueueStates (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwQueueStates
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetQueue (
    IN HANDLE       hFaxHandle,
    IN CONST DWORD  dwQueueStates
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsConfigurationA (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGA  *ppReceipts
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsConfigurationW (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGW  *ppReceipts
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetReceiptsConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGA  pReceipts
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetReceiptsConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGW  pReceipts
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsOptions (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwReceiptsOptions  // Combination of DRT_EMAIL and DRT_MSGBOX
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetVersion (
    IN  HANDLE          hFaxHandle,
    OUT PFAX_VERSION    pVersion
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetReportedServerAPIVersion (
    IN  HANDLE          hFaxHandle,
    OUT LPDWORD         lpdwReportedServerAPIVersion
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetActivityLoggingConfigurationA (
    IN  HANDLE                         hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGA *ppActivLogCfg
)
{
   SetLastError(ERROR_PROC_NOT_FOUND);
   return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetActivityLoggingConfigurationW (
    IN  HANDLE                         hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGW *ppActivLogCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetActivityLoggingConfigurationA (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGA  pActivLogCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetActivityLoggingConfigurationW (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGW  pActivLogCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetOutboxConfiguration (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_OUTBOX_CONFIG *ppOutboxCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetOutboxConfiguration (
    IN HANDLE                    hFaxHandle,
    IN CONST PFAX_OUTBOX_CONFIG  pOutboxCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetPersonalCoverPagesOption (
    IN  HANDLE  hFaxHandle,
    OUT LPBOOL  lpbPersonalCPAllowed
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationA (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGA    *ppArchiveCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationW (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGW    *ppArchiveCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGA   pArchiveCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGW   pArchiveCfg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetServerActivity (
    IN  HANDLE               hFaxHandle,
    OUT PFAX_SERVER_ACTIVITY pServerActivity
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumJobsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYA *JobEntry,
    OUT LPDWORD JobsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumJobsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_JOB_ENTRYW *JobEntry,
    OUT LPDWORD JobsReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI FaxEnumJobsExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI FaxEnumJobsExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetJobA(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYA *JobEntry
   )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetJobW(
   IN  HANDLE FaxHandle,
   IN  DWORD JobId,
   OUT PFAX_JOB_ENTRYW *JobEntry
   )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetJobExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntry
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetJobExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntry
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL WINAPI FaxSendDocumentExA
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL WINAPI FaxSendDocumentExW
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxStartMessagesEnum (
    IN  HANDLE                  hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PHANDLE                 phEnum
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEndMessagesEnum (
    IN  HANDLE  hEnum
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesA (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEA  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesW (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEW  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetMessageA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEA          *ppMsg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetMessageW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEW          *ppMsg
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRemoveMessage (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCSTR                lpctstrFilePath
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCWSTR                lpctstrFilePath
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

HRESULT WINAPI
FaxFreeSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return E_FAIL;
}


HRESULT WINAPI
FaxSetSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return E_FAIL;
}


HRESULT WINAPI
FaxGetSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return E_FAIL;
}

WINFAXAPI
BOOL
WINAPI
FaxGetSecurity (
    IN  HANDLE                  hFaxHandle,
    OUT PSECURITY_DESCRIPTOR    *ppSecDesc
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetSecurityEx (
    IN  HANDLE                  hFaxHandle,
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT PSECURITY_DESCRIPTOR    *ppSecDesc
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetSecurity (
    IN HANDLE                       hFaxHandle,
    IN SECURITY_INFORMATION         SecurityInformation,
    IN CONST PSECURITY_DESCRIPTOR   pSecDesc
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAccessCheckEx (
    IN  HANDLE          FaxHandle,
    IN  DWORD           AccessMask,
    OUT LPDWORD         lpdwRights
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetExtensionDataA (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCSTR lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetExtensionDataW (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCWSTR lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetExtensionDataA (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCSTR     lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetExtensionDataW (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCWSTR     lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumerateProvidersA (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOA *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumerateProvidersW (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOW *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingExtensionsA (
    IN  HANDLE                           hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOA    *ppRoutingExtensions,
    OUT LPDWORD                          lpdwNumExtensions
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingExtensionsW (
    IN  HANDLE                           hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOW    *ppRoutingExtensions,
    OUT LPDWORD                          lpdwNumExtensions
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
DWORD
WINAPI
IsDeviceVirtual (
    IN  HANDLE hFaxHandle,
    IN  DWORD  dwDeviceId,
    OUT LPBOOL lpbVirtual
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return ERROR_PROC_NOT_FOUND;
}

WINFAXAPI
BOOL
WINAPI
FaxGetPortExA (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXA  *ppPortInfo
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetPortExW (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXW  *ppPortInfo
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetPortExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXA  pPortInfo
)
{
   SetLastError(ERROR_PROC_NOT_FOUND);
   return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetPortExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXW  pPortInfo
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExA (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXA *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExW (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXW *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetRecipientInfoA (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEA  *lpPersonalProfile
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetRecipientInfoW (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEW  *lpPersonalProfile
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetSenderInfoA (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEA  *lpPersonalProfile
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetSenderInfoW (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEW  *lpPersonalProfile
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsA (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPA   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsW (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPW   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundGroupA (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPA pGroup
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundGroupW (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPW pGroup
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL
WINAPI
FaxSetDeviceOrderInGroupA (
        IN      HANDLE          hFaxHandle,
        IN      LPCSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

BOOL
WINAPI
FaxSetDeviceOrderInGroupW (
        IN      HANDLE          hFaxHandle,
        IN      LPCWSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundRulesA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEA *ppRules,
    OUT LPDWORD                      lpdwNumRules
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundRulesW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEW *ppRules,
    OUT LPDWORD                      lpdwNumRules
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundRuleA (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEA pRule
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundRuleW (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEW pRule
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundRuleA (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCSTR    lpctstrGroupName,
    IN  BOOL        bUseGroup
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundRuleW (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCWSTR    lpctstrGroupName,
    IN  BOOL        bUseGroup
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundRule (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetCountryListA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_TAPI_LINECOUNTRY_LISTA *ppCountryListBuffer
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetCountryListW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_TAPI_LINECOUNTRY_LISTW *ppCountryListBuffer
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrGUID,
    IN LPCSTR         lpctstrFriendlyName,
    IN LPCSTR         lpctstrImageName,
    IN LPCSTR         lpctstrTspName,
    IN DWORD            dwFSPIVersion,
    IN DWORD            dwCapabilities
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrGUID,
    IN LPCWSTR         lpctstrFriendlyName,
    IN LPCWSTR         lpctstrImageName,
    IN LPCWSTR         lpctstrTspName,
    IN DWORD            dwFSPIVersion,
    IN DWORD            dwCapabilities
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrGUID
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrGUID
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersA(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOA  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersW(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRegisterForServerEvents (
        IN  HANDLE      hFaxHandle,
        IN  DWORD       dwEventTypes,
        IN  HANDLE      hCompletionPort,
        IN  DWORD_PTR   dwCompletionKey,
        IN  HWND        hWnd,
        IN  DWORD       dwMessage,
        OUT LPHANDLE    lphEvent
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxUnregisterForServerEvents (
        IN  HANDLE      hEvent
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxAnswerCall(
        IN  HANDLE      hFaxHandle,
        IN  CONST DWORD dwDeviceId
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetConfigWizardUsed (
    OUT LPBOOL  lpbConfigWizardUsed
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxSetConfigWizardUsed (
    IN  HANDLE  hFaxHandle,
    OUT BOOL    bConfigWizardUsed
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxRefreshArchive (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetServerSKU(
    IN HANDLE	hFaxHandle,
    OUT PRODUCT_SKU_TYPE * pServerSKU
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(fxsapi)
{
    DLPENTRY(FXSAPIFree)
    DLPENTRY(FXSAPIInitialize)
    DLPENTRY(FaxAbort)
    DLPENTRY(FaxAccessCheck)
    DLPENTRY(FaxAccessCheckEx)
    DLPENTRY(FaxAddOutboundGroupA)
    DLPENTRY(FaxAddOutboundGroupW)
    DLPENTRY(FaxAddOutboundRuleA)
    DLPENTRY(FaxAddOutboundRuleW)
    DLPENTRY(FaxAnswerCall)
    DLPENTRY(FaxCheckValidFaxFolder)
    DLPENTRY(FaxClose)
    DLPENTRY(FaxCompleteJobParamsA)
    DLPENTRY(FaxCompleteJobParamsW)
    DLPENTRY(FaxConnectFaxServerA)
    DLPENTRY(FaxConnectFaxServerW)
    DLPENTRY(FaxEnableRoutingMethodA)
    DLPENTRY(FaxEnableRoutingMethodW)
    DLPENTRY(FaxEndMessagesEnum)
    DLPENTRY(FaxEnumGlobalRoutingInfoA)
    DLPENTRY(FaxEnumGlobalRoutingInfoW)
    DLPENTRY(FaxEnumJobsA)
    DLPENTRY(FaxEnumJobsExA)
    DLPENTRY(FaxEnumJobsExW)
    DLPENTRY(FaxEnumJobsW)
    DLPENTRY(FaxEnumMessagesA)
    DLPENTRY(FaxEnumMessagesW)
    DLPENTRY(FaxEnumOutboundGroupsA)
    DLPENTRY(FaxEnumOutboundGroupsW)
    DLPENTRY(FaxEnumOutboundRulesA)
    DLPENTRY(FaxEnumOutboundRulesW)
    DLPENTRY(FaxEnumPortsA)
    DLPENTRY(FaxEnumPortsExA)
    DLPENTRY(FaxEnumPortsExW)
    DLPENTRY(FaxEnumPortsW)
    DLPENTRY(FaxEnumRoutingExtensionsA)
    DLPENTRY(FaxEnumRoutingExtensionsW)
    DLPENTRY(FaxEnumRoutingMethodsA)
    DLPENTRY(FaxEnumRoutingMethodsW)
    DLPENTRY(FaxEnumerateProvidersA)
    DLPENTRY(FaxEnumerateProvidersW)
    DLPENTRY(FaxFreeBuffer)
    DLPENTRY(FaxFreeSenderInformation)
    DLPENTRY(FaxGetActivityLoggingConfigurationA)
    DLPENTRY(FaxGetActivityLoggingConfigurationW)
    DLPENTRY(FaxGetArchiveConfigurationA)
    DLPENTRY(FaxGetArchiveConfigurationW)
    DLPENTRY(FaxGetConfigWizardUsed)
    DLPENTRY(FaxGetConfigurationA)
    DLPENTRY(FaxGetConfigurationW)
    DLPENTRY(FaxGetCountryListA)
    DLPENTRY(FaxGetCountryListW)
    DLPENTRY(FaxGetDeviceStatusA)
    DLPENTRY(FaxGetDeviceStatusW)
    DLPENTRY(FaxGetExtensionDataA)
    DLPENTRY(FaxGetExtensionDataW)
    DLPENTRY(FaxGetInstallType)
    DLPENTRY(FaxGetJobA)
    DLPENTRY(FaxGetJobExA)
    DLPENTRY(FaxGetJobExW)
    DLPENTRY(FaxGetJobW)
    DLPENTRY(FaxGetLoggingCategoriesA)
    DLPENTRY(FaxGetLoggingCategoriesW)
    DLPENTRY(FaxGetMessageA)
    DLPENTRY(FaxGetMessageTiffA)
    DLPENTRY(FaxGetMessageTiffW)
    DLPENTRY(FaxGetMessageW)
    DLPENTRY(FaxGetOutboxConfiguration)
    DLPENTRY(FaxGetPageData)
    DLPENTRY(FaxGetPersonalCoverPagesOption)
    DLPENTRY(FaxGetPortA)
    DLPENTRY(FaxGetPortExA)
    DLPENTRY(FaxGetPortExW)
    DLPENTRY(FaxGetPortW)
    DLPENTRY(FaxGetQueueStates)
    DLPENTRY(FaxGetReceiptsConfigurationA)
    DLPENTRY(FaxGetReceiptsConfigurationW)
    DLPENTRY(FaxGetReceiptsOptions)
    DLPENTRY(FaxGetRecipientInfoA)
    DLPENTRY(FaxGetRecipientInfoW)
    DLPENTRY(FaxGetRecipientsLimit)
    DLPENTRY(FaxGetReportedServerAPIVersion)
    DLPENTRY(FaxGetRoutingInfoA)
    DLPENTRY(FaxGetRoutingInfoW)
    DLPENTRY(FaxGetSecurity)
    DLPENTRY(FaxGetSecurityEx)
    DLPENTRY(FaxGetSenderInfoA)
    DLPENTRY(FaxGetSenderInfoW)
    DLPENTRY(FaxGetSenderInformation)
    DLPENTRY(FaxGetServerActivity)
    DLPENTRY(FaxGetServerSKU)
    DLPENTRY(FaxGetServicePrintersA)
    DLPENTRY(FaxGetServicePrintersW)
    DLPENTRY(FaxGetVersion)
    DLPENTRY(FaxInitializeEventQueue)
    DLPENTRY(FaxOpenPort)
    DLPENTRY(FaxPrintCoverPageA)
    DLPENTRY(FaxPrintCoverPageW)
    DLPENTRY(FaxRefreshArchive)
    DLPENTRY(FaxRegisterForServerEvents)
    DLPENTRY(FaxRegisterRoutingExtensionW)
    DLPENTRY(FaxRegisterServiceProviderExA)
    DLPENTRY(FaxRegisterServiceProviderExW)
    DLPENTRY(FaxRegisterServiceProviderW)
    DLPENTRY(FaxRelease)
    DLPENTRY(FaxRemoveMessage)
    DLPENTRY(FaxRemoveOutboundGroupA)
    DLPENTRY(FaxRemoveOutboundGroupW)
    DLPENTRY(FaxRemoveOutboundRule)
    DLPENTRY(FaxSendDocumentA)
    DLPENTRY(FaxSendDocumentExA)
    DLPENTRY(FaxSendDocumentExW)
    DLPENTRY(FaxSendDocumentForBroadcastA)
    DLPENTRY(FaxSendDocumentForBroadcastW)
    DLPENTRY(FaxSendDocumentW)
    DLPENTRY(FaxSetActivityLoggingConfigurationA)
    DLPENTRY(FaxSetActivityLoggingConfigurationW)
    DLPENTRY(FaxSetArchiveConfigurationA)
    DLPENTRY(FaxSetArchiveConfigurationW)
    DLPENTRY(FaxSetConfigWizardUsed)
    DLPENTRY(FaxSetConfigurationA)
    DLPENTRY(FaxSetConfigurationW)
    DLPENTRY(FaxSetDeviceOrderInGroupA)
    DLPENTRY(FaxSetDeviceOrderInGroupW)
    DLPENTRY(FaxSetExtensionDataA)
    DLPENTRY(FaxSetExtensionDataW)
    DLPENTRY(FaxSetGlobalRoutingInfoA)
    DLPENTRY(FaxSetGlobalRoutingInfoW)
    DLPENTRY(FaxSetJobA)
    DLPENTRY(FaxSetJobW)
    DLPENTRY(FaxSetLoggingCategoriesA)
    DLPENTRY(FaxSetLoggingCategoriesW)
    DLPENTRY(FaxSetOutboundGroupA)
    DLPENTRY(FaxSetOutboundGroupW)
    DLPENTRY(FaxSetOutboundRuleA)
    DLPENTRY(FaxSetOutboundRuleW)
    DLPENTRY(FaxSetOutboxConfiguration)
    DLPENTRY(FaxSetPortA)
    DLPENTRY(FaxSetPortExA)
    DLPENTRY(FaxSetPortExW)
    DLPENTRY(FaxSetPortW)
    DLPENTRY(FaxSetQueue)
    DLPENTRY(FaxSetReceiptsConfigurationA)
    DLPENTRY(FaxSetReceiptsConfigurationW)
    DLPENTRY(FaxSetRecipientsLimit)
    DLPENTRY(FaxSetRoutingInfoA)
    DLPENTRY(FaxSetRoutingInfoW)
    DLPENTRY(FaxSetSecurity)
    DLPENTRY(FaxSetSenderInformation)
    DLPENTRY(FaxStartMessagesEnum)
    DLPENTRY(FaxStartPrintJob2A)
    DLPENTRY(FaxStartPrintJob2W)
    DLPENTRY(FaxStartPrintJobA)
    DLPENTRY(FaxStartPrintJobW)
    DLPENTRY(FaxUnregisterForServerEvents)
    DLPENTRY(FaxUnregisterRoutingExtensionA)
    DLPENTRY(FaxUnregisterRoutingExtensionW)
    DLPENTRY(FaxUnregisterServiceProviderExA)
    DLPENTRY(FaxUnregisterServiceProviderExW)
    DLPENTRY(IsDeviceVirtual)
};

DEFINE_PROCNAME_MAP(fxsapi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\dload\sti.c ===
#include "printscanpch.h"
#pragma hdrstop
#include <objbase.h>
#include <sti.h>


static
HRESULT 
StiCreateInstanceW(
    HINSTANCE hinst, 
    DWORD dwVer, 
    IStillImageW **ppSti, 
    LPUNKNOWN punkOuter)
{
    if (ppSti)
    {
        *ppSti = NULL;
    }
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(sti)
{
    DLPENTRY(StiCreateInstanceW)
};

DEFINE_PROCNAME_MAP(sti)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\dload\winspool.c ===
#include "printscanpch.h"
#pragma hdrstop

#include <winspool.h>

static
BOOL
WINAPI
AbortPrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddFormW(
    IN HANDLE   hPrinter,
    IN DWORD    Level,
    IN LPBYTE   pForm
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddJobW(
    IN HANDLE    hPrinter,
    IN DWORD     Level,
    OUT LPBYTE   pData,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddMonitorW(
    IN LPWSTR  pName,
    IN DWORD   Level,
    IN LPBYTE  pMonitors
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPortW(
    IN LPWSTR   pName,
    IN HWND     hWnd,
    IN LPWSTR   pMonitorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrinterConnectionW(
    IN LPWSTR pName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrinterDriverExW(
    IN LPWSTR   pName,
    IN DWORD    Level,
    IN PBYTE    pDriverInfo,
    IN DWORD    dwFileCopyFlags
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrinterDriverW(
    IN LPWSTR   pName,
    IN DWORD    Level,
    IN PBYTE    pDriverInfo
    )
{
    return FALSE;
}

static
HANDLE
WINAPI
AddPrinterW(
    IN LPWSTR   pName,
    IN DWORD    Level,
    IN LPBYTE   pPrinter
    )
{
    return NULL;
}

static
BOOL
WINAPI
AddPrintProcessorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pPathName,
    IN LPWSTR   pPrintProcessorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
AddPrintProvidorW(
    IN LPWSTR  pName,
    IN DWORD   level,
    IN LPBYTE  pProvidorInfo
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ClosePrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ConfigurePortW(
    IN LPWSTR   pName,
    IN HWND     hWnd,
    IN LPWSTR   pPortName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeleteFormW(
    IN HANDLE   hPrinter,
    IN LPWSTR   pFormName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeleteMonitorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pMonitorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePortW(
    IN LPWSTR   pName,
    IN HWND     hWnd,
    IN LPWSTR   pPortName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePrinter(
    IN HANDLE    hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePrinterConnectionW(
    IN LPWSTR    pName
    )
{
    return FALSE;
}

static
DWORD
WINAPI
DeletePrinterDataExW(
    IN HANDLE    hPrinter,
    IN LPCWSTR    pKeyName,
    IN LPCWSTR    pValueName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
DeletePrinterDataW(
    IN HANDLE    hPrinter,
    IN LPWSTR    pValueName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
DeletePrinterDriverExW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN LPWSTR    pDriverName,
    IN DWORD     dwDeleteFlag,
    IN DWORD     dwVersionFlag
    )
{
    return FALSE;
}


static
BOOL
WINAPI
DeletePrinterDriverW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN LPWSTR    pDriverName
    )
{
    return FALSE;
}

static
DWORD
WINAPI
DeletePrinterKeyW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
DeletePrintProcessorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pPrintProcessorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
DeletePrintProvidorW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN LPWSTR   pPrintProvidorName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EndDocPrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EndPagePrinter(
    HANDLE  hPrinter
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumJobsW(
    IN HANDLE   hPrinter,
    IN DWORD    FirstJob,
    IN DWORD    NoJobs,
    IN DWORD    Level,
    OUT LPBYTE  pJob,
    IN DWORD    cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumMonitorsW(
    IN LPWSTR    pName,
    IN DWORD     Level,
    OUT LPBYTE   pMonitors,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumPortsW(
    IN LPWSTR    pName,
    IN DWORD     Level,
    OUT LPBYTE   pPorts,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
DWORD
WINAPI
EnumPrinterDataExW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName,
    OUT LPBYTE   pEnumValues,
    IN DWORD     cbEnumValues,
    OUT LPDWORD  pcbEnumValues,
    OUT LPDWORD  pnEnumValues
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
EnumPrinterDataW(
    IN HANDLE    hPrinter,
    IN DWORD     dwIndex,
    OUT LPWSTR  pValueName,
    IN DWORD     cbValueName,
    OUT LPDWORD  pcbValueName,
    OUT LPDWORD  pType,
    OUT LPBYTE   pData,
    IN DWORD     cbData,
    OUT LPDWORD  pcbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
EnumPrinterDriversW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN DWORD     Level,
    IN LPBYTE    pDriverInfo,
    IN DWORD     cbBuf,
    IN LPDWORD   pcbNeeded,
    IN LPDWORD   pcReturned
    )
{
    return FALSE;
}

static
DWORD
WINAPI
EnumPrinterKeyW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName,
    OUT LPWSTR   pSubkey,
    IN DWORD     cbSubkey,
    OUT LPDWORD  pcbSubkey
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
EnumPrintProcessorDatatypesW(
    IN LPWSTR    pName,
    IN LPWSTR    pPrintProcessorName,
    IN DWORD     Level,
    OUT LPBYTE   pDatatypes,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumPrintProcessorsW(
    IN LPWSTR    pName,
    IN LPWSTR    pEnvironment,
    IN DWORD     Level,
    OUT LPBYTE   pPrintProcessorInfo,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded,
    OUT LPDWORD  pcReturned
    )
{
    return FALSE;
}

static
BOOL
WINAPI
FindClosePrinterChangeNotification(
    IN HANDLE    hChange
    )
{
    return FALSE;
}

static
BOOL
WINAPI
FlushPrinter(
    IN HANDLE    hPinter,
    IN LPVOID    pBuf,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcWritten,
    IN DWORD     cSleep
    )
{
    return FALSE;
}


static
BOOL
WINAPI
GetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetJobW(
    IN HANDLE    hPrinter,
    IN DWORD     JobId,
    IN DWORD     Level,
    OUT LPBYTE   pJob,
    IN DWORD     cbBuf,
    OUT LPDWORD  pcbNeeded
    )
{
    return FALSE;
}

static
DWORD
GetPrinterDataExW(
    IN HANDLE    hPrinter,
    IN LPCWSTR   pKeyName,
    IN LPCWSTR   pValueName,
    OUT LPDWORD  pType,
    OUT LPBYTE   pData,
    IN DWORD     nSize,
    OUT LPDWORD  pcbNeeded
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetPrintProcessorDirectoryW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pPrintProcessorInfo,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
DWORD
WINAPI
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
GetPrinterDriverDirectoryW(
    IN LPWSTR   pName,
    IN LPWSTR   pEnvironment,
    IN DWORD   Level,
    OUT LPBYTE  pDriverDirectory,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
WINAPI
OpenPrinterW(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ReadPrinter(
    IN HANDLE    hPrinter,
    OUT LPVOID   pBuf,
    IN DWORD     cbBuf,
    OUT LPDWORD  pNoBytesRead
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ResetPrinterW(
    IN HANDLE             hPrinter,
    IN LPPRINTER_DEFAULTS pDefault
    )
{
    return FALSE;
}

static
BOOL
WINAPI
ScheduleJob(
    IN HANDLE    hPrinter,
    IN DWORD     dwJobID
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SetFormW(
    IN HANDLE    hPrinter,
    IN LPWSTR    pFormName,
    IN DWORD     Level,
    IN LPBYTE    pForm
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SetJobW(
    IN HANDLE    hPrinter,
    IN DWORD     JobId,
    IN DWORD     Level,
    IN LPBYTE    pJob,
    IN DWORD     Command
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SetPortW(
    IN LPWSTR    pName,
    IN LPWSTR    pPortName,
    IN DWORD     dwLevel,
    IN LPBYTE    pPortInfo
    )
{
    return FALSE;
}

static
DWORD
WINAPI
SetPrinterDataExW(
    HANDLE  hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WINAPI
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    return FALSE;
}

static
DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
StartPagePrinter(
    HANDLE hPrinter
)
{
    return FALSE;
}

static
DWORD
WINAPI
WaitForPrinterChange(
    IN HANDLE  hPrinter,
    IN DWORD   Flags
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
WINAPI
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    )
{
    return FALSE;
}

static
BOOL
WINAPI
EnumPrintersW(
    IN DWORD   Flags,
    IN LPWSTR Name,
    IN DWORD   Level,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
    )
{
    return FALSE;
}

static
LONG
WINAPI
DocumentPropertiesW(
    IN HWND      hWnd,
    IN HANDLE    hPrinter,
    IN LPWSTR   pDeviceName,
    OUT PDEVMODEW pDevModeOutput,
    IN PDEVMODEW pDevModeInput,
    IN DWORD     fMode
    )
{
    return -1;
}

static
HANDLE
WINAPI
ConnectToPrinterDlg(
    IN HWND    hwnd,
    IN DWORD   Flags
    )
{
    return NULL;
}

static
LONG
WINAPI
AdvancedDocumentPropertiesW(
    IN HWND    hWnd,
    IN HANDLE  hPrinter,
    IN LPWSTR   pDeviceName,
    OUT PDEVMODEW pDevModeOutput,
    IN PDEVMODEW pDevModeInput
    )
{
    return 0;
}

static
int
WINAPI
DeviceCapabilitiesW(
    IN LPCWSTR pszDevice,
    IN LPCWSTR pszPort,
    IN WORD fwCapability,
    OUT LPWSTR pszOutput,
    IN CONST DEVMODEW* pDevMode
    )
{
    return -1;
}

static
LONG
WINAPI
ExtDeviceMode(
    HWND        hWnd,
    HANDLE      hInst,
    LPDEVMODEA  pDevModeOutput,
    LPSTR       pDeviceName,
    LPSTR       pPort,
    LPDEVMODEA  pDevModeInput,
    LPSTR       pProfile,
    DWORD       fMode
    )
{
    return -1;
}

static
BOOL
WINAPI
GetDefaultPrinterW(
    LPWSTR szDefaultPrinter,
    LPDWORD pcch
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SpoolerInit(
    VOID
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(winspool)
{
    DLOENTRY(203, GetDefaultPrinterW)
};

DEFINE_ORDINAL_MAP(winspool)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(winspool)
{
    DLPENTRY(AbortPrinter)
    DLPENTRY(AddFormW)
    DLPENTRY(AddJobW)
    DLPENTRY(AddMonitorW)
    DLPENTRY(AddPortW)
    DLPENTRY(AddPrintProcessorW)
    DLPENTRY(AddPrintProvidorW)
    DLPENTRY(AddPrinterConnectionW)
    DLPENTRY(AddPrinterDriverExW)
    DLPENTRY(AddPrinterDriverW)
    DLPENTRY(AddPrinterW)
    DLPENTRY(AdvancedDocumentPropertiesW)
    DLPENTRY(ClosePrinter)
    DLPENTRY(ConfigurePortW)
    DLPENTRY(ConnectToPrinterDlg)
    DLPENTRY(DeleteFormW)
    DLPENTRY(DeleteMonitorW)
    DLPENTRY(DeletePortW)
    DLPENTRY(DeletePrintProcessorW)
    DLPENTRY(DeletePrintProvidorW)
    DLPENTRY(DeletePrinter)
    DLPENTRY(DeletePrinterConnectionW)
    DLPENTRY(DeletePrinterDataExW)
    DLPENTRY(DeletePrinterDataW)
    DLPENTRY(DeletePrinterDriverExW)
    DLPENTRY(DeletePrinterDriverW)
    DLPENTRY(DeletePrinterKeyW)
    DLPENTRY(DeviceCapabilitiesW)
    DLPENTRY(DocumentPropertiesW)
    DLPENTRY(EndDocPrinter)
    DLPENTRY(EndPagePrinter)
    DLPENTRY(EnumFormsW)
    DLPENTRY(EnumJobsW)
    DLPENTRY(EnumMonitorsW)
    DLPENTRY(EnumPortsW)
    DLPENTRY(EnumPrintProcessorDatatypesW)
    DLPENTRY(EnumPrintProcessorsW)
    DLPENTRY(EnumPrinterDataExW)
    DLPENTRY(EnumPrinterDataW)
    DLPENTRY(EnumPrinterDriversW)
    DLPENTRY(EnumPrinterKeyW)
    DLPENTRY(EnumPrintersW)
    DLPENTRY(ExtDeviceMode)
    DLPENTRY(FindClosePrinterChangeNotification)
    DLPENTRY(FlushPrinter)
    DLPENTRY(GetFormW)
    DLPENTRY(GetJobW)
    DLPENTRY(GetPrintProcessorDirectoryW)
    DLPENTRY(GetPrinterDataExW)
    DLPENTRY(GetPrinterDataW)
    DLPENTRY(GetPrinterDriverDirectoryW)
    DLPENTRY(GetPrinterDriverW)
    DLPENTRY(GetPrinterW)
    DLPENTRY(OpenPrinterW)
    DLPENTRY(ReadPrinter)
    DLPENTRY(ResetPrinterW)
    DLPENTRY(ScheduleJob)
    DLPENTRY(SetFormW)
    DLPENTRY(SetJobW)
    DLPENTRY(SetPortW)
    DLPENTRY(SetPrinterDataExW)
    DLPENTRY(SetPrinterDataW)
    DLPENTRY(SetPrinterW)
    DLPENTRY(SpoolerInit)
    DLPENTRY(StartDocPrinterW)
    DLPENTRY(StartPagePrinter)
    DLPENTRY(WaitForPrinterChange)
    DLPENTRY(WritePrinter)
};

DEFINE_PROCNAME_MAP(winspool)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxsrc.inc ===
#
# All binaries will end up in the fax directory
#

# Mapping of old fax image names to new (Whistler) image names.
# fax projects uses this macros to figure out the name of the image they should generate.
# If you want to change the name of an image you should change the macro here and not
# change the project SOURCE file directly.

!ifndef FAXROOT
FAXROOT=$(BASEDIR)\printscan\faxsrv
!endif


FAXSETUP=FXSSTRAP
FAXSVC=FXSSVC
FAXADMIN=FXSADMIN
WINFAX=FXSAPI
WINFAXP=FXSAPIP
FAXCOM=FXSCOM
FAXCOMEX=FXSCOMEX
FAXDRV=FXSDRV
FAXEVENT=FXSEVENT
FAXMON=FXSMON
FAXPERF=FXSPERF
FAXROUTE=FXSROUTE
FAXTIFF=FXSTIFF
FAXT30=FXST30
FAXUI=FXSUI
FAXXP32=FXSXP32
FAXPNTPRT=FXSPTPRT
ROUTEEXT=FXSRTEXT
FAXQUEUE=FXSQUEUE
FAXCOVER=FXSCOVER
FAXSEND=FXSSEND
FAXEXT32=FXSEXT32
FAXOCM=FXSOCM
FAXCTXTMNU=FXSCTXT
FAXWZRD=FXSWZRD
FAXRES=FXSRES
T30PROP=FXST30P
FxsRouteMethodSnp=FXSRTMTD
FxsRouteExtSnp=FXSRTEXT
MSFXSSNP=FXSADMIN
FAXCOUNT=FXSCOUNT
FAXPERF=FXSPERF
FAXEXT_ECF=FXSEXT
FAXCLIENT=FXSCLNT
FAXCLIENTRES=FXSCLNTR
FAXST=FXSST
FAXCFGWZRD=FXSCFGWZ


BINPLACE_OVERRIDE_FLAGS=
C_DEFINES=$(C_DEFINES) -DBUILD_PRODUCT=$(BUILD_PRODUCT)

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG -DFAX_HEAP_DEBUG
!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
MSC_OPTIMIZATION=-Od
!endif
!endif

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS=$(FAXROOT)\util\unicode\$O\faxutil.lib
!else
C_DEFINES=$(C_DEFINES) -D_MBCS
LINKLIBS=$(FAXROOT)\util\ansii\$O\faxutil.lib
!endif

C_DEFINES=$(C_DEFINES) -DTAPI_CURRENT_VERSION=0x00020000 -DNT5BETA2

FAXLIB=$(FAXROOT)\lib\$(_OBJ_DIR)
FAXLIB95=$(FAXROOT)\lib\win95\$(_OBJ_DIR)

INCLUDES=$(FAXROOT)\inc;$(FAXROOT)\version

!ifndef FAX_NO_BUFFER_OVERFLOW_CHECKS
BUFFER_OVERFLOW_CHECKS=1
!else
BUFFER_OVERFLOW_CHECKS=0
!endif


MSC_WARNING_LEVEL=/W3 /WX
LINKER_FLAGS=-IGNORE:4006,4088,4104

COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h -FI$(FAXROOT)\inc\warning.h

!if $(PPC)
COMPILER_WARNINGS=$(COMPILER_WARNINGS) /W3 /WX
!endif

#
# force the build lab's checked
# build machines to have full symbolic
# debug info
#
!if "$(NTDEBUG)" == "cvp"
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -Z
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
!endif

#
# make us completely self contained
#
COFFBASE_TXT_FILE=$(FAXROOT)\NT_coffbase.txt
#BINPLACE_PLACEFILE=$(FAXROOT)\NT_placefil.txt


#
# Figure out where to place the images
# In XP, we binplace all binaries to the retail folder.
# if you want to override the default location, remove the comment
# from the line below.
#

!ifndef OVERRIDE_DEFAULT_BINPLACE
#_NTTREE=$(_NTTREE)\fax\i386
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\dload\printui.c ===
#include "printscanpch.h"
#pragma hdrstop

#include <objbase.h>
#include <shtypes.h>
#include <prsht.h>
#include <winspool.h>
#include <winprtp.h>


static
VOID
vPrinterPropPages(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
HRESULT
ShowErrorMessageHR(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  HRESULT              hr
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
RegisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder,
    OUT  PBOOL                   pbAdministrator OPTIONAL
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
UnregisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
bFolderRefresh(
    IN   HANDLE                  hFolder,
    OUT  PBOOL                   pbAdministrator
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT
ShowErrorMessageSC(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  DWORD                dwCode
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
bFolderGetPrinter(
    IN   HANDLE                  hFolder,
    IN   LPCTSTR                 pszPrinter,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded
    )
{
    return FALSE;
}

static
BOOL
bFolderEnumPrinters(
    IN   HANDLE                  hFolder,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded,
    OUT  PDWORD                  pcbReturned
    )
{
    return FALSE;
}

static
VOID
vQueueCreate(
    HWND    hwndOwner,
    LPCTSTR pszPrinter,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
VOID
vServerPropPages(
    HWND    hwndOwner,
    LPCTSTR pszServerName,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
VOID
vDocumentDefaults(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    )
{
    return;
}

static
BOOL
bPrinterSetup(
    HWND    hwnd,
    UINT    uAction,
    UINT    cchPrinterName,
    LPTSTR  pszPrinterName,
    UINT*   pcchPrinterName,
    LPCTSTR pszServerName
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(printui)
{
    DLPENTRY(RegisterPrintNotify)
    DLPENTRY(ShowErrorMessageHR)
    DLPENTRY(ShowErrorMessageSC)
    DLPENTRY(UnregisterPrintNotify)
    DLPENTRY(bFolderEnumPrinters)
    DLPENTRY(bFolderGetPrinter)
    DLPENTRY(bFolderRefresh)
    DLPENTRY(bPrinterSetup)
    DLPENTRY(vDocumentDefaults)
    DLPENTRY(vPrinterPropPages)
    DLPENTRY(vQueueCreate)
    DLPENTRY(vServerPropPages)
};

DEFINE_PROCNAME_MAP(printui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\complete.c ===
#include "faxcfgwz.h"
#include <strsafe.h>

#define MAX_SUMMARY_LEN 4096

static
BOOL
AppendSummaryText(
    LPTSTR      pSummaryText,
    DWORD       dwSummaryTextLen,
    INT         iRes,
    ...
    )

/*++

Routine Description:

    Create summary information depending on config settings

Arguments:

    pSummaryText - pointer of summary text
    dwSummaryTextLen - total length (in TCHARs) of pSummaryText
    iRes - resource ID for the text to be added into the summary text
    ... = arguments as required for the formatting

Return Value:

    TRUE if successful, FALSE for failure.

--*/
{
    va_list va;
    HRESULT hr;
    TCHAR szBuffer[MAX_SUMMARY_LEN] = {0};
    TCHAR szFormat[2*MAX_PATH + 1] = {0};

    DEBUG_FUNCTION_NAME(TEXT("AppendSummaryText"));

    if(!LoadString(g_hResource, iRes, szFormat, ARR_SIZE(szFormat)-1))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed. string ID=%d, error=%d"), 
                     iRes,
                     GetLastError());
        Assert(FALSE);
        return FALSE;
    }

    va_start(va, iRes);
    hr = StringCchVPrintf (szBuffer, ARR_SIZE(szBuffer), szFormat, va);
    va_end(va);
    if (FAILED(hr))
    {
        //
        // Failed to format string - buffer is too small
        //
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("Failed to format string - buffer is too small. 0x%08x"), hr);
        Assert(FALSE);
        return FALSE;
    }
    hr = StringCchCat (pSummaryText, dwSummaryTextLen, szBuffer);
    if (FAILED(hr))
    {
        //
        // Failed to concat string - buffer is too small
        //
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("Failed to concat string - buffer is too small. 0x%08x"), hr);
        Assert(FALSE);
        return FALSE;
    }
    return TRUE;
}   // AppendSummaryText

BOOL
ShowSummaryText(
    HWND   hDlg
)

/*++

Routine Description:

    Create summary information depending on config settings

Arguments:

    hDlg - Handle to the complete page

Return Value:

    TRUE if successful, FALSE for failure.

--*/
{
    TCHAR   szSummaryText[MAX_SUMMARY_LEN] = {0};
    HWND    hControl;
    BOOL    bRes = FALSE;
    DWORD   dwRoutingEnabled = FALSE; // indicate whether at least one routing method is enabled
    DWORD   dwIndex;

    DEBUG_FUNCTION_NAME(TEXT("ShowSummaryText()"));

    hControl = GetDlgItem(hDlg, IDC_SUMMARY);


    // get the control ID and clear the current content.
    SetWindowText(hControl, TEXT(""));

    // if no device is selected, don't show the summary page.
    if(!IsSendEnable() && !IsReceiveEnable())
    {
        ShowWindow(hControl, SW_HIDE);
        goto exit;
    }

    if(!LoadString(g_hResource, IDS_SUMMARY, szSummaryText, MAX_PATH))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     IDS_SUMMARY,
                     GetLastError());

        ShowWindow(hControl, SW_HIDE);
        goto exit;
    }
    //
    // Add send device settings
    //
    if(IsSendEnable())
    {
        if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_SEND_DEVICES))
        {
            goto exit;
        }
        for(dwIndex = 0; dwIndex < g_wizData.dwDeviceCount; dwIndex++)
        {
            if(g_wizData.pDevInfo[dwIndex].bSend)
            {
                if (!AppendSummaryText(szSummaryText, 
                                       ARR_SIZE (szSummaryText), 
                                       IDS_SUMMARY_DEVICE_ITEM, 
                                       g_wizData.pDevInfo[dwIndex].szDeviceName))
                {
                    goto exit;
                }                                       
            }
        }
        
        if(g_wizData.szTsid)
        {
            if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_TSID, g_wizData.szTsid))
            {
                goto exit;
            }
        }
    }
    //
    // Add receive device settings
    //
    if(IsReceiveEnable())
    {
        BOOL    bAuto = FALSE;
        int     iManualAnswerDeviceIndex = -1;

        if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_RECEIVE_DEVICES))
        {
            goto exit;
        }
        for(dwIndex = 0; dwIndex < g_wizData.dwDeviceCount; dwIndex++)
        {
            if(FAX_DEVICE_RECEIVE_MODE_AUTO == g_wizData.pDevInfo[dwIndex].ReceiveMode)
            {
                bAuto = TRUE;
                if (!AppendSummaryText(szSummaryText, 
                                       ARR_SIZE (szSummaryText), 
                                       IDS_SUMMARY_DEVICE_ITEM, 
                                       g_wizData.pDevInfo[dwIndex].szDeviceName))
                {
                    goto exit;
                }                                       
            }
            else if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_wizData.pDevInfo[dwIndex].ReceiveMode)
            {
                iManualAnswerDeviceIndex = dwIndex;
            }
        }
        
        if(bAuto)
        {
            if (!AppendSummaryText(szSummaryText, 
                                   ARR_SIZE (szSummaryText), 
                                   IDS_SUMMARY_AUTO_ANSWER, 
                                   g_wizData.dwRingCount))
            {
                goto exit;
            }                                   
        }

        if(iManualAnswerDeviceIndex != -1)
        {		
            Assert(!bAuto);

            if (!AppendSummaryText(szSummaryText, 
                                   ARR_SIZE (szSummaryText), 
                                   IDS_SUMMARY_DEVICE_ITEM, 
                                   g_wizData.pDevInfo[iManualAnswerDeviceIndex].szDeviceName))
            {
                goto exit;
            }                                   
            if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_MANUAL_ANSWER))
            {
                goto exit;
            }
        }

        if(g_wizData.szCsid)
        {
            if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_CSID, g_wizData.szCsid))
            {
                goto exit;
            }
        }

        // check whether user selects routing methods
        for(dwIndex = 0; dwIndex < RM_COUNT; dwIndex++)
        {
            if(g_wizData.pRouteInfo[dwIndex].bEnabled)
            {
                dwRoutingEnabled = TRUE;
                break;
            }
        }
        //
        // add routing information:
        //
        if(dwRoutingEnabled)
        {
            if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_ROUTING_METHODS))
            {
                goto exit;
            }
            for(dwIndex = 0; dwIndex < RM_COUNT; dwIndex++)
            {
                BOOL   bEnabled;
                LPTSTR tszCurSel;

                // 
                // if we don't have this kind of method, go to the next one
                //
                tszCurSel = g_wizData.pRouteInfo[dwIndex].tszCurSel;
                bEnabled  = g_wizData.pRouteInfo[dwIndex].bEnabled;

                switch (dwIndex) 
                {
                    case RM_FOLDER:

                        if(bEnabled) 
                        {
                            if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_SAVE_FOLDER, tszCurSel))
                            {
                                goto exit;
                            }
                        }
                        break;

                    case RM_PRINT:

                        if(bEnabled) 
                        {
                            if (!AppendSummaryText(szSummaryText, ARR_SIZE (szSummaryText), IDS_SUMMARY_PRINT, tszCurSel))
                            {
                                goto exit;
                            }
                        }
                        break;
                }
            }
        }
    }

    ShowWindow(hControl, SW_NORMAL);
    SetWindowText(hControl, szSummaryText);
    bRes = TRUE;

exit:
    return bRes;
}


INT_PTR CALLBACK 
CompleteDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Complete" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    HWND            hwndControl;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        {             
            // It's an intro/end page, so get the title font
            // from  the shared data and use it for the title control

            hwndControl = GetDlgItem(hDlg, IDCSTATIC_COMPLETE);
            SetWindowFont(hwndControl, g_wizData.hTitleFont, TRUE);

            return TRUE;
        }


    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE : // Enable the Back and Finish button    

                    ShowSummaryText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;

                case PSN_WIZBACK :
                    {
                        //
                        // Handle a Back button click here
                        //                    
                        if(RemoveLastPage(hDlg))
                        {
                            return TRUE;
                        }

                        break;
                    }

                    break;

                case PSN_WIZFINISH :
                
                    //
                    // Handle a Finish button click, if necessary
                    //

                    g_wizData.bFinishPressed = TRUE;

                    break;

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                default :
                    break;
            }

            break;
        } 

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\devlimit.c ===
#include "faxcfgwz.h"

BOOL g_bInitializing = FALSE; // TRUE during DoInitDevLimitDlg()

DWORD
CountSelectedDev(
    HWND    hDlg
)
/*++

Routine Description:

    Count selected devices

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    Number of the selected devices

--*/

{
    DWORD   dw;
    HWND    hwndLv;
    DWORD   dwSelected=0;    // count selected devices

    DEBUG_FUNCTION_NAME(TEXT("OnDevSelect()"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(ListView_GetCheckState(hwndLv, dw))
        {
            ++dwSelected;
        }
    }

    return dwSelected;
}


VOID
OnDevSelect(
    HWND    hDlg
)
/*++

Routine Description:

    Handle device selection

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    None

--*/

{
    HWND    hwndLv;
    INT     iItem;
    DWORD   dwSelectNum;    // count selected devices

    DEBUG_FUNCTION_NAME(TEXT("OnDevSelect()"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    dwSelectNum = CountSelectedDev(hDlg);

    if(dwSelectNum > g_wizData.dwDeviceLimit)
    {
        //
        // If the user exceeds the device limit
        // uncheck selected device
        //
        iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);
        if(iItem == -1)
        {
            Assert(FALSE);
        }
        else
        {
            ListView_SetCheckState(hwndLv, iItem, FALSE);
        }

        DisplayMessageDialog(hDlg, MB_OK | MB_ICONSTOP, 0, IDS_DEV_LIMIT_ERROR, g_wizData.dwDeviceLimit);
    }

    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_DEVICE_ERR), (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDC_STATIC_NO_DEVICE),    (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);
}

VOID
DoInitDevLimitDlg(
    HWND    hDlg
)
/*++

Routine Description:

    Init the "Device limit" page

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    None

--*/

{
    DWORD   dw;
    DWORD   dwSelected=0;    // count selected devices
    BOOL    bCheck;
    HWND    hwndLv;
    INT     iIndex;
    LV_ITEM lvItem = {0};

    DEBUG_FUNCTION_NAME(TEXT("DoInitDevLimitDlg()"));

    g_bInitializing = TRUE;

    InitDeviceList(hDlg, IDC_DEVICE_LIST);

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    //
    // Fill the list of devices and select the first item.
    //
    lvItem.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvItem.iImage  = DI_Modem;

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        lvItem.iItem   = dw;
        lvItem.pszText = g_wizData.pDevInfo[dw].szDeviceName;
        lvItem.lParam  = dw;

        iIndex = ListView_InsertItem(hwndLv, &lvItem);

        bCheck = FALSE;
        if((dwSelected < g_wizData.dwDeviceLimit) && 
           (g_wizData.pDevInfo[dw].bSend    || 
            (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode)))
        {
            bCheck = TRUE;
            ++dwSelected;
        }

        ListView_SetCheckState(hwndLv, iIndex, bCheck);
    }

    //
    // Select the first item.
    //
    ListView_SetItemState(hwndLv, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    OnDevSelect(hDlg);

    ListView_SetColumnWidth(hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );  

    g_bInitializing = FALSE;
}

void
DoSaveDevLimit(
    HWND    hDlg
)
/*++

Routine Description:

    Save the user's choice for devices

Arguments:

    hDlg - Handle to the "Device limit" page

Return Value:

    None

--*/

{
    DWORD   dw;
    HWND    hwndLv;
    BOOL    bSelected;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveDevLimit()"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        bSelected = ListView_GetCheckState(hwndLv, dw);
    
        g_wizData.pDevInfo[dw].bSelected = bSelected;

        if(!bSelected)
        {
            g_wizData.pDevInfo[dw].bSend    = FALSE;
            g_wizData.pDevInfo[dw].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
        }
    }    
}

INT_PTR 
CALLBACK 
DevLimitDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Send Device" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            DoInitDevLimitDlg(hDlg);
            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            default:
                break;
        }

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : 

                // Enable the Back and Finish button    
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
            {
                //
                // Handle a Back button click here
                //
                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }

            case PSN_WIZNEXT :
                //
                // Handle a Next button click, if necessary
                //
                DoSaveDevLimit(hDlg);

                SetLastPage(IDD_DEVICE_LIMIT_SELECT);

                if(CountSelectedDev(hDlg) == 0)
                {
                    //
                    // go to the completion page
                    //
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                    return TRUE;
                }

                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            case LVN_ITEMCHANGED:
            {
                //
                // need to validate the control after changing selection by keyboard
                // 
                if(!g_bInitializing)
                {
                    OnDevSelect(hDlg);
                }

                break;
            }

            case NM_DBLCLK:

            {
                //
                // Handle a double click event
                //
                INT   iItem;
                HWND  hwndLv;
                hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
                iItem = ((LPNMITEMACTIVATE) lParam)->iItem;
                ListView_SetCheckState(hwndLv, iItem, !ListView_GetCheckState(hwndLv, iItem));
                
                // we don't have break here because we'll go through NM_CLICK
            }

            case NM_CLICK:
            {
                //
                // Handle a Click event
                //
                INT   iItem;
                HWND  hwndLv;
                hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
                iItem = ((LPNMITEMACTIVATE) lParam)->iItem;

                ListView_SetItemState(hwndLv, iItem, LVIS_SELECTED, LVIS_SELECTED);

                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\faxcfgwzexp.h ===
#ifndef _FAX_CONFIG_WIZARD_EXPORT_H_
#define _FAX_CONFIG_WIZARD_EXPORT_H_

#ifdef __cplusplus
extern "C" {
#endif

// Functions in FaxCfgWz.c
BOOL FaxConfigWizard(BOOL bExplicitLaunch, LPBOOL lpbAbort);

typedef BOOL (*FAX_CONFIG_WIZARD)(BOOL, LPBOOL);

#define FAX_CONFIG_WIZARD_PROC  "FaxConfigWizard"

#define FAX_CONFIG_WIZARD_DLL   TEXT("FxsCfgWz.dll")

#ifdef __cplusplus
}
#endif

#endif // _FAX_CONFIG_WIZARD_EXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\dll.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    dll.c

Abstract:

    Dynamic library entry point

Environment:

    Fax configuration wizard

Revision History:

        03/13/00 -taoyuan-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcfgwz.h"
#include <faxres.h>

HINSTANCE   g_hModule = NULL;      // DLL instance handle
HINSTANCE   g_hResource = NULL;    // Resource DLL instance handle


BOOL
DllMain(
    HINSTANCE   hInstance,
    ULONG       ulReason,
    PCONTEXT    pContext
    )
/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("DllMain of Fax Config Wizard"));

    switch (ulReason) 
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstance);

            g_hModule   = hInstance;
            g_hResource = GetResInstance(hInstance); 
            if(!g_hResource)
            {
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:

            FreeResInstance();
            HeapCleanup();
            break;
    }

    return TRUE;
}

void CALLBACK 
FaxCfgWzrdDllW(
	HWND hwnd, 
	HINSTANCE hinst, 
	LPWSTR lpszCmdLine,
    int nCmdShow
) 
/*++
Routine Description:

	RunDll32.exe entry point

--*/
{
    BOOL bAbort;
    DEBUG_FUNCTION_NAME(TEXT("FaxCfgWzrdDllW()"));
	//
	// Explicit launch
	//
	FaxConfigWizard(TRUE, &bAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\faxcfgwz.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Fax configuration wizard main function

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"
#include <shfusion.h>

HANDLE          g_hFaxSvcHandle = NULL;
LIST_ENTRY      g_PageList;             // to keep track of the previous page.
BOOL            g_bShowDevicePages = TRUE;
BOOL            g_bShowUserInfo = TRUE; 
WIZARDDATA      g_wizData = {0};
extern PPRINTER_NAMES g_pPrinterNames;
extern DWORD          g_dwNumPrinters;
const LPCTSTR g_RoutingGuids[RM_COUNT] = 
{
    REGVAL_RM_FOLDER_GUID,      // RM_FOLDER
    REGVAL_RM_PRINTING_GUID     // RM_PRINT
};

typedef struct _WIZARDPAGEINFO
{
    INT         pageId;     // page dialog id
    DLGPROC     dlgProc;    // page dialog callback function
    BOOL        bSelected;  // Whether this page is selected in the wizard
    INT         Title;      // title id from the resource file
    INT         SubTitle;   // sub title id from the resource file
} WIZARDPAGEINFO, *PWIZARDPAGEINFO;

//
// all configuration pages are false here, they will be initialized by FaxConfigWizard()
//
static WIZARDPAGEINFO g_FaxWizardPage[] = 
{
    { IDD_CFG_WIZARD_WELCOME,           WelcomeDlgProc,     TRUE,   0,                          0 },
    { IDD_WIZARD_USER_INFO,             UserInfoDlgProc,    FALSE,  IDS_WIZ_USER_INFO_TITLE,    IDS_WIZ_USER_INFO_SUB },
    { IDD_DEVICE_LIMIT_SELECT,          DevLimitDlgProc,    FALSE,  IDS_DEVICE_LIMIT_TITLE,     IDS_DEVICE_LIMIT_SUB },
    { IDD_ONE_DEVICE_LIMIT,             OneDevLimitDlgProc, FALSE,  IDS_ONE_DEVICE_TITLE,       IDS_ONE_DEVICE_SUB },
    { IDD_WIZARD_SEND_SELECT_DEVICES,   SendDeviceDlgProc,  FALSE,  IDS_WIZ_SEND_DEVICE_TITLE,  IDS_WIZ_SEND_DEVICE_SUB },
    { IDD_WIZARD_SEND_TSID,             SendTsidDlgProc,    FALSE,  IDS_WIZ_SEND_TSID_TITLE,    IDS_WIZ_SEND_TSID_SUB },
    { IDD_WIZARD_RECV_SELECT_DEVICES,   RecvDeviceDlgProc,  FALSE,  IDS_WIZ_RECV_DEVICE_TITLE,  IDS_WIZ_RECV_DEVICE_SUB },
    { IDD_WIZARD_RECV_CSID,             RecvCsidDlgProc,    FALSE,  IDS_WIZ_RECV_CSID_TITLE,    IDS_WIZ_RECV_CSID_SUB },
    { IDD_WIZARD_RECV_ROUTE,            RecvRouteDlgProc,   FALSE,  IDS_WIZ_RECV_ROUTE_TITLE,   IDS_WIZ_RECV_ROUTE_SUB },
    { IDD_WIZARD_COMPLETE,              CompleteDlgProc,    TRUE,   0,                          0 }
};


#define TIME_TO_WAIT_FOR_CONVERSTION 25000
#define NUM_PAGES (sizeof(g_FaxWizardPage)/sizeof(WIZARDPAGEINFO))

enum WIZARD_PAGE 
{ 
    WELCOME = 0, 
    USER_INFO, 
    DEV_LIMIT,
    ONE_DEV_LIMIT,
    SEND_DEVICE, 
    TSID, 
    RECV_DEVICE, 
    CSID,
    ROUTE 
};

#define TITLE_SIZE   600

BOOL LoadDeviceData();
BOOL SaveDeviceData();
void FreeDeviceData();
DWORD ConvertCpeFilesToCov();


BOOL
FillInPropertyPage(
    PROPSHEETPAGE  *psp,
    PWIZARDPAGEINFO pPageInfo
)

/*++

Routine Description:

    Fill out a PROPSHEETPAGE structure with the supplied parameters

Arguments:

    psp - Points to the PROPSHEETPAGE structure to be filled out
    pData - Pointer to the shared data structure

Return Value:

    NONE

--*/

{

    LPTSTR pWizardTitle = NULL;
    LPTSTR pWizardSubTitle = NULL;

    DEBUG_FUNCTION_NAME(TEXT("FillInPropertyPage()"));

    Assert(psp);

    DebugPrintEx(DEBUG_MSG, TEXT("FillInPropertyPage %d"), pPageInfo->pageId);
    
    psp->dwSize = sizeof(PROPSHEETPAGE);

    //
    // Don't show titles if it's the first or last page
    //
    if (0 == pPageInfo->Title && 0 == pPageInfo->SubTitle) 
    {
        psp->dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
    } 
    else 
    {
        psp->dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    }

    psp->hInstance   = g_hResource; 
    psp->pszTemplate = MAKEINTRESOURCE(pPageInfo->pageId);
    psp->pfnDlgProc  = pPageInfo->dlgProc;

    if (pPageInfo->Title) 
    {
        pWizardTitle = (LPTSTR)MemAlloc(TITLE_SIZE*sizeof(TCHAR));
        if(!pWizardTitle)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed"));
            goto error;;
        }

        if (!LoadString(g_hResource, pPageInfo->Title, pWizardTitle, TITLE_SIZE))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("LoadString failed. string ID=%d, error=%d"), 
                         pPageInfo->Title,
                         GetLastError());
            goto error;
        }
    }

    if (pPageInfo->SubTitle)
    {
        pWizardSubTitle = (LPTSTR)MemAlloc(TITLE_SIZE*sizeof(TCHAR) );
        if(!pWizardSubTitle)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed"));
            goto error;
        }
        ZeroMemory(pWizardSubTitle, TITLE_SIZE*sizeof(TCHAR));

        if(IDS_DEVICE_LIMIT_SUB == pPageInfo->SubTitle && g_wizData.dwDeviceLimit != INFINITE)
        {
            //
            // Format limit device selection page subtitle
            //
            TCHAR tszBuffer[MAX_PATH];
            if (!LoadString(g_hResource, pPageInfo->SubTitle, tszBuffer, MAX_PATH))
            {
                DebugPrintEx(DEBUG_ERR, 
                             TEXT("LoadString failed. string ID=%d, error=%d"), 
                             pPageInfo->SubTitle,
                             GetLastError());
                goto error;
            }
            _sntprintf(pWizardSubTitle, TITLE_SIZE-1, tszBuffer, g_wizData.dwDeviceLimit);
        }
        else if (!LoadString(g_hResource, pPageInfo->SubTitle, pWizardSubTitle, TITLE_SIZE))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("LoadString failed. string ID=%d, error=%d"), 
                         pPageInfo->SubTitle,
                         GetLastError());
            goto error;
        }
    }

    psp->pszHeaderTitle    = pWizardTitle;
    psp->pszHeaderSubTitle = pWizardSubTitle;

    return TRUE;

error:
    MemFree(pWizardTitle);
    MemFree(pWizardSubTitle);

    return FALSE;
}







BOOL
FaxConfigWizard(
    BOOL   bExplicitLaunch,
    LPBOOL lpbAbort
)

/*++

Routine Description:

    Present the Fax Configuration Wizard to the user. 

Arguments:

    bExplicitLaunch - [in]  Fax Config Wizard was launched explicitly
    lpbAbort        - [out] TRUE if the user refused to enter a dialing location and the calling process should abort.

Return Value:

    TRUE if successful, FALSE if there is an error or the user pressed Cancel.

--*/

{
    HWND            hWnd; // window handle of the calling method
    PROPSHEETPAGE   psp[NUM_PAGES] = {0};
    PROPSHEETPAGE*  pspSaved;
    PROPSHEETHEADER psh = {0};
    BOOL            bResult = FALSE;
    HDC             hdc = NULL;
    DWORD           i = 0;
    DWORD           dwPageCount = 0;
    LPTSTR          lptstrResource = NULL;
    BOOL            bLinkWindowRegistered  = FALSE;
    int             nRes;
    BOOL            bSHFusionInitialized = FALSE;

    INITCOMMONCONTROLSEX CommonControlsEx = { sizeof(INITCOMMONCONTROLSEX), ICC_WIN95_CLASSES  };

    DEBUG_FUNCTION_NAME(TEXT("FaxConfigWizard()"));

    // 
    // initialize the link list for tracing pages
    //
    InitializeListHead(&g_PageList);

    //
    // Enable SHAutoComplete
    //
    CoInitialize(NULL);

    //
    // Fusion Initialize
    //
    if (!SHFusionInitializeFromModuleID(g_hModule, SXS_MANIFEST_RESOURCE_ID))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SHFusionInitializeFromModuleID failed."));
    }
    else
    {
        bSHFusionInitialized = TRUE;
    }

    if (!InitCommonControlsEx(&CommonControlsEx))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("InitCommonControlsEx failed"));
        goto exit;
    }

    hWnd = GetActiveWindow();
    g_wizData.hWndParent = hWnd;
    //
    // On first time, convert CPE files from CSIDL_COMMON_APPDATA\Microsoft\Windows NT\MSFax\Common Coverpages
    // to the user personal cover page directory: CSIDL_PERSONAL\Fax\Personal Coverpages
    //
    if (ConvertCpeFilesToCov() != ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("ConvertCpeFilesToCov failed, continue anyways"));
    }


    // 
    // Check if the user has run this wizard before
    //
    if(!bExplicitLaunch)
    {
        BOOL bDeviceConfigured = FALSE;
		BOOL bExistsPrinterConnection = FALSE;
		TCHAR tszPrnName[MAX_PATH];

        //
        // Is the user info already configured?
        //
        if(IsUserInfoConfigured())
        {
            g_bShowUserInfo = FALSE;
        }
        //
        // Are fax devices already configured?
        //
        if(!FaxGetConfigWizardUsed(&bDeviceConfigured))
        {
           DebugPrintEx(DEBUG_ERR, TEXT("FaxGetConfigWizardUsed failed. ec = %d"), GetLastError());
            goto exit;
        }
		//
		//Are there any printer connections installed?
		//
		if (GetFirstRemoteFaxPrinterName(tszPrnName,MAX_PATH))
		{
			bExistsPrinterConnection = TRUE;
		}			

        if(bDeviceConfigured || bExistsPrinterConnection)
        {
            g_bShowDevicePages = FALSE;
        }
    }

    if(!g_bShowUserInfo && !g_bShowDevicePages)
    {
        //
        // No pages to show - no error
        //
        bResult = TRUE;
        goto exit;
    }
    //
    // We're going to call into the local fax server - connect to it now.
    //
    if(!Connect())
    {
        if(bExplicitLaunch)
        {
            DisplayMessageDialog(hWnd, 0, 0, IDS_ERR_CANT_CONNECT);
        }
        DebugPrintEx(DEBUG_ERR, TEXT("Can't connect to fax server. ec = %d"), GetLastError());
        goto exit;
    }

    *lpbAbort = FALSE;
    if(g_bShowDevicePages)
    {
        if(FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL))
        {
            //
            // IsFaxDeviceInstalled() prompts to install a device if needed
            //
            if(!IsFaxDeviceInstalled(g_wizData.hWndParent, lpbAbort))
            {
                g_bShowDevicePages = FALSE;
            }
        }
        else
        {
            //
            // the user has no manage access
            //
            g_bShowDevicePages = FALSE;
        }
    }

    if (*lpbAbort)
    {
        //
        // the user refused to enter a dialing location and the calling process should abort.
        //
        DebugPrintEx(DEBUG_MSG, 
                     TEXT("The user refused to enter a dialing location and the calling process should abort"));
        return FALSE;
    }

    if(g_bShowDevicePages)
    {
        TCHAR tszPrnName[MAX_PATH];
        if(GetFirstLocalFaxPrinterName(tszPrnName, MAX_PATH-1))
        {
            // TODO: suggest install printer
        }
    }

    if(!g_bShowUserInfo && !g_bShowDevicePages)
    {
        //
        // no pages to show - no error
        //
        bResult = TRUE;
        goto exit;
    }
    //
    // Load shared data
    // 
    if(!LoadWizardData())
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Load data error."));
        goto exit;
    }

    //
    // Set page information depending on user selection as well as checking user access right
    //
    if(g_bShowUserInfo)
    {   
        g_FaxWizardPage[USER_INFO].bSelected = TRUE;
    }

    if(g_bShowDevicePages)
    {   
        HKEY  hRegKey;
        DWORD dwDisableRouting = 0;
        Assert(g_wizData.dwDeviceCount);

        if(1 == g_wizData.dwDeviceLimit)
        {
            g_FaxWizardPage[ONE_DEV_LIMIT].bSelected = TRUE;
        }
        else if(g_wizData.dwDeviceLimit < g_wizData.dwDeviceCount)
        {
            g_FaxWizardPage[DEV_LIMIT].bSelected = TRUE;
        }               

        g_FaxWizardPage[SEND_DEVICE].bSelected = (1 < g_wizData.dwDeviceLimit);
        g_FaxWizardPage[TSID].bSelected        = TRUE;
        g_FaxWizardPage[RECV_DEVICE].bSelected = (1 < g_wizData.dwDeviceLimit);
        g_FaxWizardPage[CSID].bSelected        = TRUE;

        hRegKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, FALSE, KEY_READ);
        if(hRegKey)
        {
            dwDisableRouting = GetRegistryDword(hRegKey, REGVAL_CFGWZRD_DISABLE_ROUTING);
            RegCloseKey(hRegKey);
        }

        g_FaxWizardPage[ROUTE].bSelected = dwDisableRouting ? FALSE : TRUE;
    }
   
    //
    // Register the link window class
    //
    bLinkWindowRegistered = LinkWindow_RegisterClass();
    if(!bLinkWindowRegistered)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LinkWindow_RegisterClass() failed - unable to register link window class"));
    }


    //
    //  Fill out one PROPSHEETPAGE structure for every page:
    //  The first page is a welcome page
    //  The last page is a complete page
    //
    pspSaved = psp;
    for(i = 0; i < NUM_PAGES; i++)
    {
        if(g_FaxWizardPage[i].bSelected)
        {
            if(!FillInPropertyPage(pspSaved++, &g_FaxWizardPage[i]))
            {
                DebugPrintEx(DEBUG_ERR, TEXT("FillInPropertyPage failed"));
                goto exit;
            }
            dwPageCount++;
        }
    }

    //
    // Fill out the PROPSHEETHEADER structure
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;

    psh.hwndParent = hWnd;
    psh.hInstance = g_hResource;
    psh.hIcon = NULL;
    psh.pszCaption = TEXT("");
    psh.nPages = dwPageCount;
    psh.nStartPage = 0;
    psh.ppsp = psp;

    if(hdc = GetDC(NULL)) 
    {
        if(GetDeviceCaps(hdc, BITSPIXEL) >= 8) 
        {
            lptstrResource = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK_256);
        }
        else
        {
            lptstrResource = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK_16);
        }

        ReleaseDC(NULL,hdc);
        hdc = NULL;
    }

    psh.pszbmHeader = MAKEINTRESOURCE(IDB_CFG_WIZ_BITMAP); 
    psh.pszbmWatermark = lptstrResource;

    //
    // Display the wizard pages
    //    
    nRes = (int)PropertySheet(&psh);
    if (nRes > 0 && g_wizData.bFinishPressed)
    {
        // 
        // Save new settings here
        //
        if(!SaveWizardData())
        {
            DisplayMessageDialog(hWnd, MB_ICONERROR, 0, IDS_ERR_NOT_SAVE);
            DebugPrintEx(DEBUG_ERR, TEXT("Can't save wizard data."));
            goto exit;
        }
    }
    else if(0 == nRes && !bExplicitLaunch) // Cancel
    {
        if(IDNO == DisplayMessageDialog(hWnd, 
                                        MB_YESNO | MB_ICONQUESTION, 
                                        0, 
                                        IDS_SHOW_NEXT_TIME))
        {
            if (g_bShowUserInfo) 
            { 
                DWORD  dwRes;
                HKEY   hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, 
                                                 REGKEY_FAX_SETUP, 
                                                 TRUE, 
                                                 KEY_ALL_ACCESS);
                if(hRegKey)
                {
                    SetRegistryDword(hRegKey, REGVAL_CFGWZRD_USER_INFO, TRUE);
                    dwRes = RegCloseKey(hRegKey);
                    if(ERROR_SUCCESS != dwRes)
                    {
                        Assert(FALSE);
                        DebugPrintEx(DEBUG_ERR, TEXT("RegCloseKey failed: error=%d"), dwRes);
                    }
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR, 
                                 TEXT("OpenRegistryKey failed: error=%d"), 
                                 GetLastError());
                }

            }

            if (g_bShowDevicePages ||
                FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL))
            { 
                //
                // If the user has manage access and does not have a fax device
                // it's mean she refused to install it.
                // So, we should not disturb her
                // with implicit invocation of the Configuration Wizard.
                //
                if(!FaxSetConfigWizardUsed(g_hFaxSvcHandle, TRUE))
                {
                    DebugPrintEx(DEBUG_ERR, TEXT("FaxSetConfigWizardUsed failed with %d"), GetLastError());
                }
            }
        }
    } 
    else if(nRes < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("PropertySheet() failed (ec: %ld)"), GetLastError());
    }

    bResult = TRUE;

exit:    
    //
    // Cleanup properly before exiting
    //
    for (i = 0; i< dwPageCount; i++) 
    {
        MemFree((PVOID)psp[i].pszHeaderTitle );
        MemFree((PVOID)psp[i].pszHeaderSubTitle );
    }

    FreeWizardData();

    ClearPageList();

    if( bLinkWindowRegistered )
    {
        LinkWindow_UnregisterClass( g_hResource );
    }
    
    DisConnect();

    if (g_pPrinterNames)
    {
        ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
        g_pPrinterNames = NULL;
    }

    if (bSHFusionInitialized)
    {
        SHFusionUninitialize();
    }

    CoUninitialize();

    return bResult; 
} // FaxConfigWizard

BOOL 
LoadWizardData()
/*++

Routine Description:

    Load the wizard data from the system. 
    If there are more than one device, we load the data for the first available device.

Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("LoadWizardData()"));

    if (g_bShowUserInfo) 
    { 
        if(!LoadUserInfo())
        {
            //
            // no user info
            //
            DebugPrintEx(DEBUG_MSG, TEXT("LoadUserInfo: failed: error=%d"), GetLastError());
        }
    }

    //
    // get the large fonts for wizard97
    // 
    if(!LoadWizardFont())
    {
        DebugPrintEx(DEBUG_MSG, TEXT("LoadWizardFont: failed."));
        goto error;
    }


    if (g_bShowDevicePages) 
    { 
        if(!LoadDeviceData())
        {
            DebugPrintEx(DEBUG_MSG, TEXT("LoadDeviceData: failed."));
            goto error;
        }
    }

    return TRUE;

error:
    FreeWizardData();

    return FALSE;

} // LoadWizardData

BOOL 
LoadWizardFont()
/*++

Routine Description:

    Load the wizard font for the title. 

Arguments:

    pData - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    HDC             hdc = NULL;
    LOGFONT         lfTitleFont = {0};
    NONCLIENTMETRICS ncm = {0};
    TCHAR           szFontName[MAX_PATH];   
    INT             iFontSize = 12;         // fixed large font size, which is 12

    DEBUG_FUNCTION_NAME(TEXT("LoadWizardFont()"));

    //
    // get the large fonts for wizard97
    // 
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SystemParametersInfo failed. ec = 0x%X"), GetLastError());
        goto Error;
    }
    else 
    {

        CopyMemory((LPVOID* )&lfTitleFont, (LPVOID *)&ncm.lfMessageFont, sizeof(lfTitleFont));
        
        if (!LoadString(g_hResource, IDS_WIZ_LARGE_FONT_NAME, szFontName, MAX_PATH ))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("LoadString failed: string ID=%d, error=%d"), 
                         IDS_WIZ_LARGE_FONT_NAME,
                         GetLastError());
            goto Error;
        }

        lfTitleFont.lfWeight = FW_BOLD;

        hdc = GetDC(NULL);
        if (!hdc)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("GetDC() failed (ec: ld)"), GetLastError());
            goto Error;
        }
        
        lfTitleFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * iFontSize / 72);
        
        g_wizData.hTitleFont = CreateFontIndirect(&lfTitleFont);

        if (!g_wizData.hTitleFont)
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("CreateFontIndirect(&lfTitleFont) failed (ec: %ld)"), 
                         GetLastError());
            goto Error;
        }

        ReleaseDC( NULL, hdc);
        hdc = NULL;
        
    }

    return TRUE;

Error:

    //
    // Cleanup properly before exiting
    //

    if (hdc)
    {
         ReleaseDC( NULL, hdc);
         hdc = NULL;
    }

    return FALSE; 
} // LoadWizardFont

BOOL 
SaveWizardData()
/*++

Routine Description:

    Save the wizard data to the system. 
    If there are more than one device, all enabled devices will have the same settings.

Arguments:

    pData - Points to the user memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    HKEY    hRegKey = 0;

    DEBUG_FUNCTION_NAME(TEXT("SaveConfigData()"));

    if(!g_hFaxSvcHandle)
    {
        Assert(FALSE);
        return FALSE;
    }

    //
    // save user info
    //
    if (g_bShowUserInfo) 
    { 
        if(!SaveUserInfo())
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SaveUserInfo failed"));
            return FALSE;
        }
    }

    //
    // save device info
    //
    if (g_bShowDevicePages)
    { 
        if(!SaveDeviceData())
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SaveDeviceData failed"));
            return FALSE;
        }
    }

    if (g_bShowDevicePages ||
        FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL))
    { 
        //
        // If the user has manage access and does not have a fax device
        // it's mean she refused to install it.
        // So, we should not disturb her
        // with implicit invocation of the Configuration Wizard.
        //
        if(!FaxSetConfigWizardUsed(g_hFaxSvcHandle, TRUE))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetConfigWizardUsed failed with %d"), GetLastError());
        }
    }

    return TRUE;
} // SaveWizardData

VOID 
FreeWizardData()
/*++

Routine Description:

    Free the wizard data and release the memory. 

Arguments:

    pData - Pointer to the receive data structure

Return Value:

    None.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FreeWizardData()"));

    if(g_wizData.hTitleFont)
    {
        DeleteObject(g_wizData.hTitleFont);
    }

    FreeUserInfo();

    FreeDeviceData();

    return;

} // FreeWizardData

BOOL
SetLastPage(
    INT pageId
)

/*++

Routine Description:

    Add one page to the link list to keep track of "go back" information

Arguments:

    pageId - Page id of the page to be added.

Return Value:

    TRUE if successful, FALSE for failure.

--*/

{
    PPAGE_INFO          pPageInfo;

    DEBUG_FUNCTION_NAME(TEXT("SetLastPage()"));

    pPageInfo = (PPAGE_INFO)MemAlloc(sizeof(PAGE_INFO));
    if(pPageInfo == NULL)
    {
        LPCTSTR faxDbgFunction = TEXT("SetLastPage()");
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed."));
        Assert(FALSE);
        return FALSE;
    }

    pPageInfo->pageId = pageId;

    //
    // add current page as the last page of the list
    //
    InsertTailList(&g_PageList, &pPageInfo->ListEntry);

    return TRUE;
}


BOOL
ClearPageList(
    VOID
    )
/*++

Routine Description:

    Clear the page list and release the allocated memory

Arguments:

    None.

Return Value:

    True if success, false if fails.

--*/

{
    PLIST_ENTRY         Last; // the last page information
    PPAGE_INFO          pPageInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("ClearPageList()"));

    while(!IsListEmpty(&g_PageList)) 
    {
        Last = g_PageList.Blink;

        pPageInfo = CONTAINING_RECORD( Last, PAGE_INFO, ListEntry );
        if(pPageInfo)
        {
            RemoveEntryList(&pPageInfo->ListEntry);
            MemFree(pPageInfo);
        }
    }

    return TRUE;
}


BOOL 
RemoveLastPage(
    HWND hwnd
)
/*++

Routine Description:

    Removes last page from the link list to keep track of "go back" information

Arguments:

    hwnd - window handle

Return Value:

    TRUE if successful, FALSE for failure.

--*/
{
    PPAGE_INFO   pPageInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("RemoveLastPage()"));

    Assert(hwnd);

    if(!g_PageList.Blink)
    {
        return FALSE;
    }

    pPageInfo = CONTAINING_RECORD( g_PageList.Blink, PAGE_INFO, ListEntry );
    if(!pPageInfo)
    {
        return FALSE;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pPageInfo->pageId);
    RemoveEntryList(&pPageInfo->ListEntry);
    MemFree(pPageInfo);

    return TRUE;
}


BOOL 
LoadDeviceData()
/*++

Routine Description:

    Load the fax devices information. 
    If there are more than one device, we load the data for the first available device.

Arguments:


Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DWORD  dwPorts = 0;
    BOOL   bRes = FALSE;
    DWORD  dw;
    DWORD  dwGroups;       // group number
    DWORD  dwGroupIndex;
    DWORD  dwSndDevIndex=0; // index of the last send    enabled device
    DWORD  dwRcvDevIndex=0; // index of the last receive enabled device
    DWORD  dwCurrentRM;
    LPBYTE pRoutingInfoBuffer;
    DWORD  dwRoutingInfoBufferSize = 0;

    PFAX_PORT_INFO_EX           pPortsInfo = NULL; // for FaxEnumPortsEx
    PFAX_OUTBOUND_ROUTING_GROUP pFaxRoutingGroup = NULL;


    DEBUG_FUNCTION_NAME(TEXT("LoadDeviceData()"));

    g_wizData.dwDeviceLimit = GetDeviceLimit();
    g_wizData.pdwSendDevOrder = NULL;
    g_wizData.szCsid = NULL;
    g_wizData.szTsid = NULL;
    g_wizData.dwDeviceCount = 0;
    g_wizData.pDevInfo = NULL;

    if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pPortsInfo, &dwPorts)) 
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxEnumPortsEx failed: error=%d."), GetLastError());
        goto exit;
    }

    if(!dwPorts)
    {
        Assert(dwPorts);
        DebugPrintEx(DEBUG_ERR, TEXT("No available ports."));
        goto exit; 
    }

    g_wizData.dwDeviceCount = dwPorts;

    g_wizData.pDevInfo = (PDEVICEINFO)MemAlloc(dwPorts * sizeof(DEVICEINFO));
    if(!g_wizData.pDevInfo)
    {
        Assert(FALSE);
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed."));
        goto exit;
    }
    ZeroMemory(g_wizData.pDevInfo, dwPorts * sizeof(DEVICEINFO));

    // 
    // pick up the first available device, if no one is available
    // choose the first device
    //
    for(dw = 0; dw < dwPorts; ++dw)
    {
        //
        // copy other device info for each device
        //
        g_wizData.pDevInfo[dw].bSend        = pPortsInfo[dw].bSend;
        g_wizData.pDevInfo[dw].ReceiveMode  = pPortsInfo[dw].ReceiveMode;
        g_wizData.pDevInfo[dw].dwDeviceId   = pPortsInfo[dw].dwDeviceID;
        g_wizData.pDevInfo[dw].szDeviceName = StringDup(pPortsInfo[dw].lpctstrDeviceName);
        if(!g_wizData.pDevInfo[dw].szDeviceName)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );
            goto exit;
        }

        if(pPortsInfo[dw].bSend)
        {
            dwSndDevIndex = dw;
        }

        if(FAX_DEVICE_RECEIVE_MODE_OFF != pPortsInfo[dw].ReceiveMode)
        {
            dwRcvDevIndex = dw;
        }
        g_wizData.pDevInfo[dw].bSelected = TRUE;
    }

    //
    // Copy TSID
    //
    g_wizData.szTsid = StringDup(pPortsInfo[dwSndDevIndex].lptstrTsid);
    if(!g_wizData.szTsid)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );
        goto exit;
    }

    //
    // Copy CSID and rings number
    //
    g_wizData.dwRingCount = pPortsInfo[dwRcvDevIndex].dwRings;
    g_wizData.szCsid = StringDup(pPortsInfo[dwRcvDevIndex].lptstrCsid);
    if(!g_wizData.szCsid)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );
        goto exit;
    }


    if (!IsDesktopSKU())
    {
        //
        // get device order
        //
        if(!FaxEnumOutboundGroups(g_hFaxSvcHandle, &pFaxRoutingGroup, &dwGroups))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxEnumOutboundGroups failed: error=%d."), GetLastError());
            Assert(FALSE);
            goto exit;
        }

        for(dwGroupIndex = 0; dwGroupIndex < dwGroups; dwGroupIndex++)
        {
            // search the <All Devices> group
            if(!lstrcmp(pFaxRoutingGroup[dwGroupIndex].lpctstrGroupName, ROUTING_GROUP_ALL_DEVICES))
            {
                // device number must be the same as port number
                Assert(dwPorts == pFaxRoutingGroup[dwGroupIndex].dwNumDevices);

                DebugPrintEx(DEBUG_MSG, TEXT("Total device number is %d."), pFaxRoutingGroup[dwGroupIndex].dwNumDevices);
                DebugPrintEx(DEBUG_MSG, TEXT("Group status is %d."), pFaxRoutingGroup[dwGroupIndex].Status);
            
                // collecting device Id
                g_wizData.pdwSendDevOrder = MemAlloc(pFaxRoutingGroup[dwGroupIndex].dwNumDevices * sizeof(DWORD));
                if(!g_wizData.pdwSendDevOrder)
                {
                    DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed."));
                    goto exit;
                }

                memcpy(g_wizData.pdwSendDevOrder, 
                       pFaxRoutingGroup[dwGroupIndex].lpdwDevices, 
                       pFaxRoutingGroup[dwGroupIndex].dwNumDevices * sizeof(DWORD));

                break;
            }
        }

        if(!g_wizData.pdwSendDevOrder)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("No device order information."));
            goto exit;
        }
    }
    //
    // load routing methods
    // the size of each routing methods should not be larger than INFO_SIZE
    // fortunately, it is gurranteed by other fax programs
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; ++dwCurrentRM) 
    {
        LPTSTR lpCurSel; 

        // 
        // Check the validity first in the loop, 
        // then save the routing info
        //
        lpCurSel = g_wizData.pRouteInfo[dwCurrentRM].tszCurSel;

        g_wizData.pRouteInfo[dwCurrentRM].bEnabled = FaxDeviceEnableRoutingMethod( 
                                            g_hFaxSvcHandle, 
                                            g_wizData.pDevInfo[dwRcvDevIndex].dwDeviceId, 
                                            g_RoutingGuids[dwCurrentRM], 
                                            QUERY_STATUS );

        if(FaxGetExtensionData( g_hFaxSvcHandle, 
                                g_wizData.pDevInfo[dwRcvDevIndex].dwDeviceId, 
                                g_RoutingGuids[dwCurrentRM], 
                                &pRoutingInfoBuffer, 
                                &dwRoutingInfoBufferSize))
        {
            // only copy the first MAX_PATH - 1 characters
            CopyMemory((LPBYTE)lpCurSel, 
                       pRoutingInfoBuffer, 
                       dwRoutingInfoBufferSize < MAX_PATH * sizeof(TCHAR) ? 
                       dwRoutingInfoBufferSize : (MAX_PATH - 1) * sizeof(TCHAR));

            FaxFreeBuffer(pRoutingInfoBuffer);
        }
    }

    bRes = TRUE;

exit:
    //
    // Clean up
    //
    if(pPortsInfo) 
    { 
        FaxFreeBuffer(pPortsInfo); 
    }
    if(pFaxRoutingGroup) 
    { 
        FaxFreeBuffer(pFaxRoutingGroup); 
    }

    if(!bRes)
    {
        FreeDeviceData();
    }

    return bRes;

} // LoadDeviceData

BOOL
SaveSingleDeviceData (
    PDEVICEINFO pDeviceInfo
)
{
    BOOL                bRes = TRUE;
    DWORD               dwCurrentRM;
    PFAX_PORT_INFO_EX   pPortInfo = NULL; // stores device info

    DEBUG_FUNCTION_NAME(TEXT("SaveSingleDeviceData"));

    if(FaxGetPortEx(g_hFaxSvcHandle, pDeviceInfo->dwDeviceId, &pPortInfo))
    {
        //
        // Save the data to all devices and enable/disable FPF_RECEIVE depending on the data
        // 
        pPortInfo->bSend         = pDeviceInfo->bSend;
        pPortInfo->ReceiveMode   = pDeviceInfo->ReceiveMode;
        pPortInfo->lptstrCsid    = g_wizData.szCsid;
        pPortInfo->lptstrTsid    = g_wizData.szTsid;
        pPortInfo->dwRings       = g_wizData.dwRingCount;            

        if(!FaxSetPortEx(g_hFaxSvcHandle, pDeviceInfo->dwDeviceId, pPortInfo))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetPortEx() failed with %d."), GetLastError());
            bRes = FALSE;
        }

        FaxFreeBuffer(pPortInfo);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxGetPortEx() failed with %d."), GetLastError());
        bRes = FALSE;
    }
    //
    // Save routing methods
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        LPTSTR   lpCurSel; 
        LPCWSTR  lpcwstrPrinterPath;
        BOOL     bEnabled; 
        // 
        // Check the validity first in the loop, 
        // then save the routing info
        //
        lpCurSel = g_wizData.pRouteInfo[dwCurrentRM].tszCurSel;
        bEnabled = g_wizData.pRouteInfo[dwCurrentRM].bEnabled;

        if ((RM_PRINT == dwCurrentRM) && bEnabled)
        {
            //
            // Attempt to convert printer display name to printer path before we pass it on to the server
            //
            lpcwstrPrinterPath = FindPrinterPathFromName (g_pPrinterNames, g_dwNumPrinters, lpCurSel);
            if (lpcwstrPrinterPath)
            {
                //
                // We have a matching path - replace name with path.
                //
                lstrcpyn (lpCurSel, lpcwstrPrinterPath, MAX_PATH);
            }
        }
        if(!FaxSetExtensionData(g_hFaxSvcHandle, 
                                pDeviceInfo->dwDeviceId, 
                                g_RoutingGuids[dwCurrentRM], 
                                (LPBYTE)lpCurSel, 
                                MAX_PATH * sizeof(TCHAR)) )
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetExtensionData() failed with %d."), GetLastError());
            bRes = FALSE;
        }

        if(!FaxDeviceEnableRoutingMethod(g_hFaxSvcHandle, 
                                         pDeviceInfo->dwDeviceId, 
                                         g_RoutingGuids[dwCurrentRM], 
                                         bEnabled ? STATUS_ENABLE : STATUS_DISABLE ) )
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxDeviceEnableRoutingMethod() failed with %d."), GetLastError());
            bRes = FALSE;
        }
    }
    return bRes;
}   // SaveSingleDeviceData

BOOL 
SaveDeviceData()
/*++

Routine Description:

    Save the fax devices configuration. 
    If there are more than one device, all enabled devices will be set 
    to current settings, except whether they are enabled to send/receive faxes.

Arguments:

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{

    DWORD  dw;
    BOOL   bRes = TRUE;

    FAX_OUTBOUND_ROUTING_GROUP  outRoutGr = {0};

    DEBUG_FUNCTION_NAME(TEXT("SaveDeviceData"));

    //
    // 1st iteration - save disabled devices only
    //
    for(dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if (g_wizData.pDevInfo[dw].bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode))
        {
            //
            // Device is active - skip it now
            //
            continue;
        }
        if (!SaveSingleDeviceData(&(g_wizData.pDevInfo[dw])))
        {
            bRes = FALSE;
        }
    }
    //
    // 2nd iteration - save enabled devices only
    //
    for(dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if (!g_wizData.pDevInfo[dw].bSend && (FAX_DEVICE_RECEIVE_MODE_OFF == g_wizData.pDevInfo[dw].ReceiveMode))
        {
            //
            // Device is inactive - skip it
            //
            continue;
        }
        if (!SaveSingleDeviceData(&(g_wizData.pDevInfo[dw])))
        {
            bRes = FALSE;
        }
    }
    if (!IsDesktopSKU ())
    {
        //
        // Set device order for send
        //
        outRoutGr.dwSizeOfStruct   = sizeof(outRoutGr);
        outRoutGr.lpctstrGroupName = ROUTING_GROUP_ALL_DEVICES;
        outRoutGr.dwNumDevices     = g_wizData.dwDeviceCount;
        outRoutGr.lpdwDevices      = g_wizData.pdwSendDevOrder;
        outRoutGr.Status           = FAX_GROUP_STATUS_ALL_DEV_VALID;

        if(!FaxSetOutboundGroup(g_hFaxSvcHandle, &outRoutGr))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxSetOutboundGroup() failed with %d."), GetLastError());
            bRes = FALSE;
        }
    }
    return bRes;
} // SaveDeviceData

void 
FreeDeviceData()
/*++

Routine Description:

    Free the devices data and release the memory. 

Arguments:

Return Value:

    none

--*/
{
    DWORD dw;

    DEBUG_FUNCTION_NAME(TEXT("FreeDeviceData()"));

    MemFree(g_wizData.szCsid);
    g_wizData.szCsid = NULL;
    MemFree(g_wizData.szTsid);
    g_wizData.szTsid = NULL;
    MemFree(g_wizData.pdwSendDevOrder);
    g_wizData.pdwSendDevOrder = NULL;

    if (g_wizData.pDevInfo)
    {
        for(dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
        {
            MemFree(g_wizData.pDevInfo[dw].szDeviceName);
            g_wizData.pDevInfo[dw].szDeviceName = NULL;
        }

        MemFree(g_wizData.pDevInfo);
        g_wizData.pDevInfo = NULL;
    }
} // FreeDeviceData





///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  ConvertCpeFilesToCov
//
//  Purpose:        Convert all of the *.CPE files from CSIDL_COMMON_APPDATA\Microsoft\Windows NT\MSFax\Common Coverpages
//                  directory to COV files at CSIDL_PERSONAL\Fax\Personal Coverpages.
//                  Mark that the conversion took place in the registry under HKCU so it will happen exactly once per user.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//    
///////////////////////////////////////////////////////////////////////////////////////
DWORD ConvertCpeFilesToCov()
{
    DWORD           dwErr                           = ERROR_SUCCESS;
    INT             iErr                            = 0;
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFind                           = INVALID_HANDLE_VALUE;
    TCHAR           szServerCpDir[2*MAX_PATH]       = {0};
    TCHAR           szSearch[MAX_PATH]              = {0};
    HKEY            hRegKey                         = NULL;
    DWORD           dwConverted                     = 0;

    DEBUG_FUNCTION_NAME(_T("ConvertCpeFilesToCov"));
    //
    // Check whether this is the first time the current user call to this function
    //
    hRegKey = OpenRegistryKey(
        HKEY_CURRENT_USER,
        REGKEY_FAX_SETUP,
        TRUE,
        KEY_ALL_ACCESS);
    if(hRegKey)
    {
        dwConverted = GetRegistryDword(hRegKey, REGVAL_CPE_CONVERT);
        if (0 == dwConverted)
        {
            SetRegistryDword(hRegKey, REGVAL_CPE_CONVERT, TRUE);
        }
        RegCloseKey(hRegKey);
    }
        
    if (dwConverted) // We don't have to convert the cpe files, we did already
        return ERROR_SUCCESS;
    
    //
    // the CPE files are in the server cover page directory
    //
    if ( !GetServerCpDir(NULL,szServerCpDir,ARR_SIZE(szServerCpDir)) )
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,_T("GetServerCpDir failed (ec=%d)"),dwErr);
        return dwErr;
    }
    
    //
    // first we're going to convert the CPEs to COV.
    // this is done by running FXSCOVER.EXE /CONVERT <CPE filename>
    //
    _sntprintf(szSearch, ARR_SIZE(szSearch)-1, _T("%s\\*.cpe"), szServerCpDir);
    hFind = FindFirstFile(szSearch, &FindFileData);
    if (hFind==INVALID_HANDLE_VALUE)
    {
        DebugPrintEx(DEBUG_MSG,_T("No CPEs exist in %s, exit function"),szServerCpDir);
        return NO_ERROR;
    }
    //
    //  Go for each Cover Page 
    //
    do
    {
        //
        //  FindFileData.cFileName
        //
        TCHAR szCmdLineParams[MAX_PATH*2] = {0};
        SHELLEXECUTEINFO sei = {0};
        _sntprintf(szCmdLineParams,ARR_SIZE(szCmdLineParams),_T("/CONVERT \"%s\\%s\""),szServerCpDir,FindFileData.cFileName);
        sei.cbSize = sizeof (SHELLEXECUTEINFO);
        sei.fMask = SEE_MASK_NOCLOSEPROCESS;

        sei.lpVerb = TEXT("open");
        sei.lpFile = FAX_COVER_IMAGE_NAME;
        sei.lpParameters = szCmdLineParams;
        sei.lpDirectory  = TEXT(".");
        sei.nShow  = SW_HIDE;

        //
        // Execute FXSCOVER.EXE and wait for it to end
        //
        if(!ShellExecuteEx(&sei))
        {
            dwErr = GetLastError();
            DebugPrintEx(DEBUG_ERR, TEXT("ShellExecuteEx failed %d"), dwErr);
            break; // don't try to continue with other files
        }
    
        dwErr = WaitForSingleObject(sei.hProcess, TIME_TO_WAIT_FOR_CONVERSTION);
        CloseHandle(sei.hProcess);
        if (WAIT_OBJECT_0 == dwErr)
        {
            //
            // Shell execute completed successfully
            //
            dwErr = ERROR_SUCCESS;
            continue;
        }
        else
        {
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForSingleObject failed with %d"), dwErr);
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForSingleObject failed GetLastError=%d"), GetLastError());
            break; // don't try to continue with other files
        }

    } while(FindNextFile(hFind, &FindFileData));

    DebugPrintEx(DEBUG_MSG, _T("last call to FindNextFile() returns %ld."), GetLastError());

    //
    //  Close Handle
    //
    FindClose(hFind);       
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\faxcfgwz.h ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    faxcfgwz.h

Abstract:

    Fax configuration wizard header file

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#ifndef _FAX_CONFIG_WIZARD_H_
#define _FAX_CONFIG_WIZARD_H_

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <windowsx.h>

#include <shlobj.h>
#include <shlobjp.h>
#include <shellapi.h>

#include <winspool.h>
#include <commdlg.h>
#include "tchar.h"

#include <faxutil.h>
#include <fxsapip.h>
#include <faxreg.h>
#include <faxroute.h>
#include <faxuiconstants.h>
#include <htmlhelp.h>

//
// our header files
//
#include "resource.h"
#include "FaxCfgWzExp.h"

#define MAX_STRING_LEN      MAX_PATH
#define MAX_MESSAGE_LEN     512

#define MAX_ARCHIVE_DIR     MAX_PATH - 16
#define MAX_DEVICE_NAME     MAX_PATH

#define DI_Modem            0

enum _ROUT_METHODS
{
	RM_FOLDER=0,
	RM_PRINT,
	RM_COUNT	// number of routing methods
};

extern HINSTANCE   g_hModule;      // DLL instance handle
extern HINSTANCE   g_hResource;    // Resource DLL instance handle

extern HANDLE           g_hFaxSvcHandle;    // fax handle for send configuration
extern LIST_ENTRY       g_PageList;         // to keep track of the previous page.
extern BOOL				g_bShowDevicePages;
extern BOOL				g_bShowUserInfo; 
extern const LPCTSTR    g_RoutingGuids[RM_COUNT];


typedef BOOL (*PINSTNEWDEV)(HWND, LPGUID, PDWORD);

#define NEW_DEV_DLL         TEXT("hdwwiz.cpl")

// used by GetProcAddress should be ANSI
#define INSTALL_NEW_DEVICE  "InstallNewDevice"


typedef struct _PAGE_INFO 
{
    LIST_ENTRY  ListEntry;
    INT         pageId;
} PAGE_INFO, *PPAGE_INFO;

typedef struct _DEVICEINFO
{
    DWORD                           dwDeviceId;     // Unique device ID for fax device
    LPTSTR                          szDeviceName;   // Name of specific device
    BOOL                            bSend;          // Send enabled
    FAX_ENUM_DEVICE_RECEIVE_MODE    ReceiveMode;    // Receive mode
    BOOL                            bSelected;      // The device is selected for fax operations
} DEVICEINFO, *PDEVICEINFO;

typedef struct _ROUTINFO
{
	BOOL   bEnabled;
	TCHAR  tszCurSel[MAX_PATH];

} ROUTINFO;

typedef struct _WIZARDDATA
{
    HFONT       hTitleFont;             // The title font for the Welcome and Completion pages
    HWND        hWndParent;             // the window handle of the caller function
    BOOL        bFinishPressed;         // whether the user clicks the finish button
    DWORD       dwDeviceLimit;          // maximum number of the fax devices for the current SKU
    
    LPTSTR      szTsid;                 // Transmit station Id
    LPTSTR      szCsid;                 // Caller station Id 
    DWORD       dwRingCount;            // number of rings allow before answering the call
    DWORD       dwDeviceCount;          // number of available devices 
    LPDWORD     pdwSendDevOrder;        // device order for sending faxes
    ROUTINFO    pRouteInfo[RM_COUNT];   // routing info
    PDEVICEINFO pDevInfo;               // pointer to structure of DEVICEINFO, 

    FAX_PERSONAL_PROFILE userInfo;      // user information

} WIZARDDATA, *PWIZARDDATA;

extern WIZARDDATA  g_wizData;

// RunDll32 entry point in dll.c
void CALLBACK FaxCfgWzrdDllW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);

// Functions in FaxCfgWz.c
BOOL LoadWizardData();
BOOL SaveWizardData();
VOID FreeWizardData();

BOOL LoadWizardFont();

BOOL SetLastPage(INT pageId);
BOOL ClearPageList(VOID);
BOOL RemoveLastPage(HWND hwnd);

// Functions in userinfo.c
INT_PTR CALLBACK AddressDetailDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UserInfoDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL LoadUserInfo();
BOOL SaveUserInfo();
VOID FreeUserInfo();

// Functions in welcome.c
INT_PTR CALLBACK WelcomeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in devlimit.c
INT_PTR CALLBACK DevLimitDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in onedevlimit.c
INT_PTR CALLBACK OneDevLimitDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in sendwzrd.c
INT_PTR CALLBACK SendDeviceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SendTsidDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in recvwzrd.c
INT_PTR CALLBACK RecvDeviceDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RecvCsidDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in route.c
INT_PTR CALLBACK RecvRouteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in complete.c
INT_PTR CALLBACK CompleteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Functions in util.c
VOID LimitTextFields(HWND hDlg, INT *pLimitInfo);
INT DisplayMessageDialog(HWND hwndParent, UINT type, INT titleStrId, INT formatStrId,...);
BOOL BrowseForDirectory(HWND hDlg, INT hResource, LPTSTR title);
BOOL Connect(VOID);
VOID DisConnect(VOID);
VOID InstallModem(HWND hWnd);
BOOL StartFaxService(LPTSTR pServerName);
BOOL IsFaxDeviceInstalled(HWND hWnd, LPBOOL);
BOOL IsUserInfoConfigured();
BOOL FaxDeviceEnableRoutingMethod(HANDLE hFaxHandle, DWORD dwDeviceId, LPCTSTR RoutingGuid, LONG Enabled);
VOID ListView_SetDeviceImageList(HWND hwndLv, HINSTANCE hinst);
BOOL IsSendEnable();
BOOL IsReceiveEnable();
int  GetDevIndexByDevId(DWORD dwDeviceId);
VOID  InitDeviceList(HWND hDlg, DWORD dwListViewResId);



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\route.c ===
#include "faxcfgwz.h"
#include <shlwapi.h>


PPRINTER_NAMES      g_pPrinterNames = NULL;
DWORD               g_dwNumPrinters = 0;

BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    )

/*++

Routine Description:

    Check the existancy of given folder name

Arguments:

    pDirectoryName - point to folder name

Return Value:

    if the folder exists, return TRUE; else, return FALSE.

--*/

{
    DWORD   dwFileAttributes;

    if(!pDirectoryName || lstrlen(pDirectoryName) == 0)
    {
        return FALSE;
    }

    dwFileAttributes = GetFileAttributes(pDirectoryName);

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
    {
        return TRUE;
    }
    return FALSE;
}


VOID
DoInitRouteOptions(
    HWND    hDlg
)

/*++

Routine Description:

    Initializes the "Route" page with information from system

Arguments:

    hDlg - Handle to the "Route" page

Return Value:

    NONE

--*/

{
    HWND                hControl;
    DWORD               CurrentRM;

    DEBUG_FUNCTION_NAME(TEXT("DoInitRouteOptions()"));

    hControl = GetDlgItem( hDlg, IDC_RECV_PRINT_TO );

    SetLTRComboBox(hDlg, IDC_RECV_PRINT_TO);

    //
    // Initialize the list of destination printers
    //
    if (g_pPrinterNames)
    {
        ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
        g_pPrinterNames = NULL;
    }
    g_pPrinterNames = CollectPrinterNames (&g_dwNumPrinters, TRUE);
    if (!g_pPrinterNames)
    {
        if (ERROR_PRINTER_NOT_FOUND == GetLastError ())
        {
            //
            // No printers
            //
        }
        else
        {
            //
            // Real error
            //
        }
        SendMessage(hControl, CB_SETCURSEL, -1, 0);
        SetWindowText(hControl, g_wizData.pRouteInfo[RM_PRINT].tszCurSel);
    }
    else
    {
        //
        // Success - fill in the combo-box
        //
        DWORD dw;
        LPCWSTR lpcwstrMatchingText;

        for (dw = 0; dw < g_dwNumPrinters; dw++)
        {
            SendMessage(hControl, CB_ADDSTRING, 0, (LPARAM) g_pPrinterNames[dw].lpcwstrDisplayName);
        }
        //
        // Now find out if we match the data the server has
        //
        if (lstrlen(g_wizData.pRouteInfo[RM_PRINT].tszCurSel))
        {
            //
            // Server has some name for printer
            //
            lpcwstrMatchingText = FindPrinterNameFromPath (g_pPrinterNames, g_dwNumPrinters, g_wizData.pRouteInfo[RM_PRINT].tszCurSel);
            if (!lpcwstrMatchingText)
            {
                //
                // No match, just fill in the text we got from the server
                //
                SendMessage(hControl, CB_SETCURSEL, -1, 0);
                SetWindowText(hControl, g_wizData.pRouteInfo[RM_PRINT].tszCurSel);
            }
            else
            {
                SendMessage(hControl, CB_SELECTSTRING, -1, (LPARAM) lpcwstrMatchingText);
            }
        }
        else
        {
            //
            // No server configuation - display no selection
            //
        }
    }        
    // 
    // Display routing methods info in the dialog.
    //
    for (CurrentRM = 0; CurrentRM < RM_COUNT; CurrentRM++) 
    {
        BOOL   bEnabled;
        LPTSTR tszCurSel;

        // 
        // if we don't have this kind of method, go to the next one
        //
        tszCurSel = g_wizData.pRouteInfo[CurrentRM].tszCurSel;
        bEnabled  = g_wizData.pRouteInfo[CurrentRM].bEnabled;

        switch (CurrentRM) 
        {
        case RM_FOLDER:

            CheckDlgButton( hDlg, IDC_RECV_SAVE, bEnabled ? BST_CHECKED : BST_UNCHECKED );
            EnableWindow( GetDlgItem( hDlg, IDC_RECV_DEST_FOLDER ), bEnabled );
            EnableWindow( GetDlgItem( hDlg, IDC_RECV_BROWSE_DIR ), bEnabled );
            if (*tszCurSel) 
            {
                SetDlgItemText( hDlg, IDC_RECV_DEST_FOLDER, tszCurSel );
            }

            break;

        case RM_PRINT:
            CheckDlgButton( hDlg, IDC_RECV_PRINT, bEnabled ? BST_CHECKED : BST_UNCHECKED );                
            EnableWindow(GetDlgItem(hDlg, IDC_RECV_PRINT_TO), bEnabled);
            break;
        }
    }
}

BOOL
DoSaveRouteOptions(
    HWND    hDlg
)
/*++

Routine Description:

    Save the information on the "Route" page to system

Arguments:

    hDlg - Handle to the "Route" page

Return Value:

    TRUE if success, else FALSE

--*/
{
    HWND                hControl;
    DWORD               i;
    ROUTINFO            SetInfo[RM_COUNT] = {0};
    LPTSTR              lpCurSel; 
    BOOL*               pbEnabled; 

    DEBUG_FUNCTION_NAME(TEXT("DoSaveRouteOptions()"));

    // 
    // Check the validity first in the loop, 
    // then save the routing info
    //
    for (i = 0; i < RM_COUNT; i++) 
    {
        lpCurSel = SetInfo[i].tszCurSel;
        Assert(lpCurSel);
        pbEnabled =  &(SetInfo[i].bEnabled);
        Assert(pbEnabled);
        *pbEnabled = 0;

        switch (i) 
        {
            case RM_PRINT:

                *pbEnabled = (IsDlgButtonChecked( hDlg, IDC_RECV_PRINT ) == BST_CHECKED);
                if(FALSE == *pbEnabled)
                {
                    break;
                }
                hControl = GetDlgItem(hDlg, IDC_RECV_PRINT_TO);
                lpCurSel[0] = TEXT('\0');
                //
                // Just read-in the selected printer display name
                //
                GetDlgItemText (hDlg, IDC_RECV_PRINT_TO, lpCurSel, MAX_PATH);
                //
                // we will check the validity only when this routing method is enabled
                // but we will save the select change anyway.
                //
                if (*pbEnabled) 
                {
                    if (lpCurSel[0] == 0) 
                    {
                        DisplayMessageDialog( hDlg, 0, 0, IDS_ERR_SELECT_PRINTER );
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        goto error;
                    }
                }
                break;

            case RM_FOLDER:
                {
                    BOOL    bValid = TRUE;
                    HCURSOR hOldCursor;

                    hControl = GetDlgItem(hDlg, IDC_RECV_DEST_FOLDER);

                    *pbEnabled = (IsDlgButtonChecked( hDlg, IDC_RECV_SAVE ) == BST_CHECKED);
                    if(!*pbEnabled)
                    {
                        break;
                    }

                    GetWindowText( hControl, lpCurSel, MAX_PATH - 1 );

                    //
                    // Validate the directory
                    //
                    hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));

                    if(!FaxCheckValidFaxFolder(g_hFaxSvcHandle, lpCurSel))
                    {
                        DWORD dwRes = GetLastError();
                        DebugPrintEx(DEBUG_ERR, TEXT("FaxCheckValidFaxFolder failed (ec: %ld)"), dwRes);

                        //
                        // Try to adjust folder
                        // 
                        dwRes = AskUserAndAdjustFaxFolder(hDlg, NULL, lpCurSel, dwRes);
                        if(ERROR_SUCCESS != dwRes) 
                        {
                            bValid = FALSE;

                            if(ERROR_BAD_PATHNAME != dwRes)
                            {
                                //
                                // The error message has not been shown by AskUserAndAdjustFaxFolder
                                //
                                DisplayMessageDialog( hDlg, 0, 0, IDS_ERR_ARCHIVE_DIR );                            
                            }
                        }
                    }

                    SetCursor (hOldCursor);
                    if(!bValid)
                    {
                        // go to the "Browse" button
                        hControl = GetDlgItem(hDlg, IDC_RECV_BROWSE_DIR);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        goto error;
                    }
                }
        }

    }
    // 
    // now save the device and routing info into shared data.
    //
    CopyMemory((LPVOID)(g_wizData.pRouteInfo), (LPVOID)SetInfo, RM_COUNT * sizeof(ROUTINFO));

    return TRUE;

error:
    return FALSE;
}


INT_PTR 
CALLBACK 
RecvRouteDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Route" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

#define EnableRouteWindow( id, idResource ) \
    EnableWindow( GetDlgItem(hDlg, idResource), IsDlgButtonChecked(hDlg, id) )

{

    switch (uMsg)
    {
        case WM_INITDIALOG :
            { 
                //
                // Maximum length for various text fields in the dialog
                //
                static INT textLimits[] = 
                {
                    IDC_RECV_DEST_FOLDER,  MAX_PATH,
                    0,
                };
                LimitTextFields(hDlg, textLimits);
                DoInitRouteOptions(hDlg); 

                SetLTREditDirection(hDlg, IDC_RECV_DEST_FOLDER);
                SHAutoComplete (GetDlgItem(hDlg, IDC_RECV_DEST_FOLDER), SHACF_FILESYSTEM);
                return TRUE;
            }

        case WM_COMMAND:

            switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
            {
                case BN_CLICKED:

                    switch(GET_WM_COMMAND_ID(wParam, lParam)) 
                    {
                        case IDC_RECV_PRINT:
                            EnableRouteWindow(IDC_RECV_PRINT, IDC_RECV_PRINT_TO);
                            break;

                        case IDC_RECV_SAVE:
                            EnableRouteWindow(IDC_RECV_SAVE, IDC_RECV_DEST_FOLDER);
                            EnableRouteWindow(IDC_RECV_SAVE, IDC_RECV_BROWSE_DIR);
                            break;

                        case IDC_RECV_BROWSE_DIR:
                        {
                            TCHAR szTitle[MAX_PATH] = {0};

                            if( !LoadString( g_hResource, IDS_RECV_BROWSE_DIR, szTitle, MAX_PATH ) )
                            {
                                DEBUG_FUNCTION_NAME(TEXT("RecvRouteDlgProc()"));
                                DebugPrintEx(DEBUG_ERR, 
                                             TEXT("LoadString failed: string ID=%d, error=%d"), 
                                             IDS_RECV_BROWSE_DIR,
                                             GetLastError());
                            }

                            if( !BrowseForDirectory(hDlg, IDC_RECV_DEST_FOLDER, szTitle) )
                            {
                                return FALSE;
                            }

                            break;
                        }
                    }

                    break;

                default:
                    break;
            }

            break;

        case WM_NOTIFY :
            {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
                {
                case PSN_SETACTIVE : //Enable the Back and Finish button    

                    //
                    // Check the "Next" button status
                    //
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;

                case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }
                
                    break;

                }

                case PSN_WIZNEXT :
                    //Handle a Next button click, if necessary

                    if(!DoSaveRouteOptions(hDlg))
                    {
                        //
                        // not finished with route configuration
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    SetLastPage(IDD_WIZARD_RECV_ROUTE);
                    break;

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                default :
                    break;
                }
            }
            break;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\onedevlimit.c ===
#include "faxcfgwz.h"


DWORD 
GetSelectedDevIndex(
    HWND    hDlg
)
/*++

Routine Description:

    Get selected device index in WIZARDDATA.pDevInfo array

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    Device index in WIZARDDATA.pDevInfo array

--*/
{
    DWORD dwIndex = 0;
    DWORD dwDeviceId = 0;
    DWORD dwDevIndex = 0;
    HWND  hComboModem = NULL;

    DEBUG_FUNCTION_NAME(TEXT("GetSelectedDevIndex()"));

    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        DebugPrintEx(DEBUG_ERR, TEXT("GetDlgItem(hDlg, IDC_COMBO_MODEM) failed, ec = %d."), GetLastError());
        return dwDevIndex;
    }

    dwIndex = (DWORD)SendMessage(hComboModem, CB_GETCURSEL,0,0);
    if(CB_ERR == dwIndex)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SendMessage(hComboModem, CB_GETCURSEL,0,0) failed."));
        return dwDevIndex;
    }

    dwDevIndex = (DWORD)SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0);
    if(CB_ERR == dwDevIndex)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0) failed."));
        return dwDevIndex;
    }

    return dwDevIndex;
}


void
OnReceiveEnable(
    HWND    hDlg
)
/*++

Routine Description:

    Handle "Receive Enable" check button

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/
{
    BOOL bRcvEnable;
    BOOL bAutoAnswer;

    DEBUG_FUNCTION_NAME(TEXT("OnReceiveEnable()"));

    bRcvEnable = IsDlgButtonChecked(hDlg, IDC_RECEIVE_ENABLE) == BST_CHECKED;

    if(bRcvEnable &&
       IsDlgButtonChecked(hDlg, IDC_MANUAL_ANSWER) != BST_CHECKED &&
       IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER)   != BST_CHECKED)
    {
        //
        // Auto answer is the default
        //
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER, BST_CHECKED);
    }

    if (bRcvEnable)
    {
        //
        // Let's see if the device is virtual
        //
        DWORD dwDevIndex = GetSelectedDevIndex(hDlg);
        DWORD dwRes;
        BOOL  bVirtual = FALSE;
        
        dwRes = IsDeviceVirtual (g_hFaxSvcHandle, g_wizData.pDevInfo[dwDevIndex].dwDeviceId, &bVirtual);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Assume device is virtual
            //
            bVirtual = TRUE;
        }
        if (bVirtual)
        {
            //
            // A virtual device is set to receive.
            // Enable ONLY auto-answer and set rings to 1.
            //
            EnableWindow (GetDlgItem(hDlg, IDC_MANUAL_ANSWER),  FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_AUTO_ANSWER),    TRUE);
            EnableWindow(GetDlgItem(hDlg, IDCSTATIC_RINGS),     TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT),      FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), FALSE);
            SetDlgItemInt(hDlg, IDC_RING_COUNT, 1,  FALSE);
            return;
        }
    }
    bAutoAnswer = IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER) == BST_CHECKED;

    EnableWindow(GetDlgItem(hDlg, IDC_MANUAL_ANSWER),  bRcvEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_AUTO_ANSWER),    bRcvEnable);
    EnableWindow(GetDlgItem(hDlg, IDCSTATIC_RINGS),    bRcvEnable);

    EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT),      bRcvEnable && bAutoAnswer);
    EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), bRcvEnable && bAutoAnswer);
}   // OnReceiveEnable

void
OnDevSelectChanged(
    HWND    hDlg
)
/*++

Routine Description:

    Handle device selection change

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/

{
    DWORD dwDevIndex;

    DEBUG_FUNCTION_NAME(TEXT("OnDevSelectChanged()"));

    dwDevIndex = GetSelectedDevIndex(hDlg);

    CheckDlgButton(hDlg, IDC_SEND_ENABLE,    g_wizData.pDevInfo[dwDevIndex].bSend ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, 
                   IDC_RECEIVE_ENABLE, 
                   (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dwDevIndex].ReceiveMode) ? BST_CHECKED : BST_UNCHECKED);

    if(FAX_DEVICE_RECEIVE_MODE_MANUAL == g_wizData.pDevInfo[dwDevIndex].ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_MANUAL_ANSWER, BST_CHECKED);
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER,   BST_UNCHECKED);
    }
    else if(FAX_DEVICE_RECEIVE_MODE_AUTO == g_wizData.pDevInfo[dwDevIndex].ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_MANUAL_ANSWER,  BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER,    BST_CHECKED);
    }
    else 
    {
        //
        // No answer mode
        //
        CheckDlgButton(hDlg, IDC_MANUAL_ANSWER,  BST_UNCHECKED);
        CheckDlgButton(hDlg, IDC_AUTO_ANSWER,    BST_UNCHECKED);
    }

    OnReceiveEnable(hDlg);
}


VOID
DoInitOneDevLimitDlg(
    HWND    hDlg
)
/*++

Routine Description:

    Init the "One device limit" page

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/

{
    DWORD dw;
    DWORD dwItem;
    DWORD dwSelectedItem=0;
    HWND  hComboModem;

    DEBUG_FUNCTION_NAME(TEXT("DoInitOneDevLimitDlg()"));

    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        return;
    }

    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        dwItem = (DWORD)SendMessage(hComboModem, CB_ADDSTRING, 0, (LPARAM)(g_wizData.pDevInfo[dw].szDeviceName));
        if(CB_ERR != dwItem && CB_ERRSPACE != dwItem)
        {
            SendMessage(hComboModem, CB_SETITEMDATA, dwItem, dw);

            if(g_wizData.pDevInfo[dw].bSend    ||
               (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode))
            {
                dwSelectedItem = dwItem;                
            }
        }
        else
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SendMessage(hComboModem, CB_ADDSTRING) failed."));
        }
    }

    SendDlgItemMessage(hDlg, 
                       IDC_SPIN_RING_COUNT, 
                       UDM_SETRANGE32, 
                       (WPARAM)FXS_RINGS_LOWER, 
                       (LPARAM)FXS_RINGS_UPPER);

    SendDlgItemMessage(hDlg, IDC_RING_COUNT, EM_SETLIMITTEXT, FXS_RINGS_LENGTH, 0);

    if(!SetDlgItemInt(hDlg, IDC_RING_COUNT, g_wizData.dwRingCount, FALSE))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SetDlgItemInt(IDC_RING_COUNT) failed with %d."), GetLastError());
    }

    SendMessage(hComboModem, CB_SETCURSEL, dwSelectedItem, 0);
    OnDevSelectChanged(hDlg);
}

void
DoSaveOneDevLimit(
    HWND    hDlg
)
/*++

Routine Description:

    Save the user's choice for devices

Arguments:

    hDlg - Handle to the "One device limit" page

Return Value:

    None

--*/

{
    DWORD dw;
    BOOL  bRes;
    DWORD dwRes;
    DWORD dwDevIndex;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveOneDevLimit()"));

    dwDevIndex = GetSelectedDevIndex(hDlg);

    //
    // disable all devices
    //
    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        g_wizData.pDevInfo[dw].bSend     = FALSE;
        g_wizData.pDevInfo[dw].ReceiveMode  = FAX_DEVICE_RECEIVE_MODE_OFF;
        g_wizData.pDevInfo[dw].bSelected = FALSE;
    }

    //
    // save "Send enable"
    //
    if(IsDlgButtonChecked(hDlg, IDC_SEND_ENABLE) == BST_CHECKED)
    {
        g_wizData.pDevInfo[dwDevIndex].bSend = TRUE;
    }

    //
    // save receive options
    //
    if(IsDlgButtonChecked(hDlg, IDC_RECEIVE_ENABLE) != BST_CHECKED)
    {
        return;
    }

    if(IsDlgButtonChecked(hDlg, IDC_MANUAL_ANSWER) == BST_CHECKED)
    {
        g_wizData.pDevInfo[dwDevIndex].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
        return;
    }

    //
    // auto answer
    //
    g_wizData.pDevInfo[dwDevIndex].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
    //
    // get ring count
    //
    dwRes = GetDlgItemInt(hDlg, IDC_RING_COUNT, &bRes, FALSE);
    if(!bRes)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetDlgItemInt(IDC_RING_COUNT) failed with %d."), GetLastError());
    }
    else
    {
        g_wizData.dwRingCount = dwRes;
    }
}


INT_PTR 
CALLBACK 
OneDevLimitDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "One device limit" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            DoInitOneDevLimitDlg(hDlg);
            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_COMBO_MODEM:

                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    OnDevSelectChanged(hDlg);
                }
                break;

            case IDC_MANUAL_ANSWER:
            case IDC_AUTO_ANSWER:
            case IDC_RECEIVE_ENABLE:

                OnReceiveEnable(hDlg);
                break;
        }

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : 

                // Enable the Back and Finish button    
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
            {
                //
                // Handle a Back button click here
                //
                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }

            case PSN_WIZNEXT :
                //
                // Handle a Next button click, if necessary
                //
                if((IsDlgButtonChecked(hDlg, IDC_RECEIVE_ENABLE) == BST_CHECKED) &&
                   (IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER)    == BST_CHECKED) &&
                   (SendDlgItemMessage(hDlg, IDC_RING_COUNT, WM_GETTEXTLENGTH, 0, 0) == 0))
                {
                    //
                    // If the rings field is empty
                    // go back to this page
                    //
                    DisplayMessageDialog(hDlg, MB_OK | MB_ICONSTOP, 0, IDS_ERR_NO_RINGS);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE; 
                }

                DoSaveOneDevLimit(hDlg);

                SetLastPage(IDD_ONE_DEVICE_LIMIT);

                if(!IsSendEnable())
                {
                    if(IsReceiveEnable())
                    {
                        //
                        // go to the CSID page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_RECV_CSID);
                        return TRUE;
                    }
                    else
                    {
                        //
                        // go to the completion page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                        return TRUE;
                    }
                }
                
                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Configuration Wizard resource ID file        //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [7000 - 7999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#include "..\faxres\resource.h"

#define IDD_CFG_WIZARD_WELCOME          7000 
#define IDD_WIZARD_USER_INFO            7001 
#define IDD_WIZARD_SEND_SELECT_DEVICES  7002 
#define IDD_WIZARD_SEND_TSID            7003 
#define IDD_WIZARD_RECV_SELECT_DEVICES  7004 
#define IDD_WIZARD_RECV_CSID            7005 
#define IDD_WIZARD_RECV_RING_COUNT      7006 
#define IDD_WIZARD_RECV_ROUTE           7007 
#define IDD_WIZARD_COMPLETE             7008 
#define IDI_Up                          7009 
#define IDI_Down                        7010 
#define IDB_FAXWIZ_WATERMARK_256        7011 
#define IDB_CFG_WIZ_BITMAP              7012 
#define IDB_FAXWIZ_WATERMARK_16         7013 
#define IDI_Unchecked                   7014 
#define IDI_Checked                     7015 
#define IDI_DisabledChecked             7016 
#define IDI_DisabledUnchecked           7017 
#define IDI_Modem                       7018 
#define IDI_Adapter                     7019 
#define IDI_Question                    7020 
#define IDI_Error                       7021 
#define IDI_Info                        7022 
#define IDS_WIZ_RECV_DEVICE_TITLE       7023 
#define IDS_WIZ_RECV_DEVICE_SUB         7024 
#define IDS_WIZ_RECV_RINGS_TITLE        7025 
#define IDS_WIZ_RECV_RINGS_SUB          7026 
#define IDS_WIZ_RECV_CSID_TITLE         7027 
#define IDS_WIZ_RECV_CSID_SUB           7028 
#define IDS_WIZ_RECV_ROUTE_TITLE        7029 
#define IDS_WIZ_RECV_ROUTE_SUB          7030 
#define IDS_WIZ_SEND_DEVICE_TITLE       7031 
#define IDS_WIZ_SEND_DEVICE_SUB         7032 
#define IDS_WIZ_SEND_TSID_TITLE         7033 
#define IDS_WIZ_SEND_TSID_SUB           7034 
#define IDS_WIZ_USER_INFO_TITLE         7035 
#define IDS_WIZ_USER_INFO_SUB           7036 
#define IDS_WIZ_LARGE_FONT_NAME         7037 
#define IDS_ERROR_TITLE                 7038 
#define IDS_ERR_ARCHIVE_DIR             7040 
#define IDS_ERR_NOT_ENOUGH_MEMORY       7042 
#define IDS_ERR_WIZ_ACCESS_DENIED       7043 
#define IDS_ERR_CANT_CONNECT            7044 
#define IDS_RECV_BROWSE_DIR             7045 
#define IDS_ERR_NO_DEVICE               7047 
#define IDS_ERR_CANT_START_SERVICE      7048 
#define IDS_ERR_CANT_GET_PORT_INFO      7049 
#define IDS_SUMMARY                     7050 
#define IDS_SUMMARY_SEND_DEVICES        7051 
#define IDS_SUMMARY_TSID                7052 
#define IDS_SUMMARY_RECEIVE_DEVICES     7053 
#define IDS_SUMMARY_CSID                7054 
#define IDS_SUMMARY_MANUAL_ANSWER       7055 
#define IDS_SUMMARY_AUTO_ANSWER         7056 
#define IDS_SUMMARY_ROUTING_METHODS     7057 
#define IDS_SUMMARY_PRINT               7058 
#define IDS_SUMMARY_SAVE_FOLDER         7059 
#define IDS_SUMMARY_DEVICE_ITEM         7060 
#define IDS_MMC_CMDLINE                 7061 
#define IDS_ADMIN_CONSOLE_LINK          7062 
#define IDC_RECV_DEVICE_LIST            7067 
#define IDC_RING_COUNT                  7068 
#define IDC_SPIN_RING_COUNT             7069 
#define IDCSTATIC_RECV_WELCOME_TITLE    7071 
#define IDC_SEND_DEVICE_LIST            7072 
#define IDC_SENDPRI_UP                  7073 
#define IDC_SENDPRI_DOWN                7074 
#define IDCSTATIC_RECV_WELCOME_DESCR    7076 
#define IDS_DEVICE_LIMIT_TITLE          7077 
#define IDCSTATIC_RECV_NEXT             7078 
#define IDS_DEVICE_LIMIT_SUB            7079 
#define IDCSTATIC_RING_COUNT            7080 
#define IDS_ONE_DEVICE_TITLE            7081 
#define IDCSTATIC_CSID                  7083 
#define IDS_ONE_DEVICE_SUB              7084 
#define IDCSTATIC_RECV_DEVICE_DESCR     7085 
#define IDD_DEVICE_LIMIT_SELECT         7086 
#define IDCSTATIC_RECV_DEVICE_SELECT    7087 
#define IDC_STATIC_DEVICE_LIMIT_SELECT  7088 
#define IDCSTATIC_RECV_ROUTE_DESCR      7089 
#define IDD_ONE_DEVICE_LIMIT            7091 
#define IDCSTATIC_COMPLETE              7092 
#define IDC_STATIC_NO_DEVICE            7093 
#define IDCSTATIC_WELCOME_TITLE         7094 
#define IDCSTATIC_NEXT                  7095 
#define IDCSTATIC_TSID                  7096 
#define IDCSTATIC_SEND_DEVICE_DESCR     7097 
#define IDCSTATIC_SEND_DEVICE_SELECT    7098 
#define IDCSTATIC_WELCOME_DESCR         7099 
#define IDCSTATIC_FULLNAME              7100 
#define IDC_SENDER_NAME                 7101 
#define IDCSTATIC_FAX_NUMBER            7102 
#define IDC_SENDER_FAX_NUMBER           7103 
#define IDCSTATIC_MAILBOX               7104 
#define IDC_SENDER_MAILBOX              7105 
#define IDCSTATIC_TITLE                 7106 
#define IDC_SENDER_TITLE                7107 
#define IDCSTATIC_COMPANY               7108 
#define IDC_SENDER_COMPANY              7109 
#define IDCSTATIC_OFFICE                7110 
#define IDC_SENDER_OFFICE_LOC           7111 
#define IDCSTATIC_DEPT                  7112 
#define IDC_SENDER_DEPT                 7113 
#define IDCSTATIC_HOME_PHONE            7114 
#define IDC_SENDER_HOME_TL              7115 
#define IDCSTATIC_WORK_PHONE            7116 
#define IDC_SENDER_OFFICE_TL            7117 
#define IDCSTATIC_BILLING_CODE          7118 
#define IDC_SENDER_BILLING_CODE         7119 
#define IDCSTATIC_TSID_DESCR            7120 
#define IDCSTATIC_FINISH                7121 
#define IDC_RECV_PRINT                  7122 
#define IDC_RECV_PRINT_TO               7123 
#define IDC_RECV_SAVE                   7124 
#define IDC_RECV_DEST_FOLDER            7125 
#define IDC_RECV_BROWSE_DIR             7126 
#define IDCSTATIC_DEVICE_SELECT_ANSWER_MODE 7127 
#define IDC_MANUAL_ANSWER               7128 
#define IDC_AUTO_ANSWER                 7129 
#define IDCSTATIC_RINGS                 7130 
#define IDC_SENDER_ADDRESS              7131 
#define IDC_ADDRESS_DETAIL              7132 
#define IDC_STATIC_NOT_FINISH           7133 
#define IDC_STATIC_CLOSE_CONFIRMATION   7134 
#define IDC_SUMMARY                     7136 
#define IDCSTATIC_COMPLETE_SUB          7137 
#define IDCSTATIC_NO_SEND_DEVICE        7138 
#define IDCSTATIC_NO_RECV_DEVICE        7139 
#define IDC_ADMINCONSOLE_LINK           7140 
#define IDCSTATIC_AUTO_ANSWER_DESC      7141 
#define IDCSTATIC_MANUAL_ANSWER_DESC    7142 
#define IDCSTATIC_NO_DEVICE_ERR         7143 
#define IDS_ERR_NO_CONFIG_ACCESS        7144 
#define IDS_ERR_GENERAL                 7145 
#define IDS_SHOW_NEXT_TIME              7146 
#define IDS_ERR_NOT_SAVE                7147 
#define IDS_ERR_NO_DIALING_LOCATION     7148 
#define IDC_SEND_ENABLE                 7151 
#define IDC_RECEIVE_ENABLE              7152 
#define IDS_DEV_LIMIT_ERROR             7153 
#define IDS_ERR_NO_RINGS                7154 
#define IDS_BAD_CSID                    7155 
#define IDS_BAD_TSID                    7156 


//////////////////////////////////////////////////////
//                                                  //
// Fax Configuration Wizard resource ID file        //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [7000 - 7999]                                    //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\userinfo.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    userinfo.c

Abstract:

    Functions for handling events in the "User Info" page of
    the fax configuration wizard

Environment:

        Fax configuration wizard

Revision History:

        03/13/00 -taoyuan-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxcfgwz.h"

// functions which will be used only in this file
VOID DoInitUserInfo(HWND hDlg);
BOOL DoSaveUserInfo(HWND hDlg);
DWORD FillInCountryCombo(HWND hDlg);


VOID
DoInitUserInfo(
    HWND   hDlg    
)

/*++

Routine Description:

    Initializes the User Info property sheet page with information from shared data

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    NONE

--*/

#define InitUserInfoTextField(id, str) SetDlgItemText(hDlg, id, (str) ? str : TEXT(""));

{
    LPTSTR  pszAddressDetail = NULL;
    PFAX_PERSONAL_PROFILE   pUserInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DoInitUserInfo()"));

    pUserInfo = &(g_wizData.userInfo);

    //
    // A numeric edit control should be LTR
    //
    SetLTREditDirection(hDlg, IDC_SENDER_FAX_NUMBER);
    SetLTREditDirection(hDlg, IDC_SENDER_MAILBOX);
    SetLTREditDirection(hDlg, IDC_SENDER_HOME_TL);
    SetLTREditDirection(hDlg, IDC_SENDER_OFFICE_TL);

    //
    // Fill in the edit text fields
    //

    InitUserInfoTextField(IDC_SENDER_NAME,         pUserInfo->lptstrName);
    InitUserInfoTextField(IDC_SENDER_FAX_NUMBER,   pUserInfo->lptstrFaxNumber);
    InitUserInfoTextField(IDC_SENDER_MAILBOX,      pUserInfo->lptstrEmail);
    InitUserInfoTextField(IDC_SENDER_COMPANY,      pUserInfo->lptstrCompany);
    InitUserInfoTextField(IDC_SENDER_TITLE,        pUserInfo->lptstrTitle);
    InitUserInfoTextField(IDC_SENDER_DEPT,         pUserInfo->lptstrDepartment);
    InitUserInfoTextField(IDC_SENDER_OFFICE_LOC,   pUserInfo->lptstrOfficeLocation);
    InitUserInfoTextField(IDC_SENDER_HOME_TL,      pUserInfo->lptstrHomePhone);
    InitUserInfoTextField(IDC_SENDER_OFFICE_TL,    pUserInfo->lptstrOfficePhone);
    InitUserInfoTextField(IDC_SENDER_BILLING_CODE, pUserInfo->lptstrBillingCode);
    InitUserInfoTextField(IDC_ADDRESS_DETAIL,      pUserInfo->lptstrStreetAddress);


    return;
}

BOOL
DoSaveUserInfo(
    HWND  hDlg    
)

/*++

Routine Description:

    Save the information on the User Info property sheet page to shared data

Arguments:

    hDlg - Handle to the User Info property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

#define SaveUserInfoTextField(id, str)                                  \
        {                                                               \
            if (! GetDlgItemText(hDlg, id, szBuffer, MAX_PATH))         \
            {                                                           \
                szBuffer[0] = 0;                                        \
            }                                                           \
            MemFree(str);                                               \
            str = StringDup(szBuffer);                                  \
            if(!str)                                                    \
            {                                                           \
                DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );    \
                return FALSE;                                           \
            }                                                           \
        }                                                               \
  

{
    TCHAR   szBuffer[MAX_PATH];
    PFAX_PERSONAL_PROFILE   pUserInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveUserInfo()"));

    pUserInfo = &(g_wizData.userInfo);

    //
    // Save the edit text fields
    //
    SaveUserInfoTextField(IDC_SENDER_NAME,         pUserInfo->lptstrName);
    SaveUserInfoTextField(IDC_SENDER_FAX_NUMBER,   pUserInfo->lptstrFaxNumber);
    SaveUserInfoTextField(IDC_SENDER_MAILBOX,      pUserInfo->lptstrEmail);
    SaveUserInfoTextField(IDC_SENDER_COMPANY,      pUserInfo->lptstrCompany);
    SaveUserInfoTextField(IDC_SENDER_TITLE,        pUserInfo->lptstrTitle);
    SaveUserInfoTextField(IDC_SENDER_DEPT,         pUserInfo->lptstrDepartment);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_LOC,   pUserInfo->lptstrOfficeLocation);
    SaveUserInfoTextField(IDC_SENDER_HOME_TL,      pUserInfo->lptstrHomePhone);
    SaveUserInfoTextField(IDC_SENDER_OFFICE_TL,    pUserInfo->lptstrOfficePhone);
    SaveUserInfoTextField(IDC_SENDER_BILLING_CODE, pUserInfo->lptstrBillingCode);
    SaveUserInfoTextField(IDC_ADDRESS_DETAIL,      pUserInfo->lptstrStreetAddress);

    return TRUE;
}

BOOL 
LoadUserInfo()
/*++

Routine Description:

    Load the user information from the system. 

Arguments:

    pUserInfo - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define  DuplicateString(dst, src)                                      \
        {                                                               \
            dst = StringDup(src);                                       \
            if(!dst)                                                    \
            {                                                           \
                bRes = FALSE;                                           \
                DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.") );    \
                goto exit;                                              \
            }                                                           \
        }
{
    BOOL                    bRes = TRUE;
    HRESULT                 hr;
    FAX_PERSONAL_PROFILE    fpp = {0};
    PFAX_PERSONAL_PROFILE   pUserInfo = NULL;

    DEBUG_FUNCTION_NAME(TEXT("LoadUserInfo()"));

    pUserInfo = &(g_wizData.userInfo);

    fpp.dwSizeOfStruct = sizeof(fpp);
    hr = FaxGetSenderInformation(&fpp);
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxGetSenderInformation error, ec = %d"), hr);
        return FALSE;
    }
    
    //
    // Copy the user information to shared data
    //
    pUserInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    DuplicateString(pUserInfo->lptstrName,           fpp.lptstrName);
    DuplicateString(pUserInfo->lptstrFaxNumber,      fpp.lptstrFaxNumber);
    DuplicateString(pUserInfo->lptstrEmail,          fpp.lptstrEmail);
    DuplicateString(pUserInfo->lptstrCompany,        fpp.lptstrCompany);
    DuplicateString(pUserInfo->lptstrTitle,          fpp.lptstrTitle);
    DuplicateString(pUserInfo->lptstrStreetAddress,  fpp.lptstrStreetAddress);
    DuplicateString(pUserInfo->lptstrCity,           fpp.lptstrCity);
    DuplicateString(pUserInfo->lptstrState,          fpp.lptstrState);
    DuplicateString(pUserInfo->lptstrZip,            fpp.lptstrZip);
    DuplicateString(pUserInfo->lptstrCountry,        fpp.lptstrCountry);
    DuplicateString(pUserInfo->lptstrDepartment,     fpp.lptstrDepartment);
    DuplicateString(pUserInfo->lptstrOfficeLocation, fpp.lptstrOfficeLocation);
    DuplicateString(pUserInfo->lptstrHomePhone,      fpp.lptstrHomePhone);
    DuplicateString(pUserInfo->lptstrOfficePhone,    fpp.lptstrOfficePhone);
    DuplicateString(pUserInfo->lptstrBillingCode,    fpp.lptstrBillingCode);

exit:
    hr = FaxFreeSenderInformation(&fpp);
    if (FAILED(hr))
    {
        //
        // Memory leak.
        //
        DebugPrintEx(DEBUG_ERR, TEXT("FaxFreeSenderInformation error, ec = %d"), hr);
    }

    return bRes;
}

BOOL 
SaveUserInfo()
/*++

Routine Description:

    Save the user information to the system. 

Arguments:

    pUserInfo - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    HRESULT                 hResult;

    DEBUG_FUNCTION_NAME(TEXT("SaveUserInfo()"));

    g_wizData.userInfo.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    hResult = FaxSetSenderInformation(&(g_wizData.userInfo));

    return (hResult == S_OK);
}

VOID 
FreeUserInfo()
/*++

Routine Description:

    Free the user info data and release the memory. 

Arguments:

    pUserInfo - Pointer to the user info data structure

Return Value:

    none

--*/

{
    FAX_PERSONAL_PROFILE fpp = {0};
    DEBUG_FUNCTION_NAME(TEXT("FreeUserInfo"));

    MemFree(g_wizData.userInfo.lptstrName);
    MemFree(g_wizData.userInfo.lptstrFaxNumber);
    MemFree(g_wizData.userInfo.lptstrCompany);
    MemFree(g_wizData.userInfo.lptstrStreetAddress);
    MemFree(g_wizData.userInfo.lptstrCity);
    MemFree(g_wizData.userInfo.lptstrState);
    MemFree(g_wizData.userInfo.lptstrZip);
    MemFree(g_wizData.userInfo.lptstrCountry);
    MemFree(g_wizData.userInfo.lptstrTitle);
    MemFree(g_wizData.userInfo.lptstrDepartment);
    MemFree(g_wizData.userInfo.lptstrOfficeLocation);
    MemFree(g_wizData.userInfo.lptstrHomePhone);
    MemFree(g_wizData.userInfo.lptstrOfficePhone);
    MemFree(g_wizData.userInfo.lptstrEmail);
    MemFree(g_wizData.userInfo.lptstrBillingCode);
    MemFree(g_wizData.userInfo.lptstrTSID);
    //
    // NULLify all pointer
    //
    g_wizData.userInfo = fpp;

    return;
}


INT_PTR CALLBACK 
UserInfoDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "User Info" tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = {

                IDC_SENDER_NAME,            MAX_USERINFO_FULLNAME,
                IDC_SENDER_FAX_NUMBER,      MAX_USERINFO_FAX_NUMBER,
                IDC_SENDER_MAILBOX,         MAX_USERINFO_MAILBOX,
                IDC_SENDER_COMPANY,         MAX_USERINFO_COMPANY,
                IDC_SENDER_TITLE,           MAX_USERINFO_TITLE,
                IDC_SENDER_DEPT,            MAX_USERINFO_DEPT,
                IDC_SENDER_OFFICE_LOC,      MAX_USERINFO_OFFICE,
                IDC_SENDER_OFFICE_TL,       MAX_USERINFO_WORK_PHONE,
                IDC_SENDER_HOME_TL,         MAX_USERINFO_HOME_PHONE,
                IDC_SENDER_BILLING_CODE,    MAX_USERINFO_BILLING_CODE,
                0,
            };

            LimitTextFields(hDlg, textLimits);
            
            //
            // Initialize the text fields with information from the registry
            //

            DoInitUserInfo(hDlg);

            return TRUE;
        }

    case WM_COMMAND:

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : // Enable the Next button    

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZBACK:
            {
                //
                // Handle a Back button click here
                //
                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }
            case PSN_WIZNEXT :

                //
                // Handle a Next button click here
                //

                DoSaveUserInfo(hDlg);
                SetLastPage(IDD_WIZARD_USER_INFO);

                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            default :
                break;
            }
        }
        break;
    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\recvwzrd.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    recvwzrd.c

Abstract:

    Fax wizard pages for receiving configuration

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"

// functions which will be used only in this file
VOID DoInitRecvDeviceList(HWND);
VOID DoShowRecvDevices(HWND);
VOID DoSaveRecvDevices(HWND);
VOID CheckAnswerOptions(HWND);


VOID 
DoShowRecvDevices(
    HWND  hDlg
)
/*++

Routine Description:

    Load the device information into the list view control

Arguments:

    hDlg - Handle to the Device Send Options property sheet page

Return Value:

    TRUE if successful, FALSE if failed.

--*/
{
    LV_ITEM item = {0};
    INT     iItem = 0;
    INT     iIndex;
    DWORD   dw;
    HWND    hwndLv;

    DEBUG_FUNCTION_NAME(TEXT("DoShowRecvDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

    ListView_DeleteAllItems(hwndLv);

    //
    // Fill the list of devices and select the first item.
    //
    item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    item.iImage  = DI_Modem;

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(!(g_wizData.pDevInfo[dw].bSelected))
        {
            //
            // skip unselected device
            //
            continue;
        }

        item.iItem   = iItem++;
        item.pszText = g_wizData.pDevInfo[dw].szDeviceName;
        item.lParam  = dw;

        iIndex = ListView_InsertItem(hwndLv, &item );
        ListView_SetCheckState(hwndLv, 
                               iIndex, 
                               (FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode));
    }

    //
    // Select the first item.
    //
    ListView_SetItemState(hwndLv, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    ListView_SetColumnWidth(hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );  
}

VOID 
DoSaveRecvDevices(
    HWND   hDlg
)
/*++

Routine Description:

    Save the user's choice for fax receiving devices

Arguments:

    hDlg - Handle to the "Receive Device" page

Return Value:

    TRUE -- if at least one device is selected or confirms for not selecting any receive
    FALSE -- if no device is selected but user chooses to go back.

--*/

{
    DWORD   dw;
    DWORD   dwDevInx;
    DWORD   dwDeviceCount;
    HWND    hwndLv;
    LVITEM  lv = {0};

    DEBUG_FUNCTION_NAME(TEXT("DoSaveRecvDevices()"));

    lv.mask = LVIF_PARAM;

    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);

    //
    // check selected devices
    //
    for(dw = 0; dw < dwDeviceCount; ++dw)
    {
        //
        // Get device index
        //
        lv.iItem = dw;
        ListView_GetItem(hwndLv, &lv);
        dwDevInx = (DWORD)lv.lParam;

        g_wizData.pDevInfo[dwDevInx].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
        if(ListView_GetCheckState(hwndLv, dw))
        {
            if(IsDlgButtonChecked(hDlg,IDC_MANUAL_ANSWER) == BST_CHECKED)
            {
                g_wizData.pDevInfo[dwDevInx].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
            }
            else
            {
                g_wizData.pDevInfo[dwDevInx].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
            }
        }
    }
}

VOID
CheckAnswerOptions(
    HWND   hDlg
)

/*++

Routine Description:

    Enable/disable the manual and auto answer radio button depending on the device
    number to receive faxes

Arguments:

    hDlg  - Handle to the "Receive Device" page

Return Value:

    None

--*/

{
    HWND    hwndLv; // list view windows
    DWORD   dwDeviceIndex;
    DWORD   dwDeviceCount;
    DWORD   dwSelectNum=0; // number of the selected devices
    BOOL    bManualAnswer = FALSE;
    BOOL    bAllowManualAnswer = TRUE;
    BOOL    bAllVirtual = TRUE; // Are all device virtual

    DEBUG_FUNCTION_NAME(TEXT("CheckAnswerOptions()"));

    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);

    if(dwDeviceCount < 1) // if there isn't device in the list.
    {
        goto exit;
    }

    Assert (g_hFaxSvcHandle);

    for(dwDeviceIndex = 0; dwDeviceIndex < dwDeviceCount; ++dwDeviceIndex)
    {
        if(ListView_GetCheckState(hwndLv, dwDeviceIndex))
        {
            DWORD dwRes;
            BOOL  bVirtual;

            dwRes = IsDeviceVirtual (g_hFaxSvcHandle, g_wizData.pDevInfo[dwDeviceIndex].dwDeviceId, &bVirtual);
            if (ERROR_SUCCESS != dwRes)
            {
                //
                // Assume device is virtual
                //
                bVirtual = TRUE;
            }
            if (!bVirtual)
            {
                bAllVirtual = FALSE;
            }
                
            ++dwSelectNum;

            if(FAX_DEVICE_RECEIVE_MODE_MANUAL == g_wizData.pDevInfo[dwDeviceIndex].ReceiveMode)
            {
                Assert(!bManualAnswer);
                bManualAnswer = TRUE;
            }
        }
    }

    if(dwSelectNum != 1)
    {
        bAllowManualAnswer = FALSE;
    }
    if (bAllVirtual && dwSelectNum)
    {
        //
        // Virtual devices don't support manual-answer mode
        //
        bAllowManualAnswer = FALSE;
        //
        // Virtual devices always answer after one ring
        //
        SetDlgItemInt (hDlg, IDC_RING_COUNT, 1, FALSE);
    }
        
    if(IsDlgButtonChecked(hDlg,IDC_MANUAL_ANSWER) == BST_CHECKED)
    {
        if (!bAllowManualAnswer)
        {
            //
            // Manual-answer is not a valid option, yet, it is selected.
            // Change to auto-answer mode.
            //
            CheckDlgButton  (hDlg, IDC_MANUAL_ANSWER, FALSE);
            CheckDlgButton  (hDlg, IDC_AUTO_ANSWER, TRUE);
            bManualAnswer = FALSE;
        }
        else
        {
            bManualAnswer = TRUE;
        }
    }

exit:
    // Show/hide answer mode controls

    EnableWindow(GetDlgItem(hDlg, IDC_MANUAL_ANSWER), !bAllVirtual && (dwSelectNum == 1));
    EnableWindow(GetDlgItem(hDlg, IDC_AUTO_ANSWER),   (dwSelectNum > 0));
    EnableWindow(GetDlgItem(hDlg, IDCSTATIC_RINGS),   (dwSelectNum > 0));

    CheckDlgButton  (hDlg, IDC_MANUAL_ANSWER, bManualAnswer ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton  (hDlg, IDC_AUTO_ANSWER, (!bManualAnswer && (dwSelectNum > 0)) ? BST_CHECKED : BST_UNCHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT),      !bAllVirtual && (dwSelectNum > 0) && IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER));
    EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), !bAllVirtual && (dwSelectNum > 0) && IsDlgButtonChecked(hDlg, IDC_AUTO_ANSWER));

    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_RECV_DEVICE), (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_DEVICE_ERR),  (dwSelectNum > 0) ? SW_HIDE : SW_SHOW);

    return;
}   // CheckAnswerOptions

INT_PTR 
CALLBACK 
RecvDeviceDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Receive Device" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
        case WM_INITDIALOG :
        {
            //
            // Maximum length for various text fields in the dialog
            //
            static INT textLimits[] = 
            {
                IDC_RING_COUNT,  FXS_RINGS_LENGTH+1,
                0,
            };

            LimitTextFields(hDlg, textLimits);

            //
            // Initiate the spin control. 
            //
            SendDlgItemMessage(hDlg, IDC_SPIN_RING_COUNT, UDM_SETRANGE32, 
                              (WPARAM)FXS_RINGS_LOWER, (LPARAM)FXS_RINGS_UPPER);

            if(g_wizData.dwRingCount > FXS_RINGS_UPPER || (int)(g_wizData.dwRingCount) < FXS_RINGS_LOWER)
            {
                SetDlgItemInt(hDlg, IDC_RING_COUNT, FXS_RINGS_DEFAULT, FALSE);
            }
            else
            {
                SetDlgItemInt(hDlg, IDC_RING_COUNT, g_wizData.dwRingCount, FALSE);
            }

            //
            // init the list view and load device info
            //
            InitDeviceList(hDlg, IDC_RECV_DEVICE_LIST); 
            DoShowRecvDevices(hDlg);
            CheckAnswerOptions(hDlg);

            return TRUE;
        }
        case WM_COMMAND:

            switch(LOWORD(wParam)) 
            {
                case IDC_MANUAL_ANSWER:
                case IDC_AUTO_ANSWER:

                    // at this time, they must be enabled
                    EnableWindow(GetDlgItem(hDlg, IDC_RING_COUNT), 
                                 LOWORD(wParam)==IDC_AUTO_ANSWER);
                    EnableWindow(GetDlgItem(hDlg, IDC_SPIN_RING_COUNT), 
                                 LOWORD(wParam)==IDC_AUTO_ANSWER);
                    break;


                default:
                    break;
            }
            break;

        case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE : 

                    DoShowRecvDevices(hDlg);

                    // Enable the Back and Finish button    
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    break;

                case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    DoSaveRecvDevices(hDlg);

                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }
                  
                    break;
                }

                case PSN_WIZNEXT :
                {
                    BOOL bRes;

                    //
                    // Handle a Next button click, if necessary
                    //
                    DoSaveRecvDevices(hDlg);

                    if(IsReceiveEnable() &&
                      (IsDlgButtonChecked(hDlg,IDC_AUTO_ANSWER) == BST_CHECKED) &&
                      (SendDlgItemMessage(hDlg, IDC_RING_COUNT, WM_GETTEXTLENGTH, 0, 0) == 0))
                    {
                        //
                        // If the rings field is empty
                        // go back to this page
                        //
                        DisplayMessageDialog(hDlg, MB_OK | MB_ICONSTOP, 0, IDS_ERR_NO_RINGS);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE; 
                    }

                    g_wizData.dwRingCount = GetDlgItemInt(hDlg, IDC_RING_COUNT, &bRes, FALSE);
                    if(!bRes)
                    {
                        DEBUG_FUNCTION_NAME(TEXT("RecvDeviceDlgProc()"));
                        DebugPrintEx(DEBUG_ERR, TEXT("GetDlgItemInt failed: %d."), GetLastError());
                    }

                    if(!IsReceiveEnable())
                    {
                        //
                        // go to the completion page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                        SetLastPage(IDD_WIZARD_RECV_SELECT_DEVICES);
                        return TRUE; 
                    }

                    SetLastPage(IDD_WIZARD_RECV_SELECT_DEVICES);
                    break;
                }

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    CheckAnswerOptions(hDlg);
                    break;
                }

                case NM_DBLCLK:
                {
                    INT  iItem;
                    HWND hwndLv;

                    iItem  = ((LPNMITEMACTIVATE)lParam)->iItem;
                    hwndLv = GetDlgItem(hDlg, IDC_RECV_DEVICE_LIST);

                    ListView_SetCheckState(hwndLv, iItem, 
                                          !ListView_GetCheckState(hwndLv, iItem));

                    // we don't have break here because we'll go through NM_CLICK
                }

                case NM_CLICK:

                    break;

                default :
                    break;
            }
        } // end of case WM_NOTIFY
        break;

    default:
        break;

    } // end of switch (uMsg)

    return FALSE;
}

INT_PTR 
CALLBACK 
RecvCsidDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "CSID" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = {

                IDC_CSID,  FXS_TSID_CSID_MAX_LENGTH + 1,
                0,
            };

            LimitTextFields(hDlg, textLimits);

            if(g_wizData.szCsid)
            {
                SetDlgItemText(hDlg, IDC_CSID, g_wizData.szCsid);
            }

            return TRUE;
        }


    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : //Enable the Back and Finish button    

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }
                    
                    break;
                }

            case PSN_WIZNEXT :
            {
                //Handle a Next button click, if necessary

                LPTSTR    pCsid = NULL;

                pCsid = (LPTSTR)MemAlloc((FXS_TSID_CSID_MAX_LENGTH + 1) * sizeof(TCHAR));
                Assert(pCsid);

                if(pCsid)
                {
                    pCsid[0] = '\0';
                    GetDlgItemText(hDlg, IDC_CSID, pCsid, FXS_TSID_CSID_MAX_LENGTH + 1);
                    MemFree(g_wizData.szCsid);
                    g_wizData.szCsid = NULL;
                }
                else
                {
                    LPCTSTR faxDbgFunction = TEXT("RecvCsidDlgProc()");
                    DebugPrintEx(DEBUG_ERR, TEXT("Can't allocate memory for CSID.") );
                }
                g_wizData.szCsid = pCsid;
                SetLastPage(IDD_WIZARD_RECV_CSID);
                break;
            }

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\sendwzrd.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    sendwzrd.c

Abstract:

    Fax wizard pages for sending configuration
    plus the welcome and complete page for the wizard.

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"

//
// functions which will be used only in this file
//
VOID DoInitSendDeviceList(HWND);
BOOL DoShowSendDevices(HWND);
VOID DoSaveSendDevices(HWND);
BOOL ValidateControl(HWND, INT);
BOOL ChangePriority(HWND, BOOL);
VOID CheckSendDevices(HWND hDlg);


BOOL 
DoShowSendDevices(
    HWND   hDlg
)
/*++

Routine Description:

    Load the device information into the list view control

Arguments:

    hDlg - Handle to the "Send Device" page

Return Value:

    NONE

--*/
{
    LV_ITEM  item;
    INT      iItem = 0;
    INT      iIndex;
    DWORD    dw;
    int      nDevInx;
    HWND     hwndLv;

    DEBUG_FUNCTION_NAME(TEXT("DoShowSendDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    ListView_DeleteAllItems(hwndLv );

    //
    // Fill the list of devices and select the first item.
    //

    for (dw = 0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        nDevInx = GetDevIndexByDevId(g_wizData.pdwSendDevOrder[dw]);
        if(nDevInx < 0)
        {
            Assert(FALSE);
            continue;
        }

        if(!(g_wizData.pDevInfo[nDevInx].bSelected))
        {
            //
            // skip unselected device
            //
            continue;
        }

        ZeroMemory( &item, sizeof(item) );
        item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem   = iItem++;
        item.pszText = g_wizData.pDevInfo[nDevInx].szDeviceName;

        //
        // we only support modem icon right now, if we can distinguish 
        // the type of a specific, add code here
        //
        item.iImage  = DI_Modem;
        item.lParam  = nDevInx;

        iIndex = ListView_InsertItem(hwndLv, &item );

        ListView_SetCheckState(hwndLv, 
                               iIndex, 
                               g_wizData.pDevInfo[nDevInx].bSend);
    }

    //
    // Select the first item and validate the buttons
    //
    ListView_SetItemState(hwndLv, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    ListView_SetColumnWidth(hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );  

    ValidateControl(hDlg, 0);

    return TRUE;

}

VOID
DoSaveSendDevices(
    HWND   hDlg
)
/*++

Routine Description:

    Save the user's choice for fax sending devices

Arguments:

    hDlg - Handle to the "Send Device" page

Return Value:

    TRUE -- if at least one device is selected or confirms for disable send
    FALSE -- if no device is selected but user chooses to go back.

--*/

{
    DWORD       dw;
    DWORD       dwOrder;
    LVITEM      lv = {0}; // for getting info of device Id
    DWORD       dwDevInx;
    DWORD       dwDeviceCount;
    HWND        hwndLv;

    DEBUG_FUNCTION_NAME(TEXT("DoSaveSendDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);


    lv.mask = LVIF_PARAM;


    //
    // check selected devices
    //
    for(dwOrder = 0; dwOrder < dwDeviceCount; ++dwOrder) 
    {
        //
        // Get device index
        //
        lv.iItem = dwOrder;
        ListView_GetItem(hwndLv, &lv);
        dwDevInx = (DWORD)lv.lParam;
            
        //
        // get device selection
        //
        g_wizData.pDevInfo[dwDevInx].bSend = ListView_GetCheckState(hwndLv, dwOrder);

        //
        // save order info
        //
        g_wizData.pdwSendDevOrder[dwOrder] = g_wizData.pDevInfo[dwDevInx].dwDeviceId;
    }

    //
    // Store unselected device order
    //
    for (dw=0; dw < g_wizData.dwDeviceCount && dwOrder < g_wizData.dwDeviceCount; ++dw)
    {
        if(!(g_wizData.pDevInfo[dw].bSelected))
        {
            g_wizData.pdwSendDevOrder[dwOrder] = g_wizData.pDevInfo[dw].dwDeviceId;
            ++dwOrder;
        }
    }
    Assert(dwOrder == g_wizData.dwDeviceCount);
}

BOOL
ValidateControl(
    HWND   hDlg,
    INT    iItem
)
/*++

Routine Description:

    Validate the up and down button in the device select page

Arguments:

    hDlg - Handle to the Device Send Options property sheet page
    iItem - index of the item being selected

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{

    DWORD dwDeviceCount = ListView_GetItemCount(GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST));

    //
    // if there is only one device or we don't click on any item
    // up and down buttons are disabled
    //
    if(dwDeviceCount < 2 || iItem == -1)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_UP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_DOWN), FALSE);
        return TRUE;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_UP),   iItem > 0); // not the top one
    EnableWindow(GetDlgItem(hDlg, IDC_SENDPRI_DOWN), iItem < (INT)dwDeviceCount - 1 ); // not the last one

    if (!IsWindowEnabled (GetFocus()))
    {
        //
        // The currently selected control turned disabled - select the list control
        //
        SetFocus (GetDlgItem (hDlg, IDC_SEND_DEVICE_LIST));
    }
    return TRUE;
}

BOOL
ChangePriority(
    HWND   hDlg,
    BOOL   bMoveUp
)
/*++

Routine Description:

    Validate the up and down button in the device select page

Arguments:

    hDlg - Handle to the Device Send Options property sheet page
    bMoveUp -- TRUE for moving up, FALSE for moving down

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    INT         iItem;
    BOOL        rslt;
    LVITEM      lv={0};
    HWND        hwndLv;
    BOOL        bChecked;
    TCHAR       pszText[MAX_DEVICE_NAME];

    DEBUG_FUNCTION_NAME(TEXT("ChangePriority()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);
    if(iItem == -1)
    {
        return FALSE;
    }

    // 
    // get selected item information and then remove it
    //
    lv.iItem = iItem;
    lv.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lv.stateMask = LVIS_SELECTED;
    lv.pszText = pszText;
    lv.cchTextMax = MAX_DEVICE_NAME;
    ListView_GetItem(hwndLv, &lv);
    bChecked = ListView_GetCheckState(hwndLv, iItem);

    rslt = ListView_DeleteItem(hwndLv, iItem);

    //
    // recalculate the item index;
    //
    if(bMoveUp)
    {
        lv.iItem--;
    }
    else
    {
        lv.iItem++;
    }

    //
    // reinsert the item and validate button state
    //
    iItem = ListView_InsertItem(hwndLv, &lv);
    ListView_SetCheckState(hwndLv, iItem, bChecked);
    ListView_SetItemState(hwndLv, iItem, LVIS_SELECTED, LVIS_SELECTED);
    ValidateControl(hDlg, iItem);

    return TRUE;
}

VOID
CheckSendDevices(
    HWND    hDlg
    )

/*++

Routine Description:

    Display a warning if no device is selected

Arguments:

    hDlg - Handle to the "Send Device" page

Return Value:

    None

--*/

{
    HWND    hwndLv; // list view windows
    DWORD   dwDeviceIndex;
    DWORD   dwDeviceCount;
    BOOL    bDeviceSelect = FALSE; // indicate whether we have at least one device selected.

    DEBUG_FUNCTION_NAME(TEXT("CheckSendDevices()"));

    hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

    dwDeviceCount = ListView_GetItemCount(hwndLv);

    if(dwDeviceCount < 1) // if there isn't device in the list.
    {
        goto exit;
    }

    for(dwDeviceIndex = 0; dwDeviceIndex < dwDeviceCount; dwDeviceIndex++)
    {       
        if(ListView_GetCheckState(hwndLv, dwDeviceIndex))
        {
            bDeviceSelect = TRUE;
            break;
        }
    }

exit:

    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_SEND_DEVICE), bDeviceSelect ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(hDlg, IDCSTATIC_NO_DEVICE_ERR),  bDeviceSelect ? SW_HIDE : SW_SHOW);

    return;
}

INT_PTR 
CALLBACK 
SendDeviceDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Send Device" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        {             
            // icon handles for up and down arrows.
            HICON  hIconUp, hIconDown;

            hIconUp = LoadIcon(g_hResource, MAKEINTRESOURCE(IDI_Up));
            hIconDown = LoadIcon(g_hResource, MAKEINTRESOURCE(IDI_Down));

            SendDlgItemMessage(hDlg, IDC_SENDPRI_UP, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconUp);
            SendDlgItemMessage(hDlg, IDC_SENDPRI_DOWN, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconDown);

            //
            // load device info
            //
            InitDeviceList(hDlg, IDC_SEND_DEVICE_LIST);
            DoShowSendDevices(hDlg);
            CheckSendDevices(hDlg);

            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_SENDPRI_UP:

                ChangePriority(hDlg, TRUE);
                break;

            case IDC_SENDPRI_DOWN:

                ChangePriority(hDlg, FALSE);
                break;

            default:
                break;
        }

        break;

    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : 

                DoShowSendDevices(hDlg);

                // Enable the Back and Finish button    
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZBACK :
            {
                //
                // Handle a Back button click here
                //
                DoSaveSendDevices(hDlg);

                if(RemoveLastPage(hDlg))
                {
                    return TRUE;
                }
                
                break;
            }

            case PSN_WIZNEXT :
                //
                // Handle a Next button click, if necessary
                //

                DoSaveSendDevices(hDlg);
            
                //
                // switch to appropriate page
                //
                if(!IsSendEnable())
                {
                    //
                    // go to the receive configuration or completion page
                    //
                    if(g_bShowDevicePages)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_RECV_SELECT_DEVICES);
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                    }

                    SetLastPage(IDD_WIZARD_SEND_SELECT_DEVICES);
                    return TRUE; 
                }

                SetLastPage(IDD_WIZARD_SEND_SELECT_DEVICES);
                break;

            case PSN_RESET :
            {
                // Handle a Cancel button click, if necessary
                break;
            }

            case LVN_ITEMCHANGED:
            {
                //
                // need to validate the control after changing selection by keyboard
                // 

                LPNMLISTVIEW pnmv; 

                pnmv = (LPNMLISTVIEW) lParam; 
                ValidateControl(hDlg, pnmv->iItem); 
                CheckSendDevices(hDlg);

                break;
            }

            case NM_DBLCLK:

            {
                //
                // Handle a double click event
                //
                INT   iItem;
                HWND  hwndLv;
                hwndLv = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);
                iItem = ((LPNMITEMACTIVATE) lParam)->iItem;
                ListView_SetCheckState(hwndLv, iItem, !ListView_GetCheckState(hwndLv, iItem));
                
                // we don't have break here because we'll go through NM_CLICK
            }

            case NM_CLICK:
            {
                //
                // Handle a Click event
                //
                HWND  hwndLv;
                LPNMITEMACTIVATE lpnmitem;
                
                lpnmitem = (LPNMITEMACTIVATE)lParam;
                hwndLv   = GetDlgItem(hDlg, IDC_SEND_DEVICE_LIST);

                ListView_SetItemState(hwndLv, lpnmitem->iItem, LVIS_SELECTED, LVIS_SELECTED);
                ValidateControl(hDlg, lpnmitem->iItem);
                CheckSendDevices(hDlg);

                break;
            }

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}


INT_PTR CALLBACK 
SendTsidDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "TSID" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = 
            {
                IDC_TSID,  FXS_TSID_CSID_MAX_LENGTH + 1,
                0,
            };

            LimitTextFields(hDlg, textLimits);
            
            if(g_wizData.szTsid)
            {
                SetDlgItemText(hDlg, IDC_TSID, g_wizData.szTsid);
            }

            return TRUE;
        }


    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE : //Enable the Back and Finish button    

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;

                case PSN_WIZBACK :
                {
                    //
                    // Handle a Back button click here
                    //
                    if(RemoveLastPage(hDlg))
                    {
                        return TRUE;
                    }

                    break;
                }

                case PSN_WIZNEXT :
                {
                    // Handle a Next button click, if necessary
                    LPTSTR    pTsid;

                    pTsid = (LPTSTR)MemAlloc((FXS_TSID_CSID_MAX_LENGTH + 1) * sizeof(TCHAR));
                    Assert(pTsid);

                    if(pTsid)
                    {
                        pTsid[0] = '\0';
                        GetDlgItemText(hDlg, IDC_TSID, pTsid, FXS_TSID_CSID_MAX_LENGTH + 1);
                
                        MemFree(g_wizData.szTsid);
                        g_wizData.szTsid = NULL;
                    }
                    else
                    {
                        LPCTSTR faxDbgFunction = TEXT("SendTsidDlgProc()");
                        DebugPrintEx(DEBUG_ERR, TEXT("Can't allocate memory for TSID."));
                    }
                    g_wizData.szTsid = pTsid;

                    if(1 == g_wizData.dwDeviceLimit && !IsReceiveEnable())
                    {
                        //
                        // go to the completion page
                        //
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WIZARD_COMPLETE);
                        SetLastPage(IDD_WIZARD_SEND_TSID);
                        return TRUE;
                    }
                    SetLastPage(IDD_WIZARD_SEND_TSID);
                    break;
                }

                case PSN_RESET :
                {
                    // Handle a Cancel button click, if necessary
                    break;
                }

                default :
                    break;
            }

            break;
        } // WM_NOTIFY

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\util.c ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Common used functions in fax configuration wizard

Environment:

    Fax configuration wizard

Revision History:

    03/13/00 -taoyuan-
            Created it.

    mm/dd/yy -author-
            description

--*/

#include "faxcfgwz.h"
#include <devguid.h>
#include <shlwapi.h>

//
// Information about list of dependent services which we stopped
//

typedef struct {

    PVOID   pNext;
    TCHAR   serviceName[1];

} DEPENDENT_SERVICE_LIST, *PDEPENDENT_SERVICE_LIST;

//
// offset of field m in a struct s 
// copied from stddef.h, so we don't need to include stddef.h
//

#define offsetof(s,m)       (size_t)( (char *)&(((s *)0)->m) - (char *)0 )


VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    NONE

--*/

{
    TCHAR  tszTitle[MAX_TITLE_LEN + 1];
    TCHAR  tszFormat[MAX_MESSAGE_LEN + 1];
    TCHAR  tszMessage[MAX_MESSAGE_LEN + 1];
    va_list ap;

    DEBUG_FUNCTION_NAME(TEXT("DisplayMessageDialog()"));

        //
        // Load dialog box title string resource
        //
    if (titleStrId == 0)
    {
        titleStrId = IDS_ERROR_TITLE;
    }

    if(!LoadString(g_hResource, titleStrId, tszTitle, ARR_SIZE(tszTitle)))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     titleStrId,
                     GetLastError());
        return IDCANCEL;
    }
    //
    // Load message format string resource
    //
    if(!LoadString(g_hResource, formatStrId, tszFormat, ARR_SIZE(tszFormat)))
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                     formatStrId,
                     GetLastError());
        return IDCANCEL;
    }

    //
    // Compose the message string
    //
    va_start(ap, formatStrId);
    wvnsprintf(tszMessage, ARR_SIZE(tszMessage), tszFormat, ap);
    va_end(ap);
    //
    // Terminate string with NULL regardless of success / failure of wvnsprintf
    //
    tszMessage[ARR_SIZE(tszMessage) - 1] = TEXT('\0');
    //
    // Display the message box
    //
    if (type == 0) 
    {
        type = MB_OK | MB_ICONERROR;
    }

    return AlignedMessageBox(hwndParent, tszMessage, tszTitle, type);
}

int CALLBACK 
BrowseCallbackProc(
    HWND    hDlg,
    UINT    uMsg,
    LPARAM  lParam,
    LPARAM  dwData
)

/*++

Routine Description:

    We use this callback function to specify the initial folder

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    uMsg - Value identifying the event. 
    lParam - Value dependent upon the message contained in the uMsg parameter. 
    dwData - Application-defined value that was specified in the lParam member of the BROWSEINFO structure. 

Return Value:

    Returns zero.

--*/

{
    switch(uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hDlg, BFFM_SETSELECTION, TRUE, dwData);
            break;

        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lParam, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            SendMessage(hDlg, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }

    }

    return 0;
}

BOOL
BrowseForDirectory(
    HWND   hDlg,
    INT    hResource,
    LPTSTR title
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    hResource - resource id to receive the directory 
    title - the title to be shown in the browse dialog

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    TCHAR           buffer[MAX_PATH];
    BOOL            bResult = FALSE;
    LPMALLOC        pMalloc = NULL;

    BROWSEINFO bi = {

        hDlg,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_NONEWFOLDERBUTTON,
        BrowseCallbackProc,
        (LPARAM) buffer,
    };

    DEBUG_FUNCTION_NAME(TEXT("BrowseForDirectory()"));

    if (!GetDlgItemText( hDlg, hResource, buffer, MAX_PATH))
    {
        buffer[0] = 0;
    }

    if(E_FAIL == SHGetMalloc(&pMalloc))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SHGetMalloc failed"));
        return bResult;
    }

    if (pidl = SHBrowseForFolder(&bi)) 
    {
        if (SHGetPathFromIDList(pidl, buffer)) 
        {
            if (lstrlen(buffer) > MAX_ARCHIVE_DIR)
            {
                DisplayMessageDialog(hDlg, 0, 0,IDS_ERR_DIR_TOO_LONG);
            }
            else 
            {
                SetDlgItemText(hDlg, hResource, buffer);
                bResult = TRUE;
            }
        }

        pMalloc->lpVtbl->Free(pMalloc, (LPVOID)pidl);

    }

    pMalloc->lpVtbl->Release(pMalloc);

    return bResult;
}

VOID
DisConnect(
)
/*++

Routine Description:

    Close current connection to the fax service

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_hFaxSvcHandle) {
        FaxClose(g_hFaxSvcHandle);
        g_hFaxSvcHandle = NULL;
    }
}

BOOL
Connect(
)
/*++

Routine Description:

    Connect to the fax service

Arguments:

    None.

Return Value:

    TRUE if successfully connected, FALSE if there is an error.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("Connect()"));

    //
    // Check if already connected to the fax service
    //
    if (g_hFaxSvcHandle) {
        return TRUE;
    }

    //
    // Connect to the fax service
    //
    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) 
    {
        LPCTSTR faxDbgFunction = TEXT("Connect()");
        DebugPrintEx(DEBUG_ERR, TEXT("Can't connect to the fax server, ec = %d."), GetLastError());
        return FALSE;
    }

    return TRUE;
}

DWORD 
DoesTAPIHaveDialingLocation (
    LPBOOL lpbRes
)
/*++

Routine name : DoesTAPIHaveDialingLocation

Routine description:

    Checks if TAPI as at least one dialing location

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    lpbRes [out]    - TRUE if TAPI has at least one dialing location. FALSE if none

Return Value:

    Standard Win32 error code

--*/
{
    DWORD                   dwRes = ERROR_SUCCESS;
    HLINEAPP                hLineApp = HandleToULong(NULL);
    DWORD                   dwNumDevs;
    LINEINITIALIZEEXPARAMS  LineInitializeExParams;
    DWORD                   dwAPIVer = 0x00020000;
    LINETRANSLATECAPS       LineTransCaps;
    HANDLE                  hEvent = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DoesTAPIHaveDialingLocation"));

    //
    // Create a dummy event
    //
    hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (!hEvent)
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("CreateEvent failed: %#lx"), 
                     GetLastError());
        return GetLastError ();
    }
    //
    // Initialize TAPI
    //
    LineInitializeExParams.dwTotalSize              = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize             = 0;
    LineInitializeExParams.dwUsedSize               = 0;
    LineInitializeExParams.dwOptions                = LINEINITIALIZEEXOPTION_USEEVENT ;
    LineInitializeExParams.Handles.hEvent           = hEvent;

    dwRes = (DWORD)lineInitializeEx(
        &hLineApp,
        GetModuleHandle(NULL),
        NULL,
        NULL,
        &dwNumDevs,
        &dwAPIVer,
        &LineInitializeExParams
        );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("lineInitializeEx failed: %#lx"), 
                     dwRes);
        goto exit;    
    }
    LineTransCaps.dwTotalSize = sizeof(LINETRANSLATECAPS);
    dwRes = (DWORD)lineGetTranslateCaps (hLineApp, 0x00020000, &LineTransCaps);
    if ((DWORD)LINEERR_INIFILECORRUPT == dwRes)
    {
        //
        // This is a special return code from TAPI which indicates no dialing rules are defined.
        //
        *lpbRes = FALSE;
    }
    else
    {
        *lpbRes = TRUE;
    }
    dwRes = ERROR_SUCCESS;

exit:
    if (hLineApp)
    {
        lineShutdown (hLineApp);
    }
    if (hEvent)
    {
        CloseHandle (hEvent);
    }
    return dwRes;
}   // DoesTAPIHaveDialingLocation

void 
InstallModem (
    HWND hWnd
    )
/*++

Routine Description:
    Pop up the hardware installation wizard to install a modem.
    
Arguments:

    hWnd - window handle of the caller.

Return Value:

    None.
    
--*/
{

    HINSTANCE hInst = NULL;
    PINSTNEWDEV pInstNewDev;

    DEBUG_FUNCTION_NAME(TEXT("InstallModem()"));

    hInst = LoadLibrary (NEW_DEV_DLL);
    if (NULL == hInst)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadLibrary failed: %#lx"), GetLastError());
        return;
    }

    pInstNewDev = (PINSTNEWDEV)GetProcAddress (hInst, INSTALL_NEW_DEVICE);
    if (NULL != pInstNewDev)
    {
        EnableWindow (hWnd, FALSE);
        pInstNewDev (hWnd, (LPGUID)&GUID_DEVCLASS_MODEM, NULL);
        EnableWindow (hWnd, TRUE);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetProcAddress failed: %#lx"), GetLastError());
    }

    FreeLibrary (hInst);

    DebugPrintEx(DEBUG_MSG, TEXT("Exit modem installation."));

    return;
}   // InstallModem


BOOL
StartFaxService(
    LPTSTR  pServerName
    )

/*++

Routine Description:

    Start the fax service  

Arguments:

    pServerName - Specifies the name of the server computer, NULL for local machine

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL  success = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("StartFaxService()"));
    
    //
    // Start the fax service and wait for it to be in the running state
    //
    if (EnsureFaxServiceIsStarted(pServerName)) 
    {
        success = WaitForServiceRPCServer(60 * 1000);
        if(!success)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("WaitForServiceRPCServer failed: %d"), GetLastError());
        }
    }

    return success;
}

BOOL 
IsUserInfoConfigured()
/*++

Routine Description:

    Check whether it's the first time starting the wizard

Arguments:

Return Value:

    TRUE if User Info Configured, FALSE if not

--*/

{
    // 
    // Set flag in the registry to specify we have done the 
    // fax configuration wizard
    //
    HKEY    hRegKey;
    BOOL    bRes = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("IsUserInfoConfigured()"));

    //
    // Open the user registry key for writing and create it if necessary
    //
    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_QUERY_VALUE)))
    {
        bRes = GetRegistryDword(hRegKey, REGVAL_CFGWZRD_USER_INFO);
            
        //
        // Close the registry key before returning to the caller
        //

        RegCloseKey(hRegKey);
    }
    else
    {
        LPCTSTR faxDbgFunction = TEXT("IsUserInfoConfigured()");
        DebugPrintEx(DEBUG_ERR, TEXT("Can't open registry to set the wizard flag."));
    }

    return bRes;
}

BOOL 
FaxDeviceEnableRoutingMethod(
    HANDLE hFaxHandle,      
    DWORD dwDeviceId,       
    LPCTSTR pRoutingGuid,    
    LONG Enabled            
)

/*++

Routine Description:

    Get or set the current status of a routing method for specific device

Arguments:

    hFaxHandle - fax handle by FaxConnectFaxServer()
    dwDeviceId - device ID
    pRoutingGuid - GUID that identifies the fax routing method
    Enabled - enabled status for the device and method, if Enabled is QUERY_STATUS, 
            it means return value is the current state

Return Value:

    if Enabled is QUERY_STATUS, return the current state of routing method;
    if Enabled is QUERY_ENABLE or QUERY_DISABLE, return TRUE for success, FALSE for failure.

--*/

{    
    BOOL                 bRes = FALSE;
    PFAX_ROUTING_METHOD  pRoutMethod = NULL;
    DWORD                dwMethodsNum;
    HANDLE               hFaxPortHandle = NULL;
    DWORD                dwInx;

    DEBUG_FUNCTION_NAME(TEXT("FaxDeviceEnableRoutingMethod()"));

    if(!hFaxHandle)
    {
        Assert(FALSE);
        return bRes;
    }

    if(!FaxOpenPort(hFaxHandle, 
                    dwDeviceId, 
                    PORT_OPEN_QUERY | PORT_OPEN_MODIFY, 
                    &hFaxPortHandle))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxOpenPort failed: %d."), GetLastError());
        goto exit;
    }

    if(Enabled == QUERY_STATUS)
    {
        if(!FaxEnumRoutingMethods(hFaxPortHandle, &pRoutMethod, &dwMethodsNum))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxEnumRoutingMethods failed: %d."), GetLastError());
            goto exit;
        }

        for(dwInx=0; dwInx < dwMethodsNum; ++dwInx)
        {
            if(!_tcsicmp(pRoutMethod[dwInx].Guid, pRoutingGuid))
            {
                bRes = pRoutMethod[dwInx].Enabled;
                goto exit;
            }
        }
        DebugPrintEx(DEBUG_MSG, TEXT("Routing method not found"));
        goto exit;
    }
    else
    {
        if(!FaxEnableRoutingMethod(hFaxPortHandle, 
                                   pRoutingGuid, 
                                   (Enabled == STATUS_ENABLE) ? TRUE : FALSE))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FaxEnableRoutingMethod failed: %d."), GetLastError());
            goto exit;
        }
    }


    bRes = TRUE;

exit:
    if(pRoutMethod) 
    { 
        FaxFreeBuffer(pRoutMethod); 
    }

    if(hFaxPortHandle) 
    { 
        FaxClose(hFaxPortHandle); 
    }

    return bRes;
}


BOOL
VerifyDialingLocations (
    HWND hWndParent
)
/*++

Routine name : VerifyDialingLocations

Routine description:

	Makes sure there's at least one TAPI dialing location defined.
    If none are defined, pops the system U/I for defining one.
    If the user cancels that U/I, offer the user a chance to re-enter a dialing location.
    If the user still refuses, return FALSE.

Author:

	Eran Yariv (EranY),	Jan, 2001

Arguments:

	hWndParent   [in]     - Parent window handle

Return Value:

    See discussion on the return value in the description above.

--*/
{
    BOOL                bDialingRulesDefined;
    DWORD               dwRes;
    DEBUG_FUNCTION_NAME(TEXT("VerifyDialingLocations"));

    //
    // Check if there are dialing rules defined
    //
    dwRes = DoesTAPIHaveDialingLocation (&bDialingRulesDefined);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't detect - return now. 
        // Assume TRUE.
        //
        return TRUE;
    }
    if (bDialingRulesDefined)
    {
        //
        // Good. Return TRUE
        //
        return TRUE;
    }
    for (;;)
    {
        //
        // No dialing rules defined, pop the simple dialing rules dialog
        //
        extern LONG LOpenDialAsst(
            IN HWND    hwnd,
            IN LPCTSTR lpszAddressIn,
            IN BOOL    fSimple, // if TRUE, uses a dialog for dialing locations. Otherwise, uses a property sheet.
            IN BOOL    fSilentInstall );

        EnableWindow (hWndParent, FALSE);
        LOpenDialAsst(hWndParent, NULL, TRUE, TRUE);
        EnableWindow (hWndParent, TRUE);
        //
        // After we popped the system dialing locations dialog, we should check and see if a location was really added.
        //
        dwRes = DoesTAPIHaveDialingLocation (&bDialingRulesDefined);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Can't detect - return now.
            // Assume TRUE.
            //
            return TRUE;
        }
        if (bDialingRulesDefined)
        {
            //
            // Good. The user just added a dialing rule
            //
            return TRUE;
        }
        //
        // Oh no - the user canceled.
        // Pop a message box asking him to retry
        //
        if (IDYES == DisplayMessageDialog(hWndParent, 
                                          MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, 
                                          0, 
                                          IDS_ERR_NO_DIALING_LOCATION))
        {                                       
            //
            // User chose to abort the wizard - return now
            //
            return FALSE;
        }
        //
        // Try again
        //
    }
    ASSERT_FALSE;
}   // VerifyDialingLocations

DWORD
CountFaxDevices ()
/*++

Routine name : CountFaxDevices

Routine description:

	Counts the number of fax devices (ports) the service knows about

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    PFAX_PORT_INFO_EX   pPortsInfo = NULL;
    DWORD               dwPorts;
    DEBUG_FUNCTION_NAME(TEXT("CountFaxDevices()"));

    if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pPortsInfo, &dwPorts))
    {
        DebugPrintEx(DEBUG_MSG, TEXT("FaxEnumPortsEx: failed: error=%d."), GetLastError());
        return 0;
    }
    if(pPortsInfo) 
    { 
        FaxFreeBuffer(pPortsInfo); 
    }   
    return dwPorts;
}   // CountFaxDevices

BOOL 
IsFaxDeviceInstalled(
    HWND    hWnd,
    LPBOOL  lpbAbort
)
/*++

Routine Description:

    Checks if some fax devices are installed.
    If not, suggest to the user to install a device.
    Also, checks if TAPI has a dialing location.
    If not, asks the user to add one.
    If the user refuses, sets lpbAbort to TRUE and return FALSE.
    
Arguments:

  hWnd     - [in]  caller window handle
  lpbAbort - [out] TRUE if the user refused to enter a dialing location and the calling process should abort.

Return Value:

    return TRUE for YES, FALSE for NO

--*/
{
    DWORD           dwDevices;
    DEBUG_FUNCTION_NAME(TEXT("IsFaxDeviceInstalled()"));
    //
    // See how many fax devices the server has found
    //
    dwDevices = CountFaxDevices();
    if(0 == dwDevices)
    {
        int iInstallNewModem;
        //
        // no available device, pop up a U/I to install modem
        //
        iInstallNewModem = DisplayMessageDialog(hWnd, 
                                                MB_YESNO | MB_ICONQUESTION, 
                                                0, 
                                                IDS_ERR_NO_DEVICE);
        if(iInstallNewModem == IDYES)
        {
            //
            // Make sure we have at least one TAPI dialing location.
            // If not, pop a system U/I for the dialing locations.
            //
            HCURSOR hOldCursor;
            int i;

            if (!VerifyDialingLocations (hWnd))
            {
                //
                // The user refused to enter a dialing location and the calling process should abort.
                //
                *lpbAbort = TRUE;
                return FALSE;
            }

            hOldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

            InstallModem(hWnd);
            // 
            // We don't need to restart the service because the 
            // service can detect the addition of new fax devices.
            // Let's wait a while for the service to discover the new device.
            // We wait up to 12 seconds.
            //
            for (i=0; i < 4; i++)
            {
                Sleep (3000);
                dwDevices = CountFaxDevices();
                if (dwDevices)
                {
                    //
                    // Hooray. Device found by service
                    //
                    break;
                }
            }
            SetCursor (hOldCursor);
        }
    }
    else
    {
        //
        // At least one device is already installed.
        // Make sure we have at least one TAPI dialing location.
        // If not, pop a system U/I for the dialing locations.
        //
        if (!VerifyDialingLocations (hWnd))
        {
            //
            // The user refused to enter a dialing location and the calling process should abort.
            //
            *lpbAbort = TRUE;
            return FALSE;
        }
    }
    return (dwDevices != 0);
}   // IsFaxDeviceInstalled

VOID 
ListView_SetDeviceImageList(
    HWND      hwndLv,
    HINSTANCE hinst 
)
/*++

Routine Description:

    Sets ImageList to list view
    
Arguments:

  hwndLv - list view handle
  hinst  - application instance

Return Value:

    none

--*/
{
    HICON      hIcon;
    HIMAGELIST himl;

    himl = ImageList_Create(
               GetSystemMetrics( SM_CXSMICON ),
               GetSystemMetrics( SM_CYSMICON ),
               ILC_MASK, 2, 2 );

    hIcon = LoadIcon( hinst, MAKEINTRESOURCE( IDI_Modem ) );
    Assert(hIcon);

    ImageList_ReplaceIcon( himl, -1, hIcon );
    DestroyIcon( hIcon );

    ListView_SetImageList( hwndLv, himl, LVSIL_SMALL );
}

BOOL
IsSendEnable()
/*++

Routine Description:

  Determine if the any of the devices configured to send faxes

Arguments:

Return Value:

    TRUE or FALSE

--*/
{
    DWORD dw;

    if(NULL == g_wizData.pDevInfo)
    {
        return FALSE;
    }

    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(g_wizData.pDevInfo[dw].bSend)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL 
IsReceiveEnable()
/*++

Routine Description:

  Determine if the any of the devices configured to receive faxes

Arguments:

Return Value:

    TRUE or FALSE

--*/
{
    DWORD dw;

    if(NULL == g_wizData.pDevInfo)
    {
        return FALSE;
    }

    for(dw=0; dw < g_wizData.dwDeviceCount; ++dw)
    {
        if(FAX_DEVICE_RECEIVE_MODE_OFF != g_wizData.pDevInfo[dw].ReceiveMode)
        {
            return TRUE;
        }
    }

    return FALSE;
}

int
GetDevIndexByDevId(
    DWORD dwDeviceId
)
/*++

Routine Description:

    Finds appropriate item index in WIZARDDATA.pDevInfo array
    by device ID

Arguments:

    dwDeviceId   - device ID

Return Value:

    device index in WIZARDDATA.pDevInfo array
    or -1 on failure

--*/
{
    DWORD dwIndex;

    if(NULL == g_wizData.pDevInfo)
    {
	    Assert(FALSE);
        return -1;
    }

    for(dwIndex = 0; dwIndex < g_wizData.dwDeviceCount; ++dwIndex)
    {
        if(g_wizData.pDevInfo[dwIndex].dwDeviceId == dwDeviceId)
        {
            return (int)dwIndex;
        }
    }

    Assert(FALSE);
    return -1;
}

VOID
InitDeviceList(
    HWND  hDlg,
    DWORD dwListViewResId
)

/*++

Routine Description:

    Initializes devices list view control

Arguments:

    hDlg            - Handle to property page
    dwListViewResId - list view resource ID

Return Value:

    NONE

--*/

{
    HWND      hwndLv;
    LV_COLUMN col = {0};

    DEBUG_FUNCTION_NAME(TEXT("InitDeviceList()"));

    Assert(hDlg);

    hwndLv = GetDlgItem(hDlg, dwListViewResId);
    Assert(hwndLv);

    //
    // Add the modem images.
    //
    ListView_SetDeviceImageList(hwndLv, g_hResource );

    ListView_SetExtendedListViewStyle(hwndLv, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    //
    // Add a single column exactly wide enough to fully display
    // the widest member of the list.
    //
    col.mask = LVCF_FMT;
    col.fmt  = LVCFMT_LEFT;
    ListView_InsertColumn(hwndLv, 0, &col );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\faxres\resource.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Definition of resource ID constants

Environment:

        Fax driver user interface

Revision History:

        02/15/01 -ivg-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

//////////////////////////////////////////////////////
//                                                  //
// THIS RESOURCE ID FILE IS PART OF FXSRES.DLL      //
//                                                  //
// ALL THE IDs SHOULD BE IN RANGE                   //
//                                                  //
// [100 - 1999]                                     //
//                                                  //
//////////////////////////////////////////////////////

#define IDS_ERR_CONNECTION_FAILED   100
#define IDS_ERR_ACCESS_DENIED       101
#define IDS_ERR_NO_MEMORY           102
#define IDS_ERR_OPERATION_FAILED    103
#define IDS_ERR_FOLDER_NOT_FOUND    104
#define IDS_ERR_DEVICE_LIMIT        105
#define IDS_ERR_INVALID_RING_COUNT  106
#define IDS_ERR_SELECT_PRINTER      107
#define IDS_ERR_NAME_IS_TOO_LONG    108
#define IDS_ERR_DIRECTORY_IN_USE    109

//
// The resource identifiers below are referred by value by FXSOCM.INF
// DO NOT CHANGE them without updating the references in FXSOCM.INF !
//
#define IDS_SEND_WIZARD_SHORTCUT        110
#define IDS_SEND_WIZARD_TOOLTIP         111
#define IDS_COVER_PAGE_EDITOR_SHORTCUT  112
#define IDS_COVER_PAGE_EDITOR_TOOLTIP   113
#define IDS_CLIENT_CONSOLE_SHORTCUT     114
#define IDS_CLIENT_CONSOLE_TOOLTIP      115
#define IDS_SERVICE_MANAGER_SHORTCUT    116
#define IDS_SERVICE_MANAGER_TOOLTIP     117
#define IDS_FAX_PROGRAM_GROUP           118
#define IDS_AWD_CONVERTOR_FRIENDLY_TYPE 119
//
// End of resource ids refered by FXSOCM.INF 
//

#define IDS_ERR_INVALID_RETRIES         1000
#define IDS_ERR_INVALID_RETRY_DELAY     1001
#define IDS_ERR_INVALID_DIRTY_DAYS      1002
#define IDS_ERR_INVALID_CSID            1003
#define IDS_ERR_INVALID_TSID            1004

//
// Dialog controls
//
#define IDC_STATIC                      1010 

// 
// Send configuration page controls
// 
#define IDC_BRANDING_CHECK              1011 
#define IDC_RETRIES_STATIC              1012 
#define IDC_RETRIES_EDIT                1013 
#define IDC_RETRIES_SPIN                1014 
#define IDC_OUTB_RETRYDELAY_STATIC      1015 
#define IDC_RETRYDELAY_EDIT             1016 
#define IDC_RETRYDELAY_SPIN             1017 
#define IDC_OUTB_MINUTES_STATIC         1018 
#define IDC_OUTB_DIS_START_STATIC       1019 
#define IDC_DISCOUNT_START_TIME         1020 
#define IDC_OUTB_DIS_STOP_STATIC        1021 
#define IDC_DISCOUNT_STOP_TIME          1022 
#define IDC_DELETE_CHECK                1023 
#define IDC_DAYS_EDIT                   1024 
#define IDC_DAYS_SPIN                   1025 
#define IDC_DAYS_STATIC                 1026 

// 
// Security strings 
// 
#define IDS_FAXSEC_SUB_LOW              1030 
#define IDS_FAXSEC_SUB_NORMAL           1031 
#define IDS_FAXSEC_SUB_HIGH             1032 
#define IDS_FAXSEC_JOB_QRY              1033 
#define IDS_FAXSEC_JOB_MNG              1034 
#define IDS_FAXSEC_CONFIG_QRY           1035 
#define IDS_FAXSEC_CONFIG_SET           1036 
#define IDS_FAXSEC_QRY_IN_ARCH          1037 
#define IDS_FAXSEC_MNG_IN_ARCH          1038 
#define IDS_FAXSEC_QRY_OUT_ARCH         1039 
#define IDS_FAXSEC_MNG_OUT_ARCH         1040 
#define IDS_FAXSEC_READ_PERM            1041 
#define IDS_FAXSEC_CHNG_PERM            1042 
#define IDS_FAXSEC_CHNG_OWNER           1043 
#define IDS_RIGHT_FAX                   1044 
#define IDS_RIGHT_MNG_DOC               1045 
#define IDS_RIGHT_MNG_CFG               1046 
#define IDS_FAXSEC_JOB_SUB              1047
#define IDS_ADMIN_CONSOLE_TITLE         1048

//
// Device config page common controls
//
#define IDCSTATIC_AUTO_ANSWER           1050
#define IDC_STATIC_STORE_IN_FOLDER      1051
#define IDC_ICON_STORE_IN_FOLDER        1052
#define IDC_CSID                        1053
#define IDC_TSID                        1054
#define IDC_DEVICE_PROP_SEND            1055
#define IDC_DEVICE_LIST                 1056
#define IDC_DEVICE_PROP_RECEIVE         1057
#define IDC_STATIC_SELECT_MODEM         1058
#define IDC_COMBO_MODEM                 1059

//
// MAPI properties dialog common controls
//
#define IDC_PRINTER_LIST                1060
#define IDC_USE_COVERPAGE               1061
#define IDC_COVERPAGE_LIST              1062
#define IDC_SEND_SINGLE_RECEIPT         1063
#define IDC_ATTACH_FAX                  1064

//
// MAPI extension common strings
//
#define IDS_PERSONAL                    1070
#define IDS_NO_FAX_PRINTER              1071
#define IDS_CANT_ACCESS_SERVER          1072


#define IDS_SERVICE_NAME				1100
#define IDS_DEVICE						1101
#define IDS_ERR_DIR_TOO_LONG            1102

#define IDS_PATH_NOT_FOUND_ASK_CREATE       1103
#define IDS_PATH_NOT_FOUND_REMOTE_FAX       1104
#define IDS_PATH_NOT_FOUND_REMOTE_PATH      1105
#define IDS_PATH_NOT_FOUND_ENV_VAR          1106
#define IDS_FILE_ACCESS_DENIED_ASK_FIX      1107
#define IDS_FILE_ACCESS_DENIED_REMOTE_FAX   1108
#define IDS_FILE_ACCESS_DENIED_REMOTE_PATH  1109
#define IDS_FILE_ACCESS_DENIED_ENV_VAR      1110
#define IDS_FAX_MESSAGE_BOX_TITLE           1111 
#define IDS_PATH_NOT_VALID                  1112
#define IDS_FAX_ERR_DIRECTORY_IN_USE        1113
#define IDS_FOLDER_ACCESS_DENIED            1114

//////////////////////////////////////////////////////
//                                                  //
// THIS RESOURCE ID FILE IS PART OF FXSRES.DLL      //
//                                                  //
// ALL THE IDs SHOULD BE IN RANGE                   //
//                                                  //
// [100 - 1999]                                     //
//                                                  //
//////////////////////////////////////////////////////

#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\cfgwzrd\welcome.c ===
#include "faxcfgwz.h"

INT_PTR CALLBACK 
WelcomeDlgProc (
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Welcome" page

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    // Process messages from the Welcome page

    HWND            hwndControl;

#define WM_SETPAGEFOCUS WM_APP+2

//
// Property Sheet control id's (determined with Spy++)
// Taken from MFC StdAfx.h
//
#define ID_WIZNEXT      0x3024


    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            TCHAR   szText[1024] = {0}; // text for "Link Window"
            TCHAR   szTemp[1024] = {0};

            // Get the shared data from PROPSHEETPAGE lParam value
            // and load it into GWL_USERDATA
            
            // It's an intro/end page, so get the title font
            // from the shared data and use it for the title control

            Assert(g_wizData.hTitleFont);
            hwndControl = GetDlgItem(hDlg, IDCSTATIC_WELCOME_TITLE);
            SetWindowFont(hwndControl, g_wizData.hTitleFont, TRUE);

            // if there are more than one device, we'll show a warning that the wizard can
            // only config the devices into same settings.
            // will do it later.
            if((g_wizData.dwDeviceCount > 1) && !IsDesktopSKU())
            {
                // if error, we will not show the warning message.
                if(GetDlgItemText(hDlg, IDC_ADMINCONSOLE_LINK, szText, MAX_STRING_LEN))
                {
                    if(!LoadString(g_hResource, IDS_ADMIN_CONSOLE_LINK, szTemp, MAX_PATH - 1)) 
                    {
                        DEBUG_FUNCTION_NAME(TEXT("WelcomeDlgProc()"));
                        DebugPrintEx(DEBUG_ERR, 
                                     TEXT("LoadString failed: string ID=%d, error=%d"), 
                                     IDS_ADMIN_CONSOLE_LINK,
                                     GetLastError());
                        Assert(FALSE);
                    }
                    else
                    {
                        _tcsncat(szText, szTemp, ARR_SIZE(szText) - _tcslen(szText)-1);
                        SetDlgItemText(hDlg, IDC_ADMINCONSOLE_LINK, szText);
                    }
                }
            }

            PostMessage(hDlg, WM_SETPAGEFOCUS, 0, 0L);

            return TRUE;
        }
    case WM_SETPAGEFOCUS:
        {
            //
            // Set Focus on the Next button
            //
            HWND hNextButton = GetDlgItem(GetParent(hDlg), ID_WIZNEXT);
            if(hNextButton)
            {
                SetFocus(hNextButton);
            }
            break;
        }
    case WM_NOTIFY :
        {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
            {
            case PSN_SETACTIVE : //Enable the Next button    

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                PostMessage(hDlg, WM_SETPAGEFOCUS, 0, 0L);
                break;

            case PSN_WIZNEXT :
                //
                // Handle a Next button click here
                //
                SetLastPage(IDD_CFG_WIZARD_WELCOME);

                break;

            case PSN_RESET :                        
                break;

            case NM_RETURN:
            case NM_CLICK:

                if( IDC_ADMINCONSOLE_LINK == lpnm->idFrom )
                {
                    InvokeServiceManager(hDlg, g_hResource, IDS_ADMIN_CONSOLE_TITLE);
                }
                break;

            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\inc\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__

#include <mmc.h>
#include <commctrl.h>

#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,	
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		if (IS_SPECIAL_DATAOBJECT(pDataObj))
			return E_NOTIMPL;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(int n = 0) : m_nType(n)
	{
	}
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(&m_spConsole);
			if (FAILED(hr))
				ATLTRACE2(atlTraceSnapin, 0, _T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
			}
		}
		return hr;
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole.QueryInterface(&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE2(atlTraceSnapin, 0, _T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE2(atlTraceSnapin, 0, _T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
		HRESULT hr = E_POINTER;

		if (lpDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::Notify called with lpDataObject==NULL \n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			// Make sure that the object is derived from CSnapInObjectRoot
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, NULL, pT, type);
		}
		return hr;
	}
    
    STDMETHOD(Destroy)(LONG_PTR cookie)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(LONG_PTR cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}
    
    STDMETHOD(GetResultViewType)(LONG_PTR cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::GetResultViewType\n"));

		HRESULT hr = E_FAIL;
		if (cookie == NULL)
		{
			T* pT = static_cast<T*> (this);
			ATLASSERT( pT->m_pComponentData != NULL );
			ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
			hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
		}
		else
		{
			CSnapInItem* pItem = (CSnapInItem*)cookie;
			hr = pItem->GetResultViewType(ppViewType, pViewOptions);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE2(atlTraceSnapin, 0, _T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        long cookieA,
        long cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::AddMenuItems\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
		}
		return hr;
	}
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::Command\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
			
			if (SUCCEEDED(hr))
				hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
		}
		return hr;
	}
};

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT pDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
		}

		return hr;
	}
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor\n"));
		

		HRESULT hr = E_POINTER;
		
		ATLASSERT(pDataObject != NULL);
		if (pDataObject == NULL)
			ATLTRACE2(atlTraceSnapin, 0, _T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

			if (SUCCEEDED(hr))
				hr = pItem->QueryPagesFor(type);
		}
		return hr;
	}
};

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendControlbarImpl::ControlbarNotify\n"));

		CSnapInItem* pItem = NULL;
		DATA_OBJECT_TYPES type=CCT_UNINITIALIZED;
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);

		if (event == MMCN_BTN_CLICK)
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
		else if (event == MMCN_SELECT)
		{
			hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
			BOOL bSelect = (BOOL) HIWORD (arg);
			BOOL bScope = (BOOL) LOWORD(arg); 
			if (bSelect)
			{
				int n = pT->m_toolbarMap.GetSize();
				for (int i = 0; i < n; i++)
				{
					IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
					 if (pToolbar != NULL)
						pT->m_spControlbar->Detach(pToolbar);
				}
			}
		}

		if (SUCCEEDED(hr) && pItem)
			hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

		return hr;
	}
};

#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRootBase* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 <= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	void __stdcall CleanUp(DWORD dw)
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					USES_CONVERSION;
					ocscpy(wszMenuText, T2OLE(szMenuText));
					ocscpy(wszStatusBar, T2OLE(szStatusBar));

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
		IExtendControlbar* pExtendControlBar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::SetControlbar\n"));
		static bool m_bAddTermFunc = false;
		if (!m_bAddTermFunc)
		{
			m_bAddTermFunc = true;
			AtlModuleAddTermFunc(&_Module, CleanUpToolbarInfo, 0);
		}

		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}
		
			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					USES_CONVERSION;
					ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg, 
		LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			if (!bSelect)
				return S_OK;
			BOOL bScope = (BOOL) LOWORD(arg); 

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;
				pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							ENABLED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								ENABLED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *pfsState, BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, 
		bool& bHandled,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2(atlTraceSnapin, 0, _T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}
	static void _stdcall CleanUpToolbarInfo(ULONG_PTR dw)
	{
		for (CSnapInToolbarInfo* pInfo = T::GetToolbarInfo(); pInfo->m_idToolbar != 0; pInfo++)
		{
			pInfo->CleanUp(PtrToUlong(&dw));
		}
	}


	static const UINT GetMenuID() 
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\inc\faxschemaconst.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxSchemaConst.h                                       //
//                                                                         //
//  DESCRIPTION   : All strings must be used explicitly of                 //
//                  schema containers.                                     //
//                                                                         //
//                 Do not make any inclusion from this file to others      //
//                 since file included by setup files !!!                  //                                                                      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 16 1999 yossg   create                                         //
//                                                                         //
//  Copyright (C) 1999   Microsoft Corporation   All Rights Reserved       //
/////////////////////////////////////////////////////////////////////////////
#ifndef _H_FAXSCHEMACONST_H_
#define _H_FAXSCHEMACONST_H_

#define SCHEMA_DEVICEDEFAULTS_CONTAINER_NAME L"Fax-DeviceDefaults"

#endif //_H_FAXSCHEMACONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\bossmtpconfigdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgSMTPConfig.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the CBosSmtpConfigDlg class.              //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLG_BOS_SMTP_CONFIG_H_INCLUDED
#define DLG_BOS_SMTP_CONFIG_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CBosSmtpConfigDlg

class CBosSmtpConfigDlg :
             public CDialogImpl<CBosSmtpConfigDlg>
{
public:
    CBosSmtpConfigDlg();

    ~CBosSmtpConfigDlg();

    enum { IDD = IDD_DLG_BOS_SMTP_SET };

BEGIN_MSG_MAP(CBosSmtpConfigDlg)
    MESSAGE_HANDLER   ( WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER( IDOK,          OnOK)
    COMMAND_ID_HANDLER( IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    COMMAND_HANDLER( IDC_SMTP_USERNAME_EDIT, EN_CHANGE,  OnTextChanged)
    COMMAND_HANDLER( IDC_SMTP_PASSWORD_EDIT, EN_CHANGE,  OnPasswordChanged)

    COMMAND_HANDLER( IDC_SMTP_ANONIM_RADIO1, BN_CLICKED, OnRadioButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_BASIC_RADIO2,  BN_CLICKED, OnRadioButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_NTLM_RADIO3,   BN_CLICKED, OnRadioButtonClicked)
    
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT InitSmtpDlg(FAX_ENUM_SMTP_AUTH_OPTIONS enumAuthOption, BSTR bstrUserName, BOOL fIsUnderLocalUserAccount);

    LRESULT OnPasswordChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTextChanged (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    inline const CComBSTR&  GetUserName() { return  m_bstrUserName; }

    inline CComBSTR& GetPassword()
    {     
        return m_bstrPassword;

    }

    
    inline FAX_ENUM_SMTP_AUTH_OPTIONS GetAuthenticationOption()
    {
        return m_enumAuthOption;
    }

    inline BOOL IsPasswordModified()
    {
        return m_fIsPasswordDirty;
    }



private:
    //
    // Methods
    //
    VOID   EnableOK(BOOL fEnable);
    VOID   EnableBasicAuthenticationControls(BOOL state);

    BOOL   IsValidData(
                     BSTR bstrUserName, 
                     BSTR bstrPassword, 
                     /*[OUT]*/int *pCtrlFocus);

    //
    // Controls
    //
    CEdit     m_UserNameBox;
    CEdit     m_PasswordBox;

    //
    // members for data
    //
    BOOL      m_fIsPasswordDirty;

    CComBSTR  m_bstrUserName;
    CComBSTR  m_bstrPassword;
    BOOL      m_fIsUnderLocalUserAccount;
    
    FAX_ENUM_SMTP_AUTH_OPTIONS m_enumAuthOption;

    //
    // Dialog initialization state
    //
    BOOL      m_fIsDialogInitiated;

};

#endif // DLG_BOS_SMTP_CONFIG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\bossmtpconfigdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgSMTPConfig.cpp                                      //
//                                                                         //
//  DESCRIPTION   : The CBosSmtpConfigDlg class implements the                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "BosSmtpConfigDlg.h"
#include "DlgConfirmPassword.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <htmlHelp.h>
#include <faxreg.h>

/////////////////////////////////////////////////////////////////////////////
// CBosSmtpConfigDlg

CBosSmtpConfigDlg::CBosSmtpConfigDlg()
{

    m_fIsPasswordDirty         = FALSE;
    m_fIsDialogInitiated       = FALSE;

    m_fIsUnderLocalUserAccount = FALSE;
}

CBosSmtpConfigDlg::~CBosSmtpConfigDlg()
{
}



/*
 -  CBosSmtpConfigDlg::InitSmtpDlg
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call,
 *      and current assined devices own parameters
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
CBosSmtpConfigDlg::InitSmtpDlg (
    FAX_ENUM_SMTP_AUTH_OPTIONS  enumAuthOption, 
    BSTR                        bstrUserName, 
    BOOL                        fIsUnderLocalUserAccount)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::InitSmtpDlg"));
    
    HRESULT hRc = S_OK;
    
    m_enumAuthOption = enumAuthOption;

    m_fIsUnderLocalUserAccount = fIsUnderLocalUserAccount;
    
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrUserName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}

/*
 +  CBosSmtpConfigDlg::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CBosSmtpConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::OnInitDialog"));
    HRESULT hRc = S_OK;    

    
    
    //
    // Attach controls
    //
    m_UserNameBox.Attach(GetDlgItem(IDC_SMTP_USERNAME_EDIT));
    m_PasswordBox.Attach(GetDlgItem(IDC_SMTP_PASSWORD_EDIT));
        
    //
    // Set length limit to area code
    //
    //
    // Limit text length
    //
    m_UserNameBox.SetLimitText(FXS_MAX_USERNAME_LENGTH);
    m_PasswordBox.SetLimitText(FXS_MAX_PASSWORD_LENGTH);



    if (FAX_SMTP_AUTH_BASIC == m_enumAuthOption)
    {
        CheckDlgButton(IDC_SMTP_BASIC_RADIO2, BST_CHECKED);
        ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));

    }
    else // not FAX_SMTP_AUTH_BASIC
    {   
        //Graying all the authenticated access area
        EnableBasicAuthenticationControls(FALSE);

        
        if (FAX_SMTP_AUTH_ANONYMOUS == m_enumAuthOption)
        {
            CheckDlgButton(IDC_SMTP_ANONIM_RADIO1, BST_CHECKED);
        }
        else if ( FAX_SMTP_AUTH_NTLM == m_enumAuthOption )
        {
            CheckDlgButton(IDC_SMTP_NTLM_RADIO3, BST_CHECKED);
        }
        else
        {
            ATLASSERT(FALSE);
        }
    }
    

    m_UserNameBox.SetWindowText( m_bstrUserName);
    m_PasswordBox.SetWindowText( TEXT("******"));
    // Free Buffer in the destructor.

    if (!m_fIsUnderLocalUserAccount )
    {   
        //
        // Hide the dialog items
        //
		::ShowWindow(::GetDlgItem(m_hWnd, IDC_SMTP_NTLM_TIP_STATIC), SW_HIDE);	 
		::ShowWindow(::GetDlgItem(m_hWnd, IDC_SMTP_INFO_ICON), SW_HIDE);	 
	}
    else
    {
        ::EnableWindow(GetDlgItem(IDC_SMTP_NTLM_RADIO3), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SMTP_NTLM_STATIC), FALSE);
    }

    m_fIsDialogInitiated = TRUE;



    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CBosSmtpConfigDlg::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CBosSmtpConfigDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::OnOK"));
    HRESULT     hRc           = S_OK;

    CComBSTR    bstrUserName; 
    CComBSTR    bstrPassword;
    
    BOOL        fSkipMessage  = FALSE;
    int         CtrlFocus     = 0; 

    if (IsDlgButtonChecked(IDC_SMTP_BASIC_RADIO2) == BST_CHECKED)
    {
        
        //
        // Advanced authentication details
        //   
        if ( !m_UserNameBox.GetWindowText(&bstrUserName))
        {
            CtrlFocus = IDC_SMTP_USERNAME_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrUserName)"));
            hRc = E_OUTOFMEMORY;

            goto Error;
        }

        if (m_fIsPasswordDirty)
        {
            //
            // Only is the password changed, we collect the new text from the control.
            // Otherwise, we leave the string as NULL so that the server won't set it.
            //
            if ( !m_PasswordBox.GetWindowText(&bstrPassword))
            {
                CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
		        DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Failed to GetWindowText(&bstrPassword)"));

                hRc = E_OUTOFMEMORY;

                goto Error;
            }

            //
            // To avoid any non controled password insertion we ask for 
            // password confirmation
            //
            INT_PTR  rc = IDOK;
            WCHAR * pszNewPassword;
            CDlgConfirmPassword   DlgConfirmPassword;

            rc = DlgConfirmPassword.DoModal();
            if (rc != IDOK)
            {
		        DebugPrintEx(
			            DEBUG_MSG,
			            _T("Password confirmation canceled by the user."));
                goto Exit;
            }

            pszNewPassword = DlgConfirmPassword.GetPassword();

            ATLASSERT(NULL != pszNewPassword);

            if ( 0 != wcscmp( pszNewPassword , bstrPassword )  )
			{
		        DebugPrintEx(
			            DEBUG_MSG,
			            _T("The passwords entered are not the same."));
                
                DlgMsgBox(this, IDS_PASSWORD_NOT_MATCH, MB_OK|MB_ICONEXCLAMATION);
                
                goto Exit;
            }

        }    
    }
    
    //
    // Step 2: Input Validation
    //
    if (!IsValidData(bstrUserName, 
                     bstrPassword,
                     &CtrlFocus)
       )
    {
        hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        //in this case detailed message box was given by the called functions
        fSkipMessage = TRUE;
        
        goto Error;
    }

    //
    // Step 3: Set data to parent property page
    //
    if (IsDlgButtonChecked(IDC_SMTP_ANONIM_RADIO1) == BST_CHECKED)
    {
        m_enumAuthOption     = FAX_SMTP_AUTH_ANONYMOUS;
    }
    else 
    {
        if (IsDlgButtonChecked(IDC_SMTP_NTLM_RADIO3) == BST_CHECKED)
        {
            m_enumAuthOption = FAX_SMTP_AUTH_NTLM;
        }
        else // IsDlgButtonChecked(IDC_SMTP_BASIC_RADIO2) == BST_CHECKED
        {
            m_enumAuthOption = FAX_SMTP_AUTH_BASIC;
        }
        
        m_bstrUserName = bstrUserName;
        if (!m_bstrUserName)
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory: Failed to allocate m_bstrUserName"));
            hRc = E_OUTOFMEMORY;

            goto Error;
        }

        if (m_fIsPasswordDirty)
        {
            m_bstrPassword = bstrPassword;
            if (!m_bstrPassword)
            {
		        DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Out of memory: Failed to allocate m_bstrPassword"));
                hRc = E_OUTOFMEMORY;

                goto Error;
            }
        }
        // else
        // m_bstrPassword = NULL;
        // by default
    }

    //
    // Step 4: Close the dialog
    //
    ATLASSERT(S_OK == hRc );

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
	
    if (!fSkipMessage)
    {
        if (E_OUTOFMEMORY == hRc)
        {
            DlgMsgBox(this, IDS_MEMORY);
        }
        else
        {
            DlgMsgBox(this, IDS_FAIL2UPDATE_SMTP_CONFIG);
        }
    }
    ::SetFocus(GetDlgItem(CtrlFocus));
  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CBosSmtpConfigDlg::OnPasswordChanged
 -
 *  Purpose:
 *      Catch changes to the password edit box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CBosSmtpConfigDlg::OnPasswordChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::OnPasswordChanged"));

    if (!m_fIsDialogInitiated) // Event receieved in a too early stage
    {
        return 0;
    }
    m_fIsPasswordDirty = TRUE;
    return OnTextChanged (wNotifyCode, wID, hWndCtl, bHandled);
}

/*
 -  CBosSmtpConfigDlg::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text in side the text box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CBosSmtpConfigDlg::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::OnTextChanged"));

    UINT fEnableOK;
	
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    fEnableOK = ( m_UserNameBox.GetWindowTextLength() );
    
    EnableOK(!!fEnableOK);

    return 0;
}


/*
 -  CBosSmtpConfigDlg::OnRadioButtonClicked
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CBosSmtpConfigDlg::OnRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (wID);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::OnRadioButtonClicked"));

    UINT fEnableOK;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
	
    if ( IsDlgButtonChecked(IDC_SMTP_BASIC_RADIO2) == BST_CHECKED )
    {        
        EnableBasicAuthenticationControls(TRUE);
	    
        fEnableOK = ( m_UserNameBox.GetWindowTextLength() );
    
        EnableOK(!!fEnableOK);
    }
    else //Anonim or NTLM
    {
        EnableBasicAuthenticationControls(FALSE);
        
        EnableOK(TRUE);
    }

    return 0;
}


/*
 -  CBosSmtpConfigDlg::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CBosSmtpConfigDlg::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CBosSmtpConfigDlg::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CBosSmtpConfigDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::OnCancel"));

    EndDialog(wID);
    return 0;
}

/*
 -  CBosSmtpConfigDlg::EnableBasicAuthenticationControls
 -
 *  Purpose:
 *      Enable/dissable Basic Authentication dialog controls.
 *
 *  Arguments:
 *      [in] state - boolean value to enable TRUE or FALSE to disable
 *
 *  Return:
 *      void
 */
VOID CBosSmtpConfigDlg::EnableBasicAuthenticationControls(BOOL state)
{
    ::EnableWindow(GetDlgItem(IDC_SMTP_USERNAME_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_SMTP_USERNAME_EDIT),   state);
    
    ::EnableWindow(GetDlgItem(IDC_SMTP_PASSWORD_STATIC), state);
    ::EnableWindow(GetDlgItem(IDC_SMTP_PASSWORD_EDIT),   state);
}



/*
 -  CBosSmtpConfigDlg::IsValidData
 -
 *  Purpose:
 *      To validate all data types before save data.
 *      This level should be responsible that detailed 
 *      error description will be shown to user.
 *
 *  Arguments:
 *      [in]   BSTRs and DWORDs
 *      [out]  iFocus
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CBosSmtpConfigDlg::IsValidData(   BSTR bstrUserName, 
                                    BSTR bstrPassword,
                                    int * pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CBosSmtpConfigDlg::IsValidData"));

    UINT    uRetIDS   = 0;

    ATLASSERT(pCtrlFocus);
    

    if (IsDlgButtonChecked(IDC_SMTP_BASIC_RADIO2) == BST_CHECKED)
    {

        //
        // User Name
        //
        if (!IsNotEmptyString(bstrUserName))
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("Username string empty or spaces only."));
            uRetIDS = IDS_USERNAME_EMPTY;

            *pCtrlFocus = IDC_SMTP_USERNAME_EDIT;
        
            goto Error;
        }

        //
        // Password
        //
        if (m_fIsPasswordDirty)
        {
            /*if ( !IsNotEmptyString(bstrPassword))
            {
                DebugPrintEx( DEBUG_ERR,
			        _T("Password string empty or spaces only."));
                uRetIDS = IDS_PASSWORD_EMPTY;

                *pCtrlFocus = IDC_SMTP_PASSWORD_EDIT;
        
                goto Error;
            }*/
        }
    }
    
    ATLASSERT(0 == uRetIDS);
    goto Exit;
    
Error:    
    ATLASSERT(0 != uRetIDS);

    DlgMsgBox(this, uRetIDS);

    return FALSE;

Exit:
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CBosSmtpConfigDlg::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CBosSmtpConfigDlg::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CBosSmtpConfigDlg::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\cataloginboundroutingmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethod.h                          //
//                                                                         //
//  DESCRIPTION   : Header file for the InboundRoutingMethod node class.   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCATALOG_INBOUNDROUTINGMETHOD_H
#define H_FAXCATALOG_INBOUNDROUTINGMETHOD_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

#include "ppFaxCatalogInboundRoutingMethod.h"

class CppFaxCatalogInboundRoutingMethod;
class CFaxCatalogInboundRoutingMethodsNode;

class CFaxCatalogInboundRoutingMethodNode : public CSnapinNode <CFaxCatalogInboundRoutingMethodNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxCatalogInboundRoutingMethodNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_CMETHOD_MOVEUP,    OnMoveUp)
        SNAPINCOMMAND_ENTRY(IDM_CMETHOD_MOVEDOWN,  OnMoveDown)
        SNAPINCOMMAND_ENTRY(ID_MOVEUP_BUTTON,   OnMoveUp)
        SNAPINCOMMAND_ENTRY(ID_MOVEDOWN_BUTTON, OnMoveDown)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCatalogInboundRoutingMethodNode)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_METHOD_UD)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_CATALOGMETHOD_MENU)

    //
    // Constructor
    //
    CFaxCatalogInboundRoutingMethodNode (CSnapInItem * pParentNode, CSnapin * pComponentData, PFAX_GLOBAL_ROUTING_INFO pMethodConfig) :
        CSnapinNode<CFaxCatalogInboundRoutingMethodNode, FALSE>(pParentNode, pComponentData )
    {
    }

    //
    // Destructor
    //
    ~CFaxCatalogInboundRoutingMethodNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxCatalogInboundRoutingMethodsNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    HRESULT    Init(PFAX_GLOBAL_ROUTING_INFO pMethodConfig);

    VOID       SetOrder(DWORD dwOrder)  { m_dwPriority = dwOrder; return; }

    HRESULT    ReselectItemInView(IConsole *pConsole);

    void       UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    BOOL       UpdateToolbarButton(UINT id, BYTE fsState);

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFExtensionName;
    static CLIPFORMAT m_CFMethodGuid;
    static CLIPFORMAT m_CFServerName;
    static CLIPFORMAT m_CFDeviceId;

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxCatalogInboundRoutingMethodsNode * m_pParentNode;

    //
    // members
    //
    CComBSTR  m_bstrFriendlyName;       //pointer to method's user-friendly name
    CComBSTR  m_bstrExtensionFriendlyName; //pointer to DLL's user-friendly name
    DWORD     m_dwPriority;             
    CComBSTR  m_bstrMethodGUID;         //GUID that uniquely identifies 
    CComBSTR  m_bstrExtensionImageName; //pointer to DLL that implements method

    // currently not in use

    //CComBSTR  m_bstrDeviceName;         //pointer to device name
    //CComBSTR  m_bstrFunctionName;       //pointer to method's function name
    //DWORD     m_dwSizeOfStruct;         //structure size, in bytes
            
    CComBSTR  m_buf; 

    //
    // Menu item handlers
    //
    HRESULT OnMoveUp  (bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot);


    //
    //  Init
    //
    HRESULT  InitMembers (PFAX_GLOBAL_ROUTING_INFO pMethodConfig);
    
};

//typedef CSnapinNode<CFaxCatalogInboundRoutingMethodNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXCATALOG_INBOUNDROUTINGMETHOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\cataloginboundroutingmethod.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethod.cpp                        //
//                                                                         //
//  DESCRIPTION   : Implementation of the Inbound Routing Method node.     //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "CatalogInboundRoutingMethod.h"
#include "CatalogInboundRoutingMethods.h"

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"
#include "faxmmc.h"

/////////////////////////////////////////////////////////////////////////////
// {220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}
static const GUID CFaxCatalogInboundRoutingMethodNodeGUID_NODETYPE = 
{ 0x220d2cb0, 0x85a9, 0x4a43, { 0xb6, 0xe8, 0x9d, 0x66, 0xb4, 0x4f, 0x1a, 0xf5 } };

const GUID*     CFaxCatalogInboundRoutingMethodNode::m_NODETYPE        = &CFaxCatalogInboundRoutingMethodNodeGUID_NODETYPE;
const OLECHAR*  CFaxCatalogInboundRoutingMethodNode::m_SZNODETYPE      = OLESTR("220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5");
const CLSID*    CFaxCatalogInboundRoutingMethodNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFExtensionName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTEEXT_NAME);
CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFMethodGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTING_METHOD_GUID);
CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
CLIPFORMAT CFaxCatalogInboundRoutingMethodNode::m_CFDeviceId = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);



/*
 -  CFaxCatalogInboundRoutingMethodNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_GLOBAL_ROUTING_INFO
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::Init(PFAX_GLOBAL_ROUTING_INFO pMethodConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);

    hRc = InitMembers( pMethodConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    
    //
    // Icon
    //
    m_resultDataItem.nImage = IMAGE_METHOD_ENABLE;

Exit:
    return hRc;
}

/*
 -  CFaxCatalogInboundRoutingMethodNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_GLOBAL_ROUTING_INFO structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::InitMembers(PFAX_GLOBAL_ROUTING_INFO pMethodConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);
    
    m_dwPriority         = pMethodConfig->Priority;
    
    m_bstrDisplayName    = pMethodConfig->FriendlyName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrFriendlyName   = pMethodConfig->FriendlyName;
    if (!m_bstrFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrMethodGUID     = pMethodConfig->Guid;
    if (!m_bstrMethodGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrExtensionFriendlyName   
                         = pMethodConfig->ExtensionFriendlyName;
    if (!m_bstrExtensionFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrExtensionImageName   
                         = pMethodConfig->ExtensionImageName;
    if (!m_bstrExtensionImageName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxCatalogInboundRoutingMethodNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxCatalogInboundRoutingMethodNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    WCHAR buff[FXS_DWORD_LEN+1];
    int iCount;

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrFriendlyName);
            }

    case 1:
            //
            // Order
            //
            iCount = swprintf(buff, L"%ld", m_dwPriority);
    
            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory - Fail to allocate bstr."));
                goto Error;
            }
            else
            {
                m_buf = buff;
                if (!m_buf)
                {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to read member - m_dwPriority."));
                    hRc = E_OUTOFMEMORY;
                    goto Error;
                }
                return (m_buf);
            }

    case 2:
            //
            // Extension 
            //
            if (!m_bstrExtensionFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrExtensionFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrExtensionFriendlyName);
            }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxCatalogInboundRoutingMethodNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxCatalogInboundRoutingMethodNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::CreatePropertyPages"));
    
    HRESULT hRc = S_OK;

    HPROPSHEETPAGE hPage;
    CppFaxCatalogInboundRoutingMethod * pPropPageMethodGeneral = NULL;


    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    //
    // General
    //
    pPropPageMethodGeneral = new CppFaxCatalogInboundRoutingMethod(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

	if (!pPropPageMethodGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
    
    hRc = pPropPageMethodGeneral->Init(   //m_bstrMethodGUID,
                                          //m_bstrFriendlyName, 
                                          m_bstrExtensionImageName                                            
                                          //,m_bstrExtensionFriendlyName
                                       );
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
    
    hPage = pPropPageMethodGeneral->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pPropPageMethodGeneral ) 
    {
        delete  pPropPageMethodGeneral;    
        pPropPageMethodGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxCatalogInboundRoutingMethodNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
-  CFaxCatalogInboundRoutingMethodNode::OnMoveDown
-
*  Purpose:
*      Call to move down device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxCatalogInboundRoutingMethodNode::OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::OnMoveDown"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( 1 > m_dwPriority ) 
        ||
         ( dwMaxOrder < m_dwPriority+1 )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order down."));
        
        return (S_FALSE);
    }
    else
    {
        return(m_pParentNode->ChangeMethodPriority( 
                                    m_dwPriority, 
                                    m_dwPriority+1, 
                                    m_bstrMethodGUID,
                                    pRoot) );
    }
}

/*
-  CFaxCatalogInboundRoutingMethodNode::OnMoveUp
-
*  Purpose:
*      To move up in the view the device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxCatalogInboundRoutingMethodNode::OnMoveUp(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::OnMoveUp"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( dwMaxOrder < m_dwPriority )
        ||
         ( 1 > m_dwPriority-1 )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order up."));
        
        return (S_FALSE);
    }
    else
    {
        return (m_pParentNode->ChangeMethodPriority( m_dwPriority, 
                                                  m_dwPriority-1, 
                                                  m_bstrMethodGUID,
                                                  pRoot) );
    }
}


/*
 -  CFaxCatalogInboundRoutingMethodNode::ReselectItemInView
 -
 *  Purpose:
 *      Reselect the node to redraw toolbar buttons
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return: OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::ReselectItemInView(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::ReselectItemInView"));
    HRESULT     hRc = S_OK;

    //
    // Need IResultData
    //
    CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
    ATLASSERT(pResultData != NULL);

    //
    // Reselect the node to redraw toolbar buttons.
    //
    hRc = pResultData->ModifyItemState( 0, m_resultDataItem.itemID, LVIS_SELECTED | LVIS_FOCUSED, 0 );
    if ( S_OK != hRc )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failure on pResultData->ModifyItemState, (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);
        goto Exit;
    }

Exit:
    return hRc;
}

/*
 -  CFaxCatalogInboundRoutingMethodNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxCatalogInboundRoutingMethodNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    DWORD dwMaxPriority;
    
    switch (id)
    {
        case IDM_CMETHOD_MOVEUP:

            *flags = ((FXS_FIRST_METHOD_PRIORITY == m_dwPriority) ?  MF_GRAYED : MF_ENABLED );           

            break;

        case IDM_CMETHOD_MOVEDOWN:
            
            ATLASSERT(NULL != m_pParentNode);
            dwMaxPriority = m_pParentNode->GetMaxOrder();

            *flags = ((dwMaxPriority == m_dwPriority)  ?  MF_GRAYED : MF_ENABLED );

            break;

        default:
            break;
    }
    
    return;
}




/*
 -  CFaxCatalogInboundRoutingMethodNode::UpdateToolbarButton
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateToolbarButton
 *      This function aloow us to decide if to the activate\grayed a toolbar button  
 *      It treating only the Enable state.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int for the toolbar button ID
 *            [in]  fsState  - state to be cosidered ENABLE ?HIDDEN etc. 
 *
 *  Return:
 *     BOOL TRUE to activate state FALSE to disabled the state for this button 
 */
BOOL CFaxCatalogInboundRoutingMethodNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateToolbarButton"));
    BOOL bRet = FALSE;	
	    
    DWORD dwMaxPriority;

    // Set whether the buttons should be enabled.
    if (fsState == ENABLED)
    {

        switch ( id )
        {
            case ID_MOVEUP_BUTTON:

                bRet = ( (FXS_FIRST_METHOD_PRIORITY == m_dwPriority) ?  FALSE : TRUE );           

                break;

            case ID_MOVEDOWN_BUTTON:
                
                ATLASSERT(NULL != m_pParentNode);
                dwMaxPriority = m_pParentNode->GetMaxOrder();

                bRet = ( (dwMaxPriority == m_dwPriority)  ?  FALSE : TRUE);
                
                break;
        
            default:
                break;

        }

    }

    // For all other possible button ID's and states, 
    // the correct answer here is FALSE.
    return bRet;

}

/*
 +
 +
 *
 *  CFaxCatalogInboundRoutingMethodNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxCatalogInboundRoutingMethodNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;


    if (cf == m_CFExtensionName)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrExtensionImageName, 
                            sizeof(WCHAR)*(m_bstrExtensionImageName.Length()+1), 
                            &uWritten);
		return hr;
	}
	if (cf == m_CFMethodGuid)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrMethodGUID, 
                            sizeof(WCHAR)*(m_bstrMethodGUID.Length()+1), 
                            &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, 
                            sizeof(WCHAR)*(bstrServerName.Length()+1), 
                            &uWritten);
		return hr;
	}

    if (cf == m_CFDeviceId)
	{
                DWORD dwDeviceID = FXS_GLOBAL_METHOD_DEVICE_ID; //== 0 : Global incoming method sign
                hr = pStream->Write((VOID *)&dwDeviceID, sizeof(DWORD), &uWritten);
		return hr;
	}

    return CSnapInItemImpl<CFaxCatalogInboundRoutingMethodNode>::FillData(cf, pStream);
}   // CFaxCatalogInboundRoutingMethodNode::FillData

/*
 +
 +  CFaxCatalogInboundRoutingMethodNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCatalogInboundRoutingMethodNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_INBOUND_ROUTING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\cataloginboundroutingmethods.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethods.h                         //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Inbound Routing Methods Node   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCATALOG_INBOUNDROUTINGMETHODS_H
#define H_FAXCATALOG_INBOUNDROUTINGMETHODS_H

#include "snapin.h"
#include "snpnres.h"


#include "CatalogInboundRoutingMethod.h"
 
class CFaxInboundRoutingNode;
class CFaxCatalogInboundRoutingMethodNode;

class CFaxCatalogInboundRoutingMethodsNode : public CNodeWithResultChildrenList<
                                        CFaxCatalogInboundRoutingMethodsNode,    
                                        CFaxCatalogInboundRoutingMethodNode, 
                                        CSimpleArray<CFaxCatalogInboundRoutingMethodNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxCatalogInboundRoutingMethodNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCatalogInboundRoutingMethodNode)
    END_SNAPINTOOLBARID_MAP()

    //
    // Constructor
    //
    CFaxCatalogInboundRoutingMethodsNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxCatalogInboundRoutingMethodsNode, CFaxCatalogInboundRoutingMethodNode, CSimpleArray<CFaxCatalogInboundRoutingMethodNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_dwNumOfInboundMethods     = 0;
        m_fSuccess = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxCatalogInboundRoutingMethodsNode()
    {
    }

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitDisplayName();

    void InitParentNode(CFaxInboundRoutingNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT ChangeMethodPriority(DWORD dwOldOrder, DWORD dwNewOrder, CComBSTR bstrMethodGUID, CSnapInObjectRootBase *pRoot);

    DWORD   GetMaxOrder()   
                { return( m_fSuccess ? m_dwNumOfInboundMethods : 0); }

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    HRESULT InitRPC(PFAX_GLOBAL_ROUTING_INFO  *pFaxInboundMethodsConfig);

    static CColumnsInfo         m_ColsInfo;
    
    DWORD                       m_dwNumOfInboundMethods;
    
    CFaxInboundRoutingNode *    m_pParentNode;

    // Succeed to populate all methods
    BOOL                        m_fSuccess;  
};

typedef CNodeWithResultChildrenList<CFaxCatalogInboundRoutingMethodsNode, CFaxCatalogInboundRoutingMethodNode, CSimpleArray<CFaxCatalogInboundRoutingMethodNode*>, FALSE>
        CBaseFaxCatalogInboundRoutingMethodsNode;

#endif  //H_FAXCATALOG_INBOUNDROUTINGMETHODS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\coverpage.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPage.h                                            //
//                                                                         //
//  DESCRIPTION   : Header file for the cover page node.                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCOVERPAGE_H
#define H_FAXCOVERPAGE_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

class CFaxCoverPagesNode;

class CFaxCoverPageNode : public CSnapinNode <CFaxCoverPageNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxCoverPageNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_EDIT_COVERPAGE,  OnEditCoverPage)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCoverPageNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_COVERPAGE_MENU)

    //
    // Constructor
    //
    CFaxCoverPageNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxCoverPageNode, FALSE>(pParentNode, pComponentData )
    {
    }

    //
    // Destructor
    //
    ~CFaxCoverPageNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxCoverPagesNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);


    HRESULT OnEditCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot);
    
    
    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    virtual HRESULT OnDoubleClick(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type);

    HRESULT    Init(WIN32_FIND_DATA * pCoverPageConfig);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    void    UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

private:
    //
    // Parent Node
    //
    CFaxCoverPagesNode * m_pParentNode;

    //
    // members
    //
    CComBSTR               m_bstrTimeFormatted;
    CComBSTR               m_bstrFileSize;
    
};

//typedef CSnapinNode<CFaxCoverPageNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXCOVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\cataloginboundroutingmethods.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CatalogInboundRoutingMethods.cpp                       //
//                                                                         //
//  DESCRIPTION   : Fax InboundRoutingMethods MMC node.                    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 27 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "CatalogInboundRoutingMethods.h"
#include "InboundRouting.h"

#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {3452FECB-E56E-4fca-943D-E8B516F8063E}
static const GUID CFaxCatalogInboundRoutingMethodsNodeGUID_NODETYPE = 
{ 0x3452fecb, 0xe56e, 0x4fca, { 0x94, 0x3d, 0xe8, 0xb5, 0x16, 0xf8, 0x6, 0x3e } };

const GUID*    CFaxCatalogInboundRoutingMethodsNode::m_NODETYPE = &CFaxCatalogInboundRoutingMethodsNodeGUID_NODETYPE;
const OLECHAR* CFaxCatalogInboundRoutingMethodsNode::m_SZNODETYPE = OLESTR("3452FECB-E56E-4fca-943D-E8B516F8063E");
const CLSID*   CFaxCatalogInboundRoutingMethodsNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxCatalogInboundRoutingMethodsNode::m_ColsInfo;

/*
 -  CFaxCatalogInboundRoutingMethodsNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxCatalogInboundRoutingMethodsNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_CATALOG_INMETHODS_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_CATALOG_INMETHODS_COL2, AUTO_WIDTH},
        {IDS_CATALOG_INMETHODS_COL3, FXS_LARGE_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxCatalogInboundRoutingMethodsNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::InitRPC(PFAX_GLOBAL_ROUTING_INFO  *pFaxInboundMethodsConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    ATLASSERT(NULL == (*pFaxInboundMethodsConfig) );

    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    ATLASSERT(NULL != m_pParentNode);
    

    //
	// Retrieve the fax Inbound Methods configuration
	//
    if (!FaxEnumGlobalRoutingInfo(pFaxServer->GetFaxServerHandle(), 
                        pFaxInboundMethodsConfig,
                        &m_dwNumOfInboundMethods)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get inbound methods catalog. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }


        goto Error; 
    }
    //For max verification
    ATLASSERT(pFaxInboundMethodsConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get Inbound Methods configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxCatalogInboundRoutingMethodsNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxCatalogInboundRoutingMethodNode *   pMethod = NULL;
                       
    PFAX_GLOBAL_ROUTING_INFO  pFaxInboundMethodsConfig = NULL ;
    DWORD i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC(&pFaxInboundMethodsConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxInboundMethodsConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxInboundMethodsConfig);
                       
    for ( i=0; i< m_dwNumOfInboundMethods; i++ )
    {
            pMethod = new CFaxCatalogInboundRoutingMethodNode(this, 
                                            m_pComponentData, 
                                            &pFaxInboundMethodsConfig[i]);
            if (!pMethod)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pMethod->InitParentNode(this);

                hRc = pMethod->Init(&pFaxInboundMethodsConfig[i]);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to Init property page members. (hRc: %08X)"),
			            hRc);
		            // NodeMsgBox by called func.
                    goto Error;
	            }

	            hRc = this->AddChildToList(pMethod);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add property page for General Tab. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTINGMETHODS);
                    goto Error;
	            }
                else
                {
                    pMethod = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);

    //
    // Success ToPopulateAllDevices to allow 
    // giving total number of devices to each device
    // when asked for reordering purposes
    //
    m_fSuccess = TRUE;

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethod ) 
    {
        delete  pMethod;    
        pMethod = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pMethod = (CFaxCatalogInboundRoutingMethodNode *)
                                    m_ResultChildrenList[j];
            delete pMethod;
            pMethod = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    if (NULL != pFaxInboundMethodsConfig)
    {
        FaxFreeBuffer(pFaxInboundMethodsConfig);
    }       
    
    return hRc;
}



/*
 -  CFaxCatalogInboundRoutingMethodsNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxCatalogInboundRoutingMethodsNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxCatalogInboundRoutingMethodsNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Call the base class
    //
    hRc = CBaseFaxCatalogInboundRoutingMethodsNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Exit;
    }


Exit:
    return hRc;
}


/*
 -  CFaxCatalogInboundRoutingMethodsNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxCatalogInboundRoutingMethodsNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

/*
 -  CFaxCatalogInboundRoutingMethodsNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCatalogInboundRoutingMethodsNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_METHODSCATALOGNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}



/*
 -  CFaxCatalogInboundRoutingMethodsNode::ChangeMethodPriority
 -
 *  Purpose:
 *      This func moves up or down specific method in the catalog order
 *
 *  Arguments:
 *      [in] dwNewOrder - specifies the new order +1 /-1 inrelative to current order.
 *      [in] bstrMethodGUID - method GUID
 *      [in] pChildNode - the method node object.
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::ChangeMethodPriority(DWORD dwOldOrder, DWORD dwNewOrder, CComBSTR bstrMethodGUID, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCatalogInboundRoutingMethodsNode::ChangeMethodPriority"));

    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    const DWORD dwOldIndex = dwOldOrder-1;
    const DWORD dwNewIndex = dwNewOrder-1; 
    
    DWORD dwN;

    CFaxCatalogInboundRoutingMethodNode * pMethodNode = NULL;

    PFAX_GLOBAL_ROUTING_INFO pRoutingInfo     = NULL;

    PFAX_GLOBAL_ROUTING_INFO pPrimaryMethod;
    PFAX_GLOBAL_ROUTING_INFO pSecondaryMethod;

    CComPtr<IConsole> spConsole;

    //
    // Validity asserts
    //
    ATLASSERT(dwNewIndex< m_dwNumOfInboundMethods);
    ATLASSERT(dwNewIndex>= 0);
    ATLASSERT(dwOldIndex< m_dwNumOfInboundMethods);
    ATLASSERT(dwOldIndex>= 0);
    
    ATLASSERT( ( dwOldIndex-dwNewIndex == 1) 
                    || ( dwOldIndex-dwNewIndex == -1) );


    //
    // RPC change Order
    //   

    //
    // 0) get server handle
    //
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // 1) Get info
    //
    if (!FaxEnumGlobalRoutingInfo(pFaxServer->GetFaxServerHandle(), 
                      &pRoutingInfo,
					  &m_dwNumOfInboundMethods)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get inbound routing method catalog configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pRoutingInfo);

    //
    // 2) Swap priority between methods 
    //
    pPrimaryMethod   = NULL;
    pSecondaryMethod = NULL;

    for (dwN = 0; dwN < m_dwNumOfInboundMethods; dwN++)
    {
        if ( dwOldOrder == pRoutingInfo[dwN].Priority)
        {
            pPrimaryMethod = &pRoutingInfo[dwN];
        }
        else if ( dwNewOrder == pRoutingInfo[dwN].Priority )
        {
            pSecondaryMethod = &pRoutingInfo[dwN];
        }

        if ((NULL != pSecondaryMethod) && (NULL != pPrimaryMethod))
        {
            break;
        }
    }
    ATLASSERT( (NULL != pPrimaryMethod) && (NULL != pSecondaryMethod) );

    pPrimaryMethod->Priority   = dwNewOrder; 
    pSecondaryMethod->Priority = dwOldOrder; 


    //
    // 3) Set Configuration
    //
    
    //
    // Primary Method
    //
    if (!FaxSetGlobalRoutingInfo(
                        pFaxServer->GetFaxServerHandle(), 
                        pPrimaryMethod) ) 
	{
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set primary method with new priority. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        goto Error; 
    }
    
    
    //
    // Secondary Method
    //
	if (!FaxSetGlobalRoutingInfo(
                        pFaxServer->GetFaxServerHandle(), 
                        pSecondaryMethod) ) 
	{
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("set secondary method with new priority. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        goto Error; 
    }
    DebugPrintEx( DEBUG_MSG, _T("Fail to set primary method with new priority"));
    //Success of RPC operations
    
    
    //
    // 4) Now to MMC
    // 
    
    //
    // Local swap
    //
    pMethodNode = m_ResultChildrenList[dwOldIndex];
    m_ResultChildrenList[dwOldIndex] = m_ResultChildrenList[dwNewIndex];
    m_ResultChildrenList[dwNewIndex] = pMethodNode;

    //
    // Fix the order members
    //
    m_ResultChildrenList[dwOldIndex]->SetOrder(dwOldOrder);
    m_ResultChildrenList[dwNewIndex]->SetOrder(dwNewOrder);
    
    
    //
    // Get console
    //
    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }
    ATLASSERT(spConsole);
    
    //
    // UpdateAllViews
    //
    spConsole->UpdateAllViews(NULL, (LPARAM)this, NULL);

    //
    // Reselect the moved item in his new place
    //
    m_ResultChildrenList[dwNewIndex]->ReselectItemInView(spConsole);
        

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set devices new order for Outbound Routing group."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    if ( NULL != pRoutingInfo )
        FaxFreeBuffer(pRoutingInfo);

    return hRc;
}

/*
 +
 +  CFaxCatalogInboundRoutingMethodsNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCatalogInboundRoutingMethodsNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_INBOUND_ROUTING);
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\coverpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPage.cpp                                          //
//                                                                         //
//  DESCRIPTION   : Implementation of the cover page result node.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "CoverPage.h"
#include "CoverPages.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCPropertyChange.h"

#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"

#include <windows.h>
#include <shlwapi.h>
#include <faxreg.h>

/////////////////////////////////////////////////////////////////////////////
// {D0F52487-3C98-4d1a-AF15-4033900DCCDC}
static const GUID CFaxCoverPageNodeGUID_NODETYPE = 
{ 0xd0f52487, 0x3c98, 0x4d1a, { 0xaf, 0x15, 0x40, 0x33, 0x90, 0xd, 0xcc, 0xdc } };

const GUID*     CFaxCoverPageNode::m_NODETYPE        = &CFaxCoverPageNodeGUID_NODETYPE;
const OLECHAR*  CFaxCoverPageNode::m_SZNODETYPE      = OLESTR("D0F52487-3C98-4d1a-AF15-4033900DCCDC");
//const OLECHAR* CnotImplemented::m_SZDISPLAY_NAME = OLESTR("Cover Pages");
const CLSID*    CFaxCoverPageNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;


/*
 -  CFaxCoverPageNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pRuleConfig - PFAX_OUTBOUND_ROUTING_RULE
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPageNode::Init(WIN32_FIND_DATA * pCoverPageData)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::Init"));

    DWORD               ec          = ERROR_SUCCESS;

    _FILETIME           FileTime;
    SYSTEMTIME          SystemTime;
    TCHAR               szLastModifiedTimeStr[MAX_PATH+1];
    TCHAR               szDateBuf[MAX_PATH+1];    

    ULARGE_INTEGER      uliFileSize; 
    CHAR                szFileSize[MAX_PATH+1];

    CComBSTR            bstrDate;
    CComBSTR            bstrTime;


    ATLASSERT(pCoverPageData);

    m_bstrDisplayName = pCoverPageData->cFileName;
    if (!m_bstrDisplayName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        
        DebugPrintEx( DEBUG_ERR, 
            _T("Null m_bstrDisplayName - out of memory."));
        
        goto Error;
    }

    //
    // Last Modified
    //
    
    if (!FileTimeToLocalFileTime(
                &pCoverPageData->ftLastWriteTime,
                &FileTime
                )
       )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to convert LocalTimeToFileTime. (ec: %ld)"), 
            ec);

        goto Error;

    }

    if (!FileTimeToSystemTime(
                &FileTime, 
                &SystemTime)
       )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to convert FileTimeToSystemTime. (ec: %ld)"), 
            ec);

        goto Error;
    }

    //
    // a. Create a string specifying the date
    //
    if (!GetY2KCompliantDate (LOCALE_USER_DEFAULT,                  // Get user's locale
                        DATE_SHORTDATE,                             // Short date format
                        &SystemTime,                                // Source date/time
                        szDateBuf,                                  // Output buffer
                        sizeof(szDateBuf)/ sizeof(szDateBuf[0])     // MAX_PATH Output buffer size
                       ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to GetY2KCompliantDate. (ec: %ld)"), 
            ec);

        goto Error;
    }
    else
    {
        bstrDate = szDateBuf;
        if (!bstrDate)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
        
            DebugPrintEx( DEBUG_ERR, 
                _T("empty m_bstrTimeFormated - out of memory."));
        
            goto Error;
        }
    }
    //
    // b. Create a string specifying the time
    //
    if (!FaxTimeFormat(
              LOCALE_USER_DEFAULT,    //Locale
              TIME_NOSECONDS,         //dwFlags options
              &SystemTime,            //CONST SYSTEMTIME time
              NULL,                   //LPCTSTR lpFormat time format string
              szLastModifiedTimeStr,  //formatted string buffer
              sizeof(szLastModifiedTimeStr)/ sizeof(szLastModifiedTimeStr[0])// MAX_PATH// size of string buffer
              )
       )
    {
        ec = GetLastError();
        DebugPrintEx(
          DEBUG_ERR,
          _T("Fail to FaxTimeFormat. (ec: %ld)"), 
          ec);

        goto Error;
    }
    else
    {
        bstrTime = szLastModifiedTimeStr;
        if (!bstrTime)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
        
            DebugPrintEx( DEBUG_ERR, 
                _T("empty m_bstrTimeFormated - out of memory."));
        
            goto Error;
        }
    }
    
    m_bstrTimeFormatted =  bstrDate;
    m_bstrTimeFormatted += L" ";
    m_bstrTimeFormatted += bstrTime;
    
    //
    // Size
    //
    uliFileSize.LowPart  = pCoverPageData->nFileSizeLow;
    uliFileSize.HighPart = pCoverPageData->nFileSizeHigh;

    if (!StrFormatByteSize64A(
                              (LONGLONG) uliFileSize.QuadPart, 
                              szFileSize, 
                              sizeof(szFileSize)/ sizeof(szFileSize[0])
                             )
       )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to convert FileTimeToSystemTime. (ec: %ld)"), 
            ec);

        goto Error;
    }
    else
    {
        m_bstrFileSize = szFileSize;
    }
    
     
    //
    // Icon
    //
    m_resultDataItem.nImage = IMAGE_SRV_COVERPAGE;

    ATLASSERT(ERROR_SUCCESS == ec);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    DebugPrintEx(
        DEBUG_ERR,
        _T("Failed to init members"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_FAIL2INIT_COVERPAGE_DATA);
    }

    return HRESULT_FROM_WIN32(ec);
    
Exit:
    return S_OK;
}


/*
 -  CFaxCoverPageNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxCoverPageNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    switch (nCol)
    {
    case 0:
        //
        // Cover page file Name
        //
        if (!m_bstrDisplayName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Null memeber BSTR - m_bstrDisplayName."));
            goto Error;
        }
        else
        {
           return (m_bstrDisplayName);
        }

    case 1:
        //
        // Cover page Last Modified
        //
        if (!m_bstrTimeFormatted)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Null memeber BSTR - m_bstrTimeFormatted."));
            goto Error;
        }
        else
        {
           return (m_bstrTimeFormatted);
        }

    case 2:
        //
        // Cover page file size
        //
        if (!m_bstrFileSize)
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Null memeber BSTR - m_bstrFileSize."));
            
            goto Error;
        }
        else
        {
           return (m_bstrFileSize);
        }

    default:
        ATLASSERT(0); // "this number of column is not supported "
        return(L"");

    } // endswitch (nCol)

Error:
   return(L"???");

}

/*
 -  CFaxCoverPageNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPageNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Delete
    //

    hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
    
    //
    // No default verb
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE); 

    return hRc;
}


HRESULT CFaxCoverPageNode::OnDoubleClick(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME(
        _T("CFaxCoverPageNode::::OnDoubleClick -->> Edit CoverPage "));

    HRESULT                     hRc   = S_OK;
    
    bool                        bTemp = true; //UNREFERENCED_PARAMETER
    CSnapInObjectRootBase * pRootTemp = NULL; //UNREFERENCED_PARAMETER
    
    hRc = OnEditCoverPage(bTemp, pRootTemp);
    if ( S_OK != hRc )
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to call OnEditCoverPage(). (hRc : %08X)"),
            hRc);
        //msgbox by called func.        
    }

    // Maguire wrote in his code:
    // "Through speaking with Eugene Baucom, I discovered that if you return S_FALSE
    // here, the default verb action will occur when the user double clicks on a node.
    // For the most part we have Properties as default verb, so a double click
    // will cause property sheet on a node to pop up."
    //
    // Hence we return S_OK in any case for now

    return S_OK;
}

/*
 -  CFaxCoverPageNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPageNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    WCHAR       pszCovDir[MAX_PATH+1];
    CComBSTR    bstrFullPath;
    CComBSTR    bstrServerName;

    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        // 1. Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Exit;
        }
    }

    //
    // Prepere the file name to delete
    //    
    bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
    if (!bstrServerName)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Out of memory. Failed to get server name."));
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    if(!GetServerCpDir(bstrServerName, 
                       pszCovDir, 
                       sizeof(pszCovDir)/sizeof(pszCovDir[0])))                  
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to get Server Cover-Page Dir. (ec : %ld)"), ec);
        hRc = HRESULT_FROM_WIN32(ec);
        goto Error;
    }
    
    bstrFullPath = pszCovDir;
    if (!bstrFullPath)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to allocate string - out of memory"));

        goto Error;
    }
    bstrFullPath += FAX_PATH_SEPARATOR_STR;
    bstrFullPath += m_bstrDisplayName;
    
    //
    // Delete - done by parent node
    //
    hRc = m_pParentNode->DeleteCoverPage(bstrFullPath, this);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to delete cover page"));
        
        goto Error;
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    
    NodeMsgBox(IDS_FAIL2DELETE_COV);

Exit:
    return hRc;
}


/*
 -  CFaxCoverPageNode::OnEditCoverPage
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxCoverPageNode::OnEditCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::OnEditCoverPage"));

    UNREFERENCED_PARAMETER (pRoot);
    UNREFERENCED_PARAMETER (bHandled);

    DWORD       ec = ERROR_SUCCESS;
    TCHAR       tszServerCPDir[MAX_PATH * 4];
    TCHAR       tszQuotedFullCPFilePath[MAX_PATH * 4];
    
    if(!IsFaxComponentInstalled(FAX_COMPONENT_CPE))
    {
        return S_OK;
    }
    ATLASSERT(m_pParentNode);
    //
    // Prepare the filename of the cover page
    // Step1: Get full path
    //
    CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
    if (!bstrServerName)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Out of memory. Failed to get server name."));
        NodeMsgBox(IDS_MEMORY);
        return E_OUTOFMEMORY;
    }
    if (!GetServerCpDir (bstrServerName, tszServerCPDir, ARR_SIZE (tszServerCPDir)))
    {
        ec = GetLastError ();
        DebugPrintEx(DEBUG_ERR, _T("Error %ld when calling GetServerCpDir"), ec);
        NodeMsgBox(IDS_MEMORY);
        return HRESULT_FROM_WIN32(ec);
    }
    //
    // To avoid problems with space included file names like: "My Cover Page.cov"
    //
    if (0 >= wnsprintf (tszQuotedFullCPFilePath, 
                        ARR_SIZE (tszQuotedFullCPFilePath), 
                        TEXT("\"%s\\%s\""),
                        tszServerCPDir,
                        m_bstrDisplayName))
    {
        ec = ERROR_BUFFER_OVERFLOW;
        DebugPrintEx(DEBUG_ERR, _T("Error %ld when calling wnsprintf"), ec);
        NodeMsgBox(IDS_MEMORY);
        return HRESULT_FROM_WIN32(ec);
    }        
    //
    // Open cover page editor
    //
    ec = m_pParentNode->OpenCoverPageEditor(CComBSTR(tszQuotedFullCPFilePath)); 
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to OpenCoverPageEditor. (ec : %ld)"), ec);

        return HRESULT_FROM_WIN32( ec );
    }
    return S_OK;
}

/*
 +
 +  CFaxCoverPageNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCoverPageNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_COVER_PAGES);
}

/*
 -  CFaxCoverPageNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxCoverPageNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    switch (id)
    {
        case IDM_EDIT_COVERPAGE:

            *flags = IsFaxComponentInstalled(FAX_COMPONENT_CPE) ? MF_ENABLED : MF_GRAYED;
            break;

        default:
            break;
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\coverpages.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPages.cpp                                         //
//                                                                         //
//  DESCRIPTION   : The implementation of fax cover pages node.            //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "CoverPages.h"

#include "oaidl.h"
#include "Icons.h"

#include <faxreg.h>
#include <commdlg.h>

#include "CovNotifyWnd.h"

#include <FaxUtil.h>

//////////////////////////////////////////////////////////////
// {4D0480C7-3DE2-46ca-B03F-5C018DF1AF4D}
static const GUID CFaxCoverPagesNodeGUID_NODETYPE = 
{ 0x4d0480c7, 0x3de2, 0x46ca, { 0xb0, 0x3f, 0x5c, 0x1, 0x8d, 0xf1, 0xaf, 0x4d } };

const GUID*    CFaxCoverPagesNode::m_NODETYPE = &CFaxCoverPagesNodeGUID_NODETYPE;
const OLECHAR* CFaxCoverPagesNode::m_SZNODETYPE = OLESTR("4D0480C7-3DE2-46ca-B03F-5C018DF1AF4D");
const CLSID*   CFaxCoverPagesNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

//
// Static members
//
CColumnsInfo CFaxCoverPagesNode::m_ColsInfo;
HANDLE       CFaxCoverPagesNode::m_hStopNotificationThreadEvent = NULL;

/*
 -  CFaxCoverPagesNode::Init
 -
 *  Purpose:
 *      Create Event for shut down notification.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPagesNode::Init()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::Init"));
    HRESULT         hRc = S_OK;
    DWORD           ec  = ERROR_SUCCESS;

    //
    // Get Sever Cover-page Dir for the current administrated server
    //    
    CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
    if (!bstrServerName)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Out of memory. Failed to get server name."));
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }

    if(!GetServerCpDir(bstrServerName, 
			           m_pszCovDir, 
                       sizeof(m_pszCovDir)/sizeof(m_pszCovDir[0])                   //*//
                       )
      )
    {
        ec = GetLastError();
        
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Failed to find Server Cover-Page Dir. (ec : %ld)"), ec);

        }
        else
        {
            DebugPrintEx(
		        DEBUG_ERR,
		        _T("Failed to get Server Cover-Page Dir. (ec : %ld)"), ec);
        }
        
        hRc = HRESULT_FROM_WIN32(ec);
        
        goto Exit;
    }

    
    //
    // Create the shutdown event. This event will be signaled when the app is
    // about to quit.
    //
    if (NULL != m_hStopNotificationThreadEvent) // can happen while retargeting
    {
        hRc = RestartNotificationThread();
        if (S_OK != hRc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Fail to RestartNotificationThread."));
            
        }
    }
    else //first time here.
    {
        m_hStopNotificationThreadEvent = CreateEvent (NULL,       // No security
                                        TRUE,       // Manual reset
                                        FALSE,      // Starts clear
                                        NULL);      // Unnamed
        if (NULL == m_hStopNotificationThreadEvent)
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Fail to CreateEvent."));
        
            //CR: NodeMsgBox(IDS_FAIL2CREATE_EVENT);
        
            hRc = HRESULT_FROM_WIN32(ec);

            goto Exit;
        }
    }


Exit:
    return hRc;
}



/*
 -  CFaxCoverPagesNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxCoverPagesNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_COVERPAGES_COL1, FXS_NORMAL_COLUMN_WIDTH},
        {IDS_COVERPAGES_COL2, FXS_NORMAL_COLUMN_WIDTH},
        {IDS_COVERPAGES_COL3, FXS_NORMAL_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxCoverPagesNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPagesNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxCoverPageNode *   pCoverPage = NULL;
                       
    WCHAR           szFileName[MAX_PATH+1];

    size_t          itFullDirectoryPathLen;
    TCHAR*          pFullDirectoryPathEnd; //pointer to the NULL after dir path with '\'

    WIN32_FIND_DATA findData;

    DWORD           ec;
    BOOL            bFindRes;
    HANDLE          hFile = INVALID_HANDLE_VALUE;

    szFileName[0]= 0;


    ATLASSERT (NULL != m_pszCovDir );
    ATLASSERT ( wcslen(m_pszCovDir) < (MAX_PATH - sizeof(FAX_COVER_PAGE_FILENAME_EXT)/sizeof(WCHAR) - 1) ); 

    //
    // Create cover page mask 
    //
    wcscpy(szFileName, m_pszCovDir);
    wcscat(szFileName, FAX_PATH_SEPARATOR_STR);

    itFullDirectoryPathLen = wcslen(szFileName);
    pFullDirectoryPathEnd = wcschr(szFileName, L'\0');

    wcscat(szFileName, FAX_COVER_PAGE_MASK);

    //
    // Find First File
    //    
    hFile = FindFirstFile(szFileName, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        ec = GetLastError();
        if(ERROR_FILE_NOT_FOUND != ec)
        {
            hRc = HRESULT_FROM_WIN32(ec);
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("FindFirstFile Failed. (ec: %ld)"), 
			    ec);
            goto Error;
        }
        else
        {
            DebugPrintEx( DEBUG_MSG,
		        _T("No server cover pages were found."));
            goto Exit;
        }
    }
    
    //
    // while loop - add cover pages to the result pane view
    //
    bFindRes = TRUE;
    while(bFindRes)
    {
        if(itFullDirectoryPathLen + _tcslen(findData.cFileName) < MAX_PATH )
        {
            _tcsncpy(pFullDirectoryPathEnd, findData.cFileName, MAX_PATH - itFullDirectoryPathLen);
            
            if (IsValidCoverPage(szFileName)) 
            {
		    
                    //
                    // add the cover page to result pane
                    //
                    pCoverPage = NULL;

                    pCoverPage = new CFaxCoverPageNode(this, m_pComponentData);
                    if (!pCoverPage)
                    {
                        hRc = E_OUTOFMEMORY;
                        NodeMsgBox(IDS_MEMORY);
                        DebugPrintEx(
	                        DEBUG_ERR,
	                        _T("Out of memory. (hRc: %08X)"),
	                        hRc);
                        goto Error;
                    }
                    else
                    {
                    //
                    // Init
                    //
                    pCoverPage->InitParentNode(this);

                    hRc = pCoverPage->Init(&findData);
                    if (FAILED(hRc))
                    {
	                    DebugPrintEx(
	                    DEBUG_ERR,
	                    _T("Fail to init cover page. (hRc: %08X)"),
	                    hRc);
	                    // done by called func NodeMsgBox(IDS_FAIL2INIT_COVERPAGE_DATA);

	                    goto Error;
                    }
                    //
                    // add to list
                    //

                    hRc = this->AddChildToList(pCoverPage);
                    if (FAILED(hRc))
                    {
                      DebugPrintEx(
	                    DEBUG_ERR,
	                    _T("Fail to add property page for General Tab. (hRc: %08X)"),
	                    hRc);

                      NodeMsgBox(IDS_FAIL2ADD_COVERPAGE);
		                      goto Error;
                    }
                    else
                    {
	                    pCoverPage = NULL;
                    }
		        }
	        }
            else
            {
                DebugPrintEx(
	                DEBUG_ERR,
	                _T("File %ws was found to be an invalid *.cov file."), pFullDirectoryPathEnd);
            }
        }
        else
        {
            DebugPrintEx(
	            DEBUG_ERR,
	            _T("The file %ws path is too long"), pFullDirectoryPathEnd);
        }

        //
        // Find Next File
        //
        bFindRes = FindNextFile(hFile, &findData);
        if(!bFindRes)
        {
            ec = GetLastError();
            if (ERROR_NO_MORE_FILES == ec)
            {
            	break;
            }
            else
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   _T("FindNexTFile Failed. (ec: %ld)"),
                   ec);

                hRc = HRESULT_FROM_WIN32(ec);		

                goto Exit;
            }
        }
    } //while(bFindRes)
    
    
    //
    // Create the Server's Cover-Page Directory listener notification thread
    //

    if (m_bIsFirstPopulateCall)
    {
        m_NotifyWin = new CFaxCoverPageNotifyWnd(this);
        if (!m_NotifyWin)
        {
            hRc = E_OUTOFMEMORY;
            NodeMsgBox(IDS_MEMORY);
		    
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Out of memory."));
            
            goto Exit;
        }


        RECT	rcRect;
        ZeroMemory(&rcRect, sizeof(rcRect));

        HWND hWndNotify = m_NotifyWin->Create(NULL,
                                rcRect,
                                NULL,      //LPCTSTR szWindowName
                                WS_POPUP,  //DWORD dwStyle
                                0x0,
                                0);

        if (!(::IsWindow(hWndNotify)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Failed to create window."));

            hWndNotify = NULL;
            delete m_NotifyWin;
            m_NotifyWin = NULL;

            goto Exit;
        }

        hRc = StartNotificationThread();
        if( S_OK != hRc)
        {
            //DbgPrint by Called Func.
            m_NotifyWin->DestroyWindow();
            delete m_NotifyWin;
            m_NotifyWin = NULL;

            goto Exit;
        }

        //
        // Update boolean member
        //
        m_bIsFirstPopulateCall = FALSE;

        DebugPrintEx(
            DEBUG_MSG,
            _T("Succeed to create server cover-page directory listener thread and to create notification window"));
    }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pCoverPage ) 
    {
        delete  pCoverPage;    
        pCoverPage = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pCoverPage = (CFaxCoverPageNode *)
                                    m_ResultChildrenList[j];
            ATLASSERT(pCoverPage);
            delete pCoverPage;
            pCoverPage = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (!FindClose(hFile))
        {
            DebugPrintEx(
                DEBUG_MSG,
                _T("Failed to FindClose()(ec: %ld)"),
            GetLastError());
        }
    }

    
    return hRc;
}



/*
 -  CFaxCoverPagesNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxCoverPagesNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxCoverPagesNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::OnRefresh"));
    HRESULT hRc = S_OK;

    //
    // Call the base class (do also repopulate)
    //
    hRc = CBaseFaxOutboundRulesNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Exit;
    }


Exit:
    return hRc;

}

/*
 -  CFaxCoverPagesNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxCoverPagesNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate children
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

HRESULT
CFaxCoverPagesNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::DoRefresh()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Repopulate children
    //
    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, FXS_HINT_DELETE_ALL_RSLT_ITEMS);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews (clear)."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }
    
    RepopulateResultChildrenList();

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }

    return hRc;
}

/*
 -  CFaxCoverPagesNode::OnNewCoverPage
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxCoverPagesNode::OnNewCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::OnNewCoverPage"));
    
UNREFERENCED_PARAMETER (pRoot);
    UNREFERENCED_PARAMETER (bHandled);

    DWORD     ec         =    ERROR_SUCCESS;
        
    ec = OpenCoverPageEditor(CComBSTR(L""));
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Fail to OpenCoverPageEditor. (ec : %ld)"), ec);

        return HRESULT_FROM_WIN32( ec );
    }
    return S_OK;
}



/*
 -  CFaxCoverPagesNode::OpenCoverPageEditor
 -
 *  Purpose:
 *      Delete cover page
 *
 *  Arguments:
 *      [in]    bstrFileName -         The cover page file name
 *
 *  Assumption:
 *              Setup prepares a shortcut to the cover page editor in the 
 *              registry "App Path". Due to this fact ShellExecute needs only the 
 *              file name of the editor and not its full path.
 *  Return:
 *      Standard Win32 error code
 */
DWORD 
CFaxCoverPagesNode::OpenCoverPageEditor( BSTR bstrFileName)
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::OpenCoverPageEditor"));
    DWORD       dwRes                   = ERROR_SUCCESS;
    
    CComBSTR    bstrCovEditor;

    HINSTANCE   hCovEditor;

    //
    // get cover pages editor file
    //

    bstrCovEditor = FAX_COVER_IMAGE_NAME;
    if (!bstrCovEditor)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to allocate string - out of memory"));

        goto Exit;
    }
	
    
    //
    // start cover page editor
    //
    hCovEditor = ShellExecute(   NULL, 
                                 TEXT("open"),  // Command 
                                 bstrCovEditor,   
                                 (bstrFileName && lstrlen(bstrFileName)) ? // Do we have a file name?
                                    bstrFileName :          // YES - use it as command line argument
                                    TEXT("/Common"),        // NO  - start the CP editor in the common CP folder 
                                 m_pszCovDir, 
                                 SW_RESTORE 
                              );
    if( (DWORD_PTR)hCovEditor <= 32 )
    {
        // ShellExecute fail
        dwRes = PtrToUlong(hCovEditor);
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to run ShellExecute. (ec : %ld)"), dwRes);

        goto Exit;
    }

        
    ATLASSERT( ERROR_SUCCESS == dwRes);

Exit:
    return dwRes;

} 


/*
 -  CFaxCoverPagesNode::OnAddCoverPageFile
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxCoverPagesNode::OnAddCoverPageFile(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::OnAddCoverPageFile"));
    HRESULT   hRc        =    S_OK;
    DWORD     ec         =    ERROR_SUCCESS;
    

    //
    // Function Call: browse and copy a cover page
    //
    if (!BrowseAndCopyCoverPage(
                            m_pszCovDir,
                            FAX_COVER_PAGE_EXT_LETTERS
                           ) 
       )
    {
        DebugPrintEx(
		    DEBUG_MSG,
		    _T("BrowseAndCopyCoverPage Canceled by user or Failed."));
        
        return S_OK; //error is teated in the called func. MMC continue as usual.

    }
    else  //Success
    {
        //
        // Repopulate: refresh the entire cover page result pane view
        //

        DoRefresh(pRoot);
    }

    return S_OK;
}


/*
 -  CFaxCoverPagesNode::BrowseAndCopyCoverPage
 -
 *  Purpose:
 *      Presents a common file open dialog for the purpose of selecting a file name
 *
 *  Arguments:
 *      [in]   pInitialDir - server cover page directory path
 *      [in]   pCovPageExtensionLetters - cover page's 3 leeters extension
 *
 *  Return:
 *      TRUE   - got a good file name, user pressed the OK button to override file, file was copy
 *      FALSE  - got nothing or user pressed the CANCEL button, or error occures.
 *
 *   the FileName is changed to have the selected file name.
 */

BOOL
CFaxCoverPagesNode::BrowseAndCopyCoverPage(
    LPTSTR pInitialDir,
    LPWSTR pCovPageExtensionLetters
    )

{   
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::BrowseAndCopyCoverPage"));

    DWORD   dwError = ERROR_SUCCESS;
    HRESULT ret     = S_OK;

    WCHAR   filter[FXS_MAX_TITLE_LEN] = {0};
    WCHAR   filename[MAX_PATH];
    WCHAR   ftitle[MAX_PATH];
    WCHAR   title[FXS_MAX_TITLE_LEN];
    
    TCHAR   szDestinationFilePath[MAX_PATH] = {0};
    TCHAR   szServerCoverPagePath[MAX_PATH];

    LPTSTR  pExtension;
    LPTSTR  pFilename;
    INT     n;

    OPENFILENAME of;
    
    //
    // (1) Init
    //

    //
    // Check in parameters
    //
    ATLASSERT( NULL != pInitialDir && 0 != pInitialDir[0] ); 
    ATLASSERT( NULL != pInitialDir && sizeof(FAX_COVER_PAGE_EXT_LETTERS)/sizeof(WCHAR) != _tcslen(pCovPageExtensionLetters) ); 
    
    //
    // Prepare parameters for the copy operation (later)
    //
    n = _tcslen(pInitialDir); 
    
	wcscpy(szServerCoverPagePath , pInitialDir);
 
    //
    // Prepare the OPENFILE structure fields 
    //

    // Compose the file-type filter string
    if (::LoadString(_Module.GetResourceInstance(), IDS_CP_FILETYPE, title, FXS_MAX_TITLE_LEN) == 0)
    {
        NodeMsgBox(IDS_MEMORY);
        return FALSE;
    }

    _snwprintf(filter, 
               ARR_SIZE(filter)-1, 
               TEXT("%s (%s)%c%s%c%c"), 
               title, 
               FAX_COVER_PAGE_MASK, 
               NUL, 
               FAX_COVER_PAGE_MASK, 
               NUL, 
               NUL);

    if (::LoadString(_Module.GetResourceInstance(), IDS_BROWSE_COVERPAGE, title, FXS_MAX_TITLE_LEN) == 0)
    {
        NodeMsgBox(IDS_MEMORY);
        return FALSE;
    }
    
    filename[0] = NUL;
    ftitle[0]   = NUL;

    //
	// Init the OPENFILE structure
	//
	
	of.lStructSize       = sizeof( OPENFILENAME );
    of.hwndOwner         = NULL;                                                    
    of.hInstance         = GetModuleHandle( NULL );
    of.lpstrFilter       = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter    = 0;
    of.nFilterIndex      = 1;
    of.lpstrFile         = filename;
    of.nMaxFile          = MAX_PATH;
    of.lpstrFileTitle    = ftitle;
    of.nMaxFileTitle     = MAX_PATH;
    of.lpstrInitialDir   = pInitialDir;
    of.lpstrTitle        = title;
    of.Flags             = OFN_EXPLORER | OFN_HIDEREADONLY |
                           OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;                   //OFN_ENABLEHOOK ;
    of.nFileOffset       = 0;
    of.nFileExtension    = 0;
    of.lpstrDefExt       = pCovPageExtensionLetters;
    of.lCustData         = 0;
    of.lpfnHook          = NULL;                                                    //BrowseHookProc;
    of.lpTemplateName    = NULL;


    //
    // (2) Call the "Open File" dialog
    //
    if (! GetOpenFileName(&of))
    {
        DebugPrintEx(
		    DEBUG_MSG,
		    _T("GetOpenFileName was canceled by user."));

        return FALSE;
    }

    //
    // (3) Check the output of the source path, filename and extension
    //

    //
    //     a. Make sure the selected filename has the correct extension
    //

    //
    //        Find the filename portion given a filename:
    //        return a pointer to the '.' character if successful
    //        NULL if there is no extension
    //

    pFilename  = &filename[of.nFileOffset];
    
    pExtension = _tcsrchr(filename, _T('.'));
    if (
         (pExtension == NULL) 
        ||
         (_tcsicmp(pExtension, FAX_COVER_PAGE_FILENAME_EXT) != EQUAL_STRING)
       )
    {
        NodeMsgBox(IDS_BAD_CP_EXTENSION);
        return FALSE;
    }

    //
    //     b. Check if the selected file directory is the 
    //        default server cover page directory
    //

    if (_tcsnicmp(filename, szServerCoverPagePath, n) == EQUAL_STRING) 
    {
        NodeMsgBox(IDS_CP_DUPLICATE);  //YESNO
        
        // Work was already done. We are leaving...
        goto Exit;
    }

    //
    //        The check if the selected file is already inside the
    //        cover page directory is done with the copy operation itself.
    //

    //
    //        The check if the destination cover page directory exists done 
    //        while the copy operation itself.
    //


    
    //
    // (4) Copy the selected cover page file to the Server Cover page directory
    //
    
    //
    //     a. prepare from pSelected the destination path 
    //
    
    


    if (n + 1 + _tcslen(pFilename) >= MAX_PATH  || pFilename >= pExtension) 
    {
        NodeMsgBox(IDS_FILENAME_TOOLONG);
        return FALSE;
    }
    _snwprintf(szDestinationFilePath, 
               ARR_SIZE(szDestinationFilePath)-1, 
               TEXT("%s%s%s%c"), 
               szServerCoverPagePath, 
               FAX_PATH_SEPARATOR_STR, 
               pFilename, 
               NUL);

    //
    //     b. Copy the selected cover page file 
    //        to the server cover page default directory
    //
    if (!CopyFile(filename, szDestinationFilePath, TRUE)) 
    {
        dwError = GetLastError();
        if ( ERROR_FILE_EXISTS == dwError)
        {
            DebugPrintEx(DEBUG_MSG,
			    _T("Copy cover page already exists at destination."));

            ret = NodeMsgBox(IDS_CP_DUP_YESNO, MB_YESNO | MB_ICONQUESTION );
            if ((HRESULT)IDYES == ret)
            {
                //Copy any way
                if (!CopyFile(filename, szDestinationFilePath, FALSE)) 
                {
                    dwError = GetLastError();
                    DebugPrintEx(DEBUG_ERR,
			            _T("Copy cover page Failed (ec = %ld)."), dwError);

                    NodeMsgBox(IDS_FAILED2COPY_COVERPAGE);

                    return FALSE;
                }
                DebugPrintEx(DEBUG_MSG,
			        _T("Copy cover page done any way."));
            }
            else  //ret == IDNO
            {
                DebugPrintEx(DEBUG_MSG,
			        _T("Copy cover page was canceled by user due to file existance at destination."));
                //lets stay friends even after this operation cancel..
				return TRUE;
            }
        } //dwError != ERROR_FILE_EXISTS
        else
        {
            DebugPrintEx(DEBUG_ERR,
			    _T("Copy cover page Failed (ec = %ld)."), dwError);
            NodeMsgBox(IDS_FAILED2COPY_COVERPAGE);
            return FALSE;
        }
    }
    
Exit:

    return TRUE;
}


/*
 -  CFaxCoverPagesNode::DeleteCoverPage
 -
 *  Purpose:
 *      Delete cover page
 *
 *  Arguments:
 *      [in]    bstrName - The cover page full path
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxCoverPagesNode::DeleteCoverPage(BSTR bstrName, CFaxCoverPageNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::DeleteRule"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    
    ATLASSERT(bstrName);
    ATLASSERT(pChildNode);
    
        
    if (!DeleteFile(bstrName)) 
    {
        ec = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to DeleteFile. (ec: %ld)"),
			ec);

        goto Error;
    } 
    

    //
    // Remove from MMC result pane
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove rule. (hRc: %08X)"),
			hRc);
        //NodeMsgBox by Caller func.
        return hRc;
    }
    
    //
    // Call the group destructor
    //
    delete pChildNode;
    
    
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was removed successfully."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    //NodeMsgBox by Caller func.;
  
Exit:
    return hRc;
}



/*
 -  CFaxCoverPagesNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displayed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxCoverPagesNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_COVERPAGES))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}
  
/*
 -  CFaxCoverPagesNode::NotifyThreadProc
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *          [in]    - pointer to the Fax Cover-Pages Node
 *  Return:
 *      WIN32 error code
 */
DWORD WINAPI CFaxCoverPagesNode::NotifyThreadProc ( LPVOID lpParameter)
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::NotifyThreadProc"));
    DWORD    dwRes   = ERROR_SUCCESS;
    HRESULT  hRc     = S_OK;

    CFaxCoverPagesNode *pCovFolder = (CFaxCoverPagesNode *)lpParameter;

    ATLASSERT (pCovFolder);


    HANDLE hWaitHandles[2];    
    DWORD dwNotifyFilter = FILE_NOTIFY_CHANGE_FILE_NAME | 
                           FILE_NOTIFY_CHANGE_SIZE      | 
                           FILE_NOTIFY_CHANGE_LAST_WRITE;
    //
    // register for a first folder notification
    //
    hWaitHandles[0] = FindFirstChangeNotification(
                                        pCovFolder->m_pszCovDir, 
                                        FALSE, 
                                        dwNotifyFilter);
    if(INVALID_HANDLE_VALUE == hWaitHandles[0])
    {
        dwRes = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to FindFirstChangeNotification. (ec : %ld)"), 
            dwRes);

        return dwRes;
    }

    while(TRUE)
    {
        hWaitHandles[1] = m_hStopNotificationThreadEvent;
        if (NULL == hWaitHandles[1])
        {
            //
            // We're shutting down
            //
            goto Exit;
        }

        //
        // wait for folder notification or shutdown
        //
		dwRes = WaitForMultipleObjects(2, hWaitHandles, FALSE, INFINITE);

        switch (dwRes)
        {
        case WAIT_OBJECT_0:

            //
            // folder notification 
            //
            if(NULL != pCovFolder->m_NotifyWin && pCovFolder->m_NotifyWin->IsWindow())
            {
                if ( !pCovFolder->m_NotifyWin->PostMessage(WM_NEW_COV))
                {
		            DebugPrintEx(DEBUG_ERR,
			            _T("Fail to PostMessage"));
                    
                    // do not exit. continue!
                }
            }

            break;


        case WAIT_OBJECT_0 + 1:
            //
            // Shutdown is now in progress
            //
		    DebugPrintEx(
			    DEBUG_MSG,
			    _T("Shutdown in progress"));

            dwRes = ERROR_SUCCESS;
            goto Exit;

        case WAIT_FAILED:
            dwRes = GetLastError();
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to WaitForMultipleObjects. (ec : %ld)"), 
                dwRes);

            goto Exit;

        case WAIT_TIMEOUT:
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Reach WAIT_TIMEOUT in INFINITE wait!"));

            ATLASSERT(FALSE);

            goto Exit;
        default:
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed. Unexpected error (ec : %ld)"), 
                dwRes);

            ATLASSERT(0);
            goto Exit;
        }

        //
        // register for a next folder notification
        //
        if(!FindNextChangeNotification(hWaitHandles[0]))
        {
            dwRes = GetLastError();
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to FindNextChangeNotification (ec : %ld)"), 
                dwRes);

            goto Exit;
        }
    }


Exit:
    //
    // close notification handel
    //
    if(!FindCloseChangeNotification(hWaitHandles[0]))
    {
        dwRes = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to FindCloseChangeNotification. (ec : %ld)"), 
            dwRes);
    }

    return dwRes;

} // NotifyThreadProc



/*
 -  CFaxCoverPagesNode::StartNotificationThread
 -
 *  Purpose:
 *      Start the server cover page directory listning thread.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::StartNotificationThread()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::StartNotificationThread"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    //
    // create thread
    //
    DWORD dwThreadId;
    m_hNotifyThread = CreateThread (  
                        NULL,            // No security
                        0,               // Default stack size
                        NotifyThreadProc,// Thread procedure
                        (LPVOID)this,    // Parameter
                        0,               // Normal creation
                        &dwThreadId      // We must have a thread id for win9x
                     );
    if (NULL == m_hNotifyThread)
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to CreateThread. (ec: %ld)"), 
            ec);
        
        hRc = HRESULT_FROM_WIN32(ec);

        goto Exit;
    }

Exit:
    return hRc;
}


/*
 -  CFaxCoverPagesNode::StopNotificationThread
 -
 *  Purpose:
 *      Stop the server cover page directory listning thread.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::StopNotificationThread()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::StopNotificationThread"));
    HRESULT       hRc        = S_OK;
    
    //
    // Signal the event telling all our thread the app. is shutting down
    //
    SetEvent (m_hStopNotificationThreadEvent);

    //
    // wait for the thread
    //
    if (NULL != m_hNotifyThread )
    {
    
        DWORD dwWaitRes = WaitForSingleObject(m_hNotifyThread, INFINITE);
        switch(dwWaitRes)
        {
            case WAIT_OBJECT_0:
		        //Success
                DebugPrintEx(
			        DEBUG_MSG,
			        _T("Succeed to WaitForSingleObject from notify thread. (ec : %ld)"));
                                
                break;

            case WAIT_FAILED:
                dwWaitRes = GetLastError();
                if (ERROR_INVALID_HANDLE != dwWaitRes)
                {
		            DebugPrintEx(
			            DEBUG_ERR,
			            _T("Failed to WaitForSingleObject. (ec : %ld)"), 
                        dwWaitRes);

                    hRc = E_FAIL;
                }
                break;
        
            case WAIT_TIMEOUT:
		        DebugPrintEx(
			        DEBUG_ERR,
			        _T("WAIT_TIMEOUT - Failed to WaitForSingleObject. (ec : %ld)"), 
                    dwWaitRes);

                hRc = E_FAIL;
                
                ATLASSERT(FALSE);

                break;
        
            default:
		        DebugPrintEx(
			        DEBUG_ERR,
			        _T("Failed to WaitForSingleObject. (ec : %ld)"), 
                    dwWaitRes);

                hRc = E_FAIL;

                break;
        }
    
        CloseHandle (m_hNotifyThread);
        m_hNotifyThread = NULL;
    
    }
    



    return hRc;
}


/*
 -  CFaxCoverPagesNode::RestartNotificationThread
 -
 *  Purpose:
 *      Restart the server cover page directory listning thread.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxCoverPagesNode::RestartNotificationThread()
{
    DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::RestartNotificationThread"));
    HRESULT       hRc        = S_OK;

    //
    // Stop
    //
    hRc = StopNotificationThread();
    if (S_OK != hRc)
    {
        //DbgMsg And MsgBox by called func.
        goto Exit;
    }

    //
    // Reset Shutdown Event handle
    //
    if (m_hStopNotificationThreadEvent)
    {
        ResetEvent (m_hStopNotificationThreadEvent);
    }

    //
    // Start
    //
    hRc = StartNotificationThread();
    if (S_OK != hRc)
    {
        //DbgMsg And MsgBox by called func.
        goto Exit;
    }

Exit:
    return hRc;
}


/*
 +
 +  CFaxCoverPagesNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxCoverPagesNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_COVER_PAGES);
}


///////////////////////////////////////////////////////////////////


/*
 -  CFaxCoverPagesNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxCoverPagesNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxCoverPagesNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    switch (id)
    {
        case IDM_NEW_COVERPAGE:

            *flags = IsFaxComponentInstalled(FAX_COMPONENT_CPE) ? MF_ENABLED : MF_GRAYED;
            break;

        default:
            break;
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\covnotifywnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CovNotifyWnd.h                                         //
//                                                                         //
//  DESCRIPTION   : The implementation of fax cover page notification      //
//                  window.                                                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 14 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef _H_FAX_COV_NOTIFY_WND_H_
#define _H_FAX_COV_NOTIFY_WND_H_

#include <atlwin.h>


const int WM_NEW_COV = WM_USER + 1; 

class CFaxCoverPagesNode;

class CFaxCoverPageNotifyWnd : public CWindowImpl<CFaxCoverPageNotifyWnd> 
{
public:
    //
    // Constructor
    //
    CFaxCoverPageNotifyWnd(CFaxCoverPagesNode * pParentNode)
    {
        m_pCoverPagesNode = pParentNode;
    }

    //
    // Destructor
    //
    ~CFaxCoverPageNotifyWnd() 
    {
    }

    BEGIN_MSG_MAP(CFaxCoverPageNotifyWnd)
       MESSAGE_HANDLER(WM_NEW_COV, OnServerCovDirChanged)
    END_MSG_MAP()

    LRESULT OnServerCovDirChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    CFaxCoverPagesNode * m_pCoverPagesNode;
};

#endif // _H_FAX_COV_NOTIFY_WND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\covnotifywnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CovNotifyWnd.cpp                                       //
//                                                                         //
//  DESCRIPTION   : The implementation of fax cover page notification      //
//                  window.                                                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 14 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CovNotifyWnd.h"

#include "CoverPages.h"

LRESULT CFaxCoverPageNotifyWnd::OnServerCovDirChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
      DEBUG_FUNCTION_NAME( _T("CFaxCoverPageNotifyWnd::OnServerCovDirChanged"));
	  ATLASSERT(m_pCoverPagesNode);

      m_pCoverPagesNode->DoRefresh();
      
	  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\coverpages.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CoverPages.h                                           //
//                                                                         //
//  DESCRIPTION   : Header file for the fax cover pages node               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Feb  9 2000 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXCOVERPAGES_H
#define H_FAXCOVERPAGES_H

#include "snapin.h"
#include "snpnres.h"

#include "CoverPage.h"
#include "CovNotifyWnd.h"

class CFaxServerNode;
class CFaxCoverPageNode;
class CFaxCoverPageNotifyWnd;       

class CFaxCoverPagesNode : public CNodeWithResultChildrenList<
                                        CFaxCoverPagesNode,    
                                        CFaxCoverPageNode, 
                                        CSimpleArray<CFaxCoverPageNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxCoverPagesNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_OPEN_COVERPAGE, OnAddCoverPageFile)
        SNAPINCOMMAND_ENTRY(IDM_NEW_COVERPAGE,  OnNewCoverPage)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxCoverPagesNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_COVERPAGES_MENU)

    //
    // Constructor
    //
    CFaxCoverPagesNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxCoverPagesNode, CFaxCoverPageNode, CSimpleArray<CFaxCoverPageNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_bIsFirstPopulateCall = TRUE;
        m_NotifyWin = NULL; 
        m_hNotifyThread = NULL;
    }

    //
    // Destructor
    //
    ~CFaxCoverPagesNode()
    {
        DEBUG_FUNCTION_NAME(_T("CFaxCoverPagesNode::~CFaxCoverPagesNode"));
         
        //
        // StopNotificationThread
        //
        HRESULT hRc = StopNotificationThread();
        if (S_OK != hRc)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to StopNotificationThread. (hRc : %08X)"), 
                hRc);
        }
             
        //
        // Close Shutdown Event handle
        //
        if (m_hStopNotificationThreadEvent)
        {
            CloseHandle (m_hStopNotificationThreadEvent);
            m_hStopNotificationThreadEvent = NULL;
        }


        //
        // Destroy Window
        //
        if (NULL != m_NotifyWin)
        {
            if (m_NotifyWin->IsWindow())
            {
                m_NotifyWin->DestroyWindow();
            }
            delete m_NotifyWin;
            m_NotifyWin = NULL;
        }
        

    }

	//
	// get data from RPC 
	//
    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void    InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);
    HRESULT DoRefresh();

    HRESULT Init();

    HRESULT InitDisplayName();

    HRESULT DeleteCoverPage(BSTR bstrName, CFaxCoverPageNode *pChildNode);

    HRESULT OnNewCoverPage(bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT OnAddCoverPageFile(bool &bHandled, CSnapInObjectRootBase *pRoot);

    DWORD   OpenCoverPageEditor( BSTR bstrFileName);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    void    UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

private:

    BOOL    BrowseAndCopyCoverPage( 
                          LPTSTR pInitialDir,
                          LPWSTR pCovPageExtensionLetters
                                  );
    
    //
    // Notification thread
    //
    HRESULT StartNotificationThread();
    HRESULT StopNotificationThread();
    HRESULT RestartNotificationThread();

    //
    // members
    //
    static CColumnsInfo         m_ColsInfo;
    
    CFaxServerNode *            m_pParentNode;

    BOOL                        m_bIsFirstPopulateCall;

    static  HANDLE              m_hStopNotificationThreadEvent;

    HANDLE                      m_hNotifyThread;    // Handle of background notify thread

    static  DWORD WINAPI        NotifyThreadProc (LPVOID lpParameter);

	CFaxCoverPageNotifyWnd *	m_NotifyWin;       //: public CWindowImpl

    WCHAR                       m_pszCovDir[MAX_PATH+1];

};

typedef CNodeWithResultChildrenList<CFaxCoverPagesNode, CFaxCoverPageNode, CSimpleArray<CFaxCoverPageNode*>, FALSE>
        CBaseFaxOutboundRulesNode;

#endif  //H_FAXCOVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\device.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Device.h                                               //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxDeviceNode class                   //
//                  This is node apears both in the scope pane and         //
//                  with full detailes in the result pane.                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  1 1999 yossg   Change totaly for New Mockup (0.7)             //
//      Dec  6 1999 yossg   add  FaxChangeState functionality              //
//      Dec 12 1999 yossg   add  OnPropertyChange functionality            //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_DEVICE_H
#define H_DEVICE_H
//#pragma message( "H_DEVICE_H" )

#include "snapin.h"
#include "snpnscp.h"


class CFaxDevicesNode;
class CppFaxDeviceGeneral;
class CFaxServer;
//class CNodeWithScopeChildrenList;

class CFaxDeviceNode : public CNodeWithScopeChildrenList<CFaxDeviceNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxDeviceNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_FAX_DEVICE_SEND,      OnFaxSend)
        SNAPINCOMMAND_RANGE_ENTRY(IDM_FAX_DEVICE_RECEIVE_AUTO, IDM_FAX_DEVICE_RECEIVE_MANUAL, OnFaxReceive)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxDeviceNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_DEVICE_MENU)

    CFaxDeviceNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxDeviceNode, FALSE>(pParentNode, pComponentData ),
        m_dwDeviceID(0),
        m_fSend(FALSE),
        m_fAutoReceive(FALSE),
        m_fManualReceive(FALSE),
        m_dwRings(0),
        m_dwStatus(0),   
        m_pFaxServer(NULL)
        {}

    ~CFaxDeviceNode()
    {
    }

    //
    // Menu item handlers
    //
    HRESULT OnFaxReceive  (UINT nID, bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnFaxSend     (bool &bHandled, CSnapInObjectRootBase *pRoot);
    
    HRESULT FaxChangeState(UINT uiIDM, BOOL fState);

    
    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    LPOLESTR GetResultPaneColInfo(int nCol);


    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
             
    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxDevicesNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    void    UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
 
    HRESULT DoRefresh();

    HRESULT RefreshAllViews(IConsole *pConsole);
    
    HRESULT RefreshTheView();

    HRESULT Init( PFAX_PORT_INFO_EX  pFaxDeviceConfig );

    HRESULT UpdateMembers( PFAX_PORT_INFO_EX  pFaxDeviceConfig );

    HRESULT UpdateDeviceStatus( DWORD  dwDeviceStatus );

    DWORD   GetDeviceID();

	
    //
    // Get methods for CLIPFORMAT FillData
    //
	CComBSTR   GetFspGuid()
	{
		return m_bstrProviderGUID;
	}

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFPermanentDeviceID;
    static CLIPFORMAT m_CFFspGuid;
    static CLIPFORMAT m_CFServerName;

    //
    // inline parent ptr
    //
    inline CFaxDevicesNode * GetParent() /*const*/ 
    { 
        return m_pParentNode;
    };

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);


private:
    
    //
    // Config Structure member
    //
    DWORD                   m_dwDeviceID;
    CComBSTR                m_bstrDescription;
    CComBSTR                m_bstrProviderName;
    CComBSTR                m_bstrProviderGUID;
    BOOL                    m_fSend;
    BOOL                    m_fAutoReceive;
    BOOL                    m_fManualReceive;
    DWORD                   m_dwRings;
    CComBSTR                m_bstrCsid;
    CComBSTR                m_bstrTsid;

    DWORD                   m_dwStatus;

    CComBSTR                m_bstrServerName;

	//
	// get data from RPC 
	//
    /*
     * (in use during refresh only)
     * (private to avoid usage by out functions )
     */
    HRESULT InitRPC( PFAX_PORT_INFO_EX * pFaxDeviceConfig );

    
    CComBSTR                m_buf;

    CppFaxDeviceGeneral *   m_pFaxDeviceGeneral;

    static CColumnsInfo     m_ColsInfo;

    CFaxDevicesNode *       m_pParentNode;

    CFaxServer *            m_pFaxServer;

};


#endif  //H_DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\c_snapin.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : C_Snapin.h (from Snapin.h)                             //
//                                                                         //
//  DESCRIPTION   : Header file for                                        //
//                    CSnapinPage                                          //
//                    CSnapinData                                          //
//                    CSnapinExtData                                       //
//                    CSnapinComponent                                     //
//                    CSnapin                                              //
//                    CSnapinAbout                                         //
//                                                                         //
//  AUTHOR        : ATL Snapin class wizard                                //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Aug 24 1998 adik    Use Comet version.                             //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//      Oct 18 1998 adik    Merged with new wizard version.                //
//      Jan 12 1999 adik    Add ParentArrayInterfaceFromDataObject.        //
//      Mar 28 1999 adik    Remove persistence support.                    //
//      Mar 30 1999 adik    Supporting ICometSnapinNode.                   //
//      Apr 27 1999 adik    Help support.                                  //
//      May 23 1999 adik    Use ifndef _IN_NEMMCUTIL in few places.        //
//      Jun 10 1999 AvihaiL Fix warnings.                                  //
//      Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn   //
//      Jul 29 1999 adik    Release extensions.                            //
//                                                                         //
//      Oct 13 1999 yossg   Welcome to Fax Server				           //
//      Dec 12 1999 yossg   add CSnapin::Notify						       //
//      Apr 14 2000 yossg   Add support for primary snapin mode            //
//      Jun 25 2000 yossg   Add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef C_SNAPIN_H_INCLUDED
#define C_SNAPIN_H_INCLUDED

#include <stdio.h>
//#include <ATLSnap.h> 
#include "..\inc\atlsnap.h"
#include "cVerNum.h"

EXTERN_C const CLSID CLSID_Snapin;
EXTERN_C const CLSID CLSID_SnapinAbout;

#define FXS_HINT_DELETE_ALL_RSLT_ITEMS    -1

class CSnapin;

////////////////////////////////////////////////////////////////////
// CSnapinExtData
//
class CSnapinExtData : public CSnapInItemImpl<CSnapinExtData, TRUE>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CSnapin *m_pComponentData;

    BEGIN_SNAPINCOMMAND_MAP(CSnapinExtData, FALSE)
    END_SNAPINCOMMAND_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    BEGIN_SNAPINTOOLBARID_MAP(CSnapinExtData)
        // Create toolbar resources with button dimensions 16x16
        // and add an entry to the MAP. You can add multiple toolbars
        // SNAPINTOOLBARID_ENTRY(Toolbar ID)
    END_SNAPINTOOLBARID_MAP()

    CSnapinExtData()
    {
        memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CSnapinExtData()
	{
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    IDataObject* m_pDataObject;
    virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        m_pDataObject = pDataObject;
        UNREFERENCED_PARAMETER(pDefault);
        // The default code stores off the pointer to the Dataobject the class is wrapping
        // at the time.
        // Alternatively you could convert the dataobject to the internal format
        // it represents and store that information
    }

    CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault);
    

}; // endclass CSnapinExtData

////////////////////////////////////////////////////////////////////
// CSnapinComponent
//
class CSnapinComponent :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<2, CSnapin>,
    public IExtendPropertySheetImpl<CSnapinComponent>,
    public IExtendContextMenuImpl<CSnapinComponent>,
    public IExtendControlbarImpl<CSnapinComponent>,
    public IComponentImpl<CSnapinComponent>
	//,     public IExtendTaskPadImpl<CSnapinComponent>
{
public:
BEGIN_COM_MAP(CSnapinComponent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
//    COM_INTERFACE_ENTRY(IExtendTaskPad)
END_COM_MAP()

public:
    // A pointer to the currently selected node used for refreshing views.
    // When we need to update the view, we tell MMC to reselect this node.
    CSnapInItem * m_pSelectedNode;

    CSnapinComponent();

    ~CSnapinComponent();

    // Handlers for notifications which we want to handle on a
    // per-IComponent basis.
public:
    // We are overiding ATLsnap.h's IComponentImpl implementation of this
    // in order to correctly handle messages which it is incorrectly
    // ignoring (e.g. MMCN_COLUMN_CLICK and MMCN_SNAPINHELP)
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                      LPARAM arg, LPARAM param);

    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
                              LPDATAOBJECT lpDataObjectB);

protected:
    virtual HRESULT OnColumnClick(LPARAM arg, LPARAM param);

    virtual HRESULT OnCutOrMove(LPARAM arg, LPARAM param);

    virtual HRESULT OnSnapinHelp(LPARAM arg, LPARAM param);

    virtual HRESULT OnViewChange(LPARAM arg, LPARAM param);

    virtual HRESULT OnPropertyChange(LPARAM arg, LPARAM param);

//    virtual HRESULT OnAddImages(LPARAM arg, LPARAM param);

public:

    // Related to TaskPad implementation.

    // We have to override this because the default implementation
    // gives back the wrong answer when the cookie is NULL.
    // NULL cookie means root node, and for our root node
    // we want a taskpad.
//  STDMETHOD(GetResultViewType)(long cookie,
//                               LPOLESTR  *ppViewType,
//                               long  *pViewOptions);

    STDMETHOD(GetTitle)(LPOLESTR pszGroup,
                        LPOLESTR *pszTitle);

    STDMETHOD(GetBanner)(LPOLESTR pszGroup,
                         LPOLESTR *pszBitmapResource);
}; // endclass CSnapinComponent

class CFaxServerNode;
////////////////////////////////////////////////////////////////////
// CSnapin
//
class CSnapin : public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<1, CSnapin>,
    public IComponentDataImpl<CSnapin, CSnapinComponent>,
    public IExtendPropertySheetImpl<CSnapin>,
    public IExtendContextMenuImpl<CSnapin>,
    public IExtendControlbarImpl<CSnapin>,
    public IPersistStream,
    public ISnapinHelp,
    public CComCoClass<CSnapin, &CLSID_Snapin>
{
public:
    CSnapin();

    ~CSnapin();

    EXTENSION_SNAPIN_DATACLASS(CSnapinExtData)

    BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CSnapin)
	    EXTENSION_SNAPIN_NODEINFO_ENTRY(CSnapinExtData)
    END_EXTENSION_SNAPIN_NODEINFO_MAP()

    
    CFaxServerNode*     m_pPrimaryFaxServerNode;
   

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_SNAPIN)

DECLARE_NOT_AGGREGATABLE(CSnapin)

    STDMETHOD(GetClassID)(CLSID *pClassID)
    {
        ATLTRACE(_T("CSnapin::GetClassID"));
        ATLASSERT(pClassID);

        *pClassID = CLSID_Snapin;

        return S_OK;
    }

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    static void WINAPI ObjectMain(bool bStarting)
    {
        if (bStarting)
            CSnapInItem::Init();
    }
    
    //
    // ISnapinHelp Interface
    //
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

    virtual WCHAR *GetHelpFile();
    virtual WCHAR *GetHelpTopic();

    //
    // Override IComponentDataImpl's Notify 
    // for lpDataObject == NULL && event == MMCN_PROPERTY_CHANGE
    //
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);

    //
    // IPersistStream: 
    // These originally pure virtual functions 
    // must been defined here
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL /*fClearDirty*/);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

private:

    CComBSTR    m_bstrServerName;
	
    BOOL        m_fAllowOverrideServerName;

}; // endclass CSnapin

////////////////////////////////////////////////////////////////////
// CSnapinAbout
//

class ATL_NO_VTABLE CSnapinAbout : public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass< CSnapinAbout, &CLSID_SnapinAbout>
{
public: 
    DECLARE_REGISTRY(CSnapinAbout, _T("SnapinAbout.1"), _T("SnapinAbout.1"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CSnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    HBITMAP m_hSmallImage;
    HBITMAP m_hSmallImageOpen;
    HBITMAP m_hLargeImage;

    CSnapinAbout(): m_hSmallImage(NULL), m_hSmallImageOpen(NULL), m_hLargeImage(NULL)
    {
    }

    ~CSnapinAbout()
    {
        if(m_hSmallImage)
        {
            DeleteObject(m_hSmallImage);
        }

        if(m_hSmallImageOpen)
        {
            DeleteObject(m_hSmallImageOpen);
        }

        if(m_hLargeImage)
        {
            DeleteObject(m_hLargeImage);
        }
    }

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_SNAPIN_DESC, szBuf, 256) == 0)
            return E_FAIL;

        *lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpDescription == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpDescription, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        USES_CONVERSION;
        WCHAR szBuf[256];
        if (::LoadString(_Module.GetResourceInstance(), IDS_SNAPIN_PROVIDER, szBuf, 256) == 0)
            return E_FAIL;

        *lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpName == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpName, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {

        USES_CONVERSION;
        TCHAR szBuf[256];
        TCHAR szFmt[200];
        if (::LoadString(_Module.GetResourceInstance(), IDS_SNAPIN_VERSION, szFmt, 200) == 0)
            return E_FAIL;
        swprintf(szBuf, szFmt, rmj, rmm, rup);
        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szBuf));
    
        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        *hAppIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_ICON_FAXSERVER));
        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP*  hSmallImage,
                                    HBITMAP*  hSmallImageOpen,
                                    HBITMAP*  hLargeImage,
                                    COLORREF* cMask)
    {
        if(!hSmallImage || !hSmallImageOpen || !hLargeImage || !cMask)
        {
            return S_FALSE;
        }

        HINSTANCE hInst = _Module.GetResourceInstance();

        if(m_hSmallImage)
        {
            *hSmallImage = m_hSmallImage;
        }
        else
        {
            m_hSmallImage = *hSmallImage = ::LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FAX_BITMAP_16));
        }

        if(m_hSmallImageOpen)
        {
            *hSmallImageOpen = m_hSmallImageOpen;
        }
        else
        {
            m_hSmallImageOpen = *hSmallImageOpen = ::LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FAX_BITMAP_16));
        }

        if(m_hLargeImage)
        {
            *hLargeImage = m_hLargeImage;
        }
        else
        {
            m_hLargeImage = *hLargeImage = ::LoadBitmap(hInst, MAKEINTRESOURCE(IDB_FAX_BITMAP_32));
        }

        *cMask = RGB(255, 255, 255); 

        return S_OK;
    }
}; // endclass CSnapinAbout

HRESULT AddBitmaps(IImageList *pImageList);

#endif // ! C_SNAPIN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\c_snapin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : C_Snapin.cpp (Snapin.cpp)                              //
//                                                                         //
//  DESCRIPTION   : Implementation file for                                //
//                    CSnapin          class                               //
//                    CSnapinComponent class                               //
//                                                                         //
//  AUTHOR        : ATL Snapin wizard                                      //
//                                                                         //
//  HISTORY       :                                                        //
//      May 25 1998 adik    Init.                                          //
//      Aug 24 1998 adik    WEB IVR instead IVR.                           //
//      Sep 14 1998 yossg   seperate common source to an included file     //
//      Oct 18 1998 adik    Merged with new wizard version.                //
//      Jan 12 1999 adik    Add ParentArrayInterfaceFromDataObject.        //
//      Mar 28 1999 adik    Remove persistence support.                    //
//      Mar 30 1999 adik    Support of ICometSnapinNode in IDataObject.    //
//      Apr 27 1999 adik    Help support.                                  //
//      Jun 10 1999 adik    Change bitmap mask to white.                   //
//      Jun 14 1999 roytal  used UNREFERENCED_PARAMETER to fix build wrn   //
//      Jun 21 1999 adik    Handle MMCN_COLUMN_CLICK to avoid ASSERT.      //
//      Jun 22 1999 zvib    change handling of property change             //
//                                                                         //
//      Oct 13 1999 yossg   Welcome to Fax Server				           //
//      Jan 19 2000 yossg   Add CFaxPropertyChangeNotification to          //
//                          CSnapinComponent::Notify MMCN_PROPERTY_CHANGE  //
//      Apr 14 2000 yossg   Add support for primary snapin mode			   //
//      Jun 25 2000 yossg   Add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "C_Snapin.h"
#include "ResUtil.h"

#include "FaxServerNode.h"  

#include "FaxMMCPropertyChange.h"
#include "FxsValid.h"
#include "Icons.h"

#include <ObjBase.h>
#include <windns.h> //DNS_MAX_NAME_BUFFER_LENGTH



HRESULT
AddBitmaps(IImageList *pImageList)
{
    HBITMAP     hBitmap16 = NULL;
    HBITMAP     hBitmap32 = NULL;
    HINSTANCE   hInst;
    HRESULT     hr;

    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as required

    hInst = _Module.GetResourceInstance();

    //
    // Load 16 bits
    //
    hBitmap16 = LoadBitmap(hInst, MAKEINTRESOURCE(IDR_TOOLBAR_16));
    if (hBitmap16 == NULL)
    {
        hr = E_FAIL;
        ATLTRACE(_T("LoadBitmap failed\n"));
        goto Cleanup;
    }

    //
    // Load 32 bits
    //
    hBitmap32 = LoadBitmap(hInst, MAKEINTRESOURCE(IDR_TOOLBAR_32));
    if (hBitmap32 == NULL)
    {
        hr = E_FAIL;
        ATLTRACE(_T("LoadBitmap failed\n"));
        goto Cleanup;
    }

    //
    // Add to image list
    //
    hr = pImageList->ImageListSetStrip(
                        (LONG_PTR*)hBitmap16,
                        (LONG_PTR*)hBitmap32,
                        0,
                        RGB(0, 0, 0));
    if ( FAILED(hr) )
    {
        ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
        goto Cleanup;
    }

Cleanup:

    if (NULL != hBitmap32)
    {
        DeleteObject(hBitmap32);
    }
    if (NULL != hBitmap16)
    {
        DeleteObject(hBitmap16);
    }

    return hr;
}

class CFaxServerNode;
CSnapin::CSnapin()
{
    m_bstrServerName                  = L"";  //LocalMachine as default
    m_fAllowOverrideServerName        = TRUE;

    m_pPrimaryFaxServerNode           = new CFaxServerNode(
                                                NULL, 
                                                this, 
                                                L""); //m_bstrServerName.m_str

    ATLASSERT(m_pPrimaryFaxServerNode != NULL);
    
    m_pPrimaryFaxServerNode->SetIcons(IMAGE_FAX, IMAGE_FAX);

    m_pNode                           = (CSnapInItem *) m_pPrimaryFaxServerNode; 

    m_pComponentData = this;
    
    m_CSnapinExtData.m_pComponentData = this;
}

CSnapin::~CSnapin()
{
    if (NULL != m_pPrimaryFaxServerNode)
    {
        delete m_pPrimaryFaxServerNode;
        m_pPrimaryFaxServerNode = NULL;
    }
    
    m_pNode = NULL;
}




HRESULT
CSnapin::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr = IComponentDataImpl<CSnapin, CSnapinComponent >::Initialize(pUnknown);
    if (FAILED(hr))
        return hr;

    CComPtr<IImageList> spImageList;

    if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
    {
        ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
        return E_UNEXPECTED;
    }

    hr = ::AddBitmaps(spImageList);

    return hr;
}

HRESULT
CSnapinExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    IUnknown* pUnk,
    DATA_OBJECT_TYPES type)
{
    UNREFERENCED_PARAMETER (lpProvider);
    UNREFERENCED_PARAMETER (handle);
    UNREFERENCED_PARAMETER (pUnk);

    // override this method.
    if (type == CCT_SCOPE || type == CCT_RESULT)
    {
        return S_OK;
    }
    return E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////

CSnapinComponent::CSnapinComponent():m_pSelectedNode(NULL)
{
}

//////////////////////////////////////////////////////////////////////////////

CSnapinComponent::~CSnapinComponent()
{
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::Notify

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    DEBUG_FUNCTION_NAME( _T("CSnapinComponent::Notify"));
    HRESULT hr = S_OK;

    if(lpDataObject != NULL && MMCN_SHOW != event)
    {
        return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);
    }
    

    //
    // In this routine we handle only
    // lpDataObject ==NULL, or we have a MMCN_SHOW event.
    //


    if(MMCN_SHOW == event)
    {
      //
      // On Show event, we want to keep, or reset
      // the node currenlty selected
      //
      ATLASSERT(lpDataObject != NULL);

      //
      // Retreive the pItem data type
      //
      CSnapInItem* pItem;
      DATA_OBJECT_TYPES type;
      hr = m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);

      if(FAILED(hr))
          return(hr);

      if( arg )
      {
         // We are being selected.
         m_pSelectedNode = pItem;

      }
      else
      {
         // We are being deselected.

         // Check to make sure that our result view doesn't think
         // this node is the currently selected one.
         if( m_pSelectedNode == pItem)
         {
            // We don't want to be the selected node anymore.
            m_pSelectedNode = NULL;
         }

      }

      //
      // Call SnapinItem notification routine
      //
      return IComponentImpl<CSnapinComponent>::Notify(lpDataObject, event, arg, param);
    }

    //
    // lpDataObject == NULL
    //

    // Currently handling only View Change (UpdateAllViews)
    // And PropertyChange

    switch (event)
    {
        case MMCN_VIEW_CHANGE:
            if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
            {
                if ( FXS_HINT_DELETE_ALL_RSLT_ITEMS == param)
                {
                    
                    ATLASSERT(m_spConsole);
                    CComQIPtr<IResultData, &IID_IResultData> pResultData(m_spConsole);
                    ATLASSERT(pResultData);
    
                    hr = pResultData->DeleteAllRsltItems();
                    if( FAILED(hr) )
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("Fail to DeleteAllRsltItems().(hRc: %08X)"),
                            hr);
                        return( hr );
                    }
                    break;
                }
                
                // We basically tell MMC to simulate reselecting the
                // currently selected node, which causes it to redraw.
                // This will cause MMC to send the MMCN_SHOW notification
                // to the selected node.
                // This function requires an HSCOPEITEM.  This is the ID member
                // of the HSCOPEDATAITEM associated with this node.
                SCOPEDATAITEM *pScopeDataItem;
                m_pSelectedNode->GetScopeData(&pScopeDataItem);
                hr = m_spConsole->SelectScopeItem(pScopeDataItem->ID);
            }
            break;



        case MMCN_PROPERTY_CHANGE:

              CFaxPropertyChangeNotification * pNotification;
              CSnapInItem * pItem;
              pNotification = ( CFaxPropertyChangeNotification * ) param;
              ATLASSERT(pNotification);
              pItem = pNotification->pItem;
              ATLASSERT(pItem);
              hr = pItem->Notify(event, arg, param, NULL, (IComponent*) this, CCT_RESULT);
              break;
              

//              CSnapInItem * pNode;
//              pNode = (CSnapInItem *) param;
//              hr = pNode->Notify(event, arg, param, NULL, (IComponent*) this, CCT_RESULT);
//              break;


//       case MMCN_PROPERTY_CHANGE:
//            {
//
//                CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
//                hr = spResultData->UpdateItem((HRESULTITEM)(param));
//            }
//            break;

        case MMCN_SNAPINHELP:
            ATLASSERT(0); // Shouldn't been called since we support ISnapinHelp

            //
            // Call imported method from NeMmcUtl.dll
            //
            OnSnapinHelp(arg, param);
            break;

        case MMCN_COLUMN_CLICK:
            //
            // MMC 1.2 handles this
            //
            break;

        default:
            //
            // Catch un handeled events
            //
            ATLASSERT(0);

    } // endswitch (event)

   return hr;
}


/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::CompareObjects

Needed so that IPropertySheetProvider::FindPropertySheet will work.

FindPropertySheet is used to bring a pre-existing property sheet to the foreground
so that we don't open multiple copies of Properties on the same node.

It requires CompareObjects to be implemented on both IComponent and IComponentData.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSnapinComponent::CompareObjects(LPDATAOBJECT lpDataObjectA,
                                 LPDATAOBJECT lpDataObjectB)
{
    ATLTRACE(_T("# CSnapinComponent::CompareObjects\n"));

    HRESULT hr;

    CSnapInItem *pDataA, *pDataB;
    DATA_OBJECT_TYPES typeA, typeB;

    hr = GetDataClass(lpDataObjectA, &pDataA, &typeA);
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = GetDataClass(lpDataObjectB, &pDataB, &typeB);
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if( pDataA == pDataB )
    {
        // They are the same object.
        return S_OK;
    }
    else
    {
        // They are different.
        return S_FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnColumnClick

HRESULT OnColumnClick(
              LPARAM arg
            , LPARAM param
            )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

    arg
    Column number.

    param
    Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnColumnClick(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnColumnClick -- Not implemented\n"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);

    // Check for preconditions:
    // None.

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnCutOrMove

HRESULT OnCutOrMove(
              LPARAM arg
            , LPARAM param
            )

In our implementation, this method gets called when the MMCN_COLUMN_CLICK
Notify message is sent for our IComponent object.

MMC sends this message when the user clicks on a result-list view column header.


Parameters

    arg
    Column number.

    param
    Sort option flags. By default, the sort is in ascending order. To specify descending order, use the RSI_DESCENDING (0x0001) flag.


Return Values

    Not used.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnCutOrMove(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnCutOrMove\n"));

    // ISSUE: This may need to be changed once the MMC team finalizes their
    // cut and paste protocol -- they seem to be in flux for 1.1 as of 02/16/98.
    // Currently, we will assume that the arg value passed to us is the source item
    // in the cut-and-paste or drag-n-drop operation.  That is, it is the object
    // to be deleted.
    // We supplied this pointer in our response to the MMCN_PASTE notification,
    // when we set param to point to the source IDataObject.

    HRESULT hr;

    if( arg != NULL )
    {

        CSnapInItem* pData;
        DATA_OBJECT_TYPES type;
        hr = CSnapInItem::GetDataClass( (IDataObject *) arg, &pData, &type);

        ATLASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            // We need a richer Notify method which has information about the IComponent and IComponentData objects
            //hr = pData->Notify(event, arg, param, TRUE, m_spConsole, NULL, NULL);

            hr = pData->Notify( MMCN_CUTORMOVE, arg, param, NULL, this, type );
        }
    }

//  return E_NOTIMPL;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnSnapinHelp

HRESULT OnSnapinHelp(
              LPARAM arg
            , LPARAM param
            )

In our implementation, this method gets called when the MMCN_SNAPINHELP
Notify message is sent for our IComponent object.

MMC sends this message when the user requests help about the snap-in.

Parameters

    arg
    0

    param
    0

Return Values

    Not used.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnSnapinHelp(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnSnapinHelp\n"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);

    // Check for preconditions:
    _ASSERTE( m_spConsole != NULL );

    ::OnSnapinHelp(m_spConsole);

#if 0
    HRESULT hr;
    //TCHAR   szFileName[MAX_PATH];
    HWND    hWnd;

    // Get HWND from MMC.
    hr = m_spConsole->GetMainWindow( &hWnd );
    _ASSERTE( SUCCEEDED( hr ) && NULL != hWnd );

#ifdef UNICODE_HHCTRL
    // ISSUE: We seemed to have a problem with passing WCHAR's to the hhctrl.ocx
    // installed on this machine -- it appears to be non-unicode.
    //lstrcpy( szFileName, HTMLHELP_NAME );
    //HtmlHelp( hWnd, szFileName, HH_DISPLAY_TOPIC, (DWORD) _T("iasmmc_main_help.htm") );
#else
    //strcpy( (CHAR *) szFileName, HTMLHELP_NAME );
    //HtmlHelp( hWnd, (TCHAR *) szFileName, HH_DISPLAY_TOPIC, (DWORD) "iasmmc_main_help.htm" );
#endif

#endif // 0
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnViewChange

HRESULT OnViewChange(
              LPARAM arg
            , LPARAM param
            )

This is where we respond to an MMCN_VIEW_CHANGE notification.

In our implementation, this is a signal to check the currently selected node in
the result pane for this component, and refresh the view if the node happens to
be the same as the pointer to a CSnapInItem passed in through arg.

We do this because you only want to refresh the view of the currently selected
node, and you only want to do that if its children have changed.

If the arg passed in is NULL, we just reselect the currently selected node.


--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnViewChange(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CNodeWithResultChildrenList::OnViewChange\n"));

    // Check for preconditions:
    UNREFERENCED_PARAMETER (param);
    _ASSERTE( m_spConsole != NULL );

    HRESULT hr = S_FALSE;

    // What localsec snapin checks for:
    if( ( arg == NULL || (CSnapInItem *) arg == m_pSelectedNode ) && m_pSelectedNode != NULL )
    {
        // We basically tell MMC to simulate reselecting the
        // currently selected node, which causes it to redraw.
        // This will cause MMC to send the MMCN_SHOW notification
        // to the selected node.
        // This function requires an HSCOPEITEM.  This is the ID member
        // of the HSCOPEDATAITEM associated with this node.
        SCOPEDATAITEM *pScopeDataItem;
        m_pSelectedNode->GetScopeData( &pScopeDataItem );
        hr = m_spConsole->SelectScopeItem( pScopeDataItem->ID );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::OnPropertyChange

HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            )

This is where we respond to an MMCN_PROPERTY_CHANGE notification.

This notification is sent when we call MMCPropertyChangeNotify.
We call this in our property pages when changes are made to the data
they contain and we may need to update of view of the data.

--*/
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSnapinComponent::OnPropertyChange(LPARAM arg, LPARAM param)
{
    ATLTRACE(_T("# CSnapinComponent::OnPropertyChange\n"));

    // Check for preconditions:
    _ASSERTE( m_spConsole != NULL );
    UNREFERENCED_PARAMETER (arg);

    HRESULT hr = S_FALSE;

    if( param == NULL )
    {

        // We want to make sure all views get updated.
        hr = m_spConsole->UpdateAllViews( NULL, (LPARAM) m_pSelectedNode, NULL);
    }
    else
    {
        // We passed a pointer to a CSnapInItem in the param argument.
        // We call notify on that node, passing it our own custom event type
        // so that it knows that it must refresh its data.

        CSnapInItem * pSnapInItem = (CSnapInItem *) param;

        // Call notify on this node with the MMCN_PROPERTY_CHANGE notification.
        // We had to use this trick because of the fact that we are using template
        // classes and so we have no common object among all our nodes
        // other than CSnapInItem.  But we can't change CSnapInItem
        // so instead we use the notify method it already has with a new
        // notification.

        // Note:  We are trying to deal gracefully here with the fact that the
        // MMCN_PROPERTY_CHANGE notification doesn't pass us an lpDataObject
        // so we have to have our own protocol for picking out which node
        // needs to update itself.

        hr = pSnapInItem->Notify( MMCN_PROPERTY_CHANGE
                            , NULL
                            , NULL
                            , NULL
                            , NULL
                            , (DATA_OBJECT_TYPES) 0
                            );

        // We want to make sure all views with this node select also get updated.
        hr = m_spConsole->UpdateAllViews( NULL, (LPARAM) pSnapInItem, NULL);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::GetTitle

IExtendTaskPad interface member.

This is the title that show up under the banner.

ISSUE: Why does this not appear to be working?

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSnapinComponent::GetTitle(LPOLESTR pszGroup, LPOLESTR *pszTitle)
{
    ATLTRACE(_T("# CSnapinComponent::GetTitle\n"));
    UNREFERENCED_PARAMETER (pszGroup);

    // Check for preconditions:
    _ASSERTE( pszTitle != NULL );

    OLECHAR szTitle[256];
    int nLoadStringResult = LoadString(_Module.GetResourceInstance(), IDS_TASKPAD_TITLE, szTitle, 256);
    _ASSERT( nLoadStringResult > 0 );

    *pszTitle= (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(lstrlen(szTitle)+1) );

    if( ! *pszTitle )
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy( *pszTitle, szTitle );

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CSnapinComponent::GetBanner

IExtendTaskPad interface member.

We provide the color bar banner that appears at the top of the taskpad.
It is a resource in our snapin DLL.

--*/
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSnapinComponent::GetBanner (LPOLESTR pszGroup, LPOLESTR *pszBitmapResource)
{
    ATLTRACE(_T("# CSnapinComponent::GetBanner\n"));
    UNREFERENCED_PARAMETER (pszGroup);

    // We are constructing a string pointing to the bitmap resource
    // of the form: "res://D:\MyPath\MySnapin.dll/img\ntbanner.gif"

    OLECHAR szBuffer[MAX_PATH*2]; // A little extra.


    // Get "res://"-type string for bitmap.
    lstrcpy (szBuffer, L"res://");
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

    // Get our executable's filename.
    HINSTANCE hInstance = _Module.GetResourceInstance();
    ::GetModuleFileName (hInstance, temp, MAX_PATH);

    // Add the name of the image within our resources.
    lstrcat (szBuffer, L"/img\\IASTaskpadBanner.gif");

    // Alloc and copy bitmap resource string.
    *pszBitmapResource = (LPOLESTR) CoTaskMemAlloc(sizeof(OLECHAR)*(lstrlen(szBuffer)+1) );
    if (!*pszBitmapResource)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy( *pszBitmapResource, szBuffer);

    return S_OK;

}

/*
 -  CSnapin::GetHelpTopic
 -
 *  Purpose:
 *      See MMC help on ISnapinHelp::GetHelpTopic
 *
 *  Arguments:
 *      [out]   lpCompiledHelpFile - Pointer to the address of the NULL-terminated
 *                                   UNICODE string that contains the full path of
 *                                   the compiled help file (.chm) for the snap-in.
 *
 *  Return:
 *      OLE error code
 */
HRESULT STDMETHODCALLTYPE
CSnapin::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
    WCHAR   *pszFilePath;
    WCHAR   *pszTopic;
    HRESULT hRc = S_OK;
    ULONG   ulLen;

    DEBUG_FUNCTION_NAME( _T("CSnapin::GetHelpTopic"));

    ATLASSERT(lpCompiledHelpFile != NULL);

    //
    // Get the CHM file name and the current topic
    //
    pszFilePath = GetHelpFile();
    pszTopic = NULL; //pszTopic = GetHelpTopic(); current implementation.

    if (pszFilePath == NULL)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,_T("Failed to GetHelpFile(). (hRc: %08X)"), hRc);
        goto Cleanup;
    }

    //
    // Allocate mem for it
    ulLen = lstrlen(pszFilePath) + 1;
    if (pszTopic && *pszTopic)
    {
        ulLen += 2 /* for "::" */ + lstrlen(pszTopic);
    }
    ulLen *= sizeof(WCHAR);

    *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(::CoTaskMemAlloc(ulLen));
    if (*lpCompiledHelpFile == NULL)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,_T("Failed to do CoTaskMemAlloc. (hRc: %08X)"), hRc);
        goto Cleanup;
    }
    wcscpy(*lpCompiledHelpFile, pszFilePath);

    //
    // Copy the help file::topic
    //
    if (pszTopic && *pszTopic)
    {
        wcscat(*lpCompiledHelpFile, L"::");
        wcscat(*lpCompiledHelpFile, pszTopic);
    }

Cleanup:
    return hRc;
}


WCHAR*
CSnapin::GetHelpFile()
{
    DEBUG_FUNCTION_NAME( _T("CSnapin::GetHelpFile"));

    return ::GetHelpFile();
}


///////////////////////////////////////////////////////////////
//
// IPesistStream
//

/////////////////////////////////////////////////////////////////////
//const WCHAR szOverrideCommandLineEquals[] = _T("/Computer=");	// Not subject to localization
//const WCHAR szOverrideCommandLineColon[] = _T("/Computer:");	// Not subject to localization

const WCHAR g_szFaxOverrideCommandLineEquals[] = _T("/FAX=");	    // Not subject to localization
const WCHAR g_szLocalMachine[] = _T("LocalMachine");		        // Not subject to localization


//we keep the version of persistence information of CSnapin 
//when the persistence format is changed we need to increase this integer number
//we will read persistnce information only if the persistence version in the stream
//matches that of the PERISISTENCE_VERSION.

#define PERISISTENCE_VERSION 100002

//
// The persist stream format is:
// 
// Version (UINT)
// AllowOverride (BOOL)
// Server Name length (UINT)
// Server Name string ( <= WCHAR * DNS_MAX_NAME_BUFFER_LENGTH )
//

/*
 -  CSnapin::Load
 -
 *  Purpose:
 *      Initializes an object from the stream where it was previously saved.
 *
 *  Arguments:
 *      [in] pStm - Pointer to the stream from which the object 
 *                  should be loaded.
 *  Return:
 *      S_OK          - The object was successfully loaded. 
 *      E_OUTOFMEMORY - The object was not loaded due to a lack of memory. 
 *      E_FAIL        - The object was not loaded due to some reason other 
 *                      than a lack of memory.
 *
 */
STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    DEBUG_FUNCTION_NAME( _T("CSnapin::Load"));
	HRESULT    hRc = S_OK;
    
    BOOL       fServerNameFoundInCommandLine = FALSE;
    CComBSTR   bstrCommandLineServerName     = L"";

    WCHAR      wszPersistStreamServerName[DNS_MAX_NAME_BUFFER_LENGTH+1] = {0};

    UINT       uiVersion  = 0;
    ULONG      nBytesRead = 0;

	//
    // Pre-conditions
    //
    ATLASSERT( NULL != pStm );

    //
    // A. Read the Stream
    // ==================
    //

    //
    // Read the Version
    //
    hRc = pStm->Read(&uiVersion, sizeof(uiVersion), NULL);
    if( FAILED( hRc ) ) 
    {
        DebugPrintEx( DEBUG_ERR,
			_T("pStm->Read(version). (hRc: %08X)"), hRc);
        
        return E_FAIL;
    }

    if (uiVersion == PERISISTENCE_VERSION)
    {

	    //
        // Read Allow-to-override stream machine-name flag 
        // from command line source
        //
	    hRc = pStm->Read( &m_fAllowOverrideServerName, sizeof(m_fAllowOverrideServerName), NULL );
        if( FAILED( hRc ) ) 
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("pStm->Read(fAllowOverrideServerName). (hRc: %08X)"), hRc);
        
            return E_FAIL;
        }

        //
        // Read the Server Name from stream
        //
	    hRc = pStm->Read (&nBytesRead , sizeof(ULONG), NULL);
        if( FAILED( hRc ) ) 
        {
            DebugPrintEx( DEBUG_ERR,
			    _T("Fail to Read server name length from stream. (hRc: %08X)"), hRc);
            return E_FAIL;
        }
	    ATLASSERT (nBytesRead <= DNS_MAX_NAME_BUFFER_LENGTH * sizeof (WCHAR));
	    if (nBytesRead <= DNS_MAX_NAME_BUFFER_LENGTH * sizeof (WCHAR))
	    {
	        hRc = pStm->Read ((PVOID) wszPersistStreamServerName, nBytesRead, NULL);
            if( FAILED( hRc ) ) 
            {
                DebugPrintEx( DEBUG_ERR,
			        _T("Fail to Read server name from stream. (hRc: %08X)"), hRc);
                return E_FAIL;
            }
        }
    }
    else // version!=PERISISTENCE_VERSION
    {
        //
        // Persistance data will not be read due to inconsitency.
        //
        
        DebugPrintEx( DEBUG_ERR,
			_T("The current *.msc file version (%ld) is differnt from the\n pesistance version the dll expecting (%ld)."), uiVersion, PERISISTENCE_VERSION);

        
        //
        // Next we'll try to Read ServerName from Command line 
        //
    }

    //
    // B. Try to read from command line
    // ================================
    //
    
    // fServerNameFoundInCommandLine initial state == FALSE
    if (m_fAllowOverrideServerName)
    {
        int      argCount   = 0;
        PWSTR*   argV       = NULL;
        
        const int cchFaxOverrideCommandLine = ( sizeof(g_szFaxOverrideCommandLineEquals) / sizeof(g_szFaxOverrideCommandLineEquals[0]) ) - 1;
    
	    argV = CommandLineToArgvW(GetCommandLine() , &argCount);

        if (argV == NULL)
        {
		    DWORD ec;
		    ec = GetLastError();
		    
		    DebugPrintEx(
			    DEBUG_ERR,
			    _T("Fail to parse Command Line To Argv. (ec: %ld)"), 
			    ec);
		    
		    return E_FAIL;
        }

        //argV[0] is not an argument
	    for (int i = 1; i < argCount; i++)
	    {
		    WCHAR * psz = argV[i]; 

		    if (  0 == wcsnicmp( psz , g_szFaxOverrideCommandLineEquals , cchFaxOverrideCommandLine )  )
		    {
			    fServerNameFoundInCommandLine = TRUE;

	     		psz = _tcsninc(psz, cchFaxOverrideCommandLine);  //psz = psz + cchFaxOverrideCommandLine;
			    if ( 0 != wcscmp( psz , g_szLocalMachine )  )
			    {

                    //
                    // Server Name initial '\\' trancation (if they are there)
                    //
                    if (  ( _tcslen(psz) > 2 ) && ( 0 == wcsncmp( psz , _T("\\\\") , 2 ))   )
                    {
                        psz = _tcsninc(psz, 2); 
                    }
                    
                    if ( _tcslen(psz) >  0)
                    {
                        //
                        // Server Name validity checks
                        //
                        CComBSTR bstrServerNameValidation = psz;
                        UINT  uTmp = 0;
                        if (!IsValidServerNameString(bstrServerNameValidation, &uTmp, TRUE /*DNS Name Length*/))
                        {
                            // Err msg by called func.
                        
                            // As in comupter management we do not pop-up here
                            // but we fix the found flag to be FALSE 
                            fServerNameFoundInCommandLine = FALSE;

                            break;
                        }
                        
			      	    bstrCommandLineServerName = psz;

                        //
                        // we will also check if the explictly inserted Server Name 
                        // is the local Server Name. This check will be done in one place 
                        // the selected readed server name (Command line or Stream)
                        // 

                    }
                    else // the case of argV[2] == "/FAX=" only => LocalMachine
                    {
				        bstrCommandLineServerName = L""; //just to be sure - the default
                    }
			    }
			    else // "/FAX=LocalMachine"
			    {
				    bstrCommandLineServerName = L""; //just to be sure - the default
			    }
			    break;
		    }
        } //if /FAX= was not found bstrCommandLineServerName stays L""


        //
        // free resources
        //
        GlobalFree(argV);

    }

	
    //
    // C. Derived Server name from the results
    // =======================================
    //

    //
    // When there is no command line explicitly request for server name
    //
    // or
    //
    // when we are not allowed to take the command data and to use it 
    // to override the straem server name 
    //
    // just then the server is taken from the stream
    //
	
    ATLASSERT (0 == m_bstrServerName.Length()); 

    if ( 
          (!fServerNameFoundInCommandLine)
        ||
          (!m_fAllowOverrideServerName) 
       ) 
    {
		//
        // We should take the stream server name
        //

        if (NULL != wszPersistStreamServerName)
        {
            if ( 0 != wcscmp( wszPersistStreamServerName , g_szLocalMachine )  )
		    {                    
                m_bstrServerName = wszPersistStreamServerName;
		    }
		    else //LocalMachine
		    {
			    m_bstrServerName = L""; //Just to be sure
		    }
        }
        else
        {
            // not a regular case: 
            // for example can occur while version inconsitancy 
            // and no command line /FAX= server name instruction 
            m_bstrServerName = L""; //Just to be sure this is actually the default
        }
    }
    else
    {
        //
        // We should take the command line server name
        //

        m_bstrServerName = bstrCommandLineServerName; 
    }

    //
    // Checks if the explictly inserted Server Name 
    // is the local Server Name 
    //
	if (m_bstrServerName.Length() > 0 )
	{
		if ( IsLocalServerName(m_bstrServerName.m_str) )
		{
			DebugPrintEx( DEBUG_MSG,
			_T("The computer name %ws is the same as the name of the current managed server."),m_bstrServerName.m_str);
        
			m_bstrServerName = L"";
		}
	}
    

    //
    // We do not check here if the server is on the net 
    // and if fax is installed and running there 
    //

	
    //
    // D. Update FaxServer and FaxServerNode DisplayName with the name 
    // retrieved during the load process
    // =======================================
    //

    ATLASSERT( m_pNode);
    CFaxServerNode * pFaxServerNode = (CFaxServerNode *)m_pNode;
    ATLASSERT( pFaxServerNode);
    

	hRc = pFaxServerNode->UpdateServerName(m_bstrServerName); 
    if (S_OK != hRc)
    {
        DebugPrintEx(DEBUG_MSG,_T("Out of memory - fail to UpdateServerName."));
        
        return hRc; //E_OUTOFMEMORY;
    }
    
    
    hRc = pFaxServerNode->InitDetailedDisplayName();
    if (S_OK != hRc)
    {
        DebugPrintEx(DEBUG_MSG,_T("Out of memory - fail to InitDetailedDisplayName."));
        
        return hRc; //E_OUTOFMEMORY;
    }

    pFaxServerNode->SetIsLaunchedFromSavedMscFile();


    ATLASSERT (S_OK == hRc);
	return hRc;

}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL /*fClearDirty*/)
{
    DEBUG_FUNCTION_NAME( _T("CSnapin::Save"));
	HRESULT hRc = S_OK;
    
    UINT uiVersion = PERISISTENCE_VERSION;

	ATLASSERT( NULL != pStm );
    
    //
    // Write the version 
    //
    hRc = pStm->Write((void *)&uiVersion, sizeof(uiVersion), 0);
    if( FAILED( hRc ) )
    {
        DebugPrintEx( DEBUG_ERR,
			_T("pStm->Write(&uiVersion). (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
    }

    //
    // Write Allow-to-override machine-name flag to the stream 
    //
    hRc = pStm->Write((void *)&m_fAllowOverrideServerName, sizeof(m_fAllowOverrideServerName), 0);
    if( FAILED( hRc ) )
    {
        DebugPrintEx( DEBUG_ERR,
			_T("pStm->Write(&uiVersion. (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
    }

    //
    // Write the Server Name length
    //    
    LPCWSTR wcszMachineName;
    if ( 0 == m_bstrServerName.Length() ) // m_bstrServerName == L"" -> LocalMachine
    {
        wcszMachineName = g_szLocalMachine; // m_bstrServerName = L"LocalMachine"  
    }
    else 
    {
        wcszMachineName = m_bstrServerName;
    }
    DWORD dwLen = (::wcslen (wcszMachineName) + 1) * sizeof (WCHAR);

	hRc = pStm->Write ((void *)&dwLen, sizeof(DWORD), NULL);
	if ( FAILED(hRc) )
	{
        DebugPrintEx( DEBUG_ERR,
			_T("Fail to Write server name length to stream. (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
	}
    
    //
    // Write the Server Name 
    //
	hRc = pStm->Write ((void *)wcszMachineName, dwLen, NULL);
	if ( FAILED (hRc) )
	{
        DebugPrintEx( DEBUG_ERR,
			_T("Fail to Write server name to stream. (hRc: %08X)"), hRc);

        return STG_E_CANTSAVE;
	}
    
    ATLASSERT( S_OK == hRc);
    return hRc;

}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ATLASSERT(pcbSize);

    ULISet32(*pcbSize, (DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR)) + (2 * sizeof(UINT)) + 1);

    return S_OK;
}



/*
 -  CSnapin::GetSizeMax
 -
 *  Purpose:
 *      Checks the object for changes since it was last saved.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\device.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Device.cpp                                             //
//                                                                         //
//  DESCRIPTION   : Fax Server MMC node creation.                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  1 1999 yossg   Change totaly for new mockup version 0.7       //
//      Dec  6 1999 yossg   add  FaxChangeState functionality              //
//      Dec 12 1999 yossg   add  OnPropertyChange functionality            //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//      Oct 17 2000 yossg                                                  //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include <FaxMMC.h>
#include "Device.h"
#include "Devices.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "ppFaxDeviceGeneral.h"

#include "InboundRoutingMethods.h" 

#include "FaxMMCPropertyChange.h"

#include "Icons.h"

#include "oaidl.h"

//Old Num (also in comet) C0548D62-1B45-11d3-B8C0-00104B3FF735
/////////////////////////////////////////////////////////////////////////////
// {3115A19A-6251-46ac-9425-14782858B8C9}
static const GUID CFaxDeviceNodeGUID_NODETYPE = FAXSRV_DEVICE_NODETYPE_GUID;

const GUID*     CFaxDeviceNode::m_NODETYPE        = &CFaxDeviceNodeGUID_NODETYPE;
const OLECHAR*  CFaxDeviceNode::m_SZNODETYPE      = FAXSRV_DEVICE_NODETYPE_GUID_STR;
const CLSID*    CFaxDeviceNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CColumnsInfo CFaxDeviceNode::m_ColsInfo;


CLIPFORMAT CFaxDeviceNode::m_CFPermanentDeviceID = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);
CLIPFORMAT CFaxDeviceNode::m_CFFspGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_FSP_GUID);
CLIPFORMAT CFaxDeviceNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
DWORD   CFaxDeviceNode::GetDeviceID()     
{ 
	return m_dwDeviceID; 
}

/*
 -  CFaxDeviceNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDeviceNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, FXS_WIDE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,
            _T("m_ColsInfo.InsertColumnsIntoMMC"));

        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxDeviceNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create the Fax Device Inbound Routing Methods node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxDeviceNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::PopulateScopeChildrenList"));
    HRESULT             hRc = S_OK; 

    CFaxInboundRoutingMethodsNode * pMethods = NULL;

    //
    // Prepare IConsoleNameSpace for case of failure
    //
    ATLASSERT(m_pComponentData);
    ATLASSERT( ((CSnapin*)m_pComponentData)->m_spConsole );
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( ((CSnapin*)m_pComponentData)->m_spConsole );
    ATLASSERT( spConsoleNameSpace );

    //
    // Fax InboundRoutingMethods Node
    //
    pMethods = new CFaxInboundRoutingMethodsNode(this, m_pComponentData);
    if (!pMethods)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory. (hRc: %08X)"),
			hRc);
        goto Error;
    }
  	else
	{
        pMethods->InitParentNode(this);

        pMethods->SetIcons(IMAGE_METHOD_ENABLE, IMAGE_METHOD_ENABLE);

        hRc = pMethods->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_METHODS);
		    goto Error;
        }

        hRc = AddChild(pMethods, &pMethods->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add the methods node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_METHODS);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethods ) 
    {
        if (0 != pMethods->m_scopeDataItem.ID )
        {
            HRESULT hr = spConsoleNameSpace->DeleteItem(pMethods->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete pMethods;    
        pMethods = NULL;    
    }

    // Empty the list of all Devices added before the one who failed
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}
/*
 -  CFaxDeviceNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxDeviceNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    int iCount;
    WCHAR buff[FXS_MAX_RINGS_LEN+1];
    UINT uiResourceId = 0;

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrDisplayName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDisplayName."));
                goto Error;
            }
            else
            {
                return (m_bstrDisplayName);
            }
            break;

    case 1:
            //
            // Receive
            //            
            if (m_fManualReceive)
            {
                uiResourceId = IDS_DEVICE_MANUAL;
            }
            else
            {
                uiResourceId = (m_fAutoReceive ? IDS_DEVICE_AUTO : IDS_FXS_NO);
            }
                        
            if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for receive value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
            break;

    case 2:
            //
            // Send
            //            
            uiResourceId = (m_fSend ? IDS_FXS_YES : IDS_FXS_NO);
                        
            if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for send value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
            break;

    case 3:
            //
            // Status
            // Although the FAX_DEVICE_STATUS_* constants are defined as bitmasks,
            // in this release there cannot be any combination of bits.
            //
            switch (m_dwStatus)
            {
                case FAX_DEVICE_STATUS_RINGING:
                    uiResourceId = IDS_DEVICE_STATUS_RINGING;
                    break;
                    
                case FAX_DEVICE_STATUS_SENDING:
                    uiResourceId = IDS_DEVICE_STATUS_SENDING;
                    break;
                    
                case FAX_DEVICE_STATUS_RECEIVING:
                    uiResourceId = IDS_DEVICE_STATUS_RECEIVING;
                    break;
                    
                case FAX_DEVICE_STATUS_POWERED_OFF:
                    uiResourceId = IDS_DEVICE_STATUS_POWERED_OFF;
                    break;
                    
                default:
                    //
                    // All other combinations are mapped to 'idle'
                    //
                    uiResourceId = IDS_DEVICE_STATUS_IDLE;
                    break;
            }
            if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for receive value."));
                goto Error;
            }
            else
            {
                return (m_buf);
            }
            break;
            
    case 4:
            //
            // Rings
            //
            iCount = swprintf(buff, L"%ld", m_dwRings);
    
            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - m_dwRings."));
                goto Error;
            }
            else
            {
                m_buf = buff;
                return (m_buf);
            }
            break;

    case 5:
            //
            // Provider
            //            
            if (!m_bstrProviderName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrProviderName."));
                goto Error;
            }
            else
            {
                return (m_bstrProviderName);
            }
            break;

    case 6:
            //
            // Description
            //
            if (!m_bstrDescription)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDescription."));
                goto Error;
            }
            else
            {
                return (m_bstrDescription);
            }
            break;

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxDeviceNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxDeviceNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;


    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    m_pFaxDeviceGeneral = NULL;    

    //
    // General
    //
    m_pFaxDeviceGeneral = new CppFaxDeviceGeneral(
												 handle,
                                                 this,
                                                 m_pParentNode,
                                                 m_dwDeviceID,
                                                 _Module.GetResourceInstance());

	if (!m_pFaxDeviceGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
	
    hRc = m_pFaxDeviceGeneral->InitRPC();	
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to call RPC to init property page for the General tab. (hRc: %08X)"),
			hRc);
        goto Error;
    }

    hRc = lpProvider->AddPage(m_pFaxDeviceGeneral->Create());
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General Tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pFaxDeviceGeneral ) 
    {
        delete  m_pFaxDeviceGeneral;    
        m_pFaxDeviceGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxDeviceNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDeviceNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
 -  CFaxDeviceNode::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::InitRPC( PFAX_PORT_INFO_EX * pFaxDeviceConfig )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::InitRPC"));
    
    ATLASSERT(NULL == (*pFaxDeviceConfig) );
    
    HRESULT        hRc        = S_OK;
    DWORD          ec         = ERROR_SUCCESS;
    
    //
    // get RPC Handle
    //   
    ATLASSERT(m_pFaxServer);

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the Device configuration
	//
    if (!FaxGetPortEx(m_pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &( *pFaxDeviceConfig))) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(*pFaxDeviceConfig);
	
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    //Important!!!
    *pFaxDeviceConfig = NULL;

    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}

/*
 -  CFaxDeviceNode::Init
 -
 *  Purpose:
 *      Initiates the private members 
 *      from configuration structure pointer.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::Init( PFAX_PORT_INFO_EX  pFaxDeviceConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::Init"));
        
    ATLASSERT(NULL != (pFaxDeviceConfig) );
    
    HRESULT        hRc        = S_OK;
    
    m_pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();

    if(!m_pFaxServer)
    {
        ATLASSERT(m_pFaxServer);
        return E_FAIL;
    }

    //
    // Constant device members
    //
    m_dwDeviceID       = pFaxDeviceConfig->dwDeviceID;

    m_bstrDisplayName  = pFaxDeviceConfig->lpctstrDeviceName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
	
    m_bstrProviderName = pFaxDeviceConfig->lpctstrProviderName;
    if (!m_bstrProviderName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrProviderGUID = pFaxDeviceConfig->lpctstrProviderGUID;
    if (!m_bstrProviderGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    //
    // Varied device members
    //
    hRc = UpdateMembers(pFaxDeviceConfig);
    if (S_OK != hRc)
    {
        goto Exit; //dbgmsg + MSgBox by called Func.
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    NodeMsgBox(IDS_MEMORY);
    
Exit:
    return (hRc);
}


/*
 -  CFaxDeviceNode::UpdateMembers
 -
 *  Purpose:
 *      Initiates the private members 
 *      from configuration structure pointer.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::UpdateMembers( PFAX_PORT_INFO_EX  pFaxDeviceConfig )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::UpdateMembers"));
    
    HRESULT        hRc        = S_OK;
    
    // func. must been called just
    // after a call to retreive config structure 
    // was done successfully!
    ATLASSERT(NULL != pFaxDeviceConfig );
    
    // We are not supporting change of DeviceID
    ATLASSERT(m_dwDeviceID == pFaxDeviceConfig->dwDeviceID);
    
    if(!pFaxDeviceConfig->lptstrDescription)
    {
        m_bstrDescription = L"";
    }
    else
    {
        m_bstrDescription = pFaxDeviceConfig->lptstrDescription;
    }
    if (!m_bstrDescription)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_fSend            = pFaxDeviceConfig->bSend;
    
    switch (pFaxDeviceConfig->ReceiveMode)
    {
        case FAX_DEVICE_RECEIVE_MODE_OFF:    // Do not answer to incoming calls
            m_fAutoReceive     = FALSE;
            m_fManualReceive   = FALSE;
            break;

        case FAX_DEVICE_RECEIVE_MODE_AUTO:   // Automatically answer to incoming calls after dwRings rings
            m_fAutoReceive     = TRUE;
            m_fManualReceive   = FALSE;
            break;

        case FAX_DEVICE_RECEIVE_MODE_MANUAL: // Manually answer to incoming calls - only FaxAnswerCall answers the call
            m_fManualReceive   = TRUE;
            m_fAutoReceive     = FALSE;
            break;
        
        default:
            ATLASSERT(FALSE);
		    
            DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Unexpected m_pFaxDeviceConfig->ReceiveMode"));

    }
    
    m_dwRings          = pFaxDeviceConfig->dwRings;

    m_dwStatus         = pFaxDeviceConfig->dwStatus;        

    m_bstrCsid         = pFaxDeviceConfig->lptstrCsid;
    if (!m_bstrCsid)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    m_bstrTsid         = pFaxDeviceConfig->lptstrTsid;
    if (!m_bstrTsid)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
	
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    //Important!!!
    //FaxFreeBuffer by called Func.
    //(*pFaxDeviceConfig) = NULL;

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    NodeMsgBox(IDS_MEMORY);
    
Exit:
    return (hRc);
}


/*
 -  CFaxDeviceNode::UpdateDeviceStatus
 -
 *  Purpose:
 *      UpdateDeviceStatus 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::UpdateDeviceStatus( DWORD  dwDeviceStatus )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::UpdateDeviceStatus"));

    m_dwStatus = dwDeviceStatus;
    
    if ( m_dwStatus & FAX_DEVICE_STATUS_POWERED_OFF)
    {
        SetIcons(IMAGE_DEVICE_POWERED_OFF, IMAGE_DEVICE_POWERED_OFF);
    }
    else
    {
        SetIcons(IMAGE_DEVICE, IMAGE_DEVICE);
    }

    return S_OK;
}

/*
 -  CFaxDeviceNode::RefreshAllViews
 -
 *  Purpose:
 *      Call IResultData::UpdateItem
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return:
 */
HRESULT
CFaxDeviceNode::RefreshAllViews(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::RefreshAllViews"));
    HRESULT     hRc = S_OK;
    
    ATLASSERT( pConsole != NULL );

    hRc = pConsole->UpdateAllViews(NULL, NULL, NULL);

    if ( FAILED(hRc) )
    {
		DebugPrintEx(
			DEBUG_ERR,
            _T("Fail to UpdateAllViews, hRc=%08X"),
            hRc);
        NodeMsgBox(IDS_REFRESH_VIEW);
    }
    return hRc;
}


/*
 -  CFaxDeviceNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the object .
 *      First it gets data structure, inits members 
 *      and frees the structure. 
 *      The last thing is to refresh the view.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDeviceNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::DoRefresh"));
    HRESULT              hRc              = S_OK;
    
    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;

    //
    // Get the Config. structure with FaxGetPortEx
    //
    hRc = InitRPC(&pFaxDeviceConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxDeviceConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxDeviceConfig);
    
    //
    // init members
    //    
    hRc = UpdateMembers(pFaxDeviceConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        goto Error;
    }

    //
    // Free Buffer - Important!!! 
    // == done on exit  ==
    //

    //
    // Refresh only this device's view
    //
    hRc = RefreshTheView();    
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( FAILED(hRc) )
    {
    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to Refresh (hRc : %08X)"),
        hRc);
    }

Exit:
    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
        pFaxDeviceConfig = NULL;
    }//any way function quits with memory allocation freed       

    return hRc;
}


/*
 -  CFaxDeviceNode::OnRefresh
 -
 *  Purpose:
 *      Called by MMC to refresh the object .
 *      First it gets data structure, inits members 
 *      and frees the structure. 
 *      Second thing is recursive refresh. 
 *      The third thing is to refresh the view.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDeviceNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnRefresh"));

    return DoRefresh();
}

/*
 -  CFaxDeviceNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements an update for the check mark
 *      beside the Receive and the Send menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxDeviceNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf); 
    
    ATLASSERT(m_fManualReceive && m_fAutoReceive); //plese see: "[yossg] Please notice" above.
    
    switch (id)
    {
        case IDM_FAX_DEVICE_SEND:
            *flags = (m_fSend ? MF_ENABLED | MF_CHECKED : MF_ENABLED | MF_UNCHECKED);
            break;
        case IDM_FAX_DEVICE_RECEIVE_AUTO: 
            *flags = (m_fAutoReceive ? MF_ENABLED | MF_CHECKED : MF_ENABLED | MF_UNCHECKED);   
            break;
        case IDM_FAX_DEVICE_RECEIVE_MANUAL: 
            if(m_pFaxServer->GetServerAPIVersion() == FAX_API_VERSION_0)
            {
                //
                // The remote fax server is SBS/BOS 2000
                // is does not support manual answering
                //
                *flags = MF_DISABLED | MF_GRAYED | MF_UNCHECKED;
            }
            else
            {
                *flags = (m_fManualReceive ? MF_ENABLED | MF_CHECKED : MF_ENABLED | MF_UNCHECKED);   
            }
            break;
        default:
            break;
    }
    return;
}

/*
 -  CFaxDeviceNode::OnFaxReceive
 -
 *  Purpose:
 *      Called when Receive Faxes was pushed.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::OnFaxReceive (UINT nID, bool &bHandled, CSnapInObjectRootBase *pRoot)
{ 
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnFaxReceive"));
    HRESULT hRc = S_OK;
    
    // The check mark state 
    BOOL fNewState;
    
    
        
    if ( IDM_FAX_DEVICE_RECEIVE_AUTO == nID)
    {
        fNewState = !m_fAutoReceive;
    }
    else if (IDM_FAX_DEVICE_RECEIVE_MANUAL == nID)
    {
        fNewState = !m_fManualReceive;
    }
    else
    {
        ATLASSERT(FALSE);
        
        DebugPrintEx(
            DEBUG_ERR,
            _T("Unexpected function call. (hRc: %08X)"),
            hRc);

        hRc = E_UNEXPECTED;
        goto Exit;
    }

    hRc = FaxChangeState(nID, fNewState);
    if ( S_OK != hRc )
    {
        //DebugPrint in the function layer
        return S_FALSE;
    }

    //
    // Service succeded. now change member
    //
    // Update new state(s) done here by FaxChangeState;

    //
    // In case Manual Receive was taken we do not have to refresh the view
    // In such a case all devices are refreshed !!!
    //
    
Exit:
    return hRc; 
}

/*
 -  CFaxDeviceNode::OnFaxSend
 -
 *  Purpose:
 *      Called when Send Faxes was pushed.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::OnFaxSend(bool &bHandled, CSnapInObjectRootBase *pRoot)
{ 
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnFaxSend"));
    HRESULT hRc = S_OK;
    
    // The check mark state 
    BOOL fNewState;
    
    fNewState = !m_fSend;

    hRc = FaxChangeState(IDM_FAX_DEVICE_SEND, fNewState);
    if ( S_OK != hRc )
    {
        //DebugPrint in the function layer
        return S_FALSE;
    }

    //
    // Service succeded. now change member
    //
    m_fSend = fNewState;

    //
    // Refresh the view 
    //
    hRc = RefreshTheView(); 
    if ( S_OK != hRc )
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to RefreshTheView(). (hRc: %08X)"),
            hRc);
        
        goto Exit;
    }

Exit:
    return hRc; 
}

/*
 -  CFaxDeviceNode::FaxChangeState
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDeviceNode::FaxChangeState(UINT uiIDM, BOOL fState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::FaxChangeState"));
	
    HRESULT            hRc        = S_OK;

    DWORD              ec         = ERROR_SUCCESS;
    
    // check input
    ATLASSERT( 
               (IDM_FAX_DEVICE_RECEIVE == uiIDM) 
              || 
               (IDM_FAX_DEVICE_SEND_AUTO == uiIDM)
              ||
               (IDM_FAX_DEVICE_RECEIVE_MANUAL == uiIDM)
             );

    PFAX_PORT_INFO_EX  pFaxDeviceInfo = NULL;
    
    //
    // Get Configuration
    //
    ATLASSERT(m_pFaxServer);

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	// Retrieve the Device configuration
    if (!FaxGetPortEx(m_pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &pFaxDeviceInfo)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDeviceInfo);

    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    //
    // Change State 
    //
    switch (uiIDM)
	{
	    case IDM_FAX_DEVICE_SEND:
		    
            pFaxDeviceInfo->bSend = fState;
		    break;

        case IDM_FAX_DEVICE_RECEIVE_AUTO:
		    
            pFaxDeviceInfo->ReceiveMode = 
                ( fState ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF); 
		    break;

        case IDM_FAX_DEVICE_RECEIVE_MANUAL:
		    
            pFaxDeviceInfo->ReceiveMode = 
                ( fState ? FAX_DEVICE_RECEIVE_MODE_MANUAL : FAX_DEVICE_RECEIVE_MODE_OFF); 
		    break;

    }
    
    //
    // Set Configuration
    //
    if (!FaxSetPortEx(
                m_pFaxServer->GetFaxServerHandle(),
                m_dwDeviceID,
                pFaxDeviceInfo)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set device configuration. (ec: %ld)"), 
			ec);

        if ( FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED == ec )
        {
            hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            
            NodeMsgBox(IDS_ERR_ADMIN_DEVICE_LIMIT, MB_OK|MB_ICONEXCLAMATION);

            goto Exit;
        }
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    //
    // Set members in cases of Receive
    //
    if ( uiIDM == IDM_FAX_DEVICE_RECEIVE_AUTO || uiIDM == IDM_FAX_DEVICE_RECEIVE_MANUAL)
    {
        if ( FAX_DEVICE_RECEIVE_MODE_MANUAL == pFaxDeviceInfo->ReceiveMode )
        {
            ATLASSERT(m_pParentNode);
            hRc = m_pParentNode->DoRefresh();
            if (S_OK != hRc)
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to call DoRefresh(). (hRc: %08X)"), 
                    hRc);
                
                goto Error;
            }
        }
        else
        {            
            hRc = DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call DoRefresh. (hRc: %08X)"),
			        hRc);
    
            }
        }
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set device configuration."));
    
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    if ( NULL != pFaxDeviceInfo )
        FaxFreeBuffer(pFaxDeviceInfo);
    
    return hRc;
}

HRESULT
CFaxDeviceNode::RefreshTheView()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::RefreshTheView"));
    HRESULT     hRc = S_OK;

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    CComPtr<IConsole> spConsole;
    spConsole = m_pComponentData->m_spConsole;
    CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( spConsole );
    
    SCOPEDATAITEM*    pScopeData;

    //
    // Get the updated SCOPEDATAITEM
    //
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        goto Error;
    }

    //
    // This will force MMC to redraw the scope group node
    //
    hRc = spNamespace->SetItem( pScopeData );
    if (FAILED(hRc))
    {
       DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to set Item pScopeData. (hRc: %08X)"),
			hRc);

        goto Error;
    }
    ATLASSERT( S_OK != hRc);
    
    goto Exit;

Error:
    NodeMsgBox(IDS_FAIL2REFRESH_DEVICE);

Exit:
    return hRc;
}


/*
 +
 +
 *
 *  CFaxDeviceNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxDeviceNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;


    if (cf == m_CFPermanentDeviceID)
	{
		DWORD dwDeviceID;
		dwDeviceID = GetDeviceID();
		hr = pStream->Write((VOID *)&dwDeviceID, sizeof(DWORD), &uWritten);
		return hr;
	}

	if (cf == m_CFFspGuid)
	{
		CComBSTR bstrGUID;
		bstrGUID = GetFspGuid();
		hr = pStream->Write((VOID *)(LPWSTR)bstrGUID, sizeof(WCHAR)*(bstrGUID.Length()+1), &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
                ATLASSERT(GetRootNode());
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
                if (!bstrServerName)
                {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. Failed to load string."));
        
                    return E_OUTOFMEMORY;
                }
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, sizeof(WCHAR)*(bstrServerName.Length()+1), &uWritten);
		return hr;
	}

	else 
        return CSnapInItemImpl<CFaxDeviceNode>::FillData(cf, pStream);
}


/*
 +
 +  CFaxDeviceNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxDeviceNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_DEVICES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\devices.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Devices.h                                              //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxDevicesNode class                  //
//                  This is the "Fax" node in the scope pane.              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   create                                         //
//      Dec  1 1999 yossg   Change totaly for New Mockup (0.7)             //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_DEVICES_H
#define H_DEVICES_H

#include "snapin.h"
#include "snpnscp.h" //#include "snpnode.h"

class CFaxDevicesAndProvidersNode;

class CFaxDevicesNode : public CNodeWithScopeChildrenList<CFaxDevicesNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxDevicesNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxDevicesNode)
    END_SNAPINTOOLBARID_MAP()

    CFaxDevicesNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxDevicesNode, FALSE>(pParentNode, pComponentData )
    {
        m_pFaxDevicesConfig               = NULL;
        m_dwNumOfDevices                  = FXS_ITEMS_NEVER_COUNTED;

        m_bIsCollectingDeviceNotification = FALSE;
    }

    ~CFaxDevicesNode()
    {
        if (m_pFaxDevicesConfig)
        {
            FaxFreeBuffer(m_pFaxDevicesConfig);
        }
    }

	//
	// get data from RPC 
	//
    HRESULT InitRPC();

	//
	// MMC functions
	//
    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    // virtual
    HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );
    

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxDevicesAndProvidersNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT DoRefresh();

    HRESULT InitDisplayName();

    HRESULT RepopulateScopeChildrenList();

    HRESULT UpdateDeviceStatusChange( DWORD dwDeviceId, DWORD dwNewStatus);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);
private:
    
    static CColumnsInfo             m_ColsInfo;

    CFaxDevicesAndProvidersNode *   m_pParentNode;

    PFAX_PORT_INFO_EX               m_pFaxDevicesConfig;
    DWORD                           m_dwNumOfDevices;

    BOOL                            m_bIsCollectingDeviceNotification;

    HRESULT                         UpdateTheView();
};

typedef CNodeWithScopeChildrenList<CFaxDevicesNode, FALSE>
        CBaseFaxDevicesNode;


#endif  //H_DEVICES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\devices.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Devices.cpp                                            //
//                                                                         //
//  DESCRIPTION   : Fax Devices MMC node.                                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  1 1999 yossg   Change totaly for new mockup version 0.7       //
//      Aug  3 2000 yossg   Add Device status real-time notification       //
//      Oct 17 2000 yossg                                                  //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Manual Receive support                     //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "DevicesAndProviders.h"
#include "Devices.h"
#include "Device.h"

#include "FaxMMCPropertyChange.h"

#include "Icons.h"

#include "oaidl.h"


/////////////////////////////////////////////////////////////////////////////
// {E6246051-92B4-42d1-9EA4-A7FD132A63F0}
static const GUID CFaxDevicesNodeGUID_NODETYPE = 
{ 0xe6246051, 0x92b4, 0x42d1, { 0x9e, 0xa4, 0xa7, 0xfd, 0x13, 0x2a, 0x63, 0xf0 } };

const GUID*    CFaxDevicesNode::m_NODETYPE = &CFaxDevicesNodeGUID_NODETYPE;
const OLECHAR* CFaxDevicesNode::m_SZNODETYPE = OLESTR("E6246051-92B4-42d1-9EA4-A7FD132A63F0");
const CLSID*   CFaxDevicesNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxDevicesNode::m_ColsInfo;


/*
 -  CFaxDevicesNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDevicesNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    HRESULT hRc = S_OK;
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_DEVICES_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_DEVICES_COL2, AUTO_WIDTH},
        {IDS_DEVICES_COL3, AUTO_WIDTH},
        {IDS_DEVICES_COL4, AUTO_WIDTH},
        {IDS_DEVICES_COL5, AUTO_WIDTH},
        {IDS_DEVICES_COL6, AUTO_WIDTH},
        {IDS_DEVICES_COL7, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxDevicesNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesNode::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxDevicesNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;


    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the fax devices configuration
	//
    if (!FaxEnumPortsEx(pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxDevicesConfig,
                        &m_dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxDevicesConfig);
	ATLASSERT(FXS_ITEMS_NEVER_COUNTED != m_dwNumOfDevices);

    
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get devices configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    //
    // allow refresh in case of failure
    //
    m_dwNumOfDevices = 0;

    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}



/*
 -  CFaxDevicesNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Devices nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxDevicesNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::PopulateScopeChildrenList"));
    HRESULT            hRc        = S_OK; 

    CFaxServer     *   pFaxServer = NULL;    
    CFaxDeviceNode *   pDevice;
    DWORD              i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC();
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        m_pFaxDevicesConfig = NULL;
        
        goto Exit; //!!!
    }
    ATLASSERT(NULL != m_pFaxDevicesConfig);
    
    for ( i = 0; i < m_dwNumOfDevices; i++ )
    {
            pDevice = NULL;

            pDevice = new CFaxDeviceNode(
                                        this, 
                                        m_pComponentData); 
            if (!pDevice)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {                        
                hRc = pDevice->Init( &m_pFaxDevicesConfig[i]);
                if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to Init() device members. (hRc: %08X)"),
			            hRc);
		            // NodeMsgBox(IDS_FAILTOADD_DEVICES); by called func.
                    goto Error;
	            }


	            pDevice->InitParentNode(this);

                //
                // Get correct icon
                //
                if ( m_pFaxDevicesConfig[i].dwStatus & FAX_DEVICE_STATUS_POWERED_OFF)
                {
                    pDevice->SetIcons(IMAGE_DEVICE_POWERED_OFF, IMAGE_DEVICE_POWERED_OFF);
                }
                else
                {
                    pDevice->SetIcons(IMAGE_DEVICE, IMAGE_DEVICE);
                }
        
	            hRc = AddChild(pDevice, &pDevice->m_scopeDataItem);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add device to the scope pane. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILTOADD_DEVICES);
                    goto Error;
	            }
                else
                {
                    pDevice = NULL;
                }
            }
    }
    
    //
    // Create the Server Device changes notification window
    //
    if (!m_bIsCollectingDeviceNotification)
    {
        pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
        ATLASSERT(pFaxServer);
        
        //
        // set pointer to device node
        // Try to create the window 
        // and Register to Event Notifications
        //
        hRc = pFaxServer->RegisterForDeviceNotifications(this);
        if (S_OK != hRc)
        {		    
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to RegisterForDeviceNotifications"));
            
            //
            // Populate should succeed here
            //
            hRc = S_OK;

            goto Exit;
        }

        //
        // Update boolean member
        //
        m_bIsCollectingDeviceNotification = TRUE;

        DebugPrintEx(
			DEBUG_MSG,
			_T("Succeed to create Device Status Server Event notification window"));
   }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    //
    //Get Rid
    //
    {    
        //from the last one 
        if ( NULL != pDevice ) //(if new succeeded)
        {
            delete  pDevice;    
        }

        //from all the previous (if there are)
        int j = m_ScopeChildrenList.GetSize();
        for (int index = 0; index < j; index++)
        {
            pDevice = (CFaxDeviceNode *)m_ScopeChildrenList[0];

            hRc = RemoveChild(pDevice);
            if (FAILED(hRc))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to delete device. (hRc: %08X)"), 
                    hRc);
                goto Error;
            }
            delete pDevice;
        }

        // Empty the list of all Devices added before the one who failed
        // already done one by one inside RemoveChild
        // m_ScopeChildrenList.RemoveAll(); 
    
        m_bScopeChildrenListPopulated = FALSE;
    }
Exit:
    return hRc;
}

/*
 -  CFaxDevicesNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDevicesNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Refersh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 
    
    return hRc;
}

/*
 -  CFaxDevicesNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDevicesNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::OnRefresh"));

    HRESULT hRc = S_OK;

    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;

	if (FXS_ITEMS_NEVER_COUNTED != m_dwNumOfDevices)//already Expanded before.
	{
        //
	    // Repopulate Scope Children List
	    //
        hRc = RepopulateScopeChildrenList();
        if (S_OK != hRc)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to RepopulateScopeChildrenList(). (hRc: %08X)"),
			    hRc);
            // Done by called func. NodeMsgBox(FAIL2REPOPULATE_DEVICES_LIST);

            goto Exit;
        }
	}
    else //never expanded before.
	{
		DebugPrintEx(
			DEBUG_MSG,
			_T("User call refresh before expand node's children."));
        //continue to reselect the node.
	}

    //
	// Get the updated SCOPEDATAITEM
	//
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_DEVICESNODE);

        goto Exit;
    }

    //
	// This will force MMC to redraw the scope node
	//
    spConsole = m_pComponentData->m_spConsole;
    ATLASSERT(spConsole);
	
    hRc = spConsole->SelectScopeItem( pScopeData->ID );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to select scope Item. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_DEVICESNODE);
    }

Exit:
    return hRc;
}


/*
 -  CFaxDevicesNode::UpdateTheView
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxDevicesNode::UpdateTheView()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::UpdateTheView()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (S_OK != hRc)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }

    return hRc;
}


/*
 -  CFaxDevicesNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxDevicesNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::DoRefresh()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    hRc = RepopulateScopeChildrenList();
    if (S_OK != hRc)
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Fail to RepopulateScopeChildrenList."));
        //NodeMsgBox by called func.
        
        goto Exit;
    }

    //
    // Refresh Result pane views
    //
    hRc = UpdateTheView();
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T(" Fail to UpdateTheView."));
        //NodeMsgBox by called func.        
    }

Exit:
    return hRc;
}


/*
 -  CFaxDevicesNode::RepopulateScopeChildrenList
 -
 *  Purpose:
 *      RePopulateScopeChildrenList
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDevicesNode::RepopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesNode::RepopulateScopeChildrenList"));
    HRESULT                 hRc = S_OK;

    CFaxDeviceNode *        pChildNode ;

    CComPtr<IConsole> spConsole;
    ATLASSERT(m_pComponentData);

    spConsole = ((CSnapin*)m_pComponentData)->m_spConsole;
    ATLASSERT( spConsole != NULL );
    
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);

    //
    // Remove device objects from list
    //
    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pChildNode = (CFaxDeviceNode *)m_ScopeChildrenList[i];

        hRc = spConsoleNameSpace->DeleteItem(pChildNode->m_scopeDataItem.ID, TRUE);
        if (FAILED(hRc))
        {
            DebugPrintEx(DEBUG_ERR,
                _T("Fail to delete device. (hRc: %08X)"), 
                hRc);
            goto Error;
        }
	delete pChildNode;
    }

    //
    // Empty the list object itself and change it's status
    //
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

    //
    // Rebuild the list
    //
    hRc = PopulateScopeChildrenList();
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
            _T("Fail to populate Devices. (hRc: %08X)"), 
            hRc);
        goto Error;
    }

    m_bScopeChildrenListPopulated = TRUE;

    ATLASSERT(S_OK == hRc);
    DebugPrintEx(DEBUG_MSG,
        _T("Succeeded to Re Populate Devices. (hRc: %08X)"), 
        hRc);
    goto Cleanup;
Error:
   NodeMsgBox(IDS_FAIL2REPOPULATE_DEVICES);

Cleanup:
    return hRc;
}


/*
 -  CFaxDevicesNode::UpdateDeviceStatusChange
 -
 *  Purpose:
 *      Update a specific device status or disable its Manual Receive option. 
 *      If device not found repopulate all devices.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesNode::UpdateDeviceStatusChange( DWORD dwDeviceId, DWORD dwNewStatus)
{
    DEBUG_FUNCTION_NAME(_T("CFaxDevicesNode::UpdateDeviceStatusChange"));

    HRESULT            hRc              = S_OK;
    
    CFaxDeviceNode *   pDeviceNode      = NULL;

	DWORD              dwNodeDeviceID   = 0;

    BOOL               fIsDeviceFound   = FALSE;


    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pDeviceNode = (CFaxDeviceNode *)m_ScopeChildrenList[i];
		dwNodeDeviceID = pDeviceNode->GetDeviceID();

        if ( dwNodeDeviceID == dwDeviceId )
        {
            fIsDeviceFound = TRUE;
    
            hRc = pDeviceNode->UpdateDeviceStatus(dwNewStatus);
            ATLASSERT(S_OK == hRc);

            break;
        }
    }

    if (fIsDeviceFound) //update single device view.
    {
        //
        // Refresh Result pane views
        //
        hRc = pDeviceNode->RefreshTheView();
        if (FAILED(hRc))
        {
            DebugPrintEx( DEBUG_ERR,
		        _T("Failed to RefreshTheView."));
            //NodeMsgBox by called func.        
        }
    }
    else //(!fIsDeviceFound) >>> RepopulateScopeChildrenList
    {
        DebugPrintEx(DEBUG_MSG,
            _T(">>>> Notification for a non peresented device was acheived.\n Retreived updated device list.\n"));
    
        hRc = DoRefresh(); 
        if (FAILED(hRc))
        {
            DebugPrintEx( DEBUG_ERR,
		        _T("Failed to DoRefresh."));
            //NodeMsgBox by called func.        
        }
    }

    
    
    return hRc;
}


/*
 -  CFaxDevicesNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxDevicesNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_DEVICESNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}
/////////////////////////////////////////////////////////////////////////////
/*
 +
 +
 *
 *  CFaxDevicesNode::OnPropertyChange
 *
 *
 *  In our implementation, this method gets called when the 
 *  MMCN_PROPERTY_CHANGE
 *  Notify message is sent for this node.
 *
 *  When the snap-in uses the MMCPropertyChangeNotify function to notify it's
 *  views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
 *  IComponentData and IComponent implementations.
 *
 *  For each device property page, when property page submitted the notification passed to 
 *  to the Devices parent node. This node Refresh all devices if needed (when manual Receive was taken by a device)
 *  or try to locate specific device by its ID from current children list.
 *
 *  Prameters
 *
 *      arg
 *      [in] TRUE if the property change is for a scope pane item.
 *
 *      lParam
 *      This is the param passed into MMCPropertyChangeNotify.
 *
 *
 *  Return Values
 *
 -
 -
 */
//////////////////////////////////////////////////////////////////////////////
HRESULT CFaxDevicesNode::OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( _T("CFaxDeviceNode::OnPropertyChange"));

    HRESULT hRc = S_OK;
    CComPtr<IConsole>   spConsole;

    CFaxDevicePropertyChangeNotification * pNotification;

    //
    // Encode Property Change Notification data
    //
    pNotification = reinterpret_cast<CFaxDevicePropertyChangeNotification *>(param);
    ATLASSERT( pNotification );
    ATLASSERT( DeviceFaxPropNotification == pNotification->enumType );

    BOOL fIsDeviceFound = FALSE;

    if ( !pNotification->fIsToNotifyAdditionalDevices)
    {
        //
        // try to find the device and refresh it only
        // from all the scope children list
        //
        DebugPrintEx(
			DEBUG_MSG,
			_T("Try to locate device by ID"));

        CFaxDeviceNode * pDevice;
        
        int j = m_ScopeChildrenList.GetSize();
        for (int i = 0; i < j; i++)
        {
            pDevice = (CFaxDeviceNode *)m_ScopeChildrenList[i];
            ATLASSERT( pDevice);

            if ( pDevice->GetDeviceID() == pNotification->dwDeviceID )
            {
                DebugPrintEx(
			        DEBUG_MSG,
			        _T("Succeed to locate device by ID"));
                
                fIsDeviceFound = TRUE;
                
                hRc = pDevice->DoRefresh();
                if (S_OK != hRc)
                {
                    DebugPrintEx(
			            DEBUG_ERR,
			            _T("Failed to call OnRefresh()"));

                    //NodeMsgBox called if needed by the called func 

                    goto Exit;
                }

                break;
            }
            pDevice = NULL;
        }
    }
        
    if ( pNotification->fIsToNotifyAdditionalDevices  || !fIsDeviceFound)
    {
        DebugPrintEx(
			DEBUG_MSG,
			_T("Decide to refresh all devices"));

        //
        // Refresh all devices 
        //
        hRc = DoRefresh();  
        if (S_OK != hRc)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Failed to call DoRefresh()"));

            //NodeMsgBox called if needed by the called func 

            goto Exit;
        }
    }
    

Exit:    
    
    //
    // Anyway
    //
    delete pNotification;
    
    
    return hRc;
}

/*
 +
 +  CFaxDevicesNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxDevicesNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_DEVICES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\devicesandproviders.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DevicesAndProviders.h                                  //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxDevicesAndProvidersNode class      //
//                  This is the "Fax" node in the scope pane.              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  9 1999 yossg   Reorganize Populate ChildrenList,              //
//                          and the call to InitDisplayName                //
//                                                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_DEVICESANDPROVIDERS_H
#define H_DEVICESANDPROVIDERS_H
//#pragma message( "H_DEVICESANDPROVIDERS_H" )


#include "snapin.h"
#include "snpnscp.h"

class CFaxServerNode;

class CFaxDevicesAndProvidersNode : public CNodeWithScopeChildrenList<CFaxDevicesAndProvidersNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxDevicesAndProvidersNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxDevicesAndProvidersNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    CFaxDevicesAndProvidersNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxDevicesAndProvidersNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxDevicesAndProvidersNode()
    {
    }

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    
    static CColumnsInfo    m_ColsInfo;

    CFaxServerNode *       m_pParentNode;
};



#endif  //H_DEVICESANDPROVIDERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\devicesandproviders.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : AllFaxDevices.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Server MMC node creation.                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Create                                         //
//      Dec  9 1999 yossg   Reorganize Populate ChildrenList,              //
//                          and the call to InitDisplayName                //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "DevicesAndProviders.h"
#include "Devices.h"
#include "Providers.h" 


//here to #include Dialog H files

#include "Icons.h"

#include "oaidl.h"


/////////////////////////////////////////////////////////////////////////////
// {CCC43AB5-C788-46df-9268-BB96CA5E3DAC}
static const GUID CFaxDevicesAndProvidersNodeGUID_NODETYPE = 
{ 0xccc43ab5, 0xc788, 0x46df, { 0x92, 0x68, 0xbb, 0x96, 0xca, 0x5e, 0x3d, 0xac } };

const GUID*    CFaxDevicesAndProvidersNode::m_NODETYPE = &CFaxDevicesAndProvidersNodeGUID_NODETYPE;
const OLECHAR* CFaxDevicesAndProvidersNode::m_SZNODETYPE = OLESTR("CCC43AB5-C788-46df-9268-BB96CA5E3DAC");
const CLSID*   CFaxDevicesAndProvidersNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxDevicesAndProvidersNode::m_ColsInfo;

/*
 -  CFaxDevicesAndProvidersNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxDevicesAndProvidersNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxDevicesAndProvidersNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, FXS_LARGE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC"));
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxDevicesAndProvidersNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Devices nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxDevicesAndProvidersNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxDevicesAndProvidersNode::PopulateScopeChildrenList"));
    HRESULT             hRc         = S_OK; 

    CFaxDevicesNode *   pDevices    = NULL;
    CFaxProvidersNode * pProviders  = NULL;

    //
    // Fax Devices
    //
    pDevices = new CFaxDevicesNode(this, m_pComponentData);
    if (!pDevices)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pDevices->InitParentNode(this);
        pDevices->SetIcons(IMAGE_DEVICE, IMAGE_DEVICE);

        hRc = pDevices->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display devices node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_DEVICES);
		    goto Error;
        }

        hRc = AddChild(pDevices, &pDevices->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add Devices node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_DEVICES);
            goto Error;
		}
	}

    //
    // Fax Providers
    //
    pProviders = new CFaxProvidersNode(this, m_pComponentData);
    if (!pProviders)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pProviders->InitParentNode(this);

        pProviders->SetIcons(IMAGE_FSP, IMAGE_FSP);

        hRc = pProviders->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display providers node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_PROVIDERS);
		    goto Error;
        }

        hRc = AddChild(pProviders, &pProviders->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add providers node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_PROVIDERS);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pDevices ) 
    {
        if (0 != pDevices->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pDevices);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() devices node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pDevices;    
        pDevices = NULL;    
    }
    if ( NULL != pProviders ) 
    {
        if (0 != pProviders->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pProviders);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Providers node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pProviders;    
        pProviders = NULL;    
    }

     
    // Empty the list
    //m_ScopeChildrenList.RemoveAll(); done step by step from RemoveChild

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}




/*
 -  CFaxDevicesAndProvidersNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxDevicesAndProvidersNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{

    HRESULT hRc = S_OK;
    
    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    
    return hRc;
}


/*
 -  CFaxDevicesAndProvidersNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxDevicesAndProvidersNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxDevicesAndProvidersNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_DEVICESANDPROVIDERSNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 +
 +  CFaxDevicesAndProvidersNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxDevicesAndProvidersNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_DEVICES);
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgconfirmpassword.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgConfirmPassword.h                                   //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgConfirmPassword class.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 27 2000 yossg   Create                                         //
//                                                                         //
//		Windows XP                                                         //
//      Feb 11 2001 yossg   Changed to include Credentials and Confirm     //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLG_CONFIRM_PASSWORD_INCLUDED
#define DLG_CONFIRM_PASSWORD_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgConfirmPassword

class CDlgConfirmPassword :
             public CDialogImpl<CDlgConfirmPassword>
{
public:
    CDlgConfirmPassword();

    ~CDlgConfirmPassword();

    enum { IDD = IDD_CONFIRM_PASSWORD };

BEGIN_MSG_MAP(CDlgConfirmPassword)
    MESSAGE_HANDLER   ( WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER( IDOK,          OnOK)
    COMMAND_ID_HANDLER( IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,   OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,          OnHelpRequest)

    COMMAND_HANDLER( IDC_SMTP_USERNAME_EDIT, EN_CHANGE,  OnTextChanged)
    COMMAND_HANDLER( IDC_SMTP_PASSWORD_EDIT,    EN_CHANGE,  OnPasswordChanged)
    COMMAND_HANDLER( IDC_CONFIRM_PASSWORD_EDIT, EN_CHANGE,  OnPasswordChanged)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPasswordChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);    
    LRESULT OnTextChanged (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT InitCredentialsDlg(BSTR bstrUserName);

    inline BOOL IsPasswordModified()
    {
        return m_fIsPasswordChangedAndConfirmed;
    }

    inline  WCHAR * GetPassword() 
    {     
        return m_bstrPassword.m_str;
    }
    
    inline const CComBSTR&  GetUserName() 
    {   
        return  m_bstrUserName; 
    }

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID   EnableOK(BOOL fEnable);

    BOOL   IsValidData(
                     BSTR bstrUserName, 
                     BSTR bstrPassword, 
                     /*[OUT]*/int *pCtrlFocus);

    //
    // Controls
    //
    CEdit     m_UserNameBox;
    CEdit     m_PasswordBox;
    CEdit     m_ConfirmPasswordBox;

    //
    // members for data
    //
    BOOL      m_fIsPasswordDirty;
    BOOL      m_fIsConfirmPasswordDirty;
    BOOL      m_fIsPasswordChangedAndConfirmed;
    
    BOOL      m_fIsDialogInitiated;

    CComBSTR  m_bstrUserName;
    CComBSTR  m_bstrPassword;
};

#endif // DLG_CONFIRM_PASSWORD_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgnewgroup.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewGroup.h                                          //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgNewFaxOutboundGroup class.     //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGNEWOUTGROUP_H_INCLUDED
#define DLGNEWOUTGROUP_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundGroup
class CFaxServer;
class CDlgNewFaxOutboundGroup :
    public CDialogImpl<CDlgNewFaxOutboundGroup>
{
public:
    CDlgNewFaxOutboundGroup(CFaxServer * pFaxServer):m_pFaxServer(pFaxServer)
	{
		ATLASSERT(pFaxServer);
	}

    ~CDlgNewFaxOutboundGroup();

    enum { IDD = IDD_DLGNEWGROUP };

BEGIN_MSG_MAP(CDlgNewFaxOutboundGroup)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    COMMAND_HANDLER(IDC_GROUPNAME_EDIT, EN_CHANGE, OnTextChanged)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTextChanged (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID      EnableOK(BOOL fEnable);

    CFaxServer * m_pFaxServer;

    //
    // Controls
    //
    CEdit     m_GroupNameEdit;

    CComBSTR  m_bstrGroupName;    
};

#endif // DLGNEWOUTGROUP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgnewdevice.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewDevice.h                                          //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgNewFaxOutboundDevice class.     //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGNEWOUTDEVICE_H_INCLUDED
#define DLGNEWOUTDEVICE_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundDevice
class CFaxServer;

class CDlgNewFaxOutboundDevice :
    public CDialogImpl<CDlgNewFaxOutboundDevice>
{
public:
	
    CDlgNewFaxOutboundDevice(CFaxServer * pFaxServer);

    ~CDlgNewFaxOutboundDevice();

    enum { IDD = IDD_DLGNEWDEVICE };

BEGIN_MSG_MAP(CDlgNewFaxOutboundDevice)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    NOTIFY_HANDLER  (IDC_DEVICE_LISTVIEW,  LVN_ITEMCHANGED,  OnListViewItemChanged)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT InitDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID, BSTR bstrGroupName);
    HRESULT InitAssignedDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID);
    HRESULT InitAllDevices( );
    
    HRESULT InitDeviceNameFromID(DWORD dwDeviceID, BSTR * pbstrDeviceName);
    HRESULT InsertDeviceToList(UINT uiIndex, DWORD dwDeviceID);

    LRESULT OnListViewItemChanged (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    //
    // Methods
    //
    VOID            EnableOK(BOOL fEnable);

    //
    // members
    //
    LPDWORD         m_lpdwAllDeviceID;
    DWORD           m_dwNumOfAllDevices;
    
    LPDWORD         m_lpdwAssignedDeviceID;
    DWORD           m_dwNumOfAssignedDevices;

    DWORD           m_dwNumOfAllAssignedDevices;

    CComBSTR        m_bstrGroupName;
    
    //
    // Controls
    //
    CListViewCtrl   m_DeviceList;

	CFaxServer * m_pFaxServer;
};

#endif // DLGNEWOUTDEVICE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgnewgroup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewGroup.cpp                                        //
//                                                                         //
//  DESCRIPTION   : The CDlgNewFaxOutboundGroup class implements the       //
//                  dialog for additon of new Group.                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgNewGroup.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "dlgutils.h"

//#include "Helper.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundGroup

CDlgNewFaxOutboundGroup::~CDlgNewFaxOutboundGroup()
{
}

/*
 +  CDlgNewFaxOutboundGroup::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundGroup::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnInitDialog"));
    HRESULT hRc = S_OK;    

    //
    // Attach controls
    //
    m_GroupNameEdit.Attach(GetDlgItem(IDC_GROUPNAME_EDIT));
        
    //
    // Set length limit to area code
    //
    m_GroupNameEdit.SetLimitText(MAX_ROUTING_GROUP_NAME - 1);

    //
    // Set focus
    //
    ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));

    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgNewFaxOutboundGroup::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundGroup::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;

    //
    // Step 0: PreApply Checks
    //
/*    
    if (!CheckValidtity())
    {
        EnableOK(FALSE);
        hRc =S_FALSE;
        goto Exit;
    }
*/
    //
    // Step 1: get data
    //
        if ( !m_GroupNameEdit.GetWindowText(&m_bstrGroupName))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&m_bstrGroupName)"));
            DlgMsgBox(this, IDS_FAIL2READ_GROUPNAME);
            ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));
            hRc = S_FALSE;
            
            goto Exit;
        }

    
    //
    // Step 2: add group via RPC call
    //

    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Add the group
    //
    if (!FaxAddOutboundGroup (
	        m_pFaxServer->GetFaxServerHandle(),
	        (LPCTSTR)m_bstrGroupName))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to add group. (ec: %ld)"), 
			ec);
        if (ERROR_DUP_NAME == ec) 
        {            
            DlgMsgBox(this, IDS_OUTGROUP_EXISTS);
            ::SetFocus(GetDlgItem(IDC_GROUPNAME_EDIT));
            goto Exit;
        }
        else if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
        
    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The group was added successfully."));

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    PageErrorEx(IDS_FAIL_ADD_RULE, GetFaxServerErrorMsg(ec), m_hWnd);
  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgNewFaxOutboundGroup::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text in side the text box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgNewFaxOutboundGroup::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnTextChanged"));

    UINT fEnableOK;
	
    fEnableOK = ( m_GroupNameEdit.GetWindowTextLength() );
    EnableOK(!!fEnableOK);
    return 0;
}

/*
 -  CDlgNewFaxOutboundGroup::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgNewFaxOutboundGroup::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgNewFaxOutboundGroup::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgNewFaxOutboundGroup::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnCancel"));

    EndDialog(wID);
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgNewFaxOutboundGroup::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgNewFaxOutboundGroup::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgNewFaxOutboundGroup::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgconfirmpassword.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgConfirmPassword.cpp                                 //
//                                                                         //
//  DESCRIPTION   : The CDlgConfirmPassword class implements the           //
//                  dialog for additon of new Group.                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 27 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "DlgConfirmPassword.h"

#include "FxsValid.h"
#include "dlgutils.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgConfirmPassword

CDlgConfirmPassword::CDlgConfirmPassword()
{
    m_fIsDialogInitiated       = FALSE;
    
    m_fIsPasswordDirty                = FALSE;
    m_fIsConfirmPasswordDirty         = FALSE;
    m_fIsPasswordChangedAndConfirmed  = FALSE;
}

CDlgConfirmPassword::~CDlgConfirmPassword()
{
}


/*
 +  CDlgConfirmPassword::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgConfirmPassword::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnInitDialog"));  
    HRESULT hRc = S_OK;    

    //
    // Attach controls
    //
    m_UserNameBox.Attach(GetDlgItem(IDC_SMTP_USERNAME_EDIT));
    m_PasswordBox.Attach(GetDlgItem(IDC_SMTP_PASSWORD_EDIT));
    m_ConfirmPasswordBox.Attach(GetDlgItem(IDC_CONFIRM_PASSWORD_EDIT));
        
    //
    // Limit text length
    //
    m_UserNameBox.SetLimitText(FXS_MAX_USERNAME_LENGTH);
    m_PasswordBox.SetLimitText(FXS_MAX_PASSWORD_LENGTH);
    m_ConfirmPasswordBox.SetLimitText(FXS_MAX_PASSWORD_LENGTH);

    //
    // Init textboxes
    //
    m_UserNameBox.SetWindowText( m_bstrUserName);
    m_PasswordBox.SetWindowText( TEXT("******"));
    m_ConfirmPasswordBox.SetWindowText( TEXT("******"));

    m_fIsDialogInitiated = TRUE;

    EnableOK(FALSE);

    return 1;  // Let the system set the focus
}

/*
 +  CDlgConfirmPassword::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgConfirmPassword::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnOK"));
    HRESULT     hRc           = S_OK;

    CComBSTR    bstrUserName;
    CComBSTR    bstrPassword;
    
    BOOL        fSkipMessage  = FALSE;
    int         CtrlFocus     = 0; 
    
    m_fIsPasswordChangedAndConfirmed  = FALSE;

    ATLASSERT (m_UserNameBox.GetWindowTextLength() >0 );//avoided by disabling OK button
    if ( !m_UserNameBox.GetWindowText(&bstrUserName))
    {
        CtrlFocus = IDC_SMTP_USERNAME_EDIT;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to GetWindowText(&bstrUserName)"));
        hRc = E_OUTOFMEMORY;

        goto Error;
    }

    //
    // Any credential change should involve password update and confirmation
    // We are supporting only two scenarioes: 1) Password update and 2) full credentilals change.
    //
    if  ( !(m_fIsPasswordDirty && m_fIsConfirmPasswordDirty) )
    {
        if (!m_fIsPasswordDirty)
        {
            CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
        }
        else // !m_fIsConfirmPasswordDirty
        {
            CtrlFocus = IDC_CONFIRM_PASSWORD_EDIT;
        }

        DebugPrintEx(
            DEBUG_WRN,
            TEXT("!(m_fIsPasswordDirty && m_fIsConfirmPasswordDirty)"));        
        
        DlgMsgBox(this, IDS_INVALID_PASSWORD, MB_OK|MB_ICONEXCLAMATION);

        hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        
        fSkipMessage = TRUE;
        
        goto Error;
    }
    else
    {
        //
        // Only is the password changed, we collect the new text from the control.
        // Otherwise, we leave the string as NULL so that the server won't set it.
        //
        if ( !m_PasswordBox.GetWindowText(&bstrPassword))
        {
            CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrPassword)"));

            hRc = E_OUTOFMEMORY;

            goto Error;
        }

        //
        // To avoid any non controled password insertion we ask for 
        // password confirmation
        //
        CComBSTR    bstrConfirmedPassword;
        if ( !m_ConfirmPasswordBox.GetWindowText(&bstrConfirmedPassword))
        {
            CtrlFocus = IDC_SMTP_PASSWORD_EDIT;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to GetWindowText(&bstrPassword)"));

            hRc = E_OUTOFMEMORY;

            goto Error;
        }

        //
        // Password Compare
        //
        if ( 0 != wcscmp( bstrConfirmedPassword , bstrPassword )  )
        {
            DebugPrintEx(
                DEBUG_MSG,
                _T("The passwords that were entered are not the same."));
        
            DlgMsgBox(this, IDS_PASSWORD_NOT_MATCH, MB_OK|MB_ICONEXCLAMATION);
        
            goto Exit;
        }
        
        m_fIsPasswordChangedAndConfirmed = TRUE;
     }    

    
    //
    // Step 2: Input Validation
    //
    if (!IsValidData(bstrUserName, bstrPassword, &CtrlFocus))
    {
        hRc = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        //in this case detailed message box was given by the called functions
        fSkipMessage = TRUE;
        
        goto Error;
    }

    //
    // Step 3: set the bstrs to the member
    //
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory: Failed to allocate m_bstrUserName"));

        hRc = E_OUTOFMEMORY;

        goto Error;
    }

    if (m_fIsPasswordChangedAndConfirmed)
    {
        m_bstrPassword = bstrPassword;
        if (!m_bstrPassword)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Out of memory: Failed to allocate m_bstrPassword"));

            hRc = E_OUTOFMEMORY;

            goto Error;
        }
    }

    //
    // Step 4: Close the dialog
    //
    ATLASSERT(S_OK == hRc );

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
	
    if (!fSkipMessage)
    {
        if (E_OUTOFMEMORY == hRc)
        {
            DlgMsgBox(this, IDS_MEMORY);
        }
        else
        {
            DlgMsgBox(this, IDS_FAIL2UPDATE_SMTP_CONFIG);
        }
    }
    ::SetFocus(GetDlgItem(CtrlFocus));
  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgConfirmPassword::OnPasswordChanged
 -
 *  Purpose:
 *      Catch changes to the password edit box.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgConfirmPassword::OnPasswordChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnPasswordChanged"));

    if (!m_fIsDialogInitiated) // Event receieved in a too early stage
    {
        return 0;
    }
    
    switch (wID)
    {
        case IDC_SMTP_PASSWORD_EDIT:
            m_fIsPasswordDirty = TRUE;
            break;

        case IDC_CONFIRM_PASSWORD_EDIT:
            m_fIsConfirmPasswordDirty = TRUE;
            break;

        default:
            ATLASSERT(FALSE);
    }
        
    UINT uEnableOK = ( m_UserNameBox.GetWindowTextLength() );
    
    EnableOK(!!uEnableOK);

    return 1;
}


/*
 -  CDlgConfirmPassword::OnTextChanged
 -
 *  Purpose:
 *      Check the validity of text inside a textbox.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgConfirmPassword::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnTextChanged"));

    UINT fEnableOK;
	
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }

    fEnableOK = ( m_UserNameBox.GetWindowTextLength() );
    
    EnableOK(!!fEnableOK);

    return 0;
}

/*
 -  CDlgConfirmPassword::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgConfirmPassword::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgConfirmPassword::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgConfirmPassword::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::OnCancel"));

    EndDialog(wID);
    return 0;
}


/*
 -  CDlgConfirmPassword::InitCredentialsDlg
 -
 *  Purpose:
 *      Initiates the configuration from data retereived by RPC,
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgConfirmPassword::InitCredentialsDlg(BSTR bstrUserName)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::InitCredentialsDlg"));
    
    HRESULT hRc = S_OK;
        
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrUserName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}


/*
 -  CDlgConfirmPassword::IsValidData
 -
 *  Purpose:
 *      To validate all data types before save data.
 *      This level should be responsible that detailed 
 *      error description will be shown to user.
 *
 *  Arguments:
 *      [in]   BSTRs and DWORDs
 *      [out]  iFocus
 *
 *  Return:
 *      BOOOLEAN
 */
BOOL CDlgConfirmPassword::IsValidData(BSTR bstrUserName, BSTR bstrPassword, int * pCtrlFocus)
{
    DEBUG_FUNCTION_NAME( _T("CDlgConfirmPassword::IsValidData"));

    UINT    uRetIDS   = 0;

    ATLASSERT(pCtrlFocus);
    
    //
    // User Name
    //
    if (!IsNotEmptyString(bstrUserName))
    {
        DebugPrintEx( DEBUG_ERR,
			_T("Username string empty or spaces only."));
        uRetIDS = IDS_USERNAME_EMPTY;

        *pCtrlFocus = IDC_SMTP_USERNAME_EDIT;
    
        goto Error;
    }

    //
    // Password
    //

    //Currently do noting. empty string is valid also.
    
    ATLASSERT(0 == uRetIDS);
    goto Exit;
    
Error:    
    ATLASSERT(0 != uRetIDS);

    DlgMsgBox(this, uRetIDS);

    return FALSE;
    
Exit:
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgConfirmPassword::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgConfirmPassword::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgSMTPConfig::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgnewdevice.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgNewDevice.cpp                                        //
//                                                                         //
//  DESCRIPTION   : The CDlgNewFaxOutboundDevice class implements the       //
//                  dialog for additon of new Group.                       //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan  3 2000 yossg    Create                                        //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgNewDevice.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "dlgutils.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundDevice

CDlgNewFaxOutboundDevice::CDlgNewFaxOutboundDevice(CFaxServer * pFaxServer)
{
    m_lpdwAllDeviceID        = NULL;
    m_dwNumOfAllDevices      = 0;

    m_lpdwAssignedDeviceID   = NULL;    
    m_dwNumOfAssignedDevices = 0;
    
    ATLASSERT(pFaxServer);
    m_pFaxServer = pFaxServer;
}

CDlgNewFaxOutboundDevice::~CDlgNewFaxOutboundDevice()
{
    if (NULL != m_lpdwAllDeviceID)
        delete[] m_lpdwAllDeviceID;

    if (NULL != m_lpdwAssignedDeviceID)
        delete[] m_lpdwAssignedDeviceID;
}

/*
 -  CDlgNewFaxOutboundDevice::initDevices
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call,
 *      and current assined devices own parameters
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InitDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID, BSTR bstrGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InitDevices"));
    
    HRESULT hRc = S_OK;
    
    m_bstrGroupName = bstrGroupName;
    if (!m_bstrGroupName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrGroupName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
        
    hRc = InitAssignedDevices(dwNumOfDevices, lpdwDeviceID);
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Failed to InitAssignDevices. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        goto Exit;
    }
    
    hRc = InitAllDevices( );
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Failed to InitRPC. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        goto Exit;
    }
    

    if ( m_dwNumOfAllDevices  <   m_dwNumOfAssignedDevices)
    {
        DebugPrintEx(DEBUG_MSG,
			_T("+++m_dwNumOfAllDevices <m_dwNumOfAssignedDevices.+++ (ec: %0X8)"), hRc);
        
        hRc = E_UNEXPECTED;
        //MsgBox by Caller Function
        
        goto Exit;
    }
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}

/*
 -  CDlgNewFaxOutboundDevice::initAllDevices
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InitAllDevices(  )
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InitAllDevices"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    PFAX_OUTBOUND_ROUTING_GROUP     pFaxGroupsConfig;
    DWORD                           dwNumOfGroups;
    DWORD        i;  //index
    BOOL         fFound     = FALSE;
    
    //
    // get Fax Handle
    //       
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the Outbound Groups configuration
    //
    if (!FaxEnumOutboundGroups(m_pFaxServer->GetFaxServerHandle(), 
                        &pFaxGroupsConfig,
                        &dwNumOfGroups)) 
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    //For max verification
    ATLASSERT(pFaxGroupsConfig);


    for ( i =0; i < dwNumOfGroups; i++  )
    {
        ATLASSERT(NULL != pFaxGroupsConfig);

        if(0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, pFaxGroupsConfig->lpctstrGroupName) )
        {
            fFound = TRUE; 
        }
        else
        {
            pFaxGroupsConfig++;
        }
    }
    
    if(fFound)
    {
        //
        // init m_dwNumOfAllDevices
        //
        m_dwNumOfAllDevices  = pFaxGroupsConfig->dwNumDevices;

        //
        // init m_lpdwAllDeviceID
        //
        if (0 < m_dwNumOfAllDevices)
        {
            m_lpdwAllDeviceID = new DWORD[m_dwNumOfAllDevices];   
            if (NULL == m_lpdwAllDeviceID)
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Error allocating %ld device ids"),
                    m_dwNumOfAllDevices);
                ec = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }                
            memcpy(m_lpdwAllDeviceID, pFaxGroupsConfig->lpdwDevices, sizeof(DWORD)*m_dwNumOfAllDevices) ;
        }
        else
        {
            DebugPrintEx( DEBUG_MSG, _T("++Empty List++ List of All Devices found to be currrently empty."));
            m_lpdwAllDeviceID = NULL;
        }
    }
    else
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("UNEXPECTED ERROR - ALL DEVICES group was not found."));
        ec = ERROR_BAD_UNIT;
        goto Error;
    }
    
    
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to init all devices list."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

   //DlgMsgBox -- NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CDlgNewFaxOutboundDevice::initAssignedDevices
 -
 *  Purpose:
 *      Initiates the list from given params.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InitAssignedDevices(DWORD dwNumOfDevices, LPDWORD lpdwDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InitAssignedDevices"));
    
    HRESULT      hRc        = S_OK;

    //
    // init m_dwNumOfAssignedDevices
    //
    m_dwNumOfAssignedDevices  = dwNumOfDevices;

    //
    // init m_lpdwAssignedDeviceID
    //
    if (0 < m_dwNumOfAssignedDevices)
    {
        m_lpdwAssignedDeviceID = new DWORD[m_dwNumOfAssignedDevices];    
        if (NULL == m_lpdwAssignedDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfAssignedDevices);
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }                
        memcpy(m_lpdwAssignedDeviceID, lpdwDeviceID, sizeof(DWORD)*m_dwNumOfAssignedDevices) ;
    }
    else
    {
        DebugPrintEx( DEBUG_MSG, _T("List of Assigned devices found to be empty."));
        m_lpdwAssignedDeviceID = NULL;
    }
    
    return hRc;
}

/*
 +  CDlgNewFaxOutboundDevice::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundDevice::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnInitDialog"));
    HRESULT hRc = S_OK;    
    
    BOOL    fAssignedDeviceFound;
    BOOL    fAllAssignedDevicesFound;

    LPDWORD lpdwDevice;
    LPDWORD lpdwAssignedDevice;

    DWORD   tmp;
    UINT    uiFoundIndex;

    
    RECT    Rect;

    //
    // Attach controls
    //
    m_DeviceList.Attach(GetDlgItem(IDC_DEVICE_LISTVIEW));
        
    m_DeviceList.GetClientRect(&Rect);
    m_DeviceList.InsertColumn(1, NULL, LVCFMT_LEFT, (Rect.right-Rect.left), 0);
    
    //
    // Fill the Availble Device List
    //
    fAllAssignedDevicesFound = FALSE;    
    uiFoundIndex             = 0;
    lpdwDevice               = &m_lpdwAllDeviceID[0];

    for ( DWORD i = 0; i < m_dwNumOfAllDevices; i++ )
    {
        if(!fAllAssignedDevicesFound)
        {

            fAssignedDeviceFound =FALSE;
            lpdwAssignedDevice = &m_lpdwAssignedDeviceID[0];
            tmp =0;

            for ( DWORD j = 0; j < m_dwNumOfAssignedDevices; j++  )
            {
                // TO DO create more incremental search here also

                ATLASSERT(NULL != lpdwDevice);
                ATLASSERT(NULL != lpdwAssignedDevice);
                
                if( *lpdwDevice == *lpdwAssignedDevice )
                {              
                    fAssignedDeviceFound = TRUE;

                    //Skip this device - It was already assigned
                    lpdwDevice++;

                    if ( ++tmp == m_dwNumOfAssignedDevices )
                        fAllAssignedDevicesFound = TRUE;
                    break;
                }
                else
                {
                    lpdwAssignedDevice++;
                }
            }
            if (!fAssignedDeviceFound)
			{
                InsertDeviceToList(uiFoundIndex++ , *lpdwDevice);
				lpdwDevice++;
			}
        } 
        else  //all assigned devices found 
        {
            ATLASSERT(lpdwDevice);
            
            //insert the rest of all devices to list
            InsertDeviceToList(uiFoundIndex++ , *lpdwDevice);
            lpdwDevice++;
        }
    }
    
    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}


/*
 -  CDlgNewFaxOutboundDevice::InsertDeviceToList
 -
 *  Purpose:
 *      Populate Avaliable devices list and discovers the devices names
 *
 *  Arguments:
 *      [in] uiIndex - index 
 *      [in] dwDeviceID - device ID  
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgNewFaxOutboundDevice::InsertDeviceToList(UINT uiIndex, DWORD dwDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::InsertDeviceToList"));
    
    HRESULT    hRc              = S_OK;
    CComBSTR   bstrDeviceName   = NULL;

    //
    // Discover Device Name
    //
    hRc = InitDeviceNameFromID(dwDeviceID, &bstrDeviceName);
    if (FAILED(hRc))
    {
       //DebugPrint by Called Func.
       goto Exit;
    }

    
    //
    // Insert New line in the list
    //
    m_DeviceList.InsertItem(uiIndex, bstrDeviceName);
    m_DeviceList.SetItemData(uiIndex, dwDeviceID);

Exit:
    return hRc;
}


/*
 -  CDlgNewFaxOutboundDevice::InitDeviceNameFromID
 -
 *  Purpose:
 *      Transslate Device ID to Device Name and insert the data to
 *      m_bstrDeviceName
 *
 *  Arguments:
 *      [in]  dwDeviceID        - device ID
 *      [out] bstrDeviceName    - device Name
 *
 *  Return:
 *      OLE error message 
 */
HRESULT CDlgNewFaxOutboundDevice::InitDeviceNameFromID(DWORD dwDeviceID, BSTR * pbstrDeviceName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetDeviceNameFromID"));
    DWORD          ec         = ERROR_SUCCESS;
    HRESULT        hRc        = S_OK;
    
    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;
    
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the Device configuration
    //
    if (!FaxGetPortEx(m_pFaxServer->GetFaxServerHandle(), 
                      dwDeviceID, 
                      &pFaxDeviceConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDeviceConfig);
    
    
    //
	// Main thing - retrieve the Device Name
	//
    *pbstrDeviceName = SysAllocString(pFaxDeviceConfig->lpctstrDeviceName);
    if ( !(*pbstrDeviceName) )
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
	
    
    
    ATLASSERT(ec == ERROR_SUCCESS);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device name."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    pFaxDeviceConfig = NULL;

    if (ERROR_BAD_UNIT != ec)
	{
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Device Not Found - Fail to discover device name from device ID."));
	}
	else
	{
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to discover device name from device ID. (ec: %ld)"),
			ec);
	}
    hRc = HRESULT_FROM_WIN32(ec);
    
    
Exit:
    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
    }       
	

    return hRc; 
}


/*
 +  CDlgNewFaxOutboundDevice::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundDevice::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;

    DWORD         dwIndex;
    UINT          uiSelectedCount;
    int           nItem;

    LPDWORD		  lpdwNewDeviceID;
    LPDWORD       lpdwTmp;
    
    FAX_OUTBOUND_ROUTING_GROUP  FaxGroupConfig;

    //
    // Step 1: Create the new devices combined list
    //
    ATLASSERT( m_DeviceList.GetSelectedCount() > 0);
    ATLASSERT( m_dwNumOfAssignedDevices >= 0);
    
    uiSelectedCount = m_DeviceList.GetSelectedCount();
    m_dwNumOfAllAssignedDevices = (DWORD)uiSelectedCount 
                                           + m_dwNumOfAssignedDevices;

    lpdwNewDeviceID = new DWORD[m_dwNumOfAllAssignedDevices]; 
    if (NULL == lpdwNewDeviceID)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Error allocating %ld device ids"),
            m_dwNumOfAllAssignedDevices);
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    lpdwTmp = &lpdwNewDeviceID[0];

    DebugPrintEx( DEBUG_MSG,
		_T("    NumOfAllAssignedDevices = %ld \n"), m_dwNumOfAllAssignedDevices);
    //
    // Already assigned part (can be zero size)
    //
    if (m_dwNumOfAssignedDevices > 0)
    {
        memcpy( lpdwNewDeviceID, m_lpdwAssignedDeviceID, sizeof(DWORD)*m_dwNumOfAssignedDevices) ;
        lpdwTmp = lpdwTmp + (int)m_dwNumOfAssignedDevices;
    }
    
    //
    // New devices to assign part (cannot be zero size)
    //
    if (uiSelectedCount > 0)
    {
        nItem = -1; 
        for (dwIndex = m_dwNumOfAssignedDevices; dwIndex < m_dwNumOfAllAssignedDevices; dwIndex++)
        {
            nItem = m_DeviceList.GetNextItem(nItem, LVNI_SELECTED);
            ATLASSERT(nItem != -1);

            *lpdwTmp = (DWORD)m_DeviceList.GetItemData(nItem);
            DebugPrintEx( DEBUG_MSG,
	            _T("    NewDeviceID = %ld.   DeviceOrder=%ld \n"), *lpdwTmp, (dwIndex+1));
            ++lpdwTmp;

        }
    }
    else
    {
        ATLASSERT(0);  //Never reach here
        DlgMsgBox(this, IDS_SELECT_ITEM);
        return 0;
    }

    
    //
    // Step 2: insert the new Id list into the group via RPC call
    //

    //
    // init the group fields and insert the new DeviceIdList  
    //
    ZeroMemory (&FaxGroupConfig, sizeof(FAX_OUTBOUND_ROUTING_GROUP));

    FaxGroupConfig.dwSizeOfStruct   = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
	FaxGroupConfig.lpctstrGroupName = m_bstrGroupName;
    FaxGroupConfig.dwNumDevices     = m_dwNumOfAllAssignedDevices;
	
    //FaxGroupConfig.Status - actually neglected by the service
	FaxGroupConfig.Status           = FAX_GROUP_STATUS_ALL_DEV_VALID;

    FaxGroupConfig.lpdwDevices      = lpdwNewDeviceID;
    
    //
    // get RPC Handle
    //   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // inject the new device list
    //
    if (!FaxSetOutboundGroup(
                m_pFaxServer->GetFaxServerHandle(),
                &FaxGroupConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set the group with new device list. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }
        
        goto Error;
    }


    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The group was added successfully."));

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    PageErrorEx(IDS_FAIL_ADD_DEVICE, GetFaxServerErrorMsg(ec), m_hWnd);

    EnableOK(FALSE);
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgNewFaxOutboundDevice::OnListViewItemChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgNewFaxOutboundDevice::OnListViewItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnListViewItemChanged"));
	
    EnableOK( m_DeviceList.GetSelectedCount() > 0 );
                    
    return 0;
}


/*
 -  CDlgNewFaxOutboundDevice::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgNewFaxOutboundDevice::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgNewFaxOutboundDevice::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgNewFaxOutboundDevice::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundDevice::OnCancel"));

    EndDialog(wID);
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgNewFaxOutboundDevice::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgNewFaxOutboundDevice::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgNewFaxOutboundDevice::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgselectcountry.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgSelectCountry.h                                     //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgSelectCountry class.           //
//                  The class implement the dialog for new Device.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg   Create                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGSELECTCOUNTRY_H_INCLUDED
#define DLGSELECTCOUNTRY_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgSelectCountry
class CFaxServer;

class CDlgSelectCountry :
    public CDialogImpl<CDlgSelectCountry>
{
public:
    CDlgSelectCountry(CFaxServer * pFaxServer);
    ~CDlgSelectCountry();

    enum { IDD = IDD_SELECT_COUNTRYCODE };

BEGIN_MSG_MAP(CDlgSelectCountry)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    COMMAND_HANDLER(IDC_COUNTRYRULE_COMBO,  CBN_SELCHANGE, OnComboChanged)

    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT InitSelectCountryCodeDlg();

    DWORD GetCountryCode(){ return m_dwCountryCode; }

private:
    //
    // Methods
    //
    VOID    EnableOK(BOOL fEnable);
    BOOL    AllReadyToApply(BOOL fSilent);

    //
    // Members
    //
	CFaxServer *                    m_pFaxServer;

    PFAX_TAPI_LINECOUNTRY_LIST      m_pCountryList;
    DWORD                           m_dwNumOfCountries;

    BOOL                            m_fAllReadyToApply;

    //
    // Controls
    //
    CComboBox                       m_CountryCombo;
    
    DWORD                           m_dwCountryCode;
    
};

#endif // DLGSELECTCOUNTRY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgnewrule.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgNewRule.h                                           //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgNewFaxOutboundRule class.      //
//                  The class implement the dialog for new Device.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg   Create                                         //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLGNEWOUTRULE_H_INCLUDED
#define DLGNEWOUTRULE_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundRule
class CFaxServer;

class CDlgNewFaxOutboundRule :
    public CDialogImpl<CDlgNewFaxOutboundRule>
{
public:
    CDlgNewFaxOutboundRule(CFaxServer * pFaxServer);
    ~CDlgNewFaxOutboundRule();

    enum { IDD = IDD_DLGNEWRULE };

BEGIN_MSG_MAP(CDlgNewFaxOutboundRule)
    MESSAGE_HANDLER   (WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER(IDOK,          OnOK)
    COMMAND_ID_HANDLER(IDCANCEL,      OnCancel)
    
    COMMAND_HANDLER(IDC_RULE_AREACODE_EDIT, EN_CHANGE,     OnTextChanged)
    COMMAND_HANDLER(IDC_COUNTRY_RADIO,      BN_CLICKED,    OnRuleTypeRadioClicked)
    COMMAND_HANDLER(IDC_AREA_RADIO,         BN_CLICKED,    OnRuleTypeRadioClicked)
    COMMAND_HANDLER(IDC_DESTINATION_RADIO1, BN_CLICKED,    OnDestenationRadioClicked)
    COMMAND_HANDLER(IDC_DESTINATION_RADIO2, BN_CLICKED,    OnDestenationRadioClicked)

    COMMAND_HANDLER(IDC_NEWRULE_COUNTRYCODE_EDIT,  EN_CHANGE,     OnTextChanged)
    COMMAND_HANDLER(IDC_NEWRULE_SELECT_BUTTON,  BN_CLICKED, OnSelectCountryCodeClicked)

    COMMAND_HANDLER(IDC_DEVICES4RULE_COMBO, CBN_SELCHANGE, OnComboChanged)
    COMMAND_HANDLER(IDC_GROUP4RULE_COMBO,   CBN_SELCHANGE, OnComboChanged)

    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTextChanged            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnComboChanged           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRuleTypeRadioClicked   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectCountryCodeClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT InitRuleDlg();

private:
    //
    // Methods
    //
    VOID    EnableOK(BOOL fEnable);
    BOOL    AllReadyToApply(BOOL fSilent);

    //
    // Members
    //
    CFaxServer * m_pFaxServer;

    PFAX_PORT_INFO_EX               m_pFaxDevicesConfig;
    DWORD                           m_dwNumOfDevices;

    PFAX_OUTBOUND_ROUTING_GROUP     m_pFaxGroupsConfig;
    DWORD                           m_dwNumOfGroups;

    BOOL                            m_fAllReadyToApply;

    //
    // misc members 
    //
    CComBSTR                        m_buf;
    
    //
    // Controls
    //
    CEdit                           m_CountryCodeEdit;
    
    CEdit                           m_AreaCodeEdit;

    CComboBox                       m_DeviceCombo;
    CComboBox                       m_GroupCombo;



};

#endif // DLGNEWOUTRULE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgselectcountry.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgSelectCountry.cpp                                   //
//                                                                         //
//  DESCRIPTION   : The CDlgSelectCountry class implements the             //
//                  dialog for selecting Country code from country ID.     //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 2000 yossg    Create                                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgSelectCountry.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCUtils.h"
#include "dlgutils.h"

#include "Helper.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgSelectCountry

CDlgSelectCountry::CDlgSelectCountry(CFaxServer * pFaxServer)
{    
    m_pCountryList      = NULL;
    m_dwNumOfCountries  = 0;

    m_fAllReadyToApply  = FALSE;

	ATLASSERT(pFaxServer);
	m_pFaxServer = pFaxServer;


}

CDlgSelectCountry::~CDlgSelectCountry()
{
    if (NULL != m_pCountryList)
        FaxFreeBuffer(m_pCountryList);
}

/*
 +  CDlgSelectCountry::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSelectCountry::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnInitDialog"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;
        
    HINSTANCE   hInst;
    hInst = _Module.GetResourceInstance();
    
    PFAX_TAPI_LINECOUNTRY_ENTRYW pCountryEntries;
    pCountryEntries = NULL;

    WCHAR buf[FXS_MAX_COUNTRYNAME_LEN //256 == TAPIUTIL MAX_COUNTRY_NAME 
              +3                       // " (" and ")"
              +FXS_MAX_COUNTRYCODE_LEN // 10
              +1];                     //NULL


    //
    // Attach controls
    //
    m_CountryCombo.Attach(GetDlgItem(IDC_COUNTRYRULE_COMBO));
        
    //
    // Step 1: Init List
    //
    
    //
    // Init country drop-down box
    //
    ATLASSERT(m_pCountryList);
	pCountryEntries = m_pCountryList->LineCountryEntries;    
    for (int i = 0; (DWORD)i < m_dwNumOfCountries; i++ )
    {   
		wsprintf(buf, _T("%s (%d)"),
			pCountryEntries[i].lpctstrCountryName,
			pCountryEntries[i].dwCountryCode);
        
        hRc = AddComboBoxItem ( m_CountryCombo, 
                                buf, //pCountryEntries[i].lpctstrCountryName, 
                                pCountryEntries[i].dwCountryCode,
                                hInst);
        if (FAILED(hRc))
        {
		    DebugPrintEx( DEBUG_ERR, _T("Fail to load country list."));
            PageError(IDS_FAIL2LOADCOUNTRYLIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_COUNTRYRULE_COMBO), FALSE);
            goto Cleanup;
        }

    }


Cleanup:
    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgSelectCountry::OnOK
 +
 *  Purpose:
 *      Submit data
 *      
 *  Arguments:
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSelectCountry::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;
    BOOL          fSkipMessage         = FALSE;

    int           iCurrentSelectedItem = 0;
    
    DWORD         dwCountryCode        = 0;

    //
    // Step 0: PreApply Checks
    //
    ATLASSERT( TRUE == m_fAllReadyToApply );
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        EnableOK(FALSE);
        hRc =S_FALSE;
        goto Exit;
    }

    //
    // Step 1: get selected country 
    //
    iCurrentSelectedItem = m_CountryCombo.GetCurSel();
    ATLASSERT(iCurrentSelectedItem != CB_ERR);          
    
    //
    // Step 2: setCountryCode from the ItemData
    //   
    m_dwCountryCode = (DWORD)m_CountryCombo.GetItemData(iCurrentSelectedItem); 

    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);

    DebugPrintEx( DEBUG_MSG,
		_T("The rule was added successfully."));

    EndDialog(wID);

    goto Exit;
  
Exit:    
    return FAILED(hRc) ? 0 : 1;
}


/*
 -  CDlgSelectCountry::OnComboChanged
 -
 *  Purpose:
 *      Gray/Ungray the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT 
CDlgSelectCountry::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnComboChanged"));

    if (AllReadyToApply(TRUE))
    {
        m_fAllReadyToApply = TRUE;
        EnableOK(TRUE);
    }
    else
    {
        m_fAllReadyToApply = FALSE;
        EnableOK(FALSE);
    }

    return 1;
}


/*
 -  CDlgSelectCountry::AllReadyToApply
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE if all ready to apply, else FALSE.
 */
BOOL 
CDlgSelectCountry::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::AllReadyToApply"));
	
    if ( CB_ERR  ==  m_CountryCombo.GetCurSel())
    {
        if (!fSilent)
        {
            DlgMsgBox(this, IDS_PLEASESELECT_COUNTRY);
            ::SetFocus(GetDlgItem(IDC_COUNTRYRULE_COMBO));
        }
        return FALSE;
    }

 
    return TRUE;           
}

/*
 -  CDlgSelectCountry::EnableOK
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *      [in] fEnable - boolen value tells 
 *                     to Enable or Disable the OK button.
 *
 *  Return:
 *      VOID
 */
VOID
CDlgSelectCountry::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgSelectCountry::OnCancel
 -
 *  Purpose:
 *      End the dialog.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgSelectCountry::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::OnCancel"));

    EndDialog(wID);
    return 0;
}

/*
 -  CDlgSelectCountry::InitSelectCountryCodeDlg
 -
 *  Purpose:
 *      Init all the members as country list pointer and 
 *      device list pointer
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      0
 */
HRESULT CDlgSelectCountry::InitSelectCountryCodeDlg()
{
    DEBUG_FUNCTION_NAME( _T("CDlgSelectCountry::InitSelectCountryCodeDlg"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;

    
    //
    // Step 1: Init Lists from RPC
    //

    //
    // get Fax Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }


    //
    // Country (code ,name)
    //
    if (!FaxGetCountryList(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pCountryList)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get c TAPI country list. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pCountryList);
    m_dwNumOfCountries = m_pCountryList->dwNumCountries;
    

    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get all configurations."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
    
    //MsgBox will be done by calling Func.

Exit:
    return hRc;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgSelectCountry::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgSelectCountry::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgSelectCountry::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgnewrule.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgNewRule.cpp                                         //
//                                                                         //
//  DESCRIPTION   : The CDlgNewFaxOutboundRule class implements the        //
//                  dialog for additon of new Rule.                        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg    Create                                        //
//      Jan 25 2000 yossg  Change the Dialog Design                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "dlgNewRule.h"
#include "DlgSelectCountry.h"

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "FaxMMCUtils.h"
#include "dlgutils.h"

#include "Helper.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgNewFaxOutboundRule

CDlgNewFaxOutboundRule::CDlgNewFaxOutboundRule(CFaxServer * pFaxServer)
{    
    m_pFaxDevicesConfig = NULL;
    m_dwNumOfDevices    = 0;

    m_pFaxGroupsConfig  = NULL;
    m_dwNumOfGroups     = 0;

    m_fAllReadyToApply  = FALSE;

    ATLASSERT(pFaxServer);
    m_pFaxServer = pFaxServer;
}

CDlgNewFaxOutboundRule::~CDlgNewFaxOutboundRule()
{
    if (NULL != m_pFaxDevicesConfig)
        FaxFreeBuffer(m_pFaxDevicesConfig);

    if (NULL != m_pFaxGroupsConfig)
        FaxFreeBuffer(m_pFaxGroupsConfig);
}

/*
 +  CDlgNewFaxOutboundRule::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundRule::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnInitDialog"));
    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;
    
    int         i , j ,k, l;
    i = j = k = l = 0;

    const int   iAllDevicesComboIndex     = 0;
    int         iAllDevicesRPCIndex       = 0;

    int         iGroupListIndexToSelect   = 0;
    
    HINSTANCE   hInst;
    hInst = _Module.GetResourceInstance();
    
    WCHAR buf[FXS_MAX_DISPLAY_NAME_LEN+1];


    //
    // Attach controls
    //
    m_CountryCodeEdit.Attach(GetDlgItem(IDC_NEWRULE_COUNTRYCODE_EDIT));
    m_AreaCodeEdit.Attach(GetDlgItem(IDC_RULE_AREACODE_EDIT));

    m_DeviceCombo.Attach(GetDlgItem(IDC_DEVICES4RULE_COMBO));
    m_GroupCombo.Attach(GetDlgItem(IDC_GROUP4RULE_COMBO));
        
    //
    // Set length limit to area code
    //
    m_CountryCodeEdit.SetLimitText(FXS_MAX_COUNTRYCODE_LEN - 1); 
    m_AreaCodeEdit.SetLimitText(FXS_MAX_AREACODE_LEN-1);

    //
    // Step 1: Init Lists
    //
    
    //
    // Init Devices
    //
    for (k = 0; (DWORD)k < m_dwNumOfDevices; k++ )
    {   
        hRc = AddComboBoxItem ( m_DeviceCombo, 
                                m_pFaxDevicesConfig[k].lpctstrDeviceName, 
                                m_pFaxDevicesConfig[k].dwDeviceID,
                                hInst);
        if (FAILED(hRc))
        {
		    DebugPrintEx( DEBUG_ERR, _T("Fail to load device list."));
            PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
            ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO), FALSE);
            goto Cleanup;
        }

    }
        
    //
    // Init groups
    //
    for (l = 0; (DWORD)l < m_dwNumOfGroups; l++ )
    {   
        if ( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_pFaxGroupsConfig[l].lpctstrGroupName))
        {
            iAllDevicesRPCIndex = l;
            //Do not do any more;
		}
        else
		{
				hRc = AddComboBoxItem ( m_GroupCombo, 
										m_pFaxGroupsConfig[l].lpctstrGroupName, 
										(DWORD)l,
										hInst);
				if (FAILED(hRc))
				{
		            DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
					PageError(IDS_FAIL2LOADDEVICELIST, m_hWnd, hInst);
                    ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
					goto Cleanup;
				}
		}
    }

    //
    // Now add "All Devices" Group as the first one
    //

    //
    // Replace <all Devices> string for localization 
    //
    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    if (!LoadString(hInst, IDS_ALL_DEVICES, buf, FXS_MAX_DISPLAY_NAME_LEN))
    {
        hRc = E_OUTOFMEMORY;
		DebugPrintEx( DEBUG_ERR, _T("Fail to load string. Out of memory."));
        PageError(IDS_FAXOUTOFMEMORY, m_hWnd, hInst);
        goto Cleanup;
    }
    //
    // insert "All Devices" Group as the first one in the groups list
    //
    ATLASSERT( 0 == iAllDevicesComboIndex );
    hRc = SetComboBoxItem ( m_GroupCombo, 
                            iAllDevicesComboIndex, 
                            buf, 
                            iAllDevicesRPCIndex,
                            hInst);
    if (FAILED(hRc))
    {
		DebugPrintEx( DEBUG_ERR, _T("Fail to load group list."));
        PageError(IDS_FAIL2LOADGROUPLIST, m_hWnd, hInst);
        ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), FALSE);
        goto Cleanup;
    }



    //
    // Step 2: Set current status 
    //          (Select items in Lists, select radio button etc.)
    //          (Gray/UnGray controls)
    //

 	m_GroupCombo.SetCurSel (iAllDevicesComboIndex);

    //
    //  Radio buttons, Gray/UnGray
    //
    CheckDlgButton(IDC_COUNTRY_RADIO, BST_CHECKED);
    ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT), FALSE);

    CheckDlgButton(IDC_DESTINATION_RADIO2, BST_CHECKED) ;
    ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO), FALSE);


Cleanup:
    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgNewFaxOutboundRule::OnOK
 +
 *  Purpose:
 *      Submit data
 *      
 *  Arguments:
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgNewFaxOutboundRule::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnOK"));
    HRESULT       hRc                  = S_OK;
    DWORD         ec                   = ERROR_SUCCESS;
    BOOL          fSkipMessage         = FALSE;

    CComBSTR      bstrAreaCode;
    CComBSTR      bstrCountryCode;

    int           iCurrentSelectedItem = 0;
    
    DWORD         dwAreaCode           = 0;
    DWORD         dwCountryCode        = 0;

    BOOL          bUseGroup;
    DWORD         dwDeviceID           = 0;
    WCHAR         lpszGroupName[MAX_ROUTING_GROUP_NAME];
    
	LPCTSTR       lpctstrGroupName     = NULL;

    //
    // Step 0: PreApply Checks
    //
    ATLASSERT( TRUE == m_fAllReadyToApply );
    if (!AllReadyToApply(/*fSilent =*/ FALSE))
    {
        EnableOK(FALSE);
        hRc =S_FALSE;
        goto Exit;
    }

    //
    // Step 1: get data
    //

    //
    // Country Code
    //
    if ( !m_CountryCodeEdit.GetWindowText(&bstrCountryCode))
    {
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Failed to GetWindowText(&bstrCountryCode)"));
        DlgMsgBox(this, IDS_FAIL2READ_COUNTRYCODE);
        ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
        hRc = S_FALSE;
        
        goto Exit;
    }
    dwCountryCode = (DWORD)wcstoul( bstrCountryCode, NULL, 10 );

    if (ROUTING_RULE_COUNTRY_CODE_ANY == dwCountryCode)
    {
        //
        // The user try to set the country code to zero
        //
		DebugPrintEx(
			    DEBUG_ERR,
			    TEXT(" CountryCode == ROUTING_RULE_COUNTRY_CODE_ANY "));
        DlgMsgBox(this, IDS_ZERO_COUNTRYCODE);
        ::SetFocus(GetDlgItem(IDC_RULE_COUNTRYCODE_EDIT));
        hRc = S_FALSE;
    
        goto Exit;
    }


    //
    // Area Code
    //
    if ( IsDlgButtonChecked(IDC_COUNTRY_RADIO) == BST_CHECKED )
    {
        dwAreaCode = (DWORD)ROUTING_RULE_AREA_CODE_ANY;
    }
    else // IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED
    {	
        if ( !m_AreaCodeEdit.GetWindowText(&bstrAreaCode))
        {
		    DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Failed to GetWindowText(&bstrAreaCode)"));
            DlgMsgBox(this, IDS_FAIL2READ_AREACODE);
            ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT));
            hRc = S_FALSE;
            
            goto Exit;
        }
        dwAreaCode = (DWORD)wcstoul( bstrAreaCode, NULL, 10 );
    }
  
    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED )
    {
        //
        // Use Group ?
        //
        bUseGroup = FALSE;
        
        //
        // Device
        //
        iCurrentSelectedItem = m_DeviceCombo.GetCurSel();
        ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply         
        dwDeviceID =  (DWORD)m_DeviceCombo.GetItemData (iCurrentSelectedItem);

    }
    else // IsDlgButtonChecked(IDC_DESTINATION_RADIO2) == BST_CHECKED
    {	
        //
        // Use Group ?
        //
        bUseGroup = TRUE;
 
        //
        // Group
        //
        iCurrentSelectedItem = m_GroupCombo.GetCurSel();
        //ATLASSERT(iCurrentSelectedItem != CB_ERR); //should be chacked pre apply        

        if (0 == iCurrentSelectedItem) //All Devices
        {
            lpctstrGroupName = ROUTING_GROUP_ALL_DEVICES;
        }
        else
        {
            ATLASSERT(MAX_ROUTING_GROUP_NAME > m_GroupCombo.GetLBTextLen(iCurrentSelectedItem)); //should be chacked by service before        
        
            m_GroupCombo.GetLBText( iCurrentSelectedItem, lpszGroupName );
            lpctstrGroupName = (LPCTSTR)lpszGroupName;
        }
    }

    
    //
    // Step 2: Add Rule to service with RPC
    //


    //
    // get RPC Handle
    //   
   
    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Add the rule
    //
    if (!FaxAddOutboundRule (
	        m_pFaxServer->GetFaxServerHandle(),
	        dwAreaCode,
	        dwCountryCode,
	        dwDeviceID,
	        lpctstrGroupName,
	        bUseGroup))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to add rule. (ec: %ld)"), 
			ec);
        if (ERROR_DUP_NAME == ec) 
        {            
            DlgMsgBox(this, IDS_OUTRULE_EXISTS);
            goto Exit;
        }
        
        if (FAX_ERR_BAD_GROUP_CONFIGURATION == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            PageError(IDS_BAD_GROUP_CONFIGURATION,m_hWnd);
            fSkipMessage = TRUE;

            goto Error; 
        }        
        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
        
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
        
    //
    // Step 3: Close the dialog
    //
    ATLASSERT(S_OK == hRc && ERROR_SUCCESS == ec);

    DebugPrintEx( DEBUG_MSG,
		_T("The rule was added successfully."));

    EndDialog(wID);

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    if (!fSkipMessage)
    {
        PageErrorEx(IDS_FAIL_ADD_RULE, GetFaxServerErrorMsg(ec), m_hWnd);
    }

  
Exit:    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgNewFaxOutboundRule::OnDestenationRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgNewFaxOutboundRule::OnDestenationRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    State = ( IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED );
    ::EnableWindow(GetDlgItem(IDC_DEVICES4RULE_COMBO), State);    
    
    ATLASSERT(!State == (IsDlgButtonChecked(IDC_DESTINATION_RADIO2) == BST_CHECKED)); 
    ::EnableWindow(GetDlgItem(IDC_GROUP4RULE_COMBO), !State);    

    if (State)//IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            EnableOK(FALSE);
            goto Exit;
        }
        //else continue to whole controls check
    }
    else //IsDlgButtonChecked(IDC_DESTINATION_RADIO2) == BST_CHECKED
    {
        if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
        {
            m_fAllReadyToApply = FALSE;
            EnableOK(FALSE);
            goto Exit;
        }
        //else continue to whole controls check
    }

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
        else
        {
            //Should be EnableOK(FALSE);
        }
    }
Exit:
    return(1);
}

/*
 -  CDlgNewFaxOutboundRule::OnRuleTypeRadioClicked
 -
 *  Purpose:
 *      Gray/Ungray the folder edit box and the
 *      browse button. Enable apply button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgNewFaxOutboundRule::OnRuleTypeRadioClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL State;

    State = ( IsDlgButtonChecked(IDC_COUNTRY_RADIO) == BST_CHECKED );
    
    ATLASSERT(!State == (IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED)); 
    ::EnableWindow(GetDlgItem(IDC_RULE_AREACODE_EDIT), !State);    

    if (!State)//IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED
    {
        if ( !m_AreaCodeEdit.GetWindowTextLength() )
        {
            m_fAllReadyToApply = FALSE;
            EnableOK(FALSE);  
			goto Exit;
        }
		//else continue to whole controls check
    }
	//else //IsDlgButtonChecked(IDC_COUNTRY_RADIO) == BST_CHECKED
    //Do noting - continue to whole controls check

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
    }

Exit:
    return(1);
}


/*
 -  CDlgNewFaxOutboundRule::OnComboChanged
 -
 *  Purpose:
 *      Gray/Ungray the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT 
CDlgNewFaxOutboundRule::OnComboChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnComboChanged"));

    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
    }

    return 1;
}

/*
 -  CDlgNewFaxOutboundRule::OnTextChanged
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgNewFaxOutboundRule::OnTextChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnTextChanged"));

    UINT fEnableOK = 0;
	
    switch (wID)
	{
		case IDC_RULE_AREACODE_EDIT:
			fEnableOK = ( m_AreaCodeEdit.GetWindowTextLength() );
			break;

		case IDC_NEWRULE_COUNTRYCODE_EDIT:
			fEnableOK = ( m_CountryCodeEdit.GetWindowTextLength() );
			break;

		default:
			ATLASSERT(FALSE);
	}
                    
    if(!!fEnableOK)
    {
        if (!m_fAllReadyToApply)
        {
            if (AllReadyToApply(TRUE))
            {
                m_fAllReadyToApply = TRUE;
                EnableOK(TRUE);
            }
        }
    }
    else
    {
        EnableOK(FALSE);
        m_fAllReadyToApply = FALSE;
    }

    return 1;
}

/*
 -  CDlgNewFaxOutboundRule::AllReadyToApply
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE if all ready to apply, else FALSE.
 */
BOOL 
CDlgNewFaxOutboundRule::AllReadyToApply(BOOL fSilent)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::AllReadyToApply"));
	
    if ( !m_CountryCodeEdit.GetWindowTextLength() )
    {
        if (!fSilent)
        {
                DlgMsgBox(this, IDS_ZERO_COUNTRYCODE);
                ::SetFocus(GetDlgItem(IDC_NEWRULE_COUNTRYCODE_EDIT));
        }
        return FALSE;    
    }

    if ( IsDlgButtonChecked(IDC_AREA_RADIO) == BST_CHECKED )
    {
        if ( !m_AreaCodeEdit.GetWindowTextLength() )
        {
            if (!fSilent)
            {
                    DlgMsgBox(this, IDS_EMPTY_AREACODE);
                    ::SetFocus(GetDlgItem(IDC_RULE_AREACODE_EDIT));
            }
            return FALSE;    
        }
    }
    //else do noting.

    if ( IsDlgButtonChecked(IDC_DESTINATION_RADIO1) == BST_CHECKED )
    {
        if ( CB_ERR  ==  m_DeviceCombo.GetCurSel())
        {
            if (!fSilent)
            {
                DlgMsgBox(this, IDS_PLEASESELECT_DEVICE);
                ::SetFocus(GetDlgItem(IDC_DEVICES4RULE_COMBO));
            }
            return FALSE;
        }
    }
    else if ( CB_ERR  ==  m_GroupCombo.GetCurSel())
    {
        if (!fSilent)
        {
            DlgMsgBox(this, IDS_PLEASESELECT_GROUP);
            ::SetFocus(GetDlgItem(IDC_GROUP4RULE_COMBO));
        }
        return FALSE;
    }

    //
    // Cheers! 
    //		...every thing ready to apply now.
    //
    return TRUE;           
}

/*
 -  CDlgNewFaxOutboundRule::EnableOK
 -
 *  Purpose:
 *      Enable/Disable the submit button.
 *
 *  Arguments:
 *      [in] fEnable - boolen value tells 
 *                     to Enable or Disable the OK button.
 *
 *  Return:
 *      VOID
 */
VOID
CDlgNewFaxOutboundRule::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgNewFaxOutboundRule::OnCancel
 -
 *  Purpose:
 *      End the dialog.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgNewFaxOutboundRule::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnCancel"));

    EndDialog(wID);
    return 0;
}

/*
 -  CDlgNewFaxOutboundRule::InitRuleDlg
 -
 *  Purpose:
 *      Init all the members as country list pointer and 
 *      device list pointer
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      0
 */
HRESULT CDlgNewFaxOutboundRule::InitRuleDlg()
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::InitRuleDlg"));
    HRESULT      hRc        = S_OK; 
    DWORD        ec         = ERROR_SUCCESS;

    
    //
    // Step 1: Init Lists from RPC
    //

    //
    // get Fax Handle
    //   

    if (!m_pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Devices (id, name)
    //
    if (!FaxEnumPortsEx(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxDevicesConfig,
                        &m_dwNumOfDevices)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get devices configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxDevicesConfig);


    //
    // Groups (names)
    //
    if (!FaxEnumOutboundGroups(m_pFaxServer->GetFaxServerHandle(), 
                        &m_pFaxGroupsConfig,
                        &m_dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            m_pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	ATLASSERT(m_pFaxGroupsConfig);



    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get all configurations."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
    
    //MsgBox will be done by calling Func.

Exit:
    return hRc;
}


/*
 -  CDlgNewFaxOutboundRule::OnSelectCountryCodeClicked
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
LRESULT
CDlgNewFaxOutboundRule::OnSelectCountryCodeClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundRule::OnSelectCountryCodeClicked"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    int         iCount      =    0;
    WCHAR       szwCountryCode[FXS_MAX_COUNTRYCODE_LEN+1];
    DWORD       dwCountryCode = 0;

    CDlgSelectCountry  DlgSelectCountry(m_pFaxServer);

    hRc = DlgSelectCountry.InitSelectCountryCodeDlg();
    if (S_OK != hRc)
    {
        //MsgBox + debug print by called func.
        goto Cleanup;
    }

    //
    // Dialog select country code
    //
    rc = DlgSelectCountry.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Retreive CountryCode
    //
    dwCountryCode = DlgSelectCountry.GetCountryCode();

    iCount = swprintf(szwCountryCode, L"%ld", dwCountryCode);
    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read member - m_dwCountryCode."));
        goto Cleanup;
    }
    m_CountryCodeEdit.SetWindowText(szwCountryCode);

    //
    // EnableOK
    //
    if (!m_fAllReadyToApply)
    {
        if (AllReadyToApply(TRUE))
        {
            m_fAllReadyToApply = TRUE;
            EnableOK(TRUE);
        }
		else
		{
			//Should be EnableOK(FALSE);
		}
    }

 
Cleanup:
    return hRc;
}


//////////////////////////////////////////////////////////////////////////////
/*++

CDlgNewFaxOutboundRule::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgNewFaxOutboundRule::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgNewFaxOutboundRule::OnHelpRequest"));
    
    switch (uMsg) 
    {   
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgutils.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgutils.h                                             //
//                                                                         //
//  DESCRIPTION   : dialog utility functions                               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Apr 29 1998 zvib    Add AdjustColumns.                             //
//      May 13 1999 roytal  Add GetIpAddrDword                             //
//      Jun 10 1999 AvihaiL Add proxy rule wizard.                         //
//                                                                         //
//      Dec  30 1999 yossg   Welcome to Fax Server.  (reduced version)     //
//      Aug  10 2000 yossg   Add TimeFormat functions                      //
//      Sept 12 2001 alexmay Add InvokePropSheet functions                 //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGUTLIS_H_
#define _DLGUTLIS_H_

#include <atlsnap.h>


// CONVINIENCE MACRO FOR atl
#define ATTACH_ATL_CONTROL(member, ControlId) member.Attach(GetDlgItem(ControlId));

#define RADIO_CHECKED(idc)  ((IsDlgButtonChecked(idc) == BST_CHECKED))
#define ENABLE_CONTROL(idc, State) ::EnableWindow(GetDlgItem(idc), State);

//int  GetDlgItemTextLength(HWND hDlg, int idc);

HRESULT
ConsoleMsgBox(
	IConsole * pConsole,
	int ids,
	LPTSTR lptstrTitle = NULL,
	UINT fuStyle = MB_OK,
	int *piRetval = NULL,
	BOOL StringFromCommonDll = FALSE);

void PageError(int ids, HWND hWnd, HINSTANCE hInst = NULL);

void PageErrorEx(int idsHeader, int ids, HWND hWnd, HINSTANCE hInst = NULL);

HRESULT 
SetComboBoxItem  (CComboBox    combo, 
                  DWORD        comboBoxIndex, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);
HRESULT 
AddComboBoxItem  (CComboBox    combo, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst = NULL);

HRESULT 
SelectComboBoxItemData  (CComboBox combo, DWORD_PTR dwItemData);

DWORD 
WinContextHelp(
    ULONG_PTR dwHelpId, 
    HWND  hWnd
);

HRESULT
DisplayContextHelp(
    IDisplayHelp* pDisplayHelp, 
    LPOLESTR      helpFile,
    WCHAR*        szTopic);

//
// Help topics
//
#define HLP_INBOUND_ROUTING L"::/FaxS_C_RcvdFaxRout.htm"
#define HLP_COVER_PAGES     L"::/FaxS_C_CovPages.htm"
#define HLP_DEVICES         L"::/FaxS_C_ManDvices.htm"
#define HLP_INTRO           L"::/FaxS_C_FaxIntro.htm"
#define HLP_MAN_INCOM       L"::/FaxS_C_ManIncom.htm"
#define HLP_GROUPS          L"::/FaxS_C_Groups.htm"
#define HLP_MAN_OUTGOING    L"::/FaxS_C_ManOutgo.htm"

//
// Time Format Utils
//
#define FXS_MAX_TIMEFORMAT_LEN      80               //MSDN "LOCALE_STIMEFORMAT" MAX VAL

HRESULT 
InvokePropSheet(
    CSnapInItem*       pNode, 
    DATA_OBJECT_TYPES  type, 
    LPUNKNOWN          lpUnknown,
    LPCWSTR            szTitle,
    DWORD              dwPage);

#endif //_DLGUTLIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgsmtpconfig.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgSMTPConfig.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the CDlgSMTPConfig class.              //
//                  The class implement the dialog for new Group.          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg   Create                                         //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef DLG_SMTP_CONFIG_H_INCLUDED
#define DLG_SMTP_CONFIG_H_INCLUDED

/////////////////////////////////////////////////////////////////////////////
// CDlgSMTPConfig

class CDlgSMTPConfig :
             public CDialogImpl<CDlgSMTPConfig>
{
public:
    CDlgSMTPConfig();

    ~CDlgSMTPConfig();

    enum { IDD = IDD_DLG_SMTP_SET };

BEGIN_MSG_MAP(CDlgSMTPConfig)
    MESSAGE_HANDLER   ( WM_INITDIALOG, OnInitDialog)
    
    COMMAND_ID_HANDLER( IDOK,          OnOK)
    COMMAND_ID_HANDLER( IDCANCEL,      OnCancel)
    
    MESSAGE_HANDLER( WM_CONTEXTMENU,  OnHelpRequest)
    MESSAGE_HANDLER( WM_HELP,         OnHelpRequest)

    COMMAND_HANDLER( IDC_SMTP_ANONIM_RADIO1, BN_CLICKED, OnRadioButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_BASIC_RADIO2,  BN_CLICKED, OnRadioButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_NTLM_RADIO3,   BN_CLICKED, OnRadioButtonClicked)
    
    COMMAND_HANDLER( IDC_SMTP_CREDENTIALS_BASIC_BUTTON, BN_CLICKED, OnCredentialsButtonClicked)
    COMMAND_HANDLER( IDC_SMTP_CREDENTIALS_NTLM_BUTTON,  BN_CLICKED, OnCredentialsButtonClicked)
	    
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRadioButtonClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCredentialsButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    HRESULT InitSmtpDlg(FAX_ENUM_SMTP_AUTH_OPTIONS enumAuthOption, BSTR bstrUserName);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    inline const CComBSTR&  GetUserName() { return  m_bstrUserName; }

    inline CComBSTR& GetPassword()
    {     
        return m_bstrPassword;

    }

    
    inline FAX_ENUM_SMTP_AUTH_OPTIONS GetAuthenticationOption()
    {
        return m_enumAuthOption;
    }

    inline BOOL IsPasswordModified()
    {
        return m_fIsPasswordDirty;
    }

private:
    //
    // Methods
    //
    VOID   EnableOK(BOOL fEnable);
    VOID   EnableCredentialsButton(DWORD iIDC);

    //
    // members for data
    //
    BOOL      m_fIsPasswordDirty;

    CComBSTR  m_bstrUserName;
    CComBSTR  m_bstrPassword;
    
    FAX_ENUM_SMTP_AUTH_OPTIONS m_enumAuthOption;

    //
    // Dialog initialization state
    //
    BOOL      m_fIsDialogInitiated;

};

#endif // DLG_SMTP_CONFIG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : dlgutils.cpp                                           //
//                                                                         //
//  DESCRIPTION   : dialog utility funcs                                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 30 1999 yossg   Welcome to Fax Server.                         //
//      Aug 10 2000 yossg   Add TimeFormat functions                       //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "dlgutils.h"


HRESULT
ConsoleMsgBox(
	IConsole * pConsole,
	int ids,
	LPTSTR lptstrTitle,
	UINT fuStyle,
	int *piRetval,
	BOOL StringFromCommonDll)
{  
    UNREFERENCED_PARAMETER(StringFromCommonDll);

    HRESULT     hr;
    int         dummy, rc;
    WCHAR       szText[256];
    int         *pres = (piRetval)? piRetval: &dummy;
    
    ATLASSERT(pConsole);   

    rc = ::LoadString(
                _Module.GetResourceInstance(),ids, szText, 256);
    if (rc <= 0)
    {        
        return E_FAIL;
    }
    
    //
    // Display the message box 
    //
    if(IsRTLUILanguage())
    {
        fuStyle |= MB_RTLREADING | MB_RIGHT;
    }

    hr = pConsole->MessageBox(szText, lptstrTitle, fuStyle, pres);

    return hr;
}

void PageError(int ids, HWND hWnd, HINSTANCE hInst /* = NULL */)
{
    WCHAR msg[FXS_MAX_ERROR_MSG_LEN+1], title[FXS_MAX_TITLE_LEN+1];
    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    LoadString(hInst, ids, msg, FXS_MAX_ERROR_MSG_LEN);
    LoadString(hInst, IDS_ERROR, title, FXS_MAX_TITLE_LEN);
    AlignedMessageBox(hWnd, msg, title, MB_OK|MB_ICONERROR);
}

void PageErrorEx(int idsHeader, int ids, HWND hWnd, HINSTANCE hInst /* = NULL */)
{
    WCHAR msg[FXS_MAX_ERROR_MSG_LEN+1]; 
    WCHAR title[FXS_MAX_TITLE_LEN+1];
    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    LoadString(hInst, idsHeader, title, FXS_MAX_TITLE_LEN);
    LoadString(hInst, ids, msg, FXS_MAX_ERROR_MSG_LEN);
    AlignedMessageBox(hWnd, msg, title, MB_OK|MB_ICONERROR);
}

HRESULT 
SetComboBoxItem  (CComboBox    combo, 
                  DWORD        comboBoxIndex, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst)
{
    DEBUG_FUNCTION_NAME( _T("SetComboBoxItem"));
    int iRes;

    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    //
    // place the string in the combobox
    //
    iRes = combo.InsertString (comboBoxIndex, lpctstrFieldText);
    if (CB_ERR == iRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("failed to insert string '%s' to combobox at index %d"), 
            lpctstrFieldText, 
            comboBoxIndex);
        goto Cleanup;
    }
    //
    // attach to the combobox item its index (usually, its his enumerated type)
    //
    iRes = combo.SetItemData (comboBoxIndex, dwItemData);
    if (CB_ERR == iRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("SetItemData failed when setting items %s data to the value of %d"), 
            lpctstrFieldText, 
            dwItemData);
        goto Cleanup;
    }

Cleanup:
    return (CB_ERR == iRes) ? E_FAIL : S_OK;
}


HRESULT 
AddComboBoxItem  (CComboBox    combo, 
                  LPCTSTR      lpctstrFieldText,
                  DWORD        dwItemData,
                  HINSTANCE    hInst)
{
    DEBUG_FUNCTION_NAME( _T("SetComboBoxItem"));

    int iRes;
    int iIndex;

    if (!hInst)
    {
        hInst = _Module.GetResourceInstance();
    }
    //
    // place the string in the combobox
    //
    iIndex = combo.AddString(lpctstrFieldText);
    if (iIndex == CB_ERR)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("failed to insert string '%s' to combobox "), 
            lpctstrFieldText);
        return E_FAIL;
    }
    //
    // attach to the combobox item its index (usually, its his enumerated type)
    //
    iRes = combo.SetItemData (iIndex, dwItemData);
    if (CB_ERR == iRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("SetItemData failed when setting items %s data to the value of %d"), 
            lpctstrFieldText, 
            dwItemData);
        return E_FAIL;
    }
    return S_OK;
}


HRESULT 
SelectComboBoxItemData (CComboBox combo, DWORD_PTR dwItemData)
{
    HRESULT     hRc = S_OK;
    int         NumItems;
    int         i;
    int         selectedItem;
    DWORD_PTR   currItemData;

    DEBUG_FUNCTION_NAME( _T("SelectComboBoxItemData"));

    //
    // scan the items in the combobox and find the item with the specific data
    //
    i        = 0;
    NumItems = combo.GetCount ();
    
    for (i = 0; i < NumItems; i++)
    {
        currItemData = combo.GetItemData (i);
        ATLASSERT (currItemData != CB_ERR);// Cant get the data of item %d of combobox, i
        if (currItemData == dwItemData)
        {
            //
            // select it
            //
            selectedItem = combo.SetCurSel (i);

            ATLASSERT (selectedItem != CB_ERR); //Cant select item %d of combobox, i
            
            DebugPrintEx(
                    DEBUG_MSG,
                    _T("Selected item %d (with data %d) of combobox"), i, dwItemData);
            
            goto Cleanup;
        }
    }

Cleanup:
    return hRc;
}

DWORD 
WinContextHelp(
    ULONG_PTR dwHelpId, 
    HWND  hWnd
)
/*++

Routine name : WinContextHelp

Routine description:

	Open context sensetive help popup 'tooltip' with WinHelp

Arguments:

	dwHelpId                      [in]     - help ID
	hWnd                          [in]     - parent window handler

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;

    if (0 == dwHelpId)
    {
        return dwRes;
    }

    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_ADMIN_HLP))
    {
        //
        // The help file is not installed
        //
        return dwRes;
    }
    
    WinHelp(hWnd, 
            FXS_ADMIN_HLP_FILE, 
            HELP_CONTEXTPOPUP, 
            dwHelpId);

    return dwRes;
}

HRESULT
DisplayContextHelp(
    IDisplayHelp* pDisplayHelp, 
    LPOLESTR      helpFile,
    WCHAR*        szTopic
)
/*++

Routine name : WinContextHelp

Routine description:

	Display context sensetive help

Arguments:

    pDisplayHelp       [in]     - IDisplayHelp interface
    helpFile           [in]     - help file name
    szTopic            [in]     - help topic name

Return Value:

    None.

--*/
{
    if(!pDisplayHelp || !helpFile || !szTopic)
    {
        return E_FAIL;
    }

    WCHAR szTopicName[MAX_PATH] = {0};

    _snwprintf(szTopicName, ARR_SIZE(szTopicName)-1, L"%s%s", helpFile, szTopic);
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(szTopicName) + 1) * sizeof(_TCHAR)));
    if (pszTopic)
    {
        _tcscpy(pszTopic, szTopicName);
        return pDisplayHelp->ShowTopic(pszTopic);
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


HRESULT 
InvokePropSheet(
    CSnapInItem*       pNode, 
    DATA_OBJECT_TYPES  type, 
    LPUNKNOWN          lpUnknown,
    LPCWSTR            szTitle,
    DWORD              dwPage)
/*++

Routine name : InvokePropSheet

Routine description:

	Invoke MMC property sheet
    Taken from the MSDN "Using IPropertySheetProvider Directly"

Arguments:

    pNode       [in] - Snapin node that should open the sheet
    type        [in] - Node type [CCT_SCOPE, CCT_RESULT, CCT_SNAPIN_MANAGER, CCT_UNINITIALIZED]
    lpUnknown   [in] - Pointer to an IComponent or IComponentData
    szTitle     [in] - Pointer to a null-terminated string that contains the title of the property page.
    dwPage      [in] - Specifies which page on the property sheet is shown. It is zero-indexed.

Return Value:

    OLE error code

--*/
{
    DEBUG_FUNCTION_NAME( _T("InvokePropSheet"));

    HRESULT hr = E_FAIL;
    
    if(!pNode || !szTitle || !lpUnknown)
    {   
        ATLASSERT(FALSE);   
        return hr;
    }

    MMC_COOKIE cookie = (MMC_COOKIE)pNode;

    //
    // Get node data object
    //
    IDataObject* pDataObject = NULL;
    hr = pNode->GetDataObject(&pDataObject, type);
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("CSnapinNode::GetDataObject() failed with %ld"), hr);
        return hr;
    }

    //
    // CoCreate an instance of the MMC Node Manager to obtain
    // an IPropertySheetProvider interface pointer
    //    
    IPropertySheetProvider* pPropertySheetProvider = NULL;
 
    hr = CoCreateInstance (CLSID_NodeManager, 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IPropertySheetProvider, 
                           (void **)&pPropertySheetProvider);
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("CoCreateInstance(CLSID_NodeManager) failed with %ld"), hr);
        goto exit;
    }
    
    hr = pPropertySheetProvider->FindPropertySheet(cookie, NULL, pDataObject);
    //
    // S_OK    - The property sheet was successfully located and was brought to the foreground. 
    // S_FALSE - A property sheet with this cookie was not found. 
    //
    if(S_OK == hr)
    {
        //
        // The page already opened
        //
        goto exit;
    }

    //
    // Create the property sheet
    //
    hr = pPropertySheetProvider->CreatePropertySheet(szTitle,     // pointer to the property page title
                                                     TRUE,        // property sheet
                                                     cookie,      // cookie of current object - can be NULL
                                                                  // for extension snap-ins
                                                     pDataObject, // data object of selected node
                                                     NULL);       // specifies flags set by the method call 
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("IPropertySheetProvider::CreatePropertySheet() failed with %ld"), hr);
        goto exit;
    }
     
    //
    // Call AddPrimaryPages. MMC will then call the
    // IExtendPropertySheet methods of our
    // property sheet extension object
    //
    hr = pPropertySheetProvider->AddPrimaryPages(lpUnknown,  // pointer to our object's IUnknown
                                                 TRUE,       // specifies whether to create a notification handle
                                                 NULL,       // must be NULL
                                                 FALSE);     // TRUE for scope pane; FALSE for result pane 
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("IPropertySheetProvider::AddPrimaryPages() failed with %ld"), hr);
        goto exit;
    }
 
    //
    // Allow property page extensions to add
    // their own pages to the property sheet
    //
    hr = pPropertySheetProvider->AddExtensionPages();
    
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("IPropertySheetProvider::AddExtensionPages() failed with %ld"), hr);
        goto exit;
    }
 
    //
    // Display property sheet
    //
    hr = pPropertySheetProvider->Show(NULL, dwPage); // NULL is allowed for modeless prop sheet
    
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("IPropertySheetProvider::Show() failed with %ld"), hr);
        goto exit;
    }
 
    //
    // Release IPropertySheetProvider interface
    //

exit:
    if(pPropertySheetProvider)
    {
        pPropertySheetProvider->Release();
    }

    if(pDataObject)
    {
        pDataObject->Release();
    }
    return hr;
} // InvokePropSheet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\dlgsmtpconfig.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : DlgSMTPConfig.cpp                                      //
//                                                                         //
//  DESCRIPTION   : The CDlgSMTPConfig class implements the                //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jul 20 2000 yossg    Create                                        //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C)  2000 Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "DlgSMTPConfig.h"
#include "DlgConfirmPassword.h"

#include "FxsValid.h"
#include "dlgutils.h"
#include <htmlHelp.h>
#include <faxreg.h>

/////////////////////////////////////////////////////////////////////////////
// CDlgSMTPConfig

CDlgSMTPConfig::CDlgSMTPConfig()
{
    m_fIsPasswordDirty         = FALSE;
    m_fIsDialogInitiated       = FALSE;
}

CDlgSMTPConfig::~CDlgSMTPConfig()
{
}



/*
 -  CDlgSMTPConfig::InitSmtpDlg
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call,
 *      and current assined devices own parameters
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CDlgSMTPConfig::InitSmtpDlg (FAX_ENUM_SMTP_AUTH_OPTIONS enumAuthOption, BSTR bstrUserName)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::InitSmtpDlg"));
    
    HRESULT hRc = S_OK;
    
    m_enumAuthOption = enumAuthOption;
    
    m_bstrUserName = bstrUserName;
    if (!m_bstrUserName )
    {
        DebugPrintEx(DEBUG_ERR,
			_T("Out of memory - Failed to Init m_bstrUserName. (ec: %0X8)"), hRc);
        //MsgBox by Caller Function
        hRc = E_OUTOFMEMORY;
        goto Exit;
    }
        
    ATLASSERT(S_OK == hRc);
    
Exit:    
    return hRc;
}

/*
 +  CDlgSMTPConfig::OnInitDialog
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSMTPConfig::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnInitDialog"));
    HRESULT hRc = S_OK;    

   
    switch (m_enumAuthOption)
    {
        case FAX_SMTP_AUTH_ANONYMOUS :

            CheckDlgButton(IDC_SMTP_ANONIM_RADIO1, BST_CHECKED);
            EnableCredentialsButton(IDC_SMTP_ANONIM_RADIO1);

            break;

        case FAX_SMTP_AUTH_BASIC : 

            CheckDlgButton(IDC_SMTP_BASIC_RADIO2, BST_CHECKED);
            EnableCredentialsButton(IDC_SMTP_BASIC_RADIO2);

            break;

        case FAX_SMTP_AUTH_NTLM : 

            CheckDlgButton(IDC_SMTP_NTLM_RADIO3, BST_CHECKED);
            EnableCredentialsButton(IDC_SMTP_NTLM_RADIO3);

            break;

        default:
            ATLASSERT(0);

    }
    
    m_fIsDialogInitiated = TRUE;

    EnableOK(FALSE);
    return 1;  // Let the system set the focus
}

/*
 +  CDlgSMTPConfig::OnOK
 +
 *  Purpose:
 *      Initiate all dialog controls.
 *      
 *  Arguments:
 *      [in] uMsg     : Value identifying the event.  
 *      [in] lParam   : Message-specific value. 
 *      [in] wParam   : Message-specific value. 
 *      [in] bHandled : bool value.
 *
 -  Return:
 -      0 or 1
 */
LRESULT
CDlgSMTPConfig::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnOK"));
    HRESULT     hRc           = S_OK;
    
    //
    // Set data member data
    //
    if (IsDlgButtonChecked(IDC_SMTP_ANONIM_RADIO1) == BST_CHECKED)
    {
        m_enumAuthOption     = FAX_SMTP_AUTH_ANONYMOUS;
    }
    else 
    {
        if (IsDlgButtonChecked(IDC_SMTP_NTLM_RADIO3) == BST_CHECKED)
        {
            m_enumAuthOption = FAX_SMTP_AUTH_NTLM;
        }
        else // IsDlgButtonChecked(IDC_SMTP_BASIC_RADIO2) == BST_CHECKED
        {
            m_enumAuthOption = FAX_SMTP_AUTH_BASIC;
        }
    }

    //
    // Step 4: Close the dialog
    //
    ATLASSERT(S_OK == hRc );

    EndDialog(wID);

    goto Exit;

  
Exit:
    
    return FAILED(hRc) ? 0 : 1;
}

/*
 -  CDlgSMTPConfig::EnableCredentialsButton
 -
 *  Purpose:
 *      Enable/disable Basic Authentication dialog controls.
 *
 *  Arguments:
 *      [in] iIDC - DWORD value for the radio button selected or the 
 *                  radio above the credetials button that should be active.
 *
 *  Return:
 *      void
 */
VOID CDlgSMTPConfig::EnableCredentialsButton(DWORD iIDC)
{
    
    switch (iIDC) 
    { 
        case IDC_SMTP_ANONIM_RADIO1: 
            
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_BASIC_BUTTON), FALSE);
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_NTLM_BUTTON), FALSE);
            break;
            
        case IDC_SMTP_BASIC_RADIO2: 

            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_BASIC_BUTTON), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_NTLM_BUTTON), FALSE);
            break; 
 
        case IDC_SMTP_NTLM_RADIO3: 
            
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_NTLM_BUTTON), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SMTP_CREDENTIALS_BASIC_BUTTON), FALSE);
            break;
            
        default:

            ATLASSERT( 0 ); // Unexpected value
            
    } 

}


/*
 -  CDlgSMTPConfig::OnRadioButtonClicked
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT
CDlgSMTPConfig::OnRadioButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER (wNotifyCode);
    UNREFERENCED_PARAMETER (hWndCtl);
    UNREFERENCED_PARAMETER (bHandled);

    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnRadioButtonClicked"));

    UINT fEnableOK;
    
    if (!m_fIsDialogInitiated) //event receieved in too early stage
    {
        return 0;
    }
	
    //
    // Activate OK button
    //
    if ( IsDlgButtonChecked(IDC_SMTP_ANONIM_RADIO1) == BST_CHECKED )
    {        
        EnableOK(TRUE);
    }
    else //BASIC or NTLM
    {
        ATLASSERT(IDC_SMTP_BASIC_RADIO2 == wID || IDC_SMTP_NTLM_RADIO3 == wID );
        
        fEnableOK = ( m_bstrUserName.Length() > 0 );
    
        EnableOK(!!fEnableOK);
    }

    //
    // Activate the proper Credentials button
    //
    EnableCredentialsButton(wID);
    
    return 0;
}


/*
 -  CDlgSMTPConfig::OnCredentialsButtonClicked
 -
 *  Purpose:
 *      Allow edit Credentials for the SMTP server configuration .
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CDlgSMTPConfig::OnCredentialsButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnCredentialsButtonClicked"));
    
    INT_PTR  rc    = IDCANCEL;
    HRESULT  hRc   = S_OK;
    DWORD    dwRet = ERROR_SUCCESS;
    
    CDlgConfirmPassword DlgCredentialsConfig;


    //
    // Dialog to configure SMTP authentication mode
    //
    hRc = DlgCredentialsConfig.InitCredentialsDlg(m_bstrUserName);
    if (FAILED(hRc))
    {
        DlgMsgBox(this, IDS_MEMORY);
        goto Cleanup;
    }

    rc = DlgCredentialsConfig.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }


    m_bstrUserName = DlgCredentialsConfig.GetUserName();
    if (!m_bstrUserName)        
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Null memeber BSTR - m_bstrUserName."));
    
        DlgMsgBox(this, IDS_MEMORY);

        goto Cleanup;
    }

    if ( DlgCredentialsConfig.IsPasswordModified() ) //If you got here password was also confirmed
    {
        m_bstrPassword  = DlgCredentialsConfig.GetPassword();
        if (!m_bstrPassword)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory while setting m_bstrPassword"));
           DlgMsgBox(this, IDS_MEMORY);

            goto Cleanup;
        }

        m_fIsPasswordDirty = TRUE;
    }
    else
    {
        m_bstrPassword.Empty();
    }

    EnableOK(TRUE);  


Cleanup:
    return 1;
}


/*
 -  CDlgSMTPConfig::EnableOK
 -
 *  Purpose:
 *      Enable (disable) apply button.
 *
 *  Arguments:
 *      [in] fEnable - the value to enable the button
 *
 *  Return:
 *      void
 */
VOID
CDlgSMTPConfig::EnableOK(BOOL fEnable)
{
    HWND hwndOK = GetDlgItem(IDOK);
    ::EnableWindow(hwndOK, fEnable);
}

/*
 -  CDlgSMTPConfig::OnCancel
 -
 *  Purpose:
 *      End dialog OnCancel.
 *
 *  Arguments:
 *
 *  Return:
 *      0
 */
LRESULT
CDlgSMTPConfig::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DEBUG_FUNCTION_NAME( _T("CDlgSMTPConfig::OnCancel"));

    EndDialog(wID);
    return 0;
}



//////////////////////////////////////////////////////////////////////////////
/*++

CDlgSMTPConfig::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CDlgSMTPConfig::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CDlgSMTPConfig::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxextensionmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  FILE          : FaxExtensionMethod.h                                   //
//                                                                         //
//  DESCRIPTION   : defines the prototype of Routing method				   //
//					Dialog display function.							   //
//                                                                         //
//  AUTHOR        : kereng                                                 //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun 24 1999 kereng  created.                                       //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef _FAXEXTMETHOD_H_
#define _FAXEXTMETHOD_H_

#include "..\..\common\src\com\msneroot\msneroot.h"

typedef int (FaxMethodDisplayDialog)(IFaxAssociatedRoutingMethod*);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxmmcglobals.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxMMCGlobals.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for all Fax MMC global varaibles           //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//                                                                         //
//  Copyright (C) 1999  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXMMCGLOBALS_H
#define H_FAXMMCGLOBALS_H

//
// global pointer to CFaxServerNode
// which is the viewable root node of the snap-in
//       
class CFaxServerNode;

#endif  //H_FAXMMCGLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxmmcpropertychange.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxMMCPropertyChange.h                                 //
//                                                                         //
//  DESCRIPTION   : Header file for FaxMMCPropertyNotification structure   //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 19 2000 yossg   Init .                                         //
//                          Windows XP                                     //
//      Feb 14 2001 yossg   Add Device class due to Manual Receive support //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXMMCPROPERTYCHANGE_H
#define H_FAXMMCPROPERTYCHANGE_H

enum ENUM_PROPCHANGE_NOTIFICATION_TYPE
{
    GeneralFaxPropNotification = 0,
    RuleFaxPropNotification,
    DeviceFaxPropNotification
};

//
// the general fax property change notifiction structure
//       
class CFaxPropertyChangeNotification
{
public:
    //
    // Constructor
    //
    CFaxPropertyChangeNotification()
    {
        pItem            = NULL;
        pParentItem      = NULL;
        enumType         = GeneralFaxPropNotification;
    }

    //
    // Destructor
    //
    ~CFaxPropertyChangeNotification()
    {
    }
    
    //
    // members
    //
    CSnapInItem *                       pItem;
    CSnapInItem *                       pParentItem;
    ENUM_PROPCHANGE_NOTIFICATION_TYPE   enumType;
};


//
// The Rule property change notifiction structure
//       
class CFaxRulePropertyChangeNotification: public CFaxPropertyChangeNotification
{
public:

    //
    // Constructor
    //
    CFaxRulePropertyChangeNotification()
    {
        dwCountryCode   = 0;
        dwAreaCode      = 0;
        dwDeviceID      = 0;
        bstrCountryName = L"";
        bstrGroupName   = L"";
    }

    //
    // Destructor
    //
    ~CFaxRulePropertyChangeNotification()
    {
    }

    //
    // members
    //
    DWORD    dwCountryCode;
    DWORD    dwAreaCode;
    CComBSTR bstrCountryName;
    BOOL     fIsGroup;
    CComBSTR bstrGroupName;
    DWORD    dwDeviceID;
};


//
// The device property change notifiction structure
//       
class CFaxDevicePropertyChangeNotification: public CFaxPropertyChangeNotification
{
public:

    //
    // Constructor
    //
    CFaxDevicePropertyChangeNotification()
    {
        dwDeviceID                   = 0;

        fIsToNotifyAdditionalDevices = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxDevicePropertyChangeNotification()
    {
    }

    //
    // members
    //
    DWORD         dwDeviceID;
    BOOL          fIsToNotifyAdditionalDevices;

};



#endif  //H_FAXMMCPROPERTYCHANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxmmcutils.cpp ===
#include "stdafx.h"
#include "FaxMMCUtils.h"
#include <faxres.h>

/*
 -  GetFaxServerErrorMsg
 -
 *  Purpose:
 *      Translate Error Code to IDS.
 *
 *  Arguments:
 *          dwEc - error code DWORD
 *
 *  Return:
 *          integer represents the IDS of error message 
 *          for this ec.
 *      
 */
int GetFaxServerErrorMsg(DWORD dwEc)
{
    DEBUG_FUNCTION_NAME( _T("GetFaxServerErrorMsg"));

    int         iIDS = IDS_GENERAL_FAILURE;

    if (IsNetworkError(dwEc))
    {
                iIDS = IDS_NETWORK_PROBLEMS;           
    }
    else
    {
        switch (dwEc)
        {
            case ERROR_NOT_ENOUGH_MEMORY:
                iIDS = IDS_MEMORY;           
                break;

            case ERROR_INVALID_PARAMETER:
                iIDS = IDS_INVALID_PARAMETER;                    
                break;

            case ERROR_ACCESS_DENIED:
                iIDS = IDS_ACCESS_DENIED;            
                break;

            case ERROR_INVALID_HANDLE:
                //
                // ERROR_INVALID_HANDLE should not been 
                // retreived except of FaxOpenPort while 
                // handle sharing corruption was occoured.
                // This case treated without calling this 
                // function.
                //
                
                ATLASSERT(FALSE);

                //
                // iIDS stays IDS_GENERAL_FAILURE due to 
                // the fact that we are not going report 
                // to the user on an invalid handle issue. 
                // This peace of code here should not been reached
                // ever and this is the reason to the assert. 
                //            
                
                break;

            case ERROR_BAD_UNIT:
                iIDS = IDS_CANNOT_FIND_DEVICE;            
                break;

            case ERROR_DIRECTORY:  //  The directory name is invalid.
                iIDS = IDS_ERROR_DIRECTORY;            
                break;

            case ERROR_BAD_PATHNAME:
                iIDS = IDS_ERROR_BAD_PATHNAME;
                break;

            case ERROR_EAS_NOT_SUPPORTED:
                iIDS = IDS_ERROR_EAS_NOT_SUPPORTED;
                break;

            case ERROR_REGISTRY_CORRUPT:
                iIDS = IDS_ERROR_REGISTRY_CORRUPT;                    
                break;

            case ERROR_PATH_NOT_FOUND:
                iIDS = IDS_ERROR_PATH_NOT_FOUND;                    
                break;

            case FAX_ERR_DIRECTORY_IN_USE:
                iIDS = IDS_FAX_ERR_DIRECTORY_IN_USE;                    
                break;

            case FAX_ERR_RULE_NOT_FOUND:
                iIDS = IDS_FAX_ERR_RULE_NOT_FOUND;                    
                break;

            case FAX_ERR_BAD_GROUP_CONFIGURATION:
                iIDS = IDS_FAX_ERR_BAD_GROUP_CONFIGURATION;                    
                break;

            case FAX_ERR_GROUP_NOT_FOUND:
                iIDS = IDS_FAX_ERR_GROUP_NOT_FOUND;                    
                break;

            case FAX_ERR_SRV_OUTOFMEMORY:
                iIDS = IDS_FAX_ERR_SRV_OUTOFMEMORY;                    
                break;

            case FAXUI_ERROR_INVALID_CSID:
                iIDS = IDS_FAX_ERR_INVALID_CSID;
                break;

            case FAXUI_ERROR_INVALID_TSID:
                iIDS = IDS_FAX_ERR_INVALID_TSID;
                break;

            default:
                break;
	    }
    }
    
    return iIDS;
}

/*
 -  IsNetworkError
 -
 *  Purpose:
 *      Verify if Error Code represents a network error.
 *
 *  Arguments:
 *          dwEc - error code DWORD
 *
 *  Return:
 *          Boolean TRUE if the dwEc represents a 
 *          network error, and FALSE if not.
 *      
 */
BOOL IsNetworkError(DWORD dwEc)
{
    DEBUG_FUNCTION_NAME( _T("IsNetworkError"));

    BOOL bIsNetworkError = FALSE; 
    //Initialized to avoid an option to future mistakes

    switch (dwEc)
    {
        case RPC_S_INVALID_BINDING:
            bIsNetworkError = TRUE;            
            break;

        case EPT_S_CANT_PERFORM_OP:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_ADDRESS_ERROR:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_CALL_CANCELLED:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_CALL_FAILED:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_CALL_FAILED_DNE:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_COMM_FAILURE:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_NO_BINDINGS:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_SERVER_TOO_BUSY:
            bIsNetworkError = TRUE;            
            break;

        case RPC_S_SERVER_UNAVAILABLE:
            bIsNetworkError = TRUE;            
            break;

	    default:
            bIsNetworkError = FALSE;            
            break;
	}
    return (bIsNetworkError);

}


/*
 -  Routine Description:
 -
 *     Invokes the browse dialog
 *
 *  Arguments:
 *
 *      lpszBrowseItem      [in/out] folder path
 *      dwMaxPath           [in]     max length of lpszBrowseItem
 *      lpszBrowseDlgTitle  [in]     browse dialog title
 *      ulBrowseFlags       [in]     browse dialog flags
 *      pParentWin          [in]     parent window
 *
 *  Return Value:
 *
 *     TRUE if successful, FALSE if the user presses Cancel
*/
BOOL
InvokeBrowseDialog( LPTSTR   lpszBrowseItem, 
                    DWORD    dwMaxPath,
                    LPCTSTR  lpszBrowseDlgTitle,
                    unsigned long ulBrowseFlags,
                    CWindow* pParentWin)
{

    DEBUG_FUNCTION_NAME( _T("InvokeBrowseDialog"));

    BOOL            fResult = FALSE;

    BROWSEINFO      bi;
    LPITEMIDLIST    pidl;
    LPMALLOC        pMalloc;
    VOID            SHFree(LPVOID);

    ATLASSERT( pParentWin != NULL);
    //
    // Preparing the BROWSEINFO structure.
    // 
    bi.hwndOwner        = (HWND)(*pParentWin); //Parents hWndDlg
    bi.pidlRoot         = NULL;
    bi.pszDisplayName   = lpszBrowseItem;
    bi.lpszTitle        = lpszBrowseDlgTitle;
    bi.ulFlags          = ulBrowseFlags;
    bi.lpfn             = BrowseCallbackProc; 
    bi.lParam           = (LPARAM) (lpszBrowseItem);
	bi.iImage           = 0;

    //
    // Memory check
    //
    if (FAILED(SHGetMalloc(&pMalloc)))
    {
        DlgMsgBox(pParentWin, IDS_MEMORY);
        return fResult;
    }

    //
    // Calling to the BrowseForFolder dialog 
    //
    if(pidl = SHBrowseForFolder(&bi)) //pidl != NULL
    {
        TCHAR szPath[MAX_PATH+1] = {0};
        //
        // Retrieving the New Path
        //
        if(SHGetPathFromIDList(pidl, szPath)) 
        {
            if(wcslen(szPath) >= dwMaxPath)
            {
                DlgMsgBox(pParentWin, IDS_ERR_DIR_TOO_LONG, MB_OK | MB_ICONERROR);
            }
            else
            {     
                DebugPrintEx(DEBUG_MSG, _T("Succeeded to Retrieve the path from browse dialog."));

                _tcsncpy(lpszBrowseItem, szPath, dwMaxPath);
                
                // Now the path was retreived successfully to
                // the back parameter lpszBrowseItem
                // and this is the only case in which the calling 
                // function gets TRUE as return value.
                
                fResult = TRUE;
            }
        }

        //
        // Free using shell allocator
        //
        pMalloc->Free(pidl);
        pMalloc->Release();
    }

    return fResult;
}


/*++
Routine Description:

    Callback function for the folder browser

Arguments:

    hwnd     : Handle to the browse dialog box. The callback function can 
               send the following messages to this window:

               BFFM_ENABLEOK      Enables the OK button if the wParam parameter 
                                  is nonzero or disables it if wParam is zero.
               BFFM_SETSELECTION  Selects the specified folder. The lParam 
                                  parameter is the PIDL of the folder to select 
                                  if wParam is FALSE, or it is the path of the 
                                  folder otherwise.
               BFFM_SETSTATUSTEXT Sets the status text to the null-terminated 
                                  string specified by the lParam parameter.
 
    uMsg     : Value identifying the event. This parameter can be one of the 
               following values:

               0                  Initialize dir path.  lParam is the path.

               BFFM_INITIALIZED   The browse dialog box has finished 
                                  initializing. lpData is NULL.
               BFFM_SELCHANGED    The selection has changed. lpData 
                                  is a pointer to the item identifier list for 
                                  the newly selected folder.
 
    lParam   : Message-specific value. For more information, see the 
               description of uMsg.

    lpData   : Application-defined value that was specified in the lParam 
               member of the BROWSEINFO structure.

Return Value:

    0 (1)

--*/
int CALLBACK BrowseCallbackProc(
                                HWND hWnd, 
                                UINT uMsg, 
                                LPARAM lParam, 
                                LPARAM lpData)
{
    int iRet = 0;    
    
    switch(uMsg)
	{

	case BFFM_INITIALIZED:
        // LParam is TRUE since you are passing a path.
        // It would be FALSE if you were passing a pidl.

        // the lpData points to the folder path.
        // It must contain a path.        
		// ASSERT(lpData && _T('\0') != *((LPTSTR)lpData));

        SendMessage(hWnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
        break;

	case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1] = {0};

            if (SHGetPathFromIDList ((LPITEMIDLIST) lParam, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);

                ::SendMessage(hWnd, BFFM_SETSTATUSTEXT, TRUE, (LPARAM)szPath);

                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            ::SendMessage(hWnd, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }


		break;

	case BFFM_VALIDATEFAILED:
		break;

	default:
		ATLTRACE2(atlTraceWindowing, 0, _T("Unknown message received in CFolderDialogImpl::BrowseCallbackProc\n"));
		break;
	}

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxmmcutils.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxMMCUtils.h                                          //
//                                                                         //
//  DESCRIPTION   : Header file for all Fax MMC private Utilities          //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//                                                                         //
//  Copyright (C) 1999  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////
#ifndef H_FAXMMCUTILS_H
#define H_FAXMMCUTILS_H

//
//
//
int GetFaxServerErrorMsg(DWORD dwEc);

//
//
//
BOOL IsNetworkError(DWORD dwEc);

//
//
//
int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

//
//
//
BOOL
InvokeBrowseDialog( LPTSTR   lpszBrowseItem, 
                    DWORD    dwMaxPath,
                    LPCTSTR  lpszBrowseDlgTitle,
                    unsigned long ulBrowseFlags,
                    CWindow* pWin);

#endif //H_FAXMMCUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxserver.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServer.h                                            //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxServer that contains the           //
//                  Connect / Disconnect functionality to the Fax Server   //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//      Aug  3 2000 yossg   Add notification window                        //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_MMCFAXSERVER_H
#define H_MMCFAXSERVER_H

class CFaxDevicesNode;
class CFaxGeneralNotifyWnd;

class CFaxServer 
{
public:
    //
    // Constructor
    //
    CFaxServer (LPTSTR lptstrServerName):
        m_hFaxHandle(NULL),
        m_bstrServerName(lptstrServerName),                
        m_pDevicesNode(NULL),
        m_pNotifyWin(NULL),
        m_hDevicesStatusNotification(NULL),
        m_dwServerAPIVersion(CURRENT_FAX_API_VERSION),
        m_bDesktopSKUConnection(FALSE)
    {}

    //
    // Destructor
    //
    ~CFaxServer ()
    {
        Disconnect();

        DestroyNotifyWindow();
    }
    
    HANDLE  GetFaxServerHandle();

    HRESULT Disconnect();

    STDMETHOD      (SetServerName)(BSTR bstrServerName);
    const CComBSTR& GetServerName();
    
    BOOL    IsServerRunningFaxService ();
    BOOL    IsServerFaxServiceStopped ();

    HRESULT RegisterForDeviceNotifications(CFaxDevicesNode * pDevices);

    HRESULT OnNewEvent(PFAX_EVENT_EX pFaxEvent);

    DWORD   GetServerAPIVersion() { return m_dwServerAPIVersion; }
    BOOL    IsDesktopSKUConnection() {return m_bDesktopSKUConnection; }

private:
    HRESULT Connect();

    HRESULT InternalRegisterForDeviceNotifications();

    DWORD   CreateNotifyWindow();
    DWORD   RegisterForNotifications();
    
    HRESULT UnRegisterForNotifications();
    VOID    DestroyNotifyWindow();

    //
    // members
    //
    HANDLE                m_hFaxHandle;
    CComBSTR              m_bstrServerName;

    CFaxDevicesNode *     m_pDevicesNode;
    CFaxGeneralNotifyWnd* m_pNotifyWin;

    //
    // Notification registration handle
    //
    HANDLE                m_hDevicesStatusNotification;    

    //
    // Server API Version info
    //
    DWORD   m_dwServerAPIVersion;
    BOOL    m_bDesktopSKUConnection;
};


#endif  //H_MMCFAXSERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxserver.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServer.cpp                                          //
//                                                                         //
//  DESCRIPTION   : CFaxServer that contains the                           //
//                  Connect / Disconnect functionality to the Fax Server   //
//                                                                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999 yossg   Init .                                         //
//      Aug  3 2000 yossg   Add notification window                        //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "FaxServer.h"

#include "Devices.h"
#include "GeneralNotifyWnd.h"

#include <FaxReg.h>

/*
 -  CFaxServer::GetFaxServerHandle
 -
 *  Purpose:
 *      If Handle does not exist re-connect.
 *      Retreives the Fax Server handle.
 *
 *  Arguments:
 *
 *  Return:
 *      Fax Server handle, if failed to connect 
 *      retrieves NULL
 */
HANDLE CFaxServer::GetFaxServerHandle()
{
    if (!m_hFaxHandle)
    {
        ATLASSERT (!m_hDevicesStatusNotification);
        
        HRESULT hRc = Connect();
        if ( FAILED(hRc))
        {
            // DebugPrintEx(DEBUG_ERR) 
            // should been already given by
            // this function caller.
        }
    }
    return m_hFaxHandle;
}

/*
 -  CFaxServer::Connect
 -
 *  Purpose:
 *      Connect to the Fax Server.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CFaxServer::Connect()
{
    DEBUG_FUNCTION_NAME(TEXT("CFaxServer::Connect"));
    DWORD  ec = ERROR_SUCCESS;

    ATLASSERT(!m_hFaxHandle);

    //
    // Connect to server
    //
    if (!FaxConnectFaxServer (m_bstrServerName, &m_hFaxHandle))
    {
        ec= GetLastError();

        DebugPrintEx(
            DEBUG_ERR,
            _T("FaxConnectFaxServer() Failed to %ws. (ec: %ld)"), 
            ((!m_bstrServerName) || (m_bstrServerName == L""))? L"local machine" : m_bstrServerName.m_str,
            ec);
        
        m_hFaxHandle = NULL;
        return HRESULT_FROM_WIN32(ec);
    }
    ATLASSERT(m_hFaxHandle);
    
    //
    // Check Server API Version
    //
    if(!FaxGetReportedServerAPIVersion(m_hFaxHandle, &m_dwServerAPIVersion))
    {
        //
        // Cannot retrieve version info
        //
        ec= GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("FaxGetReportedServerAPIVersion() failed with %ld)"), ec);
        
        Disconnect();
        return HRESULT_FROM_WIN32(ec);
    }

    if(m_dwServerAPIVersion > CURRENT_FAX_API_VERSION)
    {
        //
        // Cannot manage later version of fax
        //
        Disconnect();
        return HRESULT_FROM_WIN32(ERROR_RMODE_APP);
    }

    PRODUCT_SKU_TYPE ServerSKU = PRODUCT_SKU_UNKNOWN;
    if(!FaxGetServerSKU(m_hFaxHandle, &ServerSKU))
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("FaxGetServerSKU() failed with %ld)"), ec);       
        Disconnect();
        return HRESULT_FROM_WIN32(ec);        
    }
    
	if(IsDesktopSKUFromSKU(ServerSKU))
    {
        //
        // We are connected to WinXP Desktop SKU
        // It cannot be managed remotely
        //
        m_bDesktopSKUConnection = TRUE;

        Disconnect();
        return HRESULT_FROM_WIN32(ERROR_RMODE_APP);
    }        

    //
    // Verify or re-establish (if needed) notification setup
    //
    if (m_pDevicesNode)
    {
        HRESULT hRc = InternalRegisterForDeviceNotifications();
        if (S_OK != hRc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                    _T("InternalRegisterForDeviceNotifications Failed. (hRc: %08X)"),
                    hRc);
        }
    }
    
    
    DebugPrintEx(
        DEBUG_MSG,
        _T("FaxConnectFaxServer() succeeded. Handle: %08X"),
        m_hFaxHandle);

    return S_OK;
}

/*
 -  CFaxServer::Disconnect
 -
 *  Purpose:
 *      Disconnect from the Fax Server.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
HRESULT CFaxServer::Disconnect()
{
    DEBUG_FUNCTION_NAME(TEXT("CFaxServer::Disconnect"));
    
    HRESULT hRc = S_OK;
    DWORD   ec;

    if (NULL == m_hFaxHandle)
    {
        hRc = E_FAIL;
        DebugPrintEx(
            DEBUG_MSG,
            _T("No connection handle exists. (m_hFaxHandle is NULL)\n Connection may not started or disconnected before.\n "));
        
        return hRc;
    }

    hRc = UnRegisterForNotifications();
    if (S_OK != hRc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("UnRegisterForNotifications() failed. (hRc: %0X8)"), 
            hRc);

        // continue!!!
    }

    if (!FaxClose (m_hFaxHandle))
    {
        ec= GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            _T("FaxClose() failed. (ec: %ld)"), 
            ec);
        
        
        hRc = HRESULT_FROM_WIN32(ec);
        
        goto Cleanup; 
    }

    DebugPrintEx( DEBUG_MSG,
        _T("Succeeded to close connection to Fax. ServerHandle: %08X"),
        m_hFaxHandle);

Cleanup:
    
    m_hFaxHandle = NULL;
    
    return hRc;
}



/*
 -  CFaxServer::SetServerName
 -
 *  Purpose:
 *      Set the Server machine name
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServer::SetServerName(BSTR bstrServerName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::SetServerName"));
    HRESULT hRc = S_OK;

    m_bstrServerName = bstrServerName;
    if (!m_bstrServerName)
    {
        hRc = E_OUTOFMEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to allocate string - out of memory"));
               
        m_bstrServerName = L"";
    }

    return hRc;
}



/*
 -  CFaxServer::GetServerName
 -
 *  Purpose:
 *      Set the Server machine name
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
const CComBSTR& CFaxServer::GetServerName()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::GetServerName"));

    return m_bstrServerName;
}


/*
 +
 +
 *  CFaxServer::IsServerRunningFaxService
 *
 *  Purpose:
 *      Contacts the machine and determines if Fax Server Service is running.
 *
 *  Arguments:
 *
 *  Return:
 *      boolean value Running or notruning
 -
 -
 */
BOOL  CFaxServer::IsServerRunningFaxService ( )
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::IsServerRunningFaxService"));
    
    SC_HANDLE       SCMHandle = NULL;
    SC_HANDLE       FXSHandle = NULL;
    SERVICE_STATUS  SStatus;
    BOOL            bRun = FALSE;

    if (
        (SCMHandle = OpenSCManager(m_bstrServerName, NULL, GENERIC_READ)) 
        &&
        (FXSHandle = OpenService(SCMHandle, FAX_SERVICE_NAME, SERVICE_QUERY_STATUS)) 
        &&
        QueryServiceStatus(FXSHandle, &SStatus) 
        &&
        (SERVICE_RUNNING == SStatus.dwCurrentState) 
       )
    {
        bRun = TRUE;
    }  

    if (FXSHandle)
    {
        CloseServiceHandle(FXSHandle);
    }
    else // FXSHandle == NULL
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to Open Fax Server Service. (ec: %ld)"), 
            GetLastError());
    }

    if (SCMHandle)
    {
        CloseServiceHandle(SCMHandle);
    }
    else // SCMHandle == NULL
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to OpenSCManager. (ec: %ld)"), 
            GetLastError());
    }

    return bRun;
}


/*
 +
 +
 *  CFaxServer::IsServerFaxServiceStopped
 *
 *  Purpose:
 *      Contacts the machine and determines if Fax Server Service is already stopped.
 *
 *  Arguments:
 *      [in] bstrServerName - the server name 
 *
 *  Return:
 *      boolean value Running or notruning
 -
 -
 */
BOOL  CFaxServer::IsServerFaxServiceStopped( )
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::IsServerFaxServiceStopped"));
    
    SC_HANDLE       SCMHandle = NULL;
    SC_HANDLE       FXSHandle = NULL;
    SERVICE_STATUS  SStatus;
    BOOL            bRun = FALSE;

    if (
        (SCMHandle = OpenSCManager(m_bstrServerName, NULL, GENERIC_READ)) 
        &&
        (FXSHandle = OpenService(SCMHandle, FAX_SERVICE_NAME, SERVICE_QUERY_STATUS)) 
        &&
        QueryServiceStatus(FXSHandle, &SStatus) 
        &&
        (SERVICE_STOPPED == SStatus.dwCurrentState) 
       )
    {
        bRun = TRUE;
    }  

    if (FXSHandle)
    {
        CloseServiceHandle(FXSHandle);
    }
    else // FXSHandle == NULL
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to Open Fax Server Service. (ec: %ld)"), 
            GetLastError());
    }

    if (SCMHandle)
    {
        CloseServiceHandle(SCMHandle);
    }
    else // SCMHandle == NULL
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to OpenSCManager. (ec: %ld)"), 
            GetLastError());
    }

    return bRun;
}


/*
 +
 +
 *  CFaxServer::CreateNotifyWindow
 *
 *  Purpose:
 *     Init notification window 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 -
 -
 */
DWORD  CFaxServer::CreateNotifyWindow( )
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::CreateNotifyWindow"));
    
    DWORD   ec = ERROR_SUCCESS;
    RECT    rcRect;
    ZeroMemory(&rcRect, sizeof(rcRect));
    HWND    hDevicesNotifyHandle;

    ATLASSERT(!m_pNotifyWin);
        
    m_pNotifyWin = new CFaxGeneralNotifyWnd(this);
    if (!m_pNotifyWin)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError(ec); 
        
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to create CFaxGeneralNotifyWnd - Out of memory."));
        
        goto Exit;
    }


    hDevicesNotifyHandle = m_pNotifyWin->Create(NULL,
                            rcRect,
                            NULL,      //LPCTSTR szWindowName
                            WS_POPUP,  //DWORD dwStyle
                            0x0,
                            0);


    ATLASSERT(m_pNotifyWin->m_hWnd == m_hDevicesNotifyHandle);


    if (!(::IsWindow(hDevicesNotifyHandle)))
    {
        ec = ERROR_INVALID_HANDLE;
        
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to create window."));

        hDevicesNotifyHandle = NULL;
        delete m_pNotifyWin;
        m_pNotifyWin = NULL;

        goto Exit;
    }
    ATLASSERT(ERROR_SUCCESS == ec);
    goto Exit;
 
Exit:
    return ec;

}

/*
 +
 +
 *  CFaxServer::UnRegisterForNotifications
 *
 *  Purpose:
 *     UnRegisterFor Server Event Notifications 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 -
 -
 */
HRESULT CFaxServer::UnRegisterForNotifications()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::UnRegisterForNotifications"));

    DWORD ec = ERROR_SUCCESS;

    if (m_hDevicesStatusNotification)
    {
        //
        // Unregister server notifications
        //
        if (!FaxUnregisterForServerEvents (m_hDevicesStatusNotification))
        {
            ec = GetLastError ();
        
            DebugPrintEx(
                DEBUG_ERR,
                _T("Fail to Unregister For Device status Server Events. (ec: %ld)"), 
                ec);

            m_hDevicesStatusNotification = NULL;

            goto Exit;
        }
    }

Exit:
    return HRESULT_FROM_WIN32(ec);
}



/*
 +
 +
 *  CFaxServer::RegisterForNotification
 *
 *  Purpose:
 *     RegisterFor Server Event Notifications 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 -
 -
 */
DWORD CFaxServer::RegisterForNotifications()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::RegisterForNotifications"));

    DWORD ec = ERROR_SUCCESS;

    //
    // Register for device status notification
    //
    ATLASSERT(!m_hDevicesStatusNotification);
    ATLASSERT(m_pNotifyWin);
    ATLASSERT(m_pNotifyWin->IsWindow());

    if (!FaxRegisterForServerEvents (   
                                      m_hFaxHandle,
                                      FAX_EVENT_TYPE_DEVICE_STATUS,               
                                      NULL,                       
                                      0,                          
                                      m_pNotifyWin->m_hWnd,                    
                                      WM_GENERAL_EVENT_NOTIFICATION, 
                                      &m_hDevicesStatusNotification
                                    )                   
        )
    {
        ec = GetLastError();

        DebugPrintEx(
            DEBUG_ERR,
            _T("Fail to Register For Device Status Server Events (ec: %ld)"), ec);

        m_hDevicesStatusNotification = NULL;

        goto Exit;
    }
    ATLASSERT(m_hDevicesStatusNotification);
Exit:
    return ec;
    
}



/*
 +
 +
 *  CFaxServer::InternalRegisterForDeviceNotifications
 *
 *  Purpose:
 *     Call the members to create window and register for device notifications 
 *
 *  Arguments:
 *     non.
 *
 *  Return:
 *     HRESULT
 -
 -
 */
HRESULT CFaxServer::InternalRegisterForDeviceNotifications()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::InternalRegisterForDeviceNotifications"));
    
    DWORD ec = ERROR_SUCCESS;

    ATLASSERT (m_pDevicesNode);
        
    //
    // Check/Create notification window
    //
    if (!m_pNotifyWin)  
    {
        ATLASSERT(!m_hDevicesStatusNotification);
        
        ec = CreateNotifyWindow();
        if ( ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_MSG,
                _T("Fail to CreateNotifyWindow(). (ec: %ld)"), 
                ec);

            return HRESULT_FROM_WIN32(ec);
        }
    }
    ATLASSERT(m_pNotifyWin);

    //
    // Check/register to event notification
    //
    if (!m_hDevicesStatusNotification) 
    {
        ec = RegisterForNotifications();
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Fail to RegisterForNotification()"),
                ec);
        
            ATLASSERT(!m_hDevicesStatusNotification);

            //
            // Keep the notification window alive. 
            // Try next time to register only.
            //

            return HRESULT_FROM_WIN32(ec);
        }
        ATLASSERT(m_hDevicesStatusNotification);
    }

    return S_OK;
}





/*
 +
 +
 *  CFaxServer::OnNewEvent
 *
 *  Purpose:
 *     Called when new registered event reaches window 
 *
 *  Arguments:
 *     pFaxEvent [in] - PFAX_EVENT_EX structure pointer
 *
 *  Return:
 *     OLE error code
 -
 -
 */
HRESULT CFaxServer::OnNewEvent(PFAX_EVENT_EX pFaxEvent)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::OnNewEvent"));
    HRESULT hRc = S_OK;

    //
    // Update "Devices" Node
    //
    if ( FAX_EVENT_TYPE_DEVICE_STATUS == pFaxEvent->EventType )
    {
        ATLASSERT( m_pDevicesNode);

        hRc = m_pDevicesNode->UpdateDeviceStatusChange(
                                    pFaxEvent->EventInfo.DeviceStatus.dwDeviceId, 
                                    pFaxEvent->EventInfo.DeviceStatus.dwNewStatus);
        if (S_OK != hRc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                _T("Failed to UpdateDeviceStatusChange()"));

            goto Exit;
        }
    }
    else
    {
        ATLASSERT(FALSE); //Unsupported EVENT
    }

Exit:
    return hRc;

}

/*
 +
 +
 *  CFaxServer::RegisterForDeviceNotifications
 *
 *  Purpose:
 *     Init Devices notification window 
 *
 *  Arguments:
 *     pDevices [in] - pointer to "devices" node
 *
 *  Return:
 *     OLE error code
 -
 -
 */
HRESULT CFaxServer::RegisterForDeviceNotifications(CFaxDevicesNode * pDevices)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::RegisterForDeviceNotifications"));
    HRESULT hRc = S_OK;

    //
    // Set pointer to Devices node
    //
    m_pDevicesNode = pDevices;

    ATLASSERT (m_pDevicesNode);

    //
    // Now try to do the stages needed for this registration to happen
    //
    hRc = InternalRegisterForDeviceNotifications();
    if (S_OK != hRc)
    {
        DebugPrintEx(
            DEBUG_ERR,
                _T("InternalRegisterForDeviceNotifications Failed. (hRc: %08X)"),
                hRc);
    }

    return hRc;
}


/*
 +
 +
 *  CFaxServer::DestroyNotifyWindow
 *
 *  Purpose:
 *     DestroyNotifyWindow 
 *
 *  Arguments:
 *
 *  Return:
 *     VOID
 -
 -
 */
VOID CFaxServer::DestroyNotifyWindow()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServer::DestroyNotifyWindow"));

    //
    // Destroy Notification Window
    //
    if (NULL != m_pNotifyWin)
    {
        if (m_pNotifyWin->IsWindow())
        {
            m_pNotifyWin->DestroyWindow();
        }
        delete m_pNotifyWin;
        m_pNotifyWin = NULL;
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\fxsvalid.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FxsValid.cpp                                           //
//                                                                         //
//  DESCRIPTION   : Fax Validity checks.                                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 29 2000 yossg   Create                                         //  
//      Jul  4 2000 yossg   Add IsLocalServerName                                         //  
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "FxsValid.h"

#include <windns.h> //DNS_MAX_NAME_BUFFER_LENGTH

/*
 -  IsNotEmptyString
 -
 *  Purpose:
 *      To validate that a general string is not empty.
 *
 *  Arguments:
 *      [in]  bstrGenStr - input BSTR
 *
 *  Return:
 *      TRUE string is not length 0 or spaces only 
 *      FALSE if not 
 */
BOOL IsNotEmptyString(CComBSTR bstrGenStr)
{
    DEBUG_FUNCTION_NAME( _T("IsValidGeneralString"));

    int iLen = bstrGenStr.Length();
    if (iLen > 0)
    {
        for(int i = 0; i < iLen; i++ )
        {
            if( !iswspace( bstrGenStr[i] ) )
            {
                return(TRUE);
            }
        }
        DebugPrintEx(DEBUG_ERR,
			_T("String contains only spaces."));

        return FALSE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,
			_T("String length is zero."));

        return FALSE;
    }
}


/*
 -  IsValidServerNameString
 -
 *  Purpose:
 *      To validate string as a server name string.
 *      This level will return a detailed error message IDS.
 *
 *  Arguments:
 *      [in]  bstrServerName - input BSTR
 *      [out] puIds - pointer to IDS with error message.
 *
 *  Return:
 *      TRUE - the string is a valid server name string
 *      FALSE - if not 
 */
BOOL IsValidServerNameString(CComBSTR bstrServerName, UINT * puIds, BOOL fIsDNSName /*= FALSE*/)
{
    DEBUG_FUNCTION_NAME( _T("IsValidServerNameString"));

    int     iCount, i, iLength;
    BOOL    bFirstNonSpaceIsFound = FALSE;
    
    ATLASSERT(bstrServerName);
    ATLASSERT(puIds);

    //
    // Length == 0
    // 
    if ( 0 == ( iCount = bstrServerName.Length() ) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Server name is empty"));
        *puIds = IDS_SERVERNAME_EMPTY_STRING;
        
        return FALSE;
    }

    //
    // Length 
    //
    if ( fIsDNSName == FALSE ) 
    {
        iLength = MAX_COMPUTERNAME_LENGTH;
    }
    else 
    {
        iLength = DNS_MAX_NAME_BUFFER_LENGTH;
    }

    if ( ( iCount = bstrServerName.Length() ) > iLength )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Server name is too long"));
        *puIds = IDS_SERVERNAME_TOO_LONG;

        return FALSE;
    }
    
    //
    // search for: \ / tabs , ; : " < > * + = | [ ] ?  
    //           
    for (i = 0; i < iCount; i++)
    {
        if (
            (bstrServerName[i] == '\\')
           ||
            (bstrServerName[i] == '/')
           ||
            (bstrServerName[i] == '\t')
           ||
            (bstrServerName[i] == ',')
           ||
            (bstrServerName[i] == ';')
           ||
            (bstrServerName[i] == ':')
           ||
            (bstrServerName[i] == '"')
           ||
            (bstrServerName[i] == '<')
           ||
            (bstrServerName[i] == '>')
           ||
            (bstrServerName[i] == '*')
           ||
            (bstrServerName[i] == '+')
           ||
            (bstrServerName[i] == '=')
           ||
            (bstrServerName[i] == '|')
           ||
            (bstrServerName[i] == '?')
           ||
            (bstrServerName[i] == '[')
           ||
            (bstrServerName[i] == ']')
           )
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Server name contains an invalid character."));
            *puIds = IDS_SERVERNAME_STRING_CONTAINS_INVALID_CHARACTERS;
            
            return FALSE;
        }

        //
        // At the same loop see if all string is spaces
        //
        if (!bFirstNonSpaceIsFound)
        {
           if (bstrServerName[i] != ' ' )
           {
              bFirstNonSpaceIsFound = TRUE;
           }
        }
    }

    if (!bFirstNonSpaceIsFound)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Server name string includes only spaces."));
        *puIds = IDS_SERVERNAME_EMPTY_STRING;

        return FALSE;
    }

    return TRUE;
}




/*
 -  IsValidPortNumber
 -
 *  Purpose:
 *      To validate that string contains a valid port number.
 *      This level will return a detailed error message IDS.
 *
 *  Arguments:
 *      [in]  bstrPort - input BSTR
 *      [out] pdwPortVal - pointer to DWORD port value 
 *            in case of success.
 *      [out] puIds - pointer to IDS with error message 
 *            in case of failure.
 *
 *  Return:
 *      TRUE - the string containts a valid port number
 *      FALSE  - if not. 
 */
BOOL IsValidPortNumber(CComBSTR bstrPort, DWORD * pdwPortVal, UINT * puIds)
{
    DEBUG_FUNCTION_NAME( _T("IsValidPortNumber"));

    DWORD dwPort;
    
    ATLASSERT(bstrPort);

    //
    // Length == 0
    // 
    if (0 == bstrPort.Length())
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Port string is empty"));
        *puIds = IDS_PORT_EMPTY_STRING;
        
        return FALSE;
    }

    //
    // numerical value;
    //
    if (1 != swscanf (bstrPort, _T("%ld"), &dwPort))
    {
        *puIds = IDS_PORT_NOT_NUMERIC;
        DebugPrintEx(
			DEBUG_ERR,
			_T("port string is not a number"));
        
        return FALSE;
    }
    
    //
    // MIN_PORT_NUM <= dwPort <= MAX_PORT_NUM
    //
    if ( ((int)dwPort > FXS_MAX_PORT_NUM) || ((int)dwPort < FXS_MIN_PORT_NUM))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Port number is out off allowed values"));
        *puIds = IDS_INVALID_PORT_NUM;

        return FALSE;
    }
    
    *pdwPortVal = dwPort;
    return TRUE;
}


/*
 +  IsLocalComputer
 +
 *  Purpose:
 *      To see if the server name is the local computer name. 
 *      
 *  Arguments:
 *      [in] lpszComputer : the machine name.  
 *
 -  Return:
 -      TRUE or FALSE
 */
BOOL IsLocalServerName(IN LPCTSTR lpszComputer)
{
    DEBUG_FUNCTION_NAME( _T("IsLocalComputer"));
    
    //
    // Pre conditions
    //
    ATLASSERT(lpszComputer);

    if (!lpszComputer || !*lpszComputer)
    {
        return TRUE;
    }

    if ( _tcslen(lpszComputer) > 2 && ( 0 == wcsncmp( lpszComputer , _T("\\\\") , 2 ))   ) 
    {
        lpszComputer = _tcsninc(lpszComputer, 2); 
    }

    //
    // Computer Name Compare
    //
    BOOL    bReturn = FALSE;
    DWORD   dwErr = 0;
    TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

    // 1st: compare against local Netbios computer name
    if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
    {
        dwErr = GetLastError();
    } 
    else
    {
        bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
        if (!bReturn)
        { 
            // 2nd: compare against local Dns computer name 
            dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
            if (GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize))
            {
                bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
            }
            else
            {
                dwErr = GetLastError();
            }
        }
    }

    if (dwErr)
    {
        DebugPrintEx(DEBUG_ERR,
		_T("Failed to discover if is a local server (ec = %x)"), dwErr);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxservernode.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServerNode.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxServerNode snapin node class       //
//                  This is the "Fax" node in the scope pane.              //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Init .                                         //
//      Nov 24 1999 yossg   Rename file from FaxCfg                        //
//      Dec  9 1999 yossg   Call InitDisplayName from parent		   //
//      Mar 16 2000 yossg   Add service start-stop                         //
//      Jun 25 2000 yossg   add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//                                                                         //
//  Copyright (C) 1998 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXSERVERNODE_H
#define H_FAXSERVERNODE_H

//#pragma message( "H_FAXSERVERNODE_H" )

//
// Dialog H files
//
#include "ppFaxServerGeneral.h"
#include "ppFaxServerReceipts.h"
#include "ppFaxServerLogging.h"
#include "ppFaxServerEvents.h"
#include "ppFaxServerInbox.h"
#include "ppFaxServerOutbox.h"
#include "ppFaxServerSentItems.h"

//
// MMC FaxServer connection class
//
#include "FaxServer.h"
#include "FaxMMCGlobals.h"

#include "snapin.h"
#include "snpnscp.h"


class CppFaxServerGeneral;    
class CppFaxServerReceipts;
class CppFaxServerEvents;
class CppFaxServerLogging;
class CppFaxServerOutbox;
class CppFaxServerInbox;
class CppFaxServerSentItems;


//////////////////////////////////////////////////////////////
//class COutRoutingRulesNode;

class CFaxServerNode : public CNodeWithScopeChildrenList<CFaxServerNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxServerNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_SRV_START,   OnServiceStartCommand)
        SNAPINCOMMAND_ENTRY(IDM_SRV_STOP,    OnServiceStopCommand)
        SNAPINCOMMAND_ENTRY(ID_START_BUTTON, OnServiceStartCommand)
        SNAPINCOMMAND_ENTRY(ID_STOP_BUTTON,  OnServiceStopCommand)

        SNAPINCOMMAND_ENTRY(ID_CLIENTCONSOLE_BUTTON,  OnLaunchClientConsole)
        SNAPINCOMMAND_ENTRY(IDM_LAUNCH_CONSOLE,       OnLaunchClientConsole)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxServerNode)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_STARTSTOP)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_FAX_MENU)

    //
    // Constructor
    //
    CFaxServerNode(CSnapInItem * pParentNode, CSnapin * pComponentData, LPTSTR lptstrServerName ) :
        CNodeWithScopeChildrenList<CFaxServerNode, FALSE>(pParentNode, pComponentData ),
        m_FaxServer(lptstrServerName)
    {        
        
        m_pFaxServerGeneral    =  NULL;    
        m_pFaxServerEmail      =  NULL;
        m_pFaxServerEvents     =  NULL;
        m_pFaxServerLogging    =  NULL;
        m_pFaxServerOutbox     =  NULL;
        m_pFaxServerInbox      =  NULL;
        m_pFaxServerSentItems  =  NULL;

	    m_pParentNodeEx = NULL; // we are at the root now

        m_fAllowOverrideServerName   = FALSE;

        m_IsPrimaryModeSnapin        = FALSE;

        m_IsLaunchedFromSavedMscFile = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxServerNode()
    {
    }

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    //
    // Property pages methods
    //
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(CreateSnapinManagerPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                                        LONG_PTR handle);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT || type == CCT_SNAPIN_MANAGER)
            return S_OK;
        return S_FALSE;
    }

    HRESULT   InitDisplayName();

    const CComBSTR&  GetServerName();

    STDMETHOD(SetServerNameOnSnapinAddition)(BSTR bstrServerName, BOOL fAllowOverrideServerName);
    STDMETHOD(UpdateServerName)(BSTR bstrServerName);

    //
    // inline Fax Server ptr
    //
    inline CFaxServer * GetFaxServer() /*const*/ 
    { 
        return &m_FaxServer;
    };

    void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
	BOOL UpdateToolbarButton( UINT id, BYTE fsState );

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

    BOOL    GetAllowOverrideServerName() { return m_fAllowOverrideServerName; };

    HRESULT InitDetailedDisplayName(); //Plus ServerName

    void    SetIsLaunchedFromSavedMscFile() { m_IsLaunchedFromSavedMscFile=TRUE; }

private:
    //
    // The property pages members
    //
    CppFaxServerGeneral   *  m_pFaxServerGeneral;    
    CppFaxServerReceipts  *  m_pFaxServerEmail;
    CppFaxServerEvents    *  m_pFaxServerEvents;
    CppFaxServerLogging   *  m_pFaxServerLogging;
    CppFaxServerOutbox    *  m_pFaxServerOutbox;
    CppFaxServerInbox     *  m_pFaxServerInbox;
    CppFaxServerSentItems *  m_pFaxServerSentItems;

    //
    // Handles
    //
    static CColumnsInfo      m_ColsInfo;

    CFaxServer               m_FaxServer;
    
    BOOL                     m_fAllowOverrideServerName;

    BOOL                     m_IsPrimaryModeSnapin;

    BOOL                     m_IsLaunchedFromSavedMscFile;

    //
    // event handlers
    //
    HRESULT OnLaunchClientConsole(bool &bHandled, CSnapInObjectRootBase *pRoot); 
    HRESULT OnServiceStartCommand(bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnServiceStopCommand (bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT ForceRedrawNode();
};

typedef CNodeWithScopeChildrenList<CFaxServerNode, FALSE>
        CBaseFaxNode;

#endif  //H_FAXSERVERNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\fxsvalid.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FxsValid.h                                             //
//                                                                         //
//  DESCRIPTION   : Fax Validity checks.                                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 29 2000 yossg   Create                                         //  
//      Jul  4 2000 yossg   Add IsLocalServerName                                         //  
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FXSVALID_MMC_H
#define H_FXSVALID_MMC_H


BOOL IsNotEmptyString(CComBSTR bstrGenStr); 

BOOL IsValidServerNameString(CComBSTR bstrServerName, UINT * puIds, BOOL fIsDNSName = FALSE);

BOOL IsValidPortNumber(CComBSTR bstrPort, DWORD * pdwPortVal, UINT * puIds);

BOOL IsLocalServerName(IN LPCTSTR lpszComputer);


#endif  //H_FXSVALID_MMC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\generalnotifywnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : GeneralNotifyWnd.cpp                                    //
//                                                                         //
//  DESCRIPTION   : The implementation of fax Device notification window.  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Aug  3 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GeneralNotifyWnd.h"

#include "FaxServer.h"



/*
 -  CFaxGeneralNotifyWnd::OnServerDeviceStateChanged
 -
 *  Purpose:
 *     Catch the server event of device status change and 
 *     update the change through Devices node.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CFaxGeneralNotifyWnd::OnServerEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    DEBUG_FUNCTION_NAME( _T("CFaxGeneralNotifyWnd::OnServerEvent"));
    ATLASSERT(m_pDevicesNode);

	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( fHandled );

    HRESULT hRc = S_OK;
    
    ATLASSERT( uiMsg == WM_GENERAL_EVENT_NOTIFICATION );
    
    //
    // Extract event object
    //
    PFAX_EVENT_EX  pFaxEvent = NULL;
	pFaxEvent = reinterpret_cast<PFAX_EVENT_EX>(lParam);
    ATLASSERT( pFaxEvent );
    
	//
    // Update FaxServer object with "Devices" event
    //
    ATLASSERT(m_pFaxServer);
    
    hRc = m_pFaxServer->OnNewEvent(pFaxEvent);
    if (S_OK != hRc)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to trsport new event to FaxServer object"));
    }

    //
    // Free buffer (any way!)
    //
    if (pFaxEvent) 
    {
        FaxFreeBuffer (pFaxEvent);
        pFaxEvent = NULL;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\faxservernode.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxServerNode.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Server MMC node creation.                          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 22 1999 yossg   Init .                                         //
//      Nov 24 1999 yossg   Rename file from FaxCfg                        //
//      Dec  9 1999 yossg   Call InitDisplayName from parent               //
//      Feb  7 2000 yossg   Add Call to CreateSecurityPage          	   //
//      Mar 16 2000 yossg   Add service start-stop                         //
//      Jun 25 2000 yossg   Add stream and command line primary snapin 	   //
//                          machine targeting.                             //
//      Oct 17 2000 yossg                                                  //
//      Dec 10 2000 yossg  Update Windows XP                               //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "FaxServerNode.h"
//
//Child Nodes H files
//
#include "DevicesAndProviders.h"
#include "OutboundRouting.h"
#include "InboundRouting.h"
#include "CoverPages.h"

#include "SecurityInfo.h"  //which includes also <aclui.h>

#include "WzConnectToServer.h"
          

#include <faxreg.h>
#include "Icons.h"

#include "oaidl.h"


//
//CFaxServerNode Class
//

/////////////////////////////////////////////////////////////////////////////
// {7A4A6347-A42A-4d36-8538-6634CD3C3B15}
static const GUID CFaxServerNodeGUID_NODETYPE = 
{ 0x7a4a6347, 0xa42a, 0x4d36, { 0x85, 0x38, 0x66, 0x34, 0xcd, 0x3c, 0x3b, 0x15 } };

const GUID*    CFaxServerNode::m_NODETYPE = &CFaxServerNodeGUID_NODETYPE;
const OLECHAR* CFaxServerNode::m_SZNODETYPE = OLESTR("7A4A6347-A42A-4d36-8538-6634CD3C3B15");
const CLSID*   CFaxServerNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxServerNode::m_ColsInfo;

/*
 -  CFaxServerNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxServerNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    HRESULT hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] =
    {
        {IDS_FAX_COL_HEAD, FXS_LARGE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to InsertColumnsIntoMMC. hRc: %08X "), 
			hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}

/*
 -  CFaxServerNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::PopulateScopeChildrenList"));

    HRESULT   hRc = S_OK;

    CFaxDevicesAndProvidersNode *       pDevicesAndProviders = NULL;
    CFaxInboundRoutingNode *            pIn                  = NULL;
    CFaxOutboundRoutingNode *           pOut                 = NULL;
    CFaxCoverPagesNode *                pCoverPages          = NULL;

    CFaxServer *                        pFaxServer           = NULL;

    //
    // Prepare IConsoleNameSpace for case of failure
    //
    ATLASSERT(m_pComponentData);
    ATLASSERT( ((CSnapin*)m_pComponentData)->m_spConsole );
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace( ((CSnapin*)m_pComponentData)->m_spConsole );
    ATLASSERT( spConsoleNameSpace );

    HRESULT hr = S_OK; 

    if (m_IsPrimaryModeSnapin)
    {
        if (m_IsLaunchedFromSavedMscFile)
        {
            hRc = ForceRedrawNode();
            if ( S_OK != hRc )
            {
                //msgbox and dbgerr by called func.
                return hRc;
            }
        }
    }

    //
    // Preliminary connection-test
    //
    pFaxServer = GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        DWORD ec= GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("Failed to check connection to server. (ec: %ld)"), ec);
        
        pFaxServer->Disconnect();       

        if(pFaxServer->GetServerAPIVersion() > CURRENT_FAX_API_VERSION)
        {
            //
            // Cannot manage later version of fax
            //
            NodeMsgBox(IDS_ERR_API_NEW_VERSION, MB_OK | MB_ICONSTOP);
            hRc = HRESULT_FROM_WIN32(ERROR_RMODE_APP);
        }
        else if(pFaxServer->IsDesktopSKUConnection())
        {
            //
            // Cannot manage WinXP desktop SKU fax
            //
            NodeMsgBox(IDS_ERR_DESKTOP_SKU_CONNECTION, MB_OK | MB_ICONSTOP);
            hRc = HRESULT_FROM_WIN32(ERROR_RMODE_APP);
        }
        else
        {
            NodeMsgBox(IDS_NETWORK_PROBLEMS, MB_OK | MB_ICONSTOP);
            hRc = HRESULT_FROM_WIN32(ec);
        }
        return hRc;
    }

    //
    //Devices And Providers
    //
    pDevicesAndProviders = new CFaxDevicesAndProvidersNode(this, m_pComponentData);
    if (!pDevicesAndProviders)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pDevicesAndProviders->InitParentNode(this);

        hRc = pDevicesAndProviders->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_AllDEVICES);
		    goto Error;
        }

        pDevicesAndProviders->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = AddChild(pDevicesAndProviders, &pDevicesAndProviders->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("Fail to add devices and providers node. (hRc: %08X)"),
                   hRc);
            NodeMsgBox(IDS_FAILTOADD_AllDEVICES);
            goto Error;
        }
    }

    //
    // Fax Inbound Routing
    //
    pIn = new CFaxInboundRoutingNode(this, m_pComponentData);
    if (!pIn)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pIn->InitParentNode(this);

        pIn->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = pIn->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTING);
		    goto Error;
        }

        hRc = AddChild(pIn, &pIn->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
               DEBUG_ERR,
               TEXT("Fail to add inbound routing node. (hRc: %08X)"),
               hRc);
            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTING);
            goto Error;
        }
    }

    //
    // Fax Outbound Routing
    //
    pOut = new CFaxOutboundRoutingNode(this, m_pComponentData);
    if (!pOut)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
                DEBUG_ERR,
                TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pOut->InitParentNode(this);

        pOut->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = pOut->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_OUTBOUNDROUTING);
		    goto Error;
        }

        hRc = AddChild(pOut, &pOut->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Fail to add outbound routing node. (hRc: %08X)"),
                 hRc);
            NodeMsgBox(IDS_FAILTOADD_OUTBOUNDROUTING);
            goto Error;
        }
    }

    //
    // CoverPages
    //
    pCoverPages = new CFaxCoverPagesNode(this, m_pComponentData);
    if (!pCoverPages)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory"));
        goto Error;
    }
    else
    {
        pCoverPages->InitParentNode(this);
        
        hRc = pCoverPages->Init();
        if ( FAILED(hRc) )
        {
            if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hRc)
            {
                DebugPrintEx(
                    DEBUG_ERR, //Dbg Warning only !!!
                    _T("Cover pages folder was not found. (hRc: %08X)"), hRc);                       
		        
                NodeMsgBox(IDS_COVERPAGES_PATH_NOT_FOUND);
            }
            else
            {
                DebugPrintEx(DEBUG_ERR,_T("Failed to Init cover pages class. (hRc: %08X)"), hRc);                       
                NodeMsgBox(IDS_FAILTOADD_COVERPAGES);
            }
            goto Error;

        }

        hRc = pCoverPages->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_COVERPAGES);
		    goto Error;
        }

        pCoverPages->SetIcons(IMAGE_FAX_COVERPAGES, IMAGE_FAX_COVERPAGES);

        hRc = AddChild(pCoverPages, &pCoverPages->m_scopeDataItem);
        if (FAILED(hRc))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Fail to add reports node. (hRc: %08X)"),
                 hRc);
            NodeMsgBox(IDS_FAILTOADD_COVERPAGES);
            goto Error;
        }
    }
		
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pDevicesAndProviders ) 
    {
        if (0 != pDevicesAndProviders->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pDevicesAndProviders->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pDevicesAndProviders;    
        pDevicesAndProviders = NULL;    
    }

    if ( NULL != pIn ) 
    {
        if (0 != pIn->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pIn->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pIn;    
        pIn = NULL;    
    }

    if ( NULL != pOut ) 
    {
        if (0 != pOut->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pOut->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pOut;    
        pOut = NULL;    
    }
    if ( NULL != pCoverPages ) 
    {
        if (0 != pCoverPages->m_scopeDataItem.ID )
        {
            hr = spConsoleNameSpace->DeleteItem(pCoverPages->m_scopeDataItem.ID, TRUE);
            if (hr != S_OK) // can be only E_UNEXPECTED [MSDN]
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("spConsoleNameSpace->DeleteItem() Failed - Unexpected error. (hRc: %08X)"),
                     hr);
                ATLASSERT(FALSE);
            }
        }
        delete  pCoverPages;    
        pCoverPages = NULL;
    }

    // Empty the list
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}


/*
 -  CFaxServerNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for routing notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 *      Out of memory error or last error occured
 */
HRESULT
CFaxServerNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    HRESULT hRc    = S_OK; 
    DWORD   ec     = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::CreatePropertyPages"));

    ATLASSERT(lpProvider);    

    if( type == CCT_SNAPIN_MANAGER ) //invokes wizard
    {
        return CreateSnapinManagerPages(lpProvider, handle);
    }
    
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    m_pFaxServerGeneral    = NULL;    
    m_pFaxServerEmail      = NULL;
    m_pFaxServerEvents     = NULL;
    m_pFaxServerLogging    = NULL;
    m_pFaxServerOutbox     = NULL;
    m_pFaxServerInbox      = NULL;
    m_pFaxServerSentItems  = NULL;

    PSECURITY_DESCRIPTOR                pSecurityDescriptor = NULL;
    CFaxSecurityInformation *           pSecurityInfo = NULL;
    CFaxServer *						pFaxServer = NULL;

    HPROPSHEETPAGE                      hPage;

    BOOL                                fIsLocalServer = TRUE;

    //
    // Preliminary Access Check
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        
        NodeMsgBox(GetFaxServerErrorMsg(ec));
		
        hRc = HRESULT_FROM_WIN32(ec);
        goto Error;
    }
    
	
    if (!FaxAccessCheckEx(pFaxServer->GetFaxServerHandle(),
						FAX_ACCESS_QUERY_CONFIG,
						NULL))
    {
        ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            DebugPrintEx(
                 DEBUG_MSG,
                 _T("FaxAccessCheckEx returns ACCESS DENIED for FAX_ACCESS_QUERY_CONFIG."));
		    
            goto Security;
        }
        else 
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 _T("Fail check access for FAX_ACCESS_QUERY_CONFIG."));
            
            NodeMsgBox(GetFaxServerErrorMsg(ec));

            hRc = HRESULT_FROM_WIN32(ec);
            goto Error;
        }
    }
	

    if ( 0 != (pFaxServer->GetServerName()).Length() )
    {
        fIsLocalServer = FALSE;
    }

    //
    // General
    //
    m_pFaxServerGeneral = new CppFaxServerGeneral(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerGeneral)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
	
    hRc = m_pFaxServerGeneral->InitRPC();	
    if (FAILED(hRc))
    {
         DebugPrintEx(
             DEBUG_ERR,
             TEXT("Fail to call RPC to init property page for General Tab. (hRc: %08X)"),
             hRc);

        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerGeneral->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to Create() property page. (hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
           DEBUG_ERR,
           TEXT("Fail to add property page for General Tab. (hRc: %08X)"),
           hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Receipts - Notification delivery
    //
    m_pFaxServerEmail = new CppFaxServerReceipts(
                                                 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerEmail)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }
	
    hRc = m_pFaxServerEmail->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for mail Tab.(hRc: %08X)"),
            hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerEmail->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to add property page for Email Tab.(hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Event Reports  ("Logging Categories")
    //
    m_pFaxServerEvents = new CppFaxServerEvents(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerEvents)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }
	
    hRc = m_pFaxServerEvents->InitRPC();	
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to call RPC to init property page for event reports Tab. (hRc: %08X)"),
			hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerEvents->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for Events Tab.(hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Logging
    //
    m_pFaxServerLogging = new CppFaxServerLogging(
												 handle,
                                                 this,
                                                 fIsLocalServer,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerLogging)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }
	
    hRc = m_pFaxServerLogging->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
           DEBUG_ERR,
           TEXT("Fail to call RPC to init property page for Logging tab.(hRc: %08X)"),
           hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerLogging->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to Create() property page. (hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {		 
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for Logging Tab.(hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Outbox
    //
    m_pFaxServerOutbox = new CppFaxServerOutbox(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

    if (!m_pFaxServerOutbox)
    {
        hRc= E_OUTOFMEMORY;
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }
	
    hRc = m_pFaxServerOutbox->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for Outbox tab. (hRc: %08X)"),
            hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerOutbox->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to Create() property page. (hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to add property page for Outbox Tab.(hRc: %08X)"),
            hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Inbox Archive
    //
    m_pFaxServerInbox = new CppFaxServerInbox(
												 handle,
                                                 this,
                                                 fIsLocalServer,
                                                 _Module.GetResourceInstance());


    if (!m_pFaxServerInbox)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
		goto Error;
    }

    hRc = m_pFaxServerInbox->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for Inbox Tab.(hRc: %08X)"),
            hRc);
        goto Error;
    }

		

    hPage = NULL;
    hPage = m_pFaxServerInbox->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError()); 
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for Inbox Tab. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    //
    // Sent Items Archive
    //
    
    
    
    
    m_pFaxServerSentItems = new CppFaxServerSentItems(
												 handle,
                                                 this,
                                                 fIsLocalServer,
                                                 _Module.GetResourceInstance());
    if (!m_pFaxServerSentItems)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
    }
	
    hRc = m_pFaxServerSentItems->InitRPC();	
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to call RPC to init property page for Sent items tab. (hRc: %08X)"),
            hRc);
        goto Error;
    }


    hPage = NULL;
    hPage = m_pFaxServerSentItems->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for SentItems Tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

Security:  //Must be last tab!!!
    
    //
    // Security
    //
    pSecurityInfo = new CComObject<CFaxSecurityInformation>;
    if (!pSecurityInfo) 
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }	
    pSecurityInfo->Init(this);    
    
	hPage = NULL;
    hPage = CreateSecurityPage( pSecurityInfo );
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }
    hRc = lpProvider->AddPage( hPage );
    if (FAILED(hRc))
    {
	    DebugPrintEx(
		    DEBUG_ERR,
		    TEXT("Fail to add property page for Inbox Tab. (hRc: %08X)"),
		    hRc);
	    NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }  


    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pFaxServerGeneral ) 
    {
        delete  m_pFaxServerGeneral;    
        m_pFaxServerGeneral = NULL;    
    }
    if ( NULL != m_pFaxServerEmail ) 
    {
        delete  m_pFaxServerEmail;
        m_pFaxServerEmail = NULL;
    }
    if ( NULL != m_pFaxServerEvents ) 
    {
        delete  m_pFaxServerEvents;
        m_pFaxServerEvents = NULL;
    }
    if ( NULL != m_pFaxServerLogging ) 
    {
        delete  m_pFaxServerLogging;
        m_pFaxServerLogging = NULL;
    }
    if ( NULL != m_pFaxServerOutbox ) 
    {
        delete  m_pFaxServerOutbox;
        m_pFaxServerOutbox = NULL;
    }
    if ( NULL != m_pFaxServerInbox ) 
    {
        delete  m_pFaxServerInbox;
        m_pFaxServerInbox = NULL;
    }
    if ( NULL != m_pFaxServerSentItems ) 
    {
        delete  m_pFaxServerSentItems;
        m_pFaxServerSentItems = NULL;
    }
    if ( NULL != pSecurityInfo ) 
    {
        delete  pSecurityInfo;
        pSecurityInfo = NULL;
    }

Exit:
    if (NULL != pSecurityDescriptor )
    {
        FaxFreeBuffer( (PVOID)pSecurityDescriptor );
    }

    return hRc;
}





/*
 -  CFaxServerNode::CreateSnapinManagerPages
 -
 *  Purpose:
 *      Called to create wizard by snapin manager     
 *      CreatePropertyPages with ( type == CCT_SNAPIN_MANAGER )
 *
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for routing notification
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::CreateSnapinManagerPages(
                                LPPROPERTYSHEETCALLBACK lpProvider,
                                LONG_PTR handle)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::CreateSnapinManagerPages"));
    
    // This page will take care of deleting itself when it
    // receives the PSPCB_RELEASE message.

    CWzConnectToServer * pWzPageConnect = new CWzConnectToServer(this);
        
    HPROPSHEETPAGE   hPage = NULL;
    HRESULT hRc = S_OK;
    hPage = pWzPageConnect->Create();
    if ((!hPage))
    {
        hRc = HRESULT_FROM_WIN32(GetLastError());
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to Create() property page. (hRc: %08X)"),
			hRc);
        
        PageErrorEx(IDS_FAX_CONNECT, IDS_FAIL_TO_OPEN_TARGETING_WIZARD, NULL);

        return hRc;
    }

    hRc = lpProvider->AddPage(hPage);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add the connect to server property page to wizard. (hRc: %08X)"),
			hRc);
        PageErrorEx(IDS_FAX_CONNECT, IDS_FAIL_TO_OPEN_TARGETING_WIZARD, NULL);
        
        return hRc;
    }

    return hRc;
}

/*
 -  CFaxServerNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxServerNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hr = S_OK;

    CFaxServer* pFaxServer = NULL;

    pFaxServer = GetFaxServer();
    ATLASSERT(pFaxServer);

    if(!pFaxServer->IsServerRunningFaxService())
    {
        hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        return hr;
    }

    //
    // Init server API version information
    //
    pFaxServer->GetFaxServerHandle();

    if(pFaxServer->GetServerAPIVersion() > CURRENT_FAX_API_VERSION ||
       pFaxServer->IsDesktopSKUConnection())
    {
        //
        // Cannot manage later version of fax or WinXP desktop SKU fax
        //
        hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        return hr;
    }

    //
    // Display verbs that we support:
    // 1. Properties
    //

    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hr;
}


/*
 -  CFaxServerNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxServerNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    return S_OK;
}


/*
 -  CFaxServerNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxServerNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    BOOL fIsRunning = FALSE; 
    
    ATLASSERT(GetFaxServer());
    fIsRunning = GetFaxServer()->IsServerRunningFaxService();
    
    switch (id)
    {
        case IDM_SRV_START:
            *flags = (fIsRunning  ?  MF_GRAYED : MF_ENABLED );
            break;

        case IDM_SRV_STOP:

            *flags = (!fIsRunning ?  MF_GRAYED : MF_ENABLED );           
            break;

        case IDM_LAUNCH_CONSOLE:

            *flags = IsFaxComponentInstalled(FAX_COMPONENT_CONSOLE) ? MF_ENABLED : MF_GRAYED;
            break;

        default:
            break;
    }
    
    return;
}

/*
 -  CFaxServerNode::UpdateToolbarButton
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateToolbarButton
 *      This function aloow us to decide if to the activate\grayed a toolbar button  
 *      It treating only the Enable state.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int for the toolbar button ID
 *            [in]  fsState  - state to be cosidered ENABLE ?HIDDEN etc. 
 *
 *  Return:
 *     BOOL TRUE to activate state FALSE to disabled the state for this button 
 */
BOOL CFaxServerNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
	DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateToolbarButton"));
    BOOL bRet = FALSE;	
	
    BOOL fIsRunning = FALSE; 
    
    ATLASSERT(GetFaxServer());
    fIsRunning = GetFaxServer()->IsServerRunningFaxService();


	// Set whether the buttons should be enabled.
	if (fsState == ENABLED)
    {

        switch ( id )
        {
            case ID_START_BUTTON:
	            
                bRet = ( fIsRunning ?  FALSE : TRUE );
                break;

            case ID_STOP_BUTTON:
                
                bRet = ( fIsRunning ?  TRUE : FALSE );
                break;
        
            case ID_CLIENTCONSOLE_BUTTON:
	            
                bRet = IsFaxComponentInstalled(FAX_COMPONENT_CONSOLE); 
                break;

            default:
                break;

        }

    }

	// For all other possible button ID's and states, 
    // the correct answer here is FALSE.
	return bRet;

}


/*
-  CFaxServerNode::OnServiceStartCommand
-
*  Purpose:
*      To start Fax Server Service
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxServerNode::OnServiceStartCommand(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::OnServiceStartCommand"));
    BOOL                    bRet = FALSE;

    HRESULT                 hRc  = S_OK;
    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;

    
    //
    // 0) Service status check
    //
    ATLASSERT(GetFaxServer());
    if (GetFaxServer()->IsServerRunningFaxService())
    {
        DebugPrintEx(
			DEBUG_MSG,
			_T("Service is already running. (ec: %ld)"));
        NodeMsgBox(IDS_SRV_ALREADY_START);
        
        bRet = TRUE; //to allow toolbar refresh to correct state
    }
    else
    {

        //
        // 1) Start the service
        //
        // ATLASSERT(GetFaxServer()); was called above
        bRet = EnsureFaxServiceIsStarted (GetFaxServer()->GetServerName());
        if (!bRet) 
        { 
            NodeMsgBox(IDS_FAIL2START_SRV); 
        }
    }

    //
    // 2) Update the toolbar.
    //
	if (bRet)
    {
        //
	    // Get the updated SCOPEDATAITEM
	    //
        hRc = GetScopeData( &pScopeData );
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to get pScopeData. (hRc: %08X)"),
			    hRc);
            NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
        }
        else
        {
            //
	        // This will force MMC to redraw the scope node
	        //
            spConsole = m_pComponentData->m_spConsole;
            ATLASSERT(spConsole);
	        
            hRc = spConsole->SelectScopeItem( pScopeData->ID );
            if (FAILED(hRc))
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to select scope Item. (hRc: %08X)"),
			        hRc);
                NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
            }
        }
    }

    return (bRet ?  S_OK : E_FAIL);
}



/*
-  CFaxServerNode::OnServiceStopCommand
-
*  Purpose:
*      To stop Fax Server Service
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxServerNode::OnServiceStopCommand(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::OnServiceStopCommand"));

    BOOL                    bRet = FALSE;

    HRESULT                 hRc  = S_OK;
    CFaxServer *            pFaxServer = NULL;

    //
    // 0) Service status check
    //
    pFaxServer = GetFaxServer();
    ATLASSERT(pFaxServer);

    if (pFaxServer->IsServerFaxServiceStopped())
    {
        DebugPrintEx(
			DEBUG_MSG,
			_T("Do not have to stop - Fax server service is not started. (ec: %ld)"));
        NodeMsgBox(IDS_SRV_ALREADY_STOP);
        
        bRet = TRUE; //to allow toolbar refresh to correct state
    }
    else
    {
        //
        // 1) Stop the service
        //
        bRet = StopService(pFaxServer->GetServerName(), FAX_SERVICE_NAME, TRUE);
        if (!bRet) 
        { 
            NodeMsgBox(IDS_FAIL2STOP_SRV); 
        }
    }

    //
    // 2) Update the toolbar.
    //
	if (bRet)
    {
        pFaxServer->Disconnect();       

        SCOPEDATAITEM*          pScopeData;
        CComPtr<IConsole>       spConsole;

        //
	    // Get the updated SCOPEDATAITEM
	    //
        hRc = GetScopeData( &pScopeData );
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to get pScopeData. (hRc: %08X)"),
			    hRc);
            NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
        }
        else
        {
            //
	        // This will force MMC to redraw the scope node
	        //
            spConsole = m_pComponentData->m_spConsole;
            ATLASSERT(spConsole);
	        
            hRc = spConsole->SelectScopeItem( pScopeData->ID );
            if (FAILED(hRc))
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to select scope Item. (hRc: %08X)"),
			        hRc);
                NodeMsgBox(IDS_FAIL2UPDATE_SRVSTATUS_TOOLBAR);
            }
        }
    }

    return (bRet ?  S_OK : E_FAIL);
}


/*
 -  CFaxServerNode::OnLaunchClientConsole
 -
 *  Purpose:
 *      To launch client console.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT  CFaxServerNode::OnLaunchClientConsole(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::OnLaunchClientConsole"));
    DWORD	    dwRes  = ERROR_SUCCESS;
    HINSTANCE   hClientConsole; 
    UINT        idsRet;
    //
    // (-1) GetServerName
    //
    CComBSTR bstrServerName = L"";
    
    bstrServerName = GetServerName();
    if (!bstrServerName)
    {
         DebugPrintEx(
			DEBUG_ERR,
			_T("Launch client console failed due to failure during GetServerName."));
        
        NodeMsgBox(IDS_MEMORY);

        bstrServerName = L"";

        return E_FAIL;
    }
    
    //
    // start cover page editor
    //
    hClientConsole = ShellExecute(   NULL, 
                                 TEXT("open"),  // Command 
                                 FAX_CLIENT_CONSOLE_IMAGE_NAME,   
                                 bstrServerName, 
                                 NULL, 
                                 SW_RESTORE 
                              );
    if( (DWORD_PTR)hClientConsole <= 32 )
    {
        // ShellExecute fail
        dwRes = PtrToUlong(hClientConsole);
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to run ShellExecute. (ec : %ld)"), dwRes);
        
        ATLASSERT(dwRes >= 0);
        
        //
        // Select message to user
        //
        switch (dwRes)
        {
            case 0:                     //The operating system is out of memory or resources. 
            case SE_ERR_OOM:            //There was not enough memory to complete the operation. 
                idsRet = IDS_MEMORY;
                break;

            case ERROR_FILE_NOT_FOUND:  //The specified file was not found. 
            case ERROR_PATH_NOT_FOUND:  //The specified path was not found. 
            case ERROR_BAD_FORMAT:      //The .exe file is invalid (non-Win32 .exe or error in .exe image). 
            //case SE_ERR_PNF: value '3' already used  //The specified path was not found. 
            //case SE_ERR_FNF: value '2' already used  //The specified file was not found.  
            case SE_ERR_ASSOCINCOMPLETE:  //The file name association is incomplete or invalid. 
                idsRet = IDS_FAXCONSOLE_NOTFOUND;
                break;

            case SE_ERR_ACCESSDENIED:   //The operating system denied access to the specified file.  
                idsRet = IDS_FAXCONSOLE_ACCESSDENIED;
                break;

            case SE_ERR_DLLNOTFOUND:    //The specified dynamic-link library was not found.  
            case SE_ERR_SHARE:          //A sharing violation occurred.
            default:
                idsRet = IDS_FAIL2LAUNCH_FAXCONSOLE_GEN;
                break;
        }
        NodeMsgBox(idsRet);

        goto Exit;
    }
        
    ATLASSERT( ERROR_SUCCESS == dwRes);

Exit:
    return HRESULT_FROM_WIN32( dwRes );
}


/*
 -  CFaxServerNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_FAXSERVERNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 -  CFaxServerNode::SetServerNameOnSnapinAddition()
 -
 *  Purpose:
 *      Set server name and init the related node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::SetServerNameOnSnapinAddition(BSTR bstrServerName, BOOL fAllowOverrideServerName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::SetServerNameOnSnapinAddition"));
    HRESULT hRc = S_OK;

    hRc = UpdateServerName(bstrServerName);
    if (S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to UpdateServerName - out of memory"));
        
        goto Exit;
    }

    hRc = 	InitDetailedDisplayName();
    if ( S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitDetailedDisplayName. (hRc: %08X)"),
			hRc);
    
        goto Exit;
    }
    ATLASSERT (S_OK == hRc);

    //
    // Update override status
    //
    m_fAllowOverrideServerName = fAllowOverrideServerName;

Exit:
    return hRc;
}


/*
 -  CFaxServerNode::ForceRedrawNode
 -
 *  Purpose:
 *      To show the new node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::ForceRedrawNode()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::ForceRedrawNode"));


    HRESULT hRc = S_OK;
    
    //
    // Get IConsoleNameSpace
    //
    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    CComPtr<IConsole> spConsole;
    spConsole = m_pComponentData->m_spConsole;
	CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( spConsole );

	//
	// Get the updated SCOPEDATAITEM
	//
    SCOPEDATAITEM*    pScopeData;

	hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        goto Error;
    }
	
    //
    // Update (*pScopeData).displayname
    //
	(*pScopeData).displayname = m_bstrDisplayName;

    //
	// Force MMC to redraw the scope node
	//
	hRc = spNamespace->SetItem( pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to set Item pScopeData. (hRc: %08X)"),
			hRc);
        goto Error;
    }
        
    ATLASSERT(S_OK == hRc);
    goto Exit;


Error:
 	
    NodeMsgBox(IDS_FAIL2RENAME_NODE);
  
Exit:
    return hRc;

}



/*
 -  CFaxServerNode::UpdateServerName
 -
 *  Purpose:
 *      Update the server name for fax Server node and CFaxServer.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::UpdateServerName(BSTR bstrServerName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateServerName"));
    HRESULT hRc = S_OK;

    ATLASSERT(GetFaxServer());
    hRc = GetFaxServer()->SetServerName(bstrServerName);
    if ( S_OK != hRc)
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed Update FaxServer with the server name. (hRc: %08X)"),
			hRc);
    
        NodeMsgBox(IDS_MEMORY);

    }

    return hRc;
}



/*
 -  CFaxServerNode::InitDetailedDisplayName()
 -
 *  Purpose:
 *      Load the node's Displaed-Name string with the server name.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxServerNode::InitDetailedDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::InitDetailedDisplayName"));

    HRESULT hRc = S_OK;

    CComBSTR bstrServerName;
    CComBSTR bstrLeftBracket;
    CComBSTR bstrRightBracket;
    CComBSTR bstrLocal;


    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_FAXSERVERNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
        
    //
    // Retreive the server name
    //    
    bstrServerName = GetServerName();
    if (!bstrServerName)
    {
         DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get the server name."));
        
        NodeMsgBox(IDS_MEMORY);

        bstrServerName = L"";

        hRc = E_OUTOFMEMORY;
        goto Error;
    }


    
    //
    // Appends the sever name
    //

    if (!bstrLeftBracket.LoadString(_Module.GetResourceInstance(), 
                        IDS_LEFTBRACKET_PLUSSPACE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    if (!bstrRightBracket.LoadString(_Module.GetResourceInstance(), 
                        IDS_RIGHTBRACKET))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    if (!bstrLocal.LoadString(_Module.GetResourceInstance(), 
                        IDS_LOCAL_PLUSBRACKET_PLUSSPACE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    

    if ( 0 == bstrServerName.Length() ) //if equals L""
    {
        m_bstrDisplayName += bstrLocal;   
    }
    else
    {
        m_bstrDisplayName += bstrLeftBracket;   
        m_bstrDisplayName += bstrServerName;   
        m_bstrDisplayName += bstrRightBracket;   
    }
    
    ATLASSERT( S_OK == hRc);

    //
    // Setting this flag to allow pre connection check
    // during first FaxServerNode expand.
    //
    m_IsPrimaryModeSnapin = TRUE;


    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);


    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

const CComBSTR&  CFaxServerNode::GetServerName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxServerNode::GetServerName"));

    ATLASSERT(GetFaxServer());
    return  GetFaxServer()->GetServerName();
}

    
/*
 +
 +  CFaxServerNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxServerNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{ 
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_INTRO);
}


/////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\generalnotifywnd.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : GeneralNotifyWnd.h                                      //
//                                                                         //
//  DESCRIPTION   : Header file of fax Device notification window.         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Aug  3 2000 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 2000  Microsoft Corporation   All Rights Reserved        //
/////////////////////////////////////////////////////////////////////////////

#ifndef _H_FAX_DEVICE_NOTIFY_WND_H_
#define _H_FAX_DEVICE_NOTIFY_WND_H_

#include <atlwin.h>

const int WM_GENERAL_EVENT_NOTIFICATION = WM_USER + 3; 

class CFaxDevicesNode;
class CFaxServer;

class CFaxGeneralNotifyWnd : public CWindowImpl<CFaxGeneralNotifyWnd> 
{

public:
    //
    // Constructor
    //
    CFaxGeneralNotifyWnd(CFaxServer * pParent)
    {
        m_pFaxServer = pParent;
    }

    //
    // Destructor
    //
    ~CFaxGeneralNotifyWnd()
    {
    }
 
    BEGIN_MSG_MAP(CFaxGeneralNotifyWnd)
       MESSAGE_HANDLER(WM_GENERAL_EVENT_NOTIFICATION,OnServerEvent)
    END_MSG_MAP()

    LRESULT OnServerEvent( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

private:
    CFaxServer * m_pFaxServer;
};

#endif // _H_FAX_DEVICE_NOTIFY_WND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\hlpres.h ===
// Help ID include file.
// Used by MsFxsSnp.rc
//

#ifndef ADMIN_HELP_ID_H
#define ADMIN_HELP_ID_H

//
// IDD_FAXSERVER_RECEIPTS
//
#define HIDC_RECEIPT_ENABLE_SMTP_CHECK      0x80ef03ec           
#define HIDC_RECEIPT_ENABLE_MSGBOX_CHECK    0x80ef03f3           
#define HIDC_ADDRESS_EDIT                   0x80e10483           
#define HIDC_PORT_EDIT                      0x80e10453           
#define HIDC_SMTP_EDIT                      0x80e1043a           
#define HIDC_SMTP_AUTHEN_BUTTON             0x80e103f3    
#define HIDC_SMTP_ROUTE_CHECK               0x80e1047a

//
// IDD_DLG_SMTP_SET
//
#define HIDC_SMTP_ANONIM_RADIO1             0x80e103ec
#define HIDC_SMTP_BASIC_RADIO2              0x80e1050d           
#define HIDC_SMTP_CREDENTIALS_BASIC_BUTTON  0x80e10500    
#define HIDC_SMTP_NTLM_RADIO3               0x80e1050e           
#define HIDC_SMTP_CREDENTIALS_NTLM_BUTTON   0x80e10501    

//
// IDD_CONFIRM_PASSWORD
//
#define HIDC_SMTP_USERNAME_EDIT         0x80e10446           
#define HIDC_SMTP_PASSWORD_EDIT         0x80e1044b           

//
// IDD_FAXSERVER_INBOX_ARCHIVE
//
#define HIDC_TO_ARCHIVE_CHECK           0x80e504de           
#define HIDC_AUTODEL_CHECK              0x80e504d6           
#define HIDC_AUTODEL_EDIT               0x80e50432           
#define HIDC_HIGH_EDIT                  0x80e50430           
#define HIDC_GENERATE_WARNING_CHECK     0x80e50416           
#define HIDC_LOW_EDIT                   0x80e504dc           
#define HIDC_INBOX_BROWSE_BUTTON        0x80e50516           
#define HIDC_INBOX_FOLDER_EDIT          0x80e5051f           

//
// IDD_FAXSERVER_OUTBOX
//
#define HIDC_ALLOW_PERSONAL_CHECK       0x80e404d1           
#define HIDC_BRANDING_CHECK             0x80e404e8           
#define HIDC_DAYS_EDIT                  0x80e40431           
#define HIDC_DELETE_CHECK               0x80e40415           
#define HIDC_RETRYDELAY_EDIT            0x80e40428           
#define HIDC_RETRIES_EDIT               0x80e40426           
#define HIDC_TSID_CHECK                 0x80e404ce           
#define HIDC_DISCOUNT_START_TIME        0x80e40521    
#define HIDC_DISCOUNT_STOP_TIME         0x80e40522    

//
// IDD_FAXOUTRULE_GENERAL
//
#define HIDC_AREA_RADIO1                0x806a03f1           
#define HIDC_COUNTRY_RADIO1             0x806a03eb           
#define HIDC_DESTINATION_RADIO21        0x806a03f9           
#define HIDC_DEVICES4RULE_COMBO1        0x806a049f           
#define HIDC_GROUP4RULE_COMBO1          0x806a04a2           
#define HIDC_RULE_AREACODE_EDIT1        0x806a0506           
#define HIDC_DESTINATION_RADIO11        0x806a03f6           
#define HIDC_RULE_COUNTRYCODE_EDIT1     0x806a049b        
#define HIDC_RULE_SELECT_BUTTON1        0x806a0499        

//
// IDD_FAXDEVICE_GENERAL
//
#define HIDC_DEVICE_CSID_EDIT           0x80d6044d             
#define HIDC_DEVICE_TSID_EDIT           0x80d60447             
#define HIDC_DEVICE_RINGS_EDIT          0x80d604eb             
#define HIDC_RECEIVE_CHECK              0x80d6040d             
#define HIDC_RECEIVE_MANUAL_RADIO2      0x80d6040a             
#define HIDC_RECEIVE_AUTO_RADIO1        0x80d6040b             
#define HIDC_SEND_CHECK                 0x80d6047b             
#define HIDC_DEVICE_DESCRIPTION_EDIT    0x80d6043d             

//
// IDD_FAXPROVIDER_GENERAL
//
#define HIDC_FSPVPATH_EDIT              0x80eb044e           
#define HIDC_FSPSTATUS_EDIT             0x80eb0448           
#define HIDC_FSPVERSION_EDIT            0x80eb0440           

//
// IDD_FAXSERVER_LOGGING
//
#define HIDC_INCOMING_LOG_CHECK         0x80e204bf            
#define HIDC_LOG_BROWSE_BUTTON          0x80e20517            
#define HIDC_LOG_FILE_EDIT              0x80e2043c            
#define HIDC_OUTGOING_LOG_CHECK         0x80e204c0            

//
// IDD_FAXSERVER_SENTITEMS
//
#define HIDC_SENT_AUTODEL_CHECK         0x80e6051e            
#define HIDC_SENT_AUTODEL_EDIT          0x80e6051c            
#define HIDC_SENT_BROWSE_BUTTON         0x80e604c2            
#define HIDC_FOLDER_EDIT                0x80e604d4            
#define HIDC_SENT_GENERATE_WARNING_CHECK 0x80e60457            
#define HIDC_SENT_HIGH_EDIT             0x80e6051b            
#define HIDC_SENT_LOW_EDIT              0x80e6051a            
#define HIDC_SENT_TO_ARCHIVE_CHECK      0x80e60456            

//
// IDD_FAXSERVER_EVENTS
//
#define HIDC_GENERAL_STATIC             0x80e304ca            
#define HIDC_INBOUND_STATIC             0x80e304c7            
#define HIDC_INIT_STATIC                0x80e304c9            
#define HIDC_OUTBAND_STATIC             0x80e304c8            

//
// IDD_FAXSERVER_GENERAL
//
#define HIDC_VERSION_DTEXT              0x80e004b4                  
#define HIDC_INCOM_INPROC_ROEDIT        0x80e0044f                  
#define HIDC_OUTGOING_INPROC_ROEDIT     0x80e00449                  
#define HIDC_QUED_ROEDIT                0x80e00441                  
#define HIDC_RECEPTION_CHECK            0x80e00514                  
#define HIDC_SUBMISSION_CHECK           0x80e00512                  
#define HIDC_TRANSSMI_CHECK             0x80e00513                  

//
// IDD_FAXCATALOGMETHOD_GENERAL
//
#define HIDC_EXTENSION_DLL_EDIT         0x80ea043f                 

//
// IDD_FAXINMETHOD_GENERAL
//
#define HIDC_INMETHOD_EXT_H_STATIC      0x80e804f8             
#define HIDC_INMETHOD_STATUS_H_STATIC   0x80e804f7             
#define HIDC_INMETOD_NAME_H_STATIC      0x80e804f6             

//
// IDD_DLGNEWDEVICE
//
#define HIDC_DEVICE_LISTVIEW            0x80dd0504             

//
// IDD_DLGNEWGROUP
//
#define HIDC_GROUPNAME_EDIT             0x80d50501             

//
// IDD_DLGNEWRULE
//
#define HIDC_AREA_RADIO                 0x80e903f0             
#define HIDC_COUNTRY_RADIO              0x80e903ea             
#define HIDC_DESTINATION_RADIO1         0x80e903f5             
#define HIDC_DESTINATION_RADIO2         0x80e903f8             
#define HIDC_DEVICES4RULE_COMBO         0x80e9049e             
#define HIDC_GROUP4RULE_COMBO           0x80e904a1             
#define HIDC_RULE_AREACODE_EDIT         0x80e904d1        
#define HIDC_NEWRULE_COUNTRYCODE_EDIT   0x80e904d3        
#define HIDC_NEWRULE_SELECT_BUTTON      0x80e904d5        

//
// SELECT COUNTRY OR REGION
//
#define HIDC_COUNTRYRULE_COMBO          0x80e9049a   


#define HIDC_OK                         0x80d90001    
#define HIDC_CANCEL                     0x80d90002
          
//
// T30 extension
//
#define HIDC_ADAPTIVE_ANSWERING         0x80d90011

//
// Inbound routing extension
//
#define HIDC_IN_ROUTE_FOLDER            0x80d90021
#define HIDC_IN_ROUTE_PRINT             0x80d90022
#define HIDC_IN_ROUTE_MAILTO            0x80d90023
#define HIDC_IN_ROUTE_FOLDER_BROWSE     0x80d90024

#endif // ADMIN_HELP_ID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\helper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Helper.cpp                                             //
//                                                                         //
//  DESCRIPTION   : Some helper functions.                                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   move to Fax                                         //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

int
DlgMsgBox(CWindow *pWin, int ids, UINT nType/*=MB_OK*/)
{
    CComBSTR    bstrTitle;
    WCHAR       szText[256];
    int         rc;

    //
    // Load the string
    //
    rc = ::LoadString(_Module.GetResourceInstance(), ids, szText, 256);
    if (rc <= 0)
    {
        return E_FAIL;
    }

    //
    // Get the window text, to be set as the message box title
    //
    pWin->GetWindowText(bstrTitle.m_str);

    //
    // Show the message box
    //
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }

    rc = pWin->MessageBox(szText, bstrTitle, nType);

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\helper.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Helper.h                                               //
//                                                                         //
//  DESCRIPTION   : Prototype of some helper functions.                    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jun  2 1999 yossg    add     CHECK_RETURN_VALUE_AND_PRINT_DEBUG    //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_HELPER_H
#define H_HELPER_H

int DlgMsgBox(CWindow *pWin, int ids, UINT nType = MB_OK);

// required:
//  * to be called after decleration of    
//         DEBUG_FUNCTION_NAME( _T("CClass::FuncName"));
//  * hRc the Name of HRESULT
//  * _str - string for DPF = _T("CClass::FuncName")
//  * exit point will be called -- Cleanup:
//   

#define CHECK_RETURN_VALUE_AND_PRINT_DEBUG(_str)           \
{                                                          \
    if (FAILED (hRc))                                      \
    {                                                      \
        DebugPrintEx(DEBUG_ERR,_str, hRc);                 \
        goto Cleanup;                                      \
    }                                                      \
}

#define CHECK_RETURN_VALUE_AND_SEND_NODE_MSGBOX(_ids)      \
{                                                          \
    if (FAILED (hRc))                                      \
    {                                                      \
        NodeMsgBox(_ids);                                  \
        goto Cleanup;                                      \
    }                                                      \
}

#define CHECK_RET_CLEAN if (FAILED(ret)) goto Cleanup;
#define CHECK_HRC_CLEAN if (FAILED(hRc)) goto Cleanup;

#endif  //H_HELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\inboundrouting.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRouting.cpp                                     //
//                                                                         //
//  DESCRIPTION   : Fax Server - Fax InboundRouting node.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Jan 31 2000 yossg  Add full suport to method catalog               //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "InboundRouting.h"

#include "CatalogInboundRoutingMethods.h" 

#include "Icons.h"

//#include "oaidl.h"

/****************************************************

CFaxInboundRoutingNode Class

 ****************************************************/

// {7362F15F-30B2-46a4-A8CB-C1DD29F0B1BB}
static const GUID CFaxInboundRoutingNodeGUID_NODETYPE = 
{ 0x7362f15f, 0x30b2, 0x46a4, { 0xa8, 0xcb, 0xc1, 0xdd, 0x29, 0xf0, 0xb1, 0xbb } };

const GUID*    CFaxInboundRoutingNode::m_NODETYPE = &CFaxInboundRoutingNodeGUID_NODETYPE;
const OLECHAR* CFaxInboundRoutingNode::m_SZNODETYPE = OLESTR("7362F15F-30B2-46a4-A8CB-C1DD29F0B1BB");
const CLSID*   CFaxInboundRoutingNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxInboundRoutingNode::m_ColsInfo;

/*
 -  CFaxInboundRoutingNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxInboundRoutingNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, 200}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC. (hRc: %08X)"), hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxInboundRoutingNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Meesages nodes:
 *      Inbox, Outbox, Sent Items, Deleted Items.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingNode::PopulateScopeChildrenList"));
    HRESULT             hRc = S_OK;

    
    CFaxCatalogInboundRoutingMethodsNode *  pMethods   = NULL;


    //
    // Fax Inbound routing method catalog
    //
    pMethods = new CFaxCatalogInboundRoutingMethodsNode(this, m_pComponentData);
    if (!pMethods)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pMethods->InitParentNode(this);

        pMethods->SetIcons(IMAGE_METHOD_ENABLE, IMAGE_METHOD_ENABLE);

        hRc = pMethods->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
		    goto Error;
        }

        hRc = AddChild(pMethods, &pMethods->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add outbound routing rules node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethods ) 
    {
        if (0 != pMethods->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pMethods);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Methods node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pMethods;    
        pMethods = NULL;    
    }

    // Empty the list
    // m_ScopeChildrenList.RemoveAll(); done from RemoveChild

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}


/*
 -  CFaxInboundRoutingNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxInboundRoutingNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}


/*
 -  CFaxInboundRoutingNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxInboundRoutingNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    HRESULT hRc = S_OK;
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingNode::OnRefresh"));

    ATLTRACE(_T("CFaxInboundRoutingNode::OnRefresh"));

    //
    // Call the base class
    //
    hRc = CBaseFaxInboundRoutingNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("CBaseFaxInboundRoutingNode::OnRefresh"))

Cleanup:
    return hRc;
}

/*
 -  CFaxInboundRoutingNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxInboundRoutingNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                                IDS_DISPLAY_STR_INBOUNDROUTINGNODE) )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load inbound routing node name-string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}


/*
 +
 +  CFaxInboundRoutingNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxInboundRoutingNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_MAN_INCOM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\icons.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : Icons.h                                                //
//                                                                         //
//  DESCRIPTION   : Enumrate all COMET icons                               //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//	Dec 14 1999 yossg  arrange.				                               //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef ICONS_H_INCLUDED
#define ICONS_H_INCLUDED

enum FAX_SERVER_ICONS
{
    IMAGE_FOLDER_CLOSE,
    IMAGE_FOLDER_OPEN,
    IMAGE_FAX,
    IMAGE_METHOD_ENABLE,
    IMAGE_METHOD_DISABLE,
    IMAGE_RULE,
    IMAGE_DEVICE,
    IMAGE_RULE_ERROR,
    IMAGE_RULE_WARNING,
    IMAGE_GROUP_ERROR_CLOSE,
    IMAGE_GROUP_ERROR_OPEN,
    IMAGE_GROUP_WARN_CLOSE,
    IMAGE_GROUP_WARN_OPEN,
    IMAGE_FSP,
    IMAGE_FSP_ERROR,
    IMAGE_FAX_COVERPAGES,
    IMAGE_SRV_COVERPAGE,
    IMAGE_DEVICE_ERROR,
    IMAGE_DEVICE_POWERED_OFF,
    IMAGE_LAST  //must be and must be last
};

#endif // ! ICONS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\inboundroutingmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethod.h                                 //
//                                                                         //
//  DESCRIPTION   : Header file for the InboundRoutingMethod node class.   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 01 1999 yossg  Create                                          //
//      Dec 14 1999 yossg  add basic functionality, menu, changable icon   //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXINBOUNDROUTINGMETHOD_H
#define H_FAXINBOUNDROUTINGMETHOD_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

#include "ppFaxInboundRoutingMethodGeneral.h"

class CppFaxInboundRoutingMethod;
class CFaxInboundRoutingMethodsNode;

class CFaxInboundRoutingMethodNode : public CSnapinNode <CFaxInboundRoutingMethodNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxInboundRoutingMethodNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_FAX_INMETHOD_ENABLE,   OnMethodEnabled)
        SNAPINCOMMAND_ENTRY(IDM_FAX_INMETHOD_DISABLE,  OnMethodEnabled)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxInboundRoutingMethodNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_INMETHOD_MENU)

    //
    // Constructor
    //
    CFaxInboundRoutingMethodNode (CSnapInItem * pParentNode, CSnapin * pComponentData, PFAX_ROUTING_METHOD pMethodConfig) :
        CSnapinNode<CFaxInboundRoutingMethodNode, FALSE>(pParentNode, pComponentData )
    {
    }

    //
    // Destructor
    //
    ~CFaxInboundRoutingMethodNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxInboundRoutingMethodsNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    CComBSTR   GetName()           { return m_bstrFriendlyName; }
    BOOL       GetStatus()         { return m_fEnabled; }
    CComBSTR   GetExtensionName()  { return m_bstrExtensionFriendlyName; }

    HRESULT    Init(PFAX_ROUTING_METHOD pMethodConfig);
    void       UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    //
    // FillData
    //
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);

    //
    // Clipboard Formats
    //
    static CLIPFORMAT m_CFExtensionName;
    static CLIPFORMAT m_CFMethodGuid;
    static CLIPFORMAT m_CFServerName;
    static CLIPFORMAT m_CFDeviceId;


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxInboundRoutingMethodsNode * m_pParentNode;

    //
    // Property Pages
    //
    CppFaxInboundRoutingMethod *    m_pInboundRoutingMethodGeneral;

    //
    // members
    //
    CComBSTR  m_bstrFriendlyName;       //pointer to method's user-friendly name
    CComBSTR  m_bstrExtensionFriendlyName; //pointer to DLL's user-friendly name
    DWORD     m_dwDeviceID;             //line identifier of the device
    BOOL      m_fEnabled;               //fax routing method enable/disable flag
    CComBSTR  m_bstrMethodGUID;         //GUID that uniquely identifies 
    CComBSTR  m_bstrExtensionImageName; //pointer to DLL that implements method
    // currently not in use

    //CComBSTR  m_bstrDeviceName;         //pointer to device name
    //CComBSTR  m_bstrFunctionName;       //pointer to method's function name
    
    //DWORD     m_dwSizeOfStruct;         //structure size, in bytes
            
    CComBSTR  m_buf; 

    //
    // Menu item handlers
    //
    HRESULT OnMethodEnabled (bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT ChangeEnable    (BOOL fState);

    //
    //  Init
    //
    HRESULT  InitMembers (PFAX_ROUTING_METHOD pMethodConfig);
    
};

//typedef CSnapinNode<CFaxInboundRoutingMethodNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXINBOUNDROUTINGMETHOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\inboundroutingmethods.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethods.h                                //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Inbound Routing Methods Node   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec  1 1999 yossg   Create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXINBOUNDROUTINGMETHODS_H
#define H_FAXINBOUNDROUTINGMETHODS_H

#include "snapin.h"
#include "snpnres.h"


#include "InboundRoutingMethod.h"
 
class CFaxDeviceNode;
class CFaxInboundRoutingMethodNode;

class CFaxInboundRoutingMethodsNode : public CNodeWithResultChildrenList<
                                        CFaxInboundRoutingMethodsNode,    
                                        CFaxInboundRoutingMethodNode, 
                                        CSimpleArray<CFaxInboundRoutingMethodNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxInboundRoutingMethodsNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxInboundRoutingMethodsNode)
    END_SNAPINTOOLBARID_MAP()
    //
    // Constructor
    //
    CFaxInboundRoutingMethodsNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxInboundRoutingMethodsNode, CFaxInboundRoutingMethodNode, CSimpleArray<CFaxInboundRoutingMethodNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_pFaxInboundMethodsConfig  = NULL;

        m_dwNumOfInboundMethods     = 0;
        
    }

    //
    // Destructor
    //
    ~CFaxInboundRoutingMethodsNode()
    {
        if (NULL != m_pFaxInboundMethodsConfig) 
        {
            FaxFreeBuffer(m_pFaxInboundMethodsConfig);
        }

    }

	//
	// get data from RPC 
	//
    HRESULT InitRPC();

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void InitParentNode(CFaxDeviceNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitDisplayName();


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo         m_ColsInfo;
    
    PFAX_ROUTING_METHOD         m_pFaxInboundMethodsConfig;
    DWORD                       m_dwNumOfInboundMethods;
   
    CFaxDeviceNode *            m_pParentNode;
};

typedef CNodeWithResultChildrenList<CFaxInboundRoutingMethodsNode, CFaxInboundRoutingMethodNode, CSimpleArray<CFaxInboundRoutingMethodNode*>, FALSE>
        CBaseFaxInboundRoutingMethodsNode;

#endif  //H_FAXINBOUNDROUTINGMETHODS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\inboundrouting.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRouting.h                                       //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxInboundRoutingNode class           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXINBOUNDROUTINGNODE_H
#define H_FAXINBOUNDROUTINGNODE_H


#include "snapin.h"
//#include "snpnode.h"
#include "snpnscp.h"


class CFaxServerNode;

class CFaxInboundRoutingNode : public CNodeWithScopeChildrenList<CFaxInboundRoutingNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxInboundRoutingNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxInboundRoutingNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    CFaxInboundRoutingNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxInboundRoutingNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxInboundRoutingNode()
    {
    }

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    
    static CColumnsInfo m_ColsInfo;

    CFaxServerNode                 * m_pParentNode;
};

typedef CNodeWithScopeChildrenList<CFaxInboundRoutingNode, FALSE>
        CBaseFaxInboundRoutingNode;


#endif  //H_FAXINBOUNDROUTINGNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\inboundroutingmethod.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethod.cpp                              //
//                                                                         //
//  DESCRIPTION   : Implementation of the Inbound Routing Method node.    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec  1 1999 yossg   Created                                        //
//      Dec 14 1999 yossg  add basic functionality                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "InboundRoutingMethod.h"
#include "InboundRoutingMethods.h"

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"
#include "faxmmc.h"

/////////////////////////////////////////////////////////////////////////////
// {220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}
static const GUID CFaxInboundRoutingMethodNodeGUID_NODETYPE = FAXSRV_ROUTING_METHOD_NODETYPE_GUID;

const GUID*     CFaxInboundRoutingMethodNode::m_NODETYPE        = &CFaxInboundRoutingMethodNodeGUID_NODETYPE;
const OLECHAR*  CFaxInboundRoutingMethodNode::m_SZNODETYPE      = FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR;
//const OLECHAR* CnotImplemented::m_SZDISPLAY_NAME = OLESTR("Inbound Routing Methods");
const CLSID*    CFaxInboundRoutingMethodNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;

CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFExtensionName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTEEXT_NAME);
CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFMethodGuid = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_ROUTING_METHOD_GUID);
CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFServerName = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_SERVER_NAME);
CLIPFORMAT CFaxInboundRoutingMethodNode::m_CFDeviceId = 
        (CLIPFORMAT)RegisterClipboardFormat(CF_MSFAXSRV_DEVICE_ID);

/*
 -  CFaxInboundRoutingMethodNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_ROUTING_METHOD
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::Init(PFAX_ROUTING_METHOD pMethodConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);

    hRc = InitMembers( pMethodConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    
    //
    // Icon
    //
    m_resultDataItem.nImage = (m_fEnabled ? IMAGE_METHOD_ENABLE : IMAGE_METHOD_DISABLE );

Exit:
    return hRc;
}

/*
 -  CFaxInboundRoutingMethodNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pMethodConfig - PFAX_ROUTING_METHOD structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::InitMembers(PFAX_ROUTING_METHOD pMethodConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pMethodConfig);
    
    m_dwDeviceID         = pMethodConfig->DeviceId;
    
    m_fEnabled           = pMethodConfig->Enabled;

    m_bstrDisplayName    = pMethodConfig->FriendlyName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrFriendlyName   = pMethodConfig->FriendlyName;
    if (!m_bstrFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrMethodGUID     = pMethodConfig->Guid;
    if (!m_bstrMethodGUID)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrExtensionFriendlyName   
                         = pMethodConfig->ExtensionFriendlyName;
    if (!m_bstrExtensionFriendlyName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_bstrExtensionImageName   
                         = pMethodConfig->ExtensionImageName;
    if (!m_bstrExtensionImageName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxInboundRoutingMethodNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxInboundRoutingMethodNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    UINT uiResourceId;

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrFriendlyName);
            }

    case 1:
            //
            // Enabled
            //
           uiResourceId = (m_fEnabled ? IDS_FXS_YES : IDS_FXS_NO);
                        
           if (!m_buf.LoadString(_Module.GetResourceInstance(), uiResourceId) )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to load string for the method enabled value."));

                goto Error;
            }
            else
            {
                return (m_buf);
            }
    case 2:
            //
            // Extension 
            //
            if (!m_bstrExtensionFriendlyName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrExtensionFriendlyName."));
                goto Error;
            }
            else
            {
                return (m_bstrExtensionFriendlyName);
            }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxInboundRoutingMethodNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxInboundRoutingMethodNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;


    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    //
    // Initiate
    //
    m_pInboundRoutingMethodGeneral = NULL;    

    //
    // General
    //
    m_pInboundRoutingMethodGeneral = new CppFaxInboundRoutingMethod(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

	if (!m_pInboundRoutingMethodGeneral)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
	
    /*  
     * not exists : m_pPP..->InitRPC();	
     */


    hRc = lpProvider->AddPage(m_pInboundRoutingMethodGeneral->Create());
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pInboundRoutingMethodGeneral ) 
    {
        delete  m_pInboundRoutingMethodGeneral;    
        m_pInboundRoutingMethodGeneral = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxInboundRoutingMethodNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxInboundRoutingMethodNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
 -  CFaxInboundRoutingMethodNode::OnMethodEnabled
 -
 *  Purpose:
 *      Called when Enable /Disable menu was pushed.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::OnMethodEnabled (bool &bHandled, CSnapInObjectRootBase *pRoot)
{ 
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::OnMethodEnabled"));
    HRESULT hRc = S_OK;
    
    BOOL fNewState;
    
    fNewState = !m_fEnabled;

    hRc = ChangeEnable( fNewState);
    if ( S_OK != hRc )
    {
            //DebugPrint in the function layer
            return S_FALSE;
    }

    //
    // Service succeded. now change member
    //
    m_fEnabled = fNewState;

    //
    // Refresh the result pane view 
    //
    m_resultDataItem.nImage = (m_fEnabled ? IMAGE_METHOD_ENABLE : IMAGE_METHOD_DISABLE );
    
    hRc = RefreshSingleResultItem(pRoot);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to RefreshSingleResultItem. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TOREFRESH_INMETHOD_NODE);        
    }

    return hRc; 
}

/*
 -  CFaxInboundRoutingMethodNode::ChangeEnable
 -
 *  Purpose:
 *      .
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodNode::ChangeEnable(BOOL fState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::ChangeEnable"));
    	
    HRESULT              hRc            = S_OK;

    DWORD                ec             = ERROR_SUCCESS;

    CFaxServer *         pFaxServer     = NULL;
    HANDLE               hFaxPortHandle = NULL;
    
    //
    // Get RPC Handle
    //
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    
    //
    // Get Fax Device Handle
    //
    
    ATLASSERT(m_pParentNode);
    // only a valid handle with PORT_OPEN_MODIFY accepted here!
    if (!FaxOpenPort( pFaxServer->GetFaxServerHandle(), 
                        m_dwDeviceID, 
                        PORT_OPEN_MODIFY | PORT_OPEN_QUERY, 
                        &hFaxPortHandle )) 
    {         
        ec = GetLastError();
        // if modification handle is currently shared
        // ec == ERROR_INVALID_HANDLE 
        if (ERROR_INVALID_HANDLE ==  ec)
        {
            //Special case of ERROR_INVALID_HANDLE
		    DebugPrintEx(DEBUG_ERR,
			    _T("FaxOpenPort() failed with ERROR_INVALID_HANDLE. (ec:%ld)"),
			    ec);
            
            NodeMsgBox(IDS_OPENPORT_INVALID_HANDLE);
            
            hRc = HRESULT_FROM_WIN32(ec);
            
            goto Exit;
        }
        
		DebugPrintEx(DEBUG_ERR,
			_T("FaxOpenPort() failed with. (ec:%ld)"),
			ec);
        
        goto Error;
    } 
    ATLASSERT(NULL != hFaxPortHandle);

    //
    // Set Enabled
    //
    if (!FaxEnableRoutingMethod(
                hFaxPortHandle,
                m_bstrMethodGUID,
                fState)) 
    {		
        ec = GetLastError();
        
        //
        // 1) Warning
        //
        if (ERROR_BAD_CONFIGURATION == ec && fState)
        {
            DebugPrintEx(
			    DEBUG_WRN,
			    _T("Cannot enable routing method. The method configuration has some invalid data.(ec: %ld)"), 
			    ec);

            hRc = HRESULT_FROM_WIN32(ec);
	        
            //
            // The routing method is not configured.
            // Suggest to configure it.
            //
            int nRes = IDNO;
            NodeMsgBox(IDS_FAIL2ENABLE_METHOD, MB_YESNO | MB_ICONEXCLAMATION, &nRes);
            if(IDYES == nRes)
            {
                InvokePropSheet(this, CCT_RESULT, reinterpret_cast<IUnknown*>(m_pComponentData), m_bstrFriendlyName, 1);
            }
                  
            goto Exit;
        }

        //
        // 2) Error
        //

        //
        // 	a) Network Error
        //
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
            
            goto Error;
        }
            
        //
        // 	b) General Error
        //
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to enable /disable routing method. (ec: %ld)"), 
			ec);

        NodeMsgBox(IDS_FAIL2ENABLE_METHOD_ERR);

        hRc = HRESULT_FROM_WIN32(ec);
            
        goto Exit;
        
    }
    ATLASSERT(ERROR_SUCCESS == ec);
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    //
    // Close Fax Port handle
    // 
    if (NULL != hFaxPortHandle)
    {
        if (!FaxClose( hFaxPortHandle ))
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() on port handle failed (ec: %ld)"),
                GetLastError());
		}
    }
    
    return hRc;
}

/*
 -  CFaxInboundRoutingMethodNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxInboundRoutingMethodNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);     
    
    switch (id)
    {
    case IDM_FAX_INMETHOD_ENABLE:
        *flags = (m_fEnabled ?  MF_GRAYED  : MF_ENABLED  );   
        break;
    case IDM_FAX_INMETHOD_DISABLE:
        *flags = (m_fEnabled ?  MF_ENABLED : MF_GRAYED   );
        break;
    default:
        break;
    }
    
    return;
}

/*
 +
 +
 *
 *  CFaxInboundRoutingMethodNode::FillData
 *
 *
 *   Override CSnapInItem::FillData for private cliboard formats
 *
 *
 *   Parameters
 *
 *   Return Values
 *
 -
 -
 */

HRESULT  CFaxInboundRoutingMethodNode::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodNode::FillData"));
	
    HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;


    if (cf == m_CFExtensionName)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrExtensionImageName, 
                            sizeof(WCHAR)*(m_bstrExtensionImageName.Length()+1), 
                            &uWritten);
		return hr;
	}
	if (cf == m_CFMethodGuid)
	{
		hr = pStream->Write((VOID *)(LPWSTR)m_bstrMethodGUID, 
                            sizeof(WCHAR)*(m_bstrMethodGUID.Length()+1), 
                            &uWritten);
		return hr;
	}

	if (cf == m_CFServerName)
	{
		CComBSTR bstrServerName = ((CFaxServerNode *)GetRootNode())->GetServerName();
		hr = pStream->Write((VOID *)(LPWSTR)bstrServerName, 
                            sizeof(WCHAR)*(bstrServerName.Length()+1), 
                            &uWritten);
		return hr;
	}

    if (cf == m_CFDeviceId)
	{
		hr = pStream->Write((VOID *)&m_dwDeviceID, sizeof(DWORD), &uWritten);
		return hr;
	}
    return CSnapInItemImpl<CFaxInboundRoutingMethodNode>::FillData(cf, pStream);
}   // CFaxInboundRoutingMethodNode::FillData

/*
 +
 +  CFaxInboundRoutingMethodNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxInboundRoutingMethodNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_INBOUND_ROUTING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\myctrls.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : MyCtrls.h                                              //
//                                                                         //
//  DESCRIPTION   : Expand the imlementation of AtlCtrls.h                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999  yossg    Init.                                        //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef H_MYCTRLS_H
#define H_MYCTRLS_H


class CMyUpDownCtrl:public CUpDownCtrl
{
public:

    //
    //My implementation of SetPos with range verification
    //
    int SetPos(int nPos);
};


#endif // H_MYCTRLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\inboundroutingmethods.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : InboundRoutingMethods.cpp                              //
//                                                                         //
//  DESCRIPTION   : Fax InboundRoutingMethods MMC node.                    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec  1 1999 yossg  Create                                          //
//      Dec 14 1999 yossg  add basic functionality                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "InboundRoutingMethods.h"
#include "Device.h"
#include "Devices.h"

#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {AA94A694-844B-4d3a-A82C-2FCBDE0FF430}
static const GUID CFaxInboundRoutingMethodsNodeGUID_NODETYPE = 
{ 0xaa94a694, 0x844b, 0x4d3a, { 0xa8, 0x2c, 0x2f, 0xcb, 0xde, 0xf, 0xf4, 0x30 } };

const GUID*    CFaxInboundRoutingMethodsNode::m_NODETYPE = &CFaxInboundRoutingMethodsNodeGUID_NODETYPE;
const OLECHAR* CFaxInboundRoutingMethodsNode::m_SZNODETYPE = OLESTR("AA94A694-844B-4d3a-A82C-2FCBDE0FF430");
const CLSID*   CFaxInboundRoutingMethodsNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxInboundRoutingMethodsNode::m_ColsInfo;

/*
 -  CFaxInboundRoutingMethodsNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxInboundRoutingMethodsNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_INBOUND_METHODS_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_INBOUND_METHODS_COL2, AUTO_WIDTH},
        {IDS_INBOUND_METHODS_COL3, FXS_LARGE_COLUMN_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxInboundRoutingMethodsNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodsNode::InitRPC(  )
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;
	HANDLE		 hFaxPortHandle = NULL;
    CFaxServer * pFaxServer = NULL;

    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    ATLASSERT(NULL != m_pParentNode);
    
    //
    // get Fax Device Handle
    //   
    
    //
    // only a PORT_OPEN_QUERY is needed to show the methods
    // the handle with PORT_OPEN_MODIFY priviledge will be 
    // given for limited short period for opertion required it.
    //

    if (!FaxOpenPort( pFaxServer->GetFaxServerHandle(), 
                        m_pParentNode->GetDeviceID(), 
                        PORT_OPEN_QUERY, 
                        &hFaxPortHandle )) 
    {
		ec = GetLastError();

        if (ERROR_INVALID_HANDLE ==  ec)
        {
            //Special case of ERROR_INVALID_HANDLE
		    DebugPrintEx(DEBUG_ERR,
			    _T("FaxOpenPort() failed with ERROR_INVALID_HANDLE. (ec:%ld)"),
			    ec);
            
            NodeMsgBox(IDS_OPENPORT_INVALID_HANDLE);
            
            goto Exit;
        }

		DebugPrintEx(
			DEBUG_ERR,
			TEXT("FaxOpenPort() failed. (ec:%ld)"),
			ec);
        goto Error;
    } 
    ATLASSERT(NULL != hFaxPortHandle);

    //
	// Retrieve the fax Inbound Methods configuration
	//
    if (!FaxEnumRoutingMethods(hFaxPortHandle, 
                        &m_pFaxInboundMethodsConfig,
                        &m_dwNumOfInboundMethods)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Inbound Methods configuration. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(m_pFaxInboundMethodsConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get Inbound Methods configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
Exit:

    //
    // Close Fax Port handle
    // 
    if (NULL != hFaxPortHandle)
    {
        if (!FaxClose( hFaxPortHandle ))
		{
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() on port handle failed (ec: %ld)"),
                GetLastError());
		}
    }

    return (hRc);
}


/*
 -  CFaxInboundRoutingMethodsNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodsNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::PopulateResultChildrenList"));
    HRESULT                          hRc = S_OK;

    CFaxInboundRoutingMethodNode *   pMethod;
    DWORD                            i;
    
    //
    // Get the Config. structure 
    //
    hRc = InitRPC();
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        m_pFaxInboundMethodsConfig = NULL;
        
        goto Exit; //!!!
    }
    ATLASSERT(NULL != m_pFaxInboundMethodsConfig);

    
    //
    //
    //
    for ( i = 0; i < m_dwNumOfInboundMethods; i++ )
    {
            pMethod = NULL;

            pMethod = new CFaxInboundRoutingMethodNode(this, 
                                            m_pComponentData, 
                                            &m_pFaxInboundMethodsConfig[i]);
            if (!pMethod)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pMethod->InitParentNode(this);

                pMethod->Init(&m_pFaxInboundMethodsConfig[i]);

	            hRc = this->AddChildToList(pMethod);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add Inbound Routing Method. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAILTOADD_INBOUNDROUTINGMETHODS);
                    goto Error;
	            }
                else
                {
                    pMethod = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pMethod ) 
    {
        delete  pMethod;    
        pMethod = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pMethod = (CFaxInboundRoutingMethodNode *)
                                    m_ResultChildrenList[j];
            delete pMethod;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    return hRc;
}



/*
 -  CFaxInboundRoutingMethodsNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxInboundRoutingMethodsNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

    return hRc;
}


/*
 -  CFaxInboundRoutingMethodsNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxInboundRoutingMethodsNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxInboundRoutingMethodsNode::OnRefresh"));
    HRESULT hRc = S_OK;

    //
    // Call the base class
    //
    hRc = CBaseFaxInboundRoutingMethodsNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(DEBUG_ERR, _T("Fail to call base class's OnRefresh. (hRc: %08X)"), hRc);
                
        CFaxDevicesNode *   pFaxDevices = NULL;
        
        ATLASSERT(m_pParentNode);
        pFaxDevices = m_pParentNode->GetParent();

        ATLASSERT(pFaxDevices);            
        hRc = pFaxDevices->DoRefresh();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR, _T("Fail to call parent node - Groups DoRefresh. (hRc: %08X)"), hRc);        
        }

        goto Exit;
    }


Exit:
    return hRc;
}


/*
 -  CFaxInboundRoutingMethodsNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxInboundRoutingMethodsNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}

/*
 -  CFaxInboundRoutingMethodsNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxInboundRoutingMethodsNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxInboundRoutingMethodsNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                        IDS_DISPLAY_STR_INROUTEMETHODSNODE))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 +
 +  CFaxInboundRoutingMethodsNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxInboundRoutingMethodsNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_INBOUND_ROUTING);
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\myctrls.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : MyCtrls.cpp                                            //
//                                                                         //
//  DESCRIPTION   : Expand the imlementation of AtlCtrls.h                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Nov 25 1999  yossg    Init.                                        //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "MyCtrls.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/*
 -  CMyUpDownCtrls::OnInitDialog
 -
 *  Purpose:
 *      Call SetPos with range verification.
 *
 *  Arguments:
 *
 *  Return:
 *      int
 */
int CMyUpDownCtrl::SetPos(int nPos)
{        
    int iMin;
    int iMax;
    
    ATLASSERT(::IsWindow(m_hWnd));
    GetRange32(iMin, iMax);        

    if (nPos > iMax)
    {
        nPos = iMax;
    }
    else if (nPos < iMin)
    {
        nPos = iMin;
    }

    return (CUpDownCtrl::SetPos(nPos));       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\msfxssnp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : MsFxsSnp.cpp                                           //
//                                                                         //
//  DESCRIPTION   : Implementation of DLL Exports.                         //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 27 1999 yossg   create                                         //
//      Nov  3 1999 yossg   add GlobalStringTable                          //   
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MsFxsSnpps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "MsFxsSnp.h"

#include "MsFxsSnp_i.c"
#include "Snapin.h"
#include <faxres.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Snapin, CSnapin)
	OBJECT_ENTRY(CLSID_SnapinAbout, CSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    DEBUG_FUNCTION_NAME( _T("MsFxsSnp.dll - DllMain"));
	DebugPrintEx(DEBUG_MSG, _T("MsFxsSnp.dll - DllMain, reason=%d"), dwReason );

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);

        _Module.m_hInstResource = GetResInstance(hInstance); 
        if(!_Module.m_hInstResource)
        {
            return FALSE;
        }

        CSnapInItem::Init();
        DisableThreadLibraryCalls(hInstance);
    }
	else if(dwReason == DLL_PROCESS_DETACH) 
    {
        _Module.Term();
        FreeResInstance();
        HeapCleanup();
    }
       
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}
 
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    //
    // registers object, typelib and all interfaces in typelib
    //
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    //
    // unregisters object, typelib and all interfaces in typelib
    //
	return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outbounddevice.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRoutingDevice.cpp                              //
//                                                                         //
//  DESCRIPTION   : Implementation of the Outbound Routing Device node.    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg  Create                                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "OutboundDevice.h"
#include "OutboundGroup.h" //parent

#include "FaxServer.h"
#include "FaxServerNode.h"


#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"

/////////////////////////////////////////////////////////////////////////////
// {2E8B6DD2-6E87-407e-AF70-ABC50A2671EF}
static const GUID CFaxOutboundRoutingDeviceNodeGUID_NODETYPE = 
{ 0x2e8b6dd2, 0x6e87, 0x407e, { 0xaf, 0x70, 0xab, 0xc5, 0xa, 0x26, 0x71, 0xef } };

const GUID*     CFaxOutboundRoutingDeviceNode::m_NODETYPE        = &CFaxOutboundRoutingDeviceNodeGUID_NODETYPE;
const OLECHAR*  CFaxOutboundRoutingDeviceNode::m_SZNODETYPE      = OLESTR("2E8B6DD2-6E87-407e-AF70-ABC50A2671EF");
//const OLECHAR* CFaxOutboundRoutingDeviceNode::m_SZDISPLAY_NAME = OLESTR("Device of Outbound Routing Group");
const CLSID*    CFaxOutboundRoutingDeviceNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;


/*
 -  CFaxOutboundRoutingDeviceNode::InitRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingDeviceNode::InitRPC( PFAX_PORT_INFO_EX * pFaxDeviceConfig )
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::InitRPC"));
    
    ATLASSERT(NULL == (*pFaxDeviceConfig) );
    
    HRESULT        hRc        = S_OK;
    DWORD          ec         = ERROR_SUCCESS;

    CFaxServer *   pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Retrieve the Device configuration
    //
    if (!FaxGetPortEx(pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &( *pFaxDeviceConfig))) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(*pFaxDeviceConfig);
    
	
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
    //Important!!!
    *pFaxDeviceConfig = NULL;

    if (ERROR_BAD_UNIT != ec)
	{
	    NodeMsgBox(GetFaxServerErrorMsg(ec));
	}
	else
	{
            NodeMsgBox(IDS_FAIL_TO_DISCOVERDEVICEFORGROUP);
	}
    
Exit:
    return (hRc);
}

/*
 -  CFaxOutboundRoutingDeviceNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    dwDeviceID - unique device ID
 *      [in]    uiOrd      - the device usage order
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
CFaxOutboundRoutingDeviceNode::InitMembers(
                            PFAX_PORT_INFO_EX * pDeviceConfig,
                            DWORD dwDeviceID, 
                            UINT  uiOrd,
                            UINT  uiMaxOrd)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pDeviceConfig);
    ATLASSERT(uiMaxOrd >= uiOrd);
    
    // done in calling function - to be safe (avoid later bug creation)
    m_dwDeviceID         = dwDeviceID;
    m_uiMaxOrder         = uiMaxOrd;
    m_uiOrder            = uiOrd;
    
    m_bstrDisplayName    = (*pDeviceConfig)->lpctstrDeviceName;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrDeviceName = (*pDeviceConfig)->lpctstrDeviceName;
    if (!m_bstrDeviceName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    m_bstrProviderName = (*pDeviceConfig)->lpctstrProviderName;
    if (!m_bstrProviderName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

	if (NULL != (*pDeviceConfig)->lptstrDescription )
	{
		m_bstrDescription = (*pDeviceConfig)->lptstrDescription;
		if (!m_bstrDescription)
		{
			hRc = E_OUTOFMEMORY;
			goto Error;
		}
	}
	else
	{
		m_bstrDescription = L"";
		DebugPrintEx(
			DEBUG_ERR,
			_T("Description value supplied by service is NULL"));
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundRoutingDeviceNode::Init
 -
 *  Purpose:
 *       This method reterives the from RPC device's data 
 *       and inits the private members with it.
 *
 *  Arguments:
 *      [in]    dwDeviceID - the unique device ID 
 *      [in]    uiOrd - order index
 *      [in]    uiMaxOrd - the maximal order in the group
 *      [in]    pParentNode - pointer to parent node
 *
 *  Return:
 *      OLE error code
 */
HRESULT 
CFaxOutboundRoutingDeviceNode::Init(
                            DWORD dwDeviceID, 
                            UINT  uiOrd,
                            UINT  uiMaxOrd,
                            CFaxOutboundRoutingGroupNode * pParentNode)
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::Init"));
    HRESULT hRc = S_OK;

    FAX_SERVER_ICONS     enumIcon;

    ATLASSERT(pParentNode);
    ATLASSERT(uiMaxOrd >= uiOrd);

    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;
    
    //
    // init from function parametrs
    //
    m_dwDeviceID = dwDeviceID;
    m_uiOrder    = uiOrd;
    m_uiMaxOrder = uiMaxOrd;

    InitParentNode(pParentNode);

    //
    // Icon - optimistic start point
    //
    enumIcon = IMAGE_DEVICE;

    //
    // Get the Config. structure with FaxGetPortEx
    //
    hRc = InitRPC(&pFaxDeviceConfig);
    if (FAILED(hRc))
    {
        if( ERROR_BAD_UNIT != HRESULT_CODE(hRc) )
        {
            //DebugPrint and MsgBox by called func.
    
            //to be safe actually done by InitRPC on error.
            pFaxDeviceConfig = NULL;
    
            goto Error;
        }
        else
        {
            DebugPrintEx(
			    DEBUG_MSG,
			    TEXT("+++ +++ System can not find one device from the group. (hRc: %08X) +++ +++"),
			    hRc);
            
            // Continue !!! 
            // we will show the bad device
            // but skip it's init-members function
            // the strings to show on error were configured in the constractor

            enumIcon = IMAGE_DEVICE_ERROR;

            goto Error;
        }
    }
    ATLASSERT(NULL != pFaxDeviceConfig);
    
    
    hRc = InitMembers(&pFaxDeviceConfig, dwDeviceID, uiOrd, uiMaxOrd );
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to init (hRc : %08X)"),
            hRc);
    }

Exit:
    //
    // Icon
    //
    m_resultDataItem.nImage = enumIcon;

    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
        pFaxDeviceConfig = NULL;
    }//any way function quits with memory allocation freed       

    return hRc;
}

/*
 -  CFaxOutboundRoutingDeviceNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxOutboundRoutingDeviceNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    int   iCount;
    WCHAR buff[FXS_MAX_NUM_OF_DEVICES_LEN+1];

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
            //
            // Name
            //
            if (!m_bstrDeviceName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDeviceName."));
                goto Error;
            }
            else
            {
                return (m_bstrDeviceName);
            }
    case 1:
            //
            // Order
            //
            iCount = swprintf(buff, L"%ld", m_uiOrder);
    
            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - m_uiOrder."));
                goto Error;
            }
            else
            {
                m_buf = buff;
                return (m_buf);
            }

    case 2:
            //
            // Description
            //
            if (!m_bstrDescription)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDescription."));
                goto Error;
            }
            else
            {
                return (m_bstrDescription);
            }
    case 3:
            //
            // Provider
            //
            if (!m_bstrProviderName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrProviderName."));
                goto Error;
            }
            else
            {
                return (m_bstrProviderName);
            }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxOutboundRoutingDeviceNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingDeviceNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Delete
    // 2. Refresh
    //
    if (m_fIsChildOfAllDevicesGroup)
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN,        FALSE);
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, INDETERMINATE, TRUE);
    }
    else
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED,       TRUE);
    }

    //
    // leaf node
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE); 
    return hRc;
}


/*
-  CFaxOutboundRoutingDeviceNode::OnMoveDown
-
*  Purpose:
*      Call to move down device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxOutboundRoutingDeviceNode::OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::OnMoveDown"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( 1 > (DWORD)m_uiOrder ) 
        ||
         ( dwMaxOrder < (DWORD)(m_uiOrder+1) )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order down."));
        
        return (S_FALSE);
    }
    else
    {
        return(m_pParentNode->ChangeDeviceOrder( 
                                    (DWORD)m_uiOrder, 
                                    (DWORD)(m_uiOrder+1), 
                                    m_dwDeviceID,
                                    pRoot) );
    }
}

/*
-  CFaxOutboundRoutingDeviceNode::OnMoveUp
-
*  Purpose:
*      To move up in the view the device
*
*  Arguments:
*
*  Return:
*      OLE error code
*/
HRESULT  CFaxOutboundRoutingDeviceNode::OnMoveUp(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::OnMoveUp"));
    DWORD dwMaxOrder;

    ATLASSERT(m_pParentNode);

    //
    // Validity Check
    //
    dwMaxOrder = m_pParentNode->GetMaxOrder();
    if (
         ( 0 == dwMaxOrder ) // list was not populated successfully
        ||
         ( dwMaxOrder < (DWORD)m_uiOrder )
        ||
         ( 1 > (DWORD)(m_uiOrder-1) )
       )
    {
		DebugPrintEx(
			DEBUG_ERR,
			_T("Invalid operation. Can not move device order up."));
        
        return (S_FALSE);
    }
    else
    {
        return (m_pParentNode->ChangeDeviceOrder( (DWORD)m_uiOrder, 
                                                  (DWORD)(m_uiOrder-1), 
                                                  m_dwDeviceID,
                                                  pRoot) );
    }
}


/*
 -  CFaxOutboundRoutingDeviceNode::ReselectItemInView
 -
 *  Purpose:
 *      Reselect the node to redraw toolbar buttons
 *
 *  Arguments:
 *      [in]    pConsole - the console interface
 *
 *  Return: OLE error code
 */
HRESULT CFaxOutboundRoutingDeviceNode::ReselectItemInView(IConsole *pConsole)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::ReselectItemInView"));
    HRESULT     hRc = S_OK;

    //
    // Need IResultData
    //
    CComQIPtr<IResultData, &IID_IResultData> pResultData(pConsole);
    ATLASSERT(pResultData != NULL);

    //
    // Reselect the node to redraw toolbar buttons.
    //
    hRc = pResultData->ModifyItemState( 0, m_resultDataItem.itemID, LVIS_SELECTED | LVIS_FOCUSED, 0 );
    if ( S_OK != hRc )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failure on pResultData->UpdateItem, (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);
        goto Exit;
    }

Exit:
    return hRc;
}


/*
 -  CFaxOutboundRoutingDeviceNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */

HRESULT CFaxOutboundRoutingDeviceNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (type);

    HRESULT           hRc       = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        //  Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Cleanup;
        }
    }
    
    //
    // Delete it
    //
    ATLASSERT(m_pParentNode);
    hRc = m_pParentNode->DeleteDevice(m_dwDeviceID,
                                    this);
    if ( FAILED(hRc) )
    {
        goto Cleanup;
    }

Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundRoutingDeviceNode::UpdateToolbarButton
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateToolbarButton
 *      This function aloow us to decide if to the activate\grayed a toolbar button  
 *      It treating only the Enable state.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int for the toolbar button ID
 *            [in]  fsState  - state to be cosidered ENABLE ?HIDDEN etc. 
 *
 *  Return:
 *     BOOL TRUE to activate state FALSE to disabled the state for this button 
 */
BOOL CFaxOutboundRoutingDeviceNode::UpdateToolbarButton(UINT id, BYTE fsState)
{
    DEBUG_FUNCTION_NAME( _T("CFaxServerNode::UpdateToolbarButton"));
    BOOL bRet = FALSE;	
	    
    // Set whether the buttons should be enabled.
    if (fsState == ENABLED)
    {

        switch ( id )
        {
            case ID_MOVEUP_BUTTON:

                bRet = ( (FXS_FIRST_DEVICE_ORDER == m_uiOrder) ?  FALSE : TRUE );           

                break;

            case ID_MOVEDOWN_BUTTON:

                bRet = ( (m_uiMaxOrder == m_uiOrder)  ?  FALSE : TRUE);
                
                break;
        
            default:
                break;

        }

    }

    // For all other possible button ID's and states, 
    // the correct answer here is FALSE.
    return bRet;

}



/*
 -  CFaxOutboundRoutingDeviceNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:

 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxOutboundRoutingDeviceNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);
    
    switch (id)
    {
        case IDM_MOVEUP:

            *flags = ((FXS_FIRST_DEVICE_ORDER == m_uiOrder) ?  MF_GRAYED : MF_ENABLED );           
            break;

        case IDM_MOVEDOWN:

            *flags = ((m_uiMaxOrder == m_uiOrder)  ?  MF_GRAYED : MF_ENABLED );
            break;

        default:
            break;
    }
    
    return;
}

/*
 -  CFaxOutboundRoutingDeviceNode::SetOrder
 -
 *  Purpose:
 *      Overload function which allow 
 *      re-setting the order and the MaxOrder 
 *
 *  Arguments:
 *            
 *            [in] uiNewOrder - Device's order.
 *            [in] uiNewMaxOrder - Maximal order in the current list
 *
 *  Return:
 *      no return value - void function 
 */
VOID CFaxOutboundRoutingDeviceNode::SetOrder(UINT uiNewOrder, UINT uiNewMaxOrder)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingDeviceNode::UpdateMenuState"));

    m_uiOrder    = uiNewOrder;
    m_uiMaxOrder = uiNewMaxOrder;

    return;
}

/*
 +
 +  CFaxOutboundRoutingDeviceNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingDeviceNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_GROUPS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outbounddevice.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundDevice.h                                       //
//                                                                         //
//  DESCRIPTION   : Header file for the Outbound Routing Device node.      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg  Create                                          //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGDEVICE_H
#define H_FAXOUTBOUNDROUTINGDEVICE_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"

//#include "ppFaxInboundRoutingMethodGeneral.h"

//class CppFaxInboundRoutingMethod;
class CFaxOutboundRoutingGroupNode;

class CFaxOutboundRoutingDeviceNode : public CSnapinNode <CFaxOutboundRoutingDeviceNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingDeviceNode, FALSE)
        SNAPINCOMMAND_ENTRY(IDM_MOVEUP,         OnMoveUp)
        SNAPINCOMMAND_ENTRY(IDM_MOVEDOWN,       OnMoveDown)
        SNAPINCOMMAND_ENTRY(ID_MOVEUP_BUTTON,   OnMoveUp)
        SNAPINCOMMAND_ENTRY(ID_MOVEDOWN_BUTTON, OnMoveDown)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingDeviceNode)
        SNAPINTOOLBARID_ENTRY(IDR_TOOLBAR_DEVICE_UD)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTDEVICE_MENU)

    //
    // Constructor
    //
    CFaxOutboundRoutingDeviceNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxOutboundRoutingDeviceNode, FALSE>(pParentNode, pComponentData )
    {
        // for any case of ERROR_BAD_UNIT - device not found
        m_bstrDeviceName  = L"???";       
        m_bstrDescription = L"???";   
        m_bstrDescription = L"???";    
        
        m_fIsChildOfAllDevicesGroup = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingDeviceNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxOutboundRoutingGroupNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    VOID       SetOrder(UINT uiNewOrder)  { m_uiOrder = uiNewOrder; return; }

    VOID       SetOrder(UINT uiNewOrder, UINT uiNewMaxOrder);

    HRESULT    ReselectItemInView(IConsole *pConsole);

    HRESULT    Init(DWORD dwDeviceID, 
                    UINT  uiOrd,
                    UINT  uiMaxOrd,
                    CFaxOutboundRoutingGroupNode * pParentNode);

    VOID       MarkAsChildOfAllDevicesGroup() {m_fIsChildOfAllDevicesGroup = TRUE;}

    void       UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    BOOL       UpdateToolbarButton(UINT id, BYTE fsState);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxOutboundRoutingGroupNode * m_pParentNode;

    //
    // members
    //
    DWORD     m_dwDeviceID;             
    UINT      m_uiOrder;
    CComBSTR  m_bstrDeviceName;       
    CComBSTR  m_bstrDescription;   
    CComBSTR  m_bstrProviderName;    
    
    UINT      m_uiMaxOrder;
    BOOL      m_fIsChildOfAllDevicesGroup;            
    
    CComBSTR  m_buf; 

    //
    // Menu item handlers
    //
    HRESULT OnMoveUp  (bool &bHandled, CSnapInObjectRootBase *pRoot);
    HRESULT OnMoveDown(bool &bHandled, CSnapInObjectRootBase *pRoot);

    //
    //  Init
    //
    HRESULT  InitRPC     (PFAX_PORT_INFO_EX * pFaxDeviceConfig);

    HRESULT  InitMembers (PFAX_PORT_INFO_EX * pFaxDeviceConfig,
                            DWORD dwDeviceID, 
                            UINT  uiOrd,
                            UINT  uiMaxOrd);

    
};

//typedef CSnapinNode<CFaxOutboundRoutingDeviceNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  H_FAXOUTBOUNDROUTINGDEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundgroup.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroup.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Outbound Routing Group Node    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg   Create                                         //
//      Jan  3 2000 yossg   add new device(s)                              //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGGROUP_H
#define H_FAXOUTBOUNDROUTINGGROUP_H

#include "snapin.h"
#include "snpnres.h"


#include "OutboundDevice.h"
 
class CFaxOutboundGroupsNode;
class CFaxOutboundRoutingDeviceNode;

class CFaxOutboundRoutingGroupNode : public CNodeWithResultChildrenList<
                                        CFaxOutboundRoutingGroupNode,    
                                        CFaxOutboundRoutingDeviceNode, 
                                        CSimpleArray<CFaxOutboundRoutingDeviceNode*>, 
                                        FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingGroupNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_NEW_DEVICES, OnNewDevice)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingGroupNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTGROUP_MENU)

    //
    // Constructor
    //
    CFaxOutboundRoutingGroupNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxOutboundRoutingGroupNode, CFaxOutboundRoutingDeviceNode, CSimpleArray<CFaxOutboundRoutingDeviceNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_bstrGroupName        = L"";
        m_lpdwDeviceID         = NULL;
        m_dwNumOfDevices       = 0;
        // Succeed ToPopulateAllDevices
        m_fSuccess = FALSE;
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingGroupNode()
    {
        if (NULL != m_lpdwDeviceID)
        {
            delete[] m_lpdwDeviceID;
        }
    }

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    LPOLESTR GetResultPaneColInfo(int nCol);
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    void InitParentNode(CFaxOutboundGroupsNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT Init(PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig);

    //
    // Events on the Group
    //

    //delete the group
    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    //
    // Treat Group Devices
    //

    HRESULT OnNewDevice(bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT DeleteDevice(DWORD dwDeviceIdToRemove, CFaxOutboundRoutingDeviceNode *pChildNode);

    HRESULT ChangeDeviceOrder(DWORD dwOrder, DWORD dwNewOrder, DWORD dwDeviceID, CSnapInObjectRootBase *pRoot);

    HRESULT SetNewDeviceList(LPDWORD lpdwNewDeviceID);

    void    UpdateMenuState (UINT id, LPTSTR pBuf, UINT *flags);

    //
    // Access To private members
    //
    DWORD   GetMaxOrder()   
                { return( m_fSuccess ? m_dwNumOfDevices : 0); }

    LPDWORD GetDeviceIDList()   { return m_lpdwDeviceID; }
    
    DWORD   GetNumOfDevices()   { return m_dwNumOfDevices; }

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    static CColumnsInfo         m_ColsInfo;
            
    CFaxOutboundGroupsNode *    m_pParentNode;

    //
    // members
    //
    CComBSTR                    m_bstrGroupName;       
    DWORD                       m_dwNumOfDevices;
    LPDWORD                     m_lpdwDeviceID;   
    FAX_ENUM_GROUP_STATUS       m_enumStatus;

    CComBSTR                    m_buf; 
    
    // Succeed ToPopulateAllDevices
    BOOL                        m_fSuccess;  

    //
    // Methods
    //
    HRESULT  InitMembers  (PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig);

    HRESULT  InitGroupName(LPCTSTR lpctstrGroupName);

    UINT     GetStatusIDS (FAX_ENUM_GROUP_STATUS enumStatus);

    void     InitIcons ();

    //
    // for internal usage. similar to the public init 
    // but creates and frees its own configuration structure
    //
    HRESULT  RefreshFromRPC();

    HRESULT  RefreshNameSpaceNode();
};

typedef CNodeWithResultChildrenList<CFaxOutboundRoutingGroupNode, CFaxOutboundRoutingDeviceNode, CSimpleArray<CFaxOutboundRoutingDeviceNode*>, FALSE>
        CBaseFaxOutboundRoutingGroupNode;

#endif  //H_FAXOUTBOUNDROUTINGGROUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundgroups.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroups.h                                       //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxOutboundGroupsNode class           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Jan  3 2000 yossg   add new group                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDGROUPSNODE_H
#define H_FAXOUTBOUNDGROUPSNODE_H

#include "OutboundRouting.h"

#include "snapin.h"
#include "snpnscp.h" //#include "snpnode.h"

class CFaxOutboundRoutingNode;
class CFaxOutboundRoutingGroupNode;

class CFaxOutboundGroupsNode : public CNodeWithScopeChildrenList<CFaxOutboundGroupsNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundGroupsNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_NEW_GROUP, OnNewGroup)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundGroupsNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTGROUPS_MENU)

    CFaxOutboundGroupsNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxOutboundGroupsNode, FALSE>(pParentNode, pComponentData )
    {
        m_dwNumOfGroups = FXS_ITEMS_NEVER_COUNTED;
    }

    ~CFaxOutboundGroupsNode()
    {
    }

    HRESULT InitRPC(PFAX_OUTBOUND_ROUTING_GROUP * pFaxGroupsConfig);

    virtual HRESULT PopulateScopeChildrenList();

    HRESULT RepopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    HRESULT DoRefresh();

    void InitParentNode(CFaxOutboundRoutingNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();

    HRESULT DeleteGroup(BSTR bstrName, CFaxOutboundRoutingGroupNode *pChildNode);

    HRESULT OnNewGroup (bool &bHandled, CSnapInObjectRootBase *pRoot);

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    
    static CColumnsInfo             m_ColsInfo;

    CFaxOutboundRoutingNode *       m_pParentNode;

    DWORD                           m_dwNumOfGroups;
    
};

typedef CNodeWithScopeChildrenList<CFaxOutboundGroupsNode, FALSE>
        CBaseFaxOutboundGroupsNode;


#endif  //H_FAXOUTBOUNDGROUPSNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundgroups.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroups.cpp                                     //
//                                                                         //
//  DESCRIPTION   : Fax Server - Fax OutboundGroups node.                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Jan  3 2000 yossg   add new group                                  //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "OutboundGroups.h"
#include "OutboundGroup.h"

#include "dlgNewGroup.h"

#include "Icons.h"

//#include "oaidl.h"

// {1036F509-554F-41b7-BE77-CF8E8E994011}
static const GUID CFaxOutboundGroupsNodeGUID_NODETYPE = 
{ 0x1036f509, 0x554f, 0x41b7, { 0xbe, 0x77, 0xcf, 0x8e, 0x8e, 0x99, 0x40, 0x11 } };

const GUID*    CFaxOutboundGroupsNode::m_NODETYPE = &CFaxOutboundGroupsNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundGroupsNode::m_SZNODETYPE = OLESTR("1036F509-554F-41b7-BE77-CF8E8E994011");
const CLSID*   CFaxOutboundGroupsNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundGroupsNode::m_ColsInfo;


/*
 -  CFaxOutboundGroupsNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundGroupsNode::InitRPC(PFAX_OUTBOUND_ROUTING_GROUP * pFaxGroupsConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

	//
	// Retrieve the Outbound Groups configuration
	//
    if (!FaxEnumOutboundGroups(pFaxServer->GetFaxServerHandle(), 
                        pFaxGroupsConfig,
                        &m_dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(*pFaxGroupsConfig);
	ATLASSERT(FXS_ITEMS_NEVER_COUNTED != m_dwNumOfGroups);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get groups configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);

    //
    // allow refresh in case of failure
    //
    m_dwNumOfGroups = 0;
    
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundGroupsNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create all the Fax Outbound Routing Group nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 *		Actually it is the last OLE error code that ocoured 
 *      during processing this method.
 */
HRESULT CFaxOutboundGroupsNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::PopulateScopeChildrenList"));
    HRESULT hRc  = S_OK; 

    CFaxOutboundRoutingGroupNode * pGroup = NULL;
                       
    PFAX_OUTBOUND_ROUTING_GROUP pFaxOutboundGroupsConfig = NULL;
    DWORD i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC(&pFaxOutboundGroupsConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxOutboundGroupsConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxOutboundGroupsConfig);

    for (i=0; i< m_dwNumOfGroups; i++ )
    {
        pGroup = new CFaxOutboundRoutingGroupNode(
                                    this, 
                                    m_pComponentData);
        if (!pGroup)
        {
            hRc = E_OUTOFMEMORY;
            NodeMsgBox(IDS_MEMORY);
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Out of memory. (hRc: %08X)"),
			    hRc);
            goto Error;
        }
        else
        {
	        pGroup->InitParentNode(this);

            hRc = pGroup->Init(&pFaxOutboundGroupsConfig[i]);
	        if (FAILED(hRc))
	        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to init Group. (hRc: %08X)"),
			        hRc);
		        NodeMsgBox(IDS_FAILTOINIT_GROUP);
                goto Error;
	        }

	        hRc = AddChild(pGroup, &pGroup->m_scopeDataItem);
	        if (FAILED(hRc))
	        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to add Group. (hRc: %08X)"),
			        hRc);
		        NodeMsgBox(IDS_FAILTOADD_GROUP);
                goto Error;
	        }
        }
    }
    
    pGroup = NULL;
    
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    //
    //Get Rid
    //
    {    
        //from the last one 
        if ( NULL != pGroup ) //(if new succeeded)
        {
            delete  pGroup;    
        }

        //from all the previous (if there are)
        int j = m_ScopeChildrenList.GetSize();
        for (int index = 0; index < j; index++)
        {
            pGroup = (CFaxOutboundRoutingGroupNode *)m_ScopeChildrenList[0];

            hRc = RemoveChild(pGroup);
            if (FAILED(hRc))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to delete group. (hRc: %08X)"), 
                    hRc);
                goto Error;
            }
            delete pGroup;
        }

        // Empty the list of all groups added before the one who failed
        // already done one by one inside RemoveChild
        // m_ScopeChildrenList.RemoveAll(); 
    
        m_bScopeChildrenListPopulated = FALSE;
    }
Exit:
    if (NULL != pFaxOutboundGroupsConfig)
    {
        FaxFreeBuffer(pFaxOutboundGroupsConfig);
    }       
    
    return hRc;
}

/*
 -  CFaxOutboundGroupsNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundGroupsNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    SCODE hRc;

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::InsertColumns"));

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_OUTBOUND_GROUPS_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_OUTBOUND_GROUPS_COL2, AUTO_WIDTH},
        {IDS_OUTBOUND_GROUPS_COL3, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC. (hRc: %08X)"), hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxOutboundGroupsNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundGroupsNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 
    
    return hRc;
}


/*
 -  CFaxOutboundGroupsNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundGroupsNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::OnRefresh"));
    HRESULT hRc = S_OK;

    SCOPEDATAITEM*          pScopeData;
    CComPtr<IConsole>       spConsole;

	if (FXS_ITEMS_NEVER_COUNTED != m_dwNumOfGroups)//already expanded before.
	{

        //
        // Repopulate Scope Children List
        //
        hRc = RepopulateScopeChildrenList();
        if (S_OK != hRc)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to RepopulateScopeChildrenList(). (hRc: %08X)"),
			    hRc);
            // Done by called func. NodeMsgBox(FAIL2REPOPULATE_GROUP_LIST);

            goto Exit;
        }
    }
	else //never expanded before
    {
		DebugPrintEx(
			DEBUG_MSG,
			_T("User call refresh before expand node's children."));
        //continue to reselect the node.
	}

    //
	// Get the updated SCOPEDATAITEM
	//
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_GROUPSNODE);

        goto Exit;
    }

    //
	// This will force MMC to redraw the scope node
	//
    spConsole = m_pComponentData->m_spConsole;
    ATLASSERT(spConsole);
	
    hRc = spConsole->SelectScopeItem( pScopeData->ID );
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to select scope Item. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL2REDRAW_GROUPSNODE);
    }

Exit:
    return hRc;
}


/*
 -  CFaxOutboundGroupsNode::OnNewGroup
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxOutboundGroupsNode::OnNewGroup(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CDlgNewFaxOutboundGroup::OnNewGroup"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    CDlgNewFaxOutboundGroup      DlgNewGroup(((CFaxServerNode *)GetRootNode())->GetFaxServer());

    //
    // Dialog to add group
    //
    rc = DlgNewGroup.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Repopulate (with RPC) and Refresh the view
    //
    if (m_bScopeChildrenListPopulated)
    {
        DoRefresh(pRoot);
    }

 
Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundGroupsNode::RepopulateScopeChildrenList
 -
 *  Purpose:
 *      RePopulateScopeChildrenList
 *
 *  Arguments:
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundGroupsNode::RepopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::RepopulateScopeChildrenList"));
    HRESULT hRc = S_OK;

    CFaxOutboundRoutingGroupNode *pChildNode ;

    CComPtr<IConsole> spConsole;
    ATLASSERT(m_pComponentData);

    spConsole = ((CSnapin*)m_pComponentData)->m_spConsole;
    ATLASSERT( spConsole != NULL );
    
    CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);

    //
    // Remove group objects from list
    //
    for (int i = 0; i < m_ScopeChildrenList.GetSize(); i++)
    {
        pChildNode = (CFaxOutboundRoutingGroupNode *)m_ScopeChildrenList[i];

        hRc = spConsoleNameSpace->DeleteItem(pChildNode->m_scopeDataItem.ID, TRUE);
        if (FAILED(hRc))
        {
            DebugPrintEx(DEBUG_ERR,
                _T("Fail to delete group. (hRc: %08X)"), 
                hRc);
			// This is a very bad place to catch a failure
			// DeleteItem may return S_OK or E_UNEXPECTED
			// We do not pop-up this info to the user.

			goto Error;
        }
		delete pChildNode;
    }

    //
    // Empty the list object itself and change it's status
    //
    m_ScopeChildrenList.RemoveAll();

    m_bScopeChildrenListPopulated = FALSE;

    //
    // Rebuild the list
    //
    hRc = PopulateScopeChildrenList();
    if (FAILED(hRc))
    {
        DebugPrintEx(DEBUG_ERR,
            _T("Fail to Populate groups. (hRc: %08X)"), 
            hRc);
        goto Error;
    }

    m_bScopeChildrenListPopulated = TRUE;

    ATLASSERT(S_OK == hRc);
    DebugPrintEx(DEBUG_MSG,
        _T("Succeeded to Re Populate Groups. (hRc: %08X)"), 
        hRc);
    goto Cleanup;
Error:
   NodeMsgBox(IDS_FAIL2REPOPULATE_GROUPS);

Cleanup:
    return hRc;
}


/*
 -  CFaxOutboundGroupsNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundGroupsNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateScopeChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}


HRESULT
CFaxOutboundGroupsNode::DoRefresh()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundGroupsNode::DoRefresh()"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateScopeChildrenList();

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2REFRESH_THEVIEW);        
    }

    return hRc;
}

/*
 -  CFaxOutboundGroupsNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundGroupsNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundGroupNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), IDS_DISPLAY_STR_OUTROUTEGROUPSNODE) )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 -  CFaxOutboundGroupsNode::DeleteGroup
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    bstrName   - The Group name
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundGroupsNode::DeleteGroup(BSTR bstrName, CFaxOutboundRoutingGroupNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundGroupsNode::DeleteGroup"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;
    BOOL         fSkipMessage = FALSE;

    CFaxServer *  pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Remove with RPC from the server
    //
    if (!FaxRemoveOutboundGroup (
	        pFaxServer->GetFaxServerHandle(),
	        bstrName))
    {
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to remove group. (ec: %ld)"), 
			ec);

        if (FAX_ERR_GROUP_IN_USE == ec)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("The group is empty or none of group devices is valid. (ec: %ld)"), 
			    ec);
            
            NodeMsgBox(IDS_FAX_ERR_GROUP_IN_USE);
            fSkipMessage = TRUE;

            goto Error; 
        }

        
        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    

    //
    // Remove from MMC 
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove Group. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_REMOVE_GROUP);
        return(hRc);
    }

    //
    // Call the group destructor
    //
    delete pChildNode;

    
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The group was removed successfully."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    if (!fSkipMessage)
    {
        NodeMsgBox(GetFaxServerErrorMsg(ec));
    }
  
Exit:
    return (hRc);
}

/*
 +
 +  CFaxOutboundGroupsNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundGroupsNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_GROUPS);
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundgroup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundGroup.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Outbound Routing Group MMC node.                   //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 23 1999 yossg  Create                                          //
//      Jan  3 2000 yossg   add new device(s)                              //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "OutboundGroup.h"

#include "OutboundGroups.h"

#include "dlgNewDevice.h"

//#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {3E470227-76C1-4b66-9C63-B77DF81C145D}
static const GUID CFaxOutboundRoutingGroupNodeGUID_NODETYPE = 
{ 0x3e470227, 0x76c1, 0x4b66, { 0x9c, 0x63, 0xb7, 0x7d, 0xf8, 0x1c, 0x14, 0x5d } };

const GUID*    CFaxOutboundRoutingGroupNode::m_NODETYPE = &CFaxOutboundRoutingGroupNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundRoutingGroupNode::m_SZNODETYPE = OLESTR("3E470227-76C1-4b66-9C63-B77DF81C145D");
const CLSID*   CFaxOutboundRoutingGroupNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundRoutingGroupNode::m_ColsInfo;


/*
 -  CFaxOutboundRoutingGroupNode::RefreshFromRPC
 -
 *  Purpose:
 *      Init all members icon etc. 
 *       - with creation of structure configuration
 *       - Call InitRpc to fill it
 *       - Call InitMembers to init members and icon
 *       - Free structure
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::RefreshFromRPC()
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::RefreshFromRPC()"));

    PFAX_OUTBOUND_ROUTING_GROUP pFaxGroupsConfig = NULL;

    HRESULT      hRc              = S_OK;
    DWORD        ec               = ERROR_SUCCESS;

    CFaxServer * pFaxServer       = NULL;

    DWORD        dwNumOfGroups    = 0; 
    
    BOOL         fFound;
    DWORD        i; //index

    PFAX_OUTBOUND_ROUTING_GROUP   pFaxTmp;
    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the Outbound Groups configuration
	//
    if (!FaxEnumOutboundGroups(pFaxServer->GetFaxServerHandle(), 
                        &pFaxGroupsConfig,
                        &dwNumOfGroups)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get groups configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxGroupsConfig);

    pFaxTmp = pFaxGroupsConfig;
    fFound = FALSE;
    for ( i =0; i < dwNumOfGroups; i++  )
    {
        ATLASSERT(NULL != pFaxTmp);

        if(0 == wcscmp(m_bstrGroupName, pFaxTmp->lpctstrGroupName) )
        {
            fFound = TRUE; 
        }
        else
        {
            pFaxTmp++;
        }
    }
    
    if(fFound)
    {
        //
        // init members
        //
        m_dwNumOfDevices = pFaxTmp->dwNumDevices;

        if (0 < m_dwNumOfDevices)
        {
            if (NULL != m_dwNumOfDevices)
            {
                delete[] m_lpdwDeviceID;
            }
            m_lpdwDeviceID = new DWORD[m_dwNumOfDevices];    
            memcpy(m_lpdwDeviceID, pFaxTmp->lpdwDevices, sizeof(DWORD)*m_dwNumOfDevices) ;
        }
        else
        {
            DebugPrintEx( DEBUG_MSG, _T("Device list found to be currrently empty."));
            if (NULL != m_dwNumOfDevices)
            {
                delete[] m_lpdwDeviceID;
            }
            m_lpdwDeviceID = NULL;
        }
        
        m_enumStatus = pFaxTmp->Status;
        
        InitIcons ();
    }
    else
    {
        ec = FAX_ERR_GROUP_NOT_FOUND;
        DebugPrintEx(
            DEBUG_ERR,
            _T("UEXPECTED ERROR - Group not found."));
        goto Error;
    }


    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to re init group configuration and ."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    

Exit:
    if (NULL != pFaxGroupsConfig)
    {
        FaxFreeBuffer(pFaxGroupsConfig);
    }//any way function ends with memory allocation freed       

    return hRc;
}


/*
 -  CFaxOutboundRoutingGroupNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pGroupConfig - FAX_OUTBOUND_ROUTING_GROUP  
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::Init(PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pGroupConfig);

    hRc = InitMembers( pGroupConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    

Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pGroupConfig - FAX_OUTBOUND_ROUTING_GROUP  structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::InitMembers(PFAX_OUTBOUND_ROUTING_GROUP pGroupConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InitMembers"));
    HRESULT hRc = S_OK;

    ATLASSERT(pGroupConfig);

    //    
    // status and Icon   
    //    
    m_enumStatus      = pGroupConfig->Status;

    InitIcons ();

    //
    // Device List
    // 
    m_dwNumOfDevices  = pGroupConfig->dwNumDevices;

    ATLASSERT(0 <= m_dwNumOfDevices);

    

    if (0 < m_dwNumOfDevices)
    {
        //if (NULL != m_dwNumOfDevices)
        //{
        //    delete[] m_lpdwDeviceID;
        //}
        m_lpdwDeviceID  = new DWORD[m_dwNumOfDevices];
        if (NULL == m_lpdwDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfDevices);
            hRc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }

        memcpy(m_lpdwDeviceID, pGroupConfig->lpdwDevices, sizeof(DWORD)*m_dwNumOfDevices) ;
    }
    else
    {
        DebugPrintEx( DEBUG_MSG, _T("Device list found to be currrently empty."));
        //if (NULL != m_dwNumOfDevices)
        //{
        //    delete[] m_lpdwDeviceID;
        //}
        m_lpdwDeviceID = NULL;
    }

    hRc = InitGroupName(pGroupConfig->lpctstrGroupName);
    if (FAILED(hRc))
    {
        goto Error; 
    }    
   
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxOutboundRoutingGroupNode::InitGroupName
 -
 *  Purpose:
 *      Init the display name and group name from given group name. 
 *      Displayed name may be changed to localized version if it is
 *      the All Devices Group.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::InitGroupName(LPCTSTR lpctstrGroupName)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InitGroupName"));
    HRESULT hRc = S_OK;

    if ( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, lpctstrGroupName))
    {
        //
        // Replace <all Devices> string with the localized string 
        //       
        if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                                    IDS_ALL_DEVICES) )
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }
	}
    else
    {
        m_bstrDisplayName = lpctstrGroupName;
        if (!m_bstrDisplayName)
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }    
    }
    
    m_bstrGroupName = lpctstrGroupName;
    if (!m_bstrGroupName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }    
   
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    //NodeMsgBox done by Caller func.
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundRoutingGroupNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxOutboundRoutingGroupNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    UINT  idsStatus;
    int   iCount;
    WCHAR buff[FXS_MAX_NUM_OF_DEVICES_LEN+1];

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
        //
        // Name
        //
        if (!m_bstrDisplayName)
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Null memeber BSTR - m_bstrGroupName."));
            goto Error;
        }
        else
        {
            return (m_bstrDisplayName);
        }

    case 1:
        //
        // Number of Devices
        //
        iCount = swprintf(buff, L"%ld", m_dwNumOfDevices);

        if( iCount <= 0 )
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to read member - m_dwNumOfDevices."));
            goto Error;
        }
        else
        {
            m_buf = buff;
            return (m_buf);
        }
    
    case 2:
        //
        // Status
        //
        idsStatus = GetStatusIDS(m_enumStatus);
        if ( FXS_IDS_STATUS_ERROR == idsStatus)
        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Invalid Status value or not supported status value."));
                goto Error;
        }
        else
        {
            if (!m_buf.LoadString(idsStatus))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load status string."));
                goto Error;
            }
            return m_buf;
        }

    default:
            ATLASSERT(0); // "this number of column is not supported "
            return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}

/*
 -  CFaxOutboundRoutingGroupNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingGroupNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_OUTBOUND_DEVICES_COL1, FXS_WIDE_COLUMN_WIDTH},
        {IDS_OUTBOUND_DEVICES_COL2, AUTO_WIDTH},
        {IDS_OUTBOUND_DEVICES_COL3, AUTO_WIDTH},
        {IDS_OUTBOUND_DEVICES_COL4, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}



/*
 -  CFaxOutboundRoutingGroupNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxOutboundRoutingGroup device nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;
    BOOL fIsAllDevicesGroup = FALSE;

    CFaxOutboundRoutingDeviceNode *   pDevice;
                       
    if( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
    {
         fIsAllDevicesGroup = TRUE; 
    }


    for ( DWORD i=0; i< m_dwNumOfDevices; i++ )
    {
            pDevice = NULL;

            pDevice = new CFaxOutboundRoutingDeviceNode(this, 
                                            m_pComponentData);
            if (!pDevice)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {                
                //
                // Init parent node ptr, RPC structure, 
                // members displayed name and icon
                //
                hRc = pDevice->Init( m_lpdwDeviceID[i],
                                     i+1,  
                                     (UINT)m_dwNumOfDevices, 
                                     this);
	            if (FAILED(hRc))
	            {
		            if( ERROR_BAD_UNIT != HRESULT_CODE(hRc) )
	                {
                        DebugPrintEx(
			                DEBUG_ERR,
			                TEXT("Fail to add Device Node below Outbound Routing Group. (hRc: %08X)"),
			                hRc);
		                //NodeMsgBox done by called functions
                        goto Error;
	                }
	                else
	                {
                        DebugPrintEx(
			                DEBUG_MSG,
			                TEXT("+++ +++ system can not find one device from the group. (hRc: %08X) +++ +++"),
			                hRc);
                        //Continue - user informed data reay
                        //we will show the bad device
                        hRc = S_OK;
                    }
	            }
                
                if( fIsAllDevicesGroup )
                {
                     pDevice->MarkAsChildOfAllDevicesGroup(); 
                }
            
                hRc = this->AddChildToList(pDevice);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add Device Node below Outbound Routing Group. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAIL_ADD_DEVICE);
                    goto Error;
	            }
                else
                {
                    pDevice = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    
    //
    // Success ToPopulateAllDevices to allow 
    // giving total number of devices to each device
    // when asked for reordering purposes
    //
    m_fSuccess = TRUE;

    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pDevice ) 
    {
        delete  pDevice;    
        pDevice = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pDevice = (CFaxOutboundRoutingDeviceNode *)
                                    m_ResultChildrenList[j];
            delete pDevice;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    return hRc;
}



/*
 -  CFaxOutboundRoutingGroupNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingGroupNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Delete
    // 2. Refresh
    //
    
    if(0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN,        FALSE);
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, INDETERMINATE, TRUE);
    }
    else
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED,       TRUE);
    }

    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxOutboundRoutingGroupNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxOutboundRoutingGroupNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Refresh from server
    //
    hRc = RefreshFromRPC();
    if (FAILED(hRc))
    {
        //msg by called func.
        {
            hRc = m_pParentNode->DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call parent node - Groups DoRefresh. (hRc: %08X)"),
			        hRc);        
            }
            return hRc;
        }
    }
    else
    {
        //
        // Update Group's icon by reselecting the group node.
        //
        hRc = RefreshNameSpaceNode();
        if (FAILED(hRc))
        {
            DebugPrintEx(
		 DEBUG_ERR,
		 TEXT("Fail to refresh the group node. (hRc: %08X)"),
		 hRc);

            return hRc;
        }
    }

    //
    // Call the base class
    //
    hRc = CBaseFaxOutboundRoutingGroupNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        
        int iRes;
        NodeMsgBox(IDS_FAIL2REFERESH_GROUP, MB_OK | MB_ICONERROR, &iRes);
        ATLASSERT(IDOK == iRes);
        ATLASSERT(m_pParentNode);
        if (IDOK == iRes)
        {
            hRc = m_pParentNode->DoRefresh();
            if ( FAILED(hRc) )
            {
                DebugPrintEx(
			        DEBUG_ERR,
			        _T("Fail to call parent node - Groups DoRefresh. (hRc: %08X)"),
			        hRc);
        
            }

        }
        
    }

    return hRc;
}


/*
 -  CFaxOutboundRoutingGroupNode::OnNewDevice
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The snapin object root base node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxOutboundRoutingGroupNode::OnNewDevice(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnNewGroup"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    CDlgNewFaxOutboundDevice      DlgNewDevice(((CFaxServerNode *)GetRootNode())->GetFaxServer());

    //
    // Dialog to add device
    //
    hRc = DlgNewDevice.InitDevices(m_dwNumOfDevices, m_lpdwDeviceID, m_bstrGroupName);
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_FAIL2OPEN_DLG);
        return hRc;
    }
    
    rc = DlgNewDevice.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }

    //
    // Refresh the data 
    //      - Get newdata from RPC 
    //      - init members and 
    //      - Set icons
    //
    hRc = RefreshFromRPC();
    if (FAILED(hRc))
    {
        //msg by called func.
        return hRc;
    }

    //
    // Refresh result pane view
    //
    DoRefresh(pRoot);

    //
    // This will force MMC to redraw the scope group node
    //
    hRc = RefreshNameSpaceNode();
    if (FAILED(hRc))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Fail to RefreshNameSpaceNode. (hRc: %08X)"),
            hRc);
        goto Error;
    }
    ATLASSERT( S_OK == hRc);
    goto Cleanup;
    
Error:
    ATLASSERT( S_OK != hRc);
    NodeMsgBox(IDS_FAIL2UPDATEITEM_GROUP);

Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingGroupNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}


/*
 -  CFaxOutboundRoutingGroupNode::GetStatusIDS
 -
 *  Purpose:
 *      Transslate Status to IDS.
 *
 *  Arguments:
 *
 *            [in]  enumStatus    - unsigned int with the menu IDM value
 *
 *  Return:
 *            IDS of related status message 
 */
UINT CFaxOutboundRoutingGroupNode::GetStatusIDS(FAX_ENUM_GROUP_STATUS enumStatus)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::GetStatusIDS"));

    switch (enumStatus)
    {
        case FAX_GROUP_STATUS_ALL_DEV_VALID:
            return IDS_STATUS_GROUP_ALL_DEV_VALID;

        case FAX_GROUP_STATUS_EMPTY:
            return IDS_STATUS_GROUP_EMPTY;

        case FAX_GROUP_STATUS_ALL_DEV_NOT_VALID:
            return IDS_STATUS_GROUP_ALLDEVICESINVALID;

        case FAX_GROUP_STATUS_SOME_DEV_NOT_VALID:
            return IDS_STATUS_GROUP_SOMEDEVICESINVALID;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            return(FXS_IDS_STATUS_ERROR); //currently 999

    } // endswitch (enumStatus)
}


/*
 -  CFaxOutboundRoutingGroupNode::InitIcons
 -
 *  Purpose:
 *      Private method that initiate icons
 *      due to the status member state.
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      No.
 */
void CFaxOutboundRoutingGroupNode::InitIcons ()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::InitIcons"));
    switch (m_enumStatus)
    {
        case FAX_GROUP_STATUS_ALL_DEV_VALID:
            SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);
            return;
        case FAX_GROUP_STATUS_SOME_DEV_NOT_VALID:
            SetIcons(IMAGE_GROUP_WARN_CLOSE, IMAGE_GROUP_WARN_OPEN);
            return;

        case FAX_GROUP_STATUS_EMPTY:
        case FAX_GROUP_STATUS_ALL_DEV_NOT_VALID:
            SetIcons(IMAGE_GROUP_ERROR_CLOSE, IMAGE_GROUP_ERROR_OPEN);
            return;

        default:
            ATLASSERT(FALSE); // "this enumStatus is not supported "
            SetIcons(IMAGE_GROUP_ERROR_CLOSE, IMAGE_GROUP_ERROR_OPEN);
            return; //currently 999
    } 
    
}


/*
 -  CFaxOutboundRoutingGroupNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    CComBSTR    bstrName;
    HRESULT     hRc = S_OK;


    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        // 1. Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Cleanup;
        }
    }

    //
    // Group name
    //
    if ( !m_bstrGroupName || L"???" == m_bstrGroupName)
    {
        NodeMsgBox(IDS_INVALID_GROUP_NAME);
        goto Cleanup;
    }
    bstrName = m_bstrGroupName;

    //
    // Delete it
    //
    ATLASSERT(m_pParentNode);
    hRc = m_pParentNode->DeleteGroup(bstrName, this);
    if ( FAILED(hRc) )
    {
        goto Cleanup;
    }

Cleanup:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::ChangeDeviceOrder
 -
 *  Purpose:
 *      This func moves up or down specific device in the group order
 *
 *  Arguments:
 *      [in] dwNewOrder - specifies the new order +1 /-1 inrelative to current order.
 *      [in] dwDeviceID - Device ID
 *      [in] pChildNode - the device node object.
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::ChangeDeviceOrder(DWORD dwOrder, DWORD dwNewOrder, DWORD dwDeviceID, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::ChangeDeviceOrder"));

    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    int iIndex, iNewIndex;

    CFaxOutboundRoutingDeviceNode* tmpChildNode;

    CComPtr<IConsole> spConsole;

    //
    // Validity asserts
    //
    ATLASSERT((dwNewOrder-1)< m_dwNumOfDevices);
    ATLASSERT((dwNewOrder-1)>= 0);
    ATLASSERT((dwOrder-1)< m_dwNumOfDevices);
    ATLASSERT((dwOrder-1)>= 0);
    
    ATLASSERT( ( (dwOrder-1)-(dwNewOrder-1) == 1) 
                    || ( (dwOrder-1)-(dwNewOrder-1) == -1) );

    //
    // init swaped indexes
    //
    iIndex    = (int)(dwOrder-1);
    iNewIndex = (int)(dwNewOrder-1);

    //
    // RPC change Order
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    if (!FaxSetDeviceOrderInGroup(
                        pFaxServer->GetFaxServerHandle(), 
                        m_bstrGroupName/*lpctstrGroupName*/,
			            dwDeviceID,
			            dwNewOrder) ) 
	{
        ec = GetLastError();

        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to Set new order. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        goto Error; 
    }
    else // Success of RPC -> Now to MMC
    {
        //
        // Local swap
        //
        tmpChildNode = m_ResultChildrenList[iIndex];
        m_ResultChildrenList[iIndex] = m_ResultChildrenList[iNewIndex];
        m_ResultChildrenList[iNewIndex] = tmpChildNode;

        m_ResultChildrenList[iIndex]->SetOrder((UINT)iIndex+1);
        m_ResultChildrenList[iNewIndex]->SetOrder((UINT)iNewIndex+1);
        
        
        //
        // Get console
        //
        if (pRoot)
        {
            //
            // Get the console pointer
            //
            ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
            if (pRoot->m_nType == 1)
            {
                //
                // m_ntype == 1 means the IComponentData implementation
                //
                CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
                spConsole = pCComponentData->m_spConsole;
            }
            else
            {
                //
                // m_ntype == 2 means the IComponent implementation
                //
                CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
                spConsole = pCComponent->m_spConsole;
            }
        }
        else
        {
            ATLASSERT(m_pComponentData);
            spConsole = m_pComponentData->m_spConsole;
        }
        ATLASSERT(spConsole);
        
        //
        // UpdateAllViews
        //
        spConsole->UpdateAllViews(NULL, (LPARAM)this, NULL);
        
        //
        // Reselect the moved item in his new place
        //
        m_ResultChildrenList[iNewIndex]->ReselectItemInView(spConsole);

    }
    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set devices new order for Outbound Routing group."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingGroupNode::SetNewDeviceList
 -
 *  Purpose:
 *      To assign new device list to group.
 *
 *  Arguments:
 *      [in] lpdwNewDeviceId - the new device ID list
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingGroupNode::SetNewDeviceList(LPDWORD lpdwNewDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::SetNewDeviceLists"));

    HRESULT     hRc = S_OK;
    DWORD       ec  = ERROR_SUCCESS;

    CFaxServer * pFaxServer;

    FAX_OUTBOUND_ROUTING_GROUP   FaxGroupConfig;

    
    //
    // init the structure's fields and insert the new DeviceIdList  
    //
    ZeroMemory (&FaxGroupConfig, sizeof(FAX_OUTBOUND_ROUTING_GROUP));

    FaxGroupConfig.dwSizeOfStruct   = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
	FaxGroupConfig.lpctstrGroupName = m_bstrGroupName;
    FaxGroupConfig.dwNumDevices     = m_dwNumOfDevices - 1;
	FaxGroupConfig.Status           = m_enumStatus;

    FaxGroupConfig.lpdwDevices      = lpdwNewDeviceID;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);
        goto Error;
    }

    //
    // Set Config
    //
    if (!FaxSetOutboundGroup(
                pFaxServer->GetFaxServerHandle(),
                &FaxGroupConfig)) 
	{		
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set the group with new device list. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }
        
        goto Error;
    }

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to set device configuration."));
    

    goto Exit;

Error:
	ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);

    ATLASSERT(NULL != m_pParentNode);
    NodeMsgBox(GetFaxServerErrorMsg(ec));

Exit:    
    return(hRc);
}

/*
 -  CFaxOutboundRoutingGroupNode::DeleteDevice
 -
 *  Purpose:
 *      Delete Device from the group
 *
 *  Arguments:
 *      [in]    dwDeviceID - The device ID
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingGroupNode::DeleteDevice(DWORD dwDeviceIdToRemove, CFaxOutboundRoutingDeviceNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingDeviceNode::DeleteDevice"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    DWORD         dwIndex;    
    DWORD         dwNewIndex;    

    int           j;

    LPDWORD       lpdwNewDeviceID = NULL;
    LPDWORD       lpdwTmp;

    ATLASSERT( 0 < m_dwNumOfDevices);
    
    //
    // Step 1: create new DeviceID array
    //

    //
    // prepare for loop
    //

    lpdwTmp = &m_lpdwDeviceID[0];

    if ((m_dwNumOfDevices - 1) > 0 )
	{
		lpdwNewDeviceID = new DWORD[m_dwNumOfDevices - 1]; 
        if (NULL == lpdwNewDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfDevices - 1);
            hRc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }
	}
    
    dwNewIndex  = 0;
	for ( dwIndex = 0; dwIndex < m_dwNumOfDevices; dwIndex++, lpdwTmp++)
    {
        //
        // Safty check for last itaration
        //
        if ( dwNewIndex == (m_dwNumOfDevices-1) )
        {
            if ( dwDeviceIdToRemove != *lpdwTmp)
            {
				//unexpected error 
				DebugPrintEx( DEBUG_ERR,
					_T("Unexpected error - The device was not found."));
        
				ATLASSERT(0);

				hRc = S_FALSE;
				goto Error;
            }
            else //Device to remove found as the last one. Do nothing.
			{
				break;
			}
        }


        //
        // main operation
        //
        if ( dwDeviceIdToRemove != *lpdwTmp)
        {
            lpdwNewDeviceID[dwNewIndex] = *lpdwTmp;
			dwNewIndex++;
        }
        // else Found the device to delete. do noting.

    }



    //
    // Step 2: Insert the new device ID array to Group (via RPC)
    //
    
    //
    //          a) Call to Rpc Func.
    //
    hRc = SetNewDeviceList(lpdwNewDeviceID);
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to set the group with new device list. (RC: %0X8)"), 
			hRc);
        goto Error;
    }

    //
    //          b) Update Group class relevant members and the icon
    //
    
    // 0) Clear old DeviceID array
    if (m_dwNumOfDevices > 0 )
	{
		delete[] m_lpdwDeviceID;
		m_lpdwDeviceID = NULL;
	}

    // 1) update m_dwNumOfDevices
    --m_dwNumOfDevices;
    
    // 2) update m_lpdwDeviceID
    if (m_dwNumOfDevices > 0 )
	{
		m_lpdwDeviceID = new DWORD[m_dwNumOfDevices];
        if (NULL == m_lpdwDeviceID)
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Error allocating %ld device ids"),
                m_dwNumOfDevices);
            hRc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }
	    memcpy(m_lpdwDeviceID , lpdwNewDeviceID, sizeof(DWORD)*m_dwNumOfDevices) ;    
	}
    
    // 3) update icon
    if ( 0 == m_dwNumOfDevices)
    {
        m_enumStatus = FAX_GROUP_STATUS_EMPTY;
        InitIcons();
    }

    //
    // Step 3: Update MMC views 
    //
    //
    //           a) Remove Device from MMC result pane
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove Device from MMC views. (hRc: %08X)"),
			hRc);
        goto Error;
    }
    //
    //           -  Call the Device class destructor
    //
    delete pChildNode;

    //
    //           b) Update Order in the rest devices
    //
    ATLASSERT( m_ResultChildrenList.GetSize() == (int)m_dwNumOfDevices);
    for ( j = 0; j < (int)m_dwNumOfDevices; j++)
    {
        m_ResultChildrenList[j]->SetOrder((UINT)j+1, (UINT)m_dwNumOfDevices);
    }
    
    //
    //           c) Update the group views and the scope pane node itself 
    //
    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    hRc = m_pComponentData->m_spConsole->UpdateAllViews( NULL, NULL, NULL);
    if (FAILED(hRc))
    {
        DebugPrintEx( DEBUG_ERR,
		    _T("Unexpected error - Fail to UpdateAllViews."));
        NodeMsgBox(IDS_FAIL2UPDATEITEM_GROUP);
        
        goto Exit;
    }

    if ( 0 == m_dwNumOfDevices)
    {
        
        //
	// This will force MMC to redraw scope node
	//
        hRc = RefreshNameSpaceNode();
        if (FAILED(hRc))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Fail to RefreshNameSpaceNode. (hRc: %08X)"),
                 hRc);
            goto Error;
        }
        
    }

    ATLASSERT(S_OK == hRc);
    DebugPrintEx( DEBUG_MSG,
		_T("The device was removed successfully."));
    goto Exit;


Error:
	
    NodeMsgBox(IDS_FAIL_TO_REMOVE_DEVICE);
  
Exit:
    return hRc;
}


/*
 -  CFaxOutboundRoutingGroupNode::UpdateMenuState
 -
 *  Purpose:
 *      Overrides the ATL CSnapInItemImpl::UpdateMenuState
 *      which only have one line inside it "return;" 
 *      This function implements the grayed\ungrayed view for the 
 *      the Enable and the Disable menus.
 *
 *  Arguments:
 *
 *            [in]  id    - unsigned int with the menu IDM value
 *            [out] pBuf  - string 
 *            [out] flags - pointer to flags state combination unsigned int
 *
 *  Return:
 *      no return value - void function 
 */
void CFaxOutboundRoutingGroupNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::UpdateMenuState"));

    UNREFERENCED_PARAMETER (pBuf);     
    
    if (IDM_NEW_DEVICES == id)
    {
         if( 0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
         {
            *flags = MF_GRAYED;
         }
         else
         {
            *flags = MF_ENABLED;
         }
    }
    return;
}





/*
 -  CFaxOutboundRoutingGroupNode::RefreshNameSpaceNode
 -
 *  Purpose:
 *      Refresh the NameSpace fields of the node.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */

HRESULT CFaxOutboundRoutingGroupNode::RefreshNameSpaceNode()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::RefreshNameSpaceNode"));
    HRESULT     hRc = S_OK;

    ATLASSERT( m_pComponentData != NULL );
    ATLASSERT( m_pComponentData->m_spConsole != NULL );

    CComPtr<IConsole> spConsole;
    spConsole = m_pComponentData->m_spConsole;
    CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( spConsole );
    
    SCOPEDATAITEM*    pScopeData;

    //
    // Get the updated SCOPEDATAITEM
    //
    hRc = GetScopeData( &pScopeData );
    if (FAILED(hRc))
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to get pScopeData. (hRc: %08X)"),
			hRc);
        
        goto Error;
    }

    //
    // This will force MMC to redraw the scope group node
    //
    hRc = spNamespace->SetItem( pScopeData );
    if (FAILED(hRc))
    {
       DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to set Item pScopeData. (hRc: %08X)"),
			hRc);

        goto Error;
    }
    ATLASSERT( S_OK != hRc);
    
    goto Exit;

Error:
    NodeMsgBox(IDS_FAIL2REFRESH_GROUP);

Exit:
    return hRc;
}

/*
 +
 +  CFaxOutboundRoutingGroupNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingGroupNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_GROUPS);
}


///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundrouting.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRouting.h                                      //
//                                                                         //
//  DESCRIPTION   : Header file for CFaxOutboundRoutingNode class          //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDNODE_H
#define H_FAXOUTBOUNDNODE_H

#include "snapin.h"
#include "snpnscp.h" //#include "snpnode.h"

class CFaxServerNode;

class CFaxOutboundRoutingNode : public CNodeWithScopeChildrenList<CFaxOutboundRoutingNode, FALSE>
{
public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_SNAPIN_MENU)

    CFaxOutboundRoutingNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithScopeChildrenList<CFaxOutboundRoutingNode, FALSE>(pParentNode, pComponentData )
    {
    }

    ~CFaxOutboundRoutingNode()
    {
    }

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT PopulateScopeChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl* pHeaderCtrl);

    // virtual
    HRESULT OnRefresh(LPARAM arg,
                      LPARAM param,
                      IComponentData *pComponentData,
                      IComponent * pComponent,
                      DATA_OBJECT_TYPES type);

    void InitParentNode(CFaxServerNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    HRESULT InitDisplayName();


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo      m_ColsInfo;

    CFaxServerNode *         m_pParentNode;
};

//typedef CNodeWithScopeChildrenList<CFaxOutboundRoutingNode, FALSE>
//        CBaseFaxOutboundRoutingNode;


#endif  //H_FAXOUTBOUNDNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundrouting.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRouting.cpp                                    //
//                                                                         //
//  DESCRIPTION   : Fax Server - Fax OutboundRouting node.                 //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg   create                                         //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "OutboundRouting.h"

#include "OutboundRules.h" 
#include "OutboundGroups.h" 

#include "Icons.h"

//#include "oaidl.h"

/****************************************************

CFaxOutboundRoutingNode Class

 ****************************************************/

// {38B04E8F-9BA6-4a22-BEF3-9AD90E3349B2}
static const GUID CFaxOutboundRoutingNodeGUID_NODETYPE = 
{ 0x38b04e8f, 0x9ba6, 0x4a22, { 0xbe, 0xf3, 0x9a, 0xd9, 0xe, 0x33, 0x49, 0xb2 } };

const GUID*    CFaxOutboundRoutingNode::m_NODETYPE = &CFaxOutboundRoutingNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundRoutingNode::m_SZNODETYPE = OLESTR("38B04E8F-9BA6-4a22-BEF3-9AD90E3349B2");
const CLSID*   CFaxOutboundRoutingNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundRoutingNode::m_ColsInfo;

/*
 -  CFaxOutboundRoutingNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingNode::InsertColumns"));
    HRESULT hRc = S_OK;


    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_FAX_COL_HEAD, FXS_LARGE_COLUMN_WIDTH}, 
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    if (hRc != S_OK)
    {
        DebugPrintEx(DEBUG_ERR,_T("m_ColsInfo.InsertColumnsIntoMMC. (hRc: %08X)"), hRc);
        goto Cleanup;
    }

Cleanup:
    return(hRc);
}


/*
 -  CFaxOutboundRoutingNode::PopulateScopeChildrenList
 -
 *  Purpose:
 *      Create Out bound routing main nodes: Groups and Rules
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingNode::PopulateScopeChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingNode::PopulateScopeChildrenList"));
    HRESULT                  hRc      = S_OK; 

    CFaxOutboundGroupsNode * pGroups  = NULL;
    CFaxOutboundRoutingRulesNode *  pRules   = NULL;

    //
    // Fax OutboundGroups
    //
    pGroups = new CFaxOutboundGroupsNode(this, m_pComponentData);
    if (!pGroups)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pGroups->InitParentNode(this);
/*
        hRc = pGroups->InitRPC();
        if (FAILED(hRc))
        {
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to call RPC to init groups. (hRc: %08X)"),
			    hRc);
            goto Error;
        }
*/
        pGroups->SetIcons(IMAGE_FOLDER_CLOSE, IMAGE_FOLDER_OPEN);

        hRc = pGroups->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_ROUTINGGROUPS);
		    goto Error;
        }

        hRc = AddChild(pGroups, &pGroups->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add Devices node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_ROUTINGGROUPS);
            goto Error;
		}
	}

    //
    // Fax OutboundRules
    //
    pRules = new CFaxOutboundRoutingRulesNode(this, m_pComponentData);
    if (!pRules)
    {
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY);
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Out of memory"));
        goto Error;
    }
	else
	{
        pRules->InitParentNode(this);

        pRules->SetIcons(IMAGE_RULE, IMAGE_RULE);

        hRc = pRules->InitDisplayName();
        if ( FAILED(hRc) )
        {
            DebugPrintEx(DEBUG_ERR,_T("Failed to display node name. (hRc: %08X)"), hRc);                       
            NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
		    goto Error;
        }

        hRc = AddChild(pRules, &pRules->m_scopeDataItem);
		if (FAILED(hRc))
		{
		    DebugPrintEx(
			    DEBUG_ERR,
			    TEXT("Fail to add outbound routing rules node. (hRc: %08X)"),
			    hRc);
			NodeMsgBox(IDS_FAILTOADD_ROUTINGRULES);
            goto Error;
		}
	}

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pGroups ) 
    {
        if (0 != pGroups->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pGroups);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Groups node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pGroups;    
        pGroups = NULL;    
    }
    if ( NULL != pRules ) 
    {
        if (0 != pRules->m_scopeDataItem.ID )
        {    
            HRESULT hr = RemoveChild(pRules);
            if (FAILED(hr))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Fail to RemoveChild() Rules node from node list. (hRc: %08X)"), 
                    hr);
            }
        }
        delete  pRules;    
        pRules = NULL;    
    }

    // Empty the list
    //m_ScopeChildrenList.RemoveAll(); //Done by RemoveChild

    m_bScopeChildrenListPopulated = FALSE;

Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxOutboundRoutingNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingNode::OnRefresh"));
    HRESULT hRc = S_OK;

/*
    
    // TBD

*/
    return hRc;
}

/*
 -  CFaxOutboundRoutingNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                                IDS_DISPLAY_STR_OUTBOUNDROUTINGNODE) )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load Outbound routing node name-string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}


/*
 +
 +  CFaxOutboundRoutingNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_GROUPS); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundrule.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRule.h                                         //
//                                                                         //
//  DESCRIPTION   : Header file for the Outbound Routing Rule node.        //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 24 1999 yossg  Create                                          //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGRULE_H
#define H_FAXOUTBOUNDROUTINGRULE_H

#include "snapin.h"
#include "snpnode.h"

#include "Icons.h"


class CppFaxOutboundRoutingRule;
class CFaxOutboundRoutingRulesNode;

class CFaxOutboundRoutingRuleNode : public CSnapinNode <CFaxOutboundRoutingRuleNode, FALSE>
{

public:
    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingRuleNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingRuleNode)
    END_SNAPINTOOLBARID_MAP()

    //
    // Constructor
    //
    CFaxOutboundRoutingRuleNode (CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CSnapinNode<CFaxOutboundRoutingRuleNode, FALSE>(pParentNode, pComponentData )
    {
        m_fIsAllCountries = FALSE; 
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingRuleNode()
    {
    }

    LPOLESTR GetResultPaneColInfo(int nCol);

    void InitParentNode(CFaxOutboundRoutingRulesNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        IUnknown* pUnk,
        DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }
    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    virtual HRESULT OnDelete(LPARAM arg, 
                             LPARAM param,
                             IComponentData *pComponentData,
                             IComponent *pComponent,
                             DATA_OBJECT_TYPES type,
                             BOOL fSilent = FALSE);

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData * pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    
    DWORD      GetCountryCode()  { return m_dwCountryCode; }
    DWORD      GetAreaCode()     { return m_dwAreaCode; }
    DWORD      GetDeviceID()     { return m_dwDeviceID; }
    CComBSTR   GetGroupName()    { return m_bstrGroupName; }
    BOOL       GetIsGroup()      { return m_fIsGroup; }

    HRESULT    Init(PFAX_OUTBOUND_ROUTING_RULE pRuleConfig);

    // virtual
    HRESULT OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            );

    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:
    //
    // Parent Node
    //
    CFaxOutboundRoutingRulesNode * m_pParentNode;

    //
    // Property Pages
    //
    CppFaxOutboundRoutingRule * m_pRuleGeneralPP;

    //
    // members
    //
    DWORD                  m_dwCountryCode;
    DWORD                  m_dwAreaCode;

    CComBSTR               m_bstrCountryName;

    DWORD                  m_dwDeviceID;
    CComBSTR               m_bstrDeviceName;
    CComBSTR               m_bstrGroupName;

    BOOL                   m_fIsGroup;
    BOOL                   m_fIsAllCountries;

    FAX_ENUM_RULE_STATUS   m_enumStatus;
            
    CComBSTR               m_buf; 

    UINT     GetStatusIDS(FAX_ENUM_RULE_STATUS enumStatus);

    HRESULT  RefreshItemInView(IConsole *pConsole);

    //
    //  Init
    //
    HRESULT  InitMembers (PFAX_OUTBOUND_ROUTING_RULE pRuleConfig);

    DWORD    InitDeviceNameFromID (DWORD dwDeviceID);

    void     InitIcons ();
};

//typedef CSnapinNode<CFaxOutboundRoutingRuleNode, FALSE> CBaseFaxInboundRoutingMethodNode;

#endif  //H_FAXOUTBOUNDROUTINGRULE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxcataloginboundroutingmethod.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxCatalogInboundRoutingMethod.h                    //
//                                                                         //
//  DESCRIPTION   : Catalog's Inbox Routing Method Inbox property page     //
//                  header file.                                           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 30 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#ifndef _PP_FAXCATALOGINBOUNDROUTINGMETHOD_H_
#define _PP_FAXCATALOGINBOUNDROUTINGMETHOD_H_

#include "proppageex.h"
#include "CatalogInboundRoutingMethod.h"

class CFaxCatalogInboundRoutingMethodNode;    
/////////////////////////////////////////////////////////////////////////////
// CppFaxCatalogInboundRoutingMethod dialog

class CppFaxCatalogInboundRoutingMethod : public CPropertyPageExImpl<CppFaxCatalogInboundRoutingMethod>
{

public:
    //
    // Constructor
    //
    CppFaxCatalogInboundRoutingMethod(
             LONG_PTR       hNotificationHandle,
             CSnapInItem    *pNode,
             BOOL           bOwnsNotificationHandle,
             HINSTANCE      hInst);

    //
    // Destructor
    //
    ~CppFaxCatalogInboundRoutingMethod();

	enum { IDD = IDD_FAXCATALOGMETHOD_GENERAL };

	BEGIN_MSG_MAP(CppFaxCatalogInboundRoutingMethod)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )

        MESSAGE_HANDLER( WM_CONTEXTMENU,           OnHelpRequest)
        MESSAGE_HANDLER( WM_HELP,                  OnHelpRequest)

        CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CppFaxCatalogInboundRoutingMethod>)
	END_MSG_MAP()


    LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );
    BOOL    OnApply();

    HRESULT Init(CComBSTR bstrPath);

private:
    
    CComBSTR   m_bstrPath;

    LONG_PTR   m_lpNotifyHandle;
 
    LRESULT SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // Help
    //
    LRESULT OnHelpRequest    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};




#endif // _PP_FAXCATALOGINBOUNDROUTINGMETHOD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundrules.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRules.h                                        //
//                                                                         //
//  DESCRIPTION   : Header file for the Fax Outbound Routing Rules Node    //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Dec 24 1999 yossg  Reogenize as node with result children list     //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef H_FAXOUTBOUNDROUTINGRULES_H
#define H_FAXOUTBOUNDROUTINGRULES_H

#include "snapin.h"
#include "snpnres.h"

#include "OutboundRule.h"
 
class CFaxOutboundRoutingNode;
class CFaxOutboundRoutingRuleNode;

class CFaxOutboundRoutingRulesNode : public CNodeWithResultChildrenList<
                                        CFaxOutboundRoutingRulesNode,    
                                        CFaxOutboundRoutingRuleNode, 
                                        CSimpleArray<CFaxOutboundRoutingRuleNode*>, 
                                        FALSE>
{

public:

    BEGIN_SNAPINCOMMAND_MAP(CFaxOutboundRoutingRuleNode, FALSE)
      SNAPINCOMMAND_ENTRY(IDM_NEW_OUTRULE, OnNewRule)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CFaxOutboundRoutingRuleNode)
    END_SNAPINTOOLBARID_MAP()

    SNAPINMENUID(IDR_OUTRULES_MENU)

    //
    // Constructor
    //
    CFaxOutboundRoutingRulesNode(CSnapInItem * pParentNode, CSnapin * pComponentData) :
        CNodeWithResultChildrenList<CFaxOutboundRoutingRulesNode, CFaxOutboundRoutingRuleNode, CSimpleArray<CFaxOutboundRoutingRuleNode*>, FALSE>(pParentNode, pComponentData )
    {
        m_dwNumOfOutboundRules     = 0;
    }

    //
    // Destructor
    //
    ~CFaxOutboundRoutingRulesNode()
    {
    }

	//
	// get data from RPC 
	//
    HRESULT InitRPC(PFAX_OUTBOUND_ROUTING_RULE  *pFaxRulesConfig);

    virtual HRESULT PopulateResultChildrenList();

    virtual HRESULT InsertColumns(IHeaderCtrl *pHeaderCtrl);

    virtual HRESULT SetVerbs(IConsoleVerb *pConsoleVerb);

    void InitParentNode(CFaxOutboundRoutingNode *pParentNode)
    {
        m_pParentNode = pParentNode;
    }

    virtual HRESULT OnRefresh(LPARAM arg,
                              LPARAM param,
                              IComponentData *pComponentData,
                              IComponent * pComponent,
                              DATA_OBJECT_TYPES type);

    HRESULT DoRefresh(CSnapInObjectRootBase *pRoot);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if (type == CCT_SCOPE || type == CCT_RESULT)
            return S_OK;
        return S_FALSE;
    }

    HRESULT InitDisplayName();

    HRESULT DeleteRule(DWORD dwAreaCode, DWORD dwCountryCode, 
                        CFaxOutboundRoutingRuleNode *pChildNode);

    HRESULT OnNewRule (bool &bHandled, CSnapInObjectRootBase *pRoot);


    HRESULT OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile);

private:

    static CColumnsInfo         m_ColsInfo;
    
    DWORD                       m_dwNumOfOutboundRules;
        
    CFaxOutboundRoutingNode *   m_pParentNode;
};

typedef CNodeWithResultChildrenList<CFaxOutboundRoutingRulesNode, CFaxOutboundRoutingRuleNode, CSimpleArray<CFaxOutboundRoutingRuleNode*>, FALSE>
        CBaseFaxOutboundRulesNode;

#endif  //H_FAXOUTBOUNDROUTINGRULES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundrules.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRules.cpp                                      //
//                                                                         //
//  DESCRIPTION   : Fax Outbound Rules MMC node.                           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Sep 29 1999 yossg  Create                                          //
//      Dec 24 1999 yossg  Reogenize as node with result children list     //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "snapin.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "OutboundRules.h"
#include "OutboundRouting.h"
#include "dlgNewRule.h"

#include "oaidl.h"
#include "Icons.h"

//////////////////////////////////////////////////////////////
// {D17BA53F-0992-4404-8760-7D2933D9FC46}
static const GUID CFaxOutboundRoutingRulesNodeGUID_NODETYPE = 
{ 0xd17ba53f, 0x992, 0x4404, { 0x87, 0x60, 0x7d, 0x29, 0x33, 0xd9, 0xfc, 0x46 } };

const GUID*    CFaxOutboundRoutingRulesNode::m_NODETYPE = &CFaxOutboundRoutingRulesNodeGUID_NODETYPE;
const OLECHAR* CFaxOutboundRoutingRulesNode::m_SZNODETYPE = OLESTR("D17BA53F-0992-4404-8760-7D2933D9FC46");
const CLSID*   CFaxOutboundRoutingRulesNode::m_SNAPIN_CLASSID = &CLSID_Snapin;

CColumnsInfo CFaxOutboundRoutingRulesNode::m_ColsInfo;

/*
 -  CFaxOutboundRoutingRulesNode::InsertColumns
 -
 *  Purpose:
 *      Adds columns to the default result pane.
 *
 *  Arguments:
 *      [in]    pHeaderCtrl - IHeaderCtrl in the console-provided default result view pane 
 *
 *  Return:
 *      OLE error code
 */
HRESULT
CFaxOutboundRoutingRulesNode::InsertColumns(IHeaderCtrl *pHeaderCtrl)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::InsertColumns"));
    HRESULT  hRc = S_OK;

    static ColumnsInfoInitData ColumnsInitData[] = 
    {
        {IDS_OUTRRULES_COL1, AUTO_WIDTH},
        {IDS_OUTRRULES_COL2, AUTO_WIDTH},
        {IDS_OUTRRULES_COL3, FXS_WIDE_COLUMN_WIDTH},
        {IDS_OUTRRULES_COL4, AUTO_WIDTH},
        {LAST_IDS, 0}
    };

    hRc = m_ColsInfo.InsertColumnsIntoMMC(pHeaderCtrl,
                                         _Module.GetResourceInstance(),
                                         ColumnsInitData);
    CHECK_RETURN_VALUE_AND_PRINT_DEBUG (_T("m_ColsInfo.InsertColumnsIntoMMC"))

Cleanup:
    return(hRc);
}

/*
 -  CFaxOutboundRoutingRulesNode::initRPC
 -
 *  Purpose:
 *      Initiates the configuration structure from RPC get Call.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRulesNode::InitRPC(PFAX_OUTBOUND_ROUTING_RULE  *pFaxRulesConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::InitRPC"));
    
    HRESULT      hRc        = S_OK;
    DWORD        ec         = ERROR_SUCCESS;

    CFaxServer * pFaxServer = NULL;

    ATLASSERT(NULL == (*pFaxRulesConfig) );
    //
    // get Fax Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }
    

    //
	// Retrieve the fax Outbound Rules configuration
	//
    if (!FaxEnumOutboundRules(pFaxServer->GetFaxServerHandle(), 
                        pFaxRulesConfig,
                        &m_dwNumOfOutboundRules)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get Outbound Rules configuration. (ec: %ld)"), 
			ec);


        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }


        goto Error; 
    }
    //For max verification
    ATLASSERT(*pFaxRulesConfig);

    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get outbound rules configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
	hRc = HRESULT_FROM_WIN32(ec);
	
    ATLASSERT(NULL != m_pParentNode);
    m_pParentNode->NodeMsgBox(GetFaxServerErrorMsg(ec));
    
Exit:
    return (hRc);
}


/*
 -  CFaxOutboundRoutingRulesNode::PopulateResultChildrenList
 -
 *  Purpose:
 *      Create the FaxInboundRoutingMethods children nodes
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRulesNode::PopulateResultChildrenList()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::PopulateResultChildrenList"));
    HRESULT hRc = S_OK;

    CFaxOutboundRoutingRuleNode *   pRule = NULL;
                       
    PFAX_OUTBOUND_ROUTING_RULE  pFaxOutboundRulesConfig = NULL ;
    DWORD i;

    //
    // Get the Config. structure 
    //
    hRc = InitRPC(&pFaxOutboundRulesConfig);
    if (FAILED(hRc))
    {
        //DebugPrint and MsgBox by called func.
        
        //to be safe actually done by InitRPC on error.
        pFaxOutboundRulesConfig = NULL;
        
        goto Error;
    }
    ATLASSERT(NULL != pFaxOutboundRulesConfig);
    ATLASSERT(1 <= m_dwNumOfOutboundRules);

    
    for ( i=0; i< m_dwNumOfOutboundRules; i++ )
    {
            pRule = NULL;

            pRule = new CFaxOutboundRoutingRuleNode(this, m_pComponentData);
            if (!pRule)
            {
                hRc = E_OUTOFMEMORY;
                NodeMsgBox(IDS_MEMORY);
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. (hRc: %08X)"),
			        hRc);
                goto Error;
            }
            else
            {
	            pRule->InitParentNode(this);

                hRc = pRule->Init(&pFaxOutboundRulesConfig[i]);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to init rule node. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAIL2INIT_OUTBOUNDRULE);
                    goto Error;
	            }
	            hRc = this->AddChildToList(pRule);
	            if (FAILED(hRc))
	            {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Fail to add rule to the view. (hRc: %08X)"),
			            hRc);
		            NodeMsgBox(IDS_FAIL2ADD_OUTBOUNDRULE);
                    goto Error;
	            }
                else
                {
                    pRule = NULL;
                }
            }
    }
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != pRule ) 
    {
        delete  pRule;    
        pRule = NULL;    
    }
    
    //
    // Get rid of what we had.
    //
    {
        // Delete each node in the list of children
        int iSize = m_ResultChildrenList.GetSize();
        for (int j = 0; j < iSize; j++)
        {
            pRule = (CFaxOutboundRoutingRuleNode *)
                                    m_ResultChildrenList[j];
            ATLASSERT(pRule);
            delete pRule;
            pRule = NULL;
        }

        // Empty the list
        m_ResultChildrenList.RemoveAll();

        // We no longer have a populated list.
        m_bResultChildrenListPopulated = FALSE;
    }
    
Exit:
    if (NULL != pFaxOutboundRulesConfig)
    {
        FaxFreeBuffer(pFaxOutboundRulesConfig);
    }       
    
    return hRc;
}



/*
 -  CFaxOutboundRoutingRulesNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingRulesNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    //  Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

    //
    // We want the default verb to be expand node children
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); 

    return hRc;
}



/*
 -  CFaxOutboundRoutingRulesNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxOutboundRoutingRulesNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::OnRefresh"));
    HRESULT hRc = S_OK;


    //
    // Call the base class
    //
    hRc = CBaseFaxOutboundRulesNode::OnRefresh(arg,
                             param,
                             pComponentData,
                             pComponent,
                             type);
    if ( FAILED(hRc) )
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to call base class's OnRefresh. (hRc: %08X)"),
			hRc);
        goto Cleanup;
    }

Cleanup:

    return hRc;
}

/*
 -  CFaxOutboundRoutingRulesNode::OnNewRule
 -
 *  Purpose:
 *      
 *
 *  Arguments:
 *      [out]   bHandled - Do we handle it?
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */
HRESULT
CFaxOutboundRoutingRulesNode::OnNewRule(bool &bHandled, CSnapInObjectRootBase *pRoot)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRulesNode::OnNewRule"));
    HRESULT     hRc         =    S_OK;
    INT_PTR     rc          =    IDOK;

    CDlgNewFaxOutboundRule       DlgNewRule( ((CFaxServerNode *)GetRootNode())->GetFaxServer() );

    //
    // Dialog to add rule
    //
    hRc = DlgNewRule.InitRuleDlg();
    if (FAILED(hRc))
    {
        NodeMsgBox(IDS_FAIL2OPEN_DLG);
        return hRc;
    }

    rc = DlgNewRule.DoModal();
    if (rc != IDOK)
    {
        goto Cleanup;
    }


    //
    // Repopulate (with RPC) and Refresh the view
    //
    DoRefresh(pRoot);

Cleanup:
    return S_OK;
}


/*
 -  CFaxOutboundRoutingRulesNode::DoRefresh
 -
 *  Purpose:
 *      Refresh the view
 *
 *  Arguments:
 *      [in]    pRoot    - The root node
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingRulesNode::DoRefresh(CSnapInObjectRootBase *pRoot)
{
    CComPtr<IConsole> spConsole;

    //
    // Repopulate childs
    //
    RepopulateResultChildrenList();

    if (pRoot)
    {
        //
        // Get the console pointer
        //
        ATLASSERT(pRoot->m_nType == 1 || pRoot->m_nType == 2);
        if (pRoot->m_nType == 1)
        {
            //
            // m_ntype == 1 means the IComponentData implementation
            //
            CSnapin *pCComponentData = static_cast<CSnapin *>(pRoot);
            spConsole = pCComponentData->m_spConsole;
        }
        else
        {
            //
            // m_ntype == 2 means the IComponent implementation
            //
            CSnapinComponent *pCComponent = static_cast<CSnapinComponent *>(pRoot);
            spConsole = pCComponent->m_spConsole;
        }
    }
    else
    {
        ATLASSERT(m_pComponentData);
        spConsole = m_pComponentData->m_spConsole;
    }

    ATLASSERT(spConsole);
    spConsole->UpdateAllViews(NULL, NULL, NULL);

    return S_OK;
}


/*
 -  CFaxOutboundRoutingRulesNode::InitDisplayName
 -
 *  Purpose:
 *      To load the node's Displaed-Name string.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRulesNode::InitDisplayName()
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingRulesNode::InitDisplayName"));

    HRESULT hRc = S_OK;

    if (!m_bstrDisplayName.LoadString(_Module.GetResourceInstance(), 
                    IDS_DISPLAY_STR_OUTBOUNDRULES))
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    ATLASSERT( S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT( S_OK != hRc);

    m_bstrDisplayName = L"";

    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Fail to Load server name string."));
    NodeMsgBox(IDS_MEMORY);

Exit:
     return hRc;
}

/*
 -  CFaxOutboundRoutingRulesNode::DeleteRule
 -
 *  Purpose:
 *      Delete rule
 *
 *  Arguments:
 *      [in]    dwAreaCode - The Rule Area Code
 *      [in]    dwCountryCode - The Rule Country Code
 *      [in]    pChildNode - The node to be deleted
 *
 *  Return:
 *      OLE Error code
 */

HRESULT
CFaxOutboundRoutingRulesNode::DeleteRule(DWORD dwAreaCode, DWORD dwCountryCode, CFaxOutboundRoutingRuleNode *pChildNode)
{
    DEBUG_FUNCTION_NAME(_T("CFaxOutboundRoutingRulesNode::DeleteRule"));
    HRESULT       hRc        = S_OK;
    DWORD         ec         = ERROR_SUCCESS;

    CFaxServer *  pFaxServer = NULL;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
    // Remove with RPC from the server
    //
    if (!FaxRemoveOutboundRule (
	        pFaxServer->GetFaxServerHandle(),
	        dwAreaCode,
	        dwCountryCode))
    {
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to remove rule. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
    

    //
    // Remove from MMC result pane
    //
    ATLASSERT(pChildNode);
    hRc = RemoveChild(pChildNode);
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to remove rule. (hRc: %08X)"),
			hRc);
        NodeMsgBox(IDS_FAIL_TO_REMOVE_RULE);
        return hRc;
    }
    
    //
    // Call the rule destructor
    //
    delete pChildNode;
    
    ATLASSERT(ERROR_SUCCESS == ec);
    DebugPrintEx( DEBUG_MSG,
		_T("The rule was removed successfully."));
    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);
    hRc = HRESULT_FROM_WIN32(ec);
	
    NodeMsgBox(GetFaxServerErrorMsg(ec));
  
Exit:
    return hRc;
}

/*
 +
 +  CFaxOutboundRoutingRulesNode::OnShowContextHelp
 *
 *  Purpose:
 *      Overrides CSnapinNode::OnShowContextHelp.
 *
 *  Arguments:
 *
 *  Return:
 -      OLE error code
 -
 */
HRESULT CFaxOutboundRoutingRulesNode::OnShowContextHelp(
              IDisplayHelp* pDisplayHelp, LPOLESTR helpFile)
{
    return DisplayContextHelp(pDisplayHelp, helpFile, HLP_GROUPS);
}

///////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\ppfaxcataloginboundroutingmethod.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : CppFaxProviderGeneral.cpp                              //
//                                                                         //
//  DESCRIPTION   : prop pages of Catalog's Inbox Routing Method           //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Jan 30 2000 yossg  Created                                         //
//                                                                         //
//  Copyright (C) 1999 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSFxsSnp.h"

#include "ppFaxCatalogInboundRoutingMethod.h"
#include "FaxMMCGlobals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Constructor
//
CppFaxCatalogInboundRoutingMethod::CppFaxCatalogInboundRoutingMethod(
             LONG_PTR    hNotificationHandle,
             CSnapInItem *pNode,
             BOOL        bOwnsNotificationHandle,
             HINSTANCE   hInst)
             :   CPropertyPageExImpl<CppFaxCatalogInboundRoutingMethod>(pNode, NULL)
			                	
{
    m_lpNotifyHandle = hNotificationHandle;
}

//
// Destructor
//
CppFaxCatalogInboundRoutingMethod::~CppFaxCatalogInboundRoutingMethod()
{
    // Note - This needs to be called only once per property sheet.  
    // In our convention called in the general tab.
    if (NULL != m_lpNotifyHandle)
    {
        MMCFreeNotifyHandle(m_lpNotifyHandle);
        m_lpNotifyHandle = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CppFaxCatalogInboundRoutingMethod message handlers


/*
 -  CppFaxCatalogInboundRoutingMethod::Init
 -
 *  Purpose:
 *      Initiates all members
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
HRESULT CppFaxCatalogInboundRoutingMethod::Init(CComBSTR bstrPath)
{
    DEBUG_FUNCTION_NAME( _T("CppFaxCatalogInboundRoutingMethod::Init"));
    HRESULT hRc = S_OK;

    
    
    m_bstrPath = bstrPath;
    if (!m_bstrPath)
    {
		DebugPrintEx( DEBUG_ERR, _T("Null m_bstrPath - out of memory."));
        goto Error;
    }
    
    goto Exit;

Error:
    hRc = E_OUTOFMEMORY;

Exit:
    return hRc;
}

/*
 -  CppFaxCatalogInboundRoutingMethod::OnInitDialog
 -
 *  Purpose:
 *      Initiates all controls when dialog is called.
 *
 *  Arguments:
 *
 *  Return:
 *      
 */
LRESULT CppFaxCatalogInboundRoutingMethod::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CppFaxCatalogInboundRoutingMethod::PageInitDialog"));
    
	UNREFERENCED_PARAMETER( uiMsg );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( fHandled );
    
    //
    // Extension
    //
    SetDlgItemText(IDC_EXTENSION_DLL_EDIT, m_bstrPath);
    	
    return (1);

}

/*
 -  CppFaxCatalogInboundRoutingMethod::OnApply
 -
 *  Purpose:
 *      Calls PreApply and SetProp to Apply changes.
 *
 *  Arguments:
 *
 *  Return:
 *      TRUE or FALSE
 */
BOOL CppFaxCatalogInboundRoutingMethod::OnApply()
{

    return TRUE;
}


/*
 -  CppFaxCatalogInboundRoutingMethod::SetApplyButton
 -
 *  Purpose:
 *      set Apply buttom modified.
 *
 *  Arguments:
 *
 *  Return:
 *      1
 */
LRESULT CppFaxCatalogInboundRoutingMethod::SetApplyButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);  
    bHandled = TRUE;
    return(1);
}


//////////////////////////////////////////////////////////////////////////////
/*++

CppFaxServerSentItems::OnHelpRequest

This is called in response to the WM_HELP Notify 
message and to the WM_CONTEXTMENU Notify message.

WM_HELP Notify message.
This message is sent when the user presses F1 or <Shift>-F1
over an item or when the user clicks on the ? icon and then
presses the mouse over an item.

WM_CONTEXTMENU Notify message.
This message is sent when the user right clicks over an item
and then clicks "What's this?"

--*/

/////////////////////////////////////////////////////////////////////////////
LRESULT 
CppFaxCatalogInboundRoutingMethod::OnHelpRequest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
    DEBUG_FUNCTION_NAME(_T("CppFaxCatalogInboundRoutingMethod::OnHelpRequest"));
    
    switch (uMsg) 
    { 
        case WM_HELP: 
            WinContextHelp(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
            break;
 
        case WM_CONTEXTMENU: 
            WinContextHelp(::GetWindowContextHelpId((HWND)wParam), m_hWnd);
            break;            
    } 

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\admin\mmc\outboundrule.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : OutboundRule.cpp                                       //
//                                                                         //
//  DESCRIPTION   : Implementation of the Outbound Routing Rule node.      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Dec 24 1999 yossg  Create                                          //
//      Dec 30 1999 yossg  create ADD/REMOVE rule                          //
//      Oct 17 2000 yossg                                                  //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"

#include "snapin.h"

#include "OutboundRule.h"
#include "OutboundRules.h"

#include "ppFaxOutboundRoutingRule.h"

#include "FaxServer.h"
#include "FaxServerNode.h"

#include "FaxMMCPropertyChange.h"

#include "oaidl.h"
#include "urlmon.h"
#include "mshtmhst.h"
#include "exdisp.h"

/////////////////////////////////////////////////////////////////////////////
// {4A7636D3-13A4-4496-873F-AD5CB7360D3B}
static const GUID CFaxOutboundRoutingRuleNodeGUID_NODETYPE = 
{ 0x4a7636d3, 0x13a4, 0x4496, { 0x87, 0x3f, 0xad, 0x5c, 0xb7, 0x36, 0xd, 0x3b } };

const GUID*     CFaxOutboundRoutingRuleNode::m_NODETYPE        = &CFaxOutboundRoutingRuleNodeGUID_NODETYPE;
const OLECHAR*  CFaxOutboundRoutingRuleNode::m_SZNODETYPE      = OLESTR("4A7636D3-13A4-4496-873F-AD5CB7360D3B");
//const OLECHAR* CnotImplemented::m_SZDISPLAY_NAME = OLESTR("Outbound Routing Rules");
const CLSID*    CFaxOutboundRoutingRuleNode::m_SNAPIN_CLASSID  = &CLSID_Snapin;


/*
 -  CFaxOutboundRoutingRuleNode::Init
 -
 *  Purpose:
 *      Init all members icon etc.
 *
 *  Arguments:
 *      [in]    pRuleConfig - PFAX_OUTBOUND_ROUTING_RULE
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRuleNode::Init(PFAX_OUTBOUND_ROUTING_RULE pRuleConfig)
{

    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::Init"));
    HRESULT hRc = S_OK;

    ATLASSERT(pRuleConfig);

    hRc = InitMembers( pRuleConfig );
    if (FAILED(hRc))
    {
        DebugPrintEx(
		    DEBUG_ERR,
		    _T("Failed to InitMembers"));
        
        //NodeMsgBox done by called func.
        
        goto Exit;
    }
    ATLASSERT(SUCCEEDED(hRc));

    //
    // Icon
    //
    InitIcons();

Exit:
    return hRc;
}

/*
 -  CFaxOutboundRoutingRuleNode::InitIcons
 -
 *  Purpose:
 *      Private method that initiate icons
 *      due to the status member state.
 *
 *  Arguments:
 *      No.
 *
 *  Return:
 *      No.
 */
void CFaxOutboundRoutingRuleNode::InitIcons ()
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::InitIcons"));
    switch (m_enumStatus)
    {
        case FAX_RULE_STATUS_VALID:
            m_resultDataItem.nImage = IMAGE_RULE;
            break;
        case FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID:
            m_resultDataItem.nImage = IMAGE_RULE_WARNING;
            break;

        case FAX_RULE_STATUS_EMPTY_GROUP:
        case FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID:
        case FAX_RULE_STATUS_BAD_DEVICE:
            m_resultDataItem.nImage = IMAGE_RULE_ERROR;
            break;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            break; //currently 999

    } // endswitch (enumStatus)

    return;
}


/*
 -  CFaxOutboundRoutingRuleNode::InitMembers
 -
 *  Purpose:
 *      Private method to initiate members
 *      Must be called after init of m_pParentNode
 *
 *  Arguments:
 *      [in]    pRuleConfig - PFAX_OUTBOUND_ROUTING_RULE structure
 *
 *  Return:
 *      OLE error code
 */
HRESULT CFaxOutboundRoutingRuleNode::InitMembers(PFAX_OUTBOUND_ROUTING_RULE pRuleConfig)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::InitMembers"));
    HRESULT hRc = S_OK;

    int iCount;
    WCHAR buff[2*FXS_MAX_CODE_LEN+1];

    ATLASSERT(pRuleConfig);
    
    //    
    // status    
    //    
    m_enumStatus          = pRuleConfig->Status;

    //
    // Country code and name
    //
    m_dwCountryCode       = pRuleConfig->dwCountryCode;
    if (ROUTING_RULE_COUNTRY_CODE_ANY != m_dwCountryCode)
    {
        if (NULL != pRuleConfig->lpctstrCountryName)
        {
            m_bstrCountryName = pRuleConfig->lpctstrCountryName;
            //m_fIsAllCountries = FALSE; done at constructor. here only verify
            ATLASSERT( FALSE == m_fIsAllCountries );
        }    
        else  //special case 
        {
            // Service did not provide the country names of countries with IDs 
            // between 101 to 124
            
            //ec = GetCountryNameFromID(m_dwCountryCode);
            //if ( ERROR_SUCCESS != ec )
            //{
            //}
            m_bstrCountryName = L"";
            ATLASSERT( FALSE == m_fIsAllCountries );
        }
    }
    else  //ROUTING_RULE_COUNTRY_CODE_ANY == m_dwCountryCode
    {
            m_bstrCountryName = L"";
            m_fIsAllCountries = TRUE;
    }
    if ( !m_bstrCountryName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // area code
    //
    m_dwAreaCode          = pRuleConfig->dwAreaCode;

    //
    // Group/Device
    //
    m_fIsGroup            = pRuleConfig->bUseGroup;
    if ( m_fIsGroup )
    {
        m_bstrGroupName = pRuleConfig->Destination.lpcstrGroupName;
        if (!m_bstrGroupName)
        {
            hRc = E_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        m_dwDeviceID     = pRuleConfig->Destination.dwDeviceId;
        DWORD ec         = ERROR_SUCCESS; 
        ec = InitDeviceNameFromID(m_dwDeviceID);
        if ( ERROR_SUCCESS != ec )
        {
            if (ERROR_BAD_UNIT != ec) 
            {
                hRc = HRESULT_FROM_WIN32(ec);
            }
            else //The system cannot find the device specified
            {
                if ( FAX_RULE_STATUS_VALID != m_enumStatus)
                {
                    m_enumStatus = FAX_RULE_STATUS_BAD_DEVICE;
		            DebugPrintEx(
			            DEBUG_MSG,
			            TEXT("m_enumStatus was changed after ERROR_BAD_UNIT failure."));                    
                }
                //hRc stays S_OK !!! since we will intrduce this bad state
            }
            m_bstrDeviceName=L"???";
			//message box done by GetDeviceNameFromID
            goto Exit;
        }
        ATLASSERT(m_bstrDeviceName);
    }

    //
    // Pepare m_bstrDisplayName for NodeMsgBox
    //
    iCount = swprintf(buff, L"+%ld (%ld)", m_dwCountryCode, m_dwAreaCode);

    if( iCount <= 0 )
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to read CountryCode and/or AreaCode."));
        goto Error;
    }
    m_bstrDisplayName = buff;
    if (!m_bstrDisplayName)
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
     
    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);

    DebugPrintEx(
		DEBUG_ERR,
		_T("Failed to allocate string - out of memory"));

    ATLASSERT(NULL != m_pParentNode);
    if (NULL != m_pParentNode)
    {
        m_pParentNode->NodeMsgBox(IDS_MEMORY);
    }
    
Exit:
    return (hRc);
}

/*
 -  CFaxOutboundRoutingRuleNode::GetResultPaneColInfo
 -
 *  Purpose:
 *      Return the text for specific column
 *      Called for each column in the result pane
 *
 *  Arguments:
 *      [in]    nCol - column number
 *
 *  Return:
 *      String to be displayed in the specific column
 */
LPOLESTR CFaxOutboundRoutingRuleNode::GetResultPaneColInfo(int nCol)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetResultPaneColInfo"));
    HRESULT hRc = S_OK;

    UINT  idsStatus;
    int   iCount;
    WCHAR buffCountryCode[FXS_MAX_CODE_LEN+1];
    WCHAR buffAreaCode[FXS_MAX_CODE_LEN+1];

    m_buf.Empty();

    switch (nCol)
    {
    case 0:
        //
        // Country code
        //
        if (ROUTING_RULE_COUNTRY_CODE_ANY == m_dwCountryCode)
        {
            if (!m_buf.LoadString(IDS_COUNTRY_CODE_ANY))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load country code string."));
                goto Error;
            }
            return m_buf;
        }
        else
        {
            iCount = swprintf(buffCountryCode, L"%ld", m_dwCountryCode);

            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - CountryCode."));
                goto Error;
            }
            else
            {
                m_buf = buffCountryCode;
                return (m_buf);
            }
        }
    case 1:
        //
        // Area code
        //
        if (ROUTING_RULE_AREA_CODE_ANY == m_dwAreaCode)
        {
            if (!m_buf.LoadString(IDS_ALL_AREAS))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load area code string."));
                goto Error;
            }
            return m_buf;
        }
        else
        {
            iCount = swprintf(buffAreaCode, L"%ld", m_dwAreaCode);

            if( iCount <= 0 )
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Fail to read member - AreaCode."));
                goto Error;
            }
            else
            {
                m_buf = buffAreaCode;
                return (m_buf);
            }
        }

    case 2:
        //
        // Group/Device
        //
        if (m_fIsGroup)
        {
            if(0 == wcscmp(ROUTING_GROUP_ALL_DEVICES, m_bstrGroupName) )
            {
                if (!m_buf.LoadString(IDS_ALL_DEVICES))
                {
                    hRc = E_OUTOFMEMORY;
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Out of memory. Failed to all-devices group string."));
                    goto Error;
                }
                return m_buf;
            }
            else
            {
                if (!m_bstrGroupName)
                {
		            DebugPrintEx(
			            DEBUG_ERR,
			            TEXT("Null memeber BSTR - m_bstrGroupName."));
                    goto Error;
                }
                else
                {
                    return (m_bstrGroupName);
                }
            }
        }
        else
        {
            if (!m_bstrDeviceName)
            {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Null memeber BSTR - m_bstrDeviceName."));
                goto Error;
            }
            else
            {
                return (m_bstrDeviceName);
            }
        }

    case 3:
        //
        // Status
        //
        idsStatus = GetStatusIDS(m_enumStatus);
        if ( FXS_IDS_STATUS_ERROR == idsStatus)
        {
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Invalid Status value."));
                goto Error;
        }
        else
        {
            if (!m_buf.LoadString(idsStatus))
            {
                hRc = E_OUTOFMEMORY;
		        DebugPrintEx(
			        DEBUG_ERR,
			        TEXT("Out of memory. Failed to load status string."));
                goto Error;
            }
            return m_buf;
        }


    default:
        ATLASSERT(0); // "this number of column is not supported "
        return(L"");

    } // endswitch (nCol)

Error:
    return(L"???");

}


/*
 -  CFaxOutboundRoutingRuleNode::CreatePropertyPages
 -
 *  Purpose:
 *      Called when creating a property page of the object
 *
 *  Arguments:
 *      [in]    lpProvider - The property sheet
 *      [in]    handle     - Handle for notification
 *      [in]    pUnk       - Pointer to the data object
 *      [in]    type       - CCT_* (SCOPE, RESULT, ...)
 *
 *  Return:
 *      OLE error code
 */

HRESULT
CFaxOutboundRoutingRuleNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR                handle,
                                    IUnknown                *pUnk,
                                    DATA_OBJECT_TYPES       type)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::CreatePropertyPages"));
    HRESULT hRc = S_OK;

    ATLASSERT(lpProvider);
    ATLASSERT(type == CCT_RESULT || type == CCT_SCOPE);

    //
    // Initiate
    //
    m_pRuleGeneralPP = NULL;    

    //
    // General
    //
    m_pRuleGeneralPP = new CppFaxOutboundRoutingRule(
												 handle,
                                                 this,
                                                 TRUE,
                                                 _Module.GetResourceInstance());

	if (!m_pRuleGeneralPP)
	{
        hRc = E_OUTOFMEMORY;
        NodeMsgBox(IDS_MEMORY_FAIL_TO_OPEN_PP);
        goto Error;
	}
	
    hRc = m_pRuleGeneralPP->InitFaxRulePP(this);
    if (FAILED(hRc))
    {
		//DebugPrint by called func
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    hRc = lpProvider->AddPage(m_pRuleGeneralPP->Create());
    if (FAILED(hRc))
    {
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Fail to add property page for General tab. (hRc: %08X)"),
			hRc);
		NodeMsgBox(IDS_FAIL_TO_OPEN_PROP_PAGE);
        goto Error;
    }

    ATLASSERT(S_OK == hRc);
    goto Exit;

Error:
    ATLASSERT(S_OK != hRc);
    if ( NULL != m_pRuleGeneralPP ) 
    {
        delete  m_pRuleGeneralPP;    
        m_pRuleGeneralPP = NULL;    
    }

Exit:
    return hRc;
}


/*
 -  CFaxOutboundRoutingRuleNode::SetVerbs
 -
 *  Purpose:
 *      What verbs to enable/disable when this object is selected
 *
 *  Arguments:
 *      [in]    pConsoleVerb - MMC ConsoleVerb interface
 *
 *  Return:
 *      OLE Error code
 */
HRESULT CFaxOutboundRoutingRuleNode::SetVerbs(IConsoleVerb *pConsoleVerb)
{
    HRESULT hRc = S_OK;

    //
    // Display verbs that we support:
    // 1. Properties
    // 2. Delete
    // 3. Refresh
    //
    hRc = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    if (ROUTING_RULE_COUNTRY_CODE_ANY == m_dwCountryCode)
    {
		hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN,        FALSE);
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, INDETERMINATE, TRUE);
    }
    else
    {
        hRc = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED,       TRUE);
    }
    
    
    
    
    //    hRc = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);


    //
    // We want the default verb to be Properties
    //
    hRc = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    return hRc;
}


/*
 -  CFaxOutboundRoutingRuleNode::OnRefresh
 -
 *  Purpose:
 *      Called when refreshing the object.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
/* virtual */HRESULT
CFaxOutboundRoutingRuleNode::OnRefresh(LPARAM arg,
                   LPARAM param,
                   IComponentData *pComponentData,
                   IComponent * pComponent,
                   DATA_OBJECT_TYPES type)
{
    HRESULT             hRc = S_OK;
    CComPtr<IConsole>   spConsole;

    //
    // TBD - At The moment do nothing
    //

    return hRc;
}



/*
 -  CFaxOutboundRoutingRuleNode::GetStatusIDS
 -
 *  Purpose:
 *      Transslate Status to IDS.
 *
 *  Arguments:
 *
 *            [in]  enumStatus    - unsigned int with the menu IDM value
 *
 *  Return:
 *            IDS of related status message 
 */
UINT CFaxOutboundRoutingRuleNode::GetStatusIDS(FAX_ENUM_RULE_STATUS enumStatus)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetStatusIDS"));

    switch (enumStatus)
    {
        case FAX_RULE_STATUS_VALID:
            return IDS_STATUS_RULE_VALID;

        case FAX_RULE_STATUS_EMPTY_GROUP:
            return IDS_STATUS_RULE_EMPTY;

        case FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID:
            return IDS_STATUS_RULE_ALLDEVICESINVALID;

        case FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID:
            return IDS_STATUS_RULE_SOMEDEVICESINVALID;

        case FAX_RULE_STATUS_BAD_DEVICE:
            return IDS_STATUS_RULE_INVALID_DEVICE;

        default:
            ATLASSERT(0); // "this enumStatus is not supported "
            return(FXS_IDS_STATUS_ERROR); //currently 999

    } // endswitch (enumStatus)
}

/*
 -  CFaxOutboundRoutingRuleNode::InitDeviceNameFromID
 -
 *  Purpose:
 *      Transslate Device ID to Device Name and insert the data to
 *      m_bstrDeviceName
 *
 *  Arguments:
 *
 *            [in]  dwDeviceID    - device ID
 *
 *  Return:
 *            Error Code DWORD //OLE error message 
 */
DWORD CFaxOutboundRoutingRuleNode::InitDeviceNameFromID(DWORD dwDeviceID)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingRuleNode::GetDeviceNameFromID"));
    DWORD          ec         = ERROR_SUCCESS;

    CFaxServer *   pFaxServer = NULL;
    PFAX_PORT_INFO_EX    pFaxDeviceConfig = NULL ;
    
    //
    // get RPC Handle
    //   
    pFaxServer = ((CFaxServerNode *)GetRootNode())->GetFaxServer();
    ATLASSERT(pFaxServer);

    if (!pFaxServer->GetFaxServerHandle())
    {
        ec= GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to GetFaxServerHandle. (ec: %ld)"), 
			ec);

        goto Error;
    }

    //
	// Retrieve the Device configuration
	//
    if (!FaxGetPortEx(pFaxServer->GetFaxServerHandle(), 
                      m_dwDeviceID, 
                      &pFaxDeviceConfig)) 
	{
        ec = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			_T("Fail to get device configuration. (ec: %ld)"), 
			ec);

        if (IsNetworkError(ec))
        {
            DebugPrintEx(
			    DEBUG_ERR,
			    _T("Network Error was found. (ec: %ld)"), 
			    ec);
            
            pFaxServer->Disconnect();       
        }

        goto Error; 
    }
	//For max verification
	ATLASSERT(pFaxDeviceConfig);
    
    //
	// Retrieve the Device Name
	//
    m_bstrDeviceName = pFaxDeviceConfig->lpctstrDeviceName;
    if (!m_bstrDeviceName)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
	
    ATLASSERT(ec == ERROR_SUCCESS);
    DebugPrintEx( DEBUG_MSG,
		_T("Succeed to get device configuration."));

    goto Exit;

Error:
    ATLASSERT(ERROR_SUCCESS != ec);

    //Important!!!
    pFaxDeviceConfig = NULL;

    if (ERROR_BAD_UNIT != ec)
	{
	    NodeMsgBox(GetFaxServerErrorMsg(ec));
	}
	else
	{
            NodeMsgBox(IDS_FAIL_TO_DISCOVERDEVICENAME);
	}
    
    
Exit:
    if (NULL != pFaxDeviceConfig)
    {
        FaxFreeBuffer(pFaxDeviceConfig);
        pFaxDeviceConfig = NULL;
    }//any way function quits with memory allocation freed       

    return ec; 
}


/*
 -  CFaxOutboundRoutingRuleNode::OnDelete
 -
 *  Purpose:
 *      Called when deleting this node
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */

HRESULT CFaxOutboundRoutingRuleNode::OnDelete(
                 LPARAM arg,
                 LPARAM param,
                 IComponentData *pComponentData,
                 IComponent *pComponent,
                 DATA_OBJECT_TYPES type,
                 BOOL fSilent/* = FALSE*/

)
{
    DEBUG_FUNCTION_NAME( _T("CFaxOutboundRoutingGroupNode::OnDelete"));

    UNREFERENCED_PARAMETER (arg);
    UNREFERENCED_PARAMETER (param);
    UNREFERENCED_PARAMETER (pComponentData);
    UNREFERENCED_PARAMETER (pComponent);
    UNREFERENCED_PARAMETER (type);

    HRESULT     hRc = S_OK;


    //
    // Are you sure?
    //
    if (! fSilent)
    {
        //
        // 1. Use pConsole as owner of the message box
        //
        int res;
        NodeMsgBox(IDS_CONFIRM, MB_YESNO | MB_ICONWARNING, &res);

        if (IDNO == res)
        {
            goto Cleanup;
        }
    }

    //
    // validation of rule's AreaCode and CountryCode
    //
/*    if ( !m_bstrRuleName || L"???" == m_bstrRuleName)
    {
        NodeMsgBox(IDS_INVALID_GROUP_NAME);
        goto Cleanup;
    }
*/
    //
    // Delete it
    //
    ATLASSERT(m_pParentNode);
    hRc = m_pParentNode->DeleteRule(m_dwAreaCode,
	                                m_dwCountryCode,
                                    this);
    if ( FAILED(hRc) )
    {
        goto Cleanup;
    }

Cleanup:
    return hRc;
}


/*
 +
 +
 *
 *  CFaxOutboundRoutingRuleNode::OnPropertyChange
 *
 *
    In our implementation, this method gets called when the 
    MMCN_PROPERTY_CHANGE
    Notify message is sent for this node.
 *
    When the snap-in uses the MMCPropertyChangeNotify function to notify it's
    views about changes, MMC_PROPERTY_CHANGE is sent to the snap-in's
    IComponentData and IComponent implementations.
 *
 *
    Parameters

        arg
        [in] TRUE if the property change is for a scope pane item.

        lParam
        This is the param passed into MMCPropertyChangeNotify.


 *  Return Values
 *
 -
 -
 */
//////////////////////////////////////////////////////////////////////////////
HRESULT CFaxOutboundRoutingRuleNode::OnPropertyChange(
              LPARAM arg
            , LPARAM param
            , IComponentData * pComponentData
            , IComponent * pComponent
            , DATA_OBJECT_TYPES type
            )
{
    DEBUG_FUNCTION_NAME( _T("FaxOutboundRoutingRuleNode::OnPropertyChange"));
    HRESULT hRc = S_OK;
    CComPtr<IConsole>   spConsole;

    CFaxRulePropertyChangeNotification * pNotification;

    //
    // Encode Property Change Notification data
    //
    pNotification = reinterpret_cast<CFaxRulePropertyChangeNotification *>(param);
    ATLASSERT(pNotification);
    ATLASSERT( RuleFaxPropNotification == pNotification->enumType );

    m_dwCountryCode = pNotification->dwCountryCode;
    
    m_bstrCountryName = pNotification->bstrCountryName;
    if ( !m_bstrCountryName )
    {
        hRc = E_OUTOFMEMORY;
        goto Error;
    }
    
    m_dwAreaCode = pNotification->dwAreaCode;

    m_fIsGroup = pNotification->fIsGroup;
    if (m_fIsGroup)
    {
        m_bstrGroupName = pNotification->bstrGroupName;
    }
    else
    {
        m_dwDeviceID = pNotification->dwDeviceID;

        DWORD ec         = ERROR_SUCCESS; 
        ec = InitDeviceNameFromID(m_dwDeviceID);
        if ( ERROR_SUCCESS != ec )
        {
            if (ERROR_BAD_UNIT != ec) 
            {
                hRc = HRESULT_FROM_WIN32(ec);
            }
            else //The system cannot find the device specified
            {
                if ( FAX_RULE_STATUS_VALID != m_enumStatus)
                {
                    m_enumStatus = FAX_RULE_STATUS_BAD_DEVICE;
		            DebugPrintEx(
			            DEBUG_MSG,
			            TEXT("m_enumStatus was changed after ERROR_BAD_UNIT failure."));                    
                }
                //hRc stays S_OK !!! since we will intrduce this bad state
            }
            m_bstrDeviceName=L"???";
			//message box done by GetDeviceNameFromID
            goto Exit;
        }
        ATLASSERT(m_bstrDeviceName);
    }

        
    //
    // get IConsole
    //

//    if (pComponentData != NULL)
//    {
//         spConsole = (