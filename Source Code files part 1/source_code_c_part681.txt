't filtered out, add it to the combo
        // box and remember its handle
        dwErr = devGetDeviceHandle(hDevDatabase, i, &hDevice);
        if (dwErr == NO_ERROR) 
        {
            // For .Net 499405
            // If the device is already enabled, disable it first, 
            //  this device was not disabled when deleting the Incoming Connection
            //
            BOOL fEnabled = FALSE;

            dwErr = devGetDeviceEnable( hDevice, &fEnabled );
            if( NO_ERROR == dwErr )
            {
                if( fEnabled )
                {
                    devSetDeviceEnable( hDevice, FALSE);
                }
            }
            
            devGetDeviceName (hDevice, &pszName);
            
            dwIndex = (DWORD) SendMessage (
                                hwndCb, 
                                CB_ADDSTRING, 
                                0, 
                                (LPARAM)pszName);
                                
            SendMessage (
                hwndCb, 
                CB_SETITEMDATA, 
                dwIndex, 
                (LPARAM)hDevice);

            // If this is the device to select, remember that fact
            if (hDevice == hDevSelect)
            {
                dwSelect = j;
            }
            
            j++;
        }
    }

    ComboBox_SetCurSel(hwndCb, dwSelect); 

    return NO_ERROR;
}

//
// Initializes the dcc device wizard tab.
//
DWORD 
DccdevWizInitializeDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam) 
{
    HANDLE hDevDatabase = NULL, hDevice = NULL;
    DWORD dwStatus, dwErr, dwCount, i;
    BOOL bEnabled;
    DCCDEV_DATA * pDcData;

    // Whenever the dcc device page is left, the currently selected device
    // is remembered and its original enabling is recorded.  Then this device
    // is set to enabled.  Whenever the page is activated, the remembered 
    // device is restored to its original enabling state if it is still 
    // enabled.
    //
    // This whole process is a little confusing, but it ensures that the dcc
    // device page will interact correctly when the user goes down the dcc 
    // path and then the incoming path and back and forth.
    //
    if ((pDcData = RassrvAlloc (sizeof(DCCDEV_DATA), TRUE)) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    
    // Add the com ports as devices and filter out all non dcc 
    // devices from the device database
    devFilterDevices(hDevDatabase, INCOMING_TYPE_DIRECT);
    devAddComPorts(hDevDatabase);
    
    // Get the count of devices
    if ((dwErr = devGetDeviceCount(hDevDatabase, &dwCount)) != NO_ERROR)
    {
        return dwErr;
    }
        
    // Get the handle to the first device if any 
    for (i = 0; i < dwCount; i++) 
    {
        if (devGetDeviceHandle (hDevDatabase, i, &hDevice) == NO_ERROR)
        {
            break;
        }
    }

    // Record the device's enabling -- index is 0 (default)
    if (hDevice) 
    {
        dwErr = devGetDeviceEnable (hDevice, &(pDcData->bEnabled));
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        
        pDcData->hDevice = hDevice;
    }

    // Record the status bits
    SetWindowLongPtr (hwndDlg, GWLP_USERDATA, (LONG_PTR)pDcData);
    
    return NO_ERROR;
}

//
// Cleans up the dcc device wizard
//
DWORD 
DccdevWizCleanupDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    DCCDEV_DATA * pDcData = 
        (DCCDEV_DATA *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        
    if (pDcData)
    {
        RassrvFree (pDcData);
    }
        
    return NO_ERROR;  
}

// 
// Called to do any processing when the dcc wizard device page is 
// gaining focus
//
DWORD 
DccdevWizSetActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL;
    BOOL bEnabled;
    DCCDEV_DATA * pDcData;
    
    // Whenever the page is activated, the remembered device 
    // is restored to its original enabling state if it is still enabled.
    pDcData = (DCCDEV_DATA*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (pDcData && pDcData->hDevice) 
    {
        if (devGetDeviceEnable (pDcData->hDevice, &bEnabled) == NO_ERROR) 
        {
            if (bEnabled)
            {
                devSetDeviceEnable (pDcData->hDevice, pDcData->bEnabled);
            }
        }
    }
    
    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle (hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    
    // Fill the device combo box
    DccdevFillDeviceList (
        hwndDlg, 
        hDevDatabase, 
        (pDcData) ? pDcData->hDevice : NULL);
    
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
    
    return NO_ERROR;
}

//
// Called to do any processing when the dcc wizard device 
// page is loosing focus
//
DWORD 
DccdevWizKillActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL, hDevice = NULL;
    DCCDEV_DATA * pDcData;
    INT iCurSel = -1;
    HWND hwndCb = GetDlgItem (hwndDlg, CID_Wizard_Dccdev_LB_Devices);
    DWORD dwErr; 
    
    // Whenever the dcc device page is left, the currently selected 
    // device is remembered and its original enabling is recorded.  
    // Then this device is set to enabled.  
    pDcData = (DCCDEV_DATA*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (pDcData) 
    {
        if (hwndCb)
        {
            iCurSel = ComboBox_GetCurSel(hwndCb);
        }

        if (iCurSel != -1) 
        {
            if (hwndCb)
            {
                hDevice = (HANDLE) ComboBox_GetItemData(hwndCb, iCurSel);
            }
            dwErr = devGetDeviceEnable (hDevice, &(pDcData->bEnabled));
            if (dwErr == NO_ERROR) 
            {
                pDcData->hDevice = hDevice;
                devSetDeviceEnable (hDevice, TRUE);
            }
        }
        else 
        {
            pDcData->hDevice = NULL;
        }
    }

    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);

    // Undo the filter so that other pages aren't affected
    //devFilterDevices(
    //    hDevDatabase, 
    //    0xffffffff);

    return NO_ERROR;
}

//
// Called to cancel the edit operation on the dcc host 
// device wizard tab.
// 
DWORD 
DccdevWizCancelEdit(
    IN HWND hwndDlg, 
    IN NMHDR* pNotifyData)  
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    
    DbgOutputTrace("Rolling back dcc device wizard tab.");
    
    // Cancel the commit on the device database
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);
        
    dwErr = devRollbackDatabase(hDevDatabase);
    if (dwErr != NO_ERROR)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_GENERAL_CANT_ROLLBACK_CHANGES, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
    }

    return NO_ERROR;    
}

//
// Raises properties for a component
//
DWORD 
DccdevWizRaiseProperties (
    IN HWND hwndDlg, 
    IN HWND hwndLb,
    IN INT  iItem) 
{
    HANDLE hDevice;
    DWORD dwErr = NO_ERROR, dwId;
    MSGARGS MsgArgs;
    BOOL bIsComPort = FALSE;

    // Get a handle to the device
    hDevice = (HANDLE) ComboBox_GetItemData(hwndLb, iItem);
    if (hDevice == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Find out if the device is a com port which has not yet had a
    // null modem installed.
    //
    dwErr = devDeviceIsComPort(hDevice, &bIsComPort);
    if (dwErr != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If so, popup info to the user explaining
    // the situation.
    //
    if (bIsComPort)
    {
        ZeroMemory(&MsgArgs, sizeof(MsgArgs));

        MsgArgs.dwFlags = MB_OK | MB_ICONINFORMATION;
        MsgDlgUtil(
            hwndDlg,
            SID_COM_PORT_NOT_ENABLED,
            &MsgArgs,
            Globals.hInstDll,
            SID_DEFAULT_MSG_TITLE);
            
        return NO_ERROR;
    }

    // Get the tapi id of the device
    if (devGetDeviceId(hDevice, &dwId) != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    // Launch the device properties dialog
    dwErr = lineConfigDialogW(dwId, hwndDlg, NULL);
    if (dwErr == LINEERR_OPERATIONUNAVAIL)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_DEVICE_HAS_NO_CONFIG, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
        dwErr = NO_ERROR;
    }
    
    return dwErr;
}

//
// Called when "iItem" is being selected to enable or disable the
// properties button.
//
DWORD 
DccdevWizEnableDisableProperties(
    IN HWND hwndDlg, 
    IN HWND hwndLb,
    IN INT iItem)
{
    return NO_ERROR;
}

//
// Called to cancel the edit operation on the dcc host 
// device wizard tab.
//
DWORD 
DccdevWizCommand(
    HWND hwndDlg, 
    WPARAM wParam, 
    LPARAM lParam)  
{
    switch (LOWORD(wParam))
    {
        case CID_Dccdev_PB_Properties:
        {
            HWND hwndLb;

            hwndLb = GetDlgItem(hwndDlg, CID_Wizard_Dccdev_LB_Devices);
            if (hwndLb)
            {
                DccdevWizRaiseProperties(
                    hwndDlg, 
                    hwndLb,
                    ComboBox_GetCurSel(hwndLb));
            }
        }
        break;

        case CID_Wizard_Dccdev_LB_Devices:
        {
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                DccdevWizEnableDisableProperties(
                    hwndDlg, 
                    (HWND)lParam,
                    ComboBox_GetCurSel((HWND)lParam));
            }
        }
        break;
    }
    
    return NO_ERROR;
}

INT_PTR 
CALLBACK 
DccdevWizDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    // Filter the customized ras server ui page 
    // messages. By filtering messages through
    // here, we are able to call RasSrvGetDatabaseHandle 
    // below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
        return TRUE;

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code) 
            {
                case PSN_RESET:                    
                    DccdevWizCancelEdit(hwndDlg, (NMHDR*)lParam);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;
                    
                case PSN_SETACTIVE:
                    {
                        DWORD dwErr; 

                        if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                        {
                            DccdevWizInitializeDialog(hwndDlg, wParam);
                        }
                        
                        dwErr = DccdevWizSetActive (
                                    hwndDlg, 
                                    wParam, 
                                    lParam);
                        if (dwErr != NO_ERROR)
                        {
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                        }
                    }
                    break;
                    
                case PSN_KILLACTIVE:
                    DccdevWizKillActive (hwndDlg, wParam, lParam);
                    break;
            }
            break;//for bug 187918

        case WM_COMMAND:
            DccdevWizCommand(hwndDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            DccdevWizCleanupDialog(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}

//
// Handles the activation of the switch to mmc wizard page.
//
DWORD 
SwitchMmcWizSetActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    PWCHAR pszTitle;
    PWCHAR pszMessage;
    INT iRet;

    // Load the messages to display
    pszTitle = (PWCHAR) 
        PszLoadString(Globals.hInstDll, WRN_WIZARD_NOT_ALLOWED_TITLE);
        
    pszMessage = (PWCHAR) 
        PszLoadString(Globals.hInstDll, WRN_WIZARD_NOT_ALLOWED_MSG);

    iRet = MessageBox (
                hwndDlg, 
                pszMessage, 
                pszTitle, 
                MB_YESNO | MB_ICONINFORMATION); 
    if (iRet == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // If yes was pressed, switch to mpradmin snapin.
    if (iRet == IDYES) 
    {
        RasSrvLeaveServiceRunning (hwndDlg);
        PropSheet_PressButton (GetParent (hwndDlg), PSBTN_CANCEL);
        RassrvLaunchMMC (RASSRVUI_MPRCONSOLE);
    }

    // Otherwise, display the welcome page
    else if (iRet == IDNO) 
    {
        PropSheet_PressButton (GetParent (hwndDlg), PSBTN_BACK);
    }

    // No matter what, don't accept activation
    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    return NO_ERROR;
}

// This dialog procedure responds to messages sent to the 
// switch to mmc wizard tab.
INT_PTR 
CALLBACK 
SwitchMmcWizDialogProc (
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    // Filter the customized ras server ui page messages. By filtering 
    // messages through here, we are able to call RasSrvGetDatabaseHandle 
    // below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
        return TRUE;

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code) 
            {
                case PSN_SETACTIVE:
                    return SwitchMmcWizSetActive (hwndDlg, wParam, lParam);
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\test\main.c ===
/*
    Main.c

    Tests the dialup server ui.

    Paul Mayfield, 9/30/97
*/
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <rasuip.h>
#include <rassrvp.h>

#define mbtowc(wname, aname) MultiByteToWideChar(CP_ACP,0,aname,-1,wname,1024)

BOOL TempFunc(int argc, char ** argv);

// Error reporting
void PrintErr(DWORD err) {
        WCHAR buf[1024];
        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,(DWORD)NULL,buf,1024,NULL);
        wprintf(buf);
        wprintf(L"\n");
}

// Function adds pages to a property sheet
BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM lParam) {
    PROPSHEETHEADER * pHeader = (PROPSHEETHEADER*)lParam;
    HPROPSHEETPAGE * phpage = pHeader->phpage;
    DWORD i;

    // Increment
    pHeader->nPages++;

    // Resize
    pHeader->phpage = (HPROPSHEETPAGE *) malloc(sizeof(HPROPSHEETPAGE) * pHeader->nPages);
    if (!pHeader->phpage)
        return FALSE;

    // Copy
    for (i = 0; i < pHeader->nPages - 1; i++) 
        pHeader->phpage[i] = phpage[i];
    pHeader->phpage[i] = hPage;

    // Free
    if (phpage)
        free(phpage);

    return TRUE;
}

// Displays the properties ui of the dialup server
DWORD DisplayUI() {
    PROPSHEETHEADER header;
    DWORD dwErr;
/*
    ZeroMemory(&header, sizeof(header));
    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK;
    header.hwndParent = GetFocus();
    header.hInstance = GetModuleHandle(NULL);
    header.pszCaption = "Incoming Connections";
    header.nPages = 0;
    header.ppsp = NULL;

    // Add the property pages and display
    if ((dwErr = RasSrvAddPropPages(NULL, AddPageProc, (LPARAM)&header)) == NO_ERROR) {
        int iErr;
        iErr = PropertySheet(&header);
        if (iErr == -1)
            PrintErr(GetLastError());
    }
*/
    return NO_ERROR;
}

DWORD DisplayWizard() {
    PROPSHEETHEADER header;
    DWORD dwErr;
    int iErr;
/*
    // Initialize the header
    ZeroMemory(&header, sizeof(header));
    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK | PSH_WIZARD97;
    header.hwndParent = GetFocus();
    header.hInstance = GetModuleHandle(NULL);
    header.pszCaption = "Incoming Connections";
    header.nPages = 0;
    header.ppsp = NULL;

    // Add the wizard pages
    if ((dwErr = RasSrvAddWizPages(AddPageProc, (LPARAM)&header)) != NO_ERROR)
        return dwErr;
        
    // Display the property sheet
    iErr = PropertySheet(&header);
    if (iErr == -1)
        PrintErr(GetLastError());
*/
    return NO_ERROR;
}

DWORD DisplayDccWizard() {
/*
    PROPSHEETHEADER header;
    DWORD dwErr;
    int iErr;

    // Initialize the header
    ZeroMemory(&header, sizeof(header));
    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK | PSH_WIZARD97;
    header.hwndParent = GetFocus();
    header.hInstance = GetModuleHandle(NULL);
    header.pszCaption = "Incoming Connections";
    header.nPages = 0;
    header.ppsp = NULL;

    // Add the wizard pages
    if ((dwErr = RassrvAddDccWizPages(AddPageProc, (LPARAM)&header)) != NO_ERROR)
        return dwErr;
        
    // Display the property sheet
    iErr = PropertySheet(&header);
    if (iErr == -1)
        PrintErr(GetLastError());

    return NO_ERROR;
*/
    RasUserPrefsDlg ( NULL );
    
    return NO_ERROR;
}

// Enumerates the active connections
void EnumConnections () {
    RASSRVCONN pConnList[3];
    DWORD dwTot = 3, dwSize = dwTot * sizeof (RASSRVCONN), i, dwErr;

    if ((dwErr = RasSrvEnumConnections((LPVOID)&pConnList, &dwSize, &dwTot)) != NO_ERROR)
        PrintErr(dwErr);
    else {
        for (i=0; i < dwTot; i++)
            wprintf(L"Connection: %s\n", pConnList[i].szEntryName);
    }
}

// Finds the given connection structure in a list.  pConn will point to the
// appropriate structure on success, otherwise it will point to NULL.  If an
// error occurs, DWORD will contain an error code, otherwise NO_ERROR.
DWORD FindConnectionInList(LPRASSRVCONN lprassrvconn, DWORD dwEntries, PWCHAR pszConnName, LPRASSRVCONN * pConn) {
    DWORD i;

    if (!pConn || !lprassrvconn)
        return ERROR_INVALID_PARAMETER;

    for (i = 0; i < dwEntries; i++) {
        if (wcscmp(lprassrvconn[i].szEntryName, pszConnName) == 0) {
            *pConn = &(lprassrvconn[i]);
            break;
        }
    }

    return NO_ERROR;
}

DWORD HangupConnection(char * pszAConnectionName) {
    WCHAR pszConnectionName[1024];
    RASSRVCONN pConnList[20], *pConn;
    DWORD dwTot = 20, dwSize = dwTot * sizeof (RASSRVCONN), i, dwErr;

    mbtowc(pszConnectionName, pszAConnectionName);
    if ((dwErr = RasSrvEnumConnections((LPVOID)&pConnList, &dwSize, &dwTot)) != NO_ERROR)
        return dwErr;
    
    if ((dwErr = FindConnectionInList(pConnList, dwTot, pszConnectionName, &pConn)) != NO_ERROR)
        return dwErr;

    return RasSrvHangupConnection(pConn->hRasSrvConn);
}

// Displays status of the given active connection
DWORD StatusUI(char * pszAConnectionName) {
    printf("Multilink status will not be included in connections.\n");
    return NO_ERROR;
}    
/*
#define numPages 1
    PROPSHEETHEADER header;
    PROPSHEETPAGE   pPages[numPages];
    WCHAR pszConnectionName[1024];
    RASSRVCONN pConnList[20], *pConn;
    DWORD dwTot = 20, dwSize = dwTot * sizeof (RASSRVCONN), i, dwErr;

    mbtowc(pszConnectionName, pszAConnectionName);
    if ((dwErr = RasSrvEnumConnections((LPVOID)&pConnList, &dwSize, &dwTot)) != NO_ERROR)
        return dwErr;
    
    if ((dwErr = FindConnectionInList(pConnList, dwTot, pszConnectionName, &pConn)) != NO_ERROR)
        return dwErr;

    if (pConn) {
        // Get the property sheet page of the user
        dwErr = RasSrvAddPropPage(&(pPages[0]), RASSRVUI_MULTILINK_TAB, (DWORD)pConn->hRasSrvConn);
        if (dwErr != NO_ERROR)
            return dwErr;

        ZeroMemory(&header, sizeof(header));
        header.dwSize = sizeof(PROPSHEETHEADER);
        header.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK;
        header.hwndParent = GetFocus();
        header.hInstance = GetModuleHandle(NULL);
        header.pszCaption = "Multilink Statistics";
        header.nPages = numPages;
        header.ppsp = pPages;

        // Display the property sheet
        PropertySheet(&header);
    }
    else {
        wprintf(L"Unable to find connection: %s\n", pszConnectionName);
        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
#undef numPages
}
*/

DWORD DeleteIcon() {
    DWORD dwErr;
   
    printf("Stopping remote access service... ");
    dwErr = RasSrvCleanupService();
    if (dwErr == NO_ERROR)
        printf("Success.\n");
    else 
        printf("\n");

    return dwErr;
}


char * GetParam(char * buf) {
    char * ptr = strstr(buf, " ");
    ptr++;
    return ptr;
}

DWORD RunScript(char * filename) {
    FILE * f;
    char buf[256];
    DWORD dwErr;

    f = fopen(filename, "r");
    if (!f)
        return ERROR_OPEN_FAILED;

    while (fgets(buf, 256, f)) {
        if (buf[strlen(buf)-1] == '\n')
            buf[strlen(buf)-1] = 0;
        if (strncmp(buf, "-e", 2) == 0)
            EnumConnections();
        else if (strncmp(buf, "-p", 2) == 0) {
            if ((dwErr = DisplayUI()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-s", 2) == 0) {
            if ((dwErr = StatusUI(GetParam(buf))) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-h", 2) == 0) {
            if ((dwErr = HangupConnection(GetParam(buf))) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-r", 2) == 0) {
            if ((dwErr = RunScript(GetParam(buf))) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-w", 2) == 0) {
            if ((dwErr = DisplayWizard()) != NO_ERROR)
                PrintErr(dwErr);
        }
    }

    fclose(f);

    return NO_ERROR;
}

// usage
void usage (char * prog) {
    printf("\n");
    printf("Usage\n=====\n");
    printf("%s -d         \t Deletes the incoming connect icon (stop service).\n", prog);
    printf("%s -e         \t Enumerates the active connections.\n", prog);
    printf("%s -h <user>  \t Disconnects the given user.\n", prog);
    printf("%s -p         \t Brings up the dialup server properties page.\n", prog);
    printf("%s -r <script>\t Runs the commands in the given script file.\n", prog);
    printf("%s -s <user>  \t Shows multilink status for the given connected user.\n", prog);
    printf("%s -w         \t Runs incoming connections wizard.\n", prog);
    printf("\n");
    printf("Examples\n========\n");
    printf("%s -h \"pmay (Paul Mayfield)\" \n", prog);
    printf("%s -s \"rosemb (Rose Bigham)\" \n", prog);
    printf("%s -r script1.txt\n", prog);
}

void RunTest(int argc, char ** argv) {
    DWORD dwErr;

    if (argc < 2) 
        usage(argv[0]);
    else {
        if (strcmp(argv[1], "-e") == 0)
            EnumConnections();
        else if (strcmp(argv[1], "-p") == 0) {
            if ((dwErr = DisplayUI()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strcmp(argv[1], "-d") == 0) {
            if ((dwErr = DeleteIcon()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if ((argc > 2) && (strcmp(argv[1], "-s") == 0)) {
            if ((dwErr = StatusUI(argv[2])) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if ((argc > 2) && (strcmp(argv[1], "-h") == 0)) {
            if ((dwErr = HangupConnection(argv[2])) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if ((argc > 2) && (strcmp(argv[1], "-r") == 0)) {
            if ((dwErr = RunScript(argv[2])) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strcmp(argv[1], "-w") == 0) {
            if ((dwErr = DisplayWizard()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strcmp(argv[1], "-c") == 0) {
            if ((dwErr = DisplayDccWizard()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else
            usage(argv[0]);
    }
}

// Main function dispatches all of the work
int _cdecl main (int argc, char ** argv) {
    if (! TempFunc(argc, argv))
        RunTest(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\if.c ===
#include "precomp.h"

extern WCHAR IfNamBuffer[MaxIfDisplayLength];
DWORD IfNamBufferLength=1024;

ENUM_TO_STR     InterfaceTypes[] = {
    { ROUTER_IF_TYPE_CLIENT,        VAL_IFTYPE_CLIENT },
    { ROUTER_IF_TYPE_HOME_ROUTER,   VAL_IFTYPE_HOME_ROUTER },
    { ROUTER_IF_TYPE_FULL_ROUTER,   VAL_IFTYPE_FULL_ROUTER },
    { ROUTER_IF_TYPE_DEDICATED,     VAL_IFTYPE_DEDICATED },
    { ROUTER_IF_TYPE_INTERNAL,      VAL_IFTYPE_INTERNAL},
    { ROUTER_IF_TYPE_LOOPBACK,      VAL_IFTYPE_LOOPBACK},
    { ROUTER_IF_TYPE_TUNNEL1,       VAL_IFTYPE_TUNNEL1},
};

ENUM_TO_STR     InterfaceStates[] = {
    { ROUTER_IF_STATE_DISCONNECTED, VAL_IFSTATE_DISCONNECTED },
    { ROUTER_IF_STATE_CONNECTING, VAL_IFSTATE_CONNECTING },
    { ROUTER_IF_STATE_CONNECTED, VAL_IFSTATE_CONNECTED }
};

ENUM_TO_STR     InterfacePersistency[] = {
    { FALSE,    VAL_NO },
    { TRUE,     VAL_YES }
};

ENUM_TO_STR     InterfaceEnableStatus[] = {
    { FALSE,    VAL_ENABLED },
    { TRUE,     VAL_DISABLED }
};

ENUM_TO_STR     TransportIds[] = {
    { PID_IP,   TOKEN_IP },
    { PID_IPX,  TOKEN_IPX }
};

#define LOCAL_ROUTER_PB_PATHW  L"%SystemRoot%\\system32\\RAS\\Router.Pbk"
#define REMOTE_ROUTER_PB_PATHW L"\\\\%ls\\Admin$\\system32\\RAS\\Router.Pbk"

int
UpdateInterface (
    IN  LPTSTR              InterfaceName,
    IN  DWORD               pid
    );

int
CreateInterface (
    IN  INT                 argc,
    IN  LPTSTR              *argv
    );

int
DeleteInterface (
    IN  LPTSTR              InterfaceName
    );

int
SetInterface (
    IN  LPTSTR              InterfaceName,
    IN  LPTSTR              UserName,
    IN  LPTSTR              Domain,
    IN  LPTSTR              Password
    );

int
ConnectInterface (
    IN  LPTSTR              InterfaceName
    );

int
DisconnectInterface (
    IN  LPTSTR              InterfaceName
    );


int
EnableInterface(
    IN  LPTSTR              lpInterface,
    IN  BOOL                bEnable
);


int
ShowInterfaces (
    VOID
    );

int
ShowInterface (
    IN  LPTSTR              InterfaceName
    );

DWORD
IsPhoneBookEntry (
    LPWSTR  InterfaceName
    );

HINSTANCE           HIf;
PROUTEMON_PARAMS    pParams;
PROUTEMON_UTILS     pUtils;

#if defined( UNICODE ) || defined( _UNICODE )
#define PrintString( s )    wprintf( L"%ls\n", (s) )
#define PrintWord( w )      wprintf( L"%0x\n", (w) )

#else
#define PrintString( s )    _tprintf( TEXT( "%s\n" ), (s) )
#define PrintWord( w )      _tprintf( TEXT( "%0x\n" ), (w) )

#endif



//-----------------------------------------------------------------------------
// InterfaceMonitor
//
// Dispatches the command to the appropriate function.
//-----------------------------------------------------------------------------

int APIENTRY
InterfaceMonitor (
    IN  int                 argc,
    IN  TCHAR               *argv[],
    IN  PROUTEMON_PARAMS    params,
    IN  PROUTEMON_UTILS     utils
    ) {
    DWORD   res = 0;
    TCHAR   buffer[MAX_TOKEN];

    HIf = GetModuleHandle (NULL);
    pParams = params;
    pUtils = utils;

    if (argc>0) {
        if (_tcsicmp (argv[0], GetString (HIf, TOKEN_CREATE, buffer))==0) {
            if (argc>1)
                return CreateInterface (argc-1, &argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_DELETE, buffer))==0) {
            if (argc>1)
                return DeleteInterface (argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_SET, buffer))==0) {
            if (argc>4)
                return SetInterface (argv[1],argv[2],argv[3],argv[4]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_SHOW, buffer))==0) {
            if (argc>1)
                return ShowInterface (argv[1]);
            else
                return ShowInterfaces ();
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_CONNECT, buffer))==0) {
            if (argc>1)
                return ConnectInterface (argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_DISCONNECT, buffer))==0) {
            if (argc>1)
                return DisconnectInterface (argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_ENABLE, buffer))==0) {
            if ( argc > 1 )
                return EnableInterface (argv[1], TRUE);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_DISABLE, buffer))==0) {
            if ( argc > 1 )
                return EnableInterface ( argv[1], FALSE );
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_UPDATE, buffer))==0) {
            DWORD   pid;
            if ((argc>2) && (GetValueFromString (HIf, pUtils, TransportIds, argv[2], &pid)))
                return UpdateInterface (argv[1], pid);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if ((_tcsicmp (argv[0], GetString (HIf, TOKEN_HELP1, buffer))==0)
                || (_tcsicmp (argv[0], GetString (HIf, TOKEN_HELP2, buffer))==0)
                || (_tcsicmp (argv[0], GetString (HIf, TOKEN_HELP3, buffer))==0))
            NOTHING;
        else
            res = ERROR_INVALID_PARAMETER;
    }
    else
        res = ERROR_INVALID_PARAMETER;

    pUtils->put_msg (HIf, MSG_INTERFACE_HELP, pParams->pszProgramName);
    return res;
}


//-----------------------------------------------------------------------------
// CreateInterface
//
// Create a demand-dial interface
//-----------------------------------------------------------------------------

int
CreateInterface (
    IN  INT                 argc,
    IN  LPTSTR              *argv
    ) {

    MPR_INTERFACE_0     Ri0;
    HANDLE              hIfCfg;
    DWORD               rc, dwIfType;
    unsigned            count;
    TCHAR               buffer[MAX_TOKEN];
    ULONG               ulIfIndex;

    ZeroMemory(&Ri0,
               sizeof(Ri0));

    //
    // if there is only one argument, then it is the interface name
    // which may even be called TUNNEL1
    // if there is more than one argument, and the first is TUNNEL1, then
    // the next one is the interface name
    //

    ulIfIndex = 0;
    dwIfType  = ROUTER_IF_TYPE_FULL_ROUTER;

    if(argc > 1)
    {
        if(_tcsicmp(argv[0], GetString (HIf, TOKEN_TUNNEL1, buffer))==0)
        {
            ulIfIndex = 1;
            dwIfType  = ROUTER_IF_TYPE_TUNNEL1;

            Ri0.fEnabled = TRUE;
        }
    }

    //
    // convert interface name to unicode
    //
    
#if defined(UNICODE) || defined (_UNICODE)
    wcsncpy (Ri0.wszInterfaceName, argv[ulIfIndex],
            sizeof (Ri0.wszInterfaceName)/sizeof (Ri0.wszInterfaceName[0]));
    count = wcslen (argv[ulIfIndex]);
#else
    count = mbstowcs (Ri0.wszInterfaceName, argv[ulIfIndex],
                            sizeof (Ri0.wszInterfaceName));
#endif


    do
    {

        if ( count > MAX_INTERFACE_NAME_LEN )
        {
            rc = ERROR_INVALID_PARAMETER;
            break;
        }


        if(dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
        {
            //
            // to create an interface we need a phone book entry
            // for it.
            //

            rc = IsPhoneBookEntry (Ri0.wszInterfaceName);
            
            if ( rc != NO_ERROR )
            {
                break;
            }
        }


        //
        // create interface with defaults
        //
            
        Ri0.hInterface          = INVALID_HANDLE_VALUE;
        Ri0.dwIfType            = dwIfType;

        rc = MprConfigInterfaceCreate (
                pParams->hRouterConfig,
                0,
                (LPBYTE)&Ri0,
                &hIfCfg
             );
                        
        if ( rc != NO_ERROR )
        {
            break;
        }
                
        pUtils->put_msg (HIf, MSG_INTERFACE_CREATED, Ri0.wszInterfaceName);
                    

        //
        // if router service is running add the interface
        // to it too.
        //

        if ( pParams->hRouterAdmin ) {

            HANDLE  hIfAdmin;

            rc = MprAdminInterfaceCreate (
                    pParams->hRouterAdmin,
                    0,
                    (LPBYTE)&Ri0,
                    &hIfAdmin
                 );
                            
            if ( rc != NO_ERROR )
            {
                break;
            }

            pUtils->put_msg (HIf, MSG_INTERFACE_ADDED, Ri0.wszInterfaceName);
        }
        
    } while( FALSE );

    if ( rc != NO_ERROR ) { pUtils->put_error_msg (rc); }

    return rc;
}



//-----------------------------------------------------------------------------
// SetInterface
//
// sets the credentials to be used by an interface when dialing into
// a remote router.
//-----------------------------------------------------------------------------

int
SetInterface (
    IN  LPTSTR              InterfaceName,
    IN  LPTSTR              UserName,
    IN  LPTSTR              Domain,
    IN  LPTSTR              Password
    )
{

    HANDLE              hIfCfg      = NULL;

    DWORD               rc          = (DWORD) -1,
                        rc2         = 0,
                        dwSize      = 0;

    unsigned            ci          = 0,
                        cu          = 0,
                        cd          = 0,
                        cp          = 0;
    
    PMPR_INTERFACE_0    pRi0        = NULL;


    //
    // convert parameters to WCHAR
    //

#if defined(UNICODE) || defined (_UNICODE)

    #define pInterfaceName  InterfaceName
    #define pUserName       UserName
    #define pDomain         Domain
    #define pPassword       Password

    ci = wcslen (InterfaceName);
    cu = wcslen (UserName);
    cd = wcslen (Domain);
    cp = wcslen (Password);

#else

    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
    WCHAR   UserNameW[257];
    WCHAR   DomainW[257];
    WCHAR   PasswordW[257];

    #define pInterfaceName  InterfaceNameW
    #define pUserName       UserNameW
    #define pDomain         DomainW
    #define pPassword       PasswordW

    ci = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
    cu = mbstowcs (UserNameW, UserName,  sizeof (UserNameW));
    cd = mbstowcs (DomainW, Domain,  sizeof (DomainW));
    cp = mbstowcs (PasswordW, Password,  sizeof (PasswordW));

#endif


    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(pInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================


    do
    {
        //
        // verify parameters
        //

        if ( ( ci > MAX_INTERFACE_NAME_LEN )    ||
             ( cu > 256 )                       ||
             ( cd > 256 )                       ||
             ( cp > 256 ) )
        {
            rc = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // verify if the interface is a demand-dial interface
        // before setting credentials on it.
        //

        rc = MprConfigInterfaceGetHandle(
                pParams->hRouterConfig,
                (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                &hIfCfg
             );

        if ( rc != NO_ERROR )
        {
            break;
        }

        rc = MprConfigInterfaceGetInfo (
                pParams->hRouterConfig,
                hIfCfg,
                0,
                (LPBYTE *) &pRi0,
                &dwSize
             );

        if ( rc != NO_ERROR )
        {
            break;
        }

        if ( pRi0-> dwIfType != ROUTER_IF_TYPE_FULL_ROUTER )
        {
            rc = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // set the credentials in the router
        //

        rc = MprAdminInterfaceSetCredentials (
                pParams-> wszRouterName,
                (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                pUserName,
                pDomain,
                pPassword
             );

        if ( rc != NO_ERROR )
        {
            break;
        }

        pUtils->put_msg (HIf, MSG_INTERFACE_SET, (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName);

    } while( FALSE );


    //
    // free allocations and report errors
    //

    if ( pRi0 ) { MprConfigBufferFree( pRi0 ); }

    if ( rc != NO_ERROR ) { pUtils-> put_error_msg( rc ); }

#undef pInterfaceName
#undef pUserName
#undef pDomain
#undef pPassword

    return rc;
}


//-----------------------------------------------------------------------------
// DeleteInterface
//
// Deletes a demand-dial Interface.
//-----------------------------------------------------------------------------

int
DeleteInterface (
    IN  LPTSTR              InterfaceName
    ) {
    HANDLE              hIfCfg;
    DWORD               rc, rc2;
    unsigned            count;
    PMPR_INTERFACE_0    pRi0;
    DWORD               sz;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
    count = wcslen (InterfaceName);
#else
    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
    count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif
//======================================
// Translate the Interface Name
//======================================
rc2 = Description2IfNameW(pInterfaceName,
                          IfNamBuffer,
                          &IfNamBufferLength);
//======================================

    if (count<=MAX_INTERFACE_NAME_LEN) {
        rc = MprConfigInterfaceGetHandle (
                    pParams->hRouterConfig,
                    (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                    &hIfCfg
                    );
        if (rc==NO_ERROR) {
            rc = MprConfigInterfaceGetInfo (
                    pParams->hRouterConfig,
                    hIfCfg,
                    0,
                    (LPBYTE *)&pRi0,
                    &sz);
            if (rc==NO_ERROR) {
                if((pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) ||
                   (pRi0->dwIfType==ROUTER_IF_TYPE_TUNNEL1))
                {
                    rc = MprConfigInterfaceDelete (
                                    pParams->hRouterConfig,
                                    hIfCfg);
                    if (rc==NO_ERROR) {
                        pUtils->put_msg (HIf, MSG_INTERFACE_DELETED, (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName);
                        if (pParams->hRouterAdmin) {
                            HANDLE              hIfAdmin;
                            rc = MprAdminInterfaceGetHandle (
                                        pParams->hRouterAdmin,
                                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                                        &hIfAdmin,
                                        FALSE
                                        );
                            if (rc==NO_ERROR) {
                                rc = MprAdminInterfaceDelete (
                                        pParams->hRouterAdmin,
                                        hIfAdmin);
                                if (rc==NO_ERROR)
                                    pUtils->put_msg (HIf, MSG_INTERFACE_REMOVED, (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName);
                            }
                        }
                    }
                }
                else
                    rc = ERROR_INVALID_PARAMETER;
                MprConfigBufferFree (pRi0);
            }
        }
    }
    else
    {
        rc = ERROR_INVALID_PARAMETER;
    }

    if ( rc != NO_ERROR )
    {
        pUtils->put_error_msg (rc);
    }

    return rc;

#undef pInterfaceName
}


//-----------------------------------------------------------------------------
// ShowInterfaces
//
// Display Interfaces on a router.
//-----------------------------------------------------------------------------

int
ShowInterfaces (
    VOID
    ) {
    DWORD               rc = NO_ERROR, rc2;
    DWORD               read, total, processed=0, i;
    DWORD               hResume = 0;
    PMPR_INTERFACE_0    pRi0;

    if (pParams->hRouterAdmin)
        pUtils->put_msg (HIf, MSG_INTERFACE_RTR_TABLE_HDR);
    else
        pUtils->put_msg (HIf, MSG_INTERFACE_CFG_TABLE_HDR);

    do {
        if (pParams->hRouterAdmin)
            rc = MprAdminInterfaceEnum (
                            pParams->hRouterAdmin,
                            0,
                            (LPBYTE *)&pRi0,
                            MAXULONG,
                            &read,
                            &total,
                            &hResume);
        else
            rc = MprConfigInterfaceEnum (
                            pParams->hRouterConfig,
                            0,
                            (LPBYTE *)&pRi0,
                            MAXULONG,
                            &read,
                            &total,
                            &hResume);
        if (rc==NO_ERROR) {
            for (i=0; i<read; i++) {
                TCHAR       buffer[3][MAX_VALUE];

                //======================================
                // Translate the Interface Name
                //======================================
                rc2 = IfName2DescriptionW(pRi0[i].wszInterfaceName,
                                          IfNamBuffer,
                                          &IfNamBufferLength);
                //======================================
                        
                if (pParams->hRouterAdmin)
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_RTR_TABLE_FMT,
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0[i].fEnabled ? 0 : 1,
                                        buffer[1]),
                            GetValueString (HIf, pUtils, InterfaceStates,
                                        pRi0[i].dwConnectionState, buffer[2]),
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0[i].dwIfType, buffer[0]),
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0[i].wszInterfaceName
                            );
                else
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_CFG_TABLE_FMT,
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0[i].fEnabled ? 0 : 1,
                                        buffer[1]),
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0[i].dwIfType, buffer[0] ),
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0[i].wszInterfaceName
                            );
            }
            processed += read;
            if (pParams->hRouterAdmin)
                MprAdminBufferFree (pRi0);
            else
                MprConfigBufferFree (pRi0);
        }
        else {
            pUtils->put_error_msg (rc);
        
            break;
        }
    }
    while (processed<total);

    return rc;
}


//-----------------------------------------------------------------------------
// ShowInterface
//
// Display data for a single interface
//-----------------------------------------------------------------------------

int
ShowInterface (
    IN  LPTSTR              InterfaceName
    ) {
    HANDLE              hIfCfg;
    HANDLE              hIfAdmin;
    DWORD               rc, rc2;
    unsigned            count;
    PMPR_INTERFACE_0    pRi0;
    DWORD               sz;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
    count = wcslen (InterfaceName);
#else
    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
    count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif


    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(pInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================

    if (count<=MAX_INTERFACE_NAME_LEN) {
        if (pParams->hRouterAdmin)
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
        else
            rc = MprConfigInterfaceGetHandle (
                        pParams->hRouterConfig,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfCfg
                        );
        if (rc==NO_ERROR) {
            if (pParams->hRouterAdmin)
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
            else
                rc = MprConfigInterfaceGetInfo (
                    pParams->hRouterConfig,
                    hIfCfg,
                    0,
                    (LPBYTE *)&pRi0,
                    &sz);
            if (rc==NO_ERROR) {
                TCHAR       buffer[3][MAX_VALUE];
                //======================================
                // Translate the Interface Name
                //======================================
                rc2 = IfName2DescriptionW(pRi0->wszInterfaceName,
                                          IfNamBuffer,
                                          &IfNamBufferLength);
                //======================================
                if (pParams->hRouterAdmin)
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_RTR_SCREEN_FMT,
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0->wszInterfaceName,
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0->dwIfType, buffer[0]),
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0-> fEnabled ? 0 : 1,
                                        buffer[1]),
                            GetValueString (HIf, pUtils, InterfaceStates,
                                        pRi0->dwConnectionState, buffer[2])
                            );
                else
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_CFG_SCREEN_FMT,
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0->wszInterfaceName,
                            IfNamBuffer,
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0->dwIfType, buffer[0]),
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0-> fEnabled ? 0 : 1,
                                        buffer[1])
                            );

            }
        }

        
        if ( rc != NO_ERROR )
        {
            pUtils->put_error_msg (rc);
        }

        return rc;
    }
    
    else
    {
        pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
        return ERROR_INVALID_PARAMETER;
    }
}


//-----------------------------------------------------------------------------
// UpdateInterface
//
// Initiate autostatic updates over an interface
//-----------------------------------------------------------------------------

int
UpdateInterface (
    IN  LPTSTR              InterfaceName,
    IN  DWORD               pid
    ) {
    if (pParams->hRouterAdmin) {
        HANDLE              hIfAdmin;
        DWORD               rc, rc2;
        unsigned            count;
        PMPR_INTERFACE_0    pRi0;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
        count = wcslen (InterfaceName);
#else
        WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
        count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif


        //======================================
        // Translate the Interface Name
        //======================================
        rc2 = Description2IfNameW(pInterfaceName,
                                  IfNamBuffer,
                                  &IfNamBufferLength);
        //======================================

        if (count<=MAX_INTERFACE_NAME_LEN) {
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
            if (rc==NO_ERROR) {
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
                if (rc==NO_ERROR) {
                    if (pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) {
                        HANDLE  hEvent = NULL;
                        if (pParams->fLocalRouter) {
                            hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
                            if (hEvent==NULL) {
                                rc = GetLastError ();
                                goto Exit;
                            }
                        }
                        pUtils->put_msg (HIf, MSG_WAIT_FOR_UPDATE);
                        rc = MprAdminInterfaceUpdateRoutes (
                                pParams->hRouterAdmin,
                                hIfAdmin,
                                pid,
                                hEvent);
                        if (pParams->fLocalRouter) {
                            if (rc==PENDING) {
                                rc = WaitForSingleObject (hEvent, INFINITE);
                                ASSERT (rc==WAIT_OBJECT_0);
                            }
                            CloseHandle (hEvent);
                        }

                        if (rc==NO_ERROR) {
                           DWORD   result;
                           rc = MprAdminInterfaceQueryUpdateResult (
                                    pParams->hRouterAdmin,
                                    hIfAdmin,
                                    pid,
                                    &result);
                           if (rc==NO_ERROR)
                               rc = result;
                        }
                    }
                    else
                        rc = ERROR_INVALID_PARAMETER;
                Exit:
                    MprAdminBufferFree (pRi0);
                }
                if (rc == NO_ERROR) {
                    pUtils->put_msg (HIf, MSG_UPDATE_COMPLETED);
                    return rc;
                }
                else {
                    pUtils->put_error_msg (rc);
                    return rc;
                }
            }
            else {
                pUtils->put_error_msg (rc);
                return rc;
            }
        }
        else {
            pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
    }
    else {
        pUtils->put_msg (HIf, MSG_ROUTER_NOT_RUNNING);
        return NO_ERROR;
    }
}


//-----------------------------------------------------------------------------
// ConnectInterface
//
// Initiate a connect on a demand-dial interface
//-----------------------------------------------------------------------------

int
ConnectInterface (
    IN  LPTSTR              InterfaceName
    ) {


    HANDLE              hIfAdmin = NULL;
    DWORD               rc = (DWORD) -1, rc2;
    unsigned            count = 0;
    PMPR_INTERFACE_0    pRi0 = NULL;

    
    //
    // convert interface name to unicode
    //

#if defined( UNICODE ) || defined( _UNICODE )

#define pInterfaceName InterfaceName

    count = wcslen (InterfaceName);

#else

    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];

#define pInterfaceName InterfaceNameW

    count = mbstowcs (
                InterfaceNameW,
                InterfaceName,
                sizeof (InterfaceNameW)
            );
#endif

    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(pInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================


    do
    {

        //
        // check if connected to router
        //

        if ( !pParams-> hRouterAdmin )
        {
            pUtils-> put_msg( HIf, MSG_ROUTER_NOT_RUNNING );
            break;
        }


        //
        // verify valid interface name
        //

        if ( count > MAX_INTERFACE_NAME_LEN )
        {
            pUtils-> put_msg( HIf, MSG_INVALID_INTERFACE_NAME );
            break;
        }


        //
        // verify that specified interface is a demand dial interface
        //

        rc = MprAdminInterfaceGetHandle (
                pParams->hRouterAdmin,
                (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                &hIfAdmin,
                FALSE
             );

        if ( rc != NO_ERROR )
        {
            pUtils-> put_error_msg( rc );
            break;
        }


        rc = MprAdminInterfaceGetInfo (
                pParams->hRouterAdmin,
                hIfAdmin,
                0,
                (LPBYTE *) &pRi0
             );

        if ( rc != NO_ERROR )
        {
            pUtils-> put_error_msg( rc );
            break;
        }


        if ( pRi0-> dwIfType != ROUTER_IF_TYPE_FULL_ROUTER )
        {
            pUtils-> put_msg( HIf, ERROR_INVALID_PARAMETER );
            break;
        }


        //
        // connect interface.
        //

        pUtils-> put_msg( HIf, MSG_WAIT_FOR_CONNECT );

        rc = MprAdminInterfaceConnect(
                pParams-> hRouterAdmin,
                hIfAdmin,
                NULL,
                TRUE
             );

        if ( rc != NO_ERROR && rc != PENDING )
        {
            pUtils-> put_error_msg( rc );
            break;
        }


        pUtils-> put_msg( HIf, MSG_CONNECT_COMPLETED );

        rc = NO_ERROR;

    } while( FALSE );


    //
    // clean up
    //

    if ( pRi0 ) { MprAdminBufferFree( pRi0 ); }

    return rc;


#if 0
    if (pParams->hRouterAdmin) {

        HANDLE              hIfAdmin;
        DWORD               rc;
        unsigned            count;
        PMPR_INTERFACE_0    pRi0;


#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
        count = wcslen (InterfaceName);
#else
        WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
        count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif


        if (count<=MAX_INTERFACE_NAME_LEN) {
        
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
                        
            if (rc==NO_ERROR) {
        
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
                    
                if (rc==NO_ERROR) {

                    if (pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) {

                        HANDLE  hEvent = NULL;

                        if (pParams->fLocalRouter) {
                            hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
                            if (hEvent==NULL) {
                                rc = GetLastError ();
                                goto Exit;
                            }
                        }

                        pUtils->put_msg (HIf, MSG_WAIT_FOR_CONNECT);

                        rc = MprAdminInterfaceConnect (
                                pParams->hRouterAdmin,
                                hIfAdmin,
                                hEvent,
                                TRUE
                             );

                        if (pParams->fLocalRouter) {
                            if (rc==PENDING) {
                                rc = WaitForSingleObject (hEvent, INFINITE);
                                ASSERT (rc==WAIT_OBJECT_0);
                            }

                            CloseHandle (hEvent);
                        }
                    }
                    else
                        rc = ERROR_INVALID_PARAMETER;
                Exit:
                    MprAdminBufferFree (pRi0);
                }

                if (rc==NO_ERROR) {
                    pUtils->put_msg (HIf, MSG_CONNECT_COMPLETED);
                    return 0;
                }
                else {
                    pUtils->put_error_msg (rc);
                    return 1;
                }
            }
            else {
                pUtils->put_error_msg (rc);
                return 1;
            }
        }
        else {
            pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
            return 1;
        }
    }
    else {
        pUtils->put_msg (HIf, MSG_ROUTER_NOT_RUNNING);
        return 1;
    }
#endif

    
}


//-----------------------------------------------------------------------------
// DisconnectInterface
//
// Disconnect a demand-dial interface
//-----------------------------------------------------------------------------

int
DisconnectInterface (
    IN  LPTSTR              InterfaceName
    ) {
    if (pParams->hRouterAdmin) {
        HANDLE              hIfAdmin;
        DWORD               rc, rc2;
        unsigned            count;
        PMPR_INTERFACE_0    pRi0;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
        count = wcslen (InterfaceName);
#else
        WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
        count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif

        //======================================
        // Translate the Interface Name
        //======================================
        rc2 = Description2IfNameW(pInterfaceName,
                                  IfNamBuffer,
                                  &IfNamBufferLength);
        //======================================

        if (count<=MAX_INTERFACE_NAME_LEN) {
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
            if (rc==NO_ERROR) {
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
                if (rc==NO_ERROR) {
                    if (pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) {
                        rc = MprAdminInterfaceDisconnect (
                                pParams->hRouterAdmin,
                                hIfAdmin);
                    }
                    else
                        rc = ERROR_INVALID_PARAMETER;
                //Exit:
                    MprAdminBufferFree (pRi0);
                }
                if (rc==NO_ERROR) {
                    pUtils->put_msg (HIf, MSG_DISCONNECT_COMPLETED);
                    return rc;
                }
                else {
                    pUtils->put_error_msg (rc);
                    return rc;
                }
            }
            else {
                pUtils->put_error_msg (rc);
                return rc;
            }
        }
        else {
            pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
    }
    else {
        pUtils->put_msg (HIf, MSG_ROUTER_NOT_RUNNING);
        return NO_ERROR;
    }
}


//-----------------------------------------------------------------------------
// EnableInterface
//
// Enable/disable a demand-dial interface.
//-----------------------------------------------------------------------------

int
EnableInterface(
    IN  LPTSTR      lpInterface,
    IN  BOOL        bEnable
)
{

    DWORD               dwCount     = 0,
                        dwSize      = 0,
                        rc2         = 0,
                        dwErr       = (DWORD) -1;

    HANDLE              hInterface  = NULL;

    PMPR_INTERFACE_0    pMprIf0     = NULL;


    //
    // convert interface name to Unicode
    //

#if defined( UNICODE ) || defined( _UNICODE )

    #define lpInterfaceName lpInterface

    dwCount = wcslen( lpInterface );

#else

    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];

    #define lpInterfaceName InterfaceNameW

    dwCount = mbstowcs (
                InterfaceNameW,
                lpInterface,
                sizeof( InterfaceNameW )
            );
#endif

    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(lpInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================

    //
    // Error break out loop
    //

    do
    {
        //
        // Update the enable flag in the router config
        //

        dwErr = MprConfigInterfaceGetHandle(
                    pParams-> hRouterConfig,
                    (rc2 == NO_ERROR) ? IfNamBuffer : lpInterfaceName,
                    &hInterface
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        dwErr = MprConfigInterfaceGetInfo(
                    pParams-> hRouterConfig,
                    hInterface,
                    0,
                    (LPBYTE *) &pMprIf0,
                    &dwSize
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }

        pMprIf0-> fEnabled = bEnable;


        dwErr = MprConfigInterfaceSetInfo(
                    pParams-> hRouterConfig,
                    hInterface,
                    0,
                    (LPBYTE) pMprIf0
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        //
        // if you have a handle to the router service, update
        // the interface in the router service as well.
        //

        if ( !pParams-> hRouterAdmin )
        {
            break;
        }


        dwErr = MprAdminInterfaceGetHandle(
                    pParams-> hRouterAdmin,
                    (rc2 == NO_ERROR) ? IfNamBuffer : lpInterfaceName,
                    &hInterface,
                    FALSE
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        dwErr = MprAdminInterfaceSetInfo(
                    pParams-> hRouterAdmin,
                    hInterface,
                    0,
                    (LPBYTE) pMprIf0
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }

    } while ( FALSE );


    if ( dwErr != NO_ERROR ) { pUtils-> put_error_msg( dwErr ); }

    if ( pMprIf0 ) { MprConfigBufferFree( pMprIf0 ); }

    return (int) dwErr;

}



typedef DWORD (*PRasValidateEntryName)(
    LPWSTR lpszPhonebook,   // pointer to full path and filename of phone-book file
    LPWSTR lpszEntry    // pointer to the entry name to validate
   );



//-----------------------------------------------------------------------------
// IsPhoneBookEntry
//
// Verify that a phone book entry is present for a specified interface
//-----------------------------------------------------------------------------

DWORD
IsPhoneBookEntry (
    LPWSTR  InterfaceNameW
    ) {

    
    HMODULE                     hRasApi32;
    PRasValidateEntryName       RasValidateEntryName;
    DWORD                       rc;
    WCHAR                       wszPbPath[MAX_PATH+1];


    //
    // get phone book path + file name
    //

    if ( pParams->fLocalRouter ) {
    
        rc = ExpandEnvironmentStringsW (
                LOCAL_ROUTER_PB_PATHW,
                wszPbPath,
                sizeof (wszPbPath)/sizeof (wszPbPath[0])
             );
    }

    else {

        rc = wsprintfW (wszPbPath, REMOTE_ROUTER_PB_PATHW, pParams->wszRouterName);
    }

    ASSERT (rc > 0);


    //
    // Load RASAPI32 DLL and call into it to verify specified
    // phone book entry
    //

    hRasApi32 = LoadLibrary ("RASAPI32.DLL");

    if (hRasApi32!=NULL) {

        RasValidateEntryName = (PRasValidateEntryName)
            GetProcAddress (
                hRasApi32,
                "RasValidateEntryNameW"
            );
        
        if ( RasValidateEntryName != NULL ) {

            rc = RasValidateEntryName (
                    wszPbPath,
                    InterfaceNameW
                 );
                
            if ( rc == NO_ERROR )
                rc = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                
            else if (rc == ERROR_ALREADY_EXISTS)
                rc = NO_ERROR;
        }
        else
            rc = GetLastError ();

        FreeLibrary (hRasApi32);
    }
    else
        rc = GetLastError ();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\guidmap.c ===
/*
	File	GuidMap.c

	Defines function to map a guid interface name to an unique descriptive 
	name describing that interface and vice versa.

	Paul Mayfield, 8/25/97

	Copyright 1997, Microsoft Corporation.
*/

#include "precomp.h"

static HANDLE hConfig = NULL;

// 
// Set the server that the name mapper will utilize
//
DWORD IfNameMapSetServer(HANDLE hMprConfig) {
    hConfig = hMprConfig;
    return NO_ERROR;
}

//
//  Map the guid name to the friendly name 
//
DWORD IfName2DescriptionW(IN PWCHAR pszName, OUT PWCHAR pszBuffer, IN LPDWORD lpdwBufSize) {
    if (hConfig == NULL || lpdwBufSize == NULL)
        return ERROR_CAN_NOT_COMPLETE;

    return MprConfigGetFriendlyName (hConfig, pszName, pszBuffer, *lpdwBufSize);
}

//
//  Map the friendly name to the guid name 
//
DWORD Description2IfNameW(IN PWCHAR pszName, OUT PWCHAR pszBuffer, IN LPDWORD lpdwBufSize) {
    if (hConfig == NULL || lpdwBufSize == NULL)
        return ERROR_CAN_NOT_COMPLETE;

    return MprConfigGetGuidName (hConfig, pszName, pszBuffer, *lpdwBufSize);
}

// ==================================================================
// ANSI versions of the above functions
// ==================================================================

#define mbtowc(mb,wc) MultiByteToWideChar (CP_ACP, 0, (mb), strlen ((mb)) + 1, (wc), 1024)
#define wctomb(wc,mb) WideCharToMultiByte (CP_ACP, 0, (wc), wcslen ((wc)) + 1, (mb), 1024, NULL, NULL)

DWORD IfName2DescriptionA(LPSTR pszName, LPSTR pszBuffer, LPDWORD lpdwBufSize) {
	WCHAR pszNameW[1024];
	WCHAR pszBufferW[1024];
	DWORD dwErr;
	int ret;

    // Translate params to wide char 
	ret = mbtowc(pszName, pszNameW);
	if (!ret)
		return GetLastError();

    // Call wide char version of function and copy back to multi byte
	dwErr = IfName2DescriptionW (pszNameW, pszBufferW, lpdwBufSize);
	if (dwErr == NO_ERROR) {
		ret = wctomb(pszBufferW, pszBuffer);
		if (ret == 0)
			return GetLastError();
	}
	
	return dwErr;
} 

DWORD Description2IfNameA(LPSTR pszDesc, LPSTR pszBuffer, LPDWORD lpdwBufSize) {
	WCHAR pszNameW[1024];
	WCHAR pszBufferW[1024];
	DWORD dwErr;
	int ret;

    // Translate params to wide char 
	ret = mbtowc(pszDesc, pszNameW);
	if (ret == 0)
		return GetLastError();

    // Call wide char version of function and copy back to multi byte
	dwErr = Description2IfNameW(pszNameW, pszBufferW, lpdwBufSize);
	if (dwErr == NO_ERROR) {
		ret = wctomb(pszBufferW, pszBuffer);
		if (!ret)
			return GetLastError();
	}
	
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\loadsave.c ===
/*
    File:   LoadSave.c

    Handles routemon options to load and save router configuration.
*/

#include "precomp.h"

#define LOADSAVE_PATH_SIZE 512

// 
// Defines a macro to perform string copies to
// unicode strings regardless of the UNICODE setting.
//
#if defined( UNICODE ) || defined( _UNICODE )
#define LoadSaveStrcpy(dst, src) wcscpy((dst), (src));
#else
#define LoadSaveStrcpy(dst, src) mbstowcs((dst), (src), strlen((src)));
#endif

// 
// Defines structure of parameters that can be sent to 
// a load/save config call.
//
typedef struct _LOADSAVE_PARAMS {
    WCHAR pszPath[LOADSAVE_PATH_SIZE];
} LOADSAVE_PARAMS, * PLOADSAVE_PARAMS;

//
// Returns a static error message
//
PWCHAR LoadSaveError (DWORD dwErr) {   
    static WCHAR pszRet[512];

    ZeroMemory(pszRet, sizeof(pszRet));

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    dwErr, 
                    0, 
                    pszRet, 
                    sizeof(pszRet) / sizeof(WCHAR), 
                    NULL);
                    
    return pszRet;                    
}    


//
// Parse the load save config command line and fills 
// the parameters accordingly.
//
DWORD LoadSaveParse (
        IN  int argc, 
        IN  TCHAR *argv[], 
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils,
        IN  BOOL bLoad,
        OUT LOADSAVE_PARAMS * pParams) 
{
    DWORD dwLen;

    // Initialize the return val
    ZeroMemory(pParams, sizeof(LOADSAVE_PARAMS));
    
    // Make sure a path has been provided
    if (argc == 0) {
    	pUtils->put_msg (GetModuleHandle(NULL), 
    	                 MSG_LOADSAVE_HELP, 
    	                 pRmParams->pszProgramName);
        return ERROR_CAN_NOT_COMPLETE;    	                 
    }
    
    // Copy over the path
    LoadSaveStrcpy (pParams->pszPath, argv[0]);

    // Add a '\' to the end of the path if not provided
    // dwLen = wcslen (pParams->pszPath);
    // if (pParams->pszPath[dwLen - 1] != L'\\') {
    //     pParams->pszPath[dwLen] = L'\\';
    //     pParams->pszPath[dwLen + 1] = (WCHAR)0;
    // }
        
    return NO_ERROR;
}

//
// The load/save engine
//
DWORD LoadSaveConfig (
        IN	PROUTEMON_PARAMS	pRmParams,
        IN	PROUTEMON_UTILS		pUtils,
        IN  PLOADSAVE_PARAMS    pLsParams,
        IN  BOOL                bLoad)
{
    DWORD dwErr;
    
    if (bLoad) 
        dwErr = MprConfigServerRestore (pRmParams->hRouterConfig, 
                                        pLsParams->pszPath);
    else
        dwErr = MprConfigServerBackup (pRmParams->hRouterConfig, 
                                        pLsParams->pszPath);

    return dwErr;            
}

//
// Handles request to load config
//
DWORD APIENTRY
LoadMonitor (
        IN	int					argc,
    	IN	TCHAR				*argv[],
    	IN	PROUTEMON_PARAMS	params,
    	IN	PROUTEMON_UTILS		utils
	    )
{
    DWORD dwErr;
    LOADSAVE_PARAMS LsParams;
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ((dwErr = LoadSaveParse (argc, argv, params, 
                                utils, TRUE, &LsParams)) != NO_ERROR)
        return dwErr;

    dwErr = LoadSaveConfig (params, utils, &LsParams, TRUE);

    switch (dwErr) {
        case NO_ERROR:
            utils->put_msg(hInst, MSG_LOAD_SUCCESS, LsParams.pszPath);
            break;

        case ERROR_ROUTER_CONFIG_INCOMPATIBLE:
            utils->put_msg(hInst, MSG_LOAD_INCOMPATIBLE, LsParams.pszPath);
            break;

        case ERROR_ACCESS_DENIED:
            utils->put_msg(hInst, MSG_LOAD_FAIL_ACCESSDENIED);
            
        default:
            utils->put_msg(
                hInst, 
                MSG_LOAD_FAIL, 
                LsParams.pszPath, 
                LoadSaveError(dwErr));
            break;
    }            
    
    return dwErr;
}

// 
// Handles request to save config
//
DWORD APIENTRY
SaveMonitor (
        IN	int					argc,
    	IN	TCHAR				*argv[],
    	IN	PROUTEMON_PARAMS	params,
    	IN	PROUTEMON_UTILS		utils
	    )
{
    DWORD dwErr;
    LOADSAVE_PARAMS LsParams;

    if ((dwErr = LoadSaveParse (argc, argv, params, 
                                utils, FALSE, &LsParams)) != NO_ERROR)
        return dwErr;

    dwErr = LoadSaveConfig (params, utils, &LsParams, FALSE);

    if (dwErr == NO_ERROR)
        utils->put_msg(GetModuleHandle(NULL), MSG_SAVE_SUCCESS, LsParams.pszPath);
    else
        utils->put_msg(GetModuleHandle(NULL), MSG_SAVE_FAIL, LsParams.pszPath, LoadSaveError(dwErr));
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <memory.h>
#include <malloc.h>

#include "comstrs.h"
#include "commsgs.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\utils.h ===
#ifndef _ROUTEMON_UTILS_
#define _ROUTEMON_UTILS_

UINT APIENTRY
get_str_id (
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	ULONG			EnumVal
	);

BOOL APIENTRY
get_enum_val (
	HINSTANCE	hModule,
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	LPTSTR			String,
	PULONG			EnumVal
	);

ULONG APIENTRY
put_msg (
	HINSTANCE	hModule,
	UINT		MsgId,
    ... 
	);

ULONG APIENTRY
put_str_msg (
	HINSTANCE	hModule,
	UINT		MsgId,
    ... 
	);

ULONG APIENTRY
put_error_msg (
	DWORD				error
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\register.c ===
/*
    File:   Register.c

    Handles routemon options to register ras servers in domains.
*/

#include "precomp.h"

// 
// Defines a macro to perform string copies to
// unicode strings regardless of the UNICODE setting.
//
#if defined( UNICODE ) || defined( _UNICODE )
#define RaSrvStrcpy(dst, src) wcscpy((dst), (src));
#else
#define RaSrvStrcpy(dst, src) mbstowcs((dst), (src), strlen((src)));
#endif

// 
// Defines structure of parameters that can be sent to 
// a RaSrv api's.
//
typedef struct _RASRV_PARAMS {
    WCHAR pszDomain[512];   // Given domain
    PWCHAR pszMachine;      // Given machine
    BOOL bEnable;           // Whether to enable or disable
    BOOL bQuery;            // Whether to query status
} RASRV_PARAMS, * PRASRV_PARAMS;

//
// Returns a static error message
//
PWCHAR RaSrvError (DWORD dwErr) {   
    static WCHAR pszRet[512];

    ZeroMemory(pszRet, sizeof(pszRet));

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    dwErr, 
                    0, 
                    pszRet, 
                    sizeof(pszRet) / sizeof(WCHAR), 
                    NULL);
                    
    return pszRet;                    
}    

//
// Displays usage and returns a generic error.
//
DWORD RaSrvUsage(
        IN  HINSTANCE hInst,
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils)
{
	pUtils->put_msg (hInst, 
	                 MSG_RASRV_HELP, 
	                 pRmParams->pszProgramName);
	                 
    return ERROR_CAN_NOT_COMPLETE;    	                 
}

//
// Parses the register command line and fills 
// the parameters accordingly.
//
DWORD RaSrvParse (
        IN  int argc, 
        IN  TCHAR *argv[], 
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils,
        IN  BOOL bLoad,
        OUT RASRV_PARAMS * pParams) 
{
    DWORD dwSize, dwErr;
    BOOL bValidCmd = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
	TCHAR buf[MAX_TOKEN];
    WCHAR pszComputer[1024];
    
    // Initialize the return val
    ZeroMemory(pParams, sizeof(RASRV_PARAMS));

    // Make sure a path has been provided
    if (argc == 0) 
        return RaSrvUsage(hInst, pRmParams, pUtils);
        
    // Parse out the command
	if (_tcsicmp(argv[0], GetString (hInst, TOKEN_ENABLE, buf))==0) {
	    pParams->bEnable = TRUE;
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_DISABLE, buf))==0) {
	    pParams->bEnable = FALSE;
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_SHOW, buf))==0) {
	    pParams->bQuery = TRUE;
	}
	else 
	    return RaSrvUsage(hInst, pRmParams, pUtils);

    // Initialize the computer name if present
    if (argc > 1) {
        RaSrvStrcpy(pszComputer, argv[1]);
    }        
    else {
        dwSize = sizeof(pszComputer) / sizeof(WCHAR);
        GetComputerNameW (pszComputer, &dwSize);
    }        
    pParams->pszMachine = _wcsdup (pszComputer);

    // Initialize the domain if present
    if (argc > 2) 
        RaSrvStrcpy(pParams->pszDomain, argv[2]);            

    return NO_ERROR;
}

// 
// Cleans up any RaSrv parameters
//
DWORD RaSrvCleanup (
        IN PRASRV_PARAMS pParams) 
{
    if (pParams->pszMachine)
        free(pParams->pszMachine);
        
    return NO_ERROR;
}

//
// The RaSrv functionality engine
//
DWORD RaSrvEngine (
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PRASRV_PARAMS pParams)
{
    DWORD dwErr;
    HINSTANCE hInst = GetModuleHandle(NULL);
    BOOL bValue;
    
    // Query registration status
    //
    if (pParams->bQuery) {
        dwErr = MprAdminIsDomainRasServer (
                    pParams->pszDomain,
                    pParams->pszMachine,
                    &bValue);
        if (dwErr != NO_ERROR) {
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_QUERY_FAIL, 
                    pParams->pszMachine,
                    RaSrvError(dwErr));
            return dwErr;
        }

        if (bValue)
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_QUERY_YES, 
                    pParams->pszMachine);
        else
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_QUERY_NO, 
                    pParams->pszMachine);
    }
    
    // Register the service
    //
    else {
        dwErr = MprAdminEstablishDomainRasServer (
                    pParams->pszDomain,
                    pParams->pszMachine,
                    pParams->bEnable);
        if (dwErr != NO_ERROR) {
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_REGISTER_FAIL, 
                    pParams->pszMachine,
                    RaSrvError(dwErr));
            return dwErr;
        }

        if (pParams->bEnable)
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_ENABLE_SUCCESS, 
                    pParams->pszMachine);
        else
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_DISABLE_SUCCESS, 
                    pParams->pszMachine);
    }

    return NO_ERROR;
}

//
// Handles requests register a ras server in a domain
// or to deregister a ras server in a domain or to query
// whether a given ras server is registered in a given domain.
//
DWORD APIENTRY
RaSrvMonitor (
    IN	int					argc,
	IN	TCHAR				*argv[],
	IN	PROUTEMON_PARAMS	params,
	IN	PROUTEMON_UTILS		utils
    )
{
    DWORD dwErr = NO_ERROR;
    RASRV_PARAMS RaSrvParams;
    HINSTANCE hInst = GetModuleHandle(NULL);

    RaSrvUsage(hInst, params, utils);

 /*
    dwErr = RaSrvParse (
                    argc, 
                    argv, 
                    params, 
                    utils, 
                    TRUE, 
                    &RaSrvParams);
    if (dwErr != NO_ERROR)                    
        return dwErr;

    RaSrvEngine (params, utils, &RaSrvParams);
    
    RaSrvCleanup(&RaSrvParams);
*/    
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\utils.c ===
#include "precomp.h"



UINT APIENTRY
get_str_id (
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	ULONG			EnumVal
	) {
	ULONG	i;
	for (i=0; (i<ArraySz) && (Array->enumVal!=EnumVal); i++, Array++) ;
	if (i<ArraySz)
		return Array->strId;
	else
		return (UINT)(-1);
}

BOOL APIENTRY
get_enum_val (
	HINSTANCE		hModule,
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	LPTSTR			String,
	PULONG			EnumVal
	) {
	ULONG	i;
	TCHAR	buffer[MAX_VALUE];

	for (i=0; (i<ArraySz) 
				&& (_tcsicmp (
						String,
						GetString (
							hModule,
							Array->strId,
							buffer
						)
					)!=0); i++, Array++) ;
	if (i<ArraySz) {
		*EnumVal = Array->enumVal;
		return TRUE;
	}
	else
		return FALSE;
}

ULONG APIENTRY
put_msg (
	HINSTANCE	hModule,
	UINT		MsgId,
    ... 
	) {
	DWORD				msglen;
	LPTSTR				vp;
	va_list				arglist;

	va_start (arglist, MsgId);

	msglen = FormatMessage(
				FORMAT_MESSAGE_FROM_HMODULE |
					FORMAT_MESSAGE_ALLOCATE_BUFFER,
				hModule,
				MsgId,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				(LPTSTR)&vp,
				0,
				&arglist);
	if (msglen != 0) {
		_fputts (vp, stdout);
		LocalFree(vp);
	}

	va_end (arglist);
	return msglen;
}

ULONG APIENTRY
put_str_msg (
	HINSTANCE	hModule,
	UINT		StrId,
    ... 
	) {
	DWORD				msglen;
	static TCHAR		buffer[MAX_STR_MESSAGE];
	LPTSTR				vp;
	va_list				arglist;

	va_start (arglist, StrId);

	msglen = FormatMessage(
				FORMAT_MESSAGE_FROM_STRING |
					FORMAT_MESSAGE_ALLOCATE_BUFFER,
				GetString (hModule,StrId,buffer),
				0,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				(LPTSTR)&vp,
				0,
				&arglist);
	if (msglen != 0) {
		_fputts (vp, stdout);
		LocalFree(vp);
	}

	va_end (arglist);
	return msglen;
}


ULONG APIENTRY
put_error_msg (
	DWORD				error
	) {
	LPWSTR		vp;
	DWORD		msglen;

	if ((msglen=FormatMessageW (
			FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_ALLOCATE_BUFFER,
			NULL,
			error,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
			(LPWSTR)&vp,
			0,
			NULL))>0) {
		fputws (vp, stdout);
		LocalFree (vp);
		return msglen;
	}
	else if (MprAdminGetErrorString (error,	&vp)==NO_ERROR) {
		msglen = wcslen (vp);
		fputws (vp, stdout);
		MprAdminBufferFree (vp);
		return msglen;
	}
	else if (MprAdminGetErrorString (error,	&vp)==NO_ERROR) {
		msglen = wcslen (vp);
		fputws (vp, stdout);
		MprAdminBufferFree (vp);
		return msglen;
	}
	else 
		return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\routemon.c ===
#include "precomp.h"

#define MAX_MSG_LENGTH  512


VOID
OEMfprintf(
    IN  HANDLE  hHandle,
    IN  PWCHAR  pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen, dwWritten;

    dwLen = WideCharToMultiByte( CP_OEMCP,
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = malloc(dwLen);

    if (achOem)
    {
        WideCharToMultiByte( CP_OEMCP,
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );

        WriteFile( hHandle, achOem, dwLen-1, &dwWritten, NULL );

        free(achOem);
    }
}

#define OEMprintf(pwszUnicode) \
    OEMfprintf( GetStdHandle(STD_OUTPUT_HANDLE), pwszUnicode)

int _cdecl
wmain (
	int		argc,
	WCHAR	*argv[]
	) 
{
    DWORD       dwMsglen;
    PWCHAR      pwszOutput;
    WCHAR       rgwcInput[MAX_MSG_LENGTH];

    pwszOutput = NULL;

    do
    {
        dwMsglen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL,
                                  MSG_HELP,
                                  0L,
                                  (PWCHAR)&pwszOutput,
                                  0,
                                  NULL);

        if(dwMsglen == 0)
        {
            break;
        }

        OEMprintf(pwszOutput);

    }while(FALSE);


    if(pwszOutput)
    {
        LocalFree(pwszOutput);
    }


    return ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\cldlg.h ===
#define IDD_RTM_CLIENT              200
#define IDG_REGISTRATION_C          201
#define IDC_PROTOCOL_FAMILY_C       202
#define IDE_ROUTING_PROTOCOL_C      203
#define IDB_REGISTER_OP_C           204
#define IDG_CLIENT_OPERATION_C      205
#define IDE_NET_NUMBER_C            206
#define IDE_NEXT_HOP_C              207
#define IDE_INTERFACE_C             208
#define IDE_METRIC_C                209
#define IDE_TIMEOUT_C               210
#define IDL_MESSAGE_FLAGS_C         212
#define IDB_DO_IT_C                 213
#define IDG_REQUEST_C               214
#define IDR_ADD_C                   215
#define IDR_DELETE_C                216
#define IDR_DEQUEUE_C               217
#define IDR_DISABLE_C               218
#define IDR_ENABLE_C                219
#define IDL_ROUTING_PROTOCOL_C      211
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\user.c ===
/*
    File:   user.c

    Handles routemon options to get and set RAS user properties.
*/

#include "precomp.h"

#define NT40_BUILD_NUMBER       1381
const WCHAR pszBuildNumPath[]  =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR pszBuildVal[]      = L"CurrentBuildNumber";

// 
// Defines a macro to perform string copies to
// unicode strings regardless of the UNICODE setting.
//
#if defined( UNICODE ) || defined( _UNICODE )
#define UserStrcpy(dst, src) wcscpy((dst), (src));
#else
#define UserStrcpy(dst, src) mbstowcs((dst), (src), strlen((src)));
#endif

// 
// Defines structure of parameters that can be sent to 
// a User api's.
//
typedef struct _USER_PARAMS {
    PWCHAR pszMachine;           // Given machine
    DWORD dwToken;               // Token designating the desired command
    WCHAR pszAccount[1024];      // The account in question
    BOOL bPolicySpecified;       // Whether policy given on cmd line
    DWORD dwTokenPolicy;         // Specifies the token for the callback policy
    RAS_USER_0 UserInfo;         // Buffer to hold user info
} USER_PARAMS, * PUSER_PARAMS;

//
// Determines the role of the given computer (NTW, NTS, NTS DC, etc.)
//
DWORD UserGetMachineRole(
        IN  PWCHAR pszMachine,
        OUT DSROLE_MACHINE_ROLE * peRole) 
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pGlobalDomainInfo = NULL;
    DWORD dwErr;

    if (!peRole)
        return ERROR_INVALID_PARAMETER;

    //
    // Get the name of the domain this machine is a member of
    //
    __try {
        dwErr = DsRoleGetPrimaryDomainInformation(
                            pszMachine,   
                            DsRolePrimaryDomainInfoBasic,
                            (LPBYTE *)&pGlobalDomainInfo );

        if (dwErr != NO_ERROR) 
            return dwErr;

        *peRole = pGlobalDomainInfo->MachineRole;
    }        

    __finally {
        if (pGlobalDomainInfo)
            DsRoleFreeMemory (pGlobalDomainInfo);
    }            

    return NO_ERROR;
}    

//
// Determines the build number of a given machine
//
DWORD UserGetNtosBuildNumber(
        IN  PWCHAR pszMachine,
        OUT LPDWORD lpdwBuild)
{
    WCHAR pszComputer[1024], pszBuf[64];
    HKEY hkBuild = NULL, hkMachine = NULL;
    DWORD dwErr, dwType = REG_SZ, dwSize = sizeof(pszBuf);

    __try {
        if (pszMachine) {
            if (*pszMachine != L'\\')
                wsprintfW(pszComputer, L"\\\\%s", pszMachine);
            else
                wcscpy(pszComputer, pszMachine);
            dwErr = RegConnectRegistryW (pszComputer,
                                        HKEY_LOCAL_MACHINE,
                                        &hkMachine);
            if (dwErr != ERROR_SUCCESS)
                return dwErr;
        }
        else    
            hkMachine = HKEY_LOCAL_MACHINE;

        // Open the build number key
        dwErr = RegOpenKeyExW ( hkMachine,
                               pszBuildNumPath,
                               0,
                               KEY_READ,
                               &hkBuild);
        if (dwErr != ERROR_SUCCESS)
            return dwErr;

        // Get the value
        dwErr = RegQueryValueExW ( hkBuild,
                                   pszBuildVal,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)pszBuf,
                                   &dwSize);
        if (dwErr != ERROR_SUCCESS)
            return dwErr;

        *lpdwBuild = (DWORD) _wtoi(pszBuf);
    }
    __finally {
        if (hkMachine && pszMachine)
            RegCloseKey(hkMachine);
        if (hkBuild)
            RegCloseKey(hkBuild);
    }

    return NO_ERROR;
}


//
// Returns a static error message
//
PWCHAR UserError (DWORD dwErr) {   
    static WCHAR pszRet[512];

    ZeroMemory(pszRet, sizeof(pszRet));

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    dwErr, 
                    0, 
                    pszRet, 
                    sizeof(pszRet) / sizeof(WCHAR), 
                    NULL);
                    
    return pszRet;                    
}    

//
// Displays usage and returns a generic error.
//
DWORD UserUsage(
        IN  HINSTANCE hInst,
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils)
{
	pUtils->put_msg (hInst, 
	                 MSG_USER_HELP, 
	                 pRmParams->pszProgramName);
	                 
    return ERROR_CAN_NOT_COMPLETE;    	                 
}

//
// Parses the register command line and fills 
// the parameters accordingly.
//
DWORD UserParse (
        IN  int argc, 
        IN  TCHAR *argv[], 
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils,
        IN  BOOL bLoad,
        OUT USER_PARAMS * pParams) 
{
    DWORD dwSize, dwErr;
    BOOL bValidCmd = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
	TCHAR buf[MAX_TOKEN];
    
    // Initialize the return val
    ZeroMemory(pParams, sizeof(USER_PARAMS));

    // Parse out the name of the computer
    if (pRmParams->wszRouterName[0])
        pParams->pszMachine = (PWCHAR)&(pRmParams->wszRouterName[0]);

    // Make sure some command was issued
    if (argc == 0) 
        return UserUsage(hInst, pRmParams, pUtils);
        
    // Parse out the command
	if (_tcsicmp(argv[0], GetString (hInst, TOKEN_ENABLE, buf))==0) {
	    pParams->dwToken = TOKEN_ENABLE;
	    if (argc == 1)
    	    return UserUsage(hInst, pRmParams, pUtils);
        UserStrcpy(pParams->pszAccount, argv[1]);    	    

        // Optional setting of callback policy and number
        if (argc > 2) {
            pParams->bPolicySpecified = TRUE;
        	if (_tcsicmp(argv[2], GetString (hInst, TOKEN_NONE, buf))==0)
        	    pParams->dwTokenPolicy = TOKEN_NONE;
        	else if (_tcsicmp(argv[2], GetString (hInst, TOKEN_CALLER, buf))==0)
        	    pParams->dwTokenPolicy = TOKEN_CALLER;
        	else if (_tcsicmp(argv[2], GetString (hInst, TOKEN_ADMIN, buf))==0)
        	    pParams->dwTokenPolicy = TOKEN_ADMIN;

        	if ((pParams->dwTokenPolicy == TOKEN_ADMIN) &&
        	    (argc < 3))
        	{
                return UserUsage(hInst, pRmParams, pUtils);
        	}
        	else if (pParams->dwTokenPolicy == TOKEN_ADMIN) {
        	    UserStrcpy(pParams->UserInfo.wszPhoneNumber, argv[3]);
        	}
        }
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_DISABLE, buf))==0) {
	    pParams->dwToken = TOKEN_DISABLE;
	    if (argc == 1)
    	    return UserUsage(hInst, pRmParams, pUtils);
        UserStrcpy(pParams->pszAccount, argv[1]);    	    
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_SHOW, buf))==0) {
	    pParams->dwToken = TOKEN_SHOW;
	    if (argc == 1)
    	    return UserUsage(hInst, pRmParams, pUtils);
        UserStrcpy(pParams->pszAccount, argv[1]);    	    
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_UPGRADE, buf))==0) {
	    pParams->dwToken = TOKEN_UPGRADE;
	}
	else 
	    return UserUsage(hInst, pRmParams, pUtils);

    return NO_ERROR;
}

// 
// Cleans up any User parameters
//
DWORD UserCleanup (
        IN PUSER_PARAMS pParams) 
{
    if (pParams->pszMachine)
        free(pParams->pszMachine);
        
    return NO_ERROR;
}

//
// Gets user info
//
DWORD UserGetInfo (
        IN  PWCHAR lpszServer,
        IN  PWCHAR lpszUser,
        IN  DWORD dwLevel,
        OUT LPBYTE lpbBuffer)
{
    DWORD dwErr, dwBuild;

    // Find out the OS of the given machine.
    dwErr = UserGetNtosBuildNumber(
                lpszServer, 
                &dwBuild);
    if (dwErr != NO_ERROR)
        return dwErr;

    // If the target machine is nt4, use nt4 userparms
    if (dwBuild <= NT40_BUILD_NUMBER) {
        return MprAdminUserGetInfo(
                    lpszServer, 
                    lpszUser, 
                    dwLevel, 
                    lpbBuffer);
    }                    

    // Otherwise, use SDO's
    else {
        HANDLE hServer, hUser;

        dwErr = MprAdminUserServerConnect(
                    lpszServer,
                    TRUE,
                    &hServer);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprAdminUserOpen(
                    hServer,
                    lpszUser, 
                    &hUser);
        if (dwErr != NO_ERROR) {
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        dwErr = MprAdminUserRead(
                    hUser,
                    dwLevel,
                    lpbBuffer);
        if (dwErr != NO_ERROR) {
            MprAdminUserClose(hUser);
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        MprAdminUserClose(hUser);
        MprAdminUserServerDisconnect(hServer);
    }

    return NO_ERROR;
}
      
//
// Sets user info
//
DWORD UserSetInfo (
        IN  PWCHAR lpszServer,
        IN  PWCHAR lpszUser,
        IN  DWORD dwLevel,
        OUT LPBYTE lpbBuffer)
{
    DWORD dwErr, dwBuild;

    // Find out the OS of the given machine.
    dwErr = UserGetNtosBuildNumber(
                lpszServer, 
                &dwBuild);
    if (dwErr != NO_ERROR)
        return dwErr;

    // If the target machine is nt4, use nt4 userparms
    if (dwBuild <= NT40_BUILD_NUMBER) {
        return MprAdminUserSetInfo(
                    lpszServer, 
                    lpszUser, 
                    dwLevel, 
                    lpbBuffer);
    }                    

    // Otherwise, use SDO's
    else {
        HANDLE hServer, hUser;

        dwErr = MprAdminUserServerConnect(
                    lpszServer,
                    TRUE,
                    &hServer);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprAdminUserOpen(
                    hServer,
                    lpszUser, 
                    &hUser);
        if (dwErr != NO_ERROR) {
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        dwErr = MprAdminUserWrite(
                    hUser,
                    dwLevel,
                    lpbBuffer);
        if (dwErr != NO_ERROR) {
            MprAdminUserClose(hUser);
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        MprAdminUserClose(hUser);
        MprAdminUserServerDisconnect(hServer);
    }

    return NO_ERROR;
}

// 
// Enables or disables a user
//
DWORD UserEnableDisable(
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    DWORD dwErr;

    // Read in the old user properties if all the options
    // weren't specified on the command line.
    if (pParams->dwTokenPolicy != TOKEN_ADMIN) {
        dwErr = UserGetInfo(
                    pParams->pszMachine,
                    pParams->pszAccount,
                    0,
                    (LPBYTE)&(pParams->UserInfo));
        if (dwErr != NO_ERROR)
            return dwErr;
    }

    // Set the dialin policy 
    if (pParams->dwToken == TOKEN_ENABLE)
        pParams->UserInfo.bfPrivilege |= RASPRIV_DialinPrivilege;
    else         
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_DialinPrivilege;

    // Set the callback policy.  The callback number will already 
    // be set through the parsing.
    if (pParams->bPolicySpecified) {
        // Initialize
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_NoCallback;
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_CallerSetCallback;
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_AdminSetCallback;

        // Set
        if (pParams->dwTokenPolicy == TOKEN_NONE)
            pParams->UserInfo.bfPrivilege |= RASPRIV_NoCallback;
        else if (pParams->dwTokenPolicy == TOKEN_CALLER)
            pParams->UserInfo.bfPrivilege |= RASPRIV_CallerSetCallback;
        else
            pParams->UserInfo.bfPrivilege |= RASPRIV_AdminSetCallback;
    }         

    // Otherwise, initialize the display token
    else {
        if (pParams->UserInfo.bfPrivilege & RASPRIV_NoCallback)
            pParams->dwTokenPolicy = TOKEN_NONE;
        else if (pParams->UserInfo.bfPrivilege & RASPRIV_CallerSetCallback)
            pParams->dwTokenPolicy = TOKEN_CALLER;
        else
            pParams->dwTokenPolicy = TOKEN_ADMIN;
    }

    // Commit the changes to the system
    dwErr = UserSetInfo(
                pParams->pszMachine,
                pParams->pszAccount,
                0,
                (LPBYTE)&(pParams->UserInfo));
    if (dwErr != NO_ERROR)
        return dwErr;

    // Print out the results
    {
        HINSTANCE hInst = GetModuleHandle(NULL);
    	TCHAR buf1[MAX_TOKEN], buf2[MAX_TOKEN];
    	DWORD dwYesNo;

    	dwYesNo = (pParams->dwToken == TOKEN_ENABLE) ? VAL_YES : VAL_NO;
    	
        pUtils->put_msg(
                hInst,
                MSG_USER_ENABLEDISABLE_SUCCESS, 
                pParams->pszAccount,
                GetString (hInst, dwYesNo, buf1),
                GetString (hInst, pParams->dwTokenPolicy, buf2),
                pParams->UserInfo.wszPhoneNumber
                );
    }                
    
    return NO_ERROR;
}

//
// Shows a user
// 
DWORD UserShow(
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    DWORD dwErr;
    
    dwErr = UserGetInfo(
                pParams->pszMachine,
                pParams->pszAccount,
                0,
                (LPBYTE)&(pParams->UserInfo));
    if (dwErr != NO_ERROR)
        return dwErr;

    // Print out the results
    {
        HINSTANCE hInst = GetModuleHandle(NULL);
    	TCHAR buf1[MAX_TOKEN], buf2[MAX_TOKEN];
    	DWORD dwTknEnable, dwTknPolicy;

        dwTknEnable = (pParams->UserInfo.bfPrivilege & RASPRIV_DialinPrivilege) ?
                      VAL_YES : 
                      VAL_NO;

        if (pParams->UserInfo.bfPrivilege & RASPRIV_NoCallback)
            dwTknPolicy = TOKEN_NONE;
        else if (pParams->UserInfo.bfPrivilege & RASPRIV_CallerSetCallback)
            dwTknPolicy = TOKEN_CALLER;
        else
            dwTknPolicy = TOKEN_ADMIN;
    	
        pUtils->put_msg(
                hInst,
                MSG_USER_SHOW_SUCCESS, 
                pParams->pszAccount,
                GetString (hInst, dwTknEnable, buf1),
                GetString (hInst, dwTknPolicy, buf2),
                pParams->UserInfo.wszPhoneNumber
                );
    }                
    
    return NO_ERROR;
}

// 
// Upgrades a user
//
DWORD UserUpgrade(
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    BOOL bLocal = FALSE;
    DWORD dwErr, dwBuild;
    DSROLE_MACHINE_ROLE eRole;

    // Determine whether this should be local or 
    // domain upgrade.
    dwErr = UserGetNtosBuildNumber(pParams->pszMachine, &dwBuild);
    if (dwErr != NO_ERROR)
        return dwErr;

    // You can upgrade nt4->nt4
    if (dwBuild <= NT40_BUILD_NUMBER)
        return ERROR_CAN_NOT_COMPLETE;

    // Find out the role of the machine
    dwErr = UserGetMachineRole(pParams->pszMachine, &eRole);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Now we know whether we're local
    bLocal = ((eRole != DsRole_RoleBackupDomainController) &&
              (eRole != DsRole_RolePrimaryDomainController));


    // Upgrade the users
    dwErr = MprAdminUpgradeUsers(pParams->pszMachine, bLocal);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Print out the results
    {
        HINSTANCE hInst = GetModuleHandle(NULL);
    	TCHAR buf[MAX_TOKEN];
    	DWORD dwToken;

    	dwToken = (bLocal) ? VAL_LOCAL : VAL_DOMAIN;

        pUtils->put_msg(
                hInst,
                MSG_USER_UPGRADE_SUCCESS, 
                GetString(hInst, dwToken, buf)
                );
    }                
    
    return NO_ERROR;
}

//
// The User functionality engine
//
DWORD UserEngine (
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    DWORD dwErr;
    HINSTANCE hInst = GetModuleHandle(NULL);

    switch (pParams->dwToken) {
        case TOKEN_ENABLE:
        case TOKEN_DISABLE:
            return UserEnableDisable(pRmParams, pUtils, pParams);
        case TOKEN_SHOW:
            return UserShow(pRmParams, pUtils, pParams);
        case TOKEN_UPGRADE:
            return UserUpgrade(pRmParams, pUtils, pParams);
    }
    
    return NO_ERROR;
}

//
// Handles requests register a ras server in a domain
// or to deregister a ras server in a domain or to query
// whether a given ras server is registered in a given domain.
//
DWORD APIENTRY
UserMonitor (
    IN	int					argc,
	IN	TCHAR				*argv[],
	IN	PROUTEMON_PARAMS	params,
	IN	PROUTEMON_UTILS		utils
    )
{
    DWORD dwErr;
    USER_PARAMS UserParams;

    dwErr = UserParse (
                    argc, 
                    argv, 
                    params, 
                    utils, 
                    TRUE, 
                    &UserParams);
    if (dwErr != NO_ERROR)                    
        return NO_ERROR;

    dwErr = UserEngine (params, utils, &UserParams);
    
    UserCleanup(&UserParams);
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\enumdlg.h ===
#define IDD_ENUMERATION             300
#define IDG_CRITERIA_E              301
#define IDC_PROTOCOL_FAMILY_E       302
#define IDC_INTERFACE_E             303
#define IDE_INTERFACE_E             304
#define IDC_PROTOCOL_E              305
#define IDE_PROTOCOL_E              306
#define IDC_NETWORK_E               307
#define IDE_NETWORK_E               308
#define IDC_BESTROUTES_E            309
#define IDG_RESULT_E                310
#define IDL_ROUTE_E                 311
#define IDG_BUTTONS_E               312
#define IDB_CREATEDELETE_E          313
#define IDB_GETFIRST_E              314
#define IDB_GETNEXT_E               315
#define IDB_GETBEST_E               316
#define IDL_AGESEC_E                319
#define IDG_TIMESTAMP_E             320
#define IDL_TIMELOW_E               322
#define IDB_GETAGE_E                318
#define IDG_ROUTEAGE_E              317
#define IDL_TIMEHIGH_E              321
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\pchrtm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchmgm.h
//
// History:
//      V Raman	Oct-14-1997  Created.
//
// Pre compiled header for MGM
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <rtm.h>
#include <rtutils.h>
#include "rmrtm.h"
#include "rtmp.h"
#include "rtmv1rtm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmdlg.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmdlg.c

Abstract:
	Routing Table Manager DLL. Debugging code to display table entries
	in dialog box


Author:

	Vadim Eydelman

Revision History:

--*/

#include "pchrtm.h"
#pragma hdrstop

#if DBG


#define IP_PROTOCOL		RR_RoutingProtocol
#define	IP_INTERFACE	RR_InterfaceID
#define IP_METRIC		RR_FamilySpecificData.FSD_Metric1
#define IP_TIMESTAMP	RR_TimeStamp
#define IP_NET_NUM		RR_Network.N_NetNumber
#define IP_NET_MSK		RR_Network.N_NetMask
#define IP_NEXT_HOP_NUM	RR_NextHopAddress.N_NetNumber
#define IP_NEXT_HOP_MSK	RR_NextHopAddress.N_NetMask
#define IP_ADPTER_INDEX	RR_FamilySpecificData.FSD_AdapterIndex
#define IP_PROTOCOL_METRIC RR_FamilySpecificData.FSD_ProtocolMetric
#define IP_PSD			RR_ProtocolSpecificData

#define IPX_PROTOCOL		RR_RoutingProtocol
#define	IPX_INTERFACE		RR_InterfaceID
#define IPX_METRIC			RR_FamilySpecificData.FSD_TickCount
#define IPX_TIMESTAMP		RR_TimeStamp
#define IPX_NET_NUM			RR_Network.N_NetNumber
#define IPX_NEXT_HOP_MAC	RR_NextHopAddress.NHA_Mac
#define IPX_HOP_COUNT		RR_FamilySpecificData.FSD_HopCount
#define IPX_PSD				RR_ProtocolSpecificData

	// Make table accessible to debugging code
extern RTM_TABLE 	Tables[RTM_NUM_OF_PROTOCOL_FAMILIES];

	// Define protype internal to rtm.c
VOID
ConsolidateNetNumberLists (
	PRTM_TABLE			Table	// Table for which operation is performed
	);

DWORD		DbgLevel = 0;
DWORD		MaxTicks = MAXULONG;
DWORD 		MaxMessages=10000;



HANDLE		RTDlgThreadHdl;
ULONG		DisplayedTableIdx = 0xFFFFFFFF;
HWND		RTDlg=NULL;

	// Internal function prototypes
INT_PTR CALLBACK
RTDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);

INT
PrintRoute (
	char			*buffer,
	PRTM_ROUTE_NODE	node,
	BOOLEAN			full
	);

VOID
FillUpRouteLB (
	);



#define DLLInstanceHdl ((HANDLE)param)
DWORD WINAPI
RTDialogThread (
	LPVOID	param
	) {
	MSG			msg;
	DWORD		status;
	BOOLEAN		Done = FALSE;
	HANDLE		RegChangeEvt;
	HKEY		regHdl;
	DWORD		length, disposition, value;


	RegChangeEvt = CreateEvent (NULL, FALSE, TRUE, NULL);
	ASSERTERR (RegChangeEvt!=NULL);

	status = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
								TEXT ("System\\CurrentControlSet\\Services\\RemoteAccess\\RTM"),
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_READ,
								NULL,
								&regHdl,
								&disposition
								);
	ASSERTMSG ("Can't create registry key. ", status==NO_ERROR);

	length = sizeof (DWORD);
	status = RegQueryValueEx (regHdl, TicksWrapAroundValueName, NULL, NULL,
									 (PUCHAR)&value, &length);

	if (status==NO_ERROR)
		MaxTicks = value;

	length = sizeof (DWORD);
	status = RegQueryValueEx (regHdl, MaxMessagesValueName, NULL, NULL,
									 (PUCHAR)&value, &length);

	if (status==NO_ERROR)
		MaxMessages = value;

	while (!Done) {
		status = MsgWaitForMultipleObjects (1, &RegChangeEvt,
											FALSE, INFINITE, QS_ALLINPUT);
		if (status==(WAIT_OBJECT_0+1)) {
			while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) {
				if (msg.message==WM_QUIT) {
					Done = TRUE;
					break;
					}
				else if (!IsWindow(RTDlg)
					|| !IsDialogMessage(RTDlg, &msg)) {
					TranslateMessage (&msg);
					DispatchMessage (&msg);
					}
				}
			}
		else if (status==WAIT_OBJECT_0) {
			length = sizeof (DWORD);
			status = RegQueryValueEx (regHdl, DbgLevelValueName, NULL, NULL,
											 (PUCHAR)&DbgLevel, &length);
			if (status!=NO_ERROR)
				DbgLevel = 0;

			IF_DEBUG (DISPLAY_TABLE) {
				if (!IsWindow(RTDlg)) {
					RTDlg = CreateDialog (DLLInstanceHdl,
									MAKEINTRESOURCE (IDD_RTM_TABLE),
									NULL,
									&RTDlgProc);

					ASSERTERR (RTDlg!=NULL);
					}
				}
			else {
				if (IsWindow (RTDlg)) {
					DestroyWindow (RTDlg);
					RTDlg = NULL;
					}
				}
					

			status = RegNotifyChangeKeyValue (regHdl,
									 FALSE,
									 REG_NOTIFY_CHANGE_LAST_SET,
									 RegChangeEvt,
									 TRUE);
			ASSERTMSG ("Can't start registry notifications. ",
													 status==NO_ERROR);
			}
		}

	if (IsWindow (RTDlg)) {
		DestroyWindow (RTDlg);
		RTDlg = NULL;
		}
	RegCloseKey (regHdl);
	return 0;
	}
#undef DLLInstanceHdl

	// Dialog box procedure
INT_PTR CALLBACK
RTDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL		res = FALSE;
	char		buf[32];
	int			idx;
	TIMER_BASIC_INFORMATION	TimerInfo;
	DWORD		status;

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
								// Fill in protocol family combo box
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IPX,
							(LPARAM)"IPX"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IP,
							(LPARAM)"IP"
							);

			DisplayedTableIdx = RTM_PROTOCOL_FAMILY_IPX;
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY,
							CB_SETCURSEL,
							DisplayedTableIdx,
							0
							);

				// Start timer (updates improvized clock)
			SetTimer (hDlg, 0, 1000, NULL);

			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					res = FALSE;
					break;
				case IDC_PROTOCOL_FAMILY:
					if (HIWORD(wParam)==CBN_SELENDOK) {
						DWORD	newFamily = (DWORD)SendMessage (
												        (HWND)lParam,
												        CB_GETCURSEL,
												        0, 0);
						if ((newFamily!=CB_ERR)
							&& (newFamily!=DisplayedTableIdx)) {
								// Change the displayed table if
								// user makes different selection
                            DisplayedTableIdx = newFamily;
							SendDlgItemMessage (hDlg,
									IDL_ROUTES,
									LB_RESETCONTENT,
									0, 0);
							if (Tables[DisplayedTableIdx].RT_Heap!=NULL) {
								ConsolidateNetNumberLists (&Tables[DisplayedTableIdx]);
								FillUpRouteLB ();
								}
							}
						} 
					break;
//				case IDL_ROUTES:
//						// Update entry on which user double clicks
//					if (HIWORD(wParam)==LBN_SELCHANGE)
//						UpdateLBSelections ();
//					break;
				case IDB_RESYNC:
					SendDlgItemMessage (hDlg,
							IDL_ROUTES,
							LB_RESETCONTENT,
							0, 0);
					if (Tables[DisplayedTableIdx].RT_Heap!=NULL) {
						ConsolidateNetNumberLists (&Tables[DisplayedTableIdx]);
						FillUpRouteLB ();
						}
					break;
				}
			break;
		
		case WM_TIMER:
				// Update improvised clock
			sprintf (buf, "%08d", GetTickCount ()/1000);
			SendDlgItemMessage (hDlg, IDT_TICK_COUNT, WM_SETTEXT,
									 		0, (LPARAM)buf);
			status = NtQueryTimer (
						Tables[DisplayedTableIdx].RT_ExpirationTimer,
						TimerBasicInformation,
						&TimerInfo,
						sizeof (TimerInfo),
						NULL);
			if (NT_SUCCESS (status)) {
				if (!TimerInfo.TimerState)
					sprintf (buf, "%08d",
						(ULONG)((LONGLONG)TimerInfo.RemainingTime.QuadPart
									/(10000*1000)));
				else
					sprintf (buf, "Not set");
				}
			else
				sprintf (buf, "error");
			SendDlgItemMessage (hDlg, IDT_EXPIRATION, WM_SETTEXT,
									 		0, (LPARAM)buf);

			status = NtQueryTimer (
						Tables[DisplayedTableIdx].RT_UpdateTimer,
						TimerBasicInformation,
						&TimerInfo,
						sizeof (TimerInfo),
						NULL);
			if (NT_SUCCESS (status)) {
				if (!TimerInfo.TimerState)
					sprintf (buf, "%08d",
						(ULONG)((LONGLONG)TimerInfo.RemainingTime.QuadPart
									/(10000*1000)));
				else
					sprintf (buf, "Not set");
				}
			else
				sprintf (buf, "error");
			SendDlgItemMessage (hDlg, IDT_UPDATE, WM_SETTEXT,
									 		0, (LPARAM)buf);
			res = TRUE;
			break;
		case RT_ADDROUTE:
			SendDlgItemMessage (hDlg, IDL_ROUTES,
										LB_INSERTSTRING, wParam, lParam);
//			Trace2 (ANY, "%2d - %s added\n", wParam, lParam);
			GlobalFree ((VOID *)lParam);
			res = TRUE;
			break;

		case RT_DELETEROUTE:
			idx = (int) SendDlgItemMessage (hDlg, IDL_ROUTES,
										LB_FINDSTRING, (WPARAM)0, lParam);
			if (idx!=LB_ERR)
				SendDlgItemMessage (hDlg, IDL_ROUTES,
											LB_DELETESTRING, (WPARAM)idx, 0);
//			Trace2 (ANY, "%2d - %s deleted\n", idx, lParam);
			GlobalFree ((VOID *)lParam);
			res = TRUE;
			break;
		case WM_DESTROY:
			DisplayedTableIdx = 0xFFFFFFFF;
			break;
		}

	return res;
	}


// Prints route information
INT
PrintRoute (
	char			*buf,		// Buffer to print to
	PRTM_ROUTE_NODE	node,		// Route to print
	BOOLEAN			full		// Print everything (including variable part)
	) {
	INT res;

	switch (DisplayedTableIdx) {
		case RTM_PROTOCOL_FAMILY_IPX:
			res = sprintf (buf,
					 "     %08x    ",
					 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NET_NUM
					 );
			break;

		case RTM_PROTOCOL_FAMILY_IP:
			res = sprintf (buf,
					 "%08x-%08x",
					 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NET_NUM,
					 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NET_MSK
					 );
			break;
		}
	res += sprintf (&buf[res],
				" %4d %4d",
				 node->RN_Route.XX_INTERFACE,
				 node->RN_Route.XX_PROTOCOL);

	switch (DisplayedTableIdx) {
		case RTM_PROTOCOL_FAMILY_IPX:
			res += sprintf (&buf[res],
				 "   %02x%02x%02x%02x%02x%02x  ",
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[0],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[1],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[2],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[3],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[4],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[5]
				 );
			break;

		case RTM_PROTOCOL_FAMILY_IP:
			res += sprintf (&buf[res],
				 " %08x-%08x",
				 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NEXT_HOP_NUM,
				 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NEXT_HOP_MSK
				 );
			break;
		}

	if (full) {
		switch (DisplayedTableIdx) {
			case RTM_PROTOCOL_FAMILY_IPX:
				res += sprintf (&buf[res],
						" %6d %08d %1d %1d",
				 		((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_METRIC,
						node->RN_ExpirationTime/1000,
						IsBest (node),
						IsEnabled (node));
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				res += sprintf (&buf[res],
						" %6d %08d %1d %1d",
				 		((PRTM_IP_ROUTE)&node->RN_Route)->IP_METRIC,
						node->RN_ExpirationTime/1000,
						IsBest (node),
						IsEnabled (node));
				break;
			}
		}
	return res;
	}


// Fills list box with all routes in the current table
VOID
FillUpRouteLB (
	void
	) {
	PLIST_ENTRY			cur;
	INT					idx=0;
	PRTM_TABLE			Table = &Tables[DisplayedTableIdx];

		// Make sure we own the table while printing
	EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE);
	cur = Table->RT_NetNumberMasterList.RSL_Head.Flink;

	while (cur!=&Table->RT_NetNumberMasterList.RSL_Head) {
		PRTM_ROUTE_NODE		node = CONTAINING_RECORD (cur,
										RTM_ROUTE_NODE,
										RN_Links[RTM_NET_NUMBER_LIST_LINK]);
		if (!IsEnumerator (node))
			AddRouteToLB (Table, node, idx++);

		cur = cur->Flink;
		}

	LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
	}
	

// Insert line with item data at specified position in the list box
VOID
AddRouteToLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node,
	INT					idx
	) {
	char		*buf;

	if (IsWindow (RTDlg)
		&& (Table==&Tables[DisplayedTableIdx])) {
		buf = (char *)GlobalAlloc (GMEM_FIXED, 80);

			// Print node
		PrintRoute (buf, node, TRUE);
			// Insert at specified position
		SendNotifyMessage (RTDlg, RT_ADDROUTE, (WPARAM)idx, (LPARAM)buf);
		}
	}

// Deletes route line from the list box
VOID
DeleteRouteFromLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node
	) {
	char		*buf;

	if (IsWindow (RTDlg)
		&& (Table==&Tables[DisplayedTableIdx])) {
		buf = (char *)GlobalAlloc (GMEM_FIXED, 80);

			// Print route info
		PrintRoute (buf, node, FALSE);
			// Find corresponding line in the list
		SendNotifyMessage (RTDlg, RT_DELETEROUTE, 0, (LPARAM)buf);
		}
		
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmdb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtm.c

Abstract:
	Routing Table Manager DLL. Helper routines


Author:

	Vadim Eydelman

Revision History:

--*/

#include "pchrtm.h"
#pragma hdrstop


// Initializes sync list object
VOID
InitializeSyncList (
	PRTM_SYNC_LIST	list
	) {
	list->RSL_Sync = NULL;
	list->RSL_UseCount = 0;
	InitializeListHead (&list->RSL_Head);
	}

// Get mutually exclusive access to the sync list obect
// Returns TRUE if access if obtained, FALSE otherwise
BOOLEAN
DoEnterSyncList (
	PRTM_TABLE		table,		// Table this list belongs to
	PRTM_SYNC_LIST	list,		// List of interest
	BOOLEAN			wait		// True if caller wants to wait
								// until list becomes available
#if DBG
    , LPSTR         file,
    ULONG           line
#endif
	) {
	DWORD			status;		// Status of OS calls
	BOOLEAN			result;		// Result of operation

	EnterCriticalSection (&table->RT_Lock);
		// Protect manipilation by table-wide critical section
#if DBG
	IF_DEBUG (SYNCHRONIZATION)
		Trace4 (ANY, "%08lx (%s,%ld) - trying to enter sync list: %08x\n",
							GetCurrentThreadId (), file, line, (ULONG_PTR)list);
#endif
	if (list->RSL_UseCount<=0) {
			// Nobody uses the list -> get it and return ok
		list->RSL_UseCount = 1;
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace0 (ANY, "\t - first to enter\n");
#endif
		result = TRUE;
		}
	else if (wait) { // Somebody is using it, but caller agrees to wait
		list->RSL_UseCount += 1;	// Increment usage count
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace1 (ANY, "\t - list in use: %d\n", list->RSL_UseCount);
#endif
		if (list->RSL_Sync==NULL) {	// if there is no event to wait on,
									// get one
									// First see if one is available
									// in the stack
			PSINGLE_LIST_ENTRY cur = PopEntryList (&table->RT_SyncObjectList);

#if DBG
			IF_DEBUG (SYNCHRONIZATION)
				Trace0 (ANY, "\t - need event\n");
#endif
			if (cur==NULL) {		// No, we'll have to create one
				PRTM_SYNC_OBJECT	sync;
				sync = (PRTM_SYNC_OBJECT)GlobalAlloc (
									GMEM_FIXED,
									sizeof (RTM_SYNC_OBJECT));
				if (sync==NULL) {
#if DBG
					Trace2 (ANY, 
				 				"Can't allocate synchronization object.\n"
				 				"\tat line %ld of %s\n",
								__LINE__, __FILE__);
#endif
                    list->RSL_UseCount -= 1;
					LeaveCriticalSection (&table->RT_Lock);
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
					return FALSE;
					}

				sync->RSO_Event = CreateEvent (NULL,
												FALSE,	// Auto reset event
												FALSE,	// Initially nonsignaled
												NULL);
				if (sync->RSO_Event==NULL) {
                    status = GetLastError ();
#if DBG
					Trace2 (ANY, 
				 				"Can't allocate synchronization event.\n"
				 				"\tat line %ld of %s\n",
								__LINE__, __FILE__);
#endif
                    list->RSL_UseCount -= 1;
                    GlobalFree (sync);
					LeaveCriticalSection (&table->RT_Lock);
                    SetLastError (status);
					return FALSE;
					}

				list->RSL_Sync = sync;
#if DBG
				IF_DEBUG (SYNCHRONIZATION)
					Trace0 (ANY, "\t - event created\n");
#endif
				}
			else {	// Yes, make sure it is reset
				list->RSL_Sync = CONTAINING_RECORD (cur, RTM_SYNC_OBJECT, RSO_Link);
// Autoreset event gets reset after releasing a thread anyway
//				status = ResetEvent (list->RSL_Sync->RSO_Event);
//				ASSERTERRMSG ("Can't reset event.", status);
				}
			}
				// Now as we set up the object to wait, we can leave critical
				// section and wait on event
		LeaveCriticalSection (&table->RT_Lock);
		status = WaitForSingleObject (
							list->RSL_Sync->RSO_Event,
							INFINITE
							);
		ASSERTERRMSG ("Wait event failed.", status==WAIT_OBJECT_0);
	
			// Event is signaled, we may now access the list (auto reset event
			// releases only one thread
		EnterCriticalSection (&table->RT_Lock);

#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace1 (ANY, "%08lx - wait completed\n", GetCurrentThreadId ());
#endif

			// If our caller was the only one waiting,
			// we can release the event
		if (list->RSL_UseCount==1) {
#if DBG
			IF_DEBUG (SYNCHRONIZATION)
				Trace0 (ANY, "\t - restocking event\n");
#endif
			PushEntryList (&table->RT_SyncObjectList, &list->RSL_Sync->RSO_Link);
			list->RSL_Sync = NULL;
			}
		result = TRUE;
		}
	else {
		// Caller does not want to wait
		result = FALSE;
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace0 (ANY, "\t - doesn't want to wait\n");
#endif
		}

	LeaveCriticalSection (&table->RT_Lock);

	return result;
	}


// Release previously owned sync list object
VOID
LeaveSyncList (
	PRTM_TABLE		table,		// Table to which this object belongs
	PRTM_SYNC_LIST	list		// List to release
	) {
	DWORD			status;
								
	EnterCriticalSection (&table->RT_Lock);
#if DBG
	IF_DEBUG (SYNCHRONIZATION)
		Trace2 (ANY, "%08lx - leaving sync list: %08x\n",
									GetCurrentThreadId (), (ULONG_PTR)list);
#endif
			// Decrement the count and signal the event (only one thread
			// will be released for the auto-reset events
	list->RSL_UseCount -= 1;
	if (list->RSL_UseCount>0) {
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace1 (ANY, "%\t - releasing one of %d waiting threads\n",
															list->RSL_UseCount);
#endif
		status = SetEvent (list->RSL_Sync->RSO_Event);
		ASSERTERRMSG ("Can't signal event.", status);
		}
	LeaveCriticalSection (&table->RT_Lock);
	}






// Finds list of routes that are associated with given interface and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindInterfaceList (
	PRTM_SYNC_LIST	intfHash,
	DWORD			InterfaceID,	// Interface to look for
	BOOL			CreateNew
	) {
	PRTM_INTERFACE_NODE intfNode;
	PLIST_ENTRY			cur;

		// First try to find existing one in the list of interface lists
	cur = intfHash->RSL_Head.Flink;
	while (cur!=&intfHash->RSL_Head) {
		intfNode = CONTAINING_RECORD (cur, RTM_INTERFACE_NODE, IN_Link);
		if (InterfaceID<=intfNode->IN_InterfaceID) // List is ordered
												// so we can stop
												// if bigger number is reached
			break;
		cur = cur->Flink;
		}

		
	if ((cur==&intfHash->RSL_Head)
		|| (InterfaceID!=intfNode->IN_InterfaceID)) { // Create new interface
													// list
		if (!CreateNew)
			return NULL;

		intfNode = (PRTM_INTERFACE_NODE)GlobalAlloc (
										GMEM_FIXED,
										sizeof (RTM_INTERFACE_NODE));
		if (intfNode==NULL) {
	#if DBG
	 				// Report error in debuging builds
			Trace2 (ANY, 
		 				"Can't allocate interface node\n\tat line %ld of %s\n",
						__LINE__, __FILE__);
	#endif
			return NULL;
			}

		intfNode->IN_InterfaceID = InterfaceID;
		InitializeListHead (&intfNode->IN_Head);	// Insert it in
													// list of interface lists
		InsertTailList (cur, &intfNode->IN_Link);
		}

	return &intfNode->IN_Head;
	}

#if RTM_USE_PROTOCOL_LISTS
// Finds list of routes that are associated with given iprotocol and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindProtocolList (
	PRTM_TABLE	Table,
	DWORD		RoutingProtocol,
	BOOL		CreateNew
	) {
	PRTM_PROTOCOL_NODE protNode;
	PLIST_ENTRY			cur;

	cur = Table->RT_ProtocolList.RSL_Head.Flink;
	while (cur!=&Table->RT_ProtocolList.RSL_Head) {
		protNode = CONTAINING_RECORD (cur, RTM_PROTOCOL_NODE, PN_Link);
		if (RoutingProtocol<=protNode->PN_RoutingProtocol)
			break;
		cur = cur->Flink;
		}

	if ((cur==&Table->RT_ProtocolList.RSL_Head)
		|| (RoutingProtocol!=protNode->PN_RoutingProtocol)) {
		
		if (!CreateNew)
			return NULL;

		protNode = (PRTM_PROTOCOL_NODE)GlobalAlloc (
										GMEM_FIXED,
										sizeof (RTM_PROTOCOL_NODE));
		if (protNode==NULL) {
#if DBG
	 				// Report error in debuging builds
			Trace2 (ANY, 
		 				"Can't allocate protocol node\n\tat line %ld of %s\n",
						__LINE__, __FILE__);
#endif
			return NULL;
			}

		protNode->PN_RoutingProtocol = RoutingProtocol;
		InitializeListHead (&protNode->PN_Head);
		InsertTailList (cur, &protNode->PN_Link);
		}

	return &protNode->PN_Head;
	}
#endif

// Adds node to temporary net number list (to be later merged with master list)
// Both lists are ordered by net number.interface.protocol.next hop address
VOID
AddNetNumberListNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	) {
	PLIST_ENTRY		cur;
	INT				res;
	
	cur = Table->RT_NetNumberTempList.RSL_Head.Flink;
	while (cur!=&Table->RT_NetNumberTempList.RSL_Head) {
		PRTM_ROUTE_NODE node = CONTAINING_RECORD (
								cur,
								RTM_ROUTE_NODE,
								RN_Links[RTM_NET_NUMBER_LIST_LINK]
								);
		res = NetNumCmp (Table, &newNode->RN_Route, &node->RN_Route);
		if ((res<0)
			||((res==0)
			  &&((newNode->RN_Route.XX_PROTOCOL
						< node->RN_Route.XX_PROTOCOL)
				||((newNode->RN_Route.XX_PROTOCOL
						==node->RN_Route.XX_PROTOCOL)
				  &&((newNode->RN_Route.XX_INTERFACE
								< node->RN_Route.XX_INTERFACE)
					||((newNode->RN_Route.XX_INTERFACE
							== node->RN_Route.XX_INTERFACE)
					  && (NextHopCmp (Table, &newNode->RN_Route,
					  						&node->RN_Route)
							< 0)))))))
			break;
		cur = cur->Flink;
		}

	InsertTailList (cur, &newNode->RN_Links[RTM_NET_NUMBER_LIST_LINK]);
	}


// Adds node to expiration time queue.  (Queue is ordered by expiration time)
// Return TRUE if new node is the first in the queue
BOOL
AddExpirationQueueNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	) {
	PLIST_ENTRY		cur;
	BOOL			res = TRUE;
	
		// We'll travers the queue from the back, because normally
		// new entries are added closer the end of the queue
	cur = Table->RT_ExpirationQueue.RSL_Head.Blink;
	while (cur!=&Table->RT_ExpirationQueue.RSL_Head) {
		PRTM_ROUTE_NODE node = CONTAINING_RECORD (
								cur,
								RTM_ROUTE_NODE,
								RN_Links[RTM_EXPIRATION_QUEUE_LINK]
								);
		if (IsLater(newNode->RN_ExpirationTime, node->RN_ExpirationTime)) {
			res = FALSE;
			break;
			}
		cur = cur->Blink;
		}

	InsertHeadList (cur, &newNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
	return res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtm.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtm.c

Abstract:
        Routing Table Manager DLL. Main module


Author:

        Vadim Eydelman

Revision History:

--*/

#include "pchrtm.h"
#pragma hdrstop

/* ****** Global data ****** */

// Tables themselves
RTM_TABLE       Tables[RTM_NUM_OF_PROTOCOL_FAMILIES];



MASK_ENTRY      g_meMaskTable[ MAX_MASKS + 1 ] =
{
    { 0x00000000, 0 },

    { 0x00000001, 0 },
    { 0x00000003, 0 },
    { 0x00000007, 0 },
    { 0x0000000F, 0 },

    { 0x0000001F, 0 },
    { 0x0000003F, 0 },
    { 0x0000007F, 0 },
    { 0x000000FF, 0 },
    
    { 0x000080FF, 0 },
    { 0x0000C0FF, 0 },
    { 0x0000E0FF, 0 },
    { 0x0000F0FF, 0 },
    
    { 0x0000F8FF, 0 },
    { 0x0000FCFF, 0 },
    { 0x0000FEFF, 0 },
    { 0x0000FFFF, 0 },
    
    { 0x0080FFFF, 0 },
    { 0x00C0FFFF, 0 },
    { 0x00E0FFFF, 0 },
    { 0x00F0FFFF, 0 },
    
    { 0x00F8FFFF, 0 },
    { 0x00FCFFFF, 0 },
    { 0x00FEFFFF, 0 },
    { 0x00FFFFFF, 0 },
    
    { 0x80FFFFFF, 0 },
    { 0xC0FFFFFF, 0 },
    { 0xE0FFFFFF, 0 },
    { 0xF0FFFFFF, 0 },
    
    { 0xF8FFFFFF, 0 },
    { 0xFCFFFFFF, 0 },
    { 0xFEFFFFFF, 0 },
    { 0xFFFFFFFF, 0 }
};

#if DBG
DWORD    dbgThreadId;
ULONG    TracingHandle;
DWORD    TracingInited;
HANDLE   LoggingHandle;
ULONG    LoggingLevel;
#endif

/* ***** Internal Function Prototypes ******* */

VOID
NotifyClients (
    PRTM_TABLE              Table,
    HANDLE                  ClientHandle,
    DWORD                   Flags,
    PRTM_XX_ROUTE           CurBestRoute,
    PRTM_XX_ROUTE           PrevBestRoute
    );

VOID APIENTRY
ConsolidateNetNumberListsWI (
    PVOID                   Context
    );

VOID
ConsolidateNetNumberLists (
    PRTM_TABLE                      Table
    );

VOID APIENTRY
ScheduleUpdate (
    PVOID           Context
    );

VOID APIENTRY
ProcessExpirationQueueWI (
    PVOID                   Table
    );

VOID
ProcessExpirationQueue (
    PRTM_TABLE              Table
    );

DWORD
ReadRegistry (
    void
    );

DWORD
DoEnumerate (
    PRTM_TABLE              Table,
    PRTM_ENUMERATOR EnumPtr,
    DWORD                   EnableFlag
    );

VOID
SetMaskCount( 
    PIP_NETWORK                 pinNet,
    BOOL                        bAdd
);

#if 0 // Replaced by RTMv2's DLLMain

// DLL main function.  Called by crtdll startup routine that is
// designated as entry point for this dll.
//
//      At startup (DLL_PROCESS_ATTACH): creates all tables and starts update
//                                                                              thread
//      At shutdown (DLL_PROCESS_DETACH): stops update thread and disposes of all
//                                                                              resources

BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,                               // DLL instance handle
    DWORD               fdwReason,                              // Why is it called
    LPVOID      lpvReserved
    ) {

    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:     // We are being attached to a new process
            // Create all we need to operate
            DisableThreadLibraryCalls (hinstDLL);

            return Rtmv1DllStartup(hinstDLL);

        case DLL_PROCESS_DETACH:    // The process is exiting

            Rtmv1DllCleanup();

        default:                    // Not interested in all other cases
            return TRUE;
            break;
    }
}

#endif

BOOL
Rtmv1DllStartup (
    HINSTANCE   hinstDLL  // DLL instance handle
    )
{
    DWORD                   i;

    // Create all we need to operate

#if DBG
    RTDlgThreadHdl  = CreateThread (
        NULL,
        0,
        &RTDialogThread,
        (LPVOID)hinstDLL,
        0,
        &dbgThreadId);
    ASSERTERR (RTDlgThreadHdl!=NULL);
#endif

    for (i=0; i<RTM_NUM_OF_PROTOCOL_FAMILIES; i++) {
        Tables[i].RT_APIclientCount = RTM_CLIENT_STOP_TRESHHOLD;
        Tables[i].RT_Heap = NULL;
    }

    return TRUE;
}

VOID
Rtmv1DllCleanup (
    )
{
    DWORD                   status;
    DWORD                   i;

#if DBG
    PostThreadMessage (dbgThreadId, WM_QUIT, 0, 0);
    status = WaitForSingleObject (RTDlgThreadHdl, 5*1000);

    // 
    // Give some time to the RTDialogThread to process 
    // the WM_QUIT message and exit. 
    // If it is not quitting, its better to just 
    // leave it alone rather than terminating it.
    //

    // if (status!=WAIT_OBJECT_0)
    //     TerminateThread (RTDlgThreadHdl, 0);
    CloseHandle (RTDlgThreadHdl);

    // Deregister with tracing utils
    STOP_TRACING();
#endif

    // Dispose of all resources
    for (i=0; i<RTM_NUM_OF_PROTOCOL_FAMILIES; i++) {
        if (Tables[i].RT_Heap!=NULL)
            RtmDeleteRouteTable (i);
    }

    return;
}

/*++
*******************************************************************

        R t m C r e a t e R o u t e T a b l e

Routine Description:
        Create route table for protocol family
Arguments:
        ProtocolFamily - index that identifies protocol family
        Config - protocol family table configuration parameters
Return Value:
        NO_ERROR - table was created ok
        ERROR_NOT_ENOUGH_MEMORY - could not allocate memory to perform
                                                the operation
        ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
                                                        try again later

*******************************************************************
--*/
DWORD
RtmCreateRouteTable (
    IN DWORD                                                        ProtocolFamily,
    IN PRTM_PROTOCOL_FAMILY_CONFIG          Config
    ) {
    INT                             i;
    DWORD                   status;
    PRTM_TABLE              Table;

#if DBG
    // Register with tracing utils
    START_TRACING();
#endif

    if (ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES) {
#if DBG
        Trace2 ( ANY,
                 "Undefined Protocol Family.\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }

    Table = &Tables[ProtocolFamily];
    if (Table->RT_Heap!=NULL) {
#if DBG
        Trace2 ( ANY,
                 "Table already exists for protocol family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_ALREADY_EXISTS;
    }

    memcpy (&Table->RT_Config, Config, sizeof (Table->RT_Config));

    status = NtCreateTimer (&Table->RT_ExpirationTimer,
                            TIMER_ALL_ACCESS,
                            NULL,
                            NotificationTimer);

    if (!NT_SUCCESS (status))
        return ERROR_NO_SYSTEM_RESOURCES;

    status = NtCreateTimer (&Table->RT_UpdateTimer,
                            TIMER_ALL_ACCESS,
                            NULL,
                            NotificationTimer);

    if (!NT_SUCCESS (status)) {
        NtClose (Table->RT_ExpirationTimer);
        return ERROR_NO_SYSTEM_RESOURCES;
    }


    Table->RT_Heap = HeapCreate (0, 0, Table->RT_Config.RPFC_MaxTableSize);
    if (Table->RT_Heap==NULL) {
        NtClose (Table->RT_UpdateTimer);
        NtClose (Table->RT_ExpirationTimer);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Table->RT_NetNumberHash = (PRTM_SYNC_LIST)HeapAlloc (
        Table->RT_Heap,
        0,
        sizeof (RTM_SYNC_LIST)*Table->RT_HashTableSize);

    if (Table->RT_NetNumberHash==NULL) {
        status = GetLastError ();
        HeapDestroy (Table->RT_Heap);
        NtClose (Table->RT_UpdateTimer);
        NtClose (Table->RT_ExpirationTimer);
        return status;
    }

    Table->RT_InterfaceHash = (PRTM_SYNC_LIST)HeapAlloc (
        Table->RT_Heap,
        0,
        sizeof (RTM_SYNC_LIST)*RTM_INTF_HASH_SIZE);

    if (Table->RT_InterfaceHash==NULL) {
        status = GetLastError ();
        HeapDestroy (Table->RT_Heap);
        NtClose (Table->RT_UpdateTimer);
        NtClose (Table->RT_ExpirationTimer);
        return status;
    }

    try {
        InitializeCriticalSection (&Table->RT_Lock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    Table->RT_SyncObjectList.Next = NULL;

    for (i=0; i<Table->RT_HashTableSize; i++)
        InitializeSyncList (&Table->RT_NetNumberHash[i]);
    for (i=0; i<RTM_INTF_HASH_SIZE; i++)
        InitializeSyncList (&Table->RT_InterfaceHash[i]);


#if RTM_USE_PROTOCOL_LISTS
    InitializeSyncList (&Table->RT_ProtocolList);
#endif
    InitializeSyncList (&Table->RT_NetNumberMasterList);
    InitializeSyncList (&Table->RT_NetNumberTempList);
    InitializeSyncList (&Table->RT_DeletedList);

    InitializeSyncList (&Table->RT_ExpirationQueue);
    InitializeSyncList (&Table->RT_RouteChangeQueue);
    InitializeSyncList (&Table->RT_ClientList);

    Table->RT_NetNumberTempCount = 0;
    Table->RT_DeletedNodesCount = 0;
    Table->RT_UpdateWorkerPending = -1;
    Table->RT_ExpirationWorkerPending = -1;

    Table->RT_NetworkCount = 0;
    Table->RT_NumOfMessages = 0;

    InterlockedIncrement (&Table->RT_UpdateWorkerPending);
    status = RtlQueueWorkItem (ScheduleUpdate, Table, WT_EXECUTEINIOTHREAD);
    ASSERTMSG ("Could not queue update scheduling work item ", status==STATUS_SUCCESS);

    Table->RT_APIclientCount = 0;
    return NO_ERROR;
}


/*++
*******************************************************************

        R t m D e l e t e R o u t e T a b l e

Routine Description:
        Dispose of all resources allocated for the route table
Arguments:
        ProtocolFamily - index that identifies protocol family
Return Value:
        NO_ERROR - table was deleted ok
        ERROR_INVALID_PARAMETER - no table to delete

*******************************************************************
--*/
DWORD
RtmDeleteRouteTable (
    DWORD           ProtocolFamily
    ) {
    PSINGLE_LIST_ENTRY      cur;
    PRTM_TABLE                      Table;
    LONG                            curAPIclientCount;

    if (ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family.\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }

    Table = &Tables[ProtocolFamily];
    if (Table->RT_Heap==NULL) {
#if DBG
        Trace3 (ANY, 
                 "Table does not exist or already deleted for protocol family %d\n"
                 "\tat line %ld of %s\n",
                 ProtocolFamily, __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }

    while (!IsListEmpty (&Table->RT_ClientList.RSL_Head)) {
        PRTM_CLIENT     ClientPtr = CONTAINING_RECORD (
            Table->RT_ClientList.RSL_Head.Flink,
            RTM_CLIENT,
            RC_Link);
        RtmDeregisterClient ((HANDLE)ClientPtr);
    }

    curAPIclientCount = InterlockedExchange (&Table->RT_APIclientCount,
                                             RTM_CLIENT_STOP_TRESHHOLD)
        + RTM_CLIENT_STOP_TRESHHOLD;

    while (Table->RT_APIclientCount > curAPIclientCount)
        Sleep (100);

    while (InterlockedIncrement (&Table->RT_ExpirationWorkerPending)>0) {
        while (Table->RT_ExpirationWorkerPending!=-1)
            Sleep (100);
    }

    while (InterlockedIncrement (&Table->RT_UpdateWorkerPending)>0) {
        while (Table->RT_UpdateWorkerPending!=-1)
            Sleep (100);
    }
    NtCancelTimer (Table->RT_UpdateTimer, NULL);
    NtCancelTimer (Table->RT_ExpirationTimer, NULL);
    Sleep (100);

    NtClose (Table->RT_UpdateTimer);
    NtClose (Table->RT_ExpirationTimer);
    Sleep (100);

    cur = PopEntryList (&Table->RT_SyncObjectList);
    while (cur!=NULL) {
        GlobalFree (CONTAINING_RECORD (cur, RTM_SYNC_OBJECT, RSO_Link));
        cur = PopEntryList (&Table->RT_SyncObjectList);
    }

    HeapFree (Table->RT_Heap, 0, Table->RT_InterfaceHash);
    HeapFree (Table->RT_Heap, 0, Table->RT_NetNumberHash);
    HeapDestroy (Table->RT_Heap);
    Table->RT_Heap = NULL;
    DeleteCriticalSection (&Table->RT_Lock);
    return NO_ERROR;
}

// Registers client as a handler of specified protocol
// Returns a HANDLE be used for all subsequent
// calls to identify which Protocol Family and Routing Protocol
// should be affected by the call
// Returns NULL in case of failure. Call GetLastError () to obtain
// extended error information.
// Error codes:
//      ERROR_INVALID_PARAMETER - specified protocol family is not supported
//      ERROR_CLIENT_ALREADY_EXISTS - another client already registered
//                                                      to handle specified protocol
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client control block
HANDLE WINAPI
RtmRegisterClient (
    IN DWORD                ProtocolFamily,         // IP, IPX, etc.
    IN DWORD            RoutingProtocol,        // RIP, OSPF, etc.
    IN HANDLE               ChangeEvent OPTIONAL,// Notified when best
    // routes change in the table (see
    // RtmDequeueRouteChangeMessage
    IN DWORD                Flags
    ) {
    HANDLE                  ClientHandle;
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    PRTM_TABLE              Table;                          // Table we associated with
    DWORD                   status;                         // Operation result
    PLIST_ENTRY             cur;

    // Check if we have the table of interest
    Table = &Tables[ProtocolFamily];

    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family.\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }


    if (Flags & (~RTM_PROTOCOL_SINGLE_ROUTE)) {
#if DBG
        Trace2 (ANY, 
                 "Invalid registration flags\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        ExitTableAPI(Table);
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }
    // Allocate handle and initialize basic fields
    ClientHandle = GlobalAlloc (GMEM_FIXED, sizeof (RTM_CLIENT));
    if (ClientHandle==NULL) {
        ExitTableAPI(Table);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    ClientPtr->RC_RoutingProtocol = RoutingProtocol;
    ClientPtr->RC_NotificationEvent = ChangeEvent;
    ClientPtr->RC_Flags = Flags;

                                                        // Lock client list as we adding a new one
    if (!EnterSyncList (Table, &Table->RT_ClientList, TRUE)) {
        GlobalFree (ClientHandle);
        ExitTableAPI (Table);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return NULL;
    }
    // Check if we have another client with same
    // Routing Protocol

    cur = Table->RT_ClientList.RSL_Head.Flink;
    while (cur!=&Table->RT_ClientList.RSL_Head) {
        PRTM_CLIENT node = CONTAINING_RECORD (cur,
                                              RTM_CLIENT,
                                              RC_Link);
        if (ClientPtr->RC_RoutingProtocol< node->RC_RoutingProtocol)
            break;
        else if (ClientPtr->RC_RoutingProtocol==node->RC_RoutingProtocol) {
            LeaveSyncList (Table, &Table->RT_ClientList);
            GlobalFree (ClientHandle);
            ExitTableAPI (Table);
            SetLastError (ERROR_CLIENT_ALREADY_EXISTS);
            return NULL;
        }
        cur = cur->Flink;
    }
    // Check if client needs notifications
    if (ChangeEvent!= NULL) {
        status = ResetEvent (ChangeEvent); // Nothing yet
        ASSERTERRMSG ("Can't reset client's event.", status);
        // Lock notification messages queue
        if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
            LeaveSyncList (Table, &Table->RT_ClientList);
            GlobalFree (ClientHandle);
            ExitTableAPI (Table);
            SetLastError (ERROR_NO_SYSTEM_RESOURCES);
            return NULL;
        }

        // Point to the end of the queue: ignore
        // all previous messages
        ClientPtr->RC_PendingMessage = &Table->RT_RouteChangeQueue.RSL_Head;
        LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    }
    // Add client to the list
    InsertTailList (cur, &ClientPtr->RC_Link);
    LeaveSyncList (Table, &Table->RT_ClientList);

    ClientPtr->RC_ProtocolFamily = ProtocolFamily|RTM_CLIENT_HANDLE_TAG;
    ExitTableAPI (Table);
    return ClientHandle;
#undef ClientPtr
}

// Frees resources and the HANDLE allocated above.
// Deletes all routes associated with Routing Protocol that was represented
// by the handle
// Returned error codes:
//      NO_ERROR - handle was disposed of ok
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client control block
DWORD WINAPI
RtmDeregisterClient (
    IN HANDLE               ClientHandle
    ) {
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    RTM_XX_ROUTE            Route;
    PRTM_TABLE                      Table;
    DWORD                           ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    // Lock client list
    if (!EnterSyncList (Table, &Table->RT_ClientList, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // Check if we need to dispose of messages
    // still waiting for this client
    if (ClientPtr->RC_NotificationEvent!= NULL) {
        if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
            LeaveSyncList (Table, &Table->RT_ClientList);
            ExitTableAPI (Table);
            return ERROR_NO_SYSTEM_RESOURCES;
        }

        while (ClientPtr->RC_PendingMessage
               != &Table->RT_RouteChangeQueue.RSL_Head) {
            PRTM_ROUTE_CHANGE_NODE node = CONTAINING_RECORD (
                ClientPtr->RC_PendingMessage,
                RTM_ROUTE_CHANGE_NODE,
                RCN_Link);
            ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
            if (node->RCN_ResponsibleClient!=ClientHandle) {
                // Tell that we processed this message so it can be freed
                // if no more clients are interested
                node->RCN_ReferenceCount -= 1;
                if (node->RCN_ReferenceCount<=0) {
                    RemoveEntryList (&node->RCN_Link);
                    if (node->RCN_Route2!=NULL)
                        HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
                    HeapFree (Table->RT_Heap, 0, node);
                }
            }
        }

        LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    }
    RemoveEntryList (&ClientPtr->RC_Link);
    LeaveSyncList (Table, &Table->RT_ClientList);

    {
        RTM_CLIENT      DeadClient;
        DeadClient.RC_ProtocolFamily = ClientPtr->RC_ProtocolFamily;
        DeadClient.RC_RoutingProtocol = ClientPtr->RC_RoutingProtocol;
        // Invlaidate client's handle memory block
        ClientPtr->RC_ProtocolFamily ^= RTM_CLIENT_HANDLE_TAG;
        GlobalFree (ClientHandle);
        // Delete all routes associated with routing protocol
        // controled by the client
        RtmBlockDeleteRoutes ((HANDLE)&DeadClient, 0, &Route);
    }

    ExitTableAPI (Table);
    return NO_ERROR;
#undef ClientPtr
}

// Dequeues and returns the first change message from the queue.
// Should be called if NotificationEvent is signalled to retrieve
// chage messages pending for the client
// Change messages are generated if best route to some destination
// or any of its routing parameters (metric or protocol specific fields)
// get changed as the result of some route being added, deleted, updated,
// disabled, reenabled, or aged out.  Note that change in protocol specific fields
// or in TimeToLive parameters do not produce notification messages
// Returns NO_ERROR and resets the event if there are no more messages
//              pending for the client,
//      otherwise ERROR_MORE_MESSAGES is returned (client should keep calling
//              until NO_ERROR is returned)
//      ERROR_NO_MESSAGES will be returned if there were no messages
//              to return (can happen if called when event was not signalled)
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmDequeueRouteChangeMessage (
    IN      HANDLE          ClientHandle,                   // Handle that identifies client
    OUT     DWORD           *Flags,                                 // Flags that indentify what
    // is this message about:
    // RTM_ROUTE_ADDED - this message informs
    //      of new route (CurBestRoute is filled with
    //      this route parameters if provided)
    // RTM_ROUTE_DELETED - this message informs
    //      that route was deleted (PrevBestRoute is
    //      filled with this route parameters if provuded)
    // RTM_ROUTE_CHANGED - best route to some network has
    //      changed, (CurBestRoute is filled with parameter
    //      of route that became the best, PrevBestRoute is
    //      filled with parameters of route that was best
    //      before this change)
    OUT PVOID               CurBestRoute    OPTIONAL,
    OUT     PVOID           PrevBestRoute   OPTIONAL
    ){
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    PRTM_ROUTE_CHANGE_NODE  node=NULL;
    DWORD                                   status;
    PRTM_TABLE                              Table;
    DWORD                                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }

    // Events are reported only to the clients that
    // requested them by providing notification event
    if (ClientPtr->RC_NotificationEvent==NULL) {
#if DBG
        Trace2 (ANY, 
                 "Dequeue message is called by the client that did not provide."
                 " notification event\n"
                 "\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        ExitTableAPI (Table);
        return ERROR_INVALID_HANDLE;
    }

    if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // Traverse the queue to find the message that was not caused
    // by client's actions
    while (ClientPtr->RC_PendingMessage
           != &Table->RT_RouteChangeQueue.RSL_Head) {
        node = CONTAINING_RECORD (ClientPtr->RC_PendingMessage,
                                  RTM_ROUTE_CHANGE_NODE,
                                  RCN_Link);
        if (node->RCN_ResponsibleClient!=ClientHandle)
            break;
        ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
    }

    if (ClientPtr->RC_PendingMessage!=&Table->RT_RouteChangeQueue.RSL_Head)
        ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
    else {
        // There must be a pending message or we should have been
        // called
#if DBG
        Trace2 (ANY, 
                 "Dequeue message is called, but nothing is pending.\n"
                 "\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        status = ResetEvent (ClientPtr->RC_NotificationEvent);
        ASSERTERRMSG ("Can't reset client's event.", status);
        LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
        ExitTableAPI (Table);
        return ERROR_NO_MESSAGES;
    }

    // Copy message to client's buffers
    *Flags = node->RCN_Flags;
    switch (node->RCN_Flags) {
        case RTM_ROUTE_CHANGED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (PrevBestRoute, &node->RCN_Route2->RN_Route,
                        Table->RT_RouteSize);
            break;
        case RTM_ROUTE_ADDED:
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (CurBestRoute, &node->RCN_Route1, Table->RT_RouteSize);
            break;
        case RTM_ROUTE_DELETED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (PrevBestRoute, &node->RCN_Route1, Table->RT_RouteSize);
            break;
        default:
            ASSERTMSG ("Invalid message flag", FALSE);
            break;
    }


    // Tell that we processed this message so it can be freed if
    // no more clients are interested
    node->RCN_ReferenceCount -= 1;
    if (node->RCN_ReferenceCount<=0) {
        Table->RT_NumOfMessages -= 1;
        RemoveEntryList (&node->RCN_Link);
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
    }

    // Traverse the queue to locate next pending message
    // (not caused by the client)
    while (ClientPtr->RC_PendingMessage
           != &Table->RT_RouteChangeQueue.RSL_Head) {
        node = CONTAINING_RECORD (ClientPtr->RC_PendingMessage,
                                  RTM_ROUTE_CHANGE_NODE,
                                  RCN_Link);
        if (node->RCN_ResponsibleClient!=ClientHandle)
            break;
        ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
    }

    if (ClientPtr->RC_PendingMessage==&Table->RT_RouteChangeQueue.RSL_Head) {
        // All pending messages are processed: reset the event
        status = ResetEvent (ClientPtr->RC_NotificationEvent);
        ASSERTERRMSG ("Can't reset client's event.", status);
        status = NO_ERROR;
    }
    else
        status = ERROR_MORE_MESSAGES;

    LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    ExitTableAPI (Table);
    return status;
#undef ClientPtr
}


// Adds new route change message to the queue and notifies
// all interesed clients
VOID
NotifyClients (
    PRTM_TABLE              Table,                          // Table to which this change applies
    HANDLE                  ClientHandle,           // Client that caused this change (can
    // be NULL if this is a result of
    // route aging)
    DWORD                   Flags,                          // Change message flags
    PRTM_XX_ROUTE           CurBestRoute,           // Current best route for the network
    PRTM_XX_ROUTE           PrevBestRoute           // Previous best route for the network
    ) {
    PRTM_ROUTE_CHANGE_NODE  node;
    PLIST_ENTRY                             cur;
    BOOL                                    nodeInserted = FALSE;

    (*Table->RT_Config.RPFC_Change) (Flags, CurBestRoute, PrevBestRoute);
    // Allocate and initialize queue node
    node = (PRTM_ROUTE_CHANGE_NODE)HeapAlloc (
        Table->RT_Heap,
        0,
        FIELD_OFFSET (RTM_ROUTE_NODE, RN_Route)+Table->RT_RouteSize);
    if (node==NULL)
        return;

    if (Flags==RTM_ROUTE_CHANGED) {
        node->RCN_Route2 = (PRTM_ROUTE_NODE)HeapAlloc (
            Table->RT_Heap,
            0,
            FIELD_OFFSET (RTM_ROUTE_NODE, RN_Route)+Table->RT_RouteSize);
        if (node->RCN_Route2==NULL) {
            HeapFree (Table->RT_Heap, 0, node);
            return;
        }
    }
    else
        node->RCN_Route2 = NULL;

    node->RCN_ReferenceCount = 0;
    node->RCN_ResponsibleClient = ClientHandle;
    node->RCN_Flags = Flags;
    switch (Flags) {
        case RTM_ROUTE_CHANGED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (&node->RCN_Route2->RN_Route, PrevBestRoute,
                        Table->RT_RouteSize);
            break;
        case RTM_ROUTE_ADDED:
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (&node->RCN_Route1, CurBestRoute, Table->RT_RouteSize);
            break;
        case RTM_ROUTE_DELETED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (&node->RCN_Route1, PrevBestRoute, Table->RT_RouteSize);
            break;
        default:
            ASSERTMSG ("Invalid message flag", FALSE);
            break;
    }


    if (!EnterSyncList (Table, &Table->RT_ClientList, TRUE)) {
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
        return ;
    }

    // Find and notify interested clients
    cur = Table->RT_ClientList.RSL_Head.Flink;
    if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
        LeaveSyncList (Table, &Table->RT_ClientList);
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
        return ;
    }

    while (cur!=&Table->RT_ClientList.RSL_Head) {
        PRTM_CLIENT     clientPtr = CONTAINING_RECORD (
            cur,
            RTM_CLIENT,
            RC_Link);
        if (((HANDLE)clientPtr!=ClientHandle)
            && (clientPtr->RC_NotificationEvent!=NULL)) {
            node->RCN_ReferenceCount += 1;
            if (node->RCN_ReferenceCount==1) {
                InsertTailList (&Table->RT_RouteChangeQueue.RSL_Head,
                                &node->RCN_Link);
                Table->RT_NumOfMessages += 1;
            }

            if (clientPtr->RC_PendingMessage
                ==&Table->RT_RouteChangeQueue.RSL_Head) {
                BOOL res = SetEvent (clientPtr->RC_NotificationEvent);
                ASSERTERRMSG ("Can't set client notification event.", res);
                clientPtr->RC_PendingMessage = &node->RCN_Link;
            }
            else if ((Table->RT_NumOfMessages>RTM_MAX_ROUTE_CHANGE_MESSAGES)
                     && (clientPtr->RC_PendingMessage==
                         Table->RT_RouteChangeQueue.RSL_Head.Flink)) {
                PRTM_ROUTE_CHANGE_NODE firstNode = CONTAINING_RECORD (
                    clientPtr->RC_PendingMessage,
                    RTM_ROUTE_CHANGE_NODE,
                    RCN_Link);
#if DBG
                Trace3 (ANY, 
                         "Dequeueing message for 'lazy' client %lx.\n"
                         "\tat line %ld of %s\n",
                         (ULONG_PTR)clientPtr, __LINE__, __FILE__);
#endif
                clientPtr->RC_PendingMessage =
                    clientPtr->RC_PendingMessage->Flink;
                firstNode->RCN_ReferenceCount -= 1;
                if (firstNode->RCN_ReferenceCount==0) {
                    Table->RT_NumOfMessages -= 1;
                    RemoveEntryList (&firstNode->RCN_Link);
                    if (firstNode->RCN_Route2!=NULL)
                        HeapFree (Table->RT_Heap, 0, firstNode->RCN_Route2);
                    HeapFree (Table->RT_Heap, 0, firstNode);
                }

            }

        }
        cur = cur->Flink;
    }

    if (node->RCN_ReferenceCount==0) {
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
    }
    LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    LeaveSyncList (Table, &Table->RT_ClientList);
}


PRTM_ROUTE_NODE
CreateRouteNode (
    PRTM_TABLE              Table,
    PLIST_ENTRY             hashLink,
    PLIST_ENTRY             intfLink,
    BOOL                    intfLinkFinal,
#if RTM_USE_PROTOCOL_LISTS
    PLIST_ENTRY             protLink,
    BOOL                    protLinkFinal,
#endif
    PRTM_SYNC_LIST  hashBasket,
    PRTM_XX_ROUTE           ROUTE
    ) {
    PRTM_SYNC_LIST  intfBasket;
    PRTM_ROUTE_NODE theNode = (PRTM_ROUTE_NODE)HeapAlloc (Table->RT_Heap, 0,
                                                          FIELD_OFFSET (RTM_ROUTE_NODE, RN_Route)+Table->RT_RouteSize);

    if (theNode==NULL) {
#if DBG
        // Report error in debuging builds
        Trace2 (ANY, 
                 "Can't allocate route\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }


    theNode->RN_Flags = RTM_NODE_FLAGS_INIT;
    theNode->RN_Hash = hashBasket;
    memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
    InitializeListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);

    // Make sure we can lock all list before adding
    // We'll keep them locked untill we are sure
    // that route can be added to prevent "partially
    // inserted" entries in case of memory allocation failure, etc.
#if RTM_USE_PROTOCOL_LISTS
    if (!EnterSyncList (Table, &Table->RT_ProtocolList, TRUE)) {
        HeapFree (Table->RT_Heap, 0, theNode);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return NULL;
    }

    if (protLink==NULL) {// If we haven't seen any entries with same
        // net number and protocol, we'll find the
        // protocol list and insert at the end
        protLink = FindProtocolList (Table, ROUTE->XX_PROTOCOL);
        if (protLink==NULL) {
            LeaveSyncList (Table, &Table->RT_ProtocolList);
            HeapFree (Table->RT_Heap, 0, theNode);
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
    }
#endif

    intfBasket = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                           ROUTE->XX_INTERFACE)];
    if (!EnterSyncList (Table, intfBasket, TRUE)) {
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        HeapFree (Table->RT_Heap, 0, theNode);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return NULL;
    }

    if (intfLink==NULL) {
        intfLink = FindInterfaceList (intfBasket, ROUTE->XX_INTERFACE, TRUE);
        if (intfLink==NULL) {
#if RTM_USE_PROTOCOL_LISTS
            LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
            LeaveSyncList (Table, intfBasket);
            HeapFree (Table->RT_Heap, 0, theNode);
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
    }

    if (!EnterSyncList (Table, &Table->RT_NetNumberTempList, TRUE)) {
        LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        HeapFree (Table->RT_Heap, 0, theNode);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // Add route to hash basket list
    InsertTailList (hashLink, &theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK]);
    // Add route to protocol list
#if RTM_USE_PROTOCOL_LISTS
    if (protLinkFinal) {
        InsertTailList (protLink,
                        &theNode->RN_Links[RTM_PROTOCOL_LIST_LINK]);
    }
    else {
        InsertHeadList (protLink,
                        &theNode->RN_Links[RTM_PROTOCOL_LIST_LINK]);
    }
#endif
    // Add it to interface list
    if (intfLinkFinal) {
        InsertTailList (intfLink,
                        &theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
    }
    else {
        InsertHeadList (intfLink,
                        &theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
    }

    // We can now release interface and procotol lists
    // because we are sure that addition to net number sorted
    // list won't fail
    LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
    LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif

    // Add route to temporary net number list (to be later moved
    // to the master list by the update thread)
    AddNetNumberListNode (Table, theNode);
    Table->RT_NetNumberTempCount += 1;
    if (Table->RT_NetNumberTempCount==RTM_TEMP_LIST_MAX_COUNT) {
        if (InterlockedIncrement (&Table->RT_UpdateWorkerPending)==0) {
            DWORD   status;
            status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Table, 0);
            ASSERTERRMSG ("Can't queue update work item", status==STATUS_SUCCESS);
        }
    }

    LeaveSyncList (Table, &Table->RT_NetNumberTempList);

    return theNode;
}


DWORD
RemoveRouteNode (
    PRTM_TABLE              Table,
    PRTM_ROUTE_NODE theNode
    ) {
    PLIST_ENTRY                     head;
    PRTM_SYNC_LIST          intfBasket
        = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                    theNode->RN_Route.XX_INTERFACE)];

#if RTM_USE_PROTOCOL_LISTS
    if (!EnterSyncList (Table, &Table->RT_ProtocolList, TRUE)) {
        LeaveSyncList (Table, &Table->RT_ExpirationQueue);
        return ERROR_NO_SYSTEM_RESOURCES;
    }
#endif
    if (!EnterSyncList (Table, intfBasket, TRUE)) {
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE)) {
        LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    if (!EnterSyncList (Table, &Table->RT_DeletedList, TRUE)) {
        LeaveSyncList (Table, &Table->RT_ExpirationQueue);
        LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        return ERROR_NO_SYSTEM_RESOURCES;
    }



    // Remove node from the interface list
    head = theNode->RN_Links[RTM_INTERFACE_LIST_LINK].Flink;
    RemoveEntryList (&theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
    if (IsListEmpty (head)) {
        PRTM_INTERFACE_NODE     intfNode = CONTAINING_RECORD (head,
                                                              RTM_INTERFACE_NODE,
                                                              IN_Head);
        RemoveEntryList (&intfNode->IN_Link);
        GlobalFree (intfNode);
    }

    LeaveSyncList (Table, intfBasket);


#if RTM_USE_PROTOCOL_LISTS
    RemoveEntryList (&theNode->RN_Links[RTM_PROTOCOL_LIST_LINK]);
    // Remove node from the protocol list
    LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
    // Remove form expiration queue if it was there
    if (IsListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK])) {
        RemoveEntryList (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
    }
    LeaveSyncList (Table, &Table->RT_ExpirationQueue);

                // Remove node from the hash basket list
    RemoveEntryList (&theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK]);
    // let update thread take care of disposing
    InsertHeadList (&Table->RT_DeletedList.RSL_Head,
                    &theNode->RN_Links[RTM_DELETED_LIST_LINK]);
    Table->RT_DeletedNodesCount += 1;
    if (Table->RT_DeletedNodesCount==RTM_DELETED_LIST_MAX_COUNT) {
        if (InterlockedIncrement (&Table->RT_UpdateWorkerPending)==0) {
            DWORD status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Table, 0);
            ASSERTERRMSG ("Can't queue update work item", status==STATUS_SUCCESS);
        }
    }
    LeaveSyncList (Table, &Table->RT_DeletedList);

    return NO_ERROR;
}

// Adds a given route or updates metric, TimeToLive, and reserved fields
// if route with same net number, interface, routing protocol,
// and next hop address already exists in the table
// Returns:
//              NO_ERROR                                - if route was added OK or
//              ERROR_INVALID_PARAMETER - if Route contains invalid parameter (suh as
//                                                              protocol does not match client's protocol)
//              ERROR_NOT_ENOUGH_MEMORY - if route can not be inserted because of memory
//                                                              allocation problem
//              ERROR_NO_SYSTEM_RESOURCES               - not enough resources to lock table content
DWORD WINAPI
RtmAddRoute(
    IN HANDLE           ClientHandle, // Handle that identifies protocol family
    // and routing protocol of the route
    // to add/update (RoutingProtocol field
    // of the Route parameter is ignored)
    // and coordinates this operation with
    // notifications
    // through the event (notificanitons will not
    // be sent to the caller)
    IN PVOID                Route,                  // Route to add
    // Route fields used as input:
    // Destination network
    // Interface through which route was received
    // Address of next hop router
    // Three fields above combined with protocol id uniquely
    // identify the route in the table
    // Data specific to protocol family
    // Protocol independent metric
    // Any data specific to routing
    //      protocol (subject to size limitation
    //      defined by PROTOCOL_SPECIFIC_DATA
    //      structure above)
    IN DWORD                TimeToLive,   // In seconds. INFINITE if route is not to
    // be aged out. The maximum value for
    // this parameter is 2147483 sec (that
    // is 24+ days)

    OUT DWORD               *Flags,                 // If added/updated route is the best route to the
    // destination RTM_CURRENT_BEST_ROUTE will be set,
    //  AND if added/updated route changed (or
    // replaced alltogether) previous
    // best route info for the destination,
    // RTM_PREVIOUS_BEST_ROUTE will be set
    OUT PVOID           CurBestRoute OPTIONAL,// This buffer (if present) will
    // receive the route that became the best as
    // the result of this addition/update if
    // RTM_CURRENT_BEST_ROUTE is set
    OUT PVOID           PrevBestRoute OPTIONAL// This buffer (if present) will
    // receive the route that was the best before
    // this addition/update if
    // RTM_PREVIOUS_BEST_ROUTE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
#define ClientPtr ((PRTM_CLIENT)ClientHandle)
    DWORD                                   status; // Operation result
    INT                                             res;    // Comparison result
    PRTM_SYNC_LIST                  hashBasket;     // Hash basket to which added route
    // belongs
    // Links in all mantained lists for added route
    PLIST_ENTRY                             cur, hashLink=NULL, intfLink=NULL, protLink=NULL;
    // Node created for added route and best node for the
    // network
    PRTM_ROUTE_NODE                 theNode=NULL, curBestNode=NULL;
    // Flags that indicate that corresponing links are determined
    BOOL                                    intfLinkFinal=FALSE;
#if RTM_USE_PROTOCOL_LISTS
    BOOL                                    protLinkFinal=FALSE;
#endif
    BOOL                                    newRoute=FALSE, updatedRoute=FALSE;

    PRTM_TABLE                              Table;
    DWORD                                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }

    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
    GetSystemTimeAsFileTime (&ROUTE->XX_TIMESTAMP);

    status = ValidateRoute (Table, ROUTE);
    if (status!=NO_ERROR)
        return status;

                // Find and lock the hash basket for added route
    hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                         ((char *)ROUTE)
                                                         +sizeof(RTM_XX_ROUTE))];
    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        ExitTableAPI(Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // Traverse the list attached to the hash basket to
    // find proper place for added route (entries in hash
    // basket are ordered by network number and metric
    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );

        if (!IsEnumerator (node)) {

            // Check if network numbers match
            res = NetNumCmp (Table, ROUTE, &node->RN_Route);


            if (res==0) { // We found block of entries with same net number
                // We'll have to look through all of them

                // Check all parameters of the node to see if we already
                // have this route and this is just an update
                if ((hashLink==NULL) && (theNode==NULL)) {
                    if (ROUTE->XX_PROTOCOL
                        == node->RN_Route.XX_PROTOCOL) {
                        if (ClientPtr->RC_Flags&RTM_PROTOCOL_SINGLE_ROUTE)
                            theNode = node;
                        else if (ROUTE->XX_INTERFACE
                                 == node->RN_Route.XX_INTERFACE) {
                            res = NextHopCmp (Table, ROUTE, &node->RN_Route);
                            if (res == 0)
                                theNode = node;
                            else if (res < 0)
                                hashLink = cur;
                        }
                        else if (ROUTE->XX_INTERFACE
                                 < node->RN_Route.XX_INTERFACE)
                            hashLink = cur;
                    }
                    else if (ROUTE->XX_PROTOCOL
                             < node->RN_Route.XX_PROTOCOL)
                        hashLink = cur;
                }

                // Just looking for current best route
                // (not including added/updated route)
                if ((node!=theNode)
                    && IsEnabled(node)
                    && ((curBestNode==NULL)
                        || IsBest(node)
                        || (MetricCmp (Table,
                                       &curBestNode->RN_Route,
                                       &node->RN_Route)>0)))
                    curBestNode = node;


                // We have to check all entries with same net number
                // anyway (to find the best route), so we might as
                // well find links for the added route in protocol
                // and interface list if such links exist (if not, we'll
                // just insert new entry at the end of the list)

#if RTM_USE_PROTOCOL_LISTS
                // If we need and haven't found yet a proper place to
                // insert added route into the protocol list and this route
                // has the same protocol as added route we should
                // consider it.
                if (!protLinkFinal && (theNode==NULL)
                    && (ROUTE->XX_PROTOCOL
                        ==node->RN_Route.XX_PROTOCOL)) {
                    protLink = &node->RN_Links[RTM_PROTOCOL_LIST_LINK];
                    // If added route has lower interface number than
                    // this one we'll insert it in protocol list right
                    // BEFORE this one, otherwise
                    // we are not sure if this is a proper place yet (there
                    // may be other routes with same protocol that have
                    // lower interface number), but we note the position
                    // and insert added route right AFTER this one if there
                    // are no more routes of this protocol.
                    protLinkFinal = ROUTE->XX_INTERFACE
                        < node->RN_Route.XX_INTERFACE;
                }
#endif

                // Same story with the interface list
                if (!intfLinkFinal
                    && (ROUTE->XX_INTERFACE
                        ==node->RN_Route.XX_INTERFACE)) {
                    intfLink = &node->RN_Links[RTM_INTERFACE_LIST_LINK];
                    intfLinkFinal = ROUTE->XX_PROTOCOL
                        < node->RN_Route.XX_PROTOCOL;
                }
            }
            else if (res < 0) // We must have seen all entries with
                // matching network number -> nothing
                // to look for anymore
                break;

        }
        cur = cur->Flink;
    }



    if (theNode!=NULL) {
        // We found the route, so just need to update its parameters

        if (ClientPtr->RC_Flags&RTM_PROTOCOL_SINGLE_ROUTE) {
            updatedRoute = (MetricCmp (Table, &theNode->RN_Route, ROUTE)!=0)
                || (theNode->RN_Route.XX_INTERFACE!=ROUTE->XX_INTERFACE)
                || (NextHopCmp (Table, &theNode->RN_Route, ROUTE)!=0)
                || !FSDCmp (Table, &theNode->RN_Route, ROUTE);

            if (ROUTE->XX_INTERFACE!=theNode->RN_Route.XX_INTERFACE) {
                PRTM_SYNC_LIST                  intfBasketOld
                    = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                                theNode->RN_Route.XX_INTERFACE)];
                PRTM_SYNC_LIST                  intfBasketNew
                    = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                                ROUTE->XX_INTERFACE)];


                // Make sure we lock interface hash table basket
                // in the same order to prevent possible deadlock
                if (intfBasketOld<intfBasketNew) {
                    if (!EnterSyncList (Table, intfBasketOld, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                    if (!EnterSyncList (Table, intfBasketNew, TRUE)) {
                        LeaveSyncList (Table, intfBasketOld);
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                }
                else if (intfBasketOld>intfBasketNew) {
                    if (!EnterSyncList (Table, intfBasketNew, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                    if (!EnterSyncList (Table, intfBasketOld, TRUE)) {
                        LeaveSyncList (Table, intfBasketOld);
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                }
                else {
                    if (!EnterSyncList (Table, intfBasketOld, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                }


                if (intfLink==NULL) {
                    intfLink = FindInterfaceList (intfBasketNew, ROUTE->XX_INTERFACE, TRUE);
                    if (intfLink==NULL) {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        LeaveSyncList (Table, intfBasketOld);
                        if (intfBasketNew!=intfBasketOld)
                            LeaveSyncList (Table, intfBasketNew);
                        goto ExitAddRoute;
                    }
                }
                // Add it to interface list
                RemoveEntryList (&theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
                InsertTailList (intfLink,
                                &theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
                LeaveSyncList (Table, intfBasketOld);
                if (intfBasketNew!=intfBasketOld)
                    LeaveSyncList (Table, intfBasketNew);
            }
        }
        else
            updatedRoute = MetricCmp (Table, &theNode->RN_Route, ROUTE)
            || !FSDCmp (Table, &theNode->RN_Route, ROUTE)!=0;

    }

    else /*if (theNode==NULL)*/ {   //      We haven't found matching route,
        //      so we'll add a new one
        // If we were not able to find place to insert added route
        // into the list, we use the place where we stop
        // the search (it is either end of the list or
        // network with higher number if we did not see our
        // network or all other entries had lower metric
        if (hashLink==NULL)
            hashLink = cur;
        theNode = CreateRouteNode (Table,
                                   hashLink,
                                   intfLink,
                                   intfLinkFinal,
#if RTM_USE_PROTOCOL_LISTS
                                   protLink,
                                   protLinkFinal,
#endif
                                   hashBasket,
                                   ROUTE);
        if (theNode==NULL) {
            status = GetLastError ();
            goto ExitAddRoute;
        }

        if (curBestNode==NULL) {
            InterlockedIncrement (&Table->RT_NetworkCount);
            SetBest (theNode);       // This is the first
            // route to the network, and thus
            // it is the best.
            newRoute = TRUE;
        }
        else {
            newRoute = FALSE;
        }
    }


    // All routes (new or old) need to be placed into the Expiration list
    // to be properly aged out
    if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE)) {
        status = ERROR_NO_SYSTEM_RESOURCES;
        goto ExitAddRoute;
    }

    if (IsListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK])) {
        RemoveEntryList (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
    }

    if (TimeToLive!=INFINITE) {
        TimeToLive *= 1000;
        if (TimeToLive > (MAXTICKS/2-1))
            TimeToLive = MAXTICKS/2-1;
        theNode->RN_ExpirationTime = (GetTickCount () + TimeToLive)&0xFFFFFF00;
        if (AddExpirationQueueNode (Table, theNode)) {
            if (InterlockedIncrement (&Table->RT_ExpirationWorkerPending)==0) {
                // New route expiration time comes before the update thread
                // is scheduled to wakeup next time, so wake it up NOW
                status = RtlQueueWorkItem (ProcessExpirationQueueWI, Table, 
                                                          WT_EXECUTEINIOTHREAD);
                ASSERTERRMSG ("Can't queue expiration work item", status==STATUS_SUCCESS);
            }
        }
    }
    else
        // Initilaize this list link, so we know it is not
        // in the list and we do not have to remove it from
        // there
        InitializeListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
    LeaveSyncList (Table, &Table->RT_ExpirationQueue);



    if (!IsEnabled(theNode))  {// Ignore disabled nodes
        if (updatedRoute)
            // Update the route data
            memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
        else {
            memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                    &ROUTE->XX_TIMESTAMP,
                    sizeof (theNode->RN_Route.XX_TIMESTAMP));
            memcpy (&theNode->RN_Route.XX_PSD,
                    &ROUTE->XX_PSD,
                    sizeof (theNode->RN_Route.XX_PSD));
        }
        *Flags = 0;
    }
    else if (curBestNode!=NULL) { // There is at least one other route to the
        // same network as the route we're adding/updating
        if (MetricCmp (Table, ROUTE, &curBestNode->RN_Route)<0) {
            // Added/updated route metric is lower, it is the best
            if (!IsBest(theNode)) {// The best route has changed, we need to
                // update best route designation
                ResetBest (curBestNode);
                SetBest (theNode);
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);

                                                                        // include previous best route info
                                                                        // in notificaion message
                *Flags = RTM_PREVIOUS_BEST_ROUTE|RTM_CURRENT_BEST_ROUTE;
                if (ARGUMENT_PRESENT (CurBestRoute))
                    memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                if (ARGUMENT_PRESENT (PrevBestRoute))
                    memcpy (PrevBestRoute, &curBestNode->RN_Route, Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags, ROUTE,
                               &curBestNode->RN_Route);
            }
            else {
                if (updatedRoute) {
                    *Flags = RTM_PREVIOUS_BEST_ROUTE|RTM_CURRENT_BEST_ROUTE;
                    if (ARGUMENT_PRESENT (CurBestRoute))
                        memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                    if (ARGUMENT_PRESENT (PrevBestRoute))
                        memcpy (PrevBestRoute, &theNode->RN_Route, Table->RT_RouteSize);
                    NotifyClients (Table, ClientHandle, *Flags, ROUTE, &theNode->RN_Route);
                    // Update the route data
                    memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
                }
                else {
                    memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                            &ROUTE->XX_TIMESTAMP,
                            sizeof (theNode->RN_Route.XX_TIMESTAMP));
                    memcpy (&theNode->RN_Route.XX_PSD,
                            &ROUTE->XX_PSD,
                            sizeof (theNode->RN_Route.XX_PSD));
                }
            }
        }
        else if (IsBest(theNode)) {
            if (MetricCmp (Table, ROUTE, &curBestNode->RN_Route)>0) {
                // We are downgrading our best route,
                // and new best route poped up.
                // Update best route designation
                ResetBest (theNode);
                SetBest (curBestNode);
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
                // Inform clients about the change
                *Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
                if (ARGUMENT_PRESENT (PrevBestRoute))
                    memcpy (PrevBestRoute, &curBestNode->RN_Route, Table->RT_RouteSize);
                if (ARGUMENT_PRESENT (CurBestRoute))
                    memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags, &curBestNode->RN_Route,
                               ROUTE);
            }
            else if (updatedRoute) {
                *Flags = RTM_PREVIOUS_BEST_ROUTE|RTM_CURRENT_BEST_ROUTE;
                if (ARGUMENT_PRESENT (CurBestRoute))
                    memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                if (ARGUMENT_PRESENT (PrevBestRoute))
                    memcpy (PrevBestRoute, &theNode->RN_Route, Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags, ROUTE, &theNode->RN_Route);
                // Update the route data
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
            }
            else {
                memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                        &ROUTE->XX_TIMESTAMP,
                        sizeof (theNode->RN_Route.XX_TIMESTAMP));
                memcpy (&theNode->RN_Route.XX_PSD,
                        &ROUTE->XX_PSD,
                        sizeof (theNode->RN_Route.XX_PSD));
            }
        }
        else {  // Added route metric was and is higher and thus has no
            // effect on best route to the network
            *Flags = 0;
            // Update the route data
            if (updatedRoute) {
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
            }
            else {
                memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                        &ROUTE->XX_TIMESTAMP,
                        sizeof (theNode->RN_Route.XX_TIMESTAMP));
                memcpy (&theNode->RN_Route.XX_PSD,
                        &ROUTE->XX_PSD,
                        sizeof (theNode->RN_Route.XX_PSD));
            }
        }
    }
    else { // Not other node exist for this network
        if (newRoute) {
            *Flags = RTM_CURRENT_BEST_ROUTE;
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
            NotifyClients (Table, ClientHandle, *Flags, ROUTE, NULL);
        }
        else if (updatedRoute) {
            *Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (PrevBestRoute, &theNode->RN_Route, Table->RT_RouteSize);
            NotifyClients (Table, ClientHandle, *Flags, ROUTE, &theNode->RN_Route);
            // Update the route data
            memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
        }
        else {
            memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                    &ROUTE->XX_TIMESTAMP,
                    sizeof (theNode->RN_Route.XX_TIMESTAMP));
            memcpy (&theNode->RN_Route.XX_PSD,
                    &ROUTE->XX_PSD,
                    sizeof (theNode->RN_Route.XX_PSD));
            *Flags = 0;
        }
    }

    //
    // for each new route added the size of the net mask is noted.
    //
    // This is useful at route lookup time.  For now since there
    // is no efficient way to do a route lookup, it is necessary to 
    // guess the (sub)net mask associated with a destination to find
    // the best route associated with it.  By tracking the net mask
    // for each added route the number of guesses for the mask can
    // be minimized.
    //

    if ( newRoute )
    {
#if ROUTE_LOOKUP_BDG
        TRACE2( 
            ANY, "Network : %x %x", 
            ((PIP_NETWORK) NNM(ROUTE))->N_NetNumber,
            ((PIP_NETWORK) NNM(ROUTE))->N_NetMask
            );

        TRACE1(
            ANY, "Next Hop : %x",
            ((PRTM_IP_ROUTE) NNM(ROUTE))-> RR_NextHopAddress.N_NetNumber
            );
#endif            
        SetMaskCount( (PIP_NETWORK) NNM( ROUTE ), TRUE );
    }
    
    status = NO_ERROR;

ExitAddRoute:
    LeaveSyncList (Table, hashBasket);
    ExitTableAPI(Table);

#undef ClientPtr
#undef ROUTE
    return status;
}



// Deletes a given route
//
// Returns:
//              NO_ERROR                                - if route was deleted OK or
//              ERROR_NO_SUCH_ROUTE - if route to be deleted was not found in the table
DWORD WINAPI
RtmDeleteRoute (
    IN HANDLE           ClientHandle,       // Handle to coordinate
    // this operation with notifications
    // through the event (notificanitons will not
    // be sent to the caller)
    IN PVOID                Route,                  // ROUTE to delete
    OUT     DWORD           *Flags,                 // If deleted route was the best
    // route, RTM_PREVIOUS_BEST_ROUTE will be set
    // AND if there is another route for the same
    // network, RTM_CURRENT_BEST_ROUTE will be set
    OUT PVOID           CurBestRoute OPTIONAL// // This buffer will (optionally) receive
    // the best route for the same network
    // if RTM_CURRENT_BEST_ROUTE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
#define ClientPtr ((PRTM_CLIENT)ClientHandle)
    DWORD                                   status; // Operation result
    INT                                             res;    // Comparison result
    PRTM_SYNC_LIST                  hashBasket;     // Hash basket to which the route belongs
    PLIST_ENTRY                             cur;
    PRTM_ROUTE_NODE                 theNode=NULL,// Table node associated with the route
        curBestNode=NULL; // New best route for the
    // network which route is deleted
    // (if any)

    PRTM_TABLE                              Table;
    DWORD                                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;

                        // Try locate the node in hash basket
    hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                         ((char *)ROUTE)
                                                         +sizeof(RTM_XX_ROUTE))];

    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );
        if (!IsEnumerator (node)) {

            // Check if network number matches
            res = NetNumCmp (Table, ROUTE, &node->RN_Route);

            if (res==0) {
                // Go through entries for network of interest

                // Try to locate the route to be deleted
                if ((theNode==NULL)
                    && (ROUTE->XX_INTERFACE
                        == node->RN_Route.XX_INTERFACE)
                    && (ROUTE->XX_PROTOCOL
                        == node->RN_Route.XX_PROTOCOL)
                    && (NextHopCmp (Table, ROUTE, &node->RN_Route)
                        ==0)) {
                    theNode = node;
                    if (!IsBest(theNode))
                        break;
                }
                else if (IsEnabled(node)
                         && ((curBestNode==NULL)
                             || (MetricCmp (Table,
                                            &curBestNode->RN_Route,
                                            &node->RN_Route)>0)))
                    curBestNode = node;

            }
            else if (res < 0)
                // We passed the place where routes for our
                // network are located
                break;
        }
        cur = cur->Flink;
    }


    if (theNode!=NULL) {    // Yes, we found the node
        if (IsBest(theNode)) { // And it was the best,
            // inform interested clients
            if (curBestNode!=NULL) {        // There is another best node

                ResetBest (theNode);
                SetBest (curBestNode);

                *Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
                if (ARGUMENT_PRESENT(CurBestRoute))
                    memcpy (CurBestRoute, &curBestNode->RN_Route,
                            Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags,
                               &curBestNode->RN_Route,
                               &theNode->RN_Route);
            }
            else {                          // This one was the only available node
                InterlockedDecrement (&Table->RT_NetworkCount);
                *Flags = RTM_PREVIOUS_BEST_ROUTE;
                NotifyClients (Table, ClientHandle, *Flags, NULL, &theNode->RN_Route);


                //
                // Decrement mask count
                //
                
                SetMaskCount( (PIP_NETWORK) NNM( ROUTE ), FALSE );
    
            }
        }
        else    // This was not the best node, nobody cares
            *Flags = 0;

        status = RemoveRouteNode (Table, theNode);
    }
    else
        // Well, we don't have this node already (aged out ?)
        status = ERROR_NO_SUCH_ROUTE;

    LeaveSyncList (Table, hashBasket);
    ExitTableAPI (Table);
#undef ClientPtr
#undef ROUTE
    return status;
}



// Check if route exists and return it if so.
// Returns:
//                      TRUE if route exists for the given network
//                      FALSE otherwise
// If one of the parameters is invalid, the function returns FALSE
// and GetLastError() returns ERROR_INVALID_PARAMETER
BOOL WINAPI
RtmIsRoute (
    IN      DWORD           ProtocolFamily,
    IN      PVOID           Network,                        // Network whose existence is being checked
    OUT PVOID           BestRoute OPTIONAL      // Returns the best route if the network
    // is found
    ) {
    INT                                             res;
    PRTM_TABLE                              Table;
    PRTM_SYNC_LIST                  hashBasket;
    PLIST_ENTRY                             cur;
    PRTM_ROUTE_NODE                 bestNode = NULL;
    BOOL                                    result = FALSE;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }



    // Locate the network in the hash basket
    hashBasket = &Table->RT_NetNumberHash[HashFunction (Table, Network)];

    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        ExitTableAPI (Table);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return FALSE;
    }

    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE                 node;
        node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );
        if (!IsEnumerator (node)
            && IsEnabled(node)) {

            res = (*Table->RT_Config.RPFC_NNcmp) (
                Network,
                NNM(&node->RN_Route));

            if ((res == 0)
                && IsBest(node)) {
                bestNode = node;
                break;
            }
            else if (res < 0)
                break;
        }
        cur = cur->Flink;
    }



    if (bestNode!=NULL) { // We found a match
        if (ARGUMENT_PRESENT(BestRoute)) {
            memcpy (BestRoute, &bestNode->RN_Route, Table->RT_RouteSize);
        }
        LeaveSyncList (Table, hashBasket);
        result = TRUE;
    }
    else {
        // We don't have one (result is FALSE by default)
        LeaveSyncList (Table, hashBasket);
        // This is not an error condition, we just do not have it
        SetLastError (NO_ERROR);
    }

    ExitTableAPI (Table);
    return result;
}


// Gets number of networks with known routes for a specific protocol family
ULONG WINAPI
RtmGetNetworkCount (
    IN      DWORD           ProtocolFamily
    ) {
    PRTM_TABLE              Table;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (&Tables[ProtocolFamily])) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0;
    }


    ExitTableAPI (Table);
    return Table->RT_NetworkCount;
}

// Gets route age (time since it was created or updated last) in seconds
// from its time stamp.
// Rtm time stamps routes whenever they are added or updated.
// Note: that information returned by this routine is actually
// derived from TimeStamp field of the route structure, so it
// returns valid results only if route structure passed to was
// actually filled by Rtm
// If value in TimeStamp field is invalid this routing returns 0xFFFFFFFF
ULONG WINAPI
RtmGetRouteAge (
    IN PVOID        Route
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
    ULONGLONG               curTime;
    GetSystemTimeAsFileTime ((FILETIME *)&curTime);
    curTime -= *((PULONGLONG)&ROUTE->XX_TIMESTAMP);
    if (((PULARGE_INTEGER)&curTime)->HighPart<10000000)
        return (ULONG)(curTime/10000000);
    else {
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0xFFFFFFFF;
    }
#undef ROUTE
}


// Creates enumeration handle to start scan by specified criteria.
// Places a dummy node in the beginning of the table.
// Returns NULL in case of failure.  Call GetLastError () to get extended
// error information
// Error codes:
//      ERROR_INVALID_PARAMETER - specified protocol family is not supported or
//                                                      undefined enumeration flag
//      ERROR_NO_ROUTES - no routes exist with specified criteria
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client control block
HANDLE WINAPI
RtmCreateEnumerationHandle (
    IN      DWORD           ProtocolFamily,
    IN      DWORD           EnumerationFlags,       // Limitation flags
    IN      PVOID           CriteriaRoute // Criteria for limitation flags
    // The following fields shout be set
    // Protocol if interest if RTM_ONLY_THIS_PROTOCOL is set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)CriteriaRoute)
    HANDLE                          EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle) // To access fields
    // in this routine
    PRTM_TABLE                      Table;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (&Tables[ProtocolFamily])) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (EnumerationFlags &
        (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE
           |RTM_ONLY_THIS_PROTOCOL|RTM_ONLY_BEST_ROUTES
           |RTM_INCLUDE_DISABLED_ROUTES))) {
        ExitTableAPI (Table);
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // Allocate and initialize enumerator
    EnumerationHandle = GlobalAlloc (GMEM_FIXED,
                                     FIELD_OFFSET (RTM_ENUMERATOR, RE_Route)+Table->RT_RouteSize);
    if (EnumerationHandle!=NULL) {
        EnumPtr->RE_Flags = RTM_ENUMERATOR_FLAGS_INIT;
        EnumPtr->RE_EnumerationFlags = EnumerationFlags;
        if (EnumerationFlags
            & (RTM_ONLY_THIS_NETWORK
               |RTM_ONLY_THIS_INTERFACE
               |RTM_ONLY_THIS_PROTOCOL))
            memcpy (&EnumPtr->RE_Route, CriteriaRoute, Table->RT_RouteSize);
        EnumPtr->RE_Hash = NULL;
        EnumPtr->RE_Head = NULL;
        // WHICH LIST TO USE ?
        // In general we should have more interfaces than protocols,
        // so:
        //      if they only want a specific interface, we'll use
        //      the interface list even if they want a specific protocol too
        if (EnumerationFlags & RTM_ONLY_THIS_INTERFACE) {
            EnumPtr->RE_Link = RTM_INTERFACE_LIST_LINK;
            EnumPtr->RE_Lock = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                                         EnumPtr->RE_Route.XX_INTERFACE)];
            if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                EnumPtr->RE_Head = FindInterfaceList (EnumPtr->RE_Lock,
                                                      EnumPtr->RE_Route.XX_INTERFACE, FALSE);
                if (EnumPtr->RE_Head!=NULL) {
                    InsertTailList (EnumPtr->RE_Head,
                                    &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                }
                LeaveSyncList (Table, EnumPtr->RE_Lock);
            }
        }
#if RTM_USE_PROTOCOL_LISTS
        else if (EnumerationFlags & RTM_ONLY_THIS_PROTOCOL) {
            //      if they only want a specific protocol, we'll use
            //      the protocol list
            EnumPtr->RE_Link = RTM_PROTOCOL_LIST_LINK;
            EnumPtr->RE_Lock = &Table->RT_ProtocolList;
            if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                EnumPtr->RE_Head = FindProtocolList (Table,
                                                     EnumPtr->RE_Route.XX_PROTOCOL, FALSE);
                if (EnumPtr->RE_Head!=NULL) {
                    InsertTailList (EnumPtr->RE_Head,
                                    &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                }
                LeaveSyncList (Table, EnumPtr->RE_Lock);
            }
        }
#endif
        else {
            //      otherwise, we have to use hash table
            EnumPtr->RE_Link = RTM_NET_NUMBER_HASH_LINK;
            //      Now, if they want a specific network,
            //      we'll only search in one hash basket
            if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                EnumPtr->RE_Lock = &Table->RT_NetNumberHash[HashFunction (
                    Table,
                    ((char *)ROUTE)
                    +sizeof(RTM_XX_ROUTE))];
                if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                    if (!IsListEmpty (&EnumPtr->RE_Lock->RSL_Head)) {
                        EnumPtr->RE_Head = &EnumPtr->RE_Lock->RSL_Head;
                        InsertTailList (EnumPtr->RE_Head,
                                        &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                    }
                    LeaveSyncList (Table, EnumPtr->RE_Lock);
                }
            }
            else {
                //      Otherwise, we'll have to go through all of them
                //      starting with the first one
                EnumPtr->RE_Lock = &Table->RT_NetNumberHash[0];
                if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                    EnumPtr->RE_Head = &EnumPtr->RE_Lock->RSL_Head;
                    InsertTailList (EnumPtr->RE_Head,
                                    &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                    LeaveSyncList (Table, EnumPtr->RE_Lock);
                }
            }
        }

        if (EnumPtr->RE_Head!=NULL)
            EnumPtr->RE_ProtocolFamily = ProtocolFamily | RTM_CLIENT_HANDLE_TAG;
        else {
            GlobalFree (EnumerationHandle);
            EnumerationHandle = NULL;
            SetLastError (ERROR_NO_ROUTES);
        }
    }

    ExitTableAPI (Table);
    return EnumerationHandle;
#undef EnumPtr
}


// Returns first route that satisfies criteria of the enumeration handle
// and advances handle's dummy node past the returned route.
// Routes are not returned in any particular order.
// Returns
//              NO_ERROR                        - if next route was found in the table acording
//                                                              to specified criteria
//              ERROR_NO_MORE_ROUTES - when end of the table is reached,
//              ERROR_NO_SYSTEM_RESOURCES       - not enough resources to lock table content
DWORD WINAPI
RtmEnumerateGetNextRoute (
    IN  HANDLE      EnumerationHandle,      // Handle returned by prev call
    OUT PVOID               Route                           // Next route found
    ) {
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle) // To access fields
    // in this routine
    DWORD                           status;
    PRTM_TABLE                      Table;
    DWORD                           ProtocolFamily;

    try {
        ProtocolFamily = EnumPtr->RE_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }
    status = DoEnumerate (Table, EnumPtr,
                          (EnumPtr->RE_EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                          ? RTM_ANY_ENABLE_STATE
                          : RTM_ENABLED_NODE_FLAG);
    if (status==NO_ERROR) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );


        // Copy found route to the client's buffer
        memcpy (Route, &node->RN_Route, Table->RT_RouteSize);
        if (EnumPtr->RE_EnumerationFlags&RTM_ONLY_BEST_ROUTES) {
            // Move past all entries of given network
            // so we don't return more than one best route
            // for same network in case best route gets reassigned
            // while client is processing results of this call
            // (because we enumerate in the direction opposite
            // to the direction of insertion, new node can't
            // be inserted before the enumerator)
            PLIST_ENTRY     cur     = EnumPtr->RE_Links[EnumPtr->RE_Link].Blink;
            while (cur!=EnumPtr->RE_Head) {
                node = CONTAINING_RECORD (cur, RTM_ROUTE_NODE,
                                          RN_Links[EnumPtr->RE_Link]);

                if (!IsEnumerator (node)
                    && (NetNumCmp (Table, Route, &node->RN_Route)!=0))
                    break;
                cur = cur->Blink;
            }
            RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
            InsertHeadList (cur, &EnumPtr->RE_Links[EnumPtr->RE_Link]);
        }

    }
    else if (status==ERROR_NO_MORE_ROUTES) {
        // We are at the end of the list, nothing to return
        ;
    }
    else {
        // There was an error (DoEnumerate cleaned up everything itself)
        ExitTableAPI (Table);
        return status;
    }

    if (EnumPtr->RE_Hash!=NULL) {
        LeaveSyncList (Table, EnumPtr->RE_Hash);
        EnumPtr->RE_Hash = NULL;
    }

    LeaveSyncList (Table, EnumPtr->RE_Lock);
    ExitTableAPI (Table);
    return status;
#undef EnumPtr
}

// Frees resources allocated for enumeration handle
// Returned error codes:
//      NO_ERROR - handle was disposed of ok
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmCloseEnumerationHandle (
    IN HANDLE               EnumerationHandle
    ) {
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle) // To access fields
    // in this routine
    PLIST_ENTRY             head;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;

    try {
        ProtocolFamily = EnumPtr->RE_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    // Just pull out the enumeration node and dispose of it
    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    head = EnumPtr->RE_Links[EnumPtr->RE_Link].Flink;
    RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
    if (IsListEmpty (head)) {
        if (EnumPtr->RE_Link==RTM_INTERFACE_LIST_LINK) {
            PRTM_INTERFACE_NODE     intfNode = CONTAINING_RECORD (head,
                                                                  RTM_INTERFACE_NODE,
                                                                  IN_Head);
            RemoveEntryList (&intfNode->IN_Link);
            GlobalFree (intfNode);
        }
#if RTM_USE_PROTOCOL_LISTS
        else if (EnumPtr->RE_Link==RTM_PROTOCOL_LIST_LINK) {
            PRTM_PROTOCOL_NODE      protNode = CONTAINING_RECORD (head,
                                                                  RTM_PROTOCOL_NODE,
                                                                  PN_Head);
            RemoveEntryList (&protNode->PN_Link);
            GlobalFree (protNode);
        }
#endif
    }
    EnumPtr->RE_ProtocolFamily ^= RTM_CLIENT_HANDLE_TAG;
    LeaveSyncList (Table, EnumPtr->RE_Lock);
    GlobalFree (EnumerationHandle);
    ExitTableAPI (Table);
    return NO_ERROR;
#undef EnumPtr
}

// Delete all routes as specified by enumeraion flags (same meaning as in
// enumeration calls above, but RTM_ONLY_THIS_PROTOCOL is always set and protocol
// family and protocol values are taken from Client Handle).
// Returned error codes:
//      NO_ERROR - handle was disposed of ok
//      ERROR_INVALID_PARAMETER - undefined or unsupported enumeration flag
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory no perform the operation
DWORD WINAPI
RtmBlockDeleteRoutes (
    IN HANDLE               ClientHandle,           // Protocol family and protocol to
    // which this operation applies
    IN DWORD                EnumerationFlags,       // limitation flags
    IN PVOID                CriteriaRoute // Criteria for limitation flags
    // The following fields shout be set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)CriteriaRoute)
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    HANDLE                  EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle)
    DWORD                   status;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }

    if (EnumerationFlags & (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
    EnumerationFlags |= RTM_ONLY_THIS_PROTOCOL;
    EnumerationHandle = RtmCreateEnumerationHandle (
        ProtocolFamily,
        EnumerationFlags,
        CriteriaRoute);
    if (EnumerationHandle==NULL) {
        ExitTableAPI (Table);
        return GetLastError ();
    }

    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        RtmCloseEnumerationHandle (EnumerationHandle);
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    while ((status=DoEnumerate (Table, EnumPtr, RTM_ANY_ENABLE_STATE))==NO_ERROR) {
        PRTM_ROUTE_NODE theNode = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );
        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
            LeaveSyncList (Table, EnumPtr->RE_Lock);

        if (IsBest(theNode)) {
            // We'll look back and forward to check all nodes
            // around us with same net number trying to find another best
            // node
            DWORD   Flags;
            PRTM_ROUTE_NODE curBestNode=NULL;
            PLIST_ENTRY cur = theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur!=&theNode->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &theNode->RN_Route,
                                   &node1->RN_Route)==0) {
                        if ((curBestNode==NULL)
                            || (MetricCmp (Table,
                                           &curBestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            // Looking for the node with lowest
                            // metric that can replace disabled
                            // node
                            curBestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Blink;
            }

            cur = theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
            while (cur!=&theNode->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &theNode->RN_Route,
                                   &node1->RN_Route)==0) {
                        if ((curBestNode==NULL)
                            || (MetricCmp (Table,
                                           &curBestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            curBestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Flink;
            }

            if (curBestNode!=NULL) {        // There is another best node

                ResetBest (theNode);
                SetBest (curBestNode);

                Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
                NotifyClients (Table, ClientHandle, Flags,
                               &curBestNode->RN_Route,
                               &theNode->RN_Route);
            }
            else {                          // This one was the only available node
                InterlockedDecrement (&Table->RT_NetworkCount);
                Flags = RTM_PREVIOUS_BEST_ROUTE;
                NotifyClients (Table, ClientHandle, Flags, NULL, &theNode->RN_Route);
            }
        }

        status = RemoveRouteNode (Table, theNode);
        if (status!=NO_ERROR)
            break;

        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK) {
            if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                status = ERROR_NO_SYSTEM_RESOURCES;
                if (EnumPtr->RE_Hash!=NULL)
                    LeaveSyncList (Table, EnumPtr->RE_Hash);
                break;
            }
        }
    }

    if (status==ERROR_NO_MORE_ROUTES) {
        if (EnumPtr->RE_Hash!=NULL)
            LeaveSyncList (Table, EnumPtr->RE_Hash);
        LeaveSyncList (Table, EnumPtr->RE_Lock);

        status = NO_ERROR;
    }

    RtmCloseEnumerationHandle (EnumerationHandle);
    ExitTableAPI (Table);
    return status;
#undef EnumPtr
#undef ClientPtr
#undef ROUTE
}

// Converts all routes as specified by enumeration flags to routes of
// static protocol (as defined by ClientHandle)
// Returned error codes:
//      NO_ERROR - routes were converted ok
//      ERROR_INVALID_PARAMETER - undefined or unsupported enumeration flag
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory no perform the operation
DWORD WINAPI
RtmBlockConvertRoutesToStatic (
    IN HANDLE               ClientHandle,           // Handle of client that registered
    // to handle static protocol for
    // specified protocol family
    IN DWORD                EnumerationFlags,       // limitation flags
    IN PVOID                CriteriaRoute // Criteria for limitation flags
    // The following fields shout be set
    // Protocol of interest if RTM_ONLY_THIS_PROTOCOL is set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    ) {
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    HANDLE                  EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle)
    DWORD                   status;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }



    EnumerationHandle = RtmCreateEnumerationHandle (
        ProtocolFamily,
        EnumerationFlags,
        CriteriaRoute);
    if (EnumerationHandle==NULL) {
        ExitTableAPI(Table);
        return GetLastError ();
    }

    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        RtmCloseEnumerationHandle (EnumerationHandle);
        ExitTableAPI(Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    while ((status=DoEnumerate (Table, EnumPtr, RTM_ENABLED_NODE_FLAG))==NO_ERROR) {
        PRTM_ROUTE_NODE theNode;
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );
        if (ClientPtr->RC_RoutingProtocol==node->RN_Route.XX_PROTOCOL)
            continue;

        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
            LeaveSyncList (Table, EnumPtr->RE_Lock);

        if (ClientPtr->RC_RoutingProtocol>node->RN_Route.XX_PROTOCOL) {
            PLIST_ENTRY cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
            while (cur!=&node->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]
                    );
                if (!IsEnumerator (node1)) {
                    INT res = NetNumCmp (Table, &node->RN_Route, &node1->RN_Route);
                    if (res==0) {
                        if (ClientPtr->RC_RoutingProtocol
                            == node1->RN_Route.XX_PROTOCOL) {
                            if (node->RN_Route.XX_INTERFACE
                                == node1->RN_Route.XX_INTERFACE) {
                                res = NextHopCmp (Table, &node->RN_Route, &node1->RN_Route);
                                ASSERTMSG ("RtmBlockConvertRoutesToStatic:"
                                           " Already have same static route ",
                                           res != 0);
                                if (res <= 0)
                                    break;
                            }
                            else if (node->RN_Route.XX_INTERFACE
                                     < node1->RN_Route.XX_INTERFACE)
                                break;
                        }
                        else if (ClientPtr->RC_RoutingProtocol
                                 < node1->RN_Route.XX_PROTOCOL)
                            break;
                    }
                    else if (res<0)
                        break;
                }
                cur = cur->Flink;
            }
            theNode = CreateRouteNode (Table,
                                       cur,
                                       &node->RN_Links[RTM_INTERFACE_LIST_LINK],
                                       FALSE,
                                       node->RN_Hash,
                                       &node->RN_Route);
        }
        else {
            PLIST_ENTRY cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur!=&node->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]
                    );
                if (!IsEnumerator (node1)) {
                    INT res = NetNumCmp (Table, &node->RN_Route, &node1->RN_Route);
                    if (res==0) {
                        if (ClientPtr->RC_RoutingProtocol
                            == node1->RN_Route.XX_PROTOCOL) {
                            if (node->RN_Route.XX_INTERFACE
                                == node1->RN_Route.XX_INTERFACE) {
                                res = NextHopCmp (Table, &node->RN_Route, &node1->RN_Route);
                                ASSERTMSG ("RtmBlockConvertRoutesToStatic:"
                                           " Already have same static route ",
                                           res != 0);
                                if (res >= 0)
                                    break;
                            }
                            else if (node->RN_Route.XX_INTERFACE
                                     > node1->RN_Route.XX_INTERFACE)
                                break;
                        }
                        else if (ClientPtr->RC_RoutingProtocol
                                 > node1->RN_Route.XX_PROTOCOL)
                            break;
                    }
                    else if (res>0)
                        break;
                }
                cur = cur->Blink;
            }
            theNode = CreateRouteNode (Table,
                                       cur->Flink,
                                       &node->RN_Links[RTM_INTERFACE_LIST_LINK],
                                       TRUE,
                                       node->RN_Hash,
                                       &node->RN_Route);
        }

        if (theNode==NULL) {
            status = GetLastError ();
            if (EnumPtr->RE_Hash!=NULL)
                LeaveSyncList (Table, EnumPtr->RE_Hash);
            break;
        }

        theNode->RN_Route.XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
        theNode->RN_Flags = node->RN_Flags;
        status = RemoveRouteNode (Table, node);
        if (status!=NO_ERROR)
            break;

        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK) {
            if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                status = ERROR_NO_SYSTEM_RESOURCES;
                if (EnumPtr->RE_Hash!=NULL)
                    LeaveSyncList (Table, EnumPtr->RE_Hash);
                break;
            }
        }
    }

    if (status==ERROR_NO_MORE_ROUTES) {
        if (EnumPtr->RE_Hash!=NULL)
            LeaveSyncList (Table, EnumPtr->RE_Hash);
        LeaveSyncList (Table, EnumPtr->RE_Lock);

        status = NO_ERROR;
    }

    RtmCloseEnumerationHandle (EnumerationHandle);
    ExitTableAPI (Table);
    return status;
#undef EnumPtr
#undef ClientPtr
}

// Disables/reenables all routes as specified by enumeraion flags
// (same meaning as in enumeration calls above, but RTM_ONLY_THIS_PROTOCOL
// is always set and protocol family and protocol values are taken from
// Client Handle).

// Disables/reenables all routes as specified by enumeraion flags
// (same meaning as in enumeration calls above, but RTM_ONLY_THIS_PROTOCOL
// is always set and protocol family and protocol values are taken from
// Client Handle). Currently the only flag supported is RTN_ONLY_THIS_INTERFACE

// Disabled routes are invisible, but still maintained by the RTM.
// E.g.:        enumeration methods won't notice them;
//                      if disabled route was the best, other route will take its
//                              place (if there is one) and all clients will be
//                              notified of best route change;
//      however: disabled route can still be deleted or updated using
//                              RtmDeleteRoute or RtmAddRoute correspondingly;
//                      they can also be aged out by the RTM itself.
// Returned error codes:
//      NO_ERROR - routes were converted ok
//      ERROR_INVALID_PARAMETER - undefined or unsupported enumeration flag
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory no perform the operation
DWORD WINAPI
RtmBlockSetRouteEnable (
    IN HANDLE               ClientHandle,           // Protocol family and protocol to
    // which this operation applies
    IN DWORD                EnumerationFlags,       // limitation flags
    IN PVOID                CriteriaRoute, // Criteria for limitation flags
    // The following fields shout be set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    IN BOOL                 Enable                          // FALSE to disable routes, TRUE to
    // reenable them
    ) {
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
#define ROUTE ((PRTM_XX_ROUTE)CriteriaRoute)
    HANDLE                  EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle)
    DWORD                   status;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;
    DWORD                   EnableFlag;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    if (EnumerationFlags & (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
    EnableFlag = Enable ? 0 : RTM_ENABLED_NODE_FLAG;
    EnumerationHandle = RtmCreateEnumerationHandle (
        ProtocolFamily,
        EnumerationFlags|RTM_ONLY_THIS_PROTOCOL,
        CriteriaRoute);
    if (EnumerationHandle==NULL) {
        ExitTableAPI (Table);
        return GetLastError ();
    }

    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        RtmCloseEnumerationHandle (EnumerationHandle);
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    while ((status=DoEnumerate (Table, EnumPtr, EnableFlag))==NO_ERROR) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );

        // Update node status
        SetEnable (node, Enable);
        // If we enable this node, we'll have to check if it is the
        // best one, if we disable this node and it was the best we'll
        // try to locate another route.  In both cases we'll have to
        // locate and check all nodes to the destination
        if (Enable || IsBest(node)) {
            PRTM_ROUTE_NODE         bestNode=NULL;
            PLIST_ENTRY                     cur1;


            // We'll look back and forward to check all nodes
            // around us with same net number
            cur1 = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur1!=&node->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur1,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &node->RN_Route,
                                   &node1->RN_Route)==0) {
                        if (Enable && IsBest(node1)) {
                            // Looking for current best node
                            // that we might have to replace
                            bestNode = node1;
                            break;
                        }
                        else if (!Enable
                                 && ((bestNode==NULL)
                                     || (MetricCmp (Table,
                                                    &bestNode->RN_Route,
                                                    &node1->RN_Route)>0)))
                            // Looking for the node with lowest
                            // metric that can replace disabled
                            // node
                            bestNode = node1;
                    }
                    else
                        break;
                }
                cur1 = cur1->Blink;
            }

            // If disabling, we need to check all nodes to find
            // the best one
            // if enabling we continue only if we haven't
            // located the best node yet
            if (!Enable || (bestNode==NULL)) {
                cur1 = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
                while (cur1!=&node->RN_Hash->RSL_Head) {
                    PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                        cur1,
                        RTM_ROUTE_NODE,
                        RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                    if (!IsEnumerator (node1)
                        && IsEnabled(node1)) {
                        // Looking for current best node
                        // that we might have to replace
                        if (NetNumCmp (Table, &node->RN_Route,
                                       &node1->RN_Route)==0) {
                            if (Enable && IsBest(node1)) {
                                bestNode = node1;
                                break;
                            }
                            else if (!Enable
                                     && ((bestNode==NULL)
                                         || (MetricCmp (Table,
                                                        &bestNode->RN_Route,
                                                        &node1->RN_Route)>0)))
                                // Looking for the node with lowest
                                // metric that can replace disabled
                                // node
                                bestNode = node1;
                        }
                        else
                            break;
                    }
                    cur1 = cur1->Flink;
                }
            }

            if (!Enable // Disabling: we already know that we're removing
                // the best node (see above), so we'll have
                // to notify clients whether or not we found the
                // replacement
                // Enabling: we'll have to notify only if there
                // is no best route yet or if the route we're
                // enabling is better then current best route
                || (bestNode==NULL)
                || (MetricCmp (Table,
                               &node->RN_Route,
                               &bestNode->RN_Route)<0)) {

                if (bestNode!=NULL) {
                    // There is another route that loses or gains
                    // best status as the result of our operation
                    if (Enable) {
                        ResetBest (bestNode);
                        SetBest (node);
                        // Enabling: node replaces bestNode
                        NotifyClients (Table,
                                       NULL,
                                       RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE,
                                       &node->RN_Route,
                                       &bestNode->RN_Route);
                    }
                    else {
                        ResetBest (node);
                        SetBest (bestNode);
                        // Disabling: bestNode replaces node
                        NotifyClients (Table,
                                       NULL,
                                       RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE,
                                       &bestNode->RN_Route,
                                       &node->RN_Route);
                    }
                }
                else /* if (bestNode==NULL) */ {
                    // No other node
                    if (Enable) {
                        SetBest (node);
                        // Enabling: our node becomes the best
                        NotifyClients (Table,
                                       NULL,
                                       RTM_CURRENT_BEST_ROUTE,
                                       &node->RN_Route,
                                       NULL);
                    }
                    else {
                        ResetBest (node);
                        // Disabling: we removed the only available
                        // route
                        NotifyClients (Table,
                                       NULL,
                                       RTM_PREVIOUS_BEST_ROUTE,
                                       NULL,
                                       &node->RN_Route);
                    }
                }

            }
        }
    }

    if (status==ERROR_NO_MORE_ROUTES) {
        if (EnumPtr->RE_Hash!=NULL)
            LeaveSyncList (Table, EnumPtr->RE_Hash);
        LeaveSyncList (Table, EnumPtr->RE_Lock);

        status = NO_ERROR;
    }

    RtmCloseEnumerationHandle (EnumerationHandle);
    ExitTableAPI (Table);
    return status;

#undef EnumPtr
#undef ClientPtr
#undef ROUTE
    return NO_ERROR;
}




// Slow enumeration that may require traversing up to all the entries in the
// table if route used to compute the next entry no longer exists.
// Routes are returned in the increasing net number order

// Get first route that matches specified criteria
// Returns:
//              NO_ERROR - if matching route is found
//              ERROR_NO_ROUTES  - if no routes available with specified criteria
//              ERROR_INVALID_PARAMETER - if one of the parameters is invalid
//              ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmGetFirstRoute (
    IN      DWORD           ProtocolFamily,
    IN      DWORD           EnumerationFlags,// Limiting flags
    IN OUT PVOID Route      // On Entry: if any of the EnumerationFlags are set,
    //                       the corresponding fields of Route will
    //           be used to limit the search
    //                       to the only table entries that have
    //                       same value in the specified field.
    // On Exit:     contains first route in the table that
    //                      matches specified criteria
    ){
#define ROUTE ((PRTM_XX_ROUTE)Route)
    PRTM_TABLE                      Table;
    PLIST_ENTRY                     cur, head;
    INT                                     res, link;
    PRTM_SYNC_LIST          hashBasket;
    DWORD                           status = ERROR_NO_ROUTES;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }


    if (EnumerationFlags &
        (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE
           |RTM_ONLY_THIS_PROTOCOL|RTM_ONLY_BEST_ROUTES
           |RTM_INCLUDE_DISABLED_ROUTES))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
        hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                             ((char *)ROUTE)
                                                             +sizeof(RTM_XX_ROUTE))];
        link = RTM_NET_NUMBER_HASH_LINK;
        if (!EnterSyncList (Table, hashBasket, TRUE)) {
            ExitTableAPI (Table);
            return ERROR_NO_SYSTEM_RESOURCES;
        }
        head = &hashBasket->RSL_Head;
    }
    else {
        hashBasket = NULL;
        link = RTM_NET_NUMBER_LIST_LINK;
        head = &Table->RT_NetNumberMasterList.RSL_Head;


        if (EnterSyncList (Table, &Table->RT_NetNumberMasterList, FALSE))
            ConsolidateNetNumberLists (Table);
        else if (!EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE)) {
            ExitTableAPI (Table);
            return ERROR_NO_SYSTEM_RESOURCES;
        }
    }
    // Go through the list till entry that matches specified
    // criteria is found
    cur = head->Flink;
    while (cur!=head) {
        PRTM_ROUTE_NODE         node = CONTAINING_RECORD (cur,
                                                          RTM_ROUTE_NODE,
                                                          RN_Links[link]);
        if (!IsEnumerator (node)
            && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                || IsEnabled(node))) {
            if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                // Check network number if asked
                res = NetNumCmp (Table, ROUTE, &node->RN_Route);
                if (res > 0)    // It may be further ahead
                    goto DoNextNode;
                else if (res < 0)       // No chance to find it anymore
                    break;
            }

            // Check if it is the best route if asked
            if (EnumerationFlags & RTM_ONLY_BEST_ROUTES) {
                // We need to lock the hash list to make sure the
                // best node designation won't change while we are
                // scaning through the list
                if (hashBasket!=node->RN_Hash) {
                    if (hashBasket!=NULL)
                        LeaveSyncList (Table, hashBasket);
                    hashBasket = node->RN_Hash;
                    if (!EnterSyncList (Table, hashBasket, TRUE)) {
                        hashBasket = NULL;
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitGetFirst;
                    }
                }

                if (!IsBest(node))
                    goto DoNextNode;
            }

            // Check protocol if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_PROTOCOL)
                && (ROUTE->XX_PROTOCOL
                    !=node->RN_Route.XX_PROTOCOL))
                goto DoNextNode;

            // Check interface if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_INTERFACE)
                && (ROUTE->XX_INTERFACE
                    !=node->RN_Route.XX_INTERFACE))
                goto DoNextNode;

            // Now we have it
            memcpy (ROUTE, &node->RN_Route, Table->RT_RouteSize);

            status = NO_ERROR;
            break;
        }

DoNextNode:     // Continue searching
        cur = cur->Flink;
    }

ExitGetFirst:
    if (link==RTM_NET_NUMBER_HASH_LINK)
        LeaveSyncList (Table, hashBasket);
    else {
        if (hashBasket!=NULL)
            LeaveSyncList (Table, hashBasket);
        LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
    }
    ExitTableAPI (Table);
#undef ROUTE
    return status;
}

// Compute and return route next to the input route limiting serach to the routes
// with specified criteria
// Returns:
//              NO_ERROR - if matching route is found
//              ERROR_NO_MORE_ROUTES  - if no matching route was found while end of
//                                                               the table is reached and no route
//              ERROR_INVALID_PARAMETER - if one of the parameters is invalid
//              ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmGetNextRoute (
    IN      DWORD           ProtocolFamily,
    IN      DWORD           EnumerationFlags,// Limiting flags
    IN OUT PVOID Route      // On Entry: contains the route from which to start
    //                       the search.
    //                       if any of the EnumerationFlags are set,
    //                       the corresponding fields of Route will
    //           be used to limit the search
    //                       to the only table entries that have
    //                       same value in the specified field.
    // On Exit:     contains first route in the table that
    //                      matches specified criteria
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
    PRTM_TABLE                      Table;
    PLIST_ENTRY                     cur, posLink = NULL;
    INT                                     res;
    PRTM_SYNC_LIST          hashBasket = NULL;
    DWORD                           status = ERROR_NO_MORE_ROUTES;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }


    if (EnumerationFlags &
        (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE
           |RTM_ONLY_THIS_PROTOCOL|RTM_ONLY_BEST_ROUTES
           |RTM_INCLUDE_DISABLED_ROUTES))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    if (EnterSyncList (Table, &Table->RT_NetNumberMasterList, FALSE))
        ConsolidateNetNumberLists (Table);
    else if (!EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }


    // First try to locate starting point for the serach
    // using the hash table (should work most of the
    // time unless route was deleted while client was
    // processing it)
    hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                         ((char *)ROUTE)
                                                         +sizeof(RTM_XX_ROUTE))];


    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        status = ERROR_NO_SYSTEM_RESOURCES;
        goto ExitGetNext;
    }


    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );
        if (!IsEnumerator (node)
            && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                || IsEnabled(node))) {
            // First check network number
            // (lists are ordered by net number)
            res = NetNumCmp (Table, ROUTE, &node->RN_Route);
            if (res==0) {
                if (ROUTE->XX_PROTOCOL
                    == node->RN_Route.XX_PROTOCOL) {
                    if (ROUTE->XX_INTERFACE
                        == node->RN_Route.XX_INTERFACE) {
                        res = NextHopCmp (Table, ROUTE, &node->RN_Route);
                        if ((res == 0)
                            && IsSorted (node))
                            posLink = node->RN_Links[RTM_NET_NUMBER_LIST_LINK].Flink;
                        else if (res < 0)
                            break;
                    }
                    else if (ROUTE->XX_INTERFACE
                             < node->RN_Route.XX_INTERFACE)
                        break;
                }
                else if (ROUTE->XX_PROTOCOL
                         < node->RN_Route.XX_PROTOCOL)
                    break;
            }
            else if (res < 0)
                break;
        }
        cur = cur->Flink;
    }

    LeaveSyncList (Table, hashBasket);

    hashBasket = NULL;

    if (posLink!=NULL)
        cur = posLink; // Note the place to start with
    else { // If we didn't find the entry in
        // hash table, we'll have to go through
        // the master net number list from the
        // beginning
        cur = Table->RT_NetNumberMasterList.RSL_Head.Flink;
        while (cur!=&Table->RT_NetNumberMasterList.RSL_Head) {
            PRTM_ROUTE_NODE node = CONTAINING_RECORD (
                cur,
                RTM_ROUTE_NODE,
                RN_Links[RTM_NET_NUMBER_LIST_LINK]
                );
            if (!IsEnumerator (node)
                && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                    || IsEnabled(node))) {
                // Just do all the necessary comparisons to
                // find the following entry
                res = NetNumCmp (Table, ROUTE, &node->RN_Route);
                if ((res < 0)
                    ||((res == 0)
                       &&((ROUTE->XX_PROTOCOL
                           < node->RN_Route.XX_PROTOCOL)
                          ||((ROUTE->XX_PROTOCOL
                              ==node->RN_Route.XX_PROTOCOL)
                             &&((ROUTE->XX_INTERFACE
                                 < node->RN_Route.XX_INTERFACE)
                                ||((ROUTE->XX_INTERFACE
                                    ==node->RN_Route.XX_INTERFACE)
                                   && (NextHopCmp (Table, ROUTE,
                                                   &node->RN_Route)
                                       < 0)))))))
                    break;
            }

            cur = cur->Flink;
        }
    }

    // Now we need to locate first entry that satisfies all criteria
    while (cur!=&Table->RT_NetNumberMasterList.RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_LIST_LINK]
            );
        if (!IsEnumerator (node)
            && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                || IsEnabled(node))) {

            if (EnumerationFlags & RTM_ONLY_BEST_ROUTES) {
                // We need to lock the hash list to make sure the
                // best node designation won't change while we are
                // scaning through the list
                if (hashBasket!=node->RN_Hash) {
                    if (hashBasket!=NULL)
                        LeaveSyncList (Table, hashBasket);
                    hashBasket = node->RN_Hash;
                    if (!EnterSyncList (Table, hashBasket, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitGetNext;
                    }
                }

                // For best routes we must check if the route is best
                // and also make sure we do not return same net as in
                // previous call in case the best route was moved
                // while client was processing results of the
                // previous call
                if (!IsBest(node)
                    || (NetNumCmp (Table, ROUTE, &node->RN_Route)==0))
                    goto DoNextNode;
            }

            if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                // checking net number
                res = NetNumCmp (Table, ROUTE, &node->RN_Route);
                if (res > 0) // It is still ahead
                    goto DoNextNode;
                else if (res < 0) // no chance to find it
                    break;
                // else (res == 0), found it, continue
            }

            // Check interface if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_INTERFACE)
                && (node->RN_Route.XX_INTERFACE
                    !=ROUTE->XX_INTERFACE))
                goto DoNextNode;

            // Check protocol if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_PROTOCOL)
                && (node->RN_Route.XX_PROTOCOL
                    !=ROUTE->XX_PROTOCOL))
                goto DoNextNode;


            // Now we can return it
            // Make sure nobody changes the route while we copy
            memcpy (ROUTE, &node->RN_Route, Table->RT_RouteSize);

            status = NO_ERROR;
            break;
        }

DoNextNode:
        cur = cur->Flink;
    }

    if (hashBasket!=NULL)
        LeaveSyncList (Table, hashBasket);

ExitGetNext:
    LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
    ExitTableAPI (Table);
#undef ROUTE
    return status;
}


//----------------------------------------------------------------------------
// RtmLookupIPDestination
//
//  Given a destination address does a route lookup to get the best route
//  to that destination.
//----------------------------------------------------------------------------

BOOL WINAPI
RtmLookupIPDestination(
    DWORD                       dwDestAddr,
    PRTM_IP_ROUTE               prir
)
{
    INT         nInd;
    IP_NETWORK  ipNet;

    for ( nInd = MAX_MASKS; nInd >= 0; nInd-- )
    {
        if ( g_meMaskTable[ nInd ].dwCount == 0 )
        {
            continue;
        }

        
        ipNet.N_NetNumber   = dwDestAddr & g_meMaskTable[ nInd ].dwMask;
        ipNet.N_NetMask     = g_meMaskTable[ nInd ].dwMask;

        if ( RtmIsRoute( RTM_PROTOCOL_FAMILY_IP, &ipNet, prir ) )
        {
            if ( IsRouteLoopback( prir ) )
            {
                continue;
            }
            
            return TRUE;
        }
    }

    return FALSE;
}


//----------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------

VOID
UpdateAPC (
    PVOID           Context,
    ULONG           TimeLow,
    LONG            TimeHigh
    ) {
#define Table ((PRTM_TABLE)Context)
    if (InterlockedIncrement (&Table->RT_UpdateWorkerPending)==0) {
        DWORD status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Context, 0);
        if (status!=STATUS_SUCCESS) {
            ASSERTERRMSG ("Can't queue update work item", FALSE);
            ScheduleUpdate (Context);
        }
    }
#undef Table
}

VOID APIENTRY
ScheduleUpdate (
    PVOID           Context
    ) {
#define Table ((PRTM_TABLE)Context)
    DWORD                                   status;
    static LARGE_INTEGER    dueTime = RTM_NET_NUMBER_UPDATE_PERIOD;

    if (InterlockedDecrement (&Table->RT_UpdateWorkerPending)>=0) {
        status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Context, 0);
        if (status==STATUS_SUCCESS)
            return;
        ASSERTERRMSG ("Can't queue update work item", FALSE);
        InterlockedExchange (&Table->RT_UpdateWorkerPending, -1);
    }

    status = NtSetTimer (Table->RT_UpdateTimer,
                         &dueTime,
                         UpdateAPC,
                         Context,
                         FALSE,
                         0,
                         NULL);
    ASSERTMSG ("Could not set expiration timer ", NT_SUCCESS (status));
#undef Table
}

VOID
ConsolidateNetNumberListsWI (
    PVOID                   Context
    ) {
#define Table ((PRTM_TABLE)Context)
    DWORD                   status;

    if (EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE)) {
        InterlockedExchange (&Table->RT_UpdateWorkerPending, 0);
        ConsolidateNetNumberLists (Table);
        LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
    }

    status = RtlQueueWorkItem (ScheduleUpdate, Context, WT_EXECUTEINIOTHREAD);
    ASSERTERRMSG ("Can't queue update work item", status==STATUS_SUCCESS);
#undef Table
}

// This procedure merges temporary and master net number lists
// It also removes and disposes of nodes in the deleted list
VOID
ConsolidateNetNumberLists (
    PRTM_TABLE                      Table   // Table for which operation is performed
    ) {
    PLIST_ENTRY                     curMaster, curTemp;
    LIST_ENTRY                      tempHead;
    PRTM_ROUTE_NODE         tempNode;
    INT                                     res;
    DWORD                           status;
#if DBG
    INT                                     curMasterIdx = 0;
#endif

    // Temp and deleted lists are locked for a very short period
    // of time so that overall performance should not
    // degrade

    if (!EnterSyncList (Table, &Table->RT_NetNumberTempList, TRUE)) {
        return;
    }

    if (!EnterSyncList (Table, &Table->RT_DeletedList, TRUE)) {
        LeaveSyncList (Table, &Table->RT_NetNumberTempList);
        return;
    }

    // Process entries in deleted list
    while (!IsListEmpty (&Table->RT_DeletedList.RSL_Head)) {
        curTemp = RemoveHeadList (&Table->RT_DeletedList.RSL_Head);
        tempNode = CONTAINING_RECORD (curTemp,
                                      RTM_ROUTE_NODE,
                                      RN_Links[RTM_DELETED_LIST_LINK]);
        RemoveEntryList (&tempNode->RN_Links[RTM_NET_NUMBER_LIST_LINK]);
#if DBG
        IF_DEBUG (DISPLAY_TABLE)
            DeleteRouteFromLB (Table, tempNode);
#endif
        HeapFree (Table->RT_Heap, 0, tempNode);
    }
    // Unlock the list
    Table->RT_DeletedNodesCount = 0;
    LeaveSyncList (Table, &Table->RT_DeletedList);

                // Now, just copy the head of the temp list,
                // so we won't delay others while processing it
    if (!IsListEmpty (&Table->RT_NetNumberTempList.RSL_Head)) {
        curTemp = Table->RT_NetNumberTempList.RSL_Head.Flink;
        RemoveEntryList (&Table->RT_NetNumberTempList.RSL_Head);
        InitializeListHead (&Table->RT_NetNumberTempList.RSL_Head);
        InsertTailList (curTemp, &tempHead);
    }
    else
        InitializeListHead (&tempHead);

    Table->RT_NetNumberTempCount = 0;
    LeaveSyncList (Table, &Table->RT_NetNumberTempList);


    curMaster = Table->RT_NetNumberMasterList.RSL_Head.Flink;

    // Merge master and temp lists (both are ordered by
    // net number.interface.protocol.next hop address)
    while (!IsListEmpty (&tempHead)) {
        // Take the first entry
        curTemp = RemoveHeadList (&tempHead);
        tempNode = CONTAINING_RECORD (curTemp,
                                      RTM_ROUTE_NODE,
                                      RN_Links[RTM_NET_NUMBER_LIST_LINK]);

        // Find master list entry that should follow it
        while (curMaster!=&Table->RT_NetNumberMasterList.RSL_Head) {
            PRTM_ROUTE_NODE node = CONTAINING_RECORD (curMaster,
                                                      RTM_ROUTE_NODE,
                                                      RN_Links[RTM_NET_NUMBER_LIST_LINK]);
            if (!IsEnumerator (node)) {
                res = NetNumCmp (Table, &tempNode->RN_Route, &node->RN_Route);
                if ((res < 0)
                    ||((res == 0)
                       &&((tempNode->RN_Route.XX_PROTOCOL
                           < node->RN_Route.XX_PROTOCOL)
                          ||((tempNode->RN_Route.XX_PROTOCOL
                              ==node->RN_Route.XX_PROTOCOL)
                             &&((tempNode->RN_Route.XX_INTERFACE
                                 < node->RN_Route.XX_INTERFACE)
                                ||((tempNode->RN_Route.XX_INTERFACE
                                    ==node->RN_Route.XX_INTERFACE)
                                   && (NextHopCmp (Table, &tempNode->RN_Route,
                                                   &node->RN_Route)
                                       < 0)))))))
                    break;
            }
            curMaster = curMaster->Flink;
#if DBG
            IF_DEBUG (DISPLAY_TABLE)
                curMasterIdx += 1;
#endif
        }
        // Insert at the located point
        InsertTailList (curMaster, curTemp);
        SetSorted (tempNode);
#if DBG
        IF_DEBUG (DISPLAY_TABLE) {
            AddRouteToLB (Table, tempNode, curMasterIdx);
            curMasterIdx += 1;
        }
#endif
    }
    // We are done now
}

VOID
ExpirationAPC (
    PVOID           Context,
    ULONG           TimeLow,
    LONG            TimeHigh
    ) {
#define Table ((PRTM_TABLE)Context)
    if (InterlockedIncrement (&Table->RT_ExpirationWorkerPending)==0) {
        do {
            ProcessExpirationQueue (Table);
        }
        while (InterlockedDecrement (&Table->RT_ExpirationWorkerPending)>=0);
    }
#undef Table
}

VOID APIENTRY
ProcessExpirationQueueWI (
    PVOID           Context
    ) {
#define Table ((PRTM_TABLE)Context)
    do {
        ProcessExpirationQueue (Table);
    }
    while (InterlockedDecrement (&Table->RT_ExpirationWorkerPending)>=0);
#undef Table
}

// Checks if any entries in expiration queue have expired and deletes them
VOID
ProcessExpirationQueue (
    PRTM_TABLE              Table   // Affected table
    ) {
    DWORD                           status;
    ULONG                           tickCount = GetTickCount ();

    if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE))
        return;

                // Check all relevant entries
    while (!IsListEmpty (&Table->RT_ExpirationQueue.RSL_Head)) {
        PRTM_SYNC_LIST  hashBasket;
        PLIST_ENTRY             cur;
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            Table->RT_ExpirationQueue.RSL_Head.Flink,
            RTM_ROUTE_NODE,
            RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
        LONGLONG                dueTime;
        ULONG   timeDiff = TimeDiff (node->RN_ExpirationTime,tickCount);

        InterlockedExchange (&Table->RT_ExpirationWorkerPending, 0);

        if (IsPositiveTimeDiff (timeDiff)) {
            // The first entry in the queue is not due yet, so are
            // the others (queue is ordered by expiration time)

            dueTime = (LONGLONG)timeDiff*(-10000);
            status = NtSetTimer (Table->RT_ExpirationTimer,
                                 (PLARGE_INTEGER)&dueTime,
                                 ExpirationAPC,
                                 Table,
                                 FALSE,
                                 0,
                                 NULL);
            ASSERTMSG ("Could not set expiration timer ", NT_SUCCESS (status));
            break;
        }


        hashBasket = node->RN_Hash;
        // We need to lock the hash basket to delete the entry
        if (!EnterSyncList (Table, hashBasket, FALSE)) {
            // Can't do it at once, so we first release
            // expiration queue lock (to prevent a deadlock)
            // and then try again)
            LeaveSyncList (Table, &Table->RT_ExpirationQueue);
            if (!EnterSyncList (Table, hashBasket, TRUE)) {
                return;
            }

            if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE)) {
                LeaveSyncList (Table, hashBasket);
                return;
            }
            // Now we have both of them, but is our route still there
            if (node!=CONTAINING_RECORD (
                Table->RT_ExpirationQueue.RSL_Head.Flink,
                RTM_ROUTE_NODE,
                RN_Links[RTM_EXPIRATION_QUEUE_LINK])) {
                // Well, somebody took care of it while we were
                // waiting
                LeaveSyncList (Table, hashBasket);
                // We'll try the next one
                continue;
            }
            // Unlikely, but its due time could have changed
            timeDiff = TimeDiff (node->RN_ExpirationTime,tickCount);
            if (IsPositiveTimeDiff (timeDiff) ) {
                // The first entry in the queue is not due yet, so are
                // the others (queue is ordered by expiration time)
                LeaveSyncList (Table, hashBasket);
                dueTime = (LONGLONG)timeDiff*(-10000);
                // Well, we are done then (this was the first entry
                // in the queue (we just checked), so other are not
                // due as well)
                // Just make sure that updated thread returns soon enough
                // to take care of our first entry
                status = NtSetTimer (Table->RT_ExpirationTimer,
                                     (PLARGE_INTEGER)&dueTime,
                                     ExpirationAPC,
                                     Table,
                                     FALSE,
                                     0,
                                     NULL);
                ASSERTMSG ("Could not set expiration timer ", NT_SUCCESS (status));
                break;
            }

        }

        LeaveSyncList (Table, &Table->RT_ExpirationQueue);

        if (IsBest(node)) {
            // We need to locate the best node after this one is gone
            PRTM_ROUTE_NODE bestNode = NULL;

            cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur!=&hashBasket->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &node->RN_Route, &node1->RN_Route)==0) {
                        if ((bestNode==NULL)
                            || (MetricCmp (Table,
                                           &bestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            bestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Blink;
            }

            cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
            while (cur!=&hashBasket->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &node->RN_Route, &node1->RN_Route)==0) {
                        if ((bestNode==NULL)
                            || (MetricCmp (Table,
                                           &bestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            bestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Flink;
            }

            if (bestNode!=NULL) {   // We did find another node

                ResetBest (node);
                SetBest (bestNode);

                NotifyClients (Table,
                               NULL,
                               RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE,
                               &bestNode->RN_Route,
                               &node->RN_Route);
            }
            else {
                InterlockedDecrement (&Table->RT_NetworkCount);
                // No best node anymore
                NotifyClients (Table,
                               NULL,
                               RTM_PREVIOUS_BEST_ROUTE,
                               NULL,
                               &node->RN_Route);
            }
        }


        if (RemoveRouteNode (Table, node)!=NO_ERROR) {
            LeaveSyncList (Table, hashBasket);
            return;
        }

        LeaveSyncList (Table, hashBasket);
        // Reenter expiration queue to continue
        if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE))
            return;
    }

    LeaveSyncList (Table, &Table->RT_ExpirationQueue);
}





DWORD
DoEnumerate (
    PRTM_TABLE              Table,
    PRTM_ENUMERATOR EnumPtr,
    DWORD                   EnableFlag
    ) {
    // Now, we'll go ahead and find an entry that satisfies
    // specified criteria
    while (1) {     // This external loop is needed for the case
        // of enumerating through the hash table when
        // reaching the end of the list doesn't mean that process has
        // to be stopped: we need to move the next basket till
        // we've gone through all of them

        PLIST_ENTRY cur = EnumPtr->RE_Links[EnumPtr->RE_Link].Blink;
        while (cur!=EnumPtr->RE_Head) {
            PRTM_ROUTE_NODE node = CONTAINING_RECORD (cur, RTM_ROUTE_NODE,
                                                      RN_Links[EnumPtr->RE_Link]);
            INT     res;

            if (!IsEnumerator (node)
                && ((EnableFlag==RTM_ANY_ENABLE_STATE)
                    || IsSameEnableState(node,EnableFlag))) {


                if ((EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
                    && (EnumPtr->RE_Hash!=node->RN_Hash)) {
                    if (EnumPtr->RE_Hash!=NULL)
                        LeaveSyncList (Table, EnumPtr->RE_Hash);
                    EnumPtr->RE_Hash = node->RN_Hash;
                    if (!EnterSyncList (Table, node->RN_Hash, FALSE)) {
                        RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
                        InsertHeadList (cur, &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                        LeaveSyncList (Table, EnumPtr->RE_Lock);
                        if (!EnterSyncList (Table, EnumPtr->RE_Hash, TRUE)) {
                            EnumPtr->RE_Hash = NULL;
                            return ERROR_NO_SYSTEM_RESOURCES;
                        }
                        if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                            LeaveSyncList (Table, EnumPtr->RE_Hash);
                            EnumPtr->RE_Hash = NULL;
                            return ERROR_NO_SYSTEM_RESOURCES;
                        }
                        cur = EnumPtr->RE_Links[EnumPtr->RE_Link].Blink;
                        continue;
                    }
                }

                switch (EnumPtr->RE_Link) {
                    // Using the interface link:
                    case RTM_INTERFACE_LIST_LINK:
#if !RTM_USE_PROTOCOL_LISTS
                    case RTM_NET_NUMBER_HASH_LINK:
#endif
                        // Check protocol if necessary
                        if ((EnumPtr->RE_EnumerationFlags & RTM_ONLY_THIS_PROTOCOL)
                            && (EnumPtr->RE_Route.XX_PROTOCOL
                                !=node->RN_Route.XX_PROTOCOL)) {
                            // Break out to move ahead if protocol
                            // check fails
                            break;
                        }
                        // else Pass through to do other checks

                        // Using the protocol link: (thus we don't
                        // care about interface or we would have used
                        // interface link - see RtmCreateEnumerationHandle).
#if RTM_USE_PROTOCOL_LISTS
                    case RTM_PROTOCOL_LIST_LINK:
                        // Using the hash link: (thus we don't
                        // care about interface and protocol or we would have
                        // used other links - see RtmCreateEnumerationHandle).
                    case RTM_NET_NUMBER_HASH_LINK:
#endif
                        // Check the network number if necessary
                        if (EnumPtr->RE_EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                            res = NetNumCmp (Table, &EnumPtr->RE_Route,
                                             &node->RN_Route);
                            if (res == 0)
                                // Match, continue checks
                                ;
                            else if ((res > 0)
                                     && (EnumPtr->RE_Link
                                         ==RTM_NET_NUMBER_HASH_LINK)) {
                                // Hash list are ordered by net
                                // number, so if we got network
                                // number that is less than ours
                                // we don't have search anymore
                                // (we are going backwards)
                                return ERROR_NO_MORE_ROUTES;
                            }
                            else //  Otherwise break out of switch
                                // statement to continue the search
                                break;
                        }
                        // We didn't care about net number,
                        // so current entry will do


                        if (!(EnumPtr->RE_EnumerationFlags & RTM_ONLY_BEST_ROUTES)
                            || IsBest(node)) {
                            RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
                            InsertTailList (cur,
                                            &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                            return NO_ERROR;
                        }

                        break;
                }

            }
            // Go get next entry
            cur = cur->Blink;
        }

        // If we are not going through hash table or
        // we just interested in one network
        // or we've already been through all baskets
        // call it quits
        if ((EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
            || (EnumPtr->RE_EnumerationFlags & RTM_ONLY_THIS_NETWORK)
            || (EnumPtr->RE_Lock
                ==&Table->RT_NetNumberHash[Table->RT_HashTableSize-1]))
            break;

                        // Otherwise, go through the next basket
        RemoveEntryList (&EnumPtr->RE_Links[RTM_NET_NUMBER_HASH_LINK]);
        LeaveSyncList (Table, EnumPtr->RE_Lock);
        EnumPtr->RE_Lock += 1;
        EnumPtr->RE_Head = &EnumPtr->RE_Lock->RSL_Head;
        if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
            InitializeListEntry (&EnumPtr->RE_Links[RTM_NET_NUMBER_HASH_LINK]);
            return ERROR_NO_SYSTEM_RESOURCES;
        }

        InsertTailList (EnumPtr->RE_Head,
                        &EnumPtr->RE_Links[RTM_NET_NUMBER_HASH_LINK]);
    }
    return ERROR_NO_MORE_ROUTES;
}


//----------------------------------------------------------------------------
// SetMaskCount
//
//  Does a binary search of the g_meMaskTable to find the matching 
//  mask entry and increments the count for the specified mask
//  
//----------------------------------------------------------------------------

VOID
SetMaskCount( 
    PIP_NETWORK                 pinNet,
    BOOL                        bAdd
)
{

    DWORD                       dwLower, dwUpper, dwInd, dwMask;

    
    dwLower = 0;

    dwUpper = MAX_MASKS;

    dwMask  = pinNet-> N_NetMask;
    
    while ( dwLower <= dwUpper )
    {
        dwInd = ( dwLower + dwUpper ) / 2;

        if ( g_meMaskTable[ dwInd ].dwMask < dwMask )
        {
            //
            // Match is to be found in upper half of search region.
            //
            
            dwLower = dwInd + 1;
        }

        else if ( g_meMaskTable[ dwInd ].dwMask > dwMask )
        {
            //
            // Match is to be found in lower half of search region.
            //
            
            dwUpper = dwInd - 1;
        }

        else
        {
            //
            // Match found
            //

            if ( bAdd )
            {
                InterlockedIncrement( &g_meMaskTable[ dwInd ].dwCount );
            }

            else
            {
                InterlockedDecrement( &g_meMaskTable[ dwInd ].dwCount );
            }

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtdlg.h ===
#define IDD_RTM_TABLE               100
#define IDD_CLIENT                  200
#define IDT_TICK_COUNT              103
#define IDL_ROUTES                  102
#define IDC_PROTOCOL_FAMILY         101
#define IDB_RESYNC                  104
#define IDT_EXPIRATION              107
#define IDT_UPDATE                  108
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmtest.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmdlg.c

Abstract:
	Interactive test code for RTM dll


Author:

	Vadim Eydelman

Revision History:

--*/


#ifndef NT_INCLUDED
#include <nt.h>
#endif

#ifndef _NTRTL_
#include <ntrtl.h>
#endif

#ifndef _NTURTL_
#include <nturtl.h>
#endif

#include <windows.h>

#ifndef _WINSOCKAPI_
#include <winsock.h>
#endif

#ifndef _WSIPX_
#include <wsipx.h>
#endif

#ifndef _WSNWLINK_
#include <wsnwlink.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#ifndef _ROUTING_RTM_
#include "RTM.h"
#endif

#ifndef _ROUTING_RMRTM_
#include "RMRTM.h"
#endif


#include "cldlg.h"
#include "enumdlg.h"


#if DBG
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}

#define ASSERTERRMSG(msg,exp)								\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}
#else
#define ASSERTERR(exp)
#define ASSERTERRMSG(msg,exp)
#endif

// Basic route info, present in routes of all types
typedef	struct {
		ROUTE_HEADER;
		} RTM_XX_ROUTE, *PRTM_XX_ROUTE;

typedef union _RTM_ROUTE {
	RTM_XX_ROUTE		XX;
	RTM_IP_ROUTE		IP;
	RTM_IPX_ROUTE		IPX;
	} RTM_ROUTE, *PRTM_ROUTE;

#define XX_INTERFACE	XX.RR_InterfaceID
#define XX_PROTOCOL		XX.RR_RoutingProtocol
#define XX_TIMESTAMP	XX.RR_TimeStamp

#define IP_PROTOCOL		IP.RR_RoutingProtocol
#define	IP_INTERFACE	IP.RR_InterfaceID
#define IP_METRIC		IP.RR_FamilySpecificData.FSD_Metric1
#define IP_TIMESTAMP	IP.RR_TimeStamp
#define IP_NET_NUM		IP.RR_Network.N_NetNumber
#define IP_NET_MSK		IP.RR_Network.N_NetMask
#define IP_NEXT_HOP_NUM	IP.RR_NextHopAddress.N_NetNumber
#define IP_NEXT_HOP_MSK	IP.RR_NextHopAddress.N_NetMask
#define IP_ADPTER_INDEX	IP.RR_FamilySpecificData.FSD_AdapterIndex
#define IP_PROTOCOL_METRIC IP.RR_FamilySpecificData.FSD_ProtocolMetric
#define IP_PSD			IP.RR_ProtocolSpecificData

#define IPX_PROTOCOL		IPX.RR_RoutingProtocol
#define	IPX_INTERFACE		IPX.RR_InterfaceID
#define IPX_METRIC			IPX.RR_FamilySpecificData.FSD_Ticks
#define IPX_TIMESTAMP		IPX.RR_TimeStamp
#define IPX_NET_NUM			IPX.RR_Network.N_NetNumber
#define IPX_NEXT_HOP_MAC	IPX.RR_NextHopAddress.NHA_Mac
#define IPX_HOP_COUNT		IPX.RR_FamilySpecificData.FSD_HopCount
#define IPX_PSD				IPX.RR_ProtocolSpecificData

typedef struct _ENABLE_DLG_GROUP_PARAM {
			HWND			hCtlFirst;
			BOOLEAN			foundFirst;
			BOOLEAN			enableFlag;
			} ENABLE_DLG_GROUP_PARAM, *PENABLE_DLG_GROUP_PARAM;

HANDLE		*Clients;
HANDLE		*Events;
HANDLE		hDLLInstance;
HANDLE		*InteractiveThreads;
HANDLE		*IPXRIPThreads;
SOCKET		*Sockets;
HANDLE		*Enums;

DWORD WINAPI
ClientThread (
	LPVOID param
	);
	
	
BOOL CALLBACK
ClientDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);

BOOL CALLBACK
DoEnable (
	HWND		hwnd,	// handle of child window
	LPARAM		lParam	// application-defined value
	);

VOID
EnableDlgGroup (
	HWND		hDlg,
	HWND		hCtlFirst,
	BOOLEAN		enable
	);

VOID
DoRegister (
	HWND			hDlg,
	LONG			idx
	);

VOID
DoDeregister (
	HWND			hDlg,
	LONG			idx
	);

VOID
SetupAdd (
	HWND		hDlg
	);

VOID
SetupDelete (
	HWND		hDlg
	);

VOID
SetupDequeue (
	HWND		hDlg
	);

VOID
SetupSetEnable (
	HWND		hDlg
	);

VOID
SetupConvert (
	HWND		hDlg
	);

VOID
DoOperation (
	HWND		hDlg,
	LONG		idx
	);

DWORD WINAPI
IPXRIPListenThread (
	LPVOID		param
	);

DWORD WINAPI
EnumThread (
	LPVOID param
	);
	
BOOL CALLBACK
EnumDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);
VOID
GetCriteria (
	HWND		hDlg,
	DWORD		*ProtocolFamily,
	DWORD		*flags,
	PRTM_ROUTE	Route
	);

VOID
GetLastRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	);

VOID
DisplayRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	);


INT
IPNetCmp (
	PVOID		Net1,
	PVOID		Net2
	) {
#define IPNet1 ((PIP_NETWORK)Net1)
#define IPNet2 ((PIP_NETWORK)Net2)
	if (IPNet1->N_NetNumber>IPNet2->N_NetNumber)
		return 1;
	else if (IPNet1->N_NetNumber<IPNet2->N_NetNumber)
		return -1;
	else if (IPNet1->N_NetMask==IPNet2->N_NetMask)
		return 0;
	else if (IPNet1->N_NetMask>IPNet2->N_NetMask)
		return 1;
	else /*if (IPNet1->N_NetMask<IPNet2->N_NetMask)*/
		return -1;

#undef IPNet2
#undef IPNet1
	}
INT
IPNhaCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPRoute1 ((PRTM_ROUTE)Route1)
#define IPRoute2 ((PRTM_ROUTE)Route2)
	if (IPRoute1->IP_NET_NUM>IPRoute2->IP_NET_NUM)
		return 1;
	else if (IPRoute1->IP_NET_NUM<IPRoute2->IP_NET_NUM)
		return -1;
	else if (IPRoute1->IP_NET_MSK==IPRoute2->IP_NET_MSK)
		return 0;
	else if (IPRoute1->IP_NET_MSK>IPRoute2->IP_NET_MSK)
		return 1;
	else /*if (IPNet1->IP_NET_MSK<IPNet2->IP_NET_MSK)*/
		return -1;

#undef IPRoute2
#undef IPRoute1
	}

INT
IPMetricCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPRoute1 ((PRTM_ROUTE)Route1)
#define IPRoute2 ((PRTM_ROUTE)Route2)
	if (IPRoute1->IP_METRIC>IPRoute2->IP_METRIC)
		return 1;
	else if (IPRoute1->IP_METRIC<IPRoute2->IP_METRIC)
		return -1;
	else
		return 0;
#undef IPRoute2
#undef IPRoute1
	}

BOOL
IPFsdCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPRoute1 ((PRTM_ROUTE)Route1)
#define IPRoute2 ((PRTM_ROUTE)Route2)
	return memcmp (&IPRoute1->IP.RR_FamilySpecificData,
					&IPRoute2->IP.RR_FamilySpecificData,
					sizeof (IPRoute1->IP.RR_FamilySpecificData))==0;
#undef IPRoute2
#undef IPRoute1
	}

INT
IPHash (
	PVOID		Net
	) {
	return (*((PULONG)Net))%257;
	}

VOID
IPChange (
	DWORD		Flags,
	PVOID		CurBestRoute,
	PVOID		PrevBestRoute
	) {
	fprintf (stderr, "IPRouteChange: Flags=%d, CurBest: %08x, PrevBest: %08x\n",
					Flags, CurBestRoute, PrevBestRoute);
	}


INT
IPXNetCmp (
	PVOID		Net1,
	PVOID		Net2
	) {
#define IPXNet1 ((PIPX_NETWORK)Net1)
#define IPXNet2 ((PIPX_NETWORK)Net2)
	if (IPXNet1->N_NetNumber>IPXNet2->N_NetNumber)
		return 1;
	else if (IPXNet1->N_NetNumber<IPXNet2->N_NetNumber)
		return -1;
	else
		return 0;
#undef IPXNet2
#undef IPXNet1
	}

INT
IPXNhaCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPXRoute1 ((PRTM_ROUTE)Route1)
#define IPXRoute2 ((PRTM_ROUTE)Route2)
	return memcmp (IPXRoute1->IPX_NEXT_HOP_MAC,
					IPXRoute2->IPX_NEXT_HOP_MAC,
					sizeof (IPXRoute1->IPX_NEXT_HOP_MAC));
#undef IPXRoute2
#undef IPXRoute1
	}

INT
IPXMetricCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPXRoute1 ((PRTM_ROUTE)Route1)
#define IPXRoute2 ((PRTM_ROUTE)Route2)
	if (IPXRoute1->IPX_METRIC>IPXRoute2->IPX_METRIC)
		return 1;
	else if (IPXRoute1->IPX_METRIC<IPXRoute2->IPX_METRIC)
		return -1;
	else
		return 0;
#undef IPXRoute2
#undef IPXRoute1
	}

BOOL
IPXFsdCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPXRoute1 ((PRTM_ROUTE)Route1)
#define IPXRoute2 ((PRTM_ROUTE)Route2)
	return IPXRoute1->IPX_HOP_COUNT==IPXRoute1->IPX_HOP_COUNT;
#undef IPXRoute2
#undef IPXRoute1
	}
INT
IPXHash (
	PVOID		Net
	) {
	return (*((PULONG)Net))%257;
	}

VOID
IPXChange (
	DWORD		Flags,
	PVOID		CurBestRoute,
	PVOID		PrevBestRoute
	) {
	fprintf (stderr, "IPXRouteChange: Flags=%d, CurBest: %08x, PrevBest: %08x\n",
					Flags, CurBestRoute, PrevBestRoute);
	}

DWORD
Validate (
	PVOID	Route
	) {
	return NO_ERROR;
	}

int _cdecl
main (
	int argc,
	char **argv
	) {
	INT				i, n, m, p;
	INT				id;
	DWORD			status;
static RTM_PROTOCOL_FAMILY_CONFIG IPXConfig = {
							8*1024*1024,
							257,
							sizeof (RTM_IPX_ROUTE),
							IPXNetCmp,
							IPXNhaCmp,
							IPXMetricCmp,
							IPXFsdCmp,
							IPHash,
							Validate,
							IPXChange };
static RTM_PROTOCOL_FAMILY_CONFIG IPConfig = {
							8*1024*1024,
							257,
							sizeof (RTM_IP_ROUTE),
							IPNetCmp,
							IPNhaCmp,
							IPXMetricCmp,
							IPFsdCmp,
							IPHash,
							Validate,
							IPChange };
	status = RtmCreateRouteTable (RTM_PROTOCOL_FAMILY_IPX,
							&IPXConfig);
	ASSERTMSG ("Could not create IPX Route Table ", status == NO_ERROR);

	status = RtmCreateRouteTable (RTM_PROTOCOL_FAMILY_IP,
							&IPConfig);


	ASSERTMSG ("Could not create IPX Route Table ", status == NO_ERROR);
	if (argc>=4) {
		n = atoi (argv[1]);
		p = atoi (argv[2]);
		m = atoi (argv[3]);

		Clients = (HANDLE *)GlobalAlloc (GMEM_FIXED, n*sizeof (HANDLE));
		ASSERTERR (Clients!=NULL);

		Events = (HANDLE *)GlobalAlloc (GMEM_FIXED, n*sizeof (HANDLE));
		ASSERTERR (Events!=NULL);

		Enums = (HANDLE *)GlobalAlloc (GMEM_FIXED, p*sizeof (HANDLE));
		ASSERTERR (Events!=NULL);

		InteractiveThreads = (HANDLE *)GlobalAlloc (GMEM_FIXED, (n+p)*sizeof (HANDLE));
		ASSERTERR (InteractiveThreads!=NULL);

		hDLLInstance = LoadLibrary ("rtm.dll");
		ASSERTERR (hDLLInstance!=NULL);

		if (m>0) {
			INT		m1;
			WORD			wVersionRequested;
			WSADATA			wsaData;
			INT				err, length;
			SOCKADDR_IPX	addr;
			SOCKET			s;
			IPX_ADDRESS_DATA adptData;
			BOOL			flag;

			wVersionRequested = MAKEWORD( 1, 1 );
			err = WSAStartup( wVersionRequested, &wsaData );
			ASSERT (err==NO_ERROR);

			s = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
			ASSERTERR (s!=INVALID_SOCKET);

			memset (&addr, 0, sizeof (addr));
			addr.sa_family = AF_IPX;
			status = bind (s, (PSOCKADDR)&addr, sizeof (addr));
			ASSERTERRMSG ("Can't bind to default address.\n", status==0);
		
			// Get number of available adapters
			length = sizeof (INT);
			status = getsockopt (s,
					NSPROTO_IPX,
					IPX_MAX_ADAPTER_NUM,
					(PUCHAR)&m1,
					&length);
			ASSERTERRMSG ("Can't get number of adapters.", status==0);
			ASSERTMSG ("No adapters available", m1>0);
			if (m>m1)
				m = m1;

			IPXRIPThreads = (HANDLE *)GlobalAlloc (GMEM_FIXED, m*sizeof(HANDLE));
			ASSERTERR (IPXRIPThreads!=NULL);

			Sockets = (SOCKET *)GlobalAlloc (GMEM_FIXED, m*sizeof (SOCKET));
			ASSERTERR (Sockets!=NULL);

			for (i=0; i<m; i++) {
				Sockets[i] = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
				ASSERTERR (Sockets[i]!=INVALID_SOCKET);

				flag = TRUE;
				status = setsockopt (Sockets[i],
									SOL_SOCKET,
									SO_BROADCAST,
									(PCHAR)&flag,
									sizeof (BOOL));
				ASSERTERRMSG ("Can't set socket broadcast option.", status==0);

				flag = TRUE;
				status = setsockopt (Sockets[i],
									NSPROTO_IPX,
									IPX_RECEIVE_BROADCAST,
									(PCHAR)&flag,
									sizeof (BOOL));
				ASSERTERRMSG ("Can't set IPX broadcast option.", status==0);

				flag = TRUE;
				status = setsockopt (Sockets[i],
									NSPROTO_IPX,
									IPX_RECVHDR,
									(PCHAR)&flag,
									sizeof (BOOL));
				ASSERTERRMSG ("Can't set receive header option.", status==0);

				length = sizeof (adptData);
				adptData.adapternum = i;
				status = getsockopt (s,
									NSPROTO_IPX,
									IPX_ADDRESS,
									(PCHAR)&adptData,
									&length);
				ASSERTERRMSG ("Can't get adapter parameters.", status==0);

				memcpy (&addr.sa_netnum, &adptData.netnum, sizeof (addr.sa_netnum));
				fprintf (stderr,
					 "IPX RIP Listener # %d: Net=%02x%02x%02x%02x\n",
					 i, (UCHAR)addr.sa_netnum[0],
					 	(UCHAR)addr.sa_netnum[1],
					 	(UCHAR)addr.sa_netnum[2],
					 	(UCHAR)addr.sa_netnum[3]); 
				memcpy (&addr.sa_nodenum, &adptData.nodenum, sizeof (addr.sa_nodenum));
				fprintf (stderr,
					 "IPX RIP Listener # %d: Node=%02x%02x%02x%02x%02x%02x\n",
					 i, (UCHAR)addr.sa_nodenum[0],
					 	(UCHAR)addr.sa_nodenum[1],
					 	(UCHAR)addr.sa_nodenum[2],
					 	(UCHAR)addr.sa_nodenum[3],
					 	(UCHAR)addr.sa_nodenum[4],
					 	(UCHAR)addr.sa_nodenum[5]); 

				addr.sa_family = AF_IPX;
				addr.sa_socket = htons (0x452);

				status = bind (Sockets[i], (PSOCKADDR)&addr, sizeof(addr));
				ASSERTERRMSG ("Can't bind to adapter's address.", status==0);

				IPXRIPThreads[i] = CreateThread (NULL,
												0,
												&IPXRIPListenThread,
												(LPVOID)i,
												0,
												&id);
				ASSERTERR (IPXRIPThreads[i]!=NULL);
				}
			closesocket (s);			
			}

		for (i=0; i<n; i++) {
			InteractiveThreads[i] = CreateThread (NULL,
												 0,
												 &ClientThread, 
												 (LPVOID)i, 
												 0, 
												 &id);
			ASSERTERR (InteractiveThreads[i]!=NULL);
			}

		for (i=0; i<p ; i++) {
			InteractiveThreads[n+i] = CreateThread (NULL,
												 0,
												 &EnumThread, 
												 (LPVOID)i, 
												 0, 
												 &id);
			ASSERTERR (InteractiveThreads[n+i]!=NULL);
			}


		WaitForMultipleObjects (n+p, InteractiveThreads, TRUE, INFINITE);
		if (m>0) {
			for (i=0; i<m; i++)
				closesocket (Sockets[i]);
			status = WaitForMultipleObjects (m, IPXRIPThreads, TRUE, 5*1000);
			if (status==WAIT_TIMEOUT) {
				for (i=0; i<m; i++)
					TerminateThread (IPXRIPThreads[i], 0);
				}
			for (i=0; i<m; i++)
				CloseHandle (IPXRIPThreads[i]);

			}

		for (i=0; i<=n; i++)
			CloseHandle (InteractiveThreads[i]);
		FreeLibrary (hDLLInstance);
		WSACleanup ();
		}
	else 
		fprintf (stderr,
			 "Usage: %s <n_of_clients> <n_of_enumerators> <max_rip_listeners>\n",
			 argv[0]);

	RtmDeleteRouteTable (RTM_PROTOCOL_FAMILY_IP);
	RtmDeleteRouteTable (RTM_PROTOCOL_FAMILY_IPX);
	return 0;
	}

#define idx ((LONG)param)
DWORD WINAPI
ClientThread (
	LPVOID param
	) {
	MSG				msg;
	DWORD			status;
	HWND			ClientDlg;
	char			buf[16];
	BOOLEAN			done = FALSE;
	
	Clients[idx] = NULL;

	Events[idx] = CreateEvent (NULL, FALSE, FALSE, NULL);
	ASSERTERR (Events[idx]!=NULL);

		// Create dialog window
	ClientDlg = CreateDialogParam (hDLLInstance,
				MAKEINTRESOURCE(IDD_RTM_CLIENT),
				NULL,
				&ClientDlgProc,
				(LPARAM)idx);
	ASSERTERR (ClientDlg!=NULL);

	sprintf (buf, "Client # %d", idx+1);
	SetWindowText (ClientDlg, buf);

	while (!done) {
		status = MsgWaitForMultipleObjects (
					1,
					&Events[idx],
					FALSE,
					1000,
					QS_ALLINPUT
					);

		ASSERTERR (status!=0xFFFFFFFF);
		if (status==WAIT_OBJECT_0) {
			if (IsWindow (ClientDlg) && (Clients[idx]!=NULL))
				EnableWindow (GetDlgItem (ClientDlg, IDR_DEQUEUE_C), TRUE);
			else
				ASSERTMSG ("Event signalled to dead client or closed window ", FALSE);
			}
		while (PeekMessage (&msg,  NULL, 0, 0, PM_REMOVE)) {
			if (msg.message!=WM_QUIT) {
				if (!IsWindow(ClientDlg)
					|| !IsDialogMessage(ClientDlg, &msg)) {
					TranslateMessage (&msg);
					DispatchMessage (&msg);
					}
				}
			else
				done = TRUE;
			}
		}

	if (IsWindow (ClientDlg)) {
		DestroyWindow (ClientDlg);
		ClientDlg = NULL;
		}
	CloseHandle (Events[idx]);

	return msg.wParam;
	}
#undef idx	


BOOL CALLBACK
ClientDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL		res = FALSE;
	LONG		idx;

	idx = GetWindowLong (hDlg, DWL_USER)-1;

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
			idx = lParam+1;
			SetWindowLong (hDlg, DWL_USER, idx);
			ASSERTERR (GetLastError ()==NO_ERROR);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), FALSE);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_REQUEST_C), FALSE);
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_C,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IPX,
							(LPARAM)"IPX"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_C,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IP,
							(LPARAM)"IP"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_C,
							CB_SETCURSEL,
							0,
							0
							);
			SetDlgItemText (hDlg, IDB_REGISTER_OP_C, "Register");

			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					PostQuitMessage (0);
					res = TRUE;
					break;
				case IDB_REGISTER_OP_C:
					if (Clients[idx]==NULL)
						DoRegister (hDlg, idx);
					else
						DoDeregister (hDlg, idx);
					res = TRUE;
					break;
				case IDR_ADD_C:
					SetupAdd (hDlg);
					res = TRUE;
					break;
				case IDR_DELETE_C:
					SetupDelete (hDlg);
					res = TRUE;
					break;
				case IDR_DEQUEUE_C:
					if (GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C,
								 NULL, FALSE)!=0)
						SetupDequeue (hDlg);
					else
						SetupConvert (hDlg);
					res = TRUE;
					break;
				case IDR_DISABLE_C:
				case IDR_ENABLE_C:
					SetupSetEnable (hDlg);
					res = TRUE;
					break;
				case IDB_DO_IT_C:
					DoOperation (hDlg, idx);
					res = TRUE;
					break;
				}
			break;
		case WM_DESTROY:
			if (Clients[idx]!=NULL) {
				if (RtmDeregisterClient (Clients[idx])!=NO_ERROR)
					MessageBox (hDlg, "Deregister failed!", NULL, MB_OK|MB_ICONSTOP);

				Clients[idx] = NULL;
				}
			break;
		}

	return res;
	}



VOID
DoRegister (
	HWND			hDlg,
	LONG			idx
	) {
	DWORD	ProtocolFamily;
	DWORD	RoutingProtocol;

	ProtocolFamily = SendDlgItemMessage (hDlg, IDC_PROTOCOL_FAMILY_C,
										CB_GETCURSEL, 0, 0);
	RoutingProtocol = GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);
	SetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, RoutingProtocol, FALSE);
	Clients[idx] = RtmRegisterClient (ProtocolFamily, 
									RoutingProtocol,
									(RoutingProtocol!=0)
										? Events[idx]
										: NULL,
									(RoutingProtocol!=0)
										? 0
										: RTM_PROTOCOL_SINGLE_ROUTE);
	if (Clients[idx]!=NULL) {
		RECT	rectScr, rectDlg;

		EnableWindow (GetDlgItem (hDlg, IDC_PROTOCOL_FAMILY_C), FALSE);
		EnableWindow (GetDlgItem (hDlg, IDE_ROUTING_PROTOCOL_C), FALSE);
		SetDlgItemText (hDlg, IDB_REGISTER_OP_C, "Deregister");
		EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_REQUEST_C), TRUE);
		if (RoutingProtocol!=0) {
			SetDlgItemText (hDlg, IDR_DEQUEUE_C, "Dequeue");
			EnableWindow (GetDlgItem (hDlg, IDR_DEQUEUE_C), FALSE);
			}
		else
			SetDlgItemText (hDlg, IDR_DEQUEUE_C, "Convert");

		GetWindowRect (GetDlgItem (hDlg, IDE_NET_NUMBER_C), &rectScr);
		MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
				rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				rectDlg.right = 8*4+5;
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				rectDlg.right = 16*4+5;
				break;
			}
		MapDialogRect (hDlg, &rectDlg);
		MoveWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C),
					rectScr.left,
					rectScr.top,
					rectDlg.right,
					rectScr.bottom-rectScr.top,
					TRUE);

		GetWindowRect (GetDlgItem (hDlg, IDE_NEXT_HOP_C), &rectScr);
		MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
				rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				rectDlg.right = 12*4+5;
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				rectDlg.right = 16*4+5;
				break;
			}
		MapDialogRect (hDlg, &rectDlg);
		MoveWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C),
					rectScr.left,
					rectScr.top,
					rectDlg.right,
					rectScr.bottom-rectScr.top,
					TRUE);
		SendDlgItemMessage (hDlg, IDR_ADD_C, BM_SETCHECK, (WPARAM)1, 0);
		SetupAdd (hDlg);
		}
	else
		MessageBox (hDlg, "Registration failed!", NULL, MB_OK|MB_ICONSTOP);
	}


VOID
DoDeregister (
	HWND			hDlg,
	LONG			idx
	) {

	if (RtmDeregisterClient (Clients[idx])!=NO_ERROR)
		MessageBox (hDlg, "Deregister failed!", NULL, MB_OK|MB_ICONSTOP);

	Clients[idx] = NULL;
	ResetEvent (Events[idx]);

	EnableWindow (GetDlgItem (hDlg, IDC_PROTOCOL_FAMILY_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_ROUTING_PROTOCOL_C), TRUE);
	SetDlgItemText (hDlg, IDB_REGISTER_OP_C, "Register");
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), FALSE);
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_REQUEST_C), FALSE);
	}

VOID
SetupAdd (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupDelete (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupDequeue (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupSetEnable (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupConvert (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
DoOperation (
	HWND		hDlg,
	LONG		idx
	) {
	char						buf[32];
	LONG						TimeToLive;
	RTM_ROUTE					Route;
	DWORD						status;
	DWORD						ProtocolFamily;
	INT							i,n,val;
	DWORD						Flags;
	char						*p;
		
	memset (&Route, 0 , sizeof (RTM_ROUTE));
	ProtocolFamily = SendDlgItemMessage (hDlg, IDC_PROTOCOL_FAMILY_C,
										CB_GETCURSEL, 0, 0);

	if (IsDlgButtonChecked (hDlg, IDR_ADD_C)
		|| IsDlgButtonChecked (hDlg, IDR_DELETE_C)) {
		Route.XX_PROTOCOL 
			= GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);

		
		GetDlgItemText (hDlg, IDE_NET_NUMBER_C, buf, sizeof (buf)-1);
		p = buf;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IPX_NET_NUM = val;
				else
					Route.IPX_NET_NUM = 0;
    			p += n;
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NET_NUM = val;
				else
					Route.IP_NET_NUM = 0;
    			p += n;
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NET_MSK = val;
				else
					Route.IP_NET_MSK = 0;
    			p += n;
				break;
			}

		GetDlgItemText (hDlg, IDE_NEXT_HOP_C, buf, sizeof (buf)-1);
		p = buf;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				for (i=0; i<sizeof(Route.IPX_NEXT_HOP_MAC); i++, p+=n) {
					if (sscanf (p, "%2X%n", &val, &n)==1)
						Route.IPX_NEXT_HOP_MAC[i] = (BYTE)val;
					else
						Route.IPX_NEXT_HOP_MAC[i] = 0;
					}
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NEXT_HOP_NUM = val;
				else
					Route.IP_NEXT_HOP_NUM = 0;
    			p += n;
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NEXT_HOP_MSK = val;
				else
					Route.IP_NEXT_HOP_MSK = 0;
    			p += n;
				break;
			}

		Route.XX_INTERFACE
			 = GetDlgItemInt (hDlg, IDE_INTERFACE_C, NULL, FALSE);

		if (IsDlgButtonChecked (hDlg, IDR_ADD_C)) {
			switch (ProtocolFamily) {
				case RTM_PROTOCOL_FAMILY_IPX:
					Route.IPX_METRIC = (USHORT)GetDlgItemInt 
								(hDlg, IDE_METRIC_C, NULL, FALSE);
					break;
				case RTM_PROTOCOL_FAMILY_IP:
					Route.IP_METRIC = (USHORT)GetDlgItemInt 
								(hDlg, IDE_METRIC_C, NULL, FALSE);
					break;
				}


			TimeToLive = GetDlgItemInt (hDlg, IDE_TIMEOUT_C, NULL, FALSE);
			SetDlgItemInt (hDlg, IDE_TIMEOUT_C, TimeToLive, FALSE);
			GetDlgItemText (hDlg, IDR_ADD_C, buf, sizeof (buf)-1);
			status = RtmAddRoute (Clients[idx], &Route,
						TimeToLive,
						&Flags, NULL, NULL);
				
			}
		else {
			status = RtmDeleteRoute (Clients[idx], &Route,
									&Flags, NULL);
			SetDlgItemText (hDlg, IDE_TIMEOUT_C, "");
			}
		if (status!=NO_ERROR) {
			sprintf (buf, "Rtm returned error: %ld", status);
			MessageBox (hDlg, buf, "Error", MB_OK|MB_ICONEXCLAMATION);
			}
		SetDlgItemText (hDlg, IDL_ROUTING_PROTOCOL_C, "");
		}
	else if (IsDlgButtonChecked (hDlg, IDR_DEQUEUE_C)) {
		RTM_ROUTE	Route1;
		Route.XX_PROTOCOL
			 = GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);
		
		if (Route.XX_PROTOCOL!=0) {
			status = RtmDequeueRouteChangeMessage (Clients[idx],
													&Flags,
													&Route,
													&Route1);
			if (status==NO_ERROR) {
				SendDlgItemMessage (hDlg, IDR_DEQUEUE_C, BM_SETCHECK, (WPARAM)0, 0);
				EnableWindow (GetDlgItem (hDlg, IDR_DEQUEUE_C), FALSE);
				EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), FALSE);
				}
			else if (status!=ERROR_MORE_MESSAGES) {
				sprintf (buf, "Rtm returned error: %ld", status);
				MessageBox (hDlg, buf, "Error", MB_OK|MB_ICONEXCLAMATION);
				}
			if (!(Flags & RTM_CURRENT_BEST_ROUTE))
				memcpy (&Route, &Route1, sizeof (Route));
			SetDlgItemInt (hDlg, IDL_ROUTING_PROTOCOL_C, (UINT)Route.XX_PROTOCOL, FALSE);
			SetDlgItemText (hDlg, IDE_TIMEOUT_C, "");
			}
		else {
			Route.XX_INTERFACE
				 = GetDlgItemInt (hDlg, IDE_INTERFACE_C, NULL, FALSE);
			status = RtmBlockConvertRoutesToStatic (
						Clients[idx],
						RTM_ONLY_THIS_INTERFACE,
						&Route);
			goto OpDone;
			}
		}
	else if (IsDlgButtonChecked (hDlg, IDR_DISABLE_C)
				|| IsDlgButtonChecked (hDlg, IDR_ENABLE_C)) {
		Route.XX_PROTOCOL
			 = GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);
		Route.XX_INTERFACE 
			= GetDlgItemInt (hDlg, IDE_INTERFACE_C, NULL, FALSE);
		status = RtmBlockSetRouteEnable (Clients[idx],
											RTM_ONLY_THIS_INTERFACE,
											&Route,
							IsDlgButtonChecked (hDlg, IDR_ENABLE_C));
		goto OpDone;
		}

	SetDlgItemInt (hDlg, IDL_MESSAGE_FLAGS_C, (UINT)Flags, FALSE);
	SetDlgItemInt (hDlg, IDE_INTERFACE_C, (UINT)Route.XX_INTERFACE, FALSE);

	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			sprintf (buf,
					"%08X",
					Route.IPX_NET_NUM);
			SetDlgItemInt (hDlg, IDE_METRIC_C, (UINT)Route.IPX_METRIC, FALSE);
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			sprintf (buf,
					"%08X%08X",
					Route.IP_NET_NUM,
					Route.IP_NET_MSK);
			SetDlgItemInt (hDlg, IDE_METRIC_C, (UINT)Route.IP_METRIC, FALSE);
			break;
		}
	SetDlgItemText (hDlg, IDE_NET_NUMBER_C, buf);

	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			sprintf (buf,
					"%02X%02X%02X%02X%02X%02X",
					Route.IPX_NEXT_HOP_MAC[0],
					Route.IPX_NEXT_HOP_MAC[1],
					Route.IPX_NEXT_HOP_MAC[2],
					Route.IPX_NEXT_HOP_MAC[3],
					Route.IPX_NEXT_HOP_MAC[4],
					Route.IPX_NEXT_HOP_MAC[5]);
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			sprintf (buf,
					"%08X%08X",
					Route.IP_NEXT_HOP_NUM,
					Route.IP_NEXT_HOP_MSK);
			break;
		}

	SetDlgItemText (hDlg, IDE_NEXT_HOP_C, buf);
OpDone:
	;
	}


#define pParam ((PENABLE_DLG_GROUP_PARAM)lParam)
BOOL CALLBACK
DoEnable (
	HWND		hwnd,	// handle of child window
	LPARAM		lParam	// application-defined value
	) {
	if (!pParam->foundFirst) {
		if (pParam->hCtlFirst != hwnd)
			return TRUE;
		else
			pParam->foundFirst = TRUE;
		}
	else if (GetWindowLong (hwnd, GWL_STYLE) & WS_GROUP)
		return FALSE;

	EnableWindow (hwnd, pParam->enableFlag);
	return TRUE;
	}
#undef pParam


VOID
EnableDlgGroup (
	HWND		hDlg,
	HWND		hCtlFirst,
	BOOLEAN		enable
	) {
	ENABLE_DLG_GROUP_PARAM		param;
	
	param.hCtlFirst	= hCtlFirst;
	param.foundFirst = FALSE;
	param.enableFlag = enable;

	EnumChildWindows (hDlg, DoEnable, (LPARAM)&param);
	}




typedef USHORT IPX_SOCKETNUM, *PIPX_SOCKETNUM;
typedef UCHAR IPX_NETNUM[4], *PIPX_NETNUM;
typedef UCHAR IPX_NODENUM[6], *PIPX_NODENUM;

typedef struct _IPX_ADDRESS_BLOCK {
	IPX_NETNUM		net;
	IPX_NODENUM	node;
	IPX_SOCKETNUM	socket;
	} IPX_ADDRESS_BLOCK, *PIPX_ADDRESS_BLOCK;

// IPX Net Number copy macro
#define IPX_NETNUM_CPY(dst,src) memcpy(dst,src,sizeof(IPX_NETNUM))
// IPX Net Number comparison
#define IPX_NETNUM_CMP(addr1,addr2) memcmp(net1,net2,sizeof(IPX_NETNUM))

// IPX Node Number copy macro
#define IPX_NODENUM_CPY(dst,src) memcpy(dst,src,sizeof(IPX_NODENUM))
// IPX Node Number comparison
#define IPX_NODENUM_CMP(node1,node2) memcmp(node1,node2,sizeof(IPX_NODENUM))

// IPX Address copy macro
#define IPX_ADDR_CPY(dst,src) memcpy(dst,src,sizeof(IPX_ADDRESS_BLOCK))
// IPX Address comparison
#define IPX_ADDR_CMP(addr1,addr2) memcmp(addr1,addr2,sizeof(IPX_ADDRESS_BLOCK))

	// Header of IPX packet
typedef struct _IPX_HEADER {
		USHORT				checksum;
		USHORT				length;
		UCHAR				transportctl;
		UCHAR				pkttype;
		IPX_ADDRESS_BLOCK	dst;
		IPX_ADDRESS_BLOCK	src;
		} IPX_HEADER, *PIPX_HEADER;

typedef struct _IPX_SAP_PACKET {
		IPX_HEADER			hdr;
		USHORT				operation;
		struct {
			USHORT				type;
			UCHAR				name[48];
			IPX_ADDRESS_BLOCK	addr;
			USHORT				hops;
			}				entry[7];
		} IPX_SAP_PACKET, *PIPX_SAP_PACKET;

DWORD WINAPI
IPXRIPListenThread (
	LPVOID		param
	) {
#define adptIdx ((INT)param)
	INT				status;
	IPX_SAP_PACKET	packet;
	HANDLE			hClient;
	RTM_IPX_ROUTE	Route;
	DWORD			flags;
	IPX_NETNUM_DATA	netData;
	INT				length;


	fprintf (stderr, "IXP RIP Listener # %d: Started.\n", adptIdx);

	hClient = RtmRegisterClient (RTM_PROTOCOL_FAMILY_IPX, 1000+adptIdx, NULL, 0);
	ASSERT (hClient!=NULL);
	
	while (((status=recvfrom (Sockets[adptIdx],
							 (PCHAR)&packet,
							 sizeof (packet),
							  0, NULL, NULL)) != 0)
				&& (status!=SOCKET_ERROR)) {

//		fprintf (stderr, "IXP RIP Listener # %d: Packet received.\n", adptIdx);
		if (status>=sizeof (IPX_HEADER)) {
			packet.hdr.length = (USHORT)ntohs (packet.hdr.length);
			if (packet.hdr.length>status)
				packet.hdr.length = (USHORT)status;
			if (packet.hdr.length>=FIELD_OFFSET (IPX_SAP_PACKET, entry[0])) {
				if ((packet.hdr.pkttype==4)
						&& (ntohs(packet.operation)==2)) {
					if (FIELD_OFFSET(IPX_SAP_PACKET,entry[1])
								 					<= packet.hdr.length) {
						IPX_NETNUM_CPY (&netData.netnum, &packet.entry[0].addr.net);
						length = sizeof (netData);
						status = getsockopt (Sockets[adptIdx],
										NSPROTO_IPX,
										IPX_GETNETINFO,
										(PCHAR)&netData,
										&length);
						if (status==0) {
							Route.RR_InterfaceID = (1000+adptIdx);
							Route.RR_RoutingProtocol = 0;
							Route.RR_FamilySpecificData.FSD_Ticks =
												(USHORT)netData.netdelay;
							RtlRetrieveUlong (&Route.RR_Network.N_NetNumber,
																 netData.netnum);
							Route.RR_Network.N_NetNumber =
										 ntohl (Route.RR_Network.N_NetNumber);
							IPX_NODENUM_CPY (&Route.RR_NextHopAddress.NHA_Mac,
															 &netData.router);
							Route.RR_FamilySpecificData.FSD_HopCount = netData.hopcount;
							if (Route.RR_FamilySpecificData.FSD_HopCount<16)
								status = RtmAddRoute (hClient, &Route, 200, &flags, NULL, NULL);
							else
								status = RtmDeleteRoute (hClient, &Route, &flags, NULL);
							if (status!=0) {
								fprintf (stderr,
									"IPX RIP Listener # %d: %s failed with status %d\n",
									adptIdx,
									Route.RR_FamilySpecificData.FSD_HopCount<16 ? "AddRoute" : "DeleteRoute",
									status);
								}
							}
						else 
							fprintf (stderr,
								 "IPX RIP Listener # %d:"
								 " Can't get info about net # %02x%02x%02x%02x\n",
								 adptIdx,
								 netData.netnum[0],
								 netData.netnum[1],
								 netData.netnum[2],
								 netData.netnum[3]);

						}
					else
						fprintf (stderr,
								 "IPX RIP Listener # %d:"
								 " Invalid packet length %d.\n",
								 adptIdx,
								 packet.hdr.length);

					}
//				else
//					fprintf (stderr,
//						"IPX RIP Listener # %d:"
//						" Packet type %d, operation %d ignored.\n",
//						adptIdx,
//						packet.hdr.pkttype,
//						ntohs (packet.operation));
				}
			else
				fprintf (stderr, "IPX RIP Listener # %d: Short packet: %d\n",
								adptIdx,
								packet.hdr.length);
			}
		else
			fprintf (stderr, "IPX RIP Listener # %d: Invalid packet: %d\n",
								adptIdx,
								status);
//		Sleep (5*1000);
		}

	fprintf (stderr,
		 "IPX RIP Listener # %d: Terminating loop. Status: %d, err: %d\n",
		 adptIdx, status, GetLastError ());

	if (RtmDeregisterClient (hClient)!=NO_ERROR)
		fprintf (stderr, "Deregister client failed.\n");

	fprintf (stderr, "IXP RIP Listener # %d exited.\n", adptIdx);

	return 0;
#undef adptIdx
	}


#define idx ((LONG)param)
DWORD WINAPI
EnumThread (
	LPVOID param
	) {
	MSG				msg;
	HWND			EnumDlg;
	char			buf[16];
	
	Enums[idx] = NULL;

		// Create dialog window
	EnumDlg = CreateDialogParam (hDLLInstance,
				MAKEINTRESOURCE(IDD_ENUMERATION),
				NULL,
				&EnumDlgProc,
				(LPARAM)idx);
	ASSERTERR (EnumDlg!=NULL);

	sprintf (buf, "Enumerator # %d", idx+1);
	SetWindowText (EnumDlg, buf);

	while (GetMessage (&msg,  NULL, 0, 0)) {
		if (!IsWindow(EnumDlg)
			|| !IsDialogMessage(EnumDlg, &msg)) {
			TranslateMessage (&msg);
			DispatchMessage (&msg);
			}
		}

	if (IsWindow (EnumDlg)) {
		DestroyWindow (EnumDlg);
		EnumDlg = NULL;
		}

	if (Enums[idx]!=NULL) {
		if (Enums[idx]!=INVALID_HANDLE_VALUE) {
			if (RtmCloseEnumerationHandle (Enums[idx])!=NO_ERROR)
				MessageBox (NULL, "Close handle failed!", NULL, MB_OK|MB_ICONSTOP);
			}
		Enums[idx] = NULL;
		}

	return msg.wParam;
	}
#undef idx

BOOL CALLBACK
EnumDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL		res = FALSE;
	LONG		idx;
	RTM_ROUTE	Route;
	DWORD		ProtocolFamily;
	DWORD		flags;
	DWORD		status;
	RECT		rectDlg, rectScr;

	idx = GetWindowLong (hDlg, DWL_USER)-1;

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
			idx = lParam+1;
			SetWindowLong (hDlg, DWL_USER, idx);
			ASSERTERR (GetLastError ()==NO_ERROR);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CRITERIA_E), TRUE);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_BUTTONS_E), TRUE);
			EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E), FALSE);
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_E,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IPX,
							(LPARAM)"IPX"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_E,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IP,
							(LPARAM)"IP"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_E,
							CB_SETCURSEL,
							0,
							0
							);
			GetWindowRect (GetDlgItem (hDlg, IDE_NETWORK_E), &rectScr);
			MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
			rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
			rectDlg.right = 8*4+5;
			MapDialogRect (hDlg, &rectDlg);
			EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E), TRUE);
			MoveWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
						rectScr.left,
						rectScr.top,
						rectDlg.right,
						rectScr.bottom-rectScr.top,
						TRUE);

			EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_E),
						 IsDlgButtonChecked (hDlg, IDC_INTERFACE_E));
			EnableWindow (GetDlgItem (hDlg, IDE_PROTOCOL_E),
						 IsDlgButtonChecked (hDlg, IDC_PROTOCOL_E));
			EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
						 IsDlgButtonChecked (hDlg, IDC_NETWORK_E));

			EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E),
						 IsDlgButtonChecked (hDlg, IDC_NETWORK_E));

			SetDlgItemText (hDlg, IDB_CREATEDELETE_E, "Create Handle");
			SetDlgItemText (hDlg, IDB_GETFIRST_E, "Get First");
			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					PostQuitMessage (0);
					res = TRUE;
					break;
				case IDC_PROTOCOL_FAMILY_E:
					if (HIWORD(wParam)==CBN_SELENDOK) {
						ProtocolFamily = SendMessage (
												(HWND)lParam,
												CB_GETCURSEL,
												0, 0);
						GetWindowRect (GetDlgItem (hDlg, IDE_NETWORK_E), &rectScr);
						MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
						rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
						switch (ProtocolFamily) {
							case RTM_PROTOCOL_FAMILY_IPX:
								rectDlg.right = 8*4+5;
								break;
							case RTM_PROTOCOL_FAMILY_IP:
								rectDlg.right = 16*4+5;
								break;
							}
						MapDialogRect (hDlg, &rectDlg);
						EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E), TRUE);
						MoveWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
									rectScr.left,
									rectScr.top,
									rectDlg.right,
									rectScr.bottom-rectScr.top,
									TRUE);
						EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
									 IsDlgButtonChecked (hDlg, IDC_NETWORK_E));
						}
					break;

				case IDC_NETWORK_E:
					if (HIWORD(wParam)==BN_CLICKED)
						EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
                                        break;
				case IDC_INTERFACE_E:
				case IDC_PROTOCOL_E:
					if (HIWORD(wParam)==BN_CLICKED)
						EnableWindow (GetDlgItem (hDlg, LOWORD(wParam)+1),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					break;
					
				case IDB_CREATEDELETE_E:
					if (Enums[idx]==NULL) {
						GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
						Enums[idx] = RtmCreateEnumerationHandle (
												ProtocolFamily,
												flags,
												&Route);
						if (Enums[idx]!=NULL) {
							EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), FALSE);
							EnableWindow (GetDlgItem (hDlg, IDB_GETFIRST_E),
																		 FALSE);
							SetWindowText ((HWND)lParam, "Close Handle");
							EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E),
																		 TRUE);
							}
						else
							MessageBox (hDlg, "Create Handle failed!",
												 NULL, MB_OK|MB_ICONSTOP);
						}
					else {
						if (RtmCloseEnumerationHandle (Enums[idx])!=NO_ERROR)
							MessageBox (hDlg, "Close handle failed!",
												 NULL, MB_OK|MB_ICONSTOP);
						Enums[idx] = NULL;
						EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E), FALSE);
						SetWindowText ((HWND)lParam, "Create Handle");
						EnableWindow (GetDlgItem (hDlg, IDB_GETFIRST_E), TRUE);
						EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), TRUE);
						}
					res = TRUE;
					break;
				case IDB_GETFIRST_E:
					if (Enums[idx]==NULL) {
						GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
						status = RtmGetFirstRoute (
												ProtocolFamily,
												flags,
												&Route);
						if (status==NO_ERROR) {
							DisplayRoute (hDlg, ProtocolFamily, &Route);
							Enums[idx] = INVALID_HANDLE_VALUE;
							EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E), FALSE);
							EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), FALSE);
							EnableWindow (GetDlgItem (hDlg, IDB_CREATEDELETE_E),
																		 FALSE);
							SetWindowText ((HWND)lParam, "Stop Scan");
							EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E),
																		 TRUE);
							}
						else if (status==ERROR_NO_ROUTES)
							MessageBox (hDlg, "ERROR_NO_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
						else
							MessageBox (hDlg, "ERROR!",
												 NULL, MB_OK|MB_ICONSTOP);
						}
					else {
						Enums[idx] = NULL;
						EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E), FALSE);
						SetWindowText ((HWND)lParam, "Get First");
						EnableWindow (GetDlgItem (hDlg, IDB_CREATEDELETE_E), TRUE);
						EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), TRUE);
						EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E),
									IsDlgButtonChecked (hDlg, IDC_NETWORK_E));
						}
					res = TRUE;
					break;
				case IDB_GETNEXT_E:
					if (Enums[idx]==INVALID_HANDLE_VALUE) {
						GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
						GetLastRoute (hDlg, ProtocolFamily, &Route);
						status = RtmGetNextRoute (ProtocolFamily, flags, &Route);
						}
					else {
						status = RtmEnumerateGetNextRoute (Enums[idx], &Route);
						ProtocolFamily = SendDlgItemMessage (hDlg,
											IDC_PROTOCOL_FAMILY_E,
											CB_GETCURSEL, 0, 0);
						}
					if (status==NO_ERROR)
						DisplayRoute (hDlg, ProtocolFamily, &Route);
					else if (status==ERROR_NO_MORE_ROUTES)
						MessageBox (hDlg, "ERROR_NO_MORE_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
					else
						MessageBox (hDlg, "ERROR!",
												 NULL, MB_OK|MB_ICONSTOP);
							
					res = TRUE;
					break;
				case IDB_GETBEST_E:
					GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
					res = RtmIsRoute (ProtocolFamily, ((char *)&Route)+sizeof(RTM_XX_ROUTE), &Route);

					if (res)
						DisplayRoute (hDlg, ProtocolFamily, &Route);
					else
						MessageBox (hDlg, "NO_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
					res = TRUE;
					break;
				case IDB_GETAGE_E:
					ProtocolFamily = SendDlgItemMessage (hDlg,
											IDC_PROTOCOL_FAMILY_E,
											CB_GETCURSEL, 0, 0);
					GetLastRoute (hDlg, ProtocolFamily, &Route);
					status = RtmGetSpecificRoute (ProtocolFamily, &Route);

					if (status==NO_ERROR) {
						DisplayRoute (hDlg, ProtocolFamily, &Route);
						SetDlgItemInt (hDlg, IDL_AGESEC_E,
							 						RtmGetRouteAge (&Route), FALSE);
						}
					else
						MessageBox (hDlg, "NO_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
					res = TRUE;
					break;
				}
			break;
		case WM_DESTROY:
			if (Enums[idx]!=NULL) {
				if (Enums[idx]!=INVALID_HANDLE_VALUE) {
					if (RtmCloseEnumerationHandle (Enums[idx])!=NO_ERROR)
						MessageBox (hDlg, "Close handle failed!",
											 NULL, MB_OK|MB_ICONSTOP);
					}
				Enums[idx] = NULL;
				}
			break;
		}

	return res;
	}


VOID
GetCriteria (
	HWND		hDlg,
	DWORD		*ProtocolFamily,
	DWORD		*flags,
	PRTM_ROUTE	Route
	) {
	char						buf[32];
	char						*p;
	INT							val,i,n;
		
	*ProtocolFamily = SendDlgItemMessage (hDlg, IDC_PROTOCOL_FAMILY_E,
										CB_GETCURSEL, 0, 0);

	if (IsDlgButtonChecked (hDlg, IDC_BESTROUTES_E)) {
		*flags = RTM_ONLY_BEST_ROUTES;
		}
	else
		*flags = 0;

	if (IsDlgButtonChecked (hDlg, IDC_INTERFACE_E)) {
		*flags |= RTM_ONLY_THIS_INTERFACE;

		Route->XX_INTERFACE = GetDlgItemInt (hDlg,
									IDE_INTERFACE_E, NULL, FALSE);
		}
	if (IsDlgButtonChecked (hDlg, IDC_PROTOCOL_E)) {
		*flags |= RTM_ONLY_THIS_PROTOCOL;
		Route->XX.RR_RoutingProtocol = GetDlgItemInt (hDlg,
										IDE_PROTOCOL_E, NULL, FALSE);
		}
	if (IsDlgButtonChecked (hDlg, IDC_NETWORK_E)) {
		*flags |= RTM_ONLY_THIS_NETWORK;
		GetDlgItemText (hDlg, IDE_NETWORK_E, buf, sizeof (buf)-1);
		p = buf;
		switch (*ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route->IPX_NET_NUM = val;
				else
					Route->IPX_NET_NUM = 0;
    			p += n;
				sprintf (buf,
						"%08X",
						Route->IPX_NET_NUM);
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route->IP_NET_NUM = val;
				else
					Route->IP_NET_NUM = 0;
    			p += n;
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route->IP_NET_MSK = val;
				else
					Route->IP_NET_MSK = 0;
    			p += n;
				sprintf (buf,
						"%08X%08X",
						Route->IP_NET_NUM,
						Route->IP_NET_MSK);
				break;
			}
		SetDlgItemText (hDlg, IDE_NETWORK_E, buf);
		}
	}

VOID
GetLastRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	) {
	char		buf[128];
	char		*p;
	INT			i,n,val;


	GetDlgItemText (hDlg, IDL_ROUTE_E, buf, sizeof (buf)-1);
	p = buf;
	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IPX_NET_NUM = val;
			else
				Route->IPX_NET_NUM = 0;
			p += n;
			sscanf (p,
					" %d %d %n",
					&Route->XX_INTERFACE,
					&Route->XX_PROTOCOL,
					&n);
			p += n;
			for (i=0; i<sizeof(Route->IPX_NEXT_HOP_MAC); i++, p+=n) {
				if (sscanf (p, "%2X%n", &val, &n)==1)
					Route->IPX_NEXT_HOP_MAC[i] = (BYTE)val;
				else
					Route->IPX_NEXT_HOP_MAC[i] = 0;
				}
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NET_NUM = val;
			else
				Route->IP_NET_NUM = 0;
			p += n;
			sscanf (p, "-%n", &n);
			p += n;
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NET_MSK = val;
			else
				Route->IP_NET_MSK = 0;
			p += n;
			sscanf (p,
					" %d %d %n",
					&Route->XX_INTERFACE,
					&Route->XX_PROTOCOL,
					&n);
			p += n;

			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NEXT_HOP_NUM = val;
			else
				Route->IP_NEXT_HOP_NUM = 0;
			p += n;
			sscanf (p, "-%n", &n);
			p += n;
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NEXT_HOP_MSK = val;
			else
				Route->IP_NEXT_HOP_MSK = 0;
			p += n;

			break;
		}
	}

VOID
DisplayRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	) {
	char		buf[128];

	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			sprintf (buf,
					"     %08X    "
					" %4d %4d"
					"    %02X%02X%02X%02X%02X%02X  "
					" %4d",
					Route->IPX_NET_NUM,
					Route->XX_INTERFACE,
					Route->XX_PROTOCOL,
					Route->IPX_NEXT_HOP_MAC[0],
					Route->IPX_NEXT_HOP_MAC[1],
					Route->IPX_NEXT_HOP_MAC[2],
					Route->IPX_NEXT_HOP_MAC[3],
					Route->IPX_NEXT_HOP_MAC[4],
					Route->IPX_NEXT_HOP_MAC[5],
					Route->IPX_METRIC);
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			sprintf (buf,
					"%08X-%08X"
					" %4d %4d"
					" %08X-%08X"
					" %4d",
					Route->IP_NET_NUM,
					Route->IP_NET_MSK,
					Route->XX_INTERFACE,
					Route->XX_PROTOCOL,
					Route->IP_NEXT_HOP_NUM,
					Route->IP_NEXT_HOP_MSK,
					Route->IP_METRIC);

			break;
		}

	SetDlgItemText (hDlg, IDL_ROUTE_E, buf);
	sprintf (buf, "%08X", Route->XX_TIMESTAMP.dwHighDateTime);
	SetDlgItemText (hDlg, IDL_TIMEHIGH_E, buf);
	sprintf (buf, "%08X", Route->XX_TIMESTAMP.dwLowDateTime);
	SetDlgItemText (hDlg, IDL_TIMELOW_E, buf);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmp.h

Abstract:
	Provate Interface for Routing Table Manager DLL


Author:

	Vadim Eydelman

Revision History:

--*/

#if 0

#ifndef NT_INCLUDED
#include <nt.h>
#endif

#ifndef _NTRTL_
#include <ntrtl.h>
#endif

#ifndef _NTURTL_
#include <nturtl.h>
#endif

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifndef _WINBASE_
#include <winbase.h>
#endif

#ifndef _WINREG_
#include <winreg.h>
#endif

#ifndef _ROUTING_RTM_
#include "rtm.h"
#endif

#ifndef _ROUTING_RMRTM_
#include "rmrtm.h"
#endif

#endif


/*++
*******************************************************************
	S u p l e m e n t s  t o   R T M . H   S t r u c t u r e s

*******************************************************************
--*/
// Basic route info, present in routes of all types
typedef	struct {
		ROUTE_HEADER;
		} RTM_XX_ROUTE, *PRTM_XX_ROUTE;


#define XX_INTERFACE	RR_InterfaceID
#define XX_PROTOCOL		RR_RoutingProtocol
#define XX_METRIC		RR_Metric
#define XX_TIMESTAMP	RR_TimeStamp
#define XX_PSD			RR_ProtocolSpecificData



/*++
*******************************************************************
	S u p l e m e n t s  t o   N T R T L . H   S t r u c t u r e s

*******************************************************************
--*/
#define InitializeListEntry(entry) InitializeListHead(entry)
#define IsListEntry(entry)	(!IsListEmpty(entry))

#if DBG
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}
#else
#define ASSERTERR(exp)
#endif

#if DBG
#define ASSERTERRMSG(msg,exp) 									\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}
#else
#define ASSERTERRMSG(msg,exp)
#endif



/*++
*******************************************************************
	C o n f i g u r a t i o n   C o n s t a n t s 

*******************************************************************
--*/

// Size of interface index hash table
#define RTM_INTF_HASH_SIZE					31

// Maximum number of nodes in temp net number list that will
// triger an update (temp list is scaned when inserting the route)
#define RTM_TEMP_LIST_MAX_COUNT			16
// Maximum number of nodes in deleted list that will
// triger an update
#define RTM_DELETED_LIST_MAX_COUNT		16
// Maximum time between updates (if not triggered by the conditions above or
// client's query)
#define RTM_NET_NUMBER_UPDATE_PERIOD	{(ULONG)(-60*1000*10000), -1L}
// Maximum number of pednign notification change messages
// the queue. If this number is exceeded because some client(s) are
// not dequeueing them, oldest message will be purged
#define RTM_MAX_ROUTE_CHANGE_MESSAGES	10000




/*++
*******************************************************************
	D a t a   T y p e s 

*******************************************************************
--*/


// Types of nodes that can exist in the table
#define RTM_ENUMERATOR_FLAG				0x00000001

#define RTM_BEST_NODE_FLAG				0x00000002
#define RTM_ENABLED_NODE_FLAG			0x00000004
#define RTM_ANY_ENABLE_STATE			((DWORD)(~RTM_ENABLED_NODE_FLAG))
#define RTM_SORTED_NODE_FLAG			0x00000008

#define IsEnumerator(node) (node->RN_Flags&RTM_ENUMERATOR_FLAG)

#define IsBest(node) (node->RN_Flags&RTM_BEST_NODE_FLAG)
#define SetBest(node) node->RN_Flags|=RTM_BEST_NODE_FLAG
#define ResetBest(node) node->RN_Flags&=(~RTM_BEST_NODE_FLAG)

#define IsEnabled(node) (node->RN_Flags&RTM_ENABLED_NODE_FLAG)
#define IsSameEnableState(node,EnableFlag) \
			((node->RN_Flags&RTM_ENABLED_NODE_FLAG)==EnableFlag)
#define SetEnable(node,enable) 								\
		node->RN_Flags = enable								\
				? (node->RN_Flags|RTM_ENABLED_NODE_FLAG)	\
				: (node->RN_Flags&(~RTM_ENABLED_NODE_FLAG))

#define IsSorted(node) (node->RN_Flags&RTM_SORTED_NODE_FLAG)
#define SetSorted(node) node->RN_Flags|=RTM_SORTED_NODE_FLAG

#define RTM_NODE_FLAGS_INIT			RTM_ENABLED_NODE_FLAG
#define RTM_ENUMERATOR_FLAGS_INIT 	RTM_ENUMERATOR_FLAG
// Each node will have the following links:

	// Hash table link (routes in each basket are ordered by
	// net number.interface.protocol.next_hop_address)
#define RTM_NET_NUMBER_HASH_LINK		0

	// Deleted list link: used if entry cannot be deleted
	// immediately because net number list is locked by the
	// update thread. It is same as hash table link
	// because one must first delete entry form the hash table
	// before adding it to deleted list (there is no ordering
	// in this list)
#define RTM_DELETED_LIST_LINK			RTM_NET_NUMBER_HASH_LINK

#if RTM_USE_PROTOCOL_LISTS
	// Link in the list of routes associated with a particular routing protocol
	// (routes are grouped (not oredered) by the net number and
	// ordered by protocol.next_hop_address inside of net number group
#define RTM_PROTOCOL_LIST_LINK			(RTM_NET_NUMBER_HASH_LINK+1)
	// Link in the list of routes associated with a particular interface
	// (routes are grouped (not oredered) by the net number and
	// ordered by interface.next_hop_address inside of net number group
#define RTM_INTERFACE_LIST_LINK			(RTM_PROTOCOL_LIST_LINK+1)
#else
#define RTM_INTERFACE_LIST_LINK			(RTM_NET_NUMBER_HASH_LINK+1)
#endif

	// Link in the list ordered by net number.interface.protocol.next_hop_address
	// There are two of these list. New routes are normaly inserted
	// in temporary list that is periodically merged with master list
#define RTM_NET_NUMBER_LIST_LINK		(RTM_INTERFACE_LIST_LINK+1)

	// Link in list ordered by expiration time
#define RTM_EXPIRATION_QUEUE_LINK		(RTM_NET_NUMBER_LIST_LINK+1)

	// Total number of links for each node
#define RTM_NUM_OF_LINKS				(RTM_EXPIRATION_QUEUE_LINK+1)

	// Client count treshold that prevents client from entering RTM
	// API's until table is initialized
#define RTM_CLIENT_STOP_TRESHHOLD		(-10000)


// Event with link to store it in the stack
typedef struct _RTM_SYNC_OBJECT {
	HANDLE				RSO_Event;
	SINGLE_LIST_ENTRY	RSO_Link;
	} RTM_SYNC_OBJECT, *PRTM_SYNC_OBJECT;

// Doubly linked list protected by the event that is
// assigned to the list on demand (when somebody is trying
// to access the list that is already in use)
typedef struct _RTM_SYNC_LIST {
	PRTM_SYNC_OBJECT	RSL_Sync;		// Assigned event
	LONG				RSL_UseCount;	// Number of user accessing or waiting
	LIST_ENTRY			RSL_Head;		// List itself (head)
	} RTM_SYNC_LIST, *PRTM_SYNC_LIST;


#if RTM_PROTOCOL_LIST_LINK
/* ****** Protocol lists no longer used ****** */
// Node of list of protocol lists
typedef struct _RTM_PROTOCOL_NODE {
		LIST_ENTRY			PN_Link;	// Link in list of protocol lists
		LIST_ENTRY			PN_Head;	// List of routes associated with
										// a protocol
		DWORD				PN_RoutingProtocol; // Routing Protocol number
		} RTM_PROTOCOL_NODE, *PRTM_PROTOCOL_NODE;
#endif

// Node of list of interface lists
typedef struct _RTM_INTERFACE_NODE {
		LIST_ENTRY			IN_Link;	// Link in list of interface lists
		LIST_ENTRY			IN_Head;	// List of routes associated with
										// an interface
		DWORD				IN_InterfaceID; // Interface handle
		} RTM_INTERFACE_NODE, *PRTM_INTERFACE_NODE;


// Node of Routing Table
typedef struct _RTM_ROUTE_NODE {
	LIST_ENTRY		RN_Links[RTM_NUM_OF_LINKS];	// Links in all lists
	DWORD			RN_Flags;
	PRTM_SYNC_LIST	RN_Hash;			// Hash bucket this entry belongs to
	DWORD			RN_ExpirationTime; 	// System (Windows) Time in msec
	RTM_XX_ROUTE	RN_Route;			// Route entry
	} RTM_ROUTE_NODE, *PRTM_ROUTE_NODE;

// Node used to enumerate through any of the lists
typedef struct _RTM_ENUMERATOR {
	LIST_ENTRY		RE_Links[RTM_NUM_OF_LINKS]; // header is same as in
	DWORD			RE_Flags;			// RTM_ROUTE_NODE
	INT				RE_Link;			// Which link is used for enumeration
	PLIST_ENTRY		RE_Head;			// Head of list through which we are
										// enumerting
	PRTM_SYNC_LIST	RE_Lock;			// Syncronization object protecting
										// the this list
	PRTM_SYNC_LIST	RE_Hash;			// Hash bucket this entry belongs to
	DWORD			RE_ProtocolFamily;	// Table in which we are enumerating
	DWORD			RE_EnumerationFlags; // Which types of entries to limit
										// enumeration to
	RTM_XX_ROUTE	RE_Route;			// Criteria
	} RTM_ENUMERATOR, *PRTM_ENUMERATOR;

// Node in route change message list
typedef struct _RTM_ROUTE_CHANGE_NODE {
	LIST_ENTRY			RCN_Link;				// Link in the list
	HANDLE				RCN_ResponsibleClient; // Client that caused this change
											// or null if route was aged out
	ULONG				RCN_ReferenceCount; // Initialized with total number
				// of registered clients and decremented as messages are reported to
				// each client until all clients are informed at which point the node
				// can be deleted
	DWORD				RCN_Flags;
	PRTM_ROUTE_NODE		RCN_Route2;
	RTM_XX_ROUTE		RCN_Route1;
	} RTM_ROUTE_CHANGE_NODE, *PRTM_ROUTE_CHANGE_NODE;


#define RTM_NODE_BASE_SIZE 										\
	(FIELD_OFFSET(RTM_ROUTE_NODE,RN_Route)						\
			>FIELD_OFFSET(RTM_ROUTE_CHANGE_NODE,RCN_Route1))	\
		? FIELD_OFFSET(RTM_ROUTE_NODE,RN_Route)					\
		: FIELD_OFFSET(RTM_ROUTE_CHANGE_NODE,RCN_Route1)


// Routing Manager Table
typedef struct _RTM_TABLE {
	HANDLE				RT_Heap;			// Heap to allocate nodes from
	LONG				RT_APIclientCount;	// Count of clients that are
											// inside of RTM API calls
	HANDLE				RT_ExpirationTimer;	// Nt timer handle
	HANDLE				RT_UpdateTimer;		// Nt timer handle
	DWORD				RT_NumOfMessages;	// Number of notification
											// messages in the queue
	ULONG				RT_NetworkCount;	// Total number of networks
											// to which we have routes
	DWORD				RT_NetNumberTempCount; // How many entries are in
											// net number temp list
	DWORD				RT_DeletedNodesCount; // How many entries are in
											// deleted list
	LONG				RT_UpdateWorkerPending;	// Sorted list update is
											// being performed or scheduled
											// if >=0
	LONG				RT_ExpirationWorkerPending;	// Expiration queue check is
											// being performed or scheduled 
											// if >=0
	SINGLE_LIST_ENTRY	RT_SyncObjectList;	// Stack of events that can be
											// used for synchronization
#if RTM_PROTOCOL_LIST_LINK
/* ****** Protocol lists no longer used ****** */
	RTM_SYNC_LIST		RT_ProtocolList;	// List of protocol lists
#endif
	RTM_SYNC_LIST		RT_NetNumberMasterList; // Master net number list
	RTM_SYNC_LIST		RT_NetNumberTempList; // Temp net number list
	RTM_SYNC_LIST		RT_DeletedList;		// List of deleted routes
	RTM_SYNC_LIST		RT_ExpirationQueue;	// Expiration queue
	RTM_SYNC_LIST		RT_RouteChangeQueue;// List of route change messages
	RTM_SYNC_LIST		RT_ClientList;		// List of registered clients
	PRTM_SYNC_LIST		RT_NetNumberHash; 	// Hash table
	PRTM_SYNC_LIST		RT_InterfaceHash;	// Hash table of interface lists
	RTM_PROTOCOL_FAMILY_CONFIG	RT_Config;			// Configuration params
	CRITICAL_SECTION	RT_Lock;			// Table-wide lock
	} RTM_TABLE, *PRTM_TABLE;

// Structure associated with each client
typedef struct _RTM_CLIENT {
	LIST_ENTRY				RC_Link;		// Link in client list
	DWORD					RC_ProtocolFamily;
	DWORD					RC_RoutingProtocol;
	DWORD					RC_Flags;
	HANDLE					RC_NotificationEvent;	// Event through which client
								// is notified about route change
	PLIST_ENTRY				RC_PendingMessage;	// Pointer to first message in 
								// the route change queue that was not reported
								// to the client
	} RTM_CLIENT, *PRTM_CLIENT;

#define RT_RouteSize 		RT_Config.RPFC_RouteSize
#define RT_HashTableSize	RT_Config.RPFC_HashSize
#define NNM(Route) 			(((char *)Route)+sizeof (RTM_XX_ROUTE))

#define NetNumCmp(Table,Route1,Route2)	\
			(*Table->RT_Config.RPFC_NNcmp)(NNM(Route1),NNM(Route2))
#define NextHopCmp(Table,Route1,Route2)	\
			(*Table->RT_Config.RPFC_NHAcmp)(Route1,Route2)
#define FSDCmp(Table,Route1,Route2)	\
			(*Table->RT_Config.RPFC_FSDcmp)(Route1,Route2)
#define ValidateRoute(Table,Route) \
			(*Table->RT_Config.RPFC_Validate)(Route)
#define MetricCmp(Table,Route1,Route2) \
			(*Table->RT_Config.RPFC_RMcmp)(Route1,Route2)

#define EnterTableAPI(Table)										\
	((InterlockedIncrement(&(Table)->RT_APIclientCount)>0)			\
		? TRUE														\
		: (InterlockedDecrement (&(Table)->RT_APIclientCount), FALSE))

#define ExitTableAPI(Table)	\
	InterlockedDecrement(&(Table)->RT_APIclientCount)

/*++
*******************************************************************
	I n t e r n a l   F u n c t i o n   P r o t o t y p e s 

*******************************************************************
--*/

// Initializes sync list object
VOID
InitializeSyncList (
	PRTM_SYNC_LIST	list
	);

#if DBG
#define EnterSyncList(table,list,wait) DoEnterSyncList(table,list,wait,__FILE__,__LINE__)
#else
#define EnterSyncList(table,list,wait) DoEnterSyncList(table,list,wait)
#endif

// Get mutually exclusive access to the sync list obect
// Returns TRUE if access if obtained, FALSE otherwise
BOOLEAN
DoEnterSyncList (
	PRTM_TABLE		table,
	PRTM_SYNC_LIST	list,
	BOOLEAN			wait
#if DBG
    , LPSTR         file,
    ULONG           line
#endif
	);


// Release previously owned sync list object
VOID
LeaveSyncList (
	PRTM_TABLE		table,
	PRTM_SYNC_LIST	list
	);



#define HashFunction(Table,Net)	\
			(*Table->RT_Config.RPFC_Hash)(Net)

#define IntfHashFunction(Table,InterfaceID) \
			(InterfaceID%RTM_INTF_HASH_SIZE)

// Finds list of routes that are associated with given interface and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindInterfaceList (
	PRTM_SYNC_LIST	intfHash,
	DWORD			Interface,
	BOOL			CreateNew
	);

// Finds list of routes that are associated with given iprotocol and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindProtocolList (
	PRTM_TABLE	Table,
	DWORD		RoutingProtocol,
	BOOL		CreateNew
	);

// Adds node to temporary net number list (to be later merged with master list)
// Both lists are ordered by net number.interface.protocol.next hop address
VOID
AddNetNumberListNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	);

// Adds node to expiration time queue.  (Queue is ordered by expiration time)
// Return TRUE if new node is the first in the queue
BOOL
AddExpirationQueueNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	);

#define MAXTICKS	MAXULONG
#define IsLater(Time1,Time2)	\
			(Time1-Time2<MAXTICKS/2)
#define TimeDiff(Time1,Time2)	\
			(Time1-Time2)
#define IsPositiveTimeDiff(TimeDiff) \
			(TimeDiff<MAXTICKS/2)

#if DBG
	// Include debugging function prototypes
#ifndef _RTMDLG_
#include "rtmdlg.h"
#endif

#include <rtutils.h>
#include "rtmdbg.h"

#endif

typedef struct _MASK_ENTRY
{
    DWORD   dwMask;
    DWORD   dwCount;
    
} MASK_ENTRY, *PMASK_ENTRY;


//
// for IPv4 addresses
//

#define MAX_MASKS       32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmdlg.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmdlg.c

Abstract:
	Routing Table Manager DLL. Debugging code to display table entries
	in dialog box. External prototypes


Author:

	Vadim Eydelman

Revision History:

--*/
#ifndef _RTMDLG_
#define _RTMDLG_

#include <windows.h>
#include <stdio.h>
#include "rtdlg.h"

#define	DbgLevelValueName TEXT("DbgLevel")
#define	TicksWrapAroundValueName TEXT("TicksWrapAround")
#define	MaxMessagesValueName TEXT("MaxMessages")


#define RT_ADDROUTE		(WM_USER+10)
#define RT_UPDATEROUTE	(WM_USER+11)
#define RT_DELETEROUTE	(WM_USER+12)

// Debug flags
#define DEBUG_DISPLAY_TABLE			0x00000001
#define DEBUG_SYNCHRONIZATION		0x00000002

extern DWORD		DbgLevel;
#define IF_DEBUG(flag) if (DbgLevel & DEBUG_ ## flag)


// Make it setable to be able to test time wraparound
extern ULONG	MaxTicks;
#undef MAXTICKS
#define MAXTICKS	MaxTicks
#define GetTickCount() (GetTickCount()&MaxTicks)
#undef IsLater
#define IsLater(Time1,Time2)	\
			(((Time1-Time2)&MaxTicks)<MaxTicks/2)
#undef TimeDiff
#define TimeDiff(Time1,Time2)	\
			((Time1-Time2)&MaxTicks)
#undef IsPositiveTimeDiff
#define IsPositiveTimeDiff(TimeDiff) \
			(TimeDiff<MaxTicks/2)


extern DWORD MaxMessages;
#undef RTM_MAX_ROUTE_CHANGE_MESSAGES
#define RTM_MAX_ROUTE_CHANGE_MESSAGES MaxMessages


// Routing Table Dialog Thread
extern HANDLE		RTDlgThreadHdl;
extern HWND			RTDlg;

DWORD WINAPI
RTDialogThread (
	LPVOID	param
	);
	    
VOID
AddRouteToLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node,
	INT					idx
	);

VOID
DeleteRouteFromLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmdbg.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmdbg.h

Abstract:
    Debugging in Routing Table Manager DLL

--*/

#ifndef __ROUTING_RTMDBG_H__
#define __ROUTING_RTMDBG_H__

//
// Constants used for tracing
//

#define RTM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define RTM_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define RTM_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define RTM_TRACE_LEAVE           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define RTM_TRACE_LOCK            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define RTM_TRACE_REFS            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define RTM_TRACE_HANDLE          ((DWORD)0x00200000 | TRACE_USE_MASK)
#define RTM_TRACE_MEMORY          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define RTM_TRACE_START           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define RTM_TRACE_STOP            ((DWORD)0x01000000 | TRACE_USE_MASK)
#define RTM_TRACE_REGNS           ((DWORD)0x02000000 | TRACE_USE_MASK)
#define RTM_TRACE_ROUTE           ((DWORD)0x04000000 | TRACE_USE_MASK)
#define RTM_TRACE_QUERY           ((DWORD)0x08000000 | TRACE_USE_MASK)
#define RTM_TRACE_ENUM            ((DWORD)0x10000000 | TRACE_USE_MASK)
#define RTM_TRACE_NOTIFY          ((DWORD)0x20000000 | TRACE_USE_MASK)
#define RTM_TRACE_TIMER           ((DWORD)0x40080000 | TRACE_USE_MASK)
#define RTM_TRACE_CALLBACK        ((DWORD)0x80000000 | TRACE_USE_MASK)

//
// Macros used for tracing 
//

extern  DWORD               TracingInited;

extern  ULONG               TracingHandle;

#define TRACEHANDLE         TracingHandle

#define START_TRACING()                                             \
            if (InterlockedExchange(&TracingInited, TRUE) == FALSE) \
            {                                                       \
                TRACEHANDLE = TraceRegister("RTMv1");               \
            }                                                       \
            
#define STOP_TRACING()      TraceDeregister(TRACEHANDLE)

#define Trace0(l,a)             \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f, g)

#define Tracedump(l,a,b,c)      \
            TraceDumpEx(TRACEHANDLE,l,a,b,c,TRUE)

#if DBG_CAL

#define TraceEnter(X)    Trace0(ENTER, "Entered: "X)
#define TraceLeave(X)    Trace0(LEAVE, "Leaving: "X"\n")

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif

//
// Constants used in logging
//

#define RTM_LOGGING_NONE      0
#define RTM_LOGGING_ERROR     1
#define RTM_LOGGING_WARN      2
#define RTM_LOGGING_INFO      3

//
// Event logging macros
//

extern  HANDLE          LoggingHandle;
extern  ULONG           LoggingLevel;

#define LOGHANDLE       LoggingHandle
#define LOGLEVEL        LoggingLevel
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData

//
// Error logging
//

#define START_LOGGING()     LOGHANDLE = RouterLogRegister("RTMv1")

#define STOP_LOGGING()      RouterLogDeregister(LOGHANDLE)

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

//
// Misc Debugging Macros
//

#define IPADDR_FORMAT(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define TracePrintAddress(ID, Dest, Mask)                   \
{                                                           \
    Trace2(ID, "Dest: %d.%d.%d.%d Mask: %d.%d.%d.%d",       \
           IPADDR_FORMAT(Dest),                             \
           IPADDR_FORMAT(Mask));                            \
}

#endif //__ROUTING_RTMDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtm\rtmv1rtm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: rtmv1rtm.h
//
// History:
//      Chaitk	Feb-13-1999  Created.
//
// Private interface between RTMv1 and RTMv2
//============================================================================


#ifndef _ROUTING_RTMv1RTM_
#define _ROUTING_RTMv1RTM_

BOOL
Rtmv1DllStartup(
    HINSTANCE   hinstDLL  // DLL instance handle
);


VOID
Rtmv1DllCleanup(
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\lkuptst.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lkuptst.h

Abstract:
    Contains routines for testing an implementation
    for the generalized best matching prefix lookup 
    interface.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

#ifndef __LKUPTST_H
#define __LKUPTST_H

#include "lookup.h"

// Constants
#define MAX_FNAME_LEN               255

#define MAX_LINE_LEN                255

#define BITSINBYTE                  8

#define ADDRSIZE                    32

#define NUMBYTES                    4

#define MAXLEVEL                    32

#define MAXROUTES                   64000

#define ERROR_IPLMISC_BASE          -100

#define ERROR_WRONG_CMDUSAGE        ERROR_IPLMISC_BASE - 1
#define ERROR_OPENING_DATABASE      ERROR_IPLMISC_BASE - 2
#define ERROR_MAX_NUM_ROUTES        ERROR_IPLMISC_BASE - 3

// Macros
#define FHalf(B)        (B) >> 4
#define BHalf(B)        (B) & 0xF

#define Print           printf

#define Assert(S)       assert(S)

#define SUCCESS(S)      (S == NO_ERROR)

#define Error(S, E)     { \
                            fprintf(stderr, S, E); \
                        }

#define Fatal(S, E)     { \
                            fprintf(stderr, S, E); \
                            exit(E); \
                        }

#define ClearMemory(pm, nb) memset((pm), 0, (nb))

#if PROF

#define    PROFVARS     LARGE_INTEGER PCStart; /* PerformanceCountStart */ \
                        LARGE_INTEGER PCStop;  /* PerformanceCountStop  */ \
                        LARGE_INTEGER PCFreq;  /* PerformanceCountFreq  */ \
                        double        timer;                               \
                        double        duration;                            \
                                                                           \
                        QueryPerformanceFrequency(&PCFreq);                \
                        // Print("Perf Counter Resolution = %.3f ns\n\n",  \
                        //     (double) 1000 * 1000 * 1000 / PCFreq.QuadPart);

#define    STARTPROF    QueryPerformanceCounter(&PCStart);

#define    STOPPROF     QueryPerformanceCounter(&PCStop);

#define    INITPROF     duration = 0;


#define    ADDPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration += timer;                                   \
                        // Print("Add : %.3f ns\n\n", timer);


#define    SUBPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration -= timer;                                   \
                        // Print("Sub : %.3f ns\n\n", timer);

#define    PRINTPROF    // Print("Total Time Taken To Finish : %.3f ns\n",   \
                        //          duration);

#endif // if PROF

// Route Structures

typedef ULONG   IPAddr;
typedef ULONG   IPMask;

// A Route Corr. to a Prefix
typedef struct _Route Route;

struct _Route
{
  IPAddr         addr;       // ULONG (32 bits) representing addr
  IPMask         mask;       // ULONG (32 bits) representing mask
  IPAddr         nexthop;    // ULONG (32 bits) for next hop addr
  USHORT         len;        // Num of bits in the address route
  UINT           metric;     // A measure to compare routes with
  PVOID          interface;  // Interface on which packet is sent
  LOOKUP_LINKAGE backptr;    // Points back to the lookup structure
};

// Route Macros

#define  DEST(_pRoute_)        ((_pRoute_)->addr)
#define  MASK(_pRoute_)        ((_pRoute_)->mask)
#define  NHOP(_pRoute_)        ((_pRoute_)->nexthop)
#define  LEN(_pRoute_)         ((_pRoute_)->len)
#define  METRIC(_pRoute_)      ((_pRoute_)->metric)
#define  IF(_pRoute_)          ((_pRoute_)->interface)

#define  NULL_ROUTE(_pRoute_)  (_pRoute_ == NULL)

// Prototypes

DWORD 
WorkOnLookup (
    IN      Route                          *InputRoutes,
    IN      UINT                            NumRoutes
    );

VOID 
ReadAddrAndGetRoute (
    IN      PVOID                           Table
    );

VOID 
EnumerateAllRoutes (
    IN      PVOID                           Table
    );

UINT ReadRoutesFromFile(
    IN      FILE                           *FilePtr,
    IN      UINT                            NumRoutes,
    OUT     Route                          *RouteTable
    );

INT 
ReadRoute (
    IN      FILE                           *FilePtr,
    OUT     Route                          *route 
    );

VOID 
PrintRoute (
    IN      Route                          *route
    );

INT 
ReadIPAddr (
    IN      FILE                           *FilePtr,
    OUT     ULONG                          *addr
    );

VOID 
PrintIPAddr (
    IN      ULONG                          *addr
    );

VOID 
Usage (
    VOID
    );

#endif // __LKUPTST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\avltrie.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    avltrie.h

Abstract:

    Contains interface for a best matching
    prefix lookup using an AVL trie.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_AVLLOOKUP_H__
#define __ROUTING_AVLLOOKUP_H__

#include "lookup.h"

#define Print                    printf

#define BITS_IN_BYTE           (UINT) 8

//
// Balance factor at an AVL node
//

#define LEFT                        -1
#define EVEN                         0
#define RIGHT                       +1
#define INVALID                    100

typedef INT AVL_BALANCE, *PAVL_BALANCE;

//
// A node in the AVL trie
//
typedef struct _AVL_NODE *PAVL_NODE;

// Disable warnings for unnamed structs
#pragma warning(disable : 4201)  

typedef struct _AVL_NODE
{
    PAVL_NODE         Prefix;           // Node with the next best prefix

    PAVL_NODE         Parent;           // Parent of this AVL trie node

    struct
    {
        PAVL_NODE     LChild;
        union
        {
            PAVL_NODE Child[1];         // Child[-1] = Left, Child[1] = Right

            PVOID     Data;             // Opaque Pointer to data in the node
        };
        PAVL_NODE     RChild;
    };

    AVL_BALANCE       Balance;          // Balance factor at this node

    USHORT            NumBits;          // Actual number of bits in key
    UCHAR             KeyBits[1];       // Value of key bits to compare
}
AVL_NODE;

#pragma warning(default : 4201)  


//
// AVL trie with prefix matching
//
typedef struct _AVL_TRIE
{
    PAVL_NODE         TrieRoot;         // Pointer to the AVL trie
    
    UINT              MaxKeyBytes;      // Max num of bytes in key

    UINT              NumNodes;         // Number of nodes in trie

#if PROF

    ULONG             MemoryInUse;      // Total memory in use now
    UINT              NumAllocs;        // Num of total allocations
    UINT              NumFrees;         // Num of total free allocs

    UINT              NumInsertions;    // Num of total insertions
    UINT              NumDeletions;     // Num of total deletions
    UINT              NumSingleRots;    // Num of single rotations
    UINT              NumDoubleRots;    // Num of double rotations

#endif
}
AVL_TRIE, *PAVL_TRIE;

//
// Lookup context for an AVL trie
//
typedef struct _AVL_CONTEXT
{
    PVOID             BestNode;         // Node with best the matching prefix
    PVOID             InsPoint;         // Node to which new node is attached
    AVL_BALANCE       InsChild;         // Node should attached as this child
}
AVL_CONTEXT, *PAVL_CONTEXT;


//
// Linkage Info Kept in Data
//
typedef struct _AVL_LINKAGE
{
    PAVL_NODE         NodePtr;          // Back pointer to the owning node
}
AVL_LINKAGE, *PAVL_LINKAGE;


#define SET_NODEPTR_INTO_DATA(Data, Node) ((PAVL_LINKAGE)Data)->NodePtr = Node

#define GET_NODEPTR_FROM_DATA(Data)       ((PAVL_LINKAGE)Data)->NodePtr

//
// Key Compare/Copy inlines
//

INT
__inline
CompareFullKeys(
    IN       PUCHAR                          Key1,
    IN       PUCHAR                          Key2,
    IN       UINT                            NumBytes
    )
{
    UINT  Count;

#if _OPT_
    ULONG Temp1;
    ULONG Temp2;

    if (NumBytes == sizeof(ULONG))
    {
        Temp1 = RtlUlongByteSwap(*(ULONG *)Key1);
        Temp2 = RtlUlongByteSwap(*(ULONG *)Key2);

        if (Temp1 > Temp2)
        {
            return +1;
        }

        if (Temp1 < Temp2)
        {
            return -1;
        }

        return 0;
    }
#endif

    Count = NumBytes;

    if (!Count)
    {
        return 0;
    }

    Count--;

    while (Count && (*Key1 == *Key2))
    {
        Key1++;
        Key2++;

        Count--;
    }

    return *Key1 - *Key2;
}

INT
__inline
ComparePartialKeys(
    IN       PUCHAR                          Key1,
    IN       PUCHAR                          Key2,
    IN       USHORT                          NumBits
    )
{
    UINT  Count;

#if _OPT_
    ULONG Temp1;
    ULONG Temp2;

    if (NumBits <= sizeof(ULONG) * BITS_IN_BYTE)
    {
        Count = sizeof(ULONG) * BITS_IN_BYTE - NumBits;
        
        Temp1 = RtlUlongByteSwap(*(ULONG *)Key1) >> Count;
        Temp2 = RtlUlongByteSwap(*(ULONG *)Key2) >> Count;

        if (Temp1 > Temp2)
        {
            return +1;
        }

        if (Temp1 < Temp2)
        {
            return -1;
        }

        return 0;
    }
#endif

    Count = NumBits / BITS_IN_BYTE;

    while (Count && *Key1 == *Key2)
    {
        Key1++;
        Key2++;

        Count--;
    }
  
    if (Count)
    {
        return (*Key1 - *Key2);
    }

    Count = NumBits % BITS_IN_BYTE;

    if (Count)
    {
        Count = BITS_IN_BYTE - Count;

        return (*Key1 >> Count) - (*Key2 >> Count);
    }

    return 0;
}

VOID
__inline
CopyFullKeys(
    OUT      PUCHAR                          KeyDst,
    IN       PUCHAR                          KeySrc,
    IN       UINT                            NumBytes
    )
{
    UINT Count = NumBytes;
  
    while (Count--)
    {
        *KeyDst++ = *KeySrc++;
    }

    return;
}

VOID
__inline
CopyPartialKeys(
    OUT      PUCHAR                          KeyDst,
    IN       PUCHAR                          KeySrc,
    IN       USHORT                          NumBits
    )
{
    UINT Count = (NumBits + BITS_IN_BYTE - 1) / BITS_IN_BYTE;
  
    while (Count--)
    {
        *KeyDst++ = *KeySrc++;
    }

    return;
}

//
// Node Creation and Deletion inlines
//

PAVL_NODE
__inline
CreateTrieNode(
    IN       PAVL_TRIE                       Trie,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PAVL_NODE                       Prefix,
    IN       PLOOKUP_LINKAGE                 Data
    )
{
    PAVL_NODE NewNode;
    UINT      NumBytes;

    NumBytes = FIELD_OFFSET(AVL_NODE, KeyBits) + Trie->MaxKeyBytes;

    NewNode = AllocNZeroMemory(NumBytes);
    if (NewNode)
    {
        NewNode->Prefix = Prefix;

        NewNode->Data = Data;

        SET_NODEPTR_INTO_DATA(Data, NewNode);

        NewNode->Balance = EVEN;

        NewNode->NumBits = NumBits;
        CopyPartialKeys(NewNode->KeyBits,
                        KeyBits, 
                        NumBits);

        Trie->NumNodes++;

#if PROF
        Trie->NumAllocs++;
        Trie->MemoryInUse += NumBytes;
#endif
    }

    return NewNode;
}

VOID
__inline
DestroyTrieNode(
    IN       PAVL_TRIE                       Trie,
    IN       PAVL_NODE                       Node
    )
{
    UINT NumBytes;

    SET_NODEPTR_INTO_DATA(Node->Data, NULL);

    NumBytes = FIELD_OFFSET(AVL_NODE, KeyBits) + Trie->MaxKeyBytes;

    Trie->NumNodes--;

#if PROF
    Trie->NumFrees++;
    Trie->MemoryInUse -= NumBytes;
#endif
    
    FreeMemory(Node);
}

//
// Helper Prototypes
//

VOID
BalanceAfterInsert(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Longer
    );

VOID
BalanceAfterDelete(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Shorter
    );

VOID
SingleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
    );

VOID
DoubleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
    );

VOID
SwapWithSuccessor(
    IN       PAVL_TRIE                        Trie,
    IN OUT   PAVL_CONTEXT                     Context
    );

VOID
AdjustPrefixes(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        OldNode,
    IN       PAVL_NODE                        NewNode,
    IN       PAVL_NODE                        TheNode,
    IN       PLOOKUP_CONTEXT                  Context
    );

DWORD
CheckSubTrie(
    IN       PAVL_NODE                        Node,
    OUT      PUSHORT                          Depth
    );

DWORD
CheckTrieNode(
    IN       PAVL_NODE                        Node,
    IN       USHORT                           LDepth,
    IN       USHORT                           RDepth
    );

VOID
DumpSubTrie(
    IN       PAVL_NODE                        Node
    );

VOID
DumpTrieNode(
    IN       PAVL_NODE                        Node
    );

#endif //__ROUTING_AVLLOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\apitest.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    apitest.c

Abstract:
    Contains routines for testing the RTMv2 API.

Author:
    Chaitanya Kodeboyina (chaitk) 26-Jun-1998

Revision History:

--*/

#include "apitest.h"

MY_ENTITY_EXPORT_METHODS
Rip2Methods =
{
    5,

    {
        EntityExportMethod,
        EntityExportMethod,
        NULL,
        EntityExportMethod,
        EntityExportMethod
    }
};

MY_ENTITY_EXPORT_METHODS
OspfMethods =
{
    6,

    {
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod
    }
};

MY_ENTITY_EXPORT_METHODS
Bgp4Methods =
{
    4,

    {
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod
    }
};


ENTITY_CHARS
GlobalEntityChars [] =
{
//
//  {
//    Rtmv2Registration,
//    { RtmInstanceId, AddressFamily, { EntityProtocolId, EntityInstanceId } },
//    EntityEventCallback,    ExportMethods,
//    RoutesFileName,
//  }
//
/*
    {
        FALSE,
        { 0, RTM_PROTOCOL_FAMILY_IP, { PROTO_IP_RIP, 1   } },
        EntityEventCallback, &Rip2Methods,
        "test.out"
    },
*/
    {
        TRUE,
        { 1, AF_INET, { PROTO_IP_RIP, 1   } },
        EntityEventCallback, &Rip2Methods,
        "test.out"
    },

    {
        TRUE,
        { 1, AF_INET, { PROTO_IP_OSPF, 1  } },
        EntityEventCallback, &OspfMethods,
        "test.out"
    },

    {
        TRUE,
        { 1, AF_INET, { PROTO_IP_BGP, 1   } },
        EntityEventCallback, &Bgp4Methods,
        "test.out"
    },

    {
        TRUE,
        { 0, 0,        { 0,           0   } },
        NULL,                NULL,
        ""
    }
};

const RTM_VIEW_SET VIEW_MASK_ARR[]
          = {
              0,
              RTM_VIEW_MASK_UCAST,
              RTM_VIEW_MASK_MCAST,
              RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST
            };

// Disable warnings for unreferenced params and local variables
#pragma warning(disable: 4100)
#pragma warning(disable: 4101)

//
// Main
//

#if !LOOKUP_TESTING

int
__cdecl
main (void)
{
    PENTITY_CHARS           Entity;
    DWORD                   Status;
    LPTHREAD_START_ROUTINE  EntityThreadProc;
#if MT
    UINT                    NumThreads;
    HANDLE                  Threads[64];
#endif

    Entity = &GlobalEntityChars[0];

#if MT
    NumThreads = 0;
#endif

    while (Entity->EntityInformation.EntityId.EntityId != 0)
    {
        if (Entity->Rtmv2Registration)
        {
            EntityThreadProc = Rtmv2EntityThreadProc;
        }
        else
        {
            EntityThreadProc = Rtmv1EntityThreadProc;
        }

#if MT
        Threads[NumThreads] = CreateThread(NULL,
                                           0,
                                           EntityThreadProc,
                                           Entity++,
                                           0,
                                           NULL);

        Print("Thread ID %d: %p\n", NumThreads, Threads[NumThreads]);

        NumThreads++;
#else
        Status = EntityThreadProc(Entity++);
#endif
    }

#if MT
    WaitForMultipleObjects(NumThreads, Threads, TRUE, INFINITE);
#endif

    return 0;
}

#endif

//
// A general state machine for a protocol thread (RTMv1)
//

DWORD Rtmv1EntityThreadProc (LPVOID ThreadParameters)
{
    RTM_PROTOCOL_FAMILY_CONFIG FamilyConfig;
    PENTITY_CHARS            EntityChars;
    PRTM_ENTITY_INFO         EntityInfo;
    HANDLE                   Event;
    HANDLE                   V1RegnHandle;
    DWORD                    ProtocolId;
    UINT                     i;
    FILE                     *FilePtr;
    IP_NETWORK               Network;
    UINT                     NumDests;
    UINT                     NumRoutes;
    Route                    ThisRoute;
    Route                    Routes[MAXROUTES];
    RTM_IP_ROUTE             V1Route;
    RTM_IP_ROUTE             V1Route2;
    HANDLE                   V1EnumHandle;
    BOOL                     Exists;
    DWORD                    Flags;
    DWORD                    Status;

    //
    // Get all characteristics of this entity
    //

    EntityChars = (PENTITY_CHARS) ThreadParameters;

    EntityInfo = &EntityChars->EntityInformation;

    Assert(EntityInfo->AddressFamily == RTM_PROTOCOL_FAMILY_IP);

    Print("\n--------------------------------------------------------\n");

#if WRAPPER
    FamilyConfig.RPFC_Validate = ValidateRouteCallback;
    FamilyConfig.RPFC_Change = RouteChangeCallback;

    Status = RtmCreateRouteTable(EntityInfo->AddressFamily, &FamilyConfig);

    if (Status != ERROR_ALREADY_EXISTS)
    {
        Check(Status, 50);
    }
    else
    {
        Print("Protocol Family's Route Table already created\n");
    }

    Event = CreateEvent(NULL, TRUE, FALSE, NULL);

    Assert(Event != NULL);

    ProtocolId = EntityInfo->EntityId.EntityProtocolId,

    V1RegnHandle = RtmRegisterClient(EntityInfo->AddressFamily,
                                      ProtocolId,
                                      NULL,
                                      NULL); // RTM_PROTOCOL_SINGLE_ROUTE);
    if (V1RegnHandle == NULL)
    {
        Status = GetLastError();

        Check(Status, 52);
    }

    if ((FilePtr = fopen(EntityChars->RoutesFileName, "r")) == NULL)
    {
        Fatal("Failed open route database with status = %p\n",
                ERROR_OPENING_DATABASE);
    }

    NumRoutes = ReadRoutesFromFile(FilePtr, MAX_ROUTES, Routes);

    fclose(FilePtr);

    //
    // How many destinations do we have in table ?
    //

    NumDests = RtmGetNetworkCount(EntityInfo->AddressFamily);

    if (NumDests == 0)
    {
        Check(Status, 63);
    }

    Print("Number of destinations = %lu\n\n", NumDests);

    //
    // Add a bunch of routes from the input file
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Print("Add Route: Addr = %08x, Mask = %08x\n",
        //            Routes[i].addr,
        //            Routes[i].mask);

        ConvertRouteToV1Route(&Routes[i], &V1Route);

        V1Route.RR_ProtocolSpecificData.PSD_Data[0] =
        V1Route.RR_ProtocolSpecificData.PSD_Data[1] =
        V1Route.RR_ProtocolSpecificData.PSD_Data[2] =
        V1Route.RR_ProtocolSpecificData.PSD_Data[3] = i;

        V1Route.RR_FamilySpecificData.FSD_Priority = ProtocolId;

        V1Route.RR_FamilySpecificData.FSD_Flags = (ULONG) ~0;

        Status = RtmAddRoute(V1RegnHandle,
                              &V1Route,
                              INFINITE,
                              &Flags,
                              NULL,
                              NULL);

        Check(Status, 54);
    }

    //
    // Check if routes exist to the destination
    //

    for (i = 0; i < NumRoutes; i++)
    {
        Network.N_NetNumber = Routes[i].addr;
        Network.N_NetMask = Routes[i].mask;

        Exists = RtmIsRoute(EntityInfo->AddressFamily,
                             &Network,
                             &V1Route);
        if (!Exists)
        {
            Check(Status, 64);

            continue;
        }

        // ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        Exists = RtmLookupIPDestination(Routes[i].addr,
                                         &V1Route2);

        if (Exists)
        {
            if (!RtlEqualMemory(&V1Route, &V1Route2, sizeof(RTM_IP_ROUTE)))
            {
                Print("Routes different: \n");

                ConvertV1RouteToRoute(&V1Route, &ThisRoute);
                // PrintRoute(&ThisRoute);

                ConvertV1RouteToRoute(&V1Route2, &ThisRoute);
                // PrintRoute(&ThisRoute);

                Print("\n");
            }
        }
        else
        {
            Status = GetLastError();

            PrintIPAddr(&Routes[i].addr); Print("\n");

            Check(Status, 65);
        }
    }

    //
    // How many destinations do we have in table ?
    //

    NumDests = RtmGetNetworkCount(EntityInfo->AddressFamily);

    if (NumDests == 0)
    {
        Check(Status, 63);
    }

    Print("Number of destinations = %lu\n\n", NumDests);

    // Try using RtmGetFirstRoute and RtmGetNextRoute

    NumRoutes = 0;

    Status = RtmGetFirstRoute(EntityInfo->AddressFamily,
                               NULL,
                               &V1Route);

    // Check(Status, 59);

    while (SUCCESS(Status))
    {
        NumRoutes++;

        // Print the V1 Route that is next in the enum

        // ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        Status = RtmGetNextRoute(EntityInfo->AddressFamily,
                                  NULL,
                                  &V1Route);

        // Check(Status, 60);
    }


    // Print("Num of routes in table : %lu\n", NumRoutes);


    //
    // Disable and reenable all routes that match criteria
    //

    V1Route.RR_InterfaceID = 3;

    Status = RtmBlockSetRouteEnable(V1RegnHandle,
                                     RTM_ONLY_THIS_INTERFACE,
                                     &V1Route,
                                     FALSE);
    Check(Status, 66);

/*
    V1Route.RR_InterfaceID = 3;

    Status = RtmBlockSetRouteEnable(V1RegnHandle,
                                     RTM_ONLY_THIS_INTERFACE,
                                     &V1Route,
                                     TRUE);
    Check(Status, 66);

    //
    // Convert all routes that match criteria to static
    //

    V1Route.RR_InterfaceID = 3;

    Status = RtmBlockConvertRoutesToStatic(V1RegnHandle,
                                            RTM_ONLY_THIS_INTERFACE,
                                            &V1Route);

    Check(Status, 62);
*/

    //
    // Delete all routes that match the criteria
    //

    ZeroMemory(&V1Route, sizeof(RTM_IP_ROUTE));

    V1Route.RR_InterfaceID = 2;

    Status= RtmBlockDeleteRoutes(V1RegnHandle,
                                 RTM_ONLY_THIS_INTERFACE|RTM_ONLY_THIS_NETWORK,
                                 &V1Route);

    Check(Status, 61);

    //
    // Enum and del this regn's routes in the table
    //

    V1Route.RR_RoutingProtocol = ProtocolId;

    V1EnumHandle = RtmCreateEnumerationHandle(EntityInfo->AddressFamily,
                                              RTM_ONLY_THIS_PROTOCOL,
                                              &V1Route);
    if (V1EnumHandle == NULL)
    {
        Status = GetLastError();

        Check(Status, 56);
    }

    NumRoutes = 0;

    do
    {
        Status = RtmEnumerateGetNextRoute(V1EnumHandle,
                                          &V1Route);

        // Check(Status, 58);

        if (!SUCCESS(Status))
        {
            break;
        }

        NumRoutes++;

        // Print the V1 Route that is next in the enum

        // ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        // Delete this route from the table forever

        Status = RtmDeleteRoute(V1RegnHandle,
                                &V1Route,
                                &Flags,
                                NULL);

        Check(Status, 55);
    }
    while (TRUE);

    Print("Num of routes in table : %lu\n", NumRoutes);

    Status = RtmCloseEnumerationHandle(V1EnumHandle);

    Check(Status, 57);

    //
    // Enumerate all routes in table once again
    //

    V1EnumHandle = RtmCreateEnumerationHandle(EntityInfo->AddressFamily,
                                              RTM_INCLUDE_DISABLED_ROUTES,
                                              NULL);
    if (V1EnumHandle == NULL)
    {
        Status = GetLastError();

        Check(Status, 56);
    }

    NumRoutes = 0;

    do
    {
        Status = RtmEnumerateGetNextRoute(V1EnumHandle,
                                          &V1Route);

        // Check(Status, 58);

        if (!SUCCESS(Status))
        {
            break;
        }

        NumRoutes++;

        // Print the V1 Route that is next in the enum

        ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        UNREFERENCED_PARAMETER(Flags);

        Status = RtmDeleteRoute(V1RegnHandle,
                                &V1Route,
                                &Flags,
                                NULL);

        Check(Status, 55);
    }
    while (TRUE);

    Print("Num of routes in table : %lu\n", NumRoutes);

    Status = RtmCloseEnumerationHandle(V1EnumHandle);

    Check(Status, 57);

    //
    // Deregister the entity and clean up now
    //

    Status = RtmDeregisterClient(V1RegnHandle);

    Check(Status, 53);

    if (Event)
    {
        CloseHandle(Event);
    }

    Status = RtmDeleteRouteTable(EntityInfo->AddressFamily);

    Check(Status, 51);
#endif

    Print("\n--------------------------------------------------------\n");

    return 0;
}

VOID
ConvertRouteToV1Route(Route *ThisRoute, RTM_IP_ROUTE *V1Route)
{
    ZeroMemory(V1Route, sizeof(RTM_IP_ROUTE));

    V1Route->RR_Network.N_NetNumber = ThisRoute->addr;
    V1Route->RR_Network.N_NetMask = ThisRoute->mask;

    V1Route->RR_InterfaceID = PtrToUlong(ThisRoute->interface);

    V1Route->RR_NextHopAddress.N_NetNumber = ThisRoute->nexthop;
    V1Route->RR_NextHopAddress.N_NetMask = 0xFFFFFFFF;

    V1Route->RR_FamilySpecificData.FSD_Metric = ThisRoute->metric;

    return;
}

VOID
ConvertV1RouteToRoute(RTM_IP_ROUTE *V1Route, Route *ThisRoute)
{
    DWORD Mask;

    ZeroMemory(ThisRoute, sizeof(Route));

    ThisRoute->addr = V1Route->RR_Network.N_NetNumber;
    ThisRoute->mask = V1Route->RR_Network.N_NetMask;

    ThisRoute->len = 0;

    // No checking for contiguous masks

    Mask = ThisRoute->mask;
    while (Mask)
    {
        if (Mask & 1)
        {
            ThisRoute->len++;
        }

        Mask >>= 1;
    }

    ThisRoute->interface = ULongToPtr(V1Route->RR_InterfaceID);

    ThisRoute->nexthop = V1Route->RR_NextHopAddress.N_NetNumber;
    Assert(V1Route->RR_NextHopAddress.N_NetMask ==  0xFFFFFFFF);

    ThisRoute->metric = V1Route->RR_FamilySpecificData.FSD_Metric;

    Print("Owner = %08x, ", V1Route->RR_RoutingProtocol);
    PrintRoute(ThisRoute);

    return;
}

DWORD
ValidateRouteCallback(
    IN      PVOID                           Route
    )
{
    UNREFERENCED_PARAMETER(Route);

    return NO_ERROR;
}

VOID
RouteChangeCallback(
    IN      DWORD                           Flags,
    IN      PVOID                           CurrBestRoute,
    IN      PVOID                           PrevBestRoute
    )
{
    Route       ThisRoute;

    Print("Route Change Notification:\n");

    Print("Flags = %08x\n", Flags);

    Print("Prev Route = ");
    if (Flags & RTM_PREVIOUS_BEST_ROUTE)
    {
        ConvertV1RouteToRoute((RTM_IP_ROUTE *) PrevBestRoute, &ThisRoute);
        // PrintRoute(ThisRoute);
    }
    else
    {
        Print("NULL Route\n");
    }

    // Print("Curr Route = ");
    if (Flags & RTM_CURRENT_BEST_ROUTE)
    {
        ConvertV1RouteToRoute((RTM_IP_ROUTE *) CurrBestRoute, &ThisRoute);
        // PrintRoute(ThisRoute);
    }
    else
    {
        Print("NULL Route\n");
    }

    return;
}


//
// A general state machine for a protocol thread (RTMv2)
//

DWORD Rtmv2EntityThreadProc (LPVOID ThreadParameters)
{
    PENTITY_CHARS             EntityChars;
    PRTM_ENTITY_INFO          EntityInfo;
    RTM_INSTANCE_CONFIG       InstanceConfig;
    RTM_ADDRESS_FAMILY_CONFIG AddrFamConfig;
    RTM_ADDRESS_FAMILY_INFO   AddrFamilyInfo;
    RTM_ENTITY_HANDLE         RtmRegHandle;
    RTM_VIEW_SET              ViewSet;
    UINT                      NumViews;
    UINT                      NumInstances;
    RTM_INSTANCE_INFO         Instances[MAX_INSTANCES];
    RTM_ADDRESS_FAMILY_INFO   AddrFams[MAX_ADDR_FAMS];
    UINT                      NumEntities;
    RTM_ENTITY_HANDLE         EntityHandles[MAX_ENTITIES];
    RTM_ENTITY_INFO           EntityInfos[MAX_ENTITIES];
    UINT                      NumMethods;
    RTM_ENTITY_EXPORT_METHOD  ExportMethods[MAX_METHODS];
    RTM_ENTITY_METHOD_INPUT   Input;
    UINT                      OutputHdrSize;
    UINT                      OutputSize;
    RTM_ENTITY_METHOD_OUTPUT  Output[MAX_METHODS];
    UINT                      i, j, k, l, m;
    UCHAR                     *p;
    FILE                      *FilePtr;
    UINT                      NumRoutes;
    Route                     Routes[MAXROUTES];
    RTM_NEXTHOP_INFO          NextHopInfo;
    RTM_NEXTHOP_HANDLE        NextHopHandle;
    PRTM_NEXTHOP_INFO         NextHopPointer;
    DWORD                     ChangeFlags;
    RTM_ENUM_HANDLE           EnumHandle;
    RTM_ENUM_HANDLE           EnumHandle1;
    RTM_ENUM_HANDLE           EnumHandle2;
    UINT                      TotalHandles;
    UINT                      NumHandles;
    HANDLE                    Handles[MAX_HANDLES];
    RTM_NET_ADDRESS           NetAddress;
    UINT                      DestInfoSize;
    PRTM_DEST_INFO            DestInfo1;
    PRTM_DEST_INFO            DestInfo2;
    UINT                      NumInfos;
    PRTM_DEST_INFO            DestInfos;
    RTM_ROUTE_INFO            RouteInfo;
    RTM_ROUTE_HANDLE          RouteHandle;
    PRTM_ROUTE_INFO           RoutePointer;
    RTM_PREF_INFO             PrefInfo;
    RTM_ROUTE_LIST_HANDLE     RouteListHandle1;
    RTM_ROUTE_LIST_HANDLE     RouteListHandle2;
    RTM_NOTIFY_HANDLE         NotifyHandle;
    BOOL                      Marked;
    DWORD                     Status;
    DWORD                     Status1;
    DWORD                     Status2;

    //
    // Test the mask to len conversion macros in rtmv2.h
    //

    for (i = 0; i < 33; i++)
    {
        j = RTM_IPV4_MASK_FROM_LEN(i);

        p = (PUCHAR) &j;

        RTM_IPV4_LEN_FROM_MASK(k, j);

        Assert(i == k);

        printf("Len %2d: %08x: %02x.%02x.%02x.%02x: %2d\n",
               i, j, p[0], p[1], p[2], p[3], k);
    }

    //
    // Get all characteristics of this entity
    //

    EntityChars = (PENTITY_CHARS) ThreadParameters;

    EntityInfo = &EntityChars->EntityInformation;

    Print("\n--------------------------------------------------------\n");

    //
    // -00- Is this addr family config in registry
    //

    Status = RtmReadAddressFamilyConfig(EntityInfo->RtmInstanceId,
                                        EntityInfo->AddressFamily,
                                        &AddrFamConfig);

    DBG_UNREFERENCED_LOCAL_VARIABLE(InstanceConfig);

    if (!SUCCESS(Status))
    {
        // Fill in the instance config

        Status = RtmWriteInstanceConfig(EntityInfo->RtmInstanceId,
                                        &InstanceConfig);

        Check(Status, 0);

        // Fill in the address family config

        AddrFamConfig.AddressSize = sizeof(DWORD);

        AddrFamConfig.MaxChangeNotifyRegns = 10;
        AddrFamConfig.MaxOpaqueInfoPtrs = 10;
        AddrFamConfig.MaxNextHopsInRoute = 5;
        AddrFamConfig.MaxHandlesInEnum = 100;

        AddrFamConfig.ViewsSupported = RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST;

        Status = RtmWriteAddressFamilyConfig(EntityInfo->RtmInstanceId,
                                             EntityInfo->AddressFamily,
                                             &AddrFamConfig);
        Check(Status, 0);
    }

    //
    // -01- Register with an AF on an RTM instance
    //

    Status = RtmRegisterEntity(EntityInfo,
                               (PRTM_ENTITY_EXPORT_METHODS)
                               EntityChars->ExportMethods,
                               EntityChars->EventCallback,
                               TRUE,
                               &EntityChars->RegnProfile,
                               &RtmRegHandle);

    Check(Status, 1);

    //
    // Count the number of views for later use
    //

    NumViews = EntityChars->RegnProfile.NumberOfViews;

    //
    // Test all the management APIs before others
    //

    NumInstances = MAX_INSTANCES;

    Status = RtmGetInstances(&NumInstances,
                             &Instances[0]);

    Check(Status, 100);

    for (i = 0; i < NumInstances; i++)
    {
        Status = RtmGetInstanceInfo(Instances[i].RtmInstanceId,
                                    &Instances[i],
                                    &Instances[i].NumAddressFamilies,
                                    AddrFams);

        Check(Status, 101);
    }

    //
    // Query the appropriate table to check regn
    //

    NumEntities = MAX_ENTITIES;

    Status = RtmGetAddressFamilyInfo(EntityInfo->RtmInstanceId,
                                     EntityInfo->AddressFamily,
                                     &AddrFamilyInfo,
                                     &NumEntities,
                                     EntityInfos);
    Check(Status, 102);

    //
    // -03- Get all currently registered entities
    //

    NumEntities = MAX_ENTITIES;

    Status = RtmGetRegisteredEntities(RtmRegHandle,
                                      &NumEntities,
                                      EntityHandles,
                                      EntityInfos);

    Print("\n");
    for (i = 0; i < NumEntities; i++)
    {
        Print("%02d: Handle: %p\n", i, EntityHandles[i]);
    }
    Print("\n");

    Check(Status, 3);

    //
    // -04- Get all exports methods of each entity
    //

    for (i = 0; i < NumEntities; i++)
    {
        NumMethods = 0;

        Status = RtmGetEntityMethods(RtmRegHandle,
                                     EntityHandles[i],
                                     &NumMethods,
                                     NULL);

        Check(Status, 4);

        Print("\n");
        Print("Number of methods for %p = %2d\n",
                  EntityHandles[i],
                  NumMethods);
        Print("\n");

        Status = RtmGetEntityMethods(RtmRegHandle,
                                     EntityHandles[i],
                                     &NumMethods,
                                     ExportMethods);

        Check(Status, 4);

/*
        //
        // -06- Try blocking methods & then calling invoke
        //      Wont block as thread owns Critical Section
        //

        Status = RtmBlockMethods(RtmRegHandle,
                                 NULL,
                                 0,
                                 RTM_BLOCK_METHODS);

        Check(Status, 6);
*/

        // for (j = 0; j < NumMethods; j++)
        {
            //
            // -05- Invoke all exports methods of an entity
            //

            Input.MethodType = METHOD_TYPE_ALL_METHODS; // 1 << j;

            Input.InputSize = 0;

            OutputHdrSize = FIELD_OFFSET(RTM_ENTITY_METHOD_OUTPUT, OutputData);

            OutputSize = OutputHdrSize * MAX_METHODS;

            Status = RtmInvokeMethod(RtmRegHandle,
                                     EntityHandles[i],
                                     &Input,
                                     &OutputSize,
                                     Output);

            Print("\n");
            Print("Num Methods Called = %d\n", OutputSize / OutputHdrSize);
            Print("\n");

            Check(Status, 5);
        }
    }

    //
    // -44- Release handles we have on the entities
    //

    Status = RtmReleaseEntities(RtmRegHandle,
                                NumEntities,
                                EntityHandles);

    Check(Status, 44);

    //
    // -07- Add next hops to the table (from the info file)
    //

    if ((FilePtr = fopen(EntityChars->RoutesFileName, "r")) == NULL)
    {
        Fatal("Failed open route database with status = %x\n",
                ERROR_OPENING_DATABASE);
    }

    NumRoutes = ReadRoutesFromFile(FilePtr,
                                   MAX_ROUTES,
                                   Routes);

    fclose(FilePtr);

    // For each route, add its next-hop to the next-hop table

    for (i = 0; i < NumRoutes; i++)
    {
        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.RemoteNextHop = NULL;
        NextHopInfo.Flags = 0;
        NextHopInfo.EntitySpecificInfo = UIntToPtr(i);
        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmAddNextHop(RtmRegHandle,
                               &NextHopInfo,
                               &NextHopHandle,
                               &ChangeFlags);

        Check(Status, 7);

        // Print("Add Next Hop %lu: %p\n", i, NextHopHandle);

        if (!(ChangeFlags & RTM_NEXTHOP_CHANGE_NEW))
        {
            Status = RtmReleaseNextHops(RtmRegHandle,
                                        1,
                                        &NextHopHandle);
            Check(Status, 15);
        }
#if _DBG_
        else
        {
            Status = RtmDeleteNextHop(RtmRegHandle,
                                      NextHopHandle,
                                      NULL);
            Check(Status, 14);
        }
#endif
    }


    //
    // 08 - Find the next-hops added using RtmFindNextHop
    //

    for (i = 0; i < NumRoutes; i++)
    {
        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.NextHopOwner = RtmRegHandle;

        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmFindNextHop(RtmRegHandle,
                                &NextHopInfo,
                                &NextHopHandle,
                                &NextHopPointer);

        // Print("NextHop: Handle: %p,\n\t Addr: ", NextHopHandle);
        // Print("%3d.", (UINT) NextHopPointer->NextHopAddress.AddrBits[0]);
        // Print("%3d.", (UINT) NextHopPointer->NextHopAddress.AddrBits[1]);
        // Print("%3d.", (UINT) NextHopPointer->NextHopAddress.AddrBits[2]);
        // Print("%3d ", (UINT) NextHopPointer->NextHopAddress.AddrBits[3]);
        // Print("\n\tInterface = %lu\n", NextHopPointer->InterfaceIndex);

        Check(Status, 8);

        Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                   &NextHopHandle);

        Check(Status, 15);
    }

    //
    // -40- Register with RTM for getting change notifications
    //

    Status = RtmRegisterForChangeNotification(RtmRegHandle,
                                              RTM_VIEW_MASK_MCAST,
                                              RTM_CHANGE_TYPE_BEST,
                                              // RTM_NOTIFY_ONLY_MARKED_DESTS,
                                              EntityChars,
                                              &NotifyHandle);

    Check(Status, 40);

    Print("Change Notification Registration Successful\n\n");

    //
    // -35- Create an entity specific list to add routes to
    //

    Status = RtmCreateRouteList(RtmRegHandle,
                                &RouteListHandle1);

    Check(Status, 35);

    //
    // -17- Add routes to RIB with approprate next-hops
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Get the next hop handle using next hop address

        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.NextHopOwner = RtmRegHandle;

        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmFindNextHop(RtmRegHandle,
                                &NextHopInfo,
                                &NextHopHandle,
                                NULL);
        Check(Status, 8);

        // Now do the route add with the right information

        RouteHandle = NULL;

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                                  Routes[i].addr,
                                  Routes[i].len);

        // Print("Add Route: Len : %08x, Addr = %3d.%3d.%3d.%3d\n",
        //           NetAddress.NumBits,
        //           NetAddress.AddrBits[0],
        //           NetAddress.AddrBits[1],
        //           NetAddress.AddrBits[2],
        //           NetAddress.AddrBits[3]);

        ZeroMemory(&RouteInfo, sizeof(RTM_ROUTE_INFO));

        // Assume 'neighbour learnt from' is the 1st nexthop
        RouteInfo.Neighbour = NextHopHandle;

        RouteInfo.PrefInfo.Preference = EntityInfo->EntityId.EntityProtocolId;
        RouteInfo.PrefInfo.Metric = Routes[i].metric;

        RouteInfo.BelongsToViews = VIEW_MASK_ARR[1 + (i % 3)];

        RouteInfo.EntitySpecificInfo = UIntToPtr(i);

        RouteInfo.NextHopsList.NumNextHops = 1;
        RouteInfo.NextHopsList.NextHops[0] = NextHopHandle;

        ChangeFlags = RTM_ROUTE_CHANGE_NEW;

        Status = RtmAddRouteToDest(RtmRegHandle,
                                   &RouteHandle,
                                   &NetAddress,
                                   &RouteInfo,
                                   INFINITE,
                                   RouteListHandle1,
                                   0,
                                   NULL,
                                   &ChangeFlags);

        Check(Status, 17);

        // Update the same route using the handle

        ChangeFlags = 0;

        RouteInfo.Flags = RTM_ROUTE_FLAGS_DISCARD;

        Status = RtmAddRouteToDest(RtmRegHandle,
                                   &RouteHandle,
                                   &NetAddress,
                                   &RouteInfo,
                                   INFINITE,
                                   RouteListHandle1,
                                   0,
                                   NULL,
                                   &ChangeFlags);

        Check(Status, 17);

        // Print("Add Route %lu: %p\n", i, RouteHandle);

        Status = RtmLockRoute(RtmRegHandle,
                              RouteHandle,
                              TRUE,
                              TRUE,
                              &RoutePointer);

        Check(Status, 46);

        // Update route parameters in place

        RoutePointer->PrefInfo.Metric = 1000 - RoutePointer->PrefInfo.Metric;

        RoutePointer->BelongsToViews = VIEW_MASK_ARR[i % 3];

        RoutePointer->EntitySpecificInfo = UIntToPtr(1000 - i);

        Status = RtmUpdateAndUnlockRoute(RtmRegHandle,
                                         RouteHandle,
                                         10, // INFINITE,
                                         NULL,
                                         0,
                                         NULL,
                                         &ChangeFlags);

        Check(Status, 47);

        // Print("Update Route %lu: %p\n", i, RouteHandle);

        if (!SUCCESS(Status))
        {
            Status = RtmLockRoute(RtmRegHandle,
                                  RouteHandle,
                                  TRUE,
                                  FALSE,
                                  NULL);

            Check(Status, 46);
        }

        // Try doing a add specifying the route handle

        RouteInfo.PrefInfo.Metric = Routes[i].metric;

        RouteInfo.BelongsToViews = VIEW_MASK_ARR[1 + (i % 3)];

        RouteInfo.EntitySpecificInfo = UIntToPtr(i);

        ChangeFlags = 0;

        Status = RtmAddRouteToDest(RtmRegHandle,
                                   &RouteHandle,
                                   &NetAddress,
                                   &RouteInfo,
                                   INFINITE,
                                   RouteListHandle1,
                                   0,
                                   NULL,
                                   &ChangeFlags);
        
        Check(Status, 17);

        Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                    &NextHopHandle);

        // Check(Status, 15);

        if (!SUCCESS(Status))
        {
            // Print("%p %p\n", RtmRegHandle,NextHopHandle);

            Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                    &NextHopHandle);

            Check(Status, 15);
        }
    }

    Status = RtmCreateRouteList(RtmRegHandle,
                                &RouteListHandle2);

    Check(Status, 35);

    //
    // -38- Create an enumeration on the route list
    //

    Status = RtmCreateRouteListEnum(RtmRegHandle,
                                    RouteListHandle1,
                                    &EnumHandle);

    Check(Status, 38);

    TotalHandles = 0;

    do
    {
        //
        // -39- Get next set of routes on the enum
        //

        NumHandles = MAX_HANDLES;

        Status = RtmGetListEnumRoutes(RtmRegHandle,
                                      EnumHandle,
                                      &NumHandles,
                                      Handles);
        Check(Status, 39);

        TotalHandles += NumHandles;

        for (i = 0; i < NumHandles; i++)
        {
            ; // Print("Route Handle %5lu: %p\n", i, Handles[i]);
        }

        //
        // -37- Move all routes in one route list to another
        //

        Status = RtmInsertInRouteList(RtmRegHandle,
                                      RouteListHandle2,
                                      NumHandles,
                                      Handles);

        Check(Status, 37);

        //
        // Release the routes that have been enum'ed
        //

        Status = RtmReleaseRoutes(RtmRegHandle, NumHandles, Handles);

        Check(Status, 27);
    }
    while (NumHandles == MAX_HANDLES);

    Print("\nTotal Num of handles in list: %lu\n", TotalHandles);


    //
    // -36- Destroy all the entity specific lists
    //

    Status = RtmDeleteRouteList(RtmRegHandle, RouteListHandle1);

    Check(Status, 36);


    Status = RtmDeleteRouteList(RtmRegHandle, RouteListHandle2);

    Check(Status, 36);


    DestInfoSize = RTM_SIZE_OF_DEST_INFO(NumViews);

    DestInfo1 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    DestInfo2 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    //
    // -18- Get dests from the table using exact match
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Query for the route with the right information

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress, Routes[i].addr, Routes[i].len);

        Status = RtmGetExactMatchDestination(RtmRegHandle,
                                             &NetAddress,
                                             RTM_BEST_PROTOCOL,
                                             0,
                                             DestInfo1);
        Check(Status, 18);

        //
        // For each destination in table, mark the dest
        //

        Status = RtmMarkDestForChangeNotification(RtmRegHandle,
                                                  NotifyHandle,
                                                  DestInfo1->DestHandle,
                                                  TRUE);
        Check(Status, 48);

        Status = RtmIsMarkedForChangeNotification(RtmRegHandle,
                                                  NotifyHandle,
                                                  DestInfo1->DestHandle,
                                                  &Marked);
        Check(Status, 49);

        Assert(Marked == TRUE);

        Status = RtmReleaseDestInfo(RtmRegHandle, DestInfo1);

        Check(Status, 22);
    }

    DestInfo1 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    DestInfo2 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    //
    // -29- Get routes from the table using exact match
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Get the next hop handle using next hop address

        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.NextHopOwner = RtmRegHandle;

        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmFindNextHop(RtmRegHandle,
                                &NextHopInfo,
                                &NextHopHandle,
                                NULL);
        Check(Status, 8);

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                                  Routes[i].addr,
                                  Routes[i].len);

        // Query for the route with the right information

        RouteInfo.Neighbour = NextHopHandle;

        RouteInfo.RouteOwner = RtmRegHandle;

        RouteInfo.PrefInfo.Preference = EntityInfo->EntityId.EntityProtocolId;
        RouteInfo.PrefInfo.Metric = Routes[i].metric;

        RouteInfo.NextHopsList.NumNextHops = 1;
        RouteInfo.NextHopsList.NextHops[0] = NextHopHandle;

        Status = RtmGetExactMatchRoute(RtmRegHandle,
                                       &NetAddress,
                                       RTM_MATCH_FULL,
                                       &RouteInfo,
                                       PtrToUlong(Routes[i].interface),
                                       0,
                                       &RouteHandle);

        Check(Status, 29);

        Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                    &NextHopHandle);

        Check(Status, 15);

        Status = RtmReleaseRoutes(RtmRegHandle, 1, &RouteHandle);

        Check(Status, 27);

        Status = RtmReleaseRouteInfo(RtmRegHandle, &RouteInfo);

        Check(Status, 31);
    }


    //
    // -19- Get dests from the table using prefix match
    //
    // -20- Do a prefix walk up the tree for each dest
    //

    for (i = j = 0; i < NumRoutes; i++)
    {
        // Query for the route with the right information

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                                  Routes[i].addr,
                                  Routes[i].len);

        Status = RtmGetMostSpecificDestination(RtmRegHandle,
                                               &NetAddress,
                                               RTM_BEST_PROTOCOL,
                                               RTM_VIEW_MASK_UCAST,
                                               DestInfo1);

        // Check(Status, 19);

        if (DestInfo1->DestAddress.NumBits != NetAddress.NumBits)
        {
           ; // Print("No Exact Match : %5lu\n", j++);
        }

        while (SUCCESS(Status))
        {
            Status = RtmGetLessSpecificDestination(RtmRegHandle,
                                                   DestInfo1->DestHandle,
                                                   RTM_BEST_PROTOCOL,
                                                   RTM_VIEW_MASK_UCAST,
                                                   DestInfo2);

            // Check(Status, 20);

            Check(RtmReleaseDestInfo(RtmRegHandle, DestInfo1), 22);

            if (!SUCCESS(Status)) break;

            // Print("NumBits: %d\n", DestInfo2->DestAddress.NumBits);

            Status = RtmGetLessSpecificDestination(RtmRegHandle,
                                                   DestInfo2->DestHandle,
                                                   RTM_BEST_PROTOCOL,
                                                   RTM_VIEW_MASK_UCAST,
                                                   DestInfo1);

            // Check(Status, 20);

            Check(RtmReleaseDestInfo(RtmRegHandle, DestInfo2), 20);

            if (!SUCCESS(Status)) break;

            // Print("NumBits: %d\n", DestInfo1->DestAddress.NumBits);
        }
    }

#if DBG
    for (i = 0; i < 100000000; i++) { ; }
#endif


    //
    // Just do a "route enum" over the whole table
    //

    Status2 = RtmCreateRouteEnum(RtmRegHandle,
                                 NULL,
                                 0, // RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST,
                                 RTM_ENUM_OWN_ROUTES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &EnumHandle2);

    Check(Status2, 25);

    l = 0;

    do
    {
        NumHandles = MAX_HANDLES;

        Status2 = RtmGetEnumRoutes(RtmRegHandle,
                                   EnumHandle2,
                                   &NumHandles,
                                   Handles);

        // Check(Status2, 26);

        for (k = 0; k < NumHandles; k++)
        {
            ; // Print("Route %d: %p\n", l++, Handles[k]);
        }

        Check(RtmReleaseRoutes(RtmRegHandle,
                               NumHandles,
                               Handles),           27);
    }
    while (SUCCESS(Status2));

    //
    // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
    //

    NumHandles = MAX_HANDLES;

    Status2 = RtmGetEnumRoutes(RtmRegHandle,
                               EnumHandle2,
                               &NumHandles,
                               Handles);

    Assert((NumHandles == 0) && (Status2 == ERROR_NO_MORE_ITEMS));

    Status2 = RtmDeleteEnumHandle(RtmRegHandle,
                                  EnumHandle2);

    Check(Status2, 16);

    //
    // Get dests from the table using an enumeration
    //    -23- Open a new dest enumeration
    //    -24- Get dests in enum
    //    -16- Close destination enum.
    //

    DestInfos = ALLOC_RTM_DEST_INFO(NumViews, MAX_HANDLES);

#if MCAST_ENUM

    RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                              0x000000E0,
                              4);

#else

    RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                              0x00000000,
                              0);

#endif

    Status = RtmCreateDestEnum(RtmRegHandle,
                               RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST,
                               RTM_ENUM_RANGE | RTM_ENUM_OWN_DESTS,
                               &NetAddress,
                               RTM_THIS_PROTOCOL,
                               &EnumHandle1);

    Check(Status, 23);

    m = j = 0;

    do
    {
        NumInfos = MAX_HANDLES;

        Status1 = RtmGetEnumDests(RtmRegHandle,
                                  EnumHandle1,
                                  &NumInfos,
                                  DestInfos);

        // Check(Status1, 24);

        for (i = 0; i < NumInfos; i++)
        {
            DestInfo1 = (PRTM_DEST_INFO) ((PUCHAR)DestInfos+(i*DestInfoSize));

            // Print("Dest %d: %p\n", j++, DestInfo1->DestHandle);

            // PrintDestInfo(DestInfo1);

            Status2 = RtmCreateRouteEnum(RtmRegHandle,
                                         DestInfo1->DestHandle,
                                         RTM_VIEW_MASK_UCAST |
                                         RTM_VIEW_MASK_MCAST,
                                         RTM_ENUM_OWN_ROUTES,
                                         NULL,
                                         0, // RTM_MATCH_INTERFACE,
                                         NULL,
                                         0,
                                         &EnumHandle2);

            Check(Status2, 25);
/*
            Check(RtmHoldDestination(RtmRegHandle,
                                     DestInfo1->DestHandle,
                                     RTM_VIEW_MASK_UCAST,
                                     100),  33);
*/
            l = 0;

            PrefInfo.Preference = (ULONG) ~0;
            PrefInfo.Metric = (ULONG) 0;

            do
            {
                NumHandles = MAX_HANDLES;

                Status2 = RtmGetEnumRoutes(RtmRegHandle,
                                           EnumHandle2,
                                           &NumHandles,
                                           Handles);

                // Check(Status2, 26);

                for (k = 0; k < NumHandles; k++)
                {
                    // Print("\tRoute %d: %p\t", l++, Handles[k]);

                    // PrintRouteInfo(Handles[k]);

                    Status = RtmIsBestRoute(RtmRegHandle,
                                            Handles[k],
                                            &ViewSet);

                    Check(Status, 28);

                    // Print("Best In Views: %08x\n", ViewSet);


                    Status = RtmGetRouteInfo(RtmRegHandle,
                                             Handles[k],
                                             &RouteInfo,
                                             &NetAddress);

                    Check(Status, 30);

                    Print("RouteDest: Len : %08x,"   \
                          " Addr = %3d.%3d.%3d.%3d," \
                          " Pref = %08x, %08x\n",
                               NetAddress.NumBits,
                               NetAddress.AddrBits[0],
                               NetAddress.AddrBits[1],
                               NetAddress.AddrBits[2],
                               NetAddress.AddrBits[3],
                               RouteInfo.PrefInfo.Preference,
                               RouteInfo.PrefInfo.Metric);

                    //
                    // Make sure that list is ordered by PrefInfo
                    //

                    if ((PrefInfo.Preference < RouteInfo.PrefInfo.Preference)||
                        ((PrefInfo.Preference == RouteInfo.PrefInfo.Preference)
                         && (PrefInfo.Metric > RouteInfo.PrefInfo.Metric)))
                    {
                        Check(ERROR_INVALID_DATA, 150);
                    }

                    Status = RtmReleaseRouteInfo(RtmRegHandle,
                                                 &RouteInfo);

                    Check(Status, 31);

                    // Print("Del Route %lu: %p\n", m++, Handles[k]);

                    Status = RtmDeleteRouteToDest(RtmRegHandle,
                                                  Handles[k],
                                                  &ChangeFlags);

                    Check(Status, 32);
                }

                Check(RtmReleaseRoutes(RtmRegHandle,
                                       NumHandles,
                                       Handles),           27);
            }
            while (SUCCESS(Status2));

            //
            // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
            //

            NumHandles = MAX_HANDLES;

            Status2 = RtmGetEnumRoutes(RtmRegHandle,
                                       EnumHandle2,
                                       &NumHandles,
                                       Handles);

            Assert((NumHandles == 0) && (Status2 == ERROR_NO_MORE_ITEMS));
/*
            Check(RtmHoldDestination(RtmRegHandle,
                                     DestInfo1->DestHandle,
                                     RTM_VIEW_MASK_MCAST,
                                     100),  33);
*/
            Status2 = RtmDeleteEnumHandle(RtmRegHandle,
                                          EnumHandle2);

            Check(Status2, 16);

            // Check(RtmReleaseDestInfo(RtmRegHandle,
            //                          DestInfo1),           22);
        }

        Check(RtmReleaseDests(RtmRegHandle,
                              NumInfos,
                              DestInfos), 34);
    }
    while (SUCCESS(Status1));

    //
    // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
    //

    NumInfos = MAX_HANDLES;

    Status1 = RtmGetEnumDests(RtmRegHandle,
                              EnumHandle1,
                              &NumInfos,
                              DestInfos);

    Assert((NumInfos == 0) && (Status1 == ERROR_NO_MORE_ITEMS));

    Status1 = RtmDeleteEnumHandle(RtmRegHandle,
                                  EnumHandle1);

    Check(Status1, 16);


    //
    // -10- Enumerate all the next-hops in table,
    //
    // -11- For each next-hop in table
    //      -12- Get the next hop info,
    //      -14- Delete the next-hop,
    //      -13- Release next hop info.
    //
    // -15- Release all the next-hops in table,
    //
    // -16- Close the next hop enumeration handle.
    //

    Status = RtmCreateNextHopEnum(RtmRegHandle,
                                  0,
                                  NULL,
                                  &EnumHandle);

    Check(Status, 10);

    j = 0;

    do
    {
        NumHandles = 5; // MAX_HANDLES;

        Status = RtmGetEnumNextHops(RtmRegHandle,
                                    EnumHandle,
                                    &NumHandles,
                                    Handles);

        // Check(Status, 11);

        for (i = 0; i < NumHandles; i++)
        {
            Check(RtmGetNextHopInfo(RtmRegHandle,
                                    Handles[i],
                                    &NextHopInfo), 12);

            // Print("Deleting NextHop %lu: %p\n", j++, Handles[i]);
            // Print("State: %04x, Interface: %d\n",
            //           NextHopInfo.State,
            //           NextHopInfo.InterfaceIndex);

            Check(RtmDeleteNextHop(RtmRegHandle,
                                       Handles[i],
                                       NULL),          14);

            Check(RtmReleaseNextHopInfo(RtmRegHandle,
                                        &NextHopInfo), 13);
        }

        Check(RtmReleaseNextHops(RtmRegHandle,
                                 NumHandles,
                                 Handles),         15);
    }
    while (SUCCESS(Status));

    //
    // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
    //

    NumHandles = MAX_HANDLES;

    Status = RtmGetEnumNextHops(RtmRegHandle,
                                EnumHandle,
                                &NumHandles,
                                Handles);

    Assert((NumHandles == 0) && (Status == ERROR_NO_MORE_ITEMS));

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    Check(Status, 16);

    //
    // Make sure that the next hop table is empty now
    //

    Status = RtmCreateNextHopEnum(RtmRegHandle,
                                  0,
                                  NULL,
                                  &EnumHandle);

    NumHandles = MAX_HANDLES;

    Status = RtmGetEnumNextHops(RtmRegHandle,
                                EnumHandle,
                                &NumHandles,
                                Handles);


    if ((Status != ERROR_NO_MORE_ITEMS) || (NumHandles != 0))
    {
        Check(Status, 11);
    }

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    Check(Status, 16);

    Sleep(1000);

    //
    // -41- Deregister all existing change notif registrations
    //

    Status = RtmDeregisterFromChangeNotification(RtmRegHandle,
                                                 NotifyHandle);
    Check(Status, 41);

    Print("Change Notification Deregistration Successful\n\n");

    //
    // -02- De-register with the RTM before exiting
    //

    Status = RtmDeregisterEntity(RtmRegHandle);

    Check(Status, 2);

#if _DBG_
    Status = RtmDeregisterEntity(RtmRegHandle);

    Check(Status, 2);
#endif

    Print("\n--------------------------------------------------------\n");

    return NO_ERROR;
}


DWORD
EntityEventCallback (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    )
{
    RTM_ENTITY_HANDLE EntityHandle;
    PENTITY_CHARS     EntityChars;
    PRTM_ENTITY_INFO  EntityInfo;
    RTM_NOTIFY_HANDLE NotifyHandle;
    PRTM_DEST_INFO    DestInfos;
    UINT              NumDests;
    UINT              NumViews;
    RTM_ROUTE_HANDLE  RouteHandle;
    PRTM_ROUTE_INFO   RoutePointer;
    DWORD             ChangeFlags;
    DWORD             Status;

    Print("\nEvent callback called for %p :", RtmRegHandle);

    Status = NO_ERROR;

    Print("\n\tEntity Event = ");

    switch (EventType)
    {
    case RTM_ENTITY_REGISTERED:

        EntityHandle = (RTM_ENTITY_HANDLE) Context1;
        EntityInfo   = (PRTM_ENTITY_INFO)  Context2;

        Print("Registration\n\tEntity Handle = %p\n\tEntity IdInst = %p\n\n",
              EntityHandle,
              EntityInfo->EntityId);

/*
        //
        // -45- Make a copy of the handle of new entity
        //

        Status = RtmReferenceHandles(RtmRegHandle,
                                     1,
                                     &EntityHandle);

        Check(Status, 45);
*/
        break;

    case RTM_ENTITY_DEREGISTERED:

        EntityHandle = (RTM_ENTITY_HANDLE) Context1;
        EntityInfo   = (PRTM_ENTITY_INFO)  Context2;

        Print("Deregistration\n\tEntity Handle = %p\n\tEntity IdInst = %p\n\n",
               EntityHandle,
              EntityInfo->EntityId);

/*
        //
        // -44- Release the handle we have on the entity
        //

        Status = RtmReleaseEntities(RtmRegHandle,
                                    1,
                                    &EntityHandle);

        Check(Status, 44);
*/
        break;

    case RTM_CHANGE_NOTIFICATION:

        NotifyHandle = (RTM_NOTIFY_HANDLE) Context1;

        EntityChars  = (PENTITY_CHARS) Context2;

        Print("Changes Available\n\tNotify Handle = %p\n\tEntity Ch = %p\n\n",
              NotifyHandle,
              EntityChars);

        //
        // Count the number of view for later use
        //

        NumViews = EntityChars->RegnProfile.NumberOfViews;

        //
        // -43- Get all changes to destinations
        //

        DestInfos = ALLOC_RTM_DEST_INFO(NumViews, MAX_HANDLES);

        do
        {
            NumDests = MAX_HANDLES;

            Status = RtmGetChangedDests(RtmRegHandle,
                                        NotifyHandle,
                                        &NumDests,
                                        DestInfos);
            // Check(Status, 42);

            printf("Status = %lu\n", Status);

            Print("Num Changed Dests = %d\n", NumDests);

            EntityChars->TotalChangedDests += NumDests;

            Status = RtmReleaseChangedDests(RtmRegHandle,
                                            NotifyHandle,
                                            NumDests,
                                            DestInfos);
            Check(Status, 43);
        }
        while (NumDests > 0);

        Print("Total Changed Dests = %d\n", EntityChars->TotalChangedDests);

        break;

    case RTM_ROUTE_EXPIRED:

        RouteHandle = (RTM_ROUTE_HANDLE) Context1;

        RoutePointer = (PRTM_ROUTE_INFO) Context2;

        Print("Route Aged Out\n\tRoute Handle = %p\n\tRoute Pointer = %p\n\n",
               RouteHandle,
              RoutePointer);

        // Refresh the route by doing dummy update in place

        Status = RtmLockRoute(RtmRegHandle,
                              RouteHandle,
                              TRUE,
                              TRUE,
                              NULL);

        // Check(Status, 46);

        if (Status == NO_ERROR)
        {
            Status = RtmUpdateAndUnlockRoute(RtmRegHandle,
                                             RouteHandle,
                                             INFINITE,
                                             NULL,
                                             0,
                                             NULL,
                                             &ChangeFlags);

            Check(Status, 47);

            if (!SUCCESS(Status))
            {
                Status = RtmLockRoute(RtmRegHandle,
                                      RouteHandle,
                                      TRUE,
                                      FALSE,
                                      NULL);

                Check(Status, 46);
            }
        }

        Check(RtmReleaseRoutes(RtmRegHandle,
                               1,
                               &RouteHandle),           27);

        break;

    default:
        Status = ERROR_NOT_SUPPORTED;
    }

    return Status;
}

VOID
EntityExportMethod (
    IN  RTM_ENTITY_HANDLE         CallerHandle,
    IN  RTM_ENTITY_HANDLE         CalleeHandle,
    IN  RTM_ENTITY_METHOD_INPUT  *Input,
    OUT RTM_ENTITY_METHOD_OUTPUT *Output
    )
{
    Print("Export Function %2d called on %p: Caller = %p\n\n",
          Input->MethodType,
          CalleeHandle,
          CallerHandle);

    Output->MethodStatus = NO_ERROR;

    return;
}

// Default warnings for unreferenced params and local variables
#pragma warning(default: 4100)
#pragma warning(default: 4101)

#if _DBG_

00 RtmReadAddrFamilyConfig
00 RtmWriteAddrFamilyConfig
00 RtmWriteInstanceConfig

01 RtmRegisterEntity
02 RtmDeregisterEntity
03 RtmGetRegdEntities
04 RtmGetEntityMethods
05 RtmInvokeMethod
06 RtmBlockMethods
07 RtmAddNextHop
08 RtmFindNextHop
09 RtmLockNextHop
10 RtmCreateNextHopEnum
11 RtmGetEnumNextHops
12 RtmGetNextHopInfo
13 RtmReleaseNextHopInfo
14 RtmDelNextHop
15 RtmReleaseNextHops
16 RtmDeleteEnumHandle
17 RtmAddRouteToDest
18 RtmGetExactMatchDestination
19 RtmGetMostSpecificDestination
20 RtmGetLessSpecificDestination
21 RtmGetDestInfo
22 RtmReleaseDestInfo
23 RtmCreateDestEnum
24 RtmGetEnumDests
25 RtmCreateRouteEnum
26 RtmGetEnumRoutes
27 RtmReleaseRoutes
28 RtmIsBestRoute
29 RtmGetExactMatchRoute
30 RtmGetRouteInfo
31 RtmReleaseRouteInfo
32 RtmDelRoute
33 RtmHoldDestination
34 RtmReleaseDests
35 RtmCreateRouteList
36 RtmDeleteRouteList
37 RtmInsertInRouteList
38 RtmCreateRouteListEnum
39 RtmGetListEnumRoutes
40 RtmRegisterForChangeNotification
41 RtmDeregisterFromChangeNotification
42 RtmGetChangedDests
43 RtmReleaseChangedDests
44 RtmReleaseEntities
45 RtmReferenceHandles
46 RtmLockRoute
47 RtmUpdateAndUnlockRoute
48 RtmMarkDestForChangeNotification
49 RtmIsMarkedForChangeNotification

50 RtmCreateRouteTable
51 RtmDeleteRouteTable
52 RtmRegisterClient
53 RtmDeregisterClient
54 RtmAddRoute
55 RtmDeleteRoute
56 RtmCreateEnumerationHandle
57 RtmCloseEnumerationHandle
58 RtmEnumerateGetNextRoute
59 RtmGetFirstRoute
60 RtmGetNextRoute
61 RtmBlockDeleteRoutes
62 RtmBlockConvertRoutesToStatic
63 RtmGetNetworkCount
64 RtmIsRoute
65 RtmLookupIPDestination
66 RtmBlockSetRouteEnable

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\avltrie.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    avltrie.c

Abstract:

    Contains routines for a best matching
    prefix lookup using an AVL trie.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Jun-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#include "avltrie.h"


DWORD
WINAPI
CreateTable(
    IN       UINT                            MaxBytes,
    OUT      HANDLE                         *Table
    )

/*++

Routine Description:

    Create a table that enables to you add and delete prefixes
    (and associated data) and do best matching prefix queries.

Arguments:

    MaxBytes          - Max length of any prefix in the table,

    Table             - Pointer to the table that was created.

Return Value:

    Status of the operation

--*/

{
    PAVL_TRIE         NewTrie;

    ASSERT(sizeof(AVL_CONTEXT) <= sizeof(LOOKUP_CONTEXT));

    ASSERT(sizeof(AVL_LINKAGE) <= sizeof(LOOKUP_LINKAGE));

    if (MaxBytes == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate and initialize a new prefix table
    //

    NewTrie = AllocNZeroMemory(sizeof(AVL_TRIE));
    if (NewTrie == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if _PROF_
    NewTrie->MemoryInUse = sizeof(AVL_TRIE);
#endif

    NewTrie->MaxKeyBytes = MaxBytes;

    *Table = NewTrie;

    return NO_ERROR;
}


DWORD
WINAPI
InsertIntoTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    IN       PLOOKUP_LINKAGE                 Data
    )

/*++

Routine Description:

    Inserts new prefix (and associated data) into a prefix table.

Arguments:

    Table             - Table into which prefix is being inserted,

    NumBits           - Number of bits in the prefix being added,

    KeyBits           - Value of the bits that form the prefix,

    Context           - Search context for the prefix being added,

    Data              - Data associated with this prefix being added.

Return Value:

    Status of the operation

--*/

{
    PAVL_TRIE         Trie;
    PAVL_NODE         PrevNode;
    PAVL_NODE         BestNode;
    PAVL_NODE         NewNode;
    LOOKUP_CONTEXT    Context1;
    AVL_BALANCE       NextChild;
    PLOOKUP_LINKAGE   Dummy;

    Trie = Table;

#if PROF
    Trie->NumInsertions++;
#endif

    //
    // If there is a search context, and we have an
    // update, we can avoid the lookup (common case)
    //

    if (!ARGUMENT_PRESENT(Context))
    {
        Context = &Context1;

        SearchInTable(Table, NumBits, KeyBits, Context, &Dummy);
    }

    BestNode = ((PAVL_CONTEXT) Context)->BestNode;

    if (BestNode && (BestNode->NumBits == NumBits))
    {
        SET_NODEPTR_INTO_DATA(BestNode->Data, NULL);
        
        BestNode->Data = Data;

        SET_NODEPTR_INTO_DATA(Data, BestNode);

        return NO_ERROR;
    }

    NewNode = CreateTrieNode(Trie, NumBits, KeyBits, BestNode, Data);
    if (NewNode)
    {
        PrevNode = ((PAVL_CONTEXT) Context)->InsPoint;

        if (PrevNode)
        {
            NextChild = ((PAVL_CONTEXT) Context)->InsChild;

            PrevNode->Child[NextChild] = NewNode;

            NewNode->Parent = PrevNode;

            ((PAVL_CONTEXT) Context)->BestNode = NewNode;

            // Enumerate in range of the new node & update prefixes
            AdjustPrefixes(Trie, BestNode, NewNode, NewNode, Context);

            // Balance trie if it was thrown off balance
            BalanceAfterInsert(Trie, PrevNode, NextChild);
        }
        else
        {
            Trie->TrieRoot = NewNode;
        }

#if _DBG_
        if (CheckTable(Table) != TRUE)
        {
            DbgBreakPoint();
        }
#endif
        
        return NO_ERROR;
    }
    else // if CreateTrieNode failed
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}


DWORD
WINAPI
DeleteFromTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    )

/*++

Routine Description:

    Deletes a prefix from a prefix table and returns associated data.

Arguments:

    Table             - Table from which prefix is being deleted,

    NumBits           - Number of bits in the prefix being deleted,

    KeyBits           - Value of the bits that form the prefix,

    Context           - Search context for the prefix being deleted,

    Data              - Data associated with this prefix is retd here.

Return Value:

    Status of the operation

--*/

{
    PAVL_TRIE         Trie;
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    LOOKUP_CONTEXT    Context1;
    AVL_BALANCE       NextChild;
    DWORD             Status;

#if _DBG_
    USHORT Depth = 0;
#endif

    Trie = Table;

#if PROF
    Trie->NumDeletions++;
#endif

    //
    // If there is a search context that is valid,
    // we will avoid doing a lookup (common case)
    //

    if (!ARGUMENT_PRESENT(Context))
    {
        Context = &Context1;

        Status = SearchInTable(Table, NumBits, KeyBits, Context, Data);

        if (Status != NO_ERROR)
        {
            return Status;
        }
    }

#if WRN
    NextChild = INVALID;
#endif

    //
    // We should not come here unless the context
    // points accurately to element to be deleted
    //

    CurrNode = ((PAVL_CONTEXT) Context)->BestNode;

    ASSERT(CurrNode && (CurrNode->NumBits == NumBits) &&
           (CompareFullKeys(CurrNode->KeyBits,
                            KeyBits,
                            Trie->MaxKeyBytes) == 0));

    PrevNode = ((PAVL_CONTEXT) Context)->InsPoint;

    ASSERT(PrevNode == CurrNode->Parent);

    if (PrevNode)
    {
        NextChild = ((PAVL_CONTEXT) Context)->InsChild;
    }

    ASSERT(((PrevNode == NULL) && (Trie->TrieRoot == CurrNode))
           || (PrevNode->Child[NextChild] == CurrNode));

    //
    // If the node being deleted has two children,
    // swap its position with its successor node
    //

    if (CurrNode->Child[LEFT] && CurrNode->Child[RIGHT])
    {
#if _DBG_
        if (CheckSubTrie(PrevNode, &Depth) != NO_ERROR)
        {
            DbgBreakPoint();
        }
#endif

        SwapWithSuccessor(Trie, (PAVL_CONTEXT) Context);

#if _DBG_
        if (CheckSubTrie(PrevNode, &Depth) != NO_ERROR)
        {
            DbgBreakPoint();
        }
#endif

        CurrNode  = ((PAVL_CONTEXT) Context)->BestNode;
        PrevNode  = ((PAVL_CONTEXT) Context)->InsPoint;
        NextChild = ((PAVL_CONTEXT) Context)->InsChild;
    }

    ASSERT(((PrevNode == NULL) && (Trie->TrieRoot == CurrNode))
           || (PrevNode->Child[NextChild] == CurrNode));

#if _DBG_
    if (CheckTable(Table) != TRUE)
    {
        DbgBreakPoint();
    }
#endif

    AdjustPrefixes(Trie, CurrNode, CurrNode->Prefix, CurrNode, Context);

#if _DBG_
    if (CheckTable(Table) != TRUE)
    {
        DbgBreakPoint();
    }
#endif


    if (!CurrNode->Child[LEFT])
    {
        // (LEFT Child = NULL) => Promote the right child

        NextNode = CurrNode->Child[RIGHT];
          
        if (NextNode)
        {
            NextNode->Parent = CurrNode->Parent;
        }
    }
    else
    {
        // (RIGHT Child = NULL) => Promote the left child

        ASSERT(!CurrNode->Child[RIGHT]);

        NextNode = CurrNode->Child[LEFT];

        NextNode->Parent = CurrNode->Parent;
    }
  
    if (PrevNode)
    {
        PrevNode->Child[NextChild] = NextNode;

        // Balance trie if it was thrown off balance
        BalanceAfterDelete(Trie, PrevNode, NextChild);
    }
    else
    {
        Trie->TrieRoot = NextNode;
    }

    *Data = CurrNode->Data;

    DestroyTrieNode(Trie, CurrNode);

#if _DBG_
    if (CheckTable(Table) != TRUE)
    {
        DbgBreakPoint();
    }
#endif

    return NO_ERROR;
}


DWORD
WINAPI
SearchInTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    )
{
    PAVL_TRIE         Trie;
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         BestNode;
    AVL_BALANCE       NextChild;
    INT               Comp;
#if _PROF_
    UINT              NumTravsDn;
    UINT              NumTravsUp;  
#endif

    Trie = Table;

    ASSERT(NumBits <= Trie->MaxKeyBytes * BITS_IN_BYTE);

#if _PROF_
    NumTravsDn = 0;
    NumTravsUp = 0;
#endif

    //
    // Go down the trie using key comparisions
    // in search of a prefix matching this key
    //

    CurrNode = Trie->TrieRoot;
    PrevNode = NULL;
    
    NextChild = LEFT;

    BestNode = NULL;

    while (CurrNode)
    {
#if _PROF_
        NumTravsDn++;
#endif
        Comp = CompareFullKeys(KeyBits, 
                               CurrNode->KeyBits,
                               Trie->MaxKeyBytes);

        if ((Comp < 0) || ((Comp == 0) && (NumBits < CurrNode->NumBits)))
        {
            NextChild = LEFT;
        }
        else
        if ((Comp > 0) || (NumBits > CurrNode->NumBits))
        {
            NextChild = RIGHT;

            BestNode = CurrNode;
        }
        else
        {
            BestNode = CurrNode; 
            
            break;
        }
      
        PrevNode = CurrNode;
        CurrNode = PrevNode->Child[NextChild];
    }

    if (!CurrNode)
    {
        //
        // We do not have an exact match - so now
        // we try to refine BestNode guess to get
        // the next best prefix to the new prefix
        //

        while(BestNode)
        {
            if (BestNode->NumBits <= NumBits)
            {
                if (!(ComparePartialKeys(BestNode->KeyBits,
                                         KeyBits,
                                         BestNode->NumBits)))
                {
                    break;
                }
            }

            BestNode = BestNode->Prefix;

#if _PROF_
            if (BestNode)
            {
                NumTravsUp++;
            }
#endif
        }
    }

    if (ARGUMENT_PRESENT(Context))
    {
        ((PAVL_CONTEXT) Context)->BestNode = BestNode;
        ((PAVL_CONTEXT) Context)->InsPoint = PrevNode;
        ((PAVL_CONTEXT) Context)->InsChild = NextChild;
    }

    *Data = BestNode ? BestNode->Data : NULL;

#if _PROF_
    Print("Num Travs Dn = %5d, Travs Up = %5d\n",
             NumTravsDn,
             NumTravsUp);
#endif

    return CurrNode ? NO_ERROR : ERROR_NOT_FOUND;
}


DWORD
WINAPI
BestMatchInTable(
    IN       HANDLE                          Table,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_LINKAGE                *BestData
    )
{
    PAVL_TRIE         Trie;
    PAVL_NODE         CurrNode;
    PAVL_NODE         BestNode;
    INT               Comp;
#if _PROF_
    UINT              NumTravsDn;
    UINT              NumTravsUp;  
#endif

    Trie = Table;

#if _PROF_
    NumTravsDn = 0;
    NumTravsUp = 0;
#endif

    //
    // Go down the trie using key comparisions
    // in search of a prefix matching this key
    //

    CurrNode = Trie->TrieRoot;

    BestNode = NULL;

    while (CurrNode)
    {
#if _PROF_
        NumTravsDn++;
#endif
        Comp = CompareFullKeys(KeyBits, 
                               CurrNode->KeyBits,
                               Trie->MaxKeyBytes);

        if (Comp < 0)
        {
            CurrNode = CurrNode->Child[LEFT];
        }
        else
        {
            BestNode = CurrNode;
            CurrNode = CurrNode->Child[RIGHT];
        }
    }

    //
    // Now we refine the BestNode guess to get
    // the next best prefix to the new prefix
    //

    while(BestNode)
    {
        if (!(ComparePartialKeys(BestNode->KeyBits,
                                 KeyBits,
                                 BestNode->NumBits)))
        {
            break;
        }

        BestNode = BestNode->Prefix;

#if _PROF_
        if (BestNode)
        {
            NumTravsUp++;
        }
#endif
    }

    *BestData = BestNode ? BestNode->Data : NULL;

#if _PROF_
    Print("Num Travs Dn = %5d, Travs Up = %5d\n",
             NumTravsDn,
             NumTravsUp);
#endif

    return NO_ERROR;
}


DWORD
WINAPI
NextMatchInTable(
    IN       HANDLE                          Table,
    IN       PLOOKUP_LINKAGE                 BestData,
    OUT      PLOOKUP_LINKAGE                *NextBestData
    )
{
  PAVL_NODE         BestNode;

  UNREFERENCED_PARAMETER(Table);

  //
  // Assume the input data passed in is valid,
  // and the data is one of the items in trie
  //

  BestNode = GET_NODEPTR_FROM_DATA(BestData);

  *NextBestData = BestNode->Prefix ? BestNode->Prefix->Data : NULL;

  return NO_ERROR;
}


DWORD
WINAPI
EnumOverTable(
    IN       HANDLE                          Table,
    IN OUT   PUSHORT                         StartNumBits,
    IN OUT   PUCHAR                          StartKeyBits,
    IN OUT   PLOOKUP_CONTEXT                 Context     OPTIONAL,
    IN       USHORT                          StopNumBits OPTIONAL,
    IN       PUCHAR                          StopKeyBits OPTIONAL,
    IN OUT   PUINT                           NumItems,
    OUT      PLOOKUP_LINKAGE                *DataItems
    )
{
    PAVL_TRIE         Trie;
    PLOOKUP_LINKAGE   Data;
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    LOOKUP_CONTEXT    Context1;
    AVL_BALANCE       NextChild;
    UINT              ItemsCopied;
    INT               Comp;

    Trie = Table;

    if (!ARGUMENT_PRESENT(Context))
    {
        // No context - initialize local context

        Context = &Context1;

        ((PAVL_CONTEXT) Context)->InsChild = EVEN;
    }

    //
    // If there is a search context that is valid,
    // we will avoid doing a lookup (common case)
    //
    
    if (((PAVL_CONTEXT) Context)->InsChild == EVEN)
    {
        //
        // If we did not find an exact match,
        // remember it by modifying context
        //

        if (SearchInTable(Table,
                          *StartNumBits,
                          StartKeyBits,
                          Context,
                          &Data) != NO_ERROR)
        {
            ((PAVL_CONTEXT) Context)->BestNode = NULL;
        }
    }

    CurrNode  = ((PAVL_CONTEXT) Context)->BestNode;

    //
    // If we did not find an exact match, find the
    // successor ( node with smallest key > key )
    //

    if (!CurrNode)
    {
        PrevNode  = ((PAVL_CONTEXT) Context)->InsPoint;

        if (!PrevNode)
        {
            // No items copied
            *NumItems = 0;

            return ERROR_NO_MORE_ITEMS;
        }

        NextChild = ((PAVL_CONTEXT) Context)->InsChild;

        if (NextChild == LEFT)
        {
            CurrNode = PrevNode;
        }
        else
        {
            CurrNode = PrevNode;
            while (CurrNode->Parent)
            {
                if (CurrNode->Parent->Child[LEFT] == CurrNode)
                {
                    break;
                }

                CurrNode = CurrNode->Parent;
            }
          
            if (CurrNode->Parent)
            {
                CurrNode = CurrNode->Parent;
            }
            else
            {
                // No Items copied
                *NumItems = 0;

                return ERROR_NO_MORE_ITEMS;
            }
        }
    }

    if (*NumItems == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Enumeration Order: Node->LeftTree, Node, Node->RightTree
    //

    ItemsCopied = 0;

    do
    {
        // Check if this dest is before Stop Prefix (if it exists)
        if (StopKeyBits)
        {
            Comp = CompareFullKeys(CurrNode->KeyBits,
                                   StopKeyBits,
                                   Trie->MaxKeyBytes);

            if (Comp == 0)
            {
                if (CurrNode->NumBits <= StopNumBits)
                {
                    Comp = -1;
                }
                else
                {
                    Comp = +1;
                }
            }

            if (Comp > 0)
            {
                // Return Items Copied
                *NumItems = ItemsCopied;
                
                return ERROR_NO_MORE_ITEMS;
            }
        }

        // Copy current data to the output buffer
        DataItems[ItemsCopied++] = CurrNode->Data;
          
        // Find successor (smallest node > this node)

        if (CurrNode->Child[RIGHT])
        {
            NextNode  = CurrNode->Child[RIGHT];

            while (NextNode->Child[LEFT])
            {
                NextNode = NextNode->Child[LEFT];
            }

            CurrNode = NextNode;
        }
        else
        {
            while (CurrNode->Parent)
            {
                if (CurrNode->Parent->Child[LEFT] == CurrNode)
                {
                    break;
                }

                CurrNode = CurrNode->Parent;
            }

            if (CurrNode->Parent)
            {
                CurrNode = CurrNode->Parent;
            }
            else
            {
                // Return Items Copied
                *NumItems = ItemsCopied;

                return ERROR_NO_MORE_ITEMS;
            }
        }
    }
    while (ItemsCopied < *NumItems);

    // Update the temporary context

    ((PAVL_CONTEXT) Context)->BestNode = CurrNode;

    // Update enumeration context by adjusting starting prefix

    if (StartKeyBits)
    {
        *StartNumBits = CurrNode->NumBits;
        CopyFullKeys(StartKeyBits,
                     CurrNode->KeyBits,
                     Trie->MaxKeyBytes);
    }

    // Return Items Copied
    *NumItems = ItemsCopied;

    return NO_ERROR;
}


DWORD
WINAPI
DestroyTable(
    IN       HANDLE                          Table
    )
{
    PAVL_TRIE         Trie;

    Trie = Table;

    if (Trie->TrieRoot != NULL)
    {
        return ERROR_NOT_EMPTY;
    }

    ASSERT(Trie->NumNodes == 0);

#if _PROF_
    Trie->MemoryInUse -= sizeof(AVL_TRIE);
#endif

    FreeMemory(Trie);

    return NO_ERROR;
}


BOOL
WINAPI
CheckTable(
    IN       HANDLE                           Table
    )
{
    BOOL              Status;
    USHORT            Depth;

    Status = CheckSubTrie(((PAVL_TRIE)Table)->TrieRoot, &Depth);

#if _DBG_
    if (SUCCESS(Status))
    {
        Print("\nDepth of the AVL Trie = %lu\n\n", Depth);
    }
#endif

    return SUCCESS(Status) ? TRUE : FALSE;
}


VOID
WINAPI
DumpTable(
    IN       HANDLE                           Table,
    IN       DWORD                           Flags
    )
{
    PAVL_TRIE         Trie;

    Trie = Table;

    Print("---------------- TABLE BEGIN ---------------------------\n\n");

    if (Flags & SUMMARY)
    {
        ;
    }

#if PROF
    if (Flags & STATS)
    {
        Print(
         "Num of Ins = %6lu, Dels = %6lu, Sing Rots = %6lu, Dob Rots = %6lu\n"
         "Num Allocs = %6lu, Free = %6lu, Num Nodes = %6lu, Mem Used = %6lu\n",
         Trie->NumInsertions,
         Trie->NumDeletions,
         Trie->NumSingleRots,
         Trie->NumDoubleRots,
         Trie->NumAllocs,
         Trie->NumFrees,
         Trie->NumNodes,
         Trie->MemoryInUse);
    }
#endif

    if (Flags & ITEMS)
    {
        Print("\n");
        DumpSubTrie(Trie->TrieRoot);
        Print("\n");
    }

    Print("---------------- TABLE  END  ---------------------------\n\n");
}


//
// Helper Functions - used in insert and delete
//

VOID
BalanceAfterInsert(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Longer
    )
{
#if _DBG_
    Print("Balance after Insert Called: %p %02x\n", Node, Longer);
#endif
    
    ASSERT((Longer == LEFT) || (Longer == RIGHT));

    // Go up the tree adjusting the balances
    while (Node->Balance == EVEN)
    {
        Node->Balance = Longer;

        if (!Node->Parent)
        {
            return;
        }

        Longer = (Node->Parent->Child[LEFT] == Node) ? LEFT : RIGHT;
          
        Node = Node->Parent;
    }

    // We made the balance of an ancestor even
    if (Node->Balance != Longer)
    {
        Node->Balance = EVEN;
        return;
    }

    // Unbalanced a ancestor - rotate the tree
    if (Node->Child[Longer]->Balance == Longer)
    {
        SingleRotate(Trie, Node, (AVL_BALANCE) -Longer, &Node);
    }
    else
    {
        DoubleRotate(Trie, Node, (AVL_BALANCE) -Longer, &Node);
    }

    return;
}


VOID
BalanceAfterDelete(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Shorter
    )
{
#if _DBG_
    Print("Balance after Delete Called: %p %02x\n", Node, Shorter);
#endif

    ASSERT((Shorter == LEFT) || (Shorter == RIGHT));

    while (TRUE)
    {
        if (Node->Balance == EVEN)
        {
            Node->Balance = -Shorter;
            return;
        }

        if (Node->Balance == Shorter)
        {
            Node->Balance = EVEN;
        }
        else
        {
            ASSERT(Node->Child[-Shorter] != NULL);

            if (Node->Child[-Shorter]->Balance == -Shorter)
            {
                SingleRotate(Trie, Node, Shorter, &Node);
            }
            else
            if (Node->Child[-Shorter]->Balance ==  Shorter)
            {
                DoubleRotate(Trie, Node, Shorter, &Node);
            }
            else
            {
                SingleRotate(Trie, Node, Shorter, &Node);

                Node->Balance = Shorter;

                Node->Child[Shorter]->Balance = -Shorter;

                return;
            }
        }

        if (!Node->Parent)
        {
            return;
        }

        Shorter = (Node->Parent->Child[LEFT] == Node) ? LEFT : RIGHT;
      
        Node = Node->Parent;
    }
}


VOID
SingleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
)
{
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;

#if _DBG_
    Print("Single Rotate Called: %p %02x\n", UnbalNode, Direction);
#endif

#if PROF
    Trie->NumSingleRots++;
#endif

    ASSERT((Direction == LEFT) || (Direction == RIGHT));

    CurrNode = UnbalNode;

    ASSERT(CurrNode != NULL);

    // To rotate right, we need left child and vice versa
    NextNode = CurrNode->Child[-Direction];

    ASSERT(NextNode != NULL);

    //
    // Promote the child to the unbalanced node's position
    //

    PrevNode = CurrNode->Parent;
    if (PrevNode)
    {
        if (PrevNode->Child[LEFT] == CurrNode)
        {
            PrevNode->Child[LEFT] = NextNode;
        }
        else
        {
            PrevNode->Child[RIGHT] = NextNode;
        }
    }
    else
    {
        Trie->TrieRoot = NextNode;
    }

    NextNode->Parent = PrevNode;

    //
    // Shift a subtree of child node to unbalanced node
    //

    CurrNode->Child[-Direction] = NextNode->Child[Direction];
    if (NextNode->Child[Direction])
    {
        NextNode->Child[Direction]->Parent = CurrNode;
    }
    
    //
    // Push unbalanced node as child of the next node
    // in place of this subtree that was moved before
    //

    NextNode->Child[Direction] = CurrNode;

    CurrNode->Parent = NextNode;

    //
    // Adjust balances that have changed due to rotation.
    // When this is not accurate, the caller adjusts the
    // balances appropriately upon return from this func.
    //

    CurrNode->Balance = NextNode->Balance = EVEN;

    // Return the next node as the new balanced node
    *BalancedNode = NextNode;

    return;
}


VOID
DoubleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
)
{
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    PAVL_NODE         LastNode;

#if _DBG_
    Print("Double Rotate Called: %p %02x\n", UnbalNode, Direction);
#endif

#if PROF
    Trie->NumDoubleRots++;
#endif

    ASSERT((Direction == LEFT) || (Direction == RIGHT));

    CurrNode = UnbalNode;

    ASSERT(CurrNode != NULL);

    //
    // To rotate right, we need left child and its right child
    //

    NextNode = CurrNode->Child[-Direction];

    ASSERT(NextNode != NULL);

    LastNode = NextNode->Child[Direction];
  
    ASSERT(LastNode != NULL);

    //
    // Move grandchild's children to other nodes higher up
    //

    CurrNode->Child[-Direction] = LastNode->Child[Direction];
    if (LastNode->Child[Direction])
    {
        LastNode->Child[Direction]->Parent = CurrNode;
    }

    NextNode->Child[Direction] = LastNode->Child[-Direction];
    if (LastNode->Child[-Direction])
    {
        LastNode->Child[-Direction]->Parent = NextNode;
    }

    //
    // Adjust the balances after the above node movements
    //

    CurrNode->Balance = EVEN;
    NextNode->Balance = EVEN;
    
    if (LastNode->Balance == LEFT)
    {
        if (Direction == LEFT)
        {
            NextNode->Balance = RIGHT;
        }
        else
        {
            CurrNode->Balance = RIGHT;
        }
    }
    else
    if (LastNode->Balance == RIGHT)
    {
        if (Direction == LEFT)
        {
            CurrNode->Balance = LEFT;
        }
        else
        {
            NextNode->Balance = LEFT;
        }
    }

    //
    // Promote grandchild to the unbalanced node's position
    //

    PrevNode = CurrNode->Parent;

    LastNode->Parent = PrevNode;

    if (PrevNode)
    {
        if (PrevNode->Child[LEFT] == CurrNode)
        {
            PrevNode->Child[LEFT] = LastNode;
        }
        else
        {
            PrevNode->Child[RIGHT] = LastNode;
        }
    }
    else
    {
        Trie->TrieRoot = LastNode;
    }

    LastNode->Child[-Direction] = NextNode;
    NextNode->Parent = LastNode;
  
    LastNode->Child[Direction] = CurrNode;
    CurrNode->Parent = LastNode;
    
    LastNode->Balance = EVEN;

    // The grandchild node is the new balanced node now

    *BalancedNode = LastNode;

    return;
}


VOID
SwapWithSuccessor(
    IN       PAVL_TRIE                        Trie,
    IN OUT   PAVL_CONTEXT                     Context
    )
{
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    PAVL_NODE         TempNode1;
    PAVL_NODE         TempNode2;
    AVL_BALANCE       NextChild;

    // Get the context before the successor swap
    CurrNode  = Context->BestNode;
    PrevNode  = Context->InsPoint;
    NextChild = Context->InsChild;

    ASSERT(CurrNode->Child[LEFT] && CurrNode->Child[RIGHT]);

    // Find successor (smallest node > this node)
    NextNode = CurrNode->Child[RIGHT];
    while (NextNode->Child[LEFT])
    {
        NextNode = NextNode->Child[LEFT];
    }

    //
    // Save info for swapping node with its successor
    //

    TempNode1 = NextNode->Parent;

    TempNode2 = NextNode->Child[RIGHT];

    //
    // Promote the successor to the node's position
    //

    NextNode->Balance = CurrNode->Balance;

    NextNode->Parent = PrevNode;
    if (PrevNode)
    {
        PrevNode->Child[NextChild] = NextNode;
    }
    else
    {
        Trie->TrieRoot = NextNode;
    }

    NextNode->Child[LEFT] = CurrNode->Child[LEFT];
    NextNode->Child[LEFT]->Parent = NextNode;

    // Is the successor the immediate right child ?
    if (NextNode != CurrNode->Child[RIGHT])
    {
        NextNode->Child[RIGHT] = CurrNode->Child[RIGHT];

        CurrNode->Parent = TempNode1;

        TempNode1->Child[LEFT] = CurrNode;

        NextChild = LEFT;
    }
    else
    {
        NextNode->Child[RIGHT] = CurrNode;
        
        NextChild = RIGHT;
    }

    NextNode->Child[RIGHT]->Parent = NextNode;

    //
    // Put the node in the successor position
    //

    CurrNode->Child[LEFT] = NULL;

    CurrNode->Child[RIGHT] = TempNode2;

    if (CurrNode->Child[RIGHT])
    {
        CurrNode->Child[RIGHT]->Parent = CurrNode;
          
        CurrNode->Balance = RIGHT;
    }
    else
    {
        CurrNode->Balance = EVEN;
    }

    PrevNode = CurrNode->Parent;

    //
    // Adjust prefix relationship between the
    // node and its successor (if it existed)
    //

    if (NextNode->Prefix == CurrNode)
    {
        NextNode->Prefix = CurrNode->Prefix;
    }

    // Update context to reflect the successor swap
    Context->BestNode = CurrNode;
    Context->InsPoint = PrevNode;
    Context->InsChild = NextChild;
    
    return;
}


VOID
AdjustPrefixes(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        OldNode,
    IN       PAVL_NODE                        NewNode,
    IN       PAVL_NODE                        TheNode,
    IN       PLOOKUP_CONTEXT                  Context
    )
{
    PAVL_NODE         CurrNode;
    UINT              NumItems;
    PLOOKUP_LINKAGE   Dummy;
    DWORD             Status;
    INT               Comp;
#if _PROF_
    UINT              NumChecks;
    UINT              NumAdjust;
#endif


#if _DBG_
    Print("Adjust Prefix Called: %p %p %p\n", OldNode, NewNode, TheNode);
#endif

    //
    // If this is part of an insert, we end our prefixes'
    // adjustment when we pass out of the range of the
    // node being inserted, while in the case of delete
    // the range is determined by the node being deleted
    //
    // This node being deleted or inserted is "TheNode"
    //

    ASSERT((OldNode == TheNode) || (NewNode == TheNode));

#if _PROF_
    NumChecks = 0;
    NumAdjust = 0;
#endif

    NumItems = 1;

    do
    {
#if _PROF_
        NumChecks++;
#endif

        Status = 
          EnumOverTable(Trie, NULL, NULL, Context, 0, NULL, &NumItems, &Dummy);

        CurrNode = ((PAVL_CONTEXT) Context)->BestNode;

        if (CurrNode->NumBits > TheNode->NumBits)
        {
            // Did we reach the end of our range ?
            Comp = ComparePartialKeys(CurrNode->KeyBits,
                                      TheNode->KeyBits,
                                      TheNode->NumBits);

            if (Comp > 0)
            {
                break;
            }
            
            if (CurrNode->Prefix == OldNode)
            {
#if _PROF_
                NumAdjust++;
#endif
                CurrNode->Prefix = NewNode;
            }
        }
    }
    while (Status != ERROR_NO_MORE_ITEMS);

#if _PROF_
    Print("Num Checks = %5d, Num Adjusts = %5d\n",
             NumChecks,
             NumAdjust);
#endif
}

//
// Helper Functions - used in CheckTable
//

DWORD
CheckSubTrie(
    IN       PAVL_NODE                        Node,
    OUT      PUSHORT                          Depth
    )
{
    DWORD             Status;
    USHORT            LDepth;
    USHORT            RDepth;

    Status = NO_ERROR;

    *Depth = 0;

#if WRN
    LDepth = 0;
    RDepth = 0;
#endif
    
    if (Node)
    {
        if (SUCCESS(Status))
        {
            Status = CheckSubTrie(Node->Child[LEFT],  &LDepth);
        }

        if (SUCCESS(Status))
        {
            Status = CheckSubTrie(Node->Child[RIGHT], &RDepth);
        }

        if (SUCCESS(Status))
        {
            Status = CheckTrieNode(Node, LDepth, RDepth);

            if (!SUCCESS(Status))
            {
                Print("Inconsistent information @ Node: %p\n",
                          Node);
            }
        }

        if (SUCCESS(Status))
        {
            *Depth = (USHORT)((LDepth > RDepth) ? (LDepth + 1) : (RDepth + 1));
        }
    }

    return Status;
}

DWORD
CheckTrieNode(
    IN       PAVL_NODE                        Node,
    IN       USHORT                           LDepth,
    IN       USHORT                           RDepth
    )
{
    AVL_BALANCE    Balance;

    // Check the balance first w.r.t LDepth and RDepth
    Balance = RDepth - LDepth;

    if ((Balance < -1) || (Balance > 1))
    {
        Print("Balance out of bounds: %d\n", Balance);

        Print("LDepth = %lu, RDepth = %lu, NodeBal = %d\n",
                  LDepth, RDepth, Node->Balance);

        DumpSubTrie(Node);

        return ERROR_INVALID_DATA;
    }

    if (Balance != Node->Balance)
    {
        Print("Balance inconsistent\n");
        return ERROR_INVALID_DATA;
    }

    // Check its child relationship with its parent
    if (Node->Parent)
    {
        if ((Node->Parent->Child[LEFT] != Node) &&
            (Node->Parent->Child[RIGHT] != Node))
        {
            Print("Parent relationship bad\n");
            return ERROR_INVALID_DATA;
        }
    }

    // Check its prefix relationship with its prefix
    if (Node->Prefix)
    {
        if (Node->Prefix->NumBits >= Node->NumBits)
        {
            Print("Prefix relationship bad @1\n");
            return ERROR_INVALID_DATA;
        }
      
        if (ComparePartialKeys(Node->Prefix->KeyBits,
                               Node->KeyBits,
                               Node->Prefix->NumBits) != 0)
        {
            Print("Prefix relationship bad @2\n");
            return ERROR_INVALID_DATA;
        }
    }

    return NO_ERROR;
}

//
// Helper Functions - used in DumpTable
//

VOID
DumpSubTrie(
    IN       PAVL_NODE                        Node
    )
{
    if (Node)
    {
        DumpSubTrie(Node->Child[LEFT]);
        DumpTrieNode(Node);
        DumpSubTrie(Node->Child[RIGHT]);
    }
}

VOID
DumpTrieNode(
    IN       PAVL_NODE                        Node
    )
{
    USHORT         i;

    if (Node)
    {
        Print("TrieNode @ %p: NB = %8d, KB = ", Node, Node->NumBits);

        for (i = 0; i < (Node->NumBits + BITS_IN_BYTE - 1) / BITS_IN_BYTE; i++)
        {
            Print("%3d.", Node->KeyBits[i]);
        }

        Print("\nLeft = %p, Parent = %p, Right = %p\n",
                 Node->Child[LEFT],
                 Node->Parent,
                 Node->Child[RIGHT]);

        Print("Prefix = %p, Data = %p, Balance = %2d\n\n",
                 Node->Prefix,
                 Node->Data,
                 Node->Balance);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\lkuptst.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lkuptst.c

Abstract:
    Contains routines for testing an implementation
    for the generalized best matching prefix lookup
    interface.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

#include "lkuptst.h"

//
// Main
//

#if LOOKUP_TESTING

__cdecl
main (
    IN      UINT                            argc,
    IN      CHAR                           *argv[]
    )
{
    CHAR    RouteDatabase[MAX_FNAME_LEN];
    FILE    *FilePtr;
    UINT    NumRoutes;
    Route   InputRoutes[MAXROUTES];
    UINT    i;
    DWORD   Status;

    // Initialize input arguments
    RouteDatabase[0] = '\0';

    for ( i = 1; i < argc - 1; i++ )
    {
        if ( ( argv[i][0] == '-' ) || ( argv[i][0] == '/' ) )
        {
            if (argv[i][2])
            {
                Usage();
                return -1;
            }

            switch (toupper(argv[i][1]))
            {
            case 'D':
                lstrcpyn(RouteDatabase, argv[++i], 
                    sizeof(RouteDatabase)/sizeof(RouteDatabase[0]));
                continue;

            default:
                Usage();
                return -1;
            }
        }
        else
        {
            Usage();
            return -1;
        }
    }

    if (RouteDatabase[0] == '\0')
    {
        Usage();
        return -1;
    }

    if ((FilePtr = fopen(RouteDatabase, "r")) == NULL)
    {
        Fatal("Failed open route database with status = %08x\n",
                           ERROR_OPENING_DATABASE);
        return -1;
    }

    // Print("InputRoutes = %p\n", InputRoutes);
    NumRoutes = ReadRoutesFromFile(FilePtr, MAXROUTES, InputRoutes);
    // Print("InputRoutes = %p\n", InputRoutes);

    fclose(FilePtr);

    Status = WorkOnLookup(InputRoutes,
                          NumRoutes);

    return 0;
}

#endif

DWORD
WorkOnLookup (
    IN      Route                          *InputRoutes,
    IN      UINT                            NumRoutes
    )
{
    Route          *OutputRoute;
    HANDLE          Table;
    UINT            Status;
    UINT            i, j;
    PLOOKUP_LINKAGE linkage;

#if PROF
    HANDLE    Thread;
    UINT      Priority;

    PROFVARS;

    Thread   = GetCurrentThread();
    Priority = GetThreadPriority(Thread);

    SetThreadPriority(Thread, THREAD_PRIORITY_TIME_CRITICAL);
#endif

    // Create and Initialize a new lookup table

#if PROF
    INITPROF;
    STARTPROF;
#endif

    Status = CreateTable(NUMBYTES, &Table);

#if PROF
    STOPPROF;
    ADDPROF;
    PRINTPROF;

    Print("Time for an Initialize Table : %.3f ns\n\n", duration);
#endif

    if (!SUCCESS(Status))
    {
        Fatal("Initialize Failed With Status: %08x\n", Status);
    }

    CheckTable(Table);

    // Compute the total time for inserting all routes

#if PROF
    INITPROF;
    STARTPROF;
#endif

    // Add each route one by one to the table
    for (i = 0; i < NumRoutes ; i++)
    {
        // Print("Inserting Route %6d\n", i + 1);

        Status = InsertIntoTable(Table,
                                 LEN(&InputRoutes[i]),
                                 (PUCHAR) &DEST(&InputRoutes[i]),
                                 NULL,
                                 &InputRoutes[i].backptr);

        // CheckTable(Table);

        if (!SUCCESS(Status))
        {
            Print("Inserting item %08x/%08x, but got an error",
                             DEST(&InputRoutes[i]),
                             MASK(&InputRoutes[i]));

            Fatal("Insert Failed With Status: %08x\n", Status);
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

    // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { ; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for an Insert Table : %.3f ns for %d routes\n\n",
                         duration/i, i);
#endif

    CheckTable(Table);

#ifdef _DBG_
    DumpTable(Table, VERBOSE);
#endif

#ifdef _DBG_
    EnumerateAllRoutes(Table);
#endif

#ifdef _DBG_
    ReadAddrAndGetRoute(Table);
#endif

    // Compute the total time for searching all routes
#if PROF
    INITPROF;
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++)
    {
        Status = SearchInTable(Table,
                               LEN(&InputRoutes[i]),
                               (PUCHAR) &DEST(&InputRoutes[i]),
                               NULL,
                               &linkage);

        if (!SUCCESS(Status))
        {
            Print("Searching for %08x/%08x, but got an error\n",
                             DEST(&InputRoutes[i]),
                             MASK(&InputRoutes[i]));

            Fatal("Search Failed With Status: %08x\n", Status);
        }

        OutputRoute = CONTAINING_RECORD(linkage, Route, backptr);

        if (OutputRoute != &InputRoutes[i])
        {
            if ((DEST(OutputRoute) != DEST(&InputRoutes[i])) ||
                (MASK(OutputRoute) != MASK(&InputRoutes[i])))
            {
                Print("Searching for %08x/%08x, but got %08x/%08x\n",
                             DEST(&InputRoutes[i]),
                             MASK(&InputRoutes[i]),
                             DEST(OutputRoute),
                             MASK(OutputRoute));
            }
            else
            {
                // Print("Possible Duplicate Insertion @S\n");
            }
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

    // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { ; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for a  Search Table : %.3f ns for %d routes\n\n",
                              duration/i, i);
#endif

    // Compute the total time for searching all prefixes
#if PROF
    INITPROF;
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++)
    {
        Status = BestMatchInTable(Table,
                                  (PUCHAR) &DEST(&InputRoutes[i]),
                                  &linkage);

        OutputRoute = CONTAINING_RECORD(linkage, Route, backptr);

        if (!SUCCESS(Status))
        {
            Print("Searching for %08x, but got an error\n",
                             DEST(&InputRoutes[i]));

            Fatal("Search Failed With Status: %08x\n", Status);
        }

        if (OutputRoute != &InputRoutes[i])
        {
            if (DEST(OutputRoute) != DEST(&InputRoutes[i]))
            {
                Print("Searching for %08x, but got %08x/%08x\n",
                             DEST(&InputRoutes[i]),
                             DEST(OutputRoute),
                             MASK(OutputRoute));
            }
            else
            {
                // Print("Possible Duplicate Insertion @S\n");
            }
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

    // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { ; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for Prefix in Table : %.3f ns for %d routes\n\n",
                            duration/i, i);
#endif

  // Compute the total time for deleting all routes
#if PROF
    INITPROF;
    STARTPROF;
#endif

    // Del each route one by one to the table
    for (i = 0; i < NumRoutes ; i++)
    {
        // Print("Deleting Route %6d\n", i + 1);

        j = NumRoutes - 1 - i;

        Status = DeleteFromTable(Table,
                                 LEN(&InputRoutes[j]),
                                 (PUCHAR) &DEST(&InputRoutes[j]),
                                 NULL,
                                 &linkage);

        OutputRoute = CONTAINING_RECORD(linkage, Route, backptr);

        // CheckTable(Table);

        if (!SUCCESS(Status))
        {
/*
            Print("Deleting route %08x/%08x, but got an error\n",
                             DEST(&InputRoutes[j]),
                             MASK(&InputRoutes[j]));

            Error("Delete Failed With Status: %08x\n", Status);
*/
        }
        else
        if (OutputRoute != &InputRoutes[j])
        {
            if ((DEST(OutputRoute) != DEST(&InputRoutes[j])) ||
                (MASK(OutputRoute) != MASK(&InputRoutes[j])))
            {
                Print("Deleting route %08x/%08x, but got %08x/%08x\n",
                             DEST(&InputRoutes[j]),
                             MASK(&InputRoutes[j]),
                             DEST(OutputRoute),
                             MASK(OutputRoute));
            }
            else
            {
                // Print("Possible Duplicate Insertion @D\n");
            }
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

  // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { j = NumRoutes - 1 - i; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for a  Delete Table : %.3f ns for %d routes\n\n",
                          duration/i, i);
#endif

    CheckTable(Table);

#ifdef _DBG_
    DumpTable(Table, VERBOSE);
#endif

#ifdef _DBG_
    EnumerateAllRoutes(Table);
#endif

#ifdef _DBG_
    ReadAddrAndGetRoute(Table);
#endif

    // Destory the lookup table

#if PROF
    INITPROF;
    STARTPROF;
#endif

    Status = DestroyTable(Table);

#if PROF
    STOPPROF;
    ADDPROF;
    PRINTPROF;

    Print("Time for a Destroy Table     : %.3f ns\n\n", duration);
#endif

    if (!SUCCESS(Status))
    {
        Fatal("Destroy Failed With Status: %08x\n", Status);
    }

#if PROF
    SetThreadPriority(Thread, Priority);
#endif

    return 0;
}


// Search Testing

VOID
ReadAddrAndGetRoute (
    IN      PVOID                           Table
    )
{
    LOOKUP_CONTEXT  Context;
    FILE           *FilePtr;
    Route          *BestRoute;
    UINT            Status;
    ULONG           Addr;
    PLOOKUP_LINKAGE linkage;

    FilePtr = fopen("con", "r");

    do
    {
        Print("Enter the IP Addr to search for: ");
        ReadIPAddr(FilePtr, &Addr);

        Print("Searching route table for Addr = ");
        PrintIPAddr(&Addr);
        Print("\n");

        Status = SearchInTable(Table,
                               ADDRSIZE,
                               (PUCHAR) &Addr,
                               &Context,
                               &linkage);

        BestRoute = CONTAINING_RECORD(linkage, Route, backptr);

        if (!SUCCESS(Status))
        {
            Fatal("Search Failed With Status: %08x\n", Status);
        }

        Print("The BMP for this addr: \n");
        PrintRoute(BestRoute);
    }
    while (Addr != 0);

    fclose(FilePtr);
}


// Enumerate Testing

VOID
EnumerateAllRoutes (
    IN      PVOID                           Table
    )
{
    LOOKUP_CONTEXT  Context;
    USHORT          NumBits;
    UCHAR           KeyBits[NUMBYTES];
    UINT            Status;
    PLOOKUP_LINKAGE Linkage;
    UINT            NumDests = 1;
    PVOID           DestItems[1];

    Print("\n---------------- ENUMERATION BEGIN ---------------------\n");

    ZeroMemory(&Context, sizeof(LOOKUP_CONTEXT));

    ZeroMemory(&KeyBits, NUMBYTES);
    NumBits = 0;

    do
    {
        Status = EnumOverTable(Table,
                               &NumBits,
                               KeyBits,
                               &Context,
                               0,
                               NULL,
                               &NumDests,
                               &Linkage);

        DestItems[0] = CONTAINING_RECORD(Linkage, Route, backptr);

        if (SUCCESS(Status))
        {
            PrintRoute((Route *)DestItems[0]);
        }
    }
    while (SUCCESS(Status));

    // If it is just an EOF, print last route
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        PrintRoute((Route *)DestItems[0]);
    }

    Print("---------------- ENUMERATION  END  ---------------------\n\n");
}

UINT ReadRoutesFromFile(
    IN      FILE                           *FilePtr,
    IN      UINT                            NumRoutes,
    OUT     Route                          *RouteTable
    )
{
    UINT    i;

    for (i = 0; (!feof(FilePtr)) && (i < NumRoutes) ; )
    {
        // Print("RouteTable = %p\n", RouteTable);
        if (ReadRoute(FilePtr, &RouteTable[i]) != EOF)
        {
            if (RouteTable[i].len)
            {
                ;
            }
            else
            {
                ;
            }

            i++;
        }

        // Print("RouteTable = %p\n", RouteTable);
    }

    if (i >= NumRoutes)
    {
        Error("Number of routes in file exceeds the limit\n",
                   ERROR_MAX_NUM_ROUTES);
    }

    Print("Total number of routes = %lu\n\n", i);

    return i;
}

INT
ReadRoute (
    IN      FILE                           *FilePtr,
    OUT     Route                          *route
    )
{
    UCHAR    currLine[MAX_LINE_LEN];
    UCHAR   *addrBytes;
    UCHAR   *maskBytes;
    UINT     byteRead;
    UINT     byteTemp;
    INT      numConv;
    UINT     i;

    // Zero the input addr, mask, and len
    ClearMemory(route, sizeof(Route));

    // Input format: A1.A2..An/M1.M2..Mn!

    // Read destination IP address
    addrBytes = (UCHAR *) &DEST(route);

    // Read the address A1.A2..An
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Last Line in file
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    // Read the '/' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read destination IP mask
    maskBytes = (UCHAR *) &MASK(route);

    // Read the mask M1.M2..Mn
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Incomplete line
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Mask
        if (numConv == 0)
        {
            break;
        }

        maskBytes[i] = (UCHAR) byteRead;

        // Assume route mask is contiguous
        byteTemp = byteRead;
        while (byteTemp)
        {
            byteTemp &= byteTemp - 1;
            LEN(route)++;
        }
    }

    // Read the ',' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read next hop information
    addrBytes = (UCHAR *) &NHOP(route);

    // Read the next hop N1.N2..Nn
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Incomplete line
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    // Read the ',' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read interface addr/index
    addrBytes = (UCHAR *) &IF(route);

    // Read the interface I1.I2..In
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Incomplete line
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    // Read the ',' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read the route's metric
    fscanf(FilePtr, "%lu", &METRIC(route));

    // Read the rest of the line
    fscanf(FilePtr, "%s\n", currLine);

#ifdef _DBG_
    PrintRoute(route);
#endif

    return TRUE;
}

VOID
PrintRoute (
    IN      Route                          *route
    )
{
    if (NULL_ROUTE(route))
    {
        Print("NULL route\n");
    }
    else
    {
        Print("Route: Len = %2d", LEN(route));

        Print(", Addr = ");
        PrintIPAddr(&DEST(route));

        Print(", NHop = ");
        PrintIPAddr(&NHOP(route));

        Print(", IF = %08x", PtrToInt(IF(route)));

        Print(", Metric = %3lu\n", METRIC(route));
    }
}

INT
ReadIPAddr (
    IN      FILE                           *FilePtr,
    OUT     ULONG                          *addr
    )
{
    UCHAR  *addrBytes;
    UINT    byteRead;
    INT     numConv;
    UINT    i;

    // Initialize the addr variable to 0
    *addr = 0;

    // Cast it for easy byte access
    addrBytes = (UCHAR *)addr;

    // Read the address A1.A2..An
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Last Line in file
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    return 0;
}

VOID
PrintIPAddr (
    IN      ULONG                          *addr
    )
{
    UCHAR    *addrBytes = (UCHAR *) addr;
    UINT     i;

    if (addrBytes)
    {
        for (i = 0; i < NUMBYTES; i++)
        {
            Print("%3d.", addrBytes[i]);
        }
        Print(" ");
    }
    else
    {
        Print("NULL Addr ");
    }
}

VOID
Usage (
    VOID
    )
{
    Fatal("Failed Operation with status = %08x"
          "\n"
          "Tests and measures the IP route lookup mechanism \n"
          "\n"
          "Usage: \n"
          "\t lkuptst \t [ -d routing_database      ]  \n"
          "\n"
          "Options:\n"
          " -d routing_database  \t Name of the route database\n"
          "\n",
          ERROR_WRONG_CMDUSAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\lookup.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lookup.h

Abstract:
    Contains routines for a generalized best
    matching prefix lookup data structure.

Author:
    Chaitanya Kodeboyina (chaitk) 20-Jun-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#if PAT_TRIE

#include "pattrie.c"

#else

#include "avltrie.c"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\apitest.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    apitest.h

Abstract:
    Contains defines for testing the RTMv2 API.

Author:
    Chaitanya Kodeboyina (chaitk) 26-Aug-1998

Revision History:

--*/

#ifndef __APITEST_H
#define __APITEST_H

#include <winsock2.h>

#include <routprot.h>

#include "rtmv2.h"

#include "rtmcnfg.h"

#include "rtmmgmt.h"

#include "rtm.h"

#include "rmrtm.h"

//
// Constants
//

#define MAX_FNAME_LEN               255

#define MAX_LINE_LEN                255

#define BITSINBYTE                  8

#define ADDRSIZE                    32

#define NUMBYTES                    4

#define MAXLEVEL                    32

#define MAX_INSTANCES               10

#define MAX_ADDR_FAMS               10

#define MAX_ENTITIES                10

#define MAX_METHODS                 10

#define MAX_HANDLES                 25

#define MAX_ROUTES                  64000

#define ERROR_IPLMISC_BASE          -100

#define ERROR_WRONG_CMDUSAGE        ERROR_IPLMISC_BASE - 1
#define ERROR_OPENING_DATABASE      ERROR_IPLMISC_BASE - 2
#define ERROR_MAX_NUM_ROUTES        ERROR_IPLMISC_BASE - 3

//
// Structures
//

// Set of exported entity methods (a copy of one in rtmv2.h - but with const 7)
typedef struct _MY_ENTITY_EXPORT_METHODS 
{
  USHORT                   NumMethods;
  RTM_ENTITY_EXPORT_METHOD Methods[7];
} 
MY_ENTITY_EXPORT_METHODS, *PMY_ENTITY_EXPORT_METHODS;


// A structure that represents all entity properties
typedef struct _ENTITY_CHARS
{
    BOOL                            Rtmv2Registration;
    RTM_ENTITY_INFO                 EntityInformation;
    RTM_EVENT_CALLBACK              EventCallback;
    PMY_ENTITY_EXPORT_METHODS       ExportMethods;
    CHAR                            RoutesFileName[MAX_FNAME_LEN];

    RTM_REGN_PROFILE                RegnProfile;

    ULONGLONG                       TotalChangedDests;
}
ENTITY_CHARS, *PENTITY_CHARS;


//
// Useful Misc Macros
//

#define FHalf(B)        (B) >> 4
#define BHalf(B)        (B) & 0xF

#define Print           printf

#define Assert(S)       assert(S)

#define SUCCESS(S)      (S == NO_ERROR)

#define ErrorF(S, F, E)  { \
                            fprintf(stderr, S, F, E); \
                            DebugBreak();             \
                         }

#define FatalF(S, F, E)  { \
                            ErrorF(S, F, E);          \
                            exit(E);                  \
                         }

#define Check(E, F)     { \
                            if (!SUCCESS(E)) \
                            { \
                                FatalF("-%2d- failed with status %lu\n",F,E);\
                            } \
                        }

#define ClearMemory(pm, nb) memset((pm), 0, (nb))


//
// Profiling Macros
//

#if PROF

#define    PROFVARS     LARGE_INTEGER PCStart; /* PerformanceCountStart */ \
                        LARGE_INTEGER PCStop;  /* PerformanceCountStop  */ \
                        LARGE_INTEGER PCFreq;  /* PerformanceCountFreq  */ \
                        double        timer;                               \
                        double        duration;                            \
                                                                           \
                        QueryPerformanceFrequency(&PCFreq);                \
                        // Print("Perf Counter Resolution = %.3f ns\n\n",  \
                        //     (double) 1000 * 1000 * 1000 / PCFreq.QuadPart);

#define    STARTPROF    QueryPerformanceCounter(&PCStart);

#define    STOPPROF     QueryPerformanceCounter(&PCStop);

#define    INITPROF     duration = 0;


#define    ADDPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration += timer;                                   \
                        // Print("Add : %.3f ns\n\n", timer);


#define    SUBPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration -= timer;                                   \
                        // Print("Sub : %.3f ns\n\n", timer);

#define    PRINTPROF    // Print("Total Time Taken To Finish : %.3f ns\n",   \
                        //          duration);

#endif // if PROF


//
// Other Misc Macros
//

// Macro to allocate a RTM_DEST_INFO on the stack

#define ALLOC_RTM_DEST_INFO(NumViews, NumInfos)                              \
        (PRTM_DEST_INFO) _alloca(RTM_SIZE_OF_DEST_INFO(NumViews) * NumInfos)

//
// Prototypes
//

DWORD 
Rtmv1EntityThreadProc (
    IN      LPVOID                          ThreadParam
    );

DWORD
ValidateRouteCallback(
    IN      PVOID                           Route
    );

VOID 
RouteChangeCallback(
    IN      DWORD                           Flags, 
    IN      PVOID                           CurBestRoute, 
    IN      PVOID                           PrevBestRoute
    );

VOID
ConvertRouteToV1Route (
    IN      Route                         *ThisRoute, 
    OUT     RTM_IP_ROUTE                  *V1Route
    );

VOID
ConvertV1RouteToRoute (
    IN      RTM_IP_ROUTE                  *V1Route,
    OUT     Route                         *ThisRoute
    );

DWORD 
Rtmv2EntityThreadProc (
    IN      LPVOID                          ThreadParam
    );

DWORD
EntityEventCallback (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    );

VOID
EntityExportMethod (
    IN      RTM_ENTITY_HANDLE               CallerHandle,
    IN      RTM_ENTITY_HANDLE               CalleeHandle,
    IN      RTM_ENTITY_METHOD_INPUT        *Input,
    OUT     RTM_ENTITY_METHOD_OUTPUT       *Output
    );

#endif // __APITEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\pchrtm.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    pchrtm.h

Abstract:
    Precompiled Header for Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk) 1-Jun-1998

Revision History:

--*/

//
// NT OS Headers
//

// Disable compiler warnings in public header files
#pragma warning(disable: 4115)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>

#include <winsock2.h>

#include <rtutils.h>

#include "sync.h"

#include "rtmv1rtm.h"
#include "mgmrtm.h"

#pragma warning(default: 4115)


//
// RTMv2 Headers
//

// Disable warnings for `do { ; } while (FALSE);'
#pragma warning(disable: 4127)

// Disable warnings for cases of failing to inline
#pragma warning(disable: 4710)

// Disable warnings for probable unreachable code
#pragma warning(disable: 4702)

#include "rtmv2.h"

#include "rtmconst.h"

#include "rtmglob.h"

#include "rtmlog.h"
#include "rtmdbg.h"

#include "rtmmain.h"
#include "rtmcnfg.h"
#include "rtmmgmt.h"

#include "lookup.h"

#include "rtmregn.h"

#include "rtmrout.h"
#include "rtminfo.h"

#include "rtmtimer.h"

#include "rtmenum.h"

#include "rtmchng.h"

#include "rtmlist.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\pattrie.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    avltrie.c

Abstract:

    Contains routines for a best matching
    prefix lookup using an PATRICIA trie.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Jun-1998

Revision History:

--*/

#include "pattrie.h"

DWORD
WINAPI
CreateTable(
    IN       USHORT                          MaxBytes,
    OUT      HANDLE                         *Table
    )
{
    PPAT_TRIE         NewTrie;

    ASSERT(sizeof(PAT_CONTEXT) <= sizeof(LOOKUP_CONTEXT));

    ASSERT(sizeof(PAT_LINKAGE) <= sizeof(DATA_ENTRY));

    if (MaxBytes)
    {
        if (NewTrie = AllocNZeroMemory(sizeof(PAT_TRIE)))
        {
            NewTrie->MaxKeyBytes = (MaxBytes + sizeof(ULONG) - 1) / sizeof(ULONG);

#if _PROF_
            NewTrie->MemoryInUse = sizeof(PAT_TRIE);
#endif

            *Table = NewTrie;

            return NO_ERROR;
        }
        else // if (NewTrie == NULL)
        {
            *Table = NULL;
          
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else // (if MaxBytes == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }
}


DWORD
WINAPI
SearchInTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PDATA_ENTRY                    *Data
)
{
    PPAT_TRIE         Trie;
    PPAT_NODE         PrevNode;
    PPAT_NODE         CurrNode;
    PPAT_NODE         BestNode;
    PAT_CHILD         NextChild;
    ULONG             Key;
#if _PROF_
    UINT              NumTravs1;
    UINT              NumTravs2;
#endif

    Trie = Table;

#if DBG
    if (NumBits > Trie->MaxKeyBytes * BITS_IN_BYTE)
    {
        *Data = NULL;

        return ERROR_INVALID_PARAMETER;
    }
#endif

#if _PROF_
    NumTravs1 = 0;
    NumTravs2 = 0;
#endif

    //
    // Go down the search trie matching the
    // next set of bits in key as u do so
    //

    Key = RtlUlongByteSwap(KeyBits);

    CurrNode = Trie->TrieRoot;
    PrevNode = NULL;

    NextChild = LCHILD;

    BestNode = NULL;

    while (CurrNode)
    {
#if _PROF_
        NumTravs1++;

        if (CurrNode->Data)
        {
            NumTravs2++;
        }
#endif
    }

    return NO_ERROR;
}

DWORD
WINAPI
BestMatchInTable(
    IN       HANDLE                          Table,
    IN       PUCHAR                          KeyBits,
    OUT      PDATA_ENTRY                    *BestData
)
{
    PPAT_TRIE         Trie;
    PPAT_NODE         CurrNode;
    PAT_CHILD         NextChild;
    UINT              BitsLeft;
    ULONG             Key;
    ULONG             CurrMask;
    ULONG             CurrBits;
#if _PROF_
    UINT              NumTravs1;
    UINT              NumTravs2;  
#endif

    *BestData = NULL;

    Trie = Table;

    BytesLeft = Trie->MaxKeyBytes;

#if _PROF_
    NumTravs1 = 0;
    NumTravs2 = 0;
#endif

    //
    // Go down trie after trie until all bits done
    //

    while (BytesLeft)
    {
        //
        // Get the key for the next trie search
        //

        Key = RtlUlongByteSwap(*(ULONG *)KeyBits);

        KeyBits  += sizeof(ULONG);

        BytesLeft -= sizeof(ULONG);

        //
        // Go down the current search trie
        //

        CurrNode = Trie->TrieRoot;

        BitsLeft = sizeof(ULONG) * BITS_IN_BYTE;

        Data = NULL;

        while (CurrNode)
        {
#if _PROF_
            NumTravs1++;

            if (CurrNode->Data)
            {
                NumTravs2++;
            }
#endif

            CurrMask = MaskBits(CurrNode->NumBits);

            CurrBits = CurrNode->KeyBits;

            //
            // Try to match bits in the current node
            //

            if ((Key & CurrMask) != CurrBits)
            {
                // Failed to match this node

                break;
            }

            //
            // Update node with best data so far
            //

            if (CurrNode->Data)
            {
                Data = CurrNode->Data;
            }

            //
            // Go down for more specific match
            //

            BitsLeft -= CurrNode->NumBits;

            Key <<= CurrNode->NumBits;

            NextChild = PickMostSigNBits(Key, 1);

            CurrNode = CurrNode->Child[NextChild];
        }

        //
        // Do we do a full match in this sub-trie
        // & do we have more sub-trees to work on
        //

        if (BitsLeft || (!IS_SUB_TRIE(Data)))
        {
            *BestData = Data;
            break;
        }

        Trie = GET_SUB_TRIE(*BestData);
    }

#if _PROF_
    Print("Num Travs 1 = %5d, Travs 2 = %5d\n",
             NumTravs1,
             NumTravs2);
#endif

    return BitsLeft ? ERROR_NOT_FOUND : NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtm1to2.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtm1to2.h

Abstract:

    Contains definitions/macros that wrap RTMv2
    in the RTMv1 API.

Author:

    Chaitanya Kodeboyina (chaitk)   13-Oct-1998

Revision History:

--*/

#ifndef __ROUTING_RTM1TO2_H__
#define __ROUTING_RTM1TO2_H__

#include <winsock2.h>

#include <rtm.h>

#include <rmrtm.h>

// Protocol Id for the default wrapper registration
#define V1_WRAPPER_REGN_ID   0xA1B2C3D4

// Protocol instance for a v1 entity registration
#define V1_PROTOCOL_INSTANCE 0xABCD1234

//
// Misc defines for wrapper picked from rtmv2p.h
//

#define MAXTICKS             MAXULONG

// Basic route info, present in routes of all types

// Disable warnings for unnamed structs
#pragma warning(disable : 4201)  

typedef struct
{
    ROUTE_HEADER;
} 
RTM_XX_ROUTE, *PRTM_XX_ROUTE;

#pragma warning(default : 4201)  

//
// Extending certain V1 flags in the wrapper
//

#define RTM_ONLY_OWND_ROUTES   0x00000010

//
// Mapping of v1 address families to standard ids
//

const USHORT ADDRESS_FAMILY[2] =
{
    AF_IPX,         // RTM_PROTOCOL_FAMILY_IPX = 0
    AF_INET         // RTM_PROTOCOL_FAMILY_IP  = 1
};

//
// Address sizes of supported address families
//

#define IPX_ADDR_SIZE        6
#define IP_ADDR_SIZE         4

const USHORT ADDRESS_SIZE[2] =
{
    IPX_ADDR_SIZE,   // RTM_PROTOCOL_FAMILY_IPX = 0
    IP_ADDR_SIZE     // RTM_PROTOCOL_FAMILY_IP  = 1
};

//
// Forward declarations for structs
//
typedef struct _V1_REGN_INFO *PV1_REGN_INFO;


//
// Global info for RTMv1 - v2 wrapper
//

typedef struct _V1_GLOBAL_INFO
{
    CRITICAL_SECTION  PfRegnsLock[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // Lock guards the registrations list

    LIST_ENTRY        PfRegistrations[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // List of regns on Protocol family

    PV1_REGN_INFO     PfRegInfo[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // Default regn for this Protocol family

    PROUTE_VALIDATE_FUNC
                      PfValidateRouteFunc[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // Func to validate route, fill priority
}
V1_GLOBAL_INFO, *PV1_GLOBAL_INFO;


//
// RTMv2 to v1 Registration Wrapper
//

typedef struct _V1_REGN_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    LIST_ENTRY        RegistrationsLE;  // Linkage on list of registrations

    DWORD             ProtocolFamily;   // This maps to RTMv2's address family

    DWORD             RoutingProtocol;  // Routing protocol (RIP, OSPF...)

    DWORD             Flags;            // RTMv1 Registration flags

    RTM_ENTITY_HANDLE Rtmv2RegHandle;   // Handle to actual RTMv2 registration

    RTM_REGN_PROFILE  Rtmv2Profile;     // RTMv2 registration profile

    UINT              Rtmv2NumViews;    // Number of views in the V2 instance

    CRITICAL_SECTION  NotificationLock; // RTMv1 Notification Lock

    PROUTE_CHANGE_CALLBACK
                      NotificationFunc; // RTMv1 Notification Callback

    HANDLE            NotificationEvent;// RTMv1 Notification Event

    RTM_NOTIFY_HANDLE Rtmv2NotifyHandle;// RTMv2 Notification Handle
}
V1_REGN_INFO, *PV1_REGN_INFO;


//
// RTMv1 Route Info structure
//

typedef union {
    RTM_IPX_ROUTE     IpxRoute;         // IPX route info structure

    RTM_IP_ROUTE      IpRoute;          // IP route info structure

    RTM_XX_ROUTE      XxRoute;          // The Common route header

    UCHAR             Route[1];         // Generic route info structure
}
V1_ROUTE_INFO, *PV1_ROUTE_INFO;


//
// RTMv2 to v1 Enumeration Wrapper
//

typedef struct _V1_ENUM_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    DWORD             ProtocolFamily;   // This maps to RTMv2's address family

    DWORD             EnumFlags;        // RTMv1 Enumeration flags

    V1_ROUTE_INFO     CriteriaRoute;    // V1 Criteria route for this enum

    CRITICAL_SECTION  EnumLock;         // To serialize enumeration calls

    RTM_ENUM_HANDLE   Rtmv2RouteEnum;   // Handle to the RTMv2 route enum
}
V1_ENUM_INFO, *PV1_ENUM_INFO;

//
// Miscellaneos Func Pointer Defs
//

typedef BOOL (*PFUNC) (PVOID p, PVOID q, PVOID r);


//
// Macros to validate RTMv1 to v2 wrapper handles
//

#define V1_REGN_FROM_HANDLE(V1RegnHandle)                                   \
            (PV1_REGN_INFO) GetObjectFromHandle(V1RegnHandle, V1_REGN_TYPE)

#define VALIDATE_V1_REGN_HANDLE(V1RegnHandle, pV1Regn)                      \
            *pV1Regn = V1_REGN_FROM_HANDLE(V1RegnHandle);                   \
            if ((!*pV1Regn))                                                \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


#define V1_ENUM_FROM_HANDLE(V1EnumHandle)                                   \
            (PV1_ENUM_INFO) GetObjectFromHandle(V1EnumHandle, V1_ENUM_TYPE)

#define VALIDATE_V1_ENUM_HANDLE(V1EnumHandle, pV1Enum)                      \
            *pV1Enum = V1_ENUM_FROM_HANDLE(V1EnumHandle);                   \
            if ((!*pV1Enum))                                                \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \

//
// Macros to acquire locks in the structures above
//

#define ACQUIRE_V1_REGNS_LOCK(ProtocolFamily)                               \
            ACQUIRE_LOCK(&V1Globals.PfRegnsLock[ProtocolFamily])

#define RELEASE_V1_REGNS_LOCK(ProtocolFamily)                               \
            RELEASE_LOCK(&V1Globals.PfRegnsLock[ProtocolFamily])


#define ACQUIRE_V1_ENUM_LOCK(V1Enum)                                        \
            ACQUIRE_LOCK(&V1Enum->EnumLock)

#define RELEASE_V1_ENUM_LOCK(V1Enum)                                        \
            RELEASE_LOCK(&V1Enum->EnumLock)


#define ACQUIRE_V1_NOTIFY_LOCK(V1Regn)                                      \
            ACQUIRE_LOCK(&V1Regn->NotificationLock)

#define RELEASE_V1_NOTIFY_LOCK(V1Regn)                                      \
            RELEASE_LOCK(&V1Regn->NotificationLock)


//
// Macros to convert RTMv1 to RTMv2 structs and vice versa
//

#define MakeNetAddress(Network, ProtocolFamily, TempUlong, NetAddr)        \
            MakeNetAddressForIP(Network, TempUlong, NetAddr)

#define MakeNetAddressForIP(Network, TempUlong, NetAddr)                   \
            (NetAddr)->AddressFamily = AF_INET;                            \
            (NetAddr)->NumBits = 0;                                        \
                                                                           \
            TempUlong =                                                    \
                 RtlUlongByteSwap(((PIP_NETWORK)(Network))->N_NetMask);    \
                                                                           \
            while (TempUlong)                                              \
            {                                                              \
                ASSERT(TempUlong & 0x80000000);                            \
                TempUlong <<= 1;                                           \
                (NetAddr)->NumBits++;                                      \
            }                                                              \
                                                                           \
            (* (ULONG *) ((NetAddr)->AddrBits)) =                          \
                                  ((PIP_NETWORK) (Network))->N_NetNumber;  \


#define MakeHostAddress(HostAddr, ProtocolFamily, NetAddr)                 \
            MakeHostAddressForIP(HostAddr, NetAddr)

#define MakeHostAddressForIP(HostAddr, NetAddr)                            \
            (NetAddr)->AddressFamily = AF_INET;                            \
            (NetAddr)->NumBits = IP_ADDR_SIZE * BITS_IN_BYTE;              \
            (* (ULONG *) ((NetAddr)->AddrBits)) = (* (ULONG *) HostAddr);  \

//
// Misc V1 Macros
//

// Macro that gets the network address in the route

#define V1GetRouteNetwork(Route, ProtocolFamily, Network)                   \
        if (ProtocolFamily == RTM_PROTOCOL_FAMILY_IP)                       \
        {                                                                   \
            (*Network) = (PVOID) &((PRTM_IP_ROUTE)  Route)->RR_Network;     \
        }                                                                   \
        else                                                                \
        {                                                                   \
            (*Network) = (PVOID) &((PRTM_IPX_ROUTE) Route)->RR_Network;     \
        }                                                                   \



// Macro that gets the addr of flags in the route

#define V1GetRouteFlags(Route, ProtocolFamily, Flags)                       \
        if (ProtocolFamily == RTM_PROTOCOL_FAMILY_IP)                       \
        {                                                                   \
            Flags =                                                         \
              &((PRTM_IP_ROUTE)Route)->RR_FamilySpecificData.FSD_Flags;     \
        }                                                                   \
        else                                                                \
        {                                                                   \
            Flags =                                                         \
              &((PRTM_IPX_ROUTE)Route)->RR_FamilySpecificData.FSD_Flags;    \
        }                                                                   \


// Macro that copies one v1 route to another

#define V1CopyRoute(RouteDst, RouteSrc, ProtocolFamily)                     \
        if (ProtocolFamily == RTM_PROTOCOL_FAMILY_IP)                       \
        {                                                                   \
            CopyMemory(RouteDst, RouteSrc, sizeof(RTM_IP_ROUTE));           \
        }                                                                   \
        else                                                                \
        {                                                                   \
            CopyMemory(RouteDst, RouteSrc, sizeof(RTM_IPX_ROUTE));          \
        }                                                                   \

//
// Misc V2 Macros
//

// Macro to allocate a set of handles on the stack

#define ALLOC_HANDLES(NumHandles)                                           \
        (HANDLE *) _alloca(sizeof(HANDLE) * NumHandles)                     \


// Macro to allocate a RTM_DEST_INFO on the stack

#define ALLOC_DEST_INFO(NumViews, NumInfos)                                 \
        (PRTM_DEST_INFO) _alloca(RTM_SIZE_OF_DEST_INFO(NumViews) * NumInfos)

// Macro to allocate a RTM_ROUTE_INFO on the stack

#define ALLOC_ROUTE_INFO(NumNextHops, NumInfos)                             \
        (PRTM_ROUTE_INFO) _alloca((sizeof(RTM_ROUTE_INFO) +                 \
                                  (NumNextHops - 1) *                       \
                                   sizeof(RTM_NEXTHOP_HANDLE)) * NumInfos)  \

// Misc Macros

#define SWAP_POINTERS(p1, p2)   { PVOID p = p1; p1 = p2; p2 = p; }

//
// Callback that converts RTMv2 events to RTMv1
//

DWORD
WINAPI
V2EventCallback (
    IN      RTM_ENTITY_HANDLE               Rtmv2RegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    );

//
// Other helper functions
//

HANDLE 
RtmpRegisterClient (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           RoutingProtocol,
    IN      PROUTE_CHANGE_CALLBACK          ChangeFunc  OPTIONAL,
    IN      HANDLE                          ChangeEvent OPTIONAL,
    IN      DWORD                           Flags
    );

DWORD 
BlockOperationOnRoutes (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute,
    IN      PFUNC                           RouteOperation
    );

BOOL
MatchCriteriaAndCopyRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum  OPTIONAL,
    OUT     PVOID                           V1Route OPTIONAL
    );

#define MatchCriteria(R, H, E) MatchCriteriaAndCopyRoute(R, H, E, NULL)

BOOL
MatchCriteriaAndDeleteRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    );

BOOL
MatchCriteriaAndChangeOwner (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    );

BOOL
MatchCriteriaAndEnableRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    );

BOOL
CopyNonLoopbackIPRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_DEST_INFO                  V2DestInfo,
    OUT     PVOID                           V1Route
    );

VOID 
MakeV2RouteFromV1Route (
    IN     PV1_REGN_INFO                   V1Regn,
    IN     PVOID                           V1Route,
    IN     PRTM_NEXTHOP_HANDLE             V2NextHop,
    OUT    PRTM_NET_ADDRESS                V2DestAddr  OPTIONAL,
    OUT    PRTM_ROUTE_INFO                 V2RouteInfo OPTIONAL
    );

VOID 
MakeV2NextHopFromV1Route (
    IN     PV1_REGN_INFO                   V1Regn,
    IN     PVOID                           V1Route,
    OUT    PRTM_NEXTHOP_INFO               V2NextHop
    );

VOID
MakeV1RouteFromV2Dest (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_DEST_INFO              DestInfo,
    OUT         PVOID                       V1Route
    );

DWORD 
MakeV1RouteFromV2Route (
    IN     PV1_REGN_INFO                   V1Regn,
    IN     PRTM_ROUTE_INFO                 V2Route,
    OUT    PVOID                           V1Route
    );

#endif // __ROUTING_RTM1TO2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\makefile.inc ===
$(O)\rtmmsg.mc: ..\mgm\log.h
    mapmsg NET IPMGMLOG_BASE ..\mgm\log.h > $(O)\rtmmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtm1to2.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtm1to2.c

Abstract:

    Contains routines that wrap RTMv2 functions
    in the RTMv1 API.

Author:

    Chaitanya Kodeboyina (chaitk)   13-Oct-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#if WRAPPER

#include "rtm1to2.h"

// Wrapper Globals
V1_GLOBAL_INFO  V1Globals;

DWORD
RtmCreateRouteTable (
    IN      DWORD                           ProtocolFamily,
    IN      PRTM_PROTOCOL_FAMILY_CONFIG     Config
    )

/*++

Routine Description:

    Triggers the creation of a new route table corresponding
    to a protocol family (same as address family in RTMv2) 
    in the default instance of RTMv2 by performing the very 
    first registration in that protocol family.

    This default registration is also used for mapping RTMv1
    operations that do not require a registration handle 
    (V1 enums etc.) to their corresponding RTMv2 operations.
    Note that all RTMv2 calls require a registration handle.

    This call also creates a list of all V1 registrations at
    any time. This is used to automatically deregister all 
    RTMv1 registrations before destroying this route table.

    We also set up the notification of changes in best routes
    to the router manager (RM) that invoked this function.

Arguments:

    ProtocolFamily - Protocol Family (same as v2 address family)

    Config         - Protocol family's router manager callbacks
                     (Only the "route change callback" and the
                     "validate route callback" funcs are used)

Return Value:

    Status of the operation

--*/

{
    HANDLE           V1RegHandle;
    DWORD            Status;

    //
    // Validate incoming parameters before action
    //

    if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (V1Globals.PfRegInfo[ProtocolFamily])
    {
        return ERROR_ALREADY_EXISTS;
    }

    //
    // Initialize the lock that guards regns list
    //

    try
    {
        InitializeCriticalSection(&V1Globals.PfRegnsLock[ProtocolFamily]);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize list of regns on protocol family
    InitializeListHead(&V1Globals.PfRegistrations[ProtocolFamily]);

    //
    // Register on behalf of this protocol family
    //
    // This handle is also used for ops that
    // need a handle in RTM v2 but not in v1
    //
    // We are also setting up best route change
    // notifications for RM using its callback
    //

    V1RegHandle = RtmpRegisterClient(ProtocolFamily,
                                     V1_WRAPPER_REGN_ID,
                                     Config->RPFC_Change,
                                     NULL,
                                     0);
    if (V1RegHandle == NULL)
    {
        Status = GetLastError();

        DeleteCriticalSection(&V1Globals.PfRegnsLock[ProtocolFamily]);

        return Status;
    }

    V1Globals.PfValidateRouteFunc[ProtocolFamily] = Config->RPFC_Validate;

    V1Globals.PfRegInfo[ProtocolFamily] = GET_POINTER_FROM_HANDLE(V1RegHandle);

    return NO_ERROR;
}


DWORD
RtmDeleteRouteTable (
    IN      DWORD                           ProtocolFamily
    )

/*++

Routine Description:

    Deletes the route table for a particular address family
    after deregistering any active V1 registrations present.
    Note that atleast 1 registration (the wrapper's default
    registration) is active at this point.

    We assume that all RTMv2 protocols have deregistered by
    the time this function is called. We also assume that
    no RTMv1 protocols are trying to register or deregister
    while this function is executing, as we do not hold the
    lock that protects the list of registrations.

Arguments:

    ProtocolFamily - Protocol Family whose table is deleted.

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO    Regn;
    PLIST_ENTRY      Regns;
    DWORD            Status;

    //
    // Validate incoming parameters before action
    //

    if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (V1Globals.PfRegInfo[ProtocolFamily] == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Deregister existing regns on protocol family
    // including the default regn of the V1 wrapper
    //

    Regns = &V1Globals.PfRegistrations[ProtocolFamily];

    // We have atleast the default regn available
    ASSERT(!IsListEmpty(Regns));

    while (!IsListEmpty(Regns))
    {
        Regn = CONTAINING_RECORD(Regns->Flink, V1_REGN_INFO, RegistrationsLE);

        Status = RtmDeregisterClient(MAKE_HANDLE_FROM_POINTER(Regn));

        ASSERT(Status == NO_ERROR);
    }

    // Free the lock used to guard the regns list
    DeleteCriticalSection(&V1Globals.PfRegnsLock[ProtocolFamily]);

    V1Globals.PfRegInfo[ProtocolFamily] = NULL;

    return NO_ERROR;
}


HANDLE 
WINAPI
RtmRegisterClient (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           RoutingProtocol,
    IN      HANDLE                          ChangeEvent OPTIONAL,
    IN      DWORD                           Flags
    )

/*++

Routine Description:

    Registers an RTMv1 client with the default instance and
    given protocol family in RTMv2. Also sets up notification
    of best route changes if caller asks for it.

Arguments:

    ProtocolFamily  - Protocol Family we are registering with.

    RoutingProtocol - Protocol ID of registering component.

    ChangeEvent     - Event to indicate changes in best routes.

    Flags           - RTM_PROTOCOL_SINGLE_ROUTE indicates that
                      this protocol adds atmost one route per
                      destination.

Return Value:

    Registration Handle or NULL ( Use GetLastError() to get error )

--*/

{
    return RtmpRegisterClient(ProtocolFamily,
                              RoutingProtocol,
                              NULL,
                              ChangeEvent,
                              Flags);
}

HANDLE 
RtmpRegisterClient (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           RoutingProtocol,
    IN      PROUTE_CHANGE_CALLBACK          ChangeFunc  OPTIONAL,
    IN      HANDLE                          ChangeEvent OPTIONAL,
    IN      DWORD                           Flags
    )

/*++

Routine Description:

    Registers an RTMv1 client with the default instance and
    given protocol family in RTMv2. Also sets up notification
    of best route changes if caller asks for it.

    Note that any protocol that needs to be indicated of best
    -route changes can either specify an event OR a callback
    for this purpose.

Arguments:

    ProtocolFamily  - Protocol Family we are registering with.

    RoutingProtocol - Protocol ID of registering component.

    ChangeFunc      - Callback to indicates changes in best routes.

    ChangeEvent     - Event to indicate changes in best routes.

    Flags           - RTM_PROTOCOL_SINGLE_ROUTE indicates that 
                      this component keeps atmost one route per 
                      network (destination in RTMv2) in RTM.

Return Value:

    Registration Handle or NULL ( Use GetLastError() to get error )

--*/

{
    PV1_REGN_INFO    V1Regn;
    RTM_ENTITY_INFO  EntityInfo;
    BOOL             LockInited;
    BOOL             Success;
    DWORD            Status;

    //
    // Check parameters for validity (in v1 bounds)
    //

    if ((ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES) ||
        (Flags & (~RTM_PROTOCOL_SINGLE_ROUTE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Create a RTMv1->v2 registration wrapper
    //

    V1Regn = (PV1_REGN_INFO) AllocNZeroObject(sizeof(V1_REGN_INFO));

    if (V1Regn == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    LockInited = FALSE;

    do
    {
#if DBG_HDL
        V1Regn->ObjectHeader.TypeSign = V1_REGN_ALLOC;
#endif
        //
        // Register with RTMv2 after mapping input params to RTMv2
        //

        // All v1 registrations fall in default Instance in RTMv2
        EntityInfo.RtmInstanceId = 0; 

        // We need to convert v1 protocol family id to winsock id
        EntityInfo.AddressFamily = ADDRESS_FAMILY[ProtocolFamily];

        // All v1 protocols can register atmost once with RTMv2
        // as they all will use the same "Protocol Instance Id"
        EntityInfo.EntityId.EntityProtocolId = RoutingProtocol;
        EntityInfo.EntityId.EntityInstanceId = V1_PROTOCOL_INSTANCE;

        Status = RtmRegisterEntity(&EntityInfo,
                                   (PRTM_ENTITY_EXPORT_METHODS) NULL,
                                   V2EventCallback,
                                   FALSE,
                                   &V1Regn->Rtmv2Profile,
                                   &V1Regn->Rtmv2RegHandle);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Cache RTMv1 specific params in RTMv1 regn
        //

        V1Regn->ProtocolFamily = ProtocolFamily;

        V1Regn->RoutingProtocol = RoutingProtocol;

        V1Regn->Flags = Flags;

        //
        // Store actual number of views in this regn
        //

        V1Regn->Rtmv2NumViews = V1Regn->Rtmv2Profile.NumberOfViews;

        //
        // Is caller interested in being notified of best route changes ?
        //

        if (/*ARGUMENT_PRESENT*/(ChangeFunc) || ARGUMENT_PRESENT(ChangeEvent))
        {
            if (/*ARGUMENT_PRESENT*/(ChangeFunc))
            {
                // The caller to be notified of changes directly

                V1Regn->NotificationFunc = ChangeFunc;
            }
            else
            {
                // Caller to be notified of changes with an event

                Success = ResetEvent(ChangeEvent);

                if (!Success)
                {
                    Status = GetLastError();
                    break;
                }

                V1Regn->NotificationEvent = ChangeEvent;

                // Initialize lock to syncronize set/reset event
                
                try
                {
                    InitializeCriticalSection(&V1Regn->NotificationLock);

                    LockInited = TRUE;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

            //
            // Register for change notifications with v2
            //

            Status = 
                RtmRegisterForChangeNotification(V1Regn->Rtmv2RegHandle,
                                                 RTM_VIEW_MASK_UCAST,
                                                 RTM_CHANGE_TYPE_ALL,
                                                 (PVOID) V1Regn,
                                                 &V1Regn->Rtmv2NotifyHandle);

            if (Status != NO_ERROR)
            {
                break;
            }
        }

        //
        // Stick it in the list of regns on protocol family
        //

        ACQUIRE_V1_REGNS_LOCK(ProtocolFamily);

        InsertHeadList(&V1Globals.PfRegistrations[ProtocolFamily],
                       &V1Regn->RegistrationsLE);

        RELEASE_V1_REGNS_LOCK(ProtocolFamily);

        return MAKE_HANDLE_FROM_POINTER(V1Regn);
    }
    while (FALSE);

    //
    // Some error occured - clean up and return NULL
    //

    if (LockInited)
    {
        DeleteCriticalSection(&V1Regn->NotificationLock);
    }

    if (V1Regn->Rtmv2RegHandle)
    {
        ASSERT(RtmDeregisterEntity(V1Regn->Rtmv2RegHandle) == NO_ERROR);
    }

#if DBG_HDL
    V1Regn->ObjectHeader.TypeSign = V1_REGN_FREED;
#endif

    FreeObject(V1Regn);

    SetLastError(Status);

    return NULL;
}


DWORD 
WINAPI
RtmDeregisterClient (
    IN      HANDLE                          ClientHandle
    )

/*++

Routine Description:

    Deregisters an RTMv1 client from the default instance and
    given protocol family in RTMv2. Also deletes any state
    that the RTMv1 caller left out - routes, nexthops etc.
    and deregisters any change notifications set up during
    registration time.

Arguments:

    ClientHandle - RTMv1 registration handle being deregistered.

Return Value:

    Status of the operation.

--*/

{
    RTM_NEXTHOP_HANDLE  EnumHandle;
    PV1_REGN_INFO       V1Regn;
    HANDLE             *Handles;
    UINT                NumHandles, i;
    BOOL                Success;
    DWORD               Status;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    //
    // Remove the regn from the list of regns on protocol family
    //

    ACQUIRE_V1_REGNS_LOCK(V1Regn->ProtocolFamily);

    RemoveEntryList(&V1Regn->RegistrationsLE);

    RELEASE_V1_REGNS_LOCK(V1Regn->ProtocolFamily);

    do
    {
        // Allocate this var-size handles array on the stack
        Handles = ALLOC_HANDLES(V1Regn->Rtmv2Profile.MaxHandlesInEnum);

        //
        // Remove all the next-hops added by this client protocol 
        //

        Status = RtmCreateNextHopEnum(V1Regn->Rtmv2RegHandle,
                                      0,
                                      NULL,
                                      &EnumHandle);
        if (Status != NO_ERROR)
        {
            break;
        }

        do 
        {
            NumHandles = V1Regn->Rtmv2Profile.MaxHandlesInEnum;

            Status = RtmGetEnumNextHops(V1Regn->Rtmv2RegHandle,
                                        EnumHandle,
                                        &NumHandles,
                                        Handles);
        
            for (i = 0; i < NumHandles; i++)
            {
                ASSERT(RtmDeleteNextHop(V1Regn->Rtmv2RegHandle,
                                        Handles[i],
                                        NULL) == NO_ERROR);
            }
        }
        while (Status == NO_ERROR);

        ASSERT(RtmDeleteEnumHandle(V1Regn->Rtmv2RegHandle, 
                                   EnumHandle) == NO_ERROR);

        //
        // Clean up resources allocated for change processing
        //

        if (V1Regn->NotificationFunc || V1Regn->NotificationEvent)
        {
            // Stop the notification of changes to best routes
            
            Status = 
                RtmDeregisterFromChangeNotification(V1Regn->Rtmv2RegHandle,
                                                    V1Regn->Rtmv2NotifyHandle);
            if (Status != NO_ERROR)
            {
                break;
            }
    
            if (V1Regn->NotificationEvent)
            {
                // Free the lock that serves in syncronization
                DeleteCriticalSection(&V1Regn->NotificationLock);

                // Reset the event to indicate no more changes
                Success = ResetEvent(V1Regn->NotificationEvent);
    
                if (!Success)
                {
                    Status = GetLastError();
                    break;
                }
            }
        }

        //
        // Deregister with RTMv2 using RTMv2 regn handle
        //
        
        Status = RtmDeregisterEntity(V1Regn->Rtmv2RegHandle);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Free resources allocated for the regn wrapper
        //

#if DBG_HDL
        V1Regn->ObjectHeader.TypeSign = V1_REGN_FREED;
#endif

        FreeObject(V1Regn);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error occured - clean up and return status
    //

    ASSERT(FALSE);

    return Status;
}


DWORD 
WINAPI
RtmAddRoute (
    IN      HANDLE                          ClientHandle,
    IN      PVOID                           Route,
    IN      DWORD                           TimeToLive,
    OUT     DWORD                          *Flags         OPTIONAL,
    OUT     PVOID                           CurBestRoute  OPTIONAL,
    OUT     PVOID                           PrevBestRoute OPTIONAL
)

/*++

Routine Description:

    Adds a route to RTMv2 after converting the RTMv1 route to
    RTMv2 format.

    We create a next hop object if one does not exist, and add
    a route through it.

Arguments:

    ClientHandle  - RTMv1 registration handle of the caller.

    Route         - Info for V1 route being added/updated.

    TimeToLive    - Time for which the route is kept in RTM
                    before being deleted (value is seconds).

    THE FOLLOWING PARAMETERS ARE OBSOLETE IN THIS WRAPPER

    Flags         - Returns error if this param is not NULL.

    CurBestRoute  - Returns error if this param is not NULL.

    PrevBestRoute - Returns error if this param is not NULL.

Return Value:

    Status of the operation.

--*/

{
    PV1_REGN_INFO      V1Regn;
    RTM_NET_ADDRESS    DestAddr;
    RTM_ROUTE_INFO     V2RouteInfo;
    RTM_NEXTHOP_INFO   V2NextHopInfo;
    RTM_NEXTHOP_HANDLE V2NextHop;
    DWORD              ChangeFlags;
    DWORD              Status;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    // Protocols specify Flags parameter but don't use it

    *Flags = RTM_NO_CHANGE;

    if (ARGUMENT_PRESENT(CurBestRoute) || ARGUMENT_PRESENT(PrevBestRoute))
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Call back into RM to validate route, set priority
    //

    Status = V1Globals.PfValidateRouteFunc[V1Regn->ProtocolFamily](Route);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Create a new next-hop with this interface
    // (if this next-hop is not already present)
    //

    MakeV2NextHopFromV1Route(V1Regn, Route, &V2NextHopInfo);

    V2NextHop = NULL;

    Status = RtmAddNextHop(V1Regn->Rtmv2RegHandle,
                           &V2NextHopInfo,
                           &V2NextHop,
                           &ChangeFlags);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Create a new route with the above nexthop
    //
    
    MakeV2RouteFromV1Route(V1Regn, Route, V2NextHop, &DestAddr, &V2RouteInfo);

    //
    // Convert TimeToLive for secs to ms
    //

    if (TimeToLive != INFINITE)
    {
        TimeToLive *= 1000;
            
        if (TimeToLive > (MAXTICKS/2-1))
        {
            TimeToLive = MAXTICKS/2-1;
        }
    }

    // Setup flags that control RTMv2's add route

    ChangeFlags = (V1Regn->Flags & RTM_PROTOCOL_SINGLE_ROUTE) 
                      ? RTM_ROUTE_CHANGE_FIRST : 0;

    //
    // Add the new route using the RTMv2 API call
    //
        
    Status = RtmAddRouteToDest(V1Regn->Rtmv2RegHandle,
                               NULL,
                               &DestAddr,
                               &V2RouteInfo,
                               TimeToLive,
                               NULL,
                               0,
                               NULL,
                               &ChangeFlags);

    //
    // Remove the handle ref we got on the nexthop above
    //

    ASSERT(RtmReleaseNextHops(V1Regn->Rtmv2RegHandle,
                              1,
                              &V2NextHop) == NO_ERROR);
    return Status;
}


DWORD 
WINAPI
RtmDeleteRoute (
    IN      HANDLE                          ClientHandle,
    IN      PVOID                           Route,
    OUT     DWORD                          *Flags        OPTIONAL,
    OUT     PVOID                           CurBestRoute OPTIONAL
    )

/*++

Routine Description:

    Deletes the route in RTMv2 that corresponds to input RTMv1
    route.

Arguments:

    ClientHandle  - RTMv1 registration handle of the caller.

    Route         - Info for V1 route being deleted in RTM.

    THE FOLLOWING PARAMETERS ARE OBSOLETE IN THIS WRAPPER

    Flags         - Returns error if this param is not NULL.

    CurBestRoute  - Returns error if this param is not NULL.

Return Value:

    Status of the operation.

--*/

{
    PV1_REGN_INFO      V1Regn;
    RTM_NET_ADDRESS    DestAddr;
    RTM_ROUTE_INFO     V2RouteInfo;
    RTM_ROUTE_HANDLE   V2Route;
    RTM_NEXTHOP_INFO   V2NextHopInfo;
    RTM_NEXTHOP_HANDLE V2NextHop;
    DWORD              ChangeFlags;
    DWORD              Status;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    // Protocols specify Flags parameter but don't use it

    *Flags = RTM_NO_CHANGE;

    if (ARGUMENT_PRESENT(CurBestRoute))
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Find the next-hop with this interface
    //

    MakeV2NextHopFromV1Route(V1Regn, Route, &V2NextHopInfo);

    V2NextHop = NULL;

    Status = RtmFindNextHop(V1Regn->Rtmv2RegHandle,
                            &V2NextHopInfo,
                            &V2NextHop,
                            NULL);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Delete the route with the above nexthop
    //

    MakeV2RouteFromV1Route(V1Regn, Route, V2NextHop, &DestAddr, &V2RouteInfo);

    //
    // We can get this route by matching the route's
    // net addr, its owner and neighbour learnt from
    //

    Status = RtmGetExactMatchRoute(V1Regn->Rtmv2RegHandle,
                                   &DestAddr,
                                   RTM_MATCH_OWNER | RTM_MATCH_NEIGHBOUR,
                                   &V2RouteInfo,
                                   0,
                                   0,
                                   &V2Route);
    if (Status == NO_ERROR)
    {
        //
        // Delete the route found above using the handle
        //
        
        Status = RtmDeleteRouteToDest(V1Regn->Rtmv2RegHandle,
                                      V2Route,
                                      &ChangeFlags);

        if (Status != NO_ERROR)
        {
            // If delete was successful, this deref is automatic

            ASSERT(RtmReleaseRoutes(V1Regn->Rtmv2RegHandle,
                                    1,
                                    &V2Route) == NO_ERROR);
        }

        ASSERT(RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle,
                                   &V2RouteInfo) == NO_ERROR);
    }

    //
    // Remove the handle ref we got on the nexthop
    //

    ASSERT(RtmReleaseNextHops(V1Regn->Rtmv2RegHandle,
                              1,
                              &V2NextHop) == NO_ERROR);

    return Status;
}


DWORD 
WINAPI
RtmDequeueRouteChangeMessage (
    IN      HANDLE                          ClientHandle,
    OUT     DWORD                          *Flags,
    OUT     PVOID                           CurBestRoute    OPTIONAL,
    OUT     PVOID                           PrevBestRoute   OPTIONAL
    )

/*++

Routine Description:

    Removes a route change message (basically a dest that has
    changed recently) from the client's own queue of pending
    changes to be notified.

    If a best route exists on the dest, RTM_CURRENT_BEST_ROUTE
    is set in flags and CurBestRoute is filled with best info.

    If the dest has no best routes (in unicast view), then the
    flags are set to RTM_PREVIOUS_BEST_ROUTE, and a route with
    correct network address and rest of route info set to some
    dummy info is returned.

    At no point are both flags set (as was the case in RTMv1).

Arguments:

    ClientHandle  - RTMv1 registration handle of the caller.

    THESE HAVE A SLIGHTLY DIFFERENT MEANING IN THE WRAPPER

    Flags         - RTM_NO_CHANGE, RTM_PREVIOUS_BEST_ROUTE 
                    or RTM_CURRENT_BEST_ROUTE

    CurBestRoute  - Info for current best route is filled.
                    ( See routine description just above )

    PrevBestRoute - Info for previous best route is filled.
                    ( See routine description just above )

Return Value:

    Status of the operation.

--*/

{
    PV1_REGN_INFO      V1Regn;
    PRTM_DEST_INFO     DestInfo;
    PRTM_ROUTE_INFO    V2RouteInfo;
    RTM_ROUTE_HANDLE   V2RouteHandle;
    UINT               NumDests;
    DWORD              Status;
    DWORD              Status1;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    *Flags = RTM_NO_CHANGE;


    // Allocate this var-size dest-info on the stack
    DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);


    if (V1Regn->NotificationEvent)
    {
        //
        // This lock serves to make the RtmGetChangedDests
        // call and resetting of the "more changes" event 
        // a single combined atomic operation, preventing
        // a case when a set gets lost due to a late reset.
        //

        ACQUIRE_V1_NOTIFY_LOCK(V1Regn);
    }


    Status = NO_ERROR;

    NumDests = 0;


    while (Status == NO_ERROR)
    {
        //
        // Release any destination we got in the prev loop
        //

        if (NumDests == 1)
        {
            ASSERT(RtmReleaseChangedDests(V1Regn->Rtmv2RegHandle,
                                          V1Regn->Rtmv2NotifyHandle,
                                          1,
                                          DestInfo) == NO_ERROR);
        }

        //
        // Get the next changed destination for client
        //
        
        NumDests = 1;

        Status = RtmGetChangedDests(V1Regn->Rtmv2RegHandle,
                                    V1Regn->Rtmv2NotifyHandle,
                                    &NumDests,
                                    DestInfo);
        if (NumDests < 1)
        {
            break;
        }

        //
        // Get the current best route for this dest
        //

        V2RouteHandle = DestInfo->ViewInfo[0].Route;

        if (V2RouteHandle != NULL)
        {
            //
            // We have a best route on the changed dest
            // Give the caller the new best route info 
            //

            if (ARGUMENT_PRESENT(CurBestRoute))
            {
                // Get the route's information from RTMv2

                V2RouteInfo = 
                  ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

                Status1 = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                                          V2RouteHandle,
                                          V2RouteInfo,
                                          NULL);

                if (Status1 != NO_ERROR)
                {
                    // Best Route would have got deleted - get next change
                    continue;
                };

                Status1 = 
                    MakeV1RouteFromV2Route(V1Regn, V2RouteInfo, CurBestRoute);

                ASSERT(RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, 
                                           V2RouteInfo) == NO_ERROR);

                if (Status1 != NO_ERROR)
                {
                    // Best Route would have got changed - get next change
                    continue;
                }
            }

            *Flags = RTM_CURRENT_BEST_ROUTE;
        }
        else
        {
            //
            // We have no best route on the changed dest,
            // Give dummy best route info with this dest
            //

            if (ARGUMENT_PRESENT(PrevBestRoute))
            {
                MakeV1RouteFromV2Dest(V1Regn, DestInfo, PrevBestRoute);
            }

            *Flags = RTM_PREVIOUS_BEST_ROUTE;
        }

        //
        // Do we have more changes to process here ?
        //

        if (Status == ERROR_NO_MORE_ITEMS)
        {
            // We have no more changes to notify - reset event if present
            
            if (V1Regn->NotificationEvent)
            {
                ResetEvent(V1Regn->NotificationEvent);
            }

            Status = NO_ERROR;
        }
        else
        {
            // We have more changes to give out - indicate so in status
            
            ASSERT(Status == NO_ERROR);

            Status = ERROR_MORE_DATA;
        }

        break;
    }

    if (NumDests == 1)
    {
        ASSERT(SUCCESS(RtmReleaseChangedDests(V1Regn->Rtmv2RegHandle,
                                              V1Regn->Rtmv2NotifyHandle,
                                              1,
                                              DestInfo)));
    }

    if (V1Regn->NotificationEvent)
    {
        RELEASE_V1_NOTIFY_LOCK(V1Regn);
    }

    return Status;
}


DWORD
V2EventCallback (
    IN      RTM_ENTITY_HANDLE               Rtmv2RegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    )

/*++

Routine Description:

    This is the callback function that gets called when any
    RTMv2 event happens like change notification available,
    route's timed out etc.

    Context1 & Context2 contain event specific information.

Arguments:

    Rtmv2RegHandle  - Regn handle of entity being informed.

    EventType       - Type of event that caused this call.

    Context1        - Context associated with this event.

    Context2        - Context associated with this event.

Return Value:

    Status of the operation being returned to RTMv2

--*/

{
    PV1_REGN_INFO      V1Regn;
    HANDLE             V1RegHandle;
    V1_ROUTE_INFO      CurBestRoute;
    V1_ROUTE_INFO      PrevBestRoute;
    DWORD              Flags;
    DWORD              Status;

    UNREFERENCED_PARAMETER(Rtmv2RegHandle);
    UNREFERENCED_PARAMETER(Context1);

    switch(EventType)
    {
    case RTM_CHANGE_NOTIFICATION:

        V1Regn = (PV1_REGN_INFO) Context2;

        //
        // Signal availability of new changes using either callback or event
        //

        if (V1Regn->NotificationFunc)
        {
            V1RegHandle = MAKE_HANDLE_FROM_POINTER(V1Regn);

            do
            {
                // Get the next change in this regn's queue

                Status = RtmDequeueRouteChangeMessage(V1RegHandle,
                                                      &Flags,
                                                      &CurBestRoute,
                                                      &PrevBestRoute);
                if (Status != ERROR_MORE_DATA)
                {
                    break;
                }

                // Call the notification callback with data
                V1Regn->NotificationFunc(Flags, &CurBestRoute, &PrevBestRoute);
            }
            while (TRUE);

            // Give the final notification call if needed

            if (Status == NO_ERROR)
            {
                // Call the notification callback with data
                V1Regn->NotificationFunc(Flags, &CurBestRoute, &PrevBestRoute);
            }
        }
        else
        {
            //
            // Set event to signal availability of changes
            //

            ASSERT(V1Regn->NotificationEvent);

            ACQUIRE_V1_NOTIFY_LOCK(V1Regn);

            SetEvent(V1Regn->NotificationEvent);

            RELEASE_V1_NOTIFY_LOCK(V1Regn);
        }

        return NO_ERROR;

    case RTM_ROUTE_EXPIRED:

        //
        // Do not handle this route expiry notification.
        // This will automatically cause deletion of the
        // route and the appropriate change notification
        // generated and indicated to all the protocols.
        //

        return ERROR_NOT_SUPPORTED;
    }

    return ERROR_NOT_SUPPORTED;
}


HANDLE
WINAPI
RtmCreateEnumerationHandle (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute
    )

/*++

Routine Description:

    Creates an enumeration on routes in RTM that match the
    appropriate criteria in the input route.

    This call does not need an RTMv1 registration handle,
    so we use the wrapper's default V1 registration with
    RTMv2 to make RTMv2 calls.

    Matching Routes are returned in the order governed the
    following fields -

    ( Dest Address and Mask, Route Preference and Metric )

Arguments:

    ProtocolFamily   - Protocol family of the routes we want

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Enumeration Handle or NULL ( GetLastError() to get error )

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_DEST_HANDLE   DestHandle;
    PRTM_DEST_INFO    DestInfo;
    RTM_NET_ADDRESS   DestAddr;
    PV1_ENUM_INFO     V1Enum;
    PVOID             Network;
    RTM_VIEW_SET      TargetViews;
    ULONG             TempUlong;
    DWORD             EnumFlags;
    DWORD             MatchFlags;
    ULONG             InterfaceIndex;
    DWORD             Status;

    //
    // Validate incoming parameters before action
    //

    if ((ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES) ||
        (EnumerationFlags & ~(RTM_ONLY_THIS_NETWORK   |
                              RTM_ONLY_THIS_PROTOCOL  |
                              RTM_ONLY_THIS_INTERFACE |
                              RTM_ONLY_BEST_ROUTES    |
                              RTM_ONLY_OWND_ROUTES    |
                              RTM_INCLUDE_DISABLED_ROUTES)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // Specify Criteria if these flags are set

    if ((!ARGUMENT_PRESENT(CriteriaRoute)) &&
        (EnumerationFlags & (RTM_ONLY_THIS_NETWORK   |
                             RTM_ONLY_THIS_PROTOCOL  |
                             RTM_ONLY_THIS_INTERFACE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    V1Regn = V1Globals.PfRegInfo[ProtocolFamily];
    if (V1Regn == NULL)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }

    //
    // If we don't need disabled routes, just use unicast view;
    // or use 0 views to get all routes including disabled ones
    //

    if (EnumerationFlags & RTM_INCLUDE_DISABLED_ROUTES)
    {
        TargetViews = RTM_VIEW_MASK_ANY;
    }
    else
    {
        TargetViews = RTM_VIEW_MASK_UCAST;
    }

    //
    // If enuming a certain n/w, check if corr. dest exists
    //

    DestHandle = NULL;

#if WRN
    DestInfo = NULL;
#endif

    if (EnumerationFlags & RTM_ONLY_THIS_NETWORK)
    {
        V1GetRouteNetwork(CriteriaRoute, ProtocolFamily, &Network);

        MakeNetAddress(Network, ProtocolFamily, TempUlong, &DestAddr);

        // Allocate this var-size dest-info on the stack
        DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

        Status = RtmGetExactMatchDestination(V1Regn->Rtmv2RegHandle,
                                             &DestAddr,
                                             RTM_BEST_PROTOCOL,
                                             TargetViews,
                                             DestInfo);
        if (Status != NO_ERROR)
        {
            SetLastError(Status);
            return NULL;
        }

        DestHandle = DestInfo->DestHandle;
    }

    do
    {
        //
        // Allocate a V1 enumeration wrapper structure
        //

        V1Enum = (PV1_ENUM_INFO) AllocNZeroObject(sizeof(V1_ENUM_INFO));

        if (V1Enum == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

#if DBG_HDL
        V1Enum->ObjectHeader.TypeSign = V1_ENUM_ALLOC;
#endif
        //
        // Cache RTMv1 specific params in RTMv1 enum
        //

        V1Enum->ProtocolFamily = ProtocolFamily;

        V1Enum->EnumFlags = EnumerationFlags;

        if (ARGUMENT_PRESENT(CriteriaRoute))
        {
            // Convert the V1 criteria into V2 criteria

            V1CopyRoute(V1Enum->CriteriaRoute.Route, 
                        CriteriaRoute, 
                        ProtocolFamily);
        }

        //
        // Create a route enum on a dest or all dests
        //

        if (EnumerationFlags & RTM_ONLY_OWND_ROUTES)
        {
            EnumFlags = RTM_ENUM_OWN_ROUTES;
        }
        else
        {
            EnumFlags = RTM_ENUM_ALL_ROUTES;
        }
        
        MatchFlags = InterfaceIndex = 0;

        // Do we have to enum's routes on an interface

        if (EnumerationFlags & RTM_ONLY_THIS_INTERFACE) 
        {
            MatchFlags = RTM_MATCH_INTERFACE;

            InterfaceIndex = 
                ((PV1_ROUTE_INFO) CriteriaRoute)->XxRoute.RR_InterfaceID;
        }

        Status = RtmCreateRouteEnum(V1Regn->Rtmv2RegHandle,
                                    DestHandle,
                                    TargetViews,
                                    EnumFlags,
                                    NULL,
                                    MatchFlags,
                                    NULL,
                                    InterfaceIndex,
                                    &V1Enum->Rtmv2RouteEnum);
        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Initialize lock used to serialize enum ops
        //

        try
        {
            InitializeCriticalSection(&V1Enum->EnumLock);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Release the destination info as we are done
        //

        if (EnumerationFlags & RTM_ONLY_THIS_NETWORK)
        {
            ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, 
                                              DestInfo)));
        }

        return MAKE_HANDLE_FROM_POINTER(V1Enum);
    }
    while (FALSE);

    //
    // Some error occurred - clean up and return NULL
    //

    if (EnumerationFlags & RTM_ONLY_THIS_NETWORK)
    {
        ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, 
                                          DestInfo)));
    }

    if (V1Enum)
    {
        if (V1Enum->Rtmv2RouteEnum)
        {
            ASSERT(SUCCESS(RtmDeleteEnumHandle(V1Regn->Rtmv2RegHandle, 
                                               V1Enum->Rtmv2RouteEnum)));
        }

#if DBG_HDL
        V1Enum->ObjectHeader.TypeSign = V1_ENUM_FREED;
#endif

        FreeObject(V1Enum);
    }

    SetLastError(Status);

    return NULL;
}


DWORD 
WINAPI
RtmEnumerateGetNextRoute (
    IN      HANDLE                          EnumerationHandle,
    OUT     PVOID                           Route
    )

/*++

Routine Description:

    Get the next route in the V1 enumeration (satisfying the
    enumeration critieria).

Arguments:

    EnumerationHandle - Handle that identifies the enumeration

    Route             - Next route is returned in this param

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_ROUTE_HANDLE  V2Route;
    PV1_ENUM_INFO     V1Enum;
    UINT              NumRoutes;
    BOOL              Match;
    DWORD             Status;

    VALIDATE_V1_ENUM_HANDLE(EnumerationHandle, &V1Enum);

    V1Regn = V1Globals.PfRegInfo[V1Enum->ProtocolFamily];

    // Acquire the enum lock to serialize requests
    ACQUIRE_V1_ENUM_LOCK(V1Enum);

    //
    // Do until you have a matching route or no more routes
    //

    Match = FALSE;

    do 
    {
        // Get next route in enum, and check if it matches

        //
        // Routes are enum'ed in the following order,
        // Network Addr, Route Priority, Route Metric
        //

        NumRoutes = 1;

        Status = RtmGetEnumRoutes(V1Regn->Rtmv2RegHandle,
                                  V1Enum->Rtmv2RouteEnum,
                                  &NumRoutes,
                                  &V2Route);
        if (NumRoutes < 1)
        {
            break;
        }

        Match = MatchCriteriaAndCopyRoute(V1Regn, V2Route, V1Enum, Route);

        ASSERT(SUCCESS(RtmReleaseRoutes(V1Regn->Rtmv2RegHandle,
                                        1,
                                        &V2Route)));
    }
    while (!Match);

    RELEASE_V1_ENUM_LOCK(V1Enum);

    return Match ? NO_ERROR : Status;
}


DWORD 
WINAPI
RtmCloseEnumerationHandle (
    IN      HANDLE                          EnumerationHandle
    )

/*++

Routine Description:

    Closes the enumeration and releases its resources.

Arguments:

    EnumerationHandle - Handle that identifies the enumeration

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;
    PV1_ENUM_INFO     V1Enum;
    DWORD             Status;

    VALIDATE_V1_ENUM_HANDLE(EnumerationHandle, &V1Enum);

    V1Regn = V1Globals.PfRegInfo[V1Enum->ProtocolFamily];
    
    do
    {
        //
        // Free the RTMv2 route enumeration and resouces
        //

        if (V1Enum->Rtmv2RouteEnum)
        {
            Status = RtmDeleteEnumHandle(V1Regn->Rtmv2RegHandle, 
                                         V1Enum->Rtmv2RouteEnum);

            ASSERT(Status == NO_ERROR);

            V1Enum->Rtmv2RouteEnum = NULL;
        }

        //
        // Free resources allocated for the enum wrapper
        //

        DeleteCriticalSection(&V1Enum->EnumLock);

#if DBG_HDL
        V1Enum->ObjectHeader.TypeSign = V1_ENUM_FREED;
#endif

        FreeObject(V1Enum);

        return NO_ERROR;
    }
    while (FALSE);

    ASSERT(FALSE);

    return Status;
}


DWORD 
WINAPI
RtmGetFirstRoute (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           EnumerationFlags,
    IN OUT  PVOID                           Route
    )

/*++

Routine Description:

    Returns the first route in the table that matches the
    criteria.

    This function just opens a new enumeration and gets
    the first route that matches enumeration critiria,
    and closes the enumeration.

Arguments:

    ProtocolFamily   - Protocol family of the route we want

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    HANDLE            V1EnumHandle;
    DWORD             Status;

    //
    // Create an enumeration and return the first route in it
    //

    V1EnumHandle = RtmCreateEnumerationHandle(ProtocolFamily,
                                              EnumerationFlags,
                                              Route);
    if (V1EnumHandle == NULL)
    {
        return GetLastError();
    }

    Status = RtmEnumerateGetNextRoute(V1EnumHandle, Route);

    ASSERT(SUCCESS(RtmCloseEnumerationHandle(V1EnumHandle)));

    return Status;
}


DWORD 
WINAPI
RtmGetNextRoute (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           EnumerationFlags,
    OUT     PVOID                           Route
    )

/*++

Routine Description:

    Returns the next route in the table that matches the
    criteria.

    The routes in RTMv2 are ordered using the following 
    fields -
    (Dest Address and Mask, Route Preference and Metric)

    If we have 2 routes with identical values for all the
    above fields, then you have no way of knowing which
    of these routes you returned the last time this call
    was made. For this reason, this call is not supported
    in this wrapper.

    One should create an enumeration to actually get the
    next route in the table.

Arguments:

    ProtocolFamily   - Protocol family of the route we want

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    UNREFERENCED_PARAMETER(ProtocolFamily);
    UNREFERENCED_PARAMETER(EnumerationFlags);
    UNREFERENCED_PARAMETER(Route);

    return ERROR_NOT_SUPPORTED;
}


DWORD 
WINAPI
RtmBlockDeleteRoutes (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute
    )

/*++

Routine Description:

    Deletes all routes in the route table that match the 
    criteria specified.

    Note that if we have multiple instances of a protocol
    running (say RIP), then each version can delete only
    the routes in owns.

Arguments:

    ClientHandle     - RTM v1 registration handle of caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;

    //
    // Check parameters for validity (in v1 bounds)
    //

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    if (EnumerationFlags & ~(RTM_ONLY_THIS_NETWORK | RTM_ONLY_THIS_INTERFACE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Deletes only routes of this instance of the protocol
    // Also include all disabled routes in the enumeration
    //

    EnumerationFlags |= (RTM_ONLY_OWND_ROUTES | RTM_INCLUDE_DISABLED_ROUTES);

    //
    // Call block operation to delete all matching routes
    //

    return BlockOperationOnRoutes(V1Regn,
                                  EnumerationFlags,
                                  CriteriaRoute,
                                  MatchCriteriaAndDeleteRoute);
}


BOOL
MatchCriteriaAndDeleteRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    )

/*++

Routine Description:

    Deletes input route if it matches the enumeration criteria.

    The enumeration criteria returns only routes owned by the
    caller. See RTM_ONLY_OWND_ROUTES in RtmBlockDeleteRoutes.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

Return Value:

    TRUE if you have released input route handle, FALSE if not

--*/

{
    DWORD      ChangeFlags;
    BOOL       Match;
    DWORD      Status;

    Match = MatchCriteria(V1Regn, V2RouteHandle, V1Enum);

    if (Match)
    {
        // Caller can delete the route only if he owns it

        Status = RtmDeleteRouteToDest(V1Regn->Rtmv2RegHandle,
                                      V2RouteHandle,
                                      &ChangeFlags);
        if (Status != NO_ERROR)
        {
            ASSERT(FALSE);

            Match = FALSE;
        }
    }

    return Match;
}


DWORD
WINAPI
RtmBlockSetRouteEnable (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute,
    IN      BOOL                            Enable
    )

/*++

Routine Description:

    Enables or disables all routes in the route table that
    match the criteria specified.

    Disabling a route removes it from consideration in all
    best route computations. We do this by adding this 
    route in "no" views in RTMv2. In other words, this
    route is not considered for best route computations
    in any views.

    Note that if we have multiple instances of a protocol
    running (say RIP), then each version can disable or
    enable only the routes it owns.

Arguments:

    ClientHandle     - RTM v1 registration handle of caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

    Enable           - TRUE to enable, and FALSE to disable

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;
    DWORD            *Flags;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    if (EnumerationFlags & ~(RTM_ONLY_THIS_NETWORK | RTM_ONLY_THIS_INTERFACE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Enable/Disable routes only of this instance of the protocol

    EnumerationFlags |= RTM_ONLY_OWND_ROUTES;

    // If we are enabling routes, get disable routes too

    if (Enable)
    {
        EnumerationFlags |= RTM_INCLUDE_DISABLED_ROUTES;
    }

    //
    // Set the enable/disable flag in the criteria route
    //

    V1GetRouteFlags(CriteriaRoute, V1Regn->ProtocolFamily, Flags);

    if (Enable)
    {
        (*Flags) |=  IP_VALID_ROUTE;
    }
    else
    {
        (*Flags) &= ~IP_VALID_ROUTE;
    }

    //
    // Call block operation to enable/disable all matching routes
    //

    return BlockOperationOnRoutes(V1Regn,
                                  EnumerationFlags,
                                  CriteriaRoute,
                                  MatchCriteriaAndEnableRoute);
}


BOOL
MatchCriteriaAndEnableRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    )

/*++

Routine Description:

    Enables/disables route if it matches enumeration criteria.

    We enable or disable a route by adding or removing it
    from the unicast view, as we assume that v1 protocols 
    understand only the unicast view. This will work only
    if we enable or disable route owned by caller.

    Enumeration criteria returns only routes owned by caller.
    See RTM_ONLY_OWND_ROUTES in RtmBlockSetRouteEnable.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

Return Value:

    TRUE if you have released input route handle, FALSE if not

--*/

{
    PRTM_ROUTE_INFO V2RoutePointer;
    RTM_VIEW_SET    Views;
    DWORD           ChangeFlags;
    BOOL            Match;
    DWORD          *Flags;
    DWORD           Status;

    Match = MatchCriteria(V1Regn, V2RouteHandle, V1Enum);

    if (!Match)
    {
        return FALSE;
    }

    do
    {
        // Do we need to enable or disable the route ?

        V1GetRouteFlags(&V1Enum->CriteriaRoute, V1Regn->ProtocolFamily, Flags);

        //
        // Remove route from unicast view to disable;
        // add it back to the unicast view to enable
        //

        if ((*Flags) & IP_VALID_ROUTE)
        {
            Views = RTM_VIEW_MASK_UCAST;
        }
        else
        {
            Views = RTM_VIEW_MASK_NONE;
        }

        // 
        // Only the route's owner can lock and update it
        //

        Status = RtmLockRoute(V1Regn->Rtmv2RegHandle,
                              V2RouteHandle,
                              TRUE,
                              &V2RoutePointer);

        if (Status != NO_ERROR)
        {
            break;
        }

        V2RoutePointer->BelongsToViews = Views;

        // Note that we are not preserving timeout value

        Status = RtmUpdateAndUnlockRoute(V1Regn->Rtmv2RegHandle,
                                         V2RouteHandle,
                                         INFINITE,
                                         NULL,
                                         0,
                                         NULL,
                                         &ChangeFlags);

        if (Status != NO_ERROR)
        {
            break;
        }

        return FALSE;
    }
    while (FALSE);

    ASSERT(FALSE);

    return FALSE;
}


DWORD 
WINAPI
RtmBlockConvertRoutesToStatic (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute
    )

/*++

Routine Description:

    Makes the caller the owner of all the routes matching
    the input criteria.

    Changing the owner is done by adding a new route for
    each matching route with the same info. The caller
    is the owner of the new route.

Arguments:

    ClientHandle     - RTM v1 registration handle of caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    //
    // In accordance with RTMv1, act only on enabled routes
    //

    EnumerationFlags &= ~RTM_INCLUDE_DISABLED_ROUTES;

    //
    // Call block op to add a new route for each matching one.
    //

    return BlockOperationOnRoutes(V1Regn,
                                  EnumerationFlags,
                                  CriteriaRoute,
                                  MatchCriteriaAndChangeOwner);
}


BOOL
MatchCriteriaAndChangeOwner (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    )

/*++

Routine Description:

    Makes a copy of the route if it matches the enum criteria.
    The new copy of the route will have the caller as its
    owner. The matching route can then be deleted (if needed).

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

Return Value:

    TRUE if you have released input route handle, FALSE if not

--*/

{
    RTM_ENTITY_INFO    EntityInfo;
    PRTM_DEST_INFO     DestInfo;
    PRTM_ROUTE_INFO    V2RouteInfo;
    RTM_NEXTHOP_HANDLE NextHopHandle;
    RTM_NEXTHOP_HANDLE OldNextHop;
    RTM_NEXTHOP_HANDLE OldNeighbour;
    RTM_NEXTHOP_INFO   NextHopInfo;
    RTM_VIEW_SET       BestInViews;
    ULONG              Protocol;
    BOOL               Match;
    DWORD              ChangeFlags;
    DWORD              Status;

    //
    // Get the route's information from RTMv2
    //

    V2RouteInfo = 
        ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

    Status = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                             V2RouteHandle,
                             V2RouteInfo,
                             NULL);
    
    if (Status != NO_ERROR)
    {
        return FALSE;
    }

    Match = FALSE;

    do
    {
        //
        // Is the route owner already target protocol ?
        //

        if (V2RouteInfo->RouteOwner == V1Regn->Rtmv2RegHandle)
        {
            break;
        }

        //
        // Does it match the criteria route's protocol ?
        //

        if (V1Enum->EnumFlags & RTM_ONLY_THIS_PROTOCOL)
        {
            //
            // Get the protocol type for this route
            //

            Status = RtmGetEntityInfo(V1Regn->Rtmv2RegHandle,
                                      V2RouteInfo->RouteOwner,
                                      &EntityInfo);
            if (Status != NO_ERROR)
            {
                break;
            }

            Protocol = EntityInfo.EntityId.EntityProtocolId;

            Status = RtmReleaseEntityInfo(V1Regn->Rtmv2RegHandle,
                                          &EntityInfo);

            ASSERT(Status == NO_ERROR);

            // Is this the routing protocol we need ?

            if (V1Enum->CriteriaRoute.XxRoute.RR_RoutingProtocol
                    != Protocol)
            {
                break;
            }
        }

        //
        // And does it match other criteria in enum ?
        //

        if (V1Enum->EnumFlags & RTM_ONLY_BEST_ROUTES)
        {
            Status = RtmIsBestRoute(V1Regn->Rtmv2RegHandle,
                                    V2RouteHandle,
                                    &BestInViews);

            if ((BestInViews & RTM_VIEW_MASK_UCAST) == 0)
            {
                break;
            }
        }

        //
        // We are checking only the first next hop
        // as we expect this function to be used
        // only by V1 protocols on their own routes
        //

        ASSERT(V2RouteInfo->NextHopsList.NumNextHops == 1);

        Status = RtmGetNextHopInfo(V1Regn->Rtmv2RegHandle,
                                   V2RouteInfo->NextHopsList.NextHops[0],
                                   &NextHopInfo);

        if (Status != NO_ERROR)
        {
            break;
        }

#if DBG
        // Do we need to match the nexthop intf ?

        if (V1Enum->EnumFlags & RTM_ONLY_THIS_INTERFACE)
        {
            // Compare this next-hops interface with criteria

            if (NextHopInfo.InterfaceIndex ==
                V1Enum->CriteriaRoute.XxRoute.RR_InterfaceID)
            {
                Match = TRUE;
            }

            // We have already done this filtering in RTM v2
            ASSERT(Match == TRUE);
        }
#endif

        // Add the same next hop with a different owner

        if (Match)
        {
            NextHopHandle = NULL;

            do
            {
                Status = RtmAddNextHop(V1Regn->Rtmv2RegHandle,
                                       &NextHopInfo,
                                       &NextHopHandle,
                                       &ChangeFlags);

                if (Status != NO_ERROR)
                {
                    Match = FALSE;
                    break;
                }

                // Allocate this var-size dest-info on the stack
                DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

                //
                // Get the destination address corr to handle
                //

                Status = RtmGetDestInfo(V1Regn->Rtmv2RegHandle,
                                        V2RouteInfo->DestHandle,
                                        RTM_BEST_PROTOCOL,
                                        RTM_VIEW_ID_UCAST,
                                        DestInfo);

                if (Status != NO_ERROR)
                {
                    Match = FALSE;
                    break;
                }

                //
                // Add this route again with a different owner
                //

                ChangeFlags = (V1Regn->Flags & RTM_PROTOCOL_SINGLE_ROUTE) 
                                   ? RTM_ROUTE_CHANGE_FIRST : 0;

                // Update route with new next hop neighbour

                OldNeighbour = V2RouteInfo->Neighbour;
                V2RouteInfo->Neighbour = NextHopHandle;

                // Update route with new forwarding next hop

                OldNextHop = V2RouteInfo->NextHopsList.NextHops[0];
                V2RouteInfo->NextHopsList.NextHops[0] = NextHopHandle;

                //
                // Add the new route using the RTMv2 API call
                //
        
                Status = RtmAddRouteToDest(V1Regn->Rtmv2RegHandle,
                                           NULL,
                                           &DestInfo->DestAddress,
                                           V2RouteInfo,
                                           INFINITE,
                                           NULL,
                                           0,
                                           NULL,
                                           &ChangeFlags);
                if (Status != NO_ERROR)
                {
                    Match = FALSE;
                }

                //
                // Restore old information nexthop information
                //

                V2RouteInfo->Neighbour = OldNeighbour;
                V2RouteInfo->NextHopsList.NextHops[0] = OldNextHop;

                Status = RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle,
                                            DestInfo);

                ASSERT(Status == NO_ERROR);
            }
            while (FALSE);

            // If we have a next hop handle, release it

            if (NextHopHandle)
            {
                Status = RtmReleaseNextHops(V1Regn->Rtmv2RegHandle,
                                            1,
                                            &NextHopHandle);
                ASSERT(Status == NO_ERROR);
            }
        }

        Status = RtmReleaseNextHopInfo(V1Regn->Rtmv2RegHandle, &NextHopInfo);

        ASSERT(Status == NO_ERROR);

    }
    while (FALSE);

#if DELETE_OLD

    //
    // Impersonate previous owner and delete his route
    //

    if (Match)
    {
        Status = RtmDeleteRouteToDest(V2RouteInfo->RouteOwner,
                                      V2RouteHandle,
                                      &ChangeFlags);
        if (Status != NO_ERROR)
        {
            // Must have been deleted meanwhile - ignore

            Match = FALSE;
        }
    }

#else

    Match = FALSE;

#endif

    ASSERT(SUCCESS(RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, V2RouteInfo)));

    return Match;
}


DWORD 
BlockOperationOnRoutes (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute,
    IN      PFUNC                           RouteOperation
    )

/*++

Routine Description:

    Performs the route operation specified on each route in
    the table that matches the enumeration criteria.

    The route operation is called with the route handle of
    each matching route. If the operation returns FALSE,
    then the route handle is released, else it is expected
    that the handle was released by the operation itself.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

    RouteOperation   - Operation performed on matching routes

Return Value:

    Status of the operation

--*/

{
    HANDLE            V1EnumHandle;
    PV1_ENUM_INFO     V1Enum;
    PRTM_ROUTE_HANDLE V2RouteHandles;
    UINT              NumRoutes;
    UINT              i;
    DWORD             Status1;
    DWORD             Status;

    //
    // Create an enumeration to get all matching routes
    //

    V1EnumHandle = RtmCreateEnumerationHandle(V1Regn->ProtocolFamily,
                                              EnumerationFlags,
                                              CriteriaRoute);
    if (V1EnumHandle == NULL)
    {
        return GetLastError();
    }

    VALIDATE_V1_ENUM_HANDLE(V1EnumHandle, &V1Enum);

    //
    // Get list of all  matching routes and call operation
    //

    // Allocate this var-size handles array on the stack
    V2RouteHandles = ALLOC_HANDLES(V1Regn->Rtmv2Profile.MaxHandlesInEnum);

    do 
    {
        // Get next route in enum, and run operation on it

        NumRoutes = V1Regn->Rtmv2Profile.MaxHandlesInEnum;

        Status = RtmGetEnumRoutes(V1Regn->Rtmv2RegHandle,
                                  V1Enum->Rtmv2RouteEnum,
                                  &NumRoutes,
                                  V2RouteHandles);

        for (i = 0; i < NumRoutes; i++)
        {
            if (!RouteOperation(V1Regn, V2RouteHandles[i], V1Enum))
            {
                // Operation not successful - release handle

                Status1 = RtmReleaseRoutes(V1Regn->Rtmv2RegHandle,
                                           1,
                                           &V2RouteHandles[i]);
                ASSERT(SUCCESS(Status1));
            }
        }
    }
    while (Status == NO_ERROR);

    ASSERT(SUCCESS(RtmCloseEnumerationHandle(V1EnumHandle)));

    return (Status == ERROR_NO_MORE_ROUTES) ? NO_ERROR : Status;
}


BOOL
MatchCriteriaAndCopyRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum  OPTIONAL,
    OUT     PVOID                           V1Route OPTIONAL
    )

/*++

Routine Description:

    If the input route matches enumeration criteria, it converts
    to a V1 route and copies it to the output buffer.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

    V1Route          - Buffer in which the V1 route is copied

Return Value:

    TRUE if route matches criteria, and FALSE if it does not

--*/

{
    RTM_ENTITY_INFO   EntityInfo;
    PRTM_ROUTE_INFO   V2RouteInfo;
    RTM_VIEW_SET      BestInViews;
    ULONG             Protocol;
    BOOL              Match;
    DWORD             Status;

    //
    // Get the route's information from RTMv2
    //

    V2RouteInfo = 
        ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

    Status = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                             V2RouteHandle,
                             V2RouteInfo,
                             NULL);
    
    if (Status != NO_ERROR)
    {
        return FALSE;
    }

    //
    // If we have no criteria, we match every route
    //

    if (!ARGUMENT_PRESENT(V1Enum))
    {
        Match = TRUE;
    }
    else
    {
        Match = FALSE;

        do
        {
            if (V1Enum->EnumFlags & RTM_INCLUDE_DISABLED_ROUTES)
            {
                // Is route anything but a unicast or disabled one ?

                if (V2RouteInfo->BelongsToViews & ~RTM_VIEW_MASK_UCAST)
                {
                    break;
                }
            }

            //
            // Does it match the criteria route's protocol ?
            //

            if (V1Enum->EnumFlags & RTM_ONLY_THIS_PROTOCOL)
            {
                //
                // Get the protocol type for this route
                //

                Status = RtmGetEntityInfo(V1Regn->Rtmv2RegHandle,
                                          V2RouteInfo->RouteOwner,
                                          &EntityInfo);

                if (Status != NO_ERROR)
                {
                    break;
                }

                Protocol = EntityInfo.EntityId.EntityProtocolId;

                Status = RtmReleaseEntityInfo(V1Regn->Rtmv2RegHandle,
                                              &EntityInfo);

                ASSERT(Status == NO_ERROR);

                // Is this the routing protocol we need ?

                if (V1Enum->CriteriaRoute.XxRoute.RR_RoutingProtocol
                        != Protocol)
                {
                    break;
                }
            }

            //
            // And does it match other criteria in enum ?
            //

            if (V1Enum->EnumFlags & RTM_ONLY_BEST_ROUTES)
            {
                Status = RtmIsBestRoute(V1Regn->Rtmv2RegHandle,
                                        V2RouteHandle,
                                        &BestInViews);

                if ((BestInViews & RTM_VIEW_MASK_UCAST) == 0)
                {
                    break;
                }
            }

#if DBG
            if (V1Enum->EnumFlags & RTM_ONLY_THIS_INTERFACE)
            {
                RTM_NEXTHOP_INFO  NextHopInfo;
                ULONG             IfIndex;

                //
                // We are checking only the first next hop
                // as we expect this function to be used
                // only by V1 protocols on their own routes
                //

                ASSERT(V2RouteInfo->NextHopsList.NumNextHops == 1);

                Status = 
                    RtmGetNextHopInfo(V1Regn->Rtmv2RegHandle,
                                      V2RouteInfo->NextHopsList.NextHops[0],
                                      &NextHopInfo);

                if (Status != NO_ERROR)
                {
                    break;
                }

                // Get the interface index for this nexthop

                IfIndex = NextHopInfo.InterfaceIndex;

                Status = RtmReleaseNextHopInfo(V1Regn->Rtmv2RegHandle,
                                               &NextHopInfo);

                ASSERT(Status == NO_ERROR);

                // Is this the interface that we are enum'ing
                
                if (IfIndex !=V1Enum->CriteriaRoute.XxRoute.RR_InterfaceID)
                {
                    // We have already done this filtering in RTM v2
                    ASSERT(FALSE);

                    break;
                }
            }
#endif

            Match = TRUE;
        }
        while (FALSE);
    }


    //
    // If we have a match, then make a copy of this route
    //

    if (Match)
    {
        if (ARGUMENT_PRESENT(V1Route))
        {
            Status = MakeV1RouteFromV2Route(V1Regn, V2RouteInfo, V1Route);

            if (Status != NO_ERROR)
            {
                Match = FALSE;
            }
        }
    }

    Status = RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, V2RouteInfo);

    ASSERT(Status == NO_ERROR);

    return Match;
}


BOOL
WINAPI
RtmIsRoute (
    IN      DWORD                           ProtocolFamily,
    IN      PVOID                           Network,
    OUT     PVOID                           BestRoute OPTIONAL
    )

/*++

Routine Description:

    Checks the route table corr. to a protocol family
    for the existence of a route to the input network.

Arguments:

    ProtocolFamily - Protocol family of the route table

    Network        - Network address we are trying to reach

    BestRoute      - Best route to the network is filled

Return Value:

    TRUE if a best route exists, FALSE if not, 
    Use GetLastError to check the status code

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_ROUTE_HANDLE  V2RouteHandle;
    PRTM_DEST_INFO    DestInfo;
    RTM_NET_ADDRESS   NetAddr;
    BOOL              Match;
    DWORD             Status;

    //
    // Validate incoming parameters before action
    //

    if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    V1Regn = V1Globals.PfRegInfo[ProtocolFamily];

    if (V1Regn == NULL)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Allocate this var-size dest-info on the stack
    DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

    MakeNetAddress(Network, TempUlong, ProtocolFamily, &NetAddr);

    Status = RtmGetExactMatchDestination(V1Regn->Rtmv2RegHandle,
                                         &NetAddr,
                                         RTM_BEST_PROTOCOL,
                                         RTM_VIEW_MASK_UCAST,
                                         DestInfo);
    if (Status == NO_ERROR)
    {
        //
        // We have a unicast route to the network
        //

        if (ARGUMENT_PRESENT(BestRoute))
        {
            V2RouteHandle = DestInfo->ViewInfo[0].Route;

            ASSERT(V2RouteHandle != NULL);

            // We have no criteria; so pass NULL for it

            Match = MatchCriteriaAndCopyRoute(V1Regn,
                                              V2RouteHandle,
                                              NULL,
                                              BestRoute);

            ASSERT(Match == TRUE);
        }

        Status = RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, DestInfo);

        ASSERT(Status == NO_ERROR);

        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
RtmLookupIPDestination(
    IN      DWORD                           DestAddr,
    OUT     PRTM_IP_ROUTE                   IPRoute
)

/*++

Routine Description:

    Gets the best non-loopback IP route to the
    input destination address.

Arguments:

    DestAddr  - Network address of the input dest

    IPRoute   - Best non-loopback route is filled

Return Value:

    TRUE if a best route exists, FALSE if not, 
    Use GetLastError to check the status code

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_NET_ADDRESS   NetAddr;
    PRTM_DEST_INFO    DestInfo1;
    PRTM_DEST_INFO    DestInfo2;
    DWORD             Status;

    //
    // Validate incoming parameters before action
    //

    V1Regn = V1Globals.PfRegInfo[RTM_PROTOCOL_FAMILY_IP];
    if (V1Regn == NULL)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Allocate this var-size dest-infos on the stack

    DestInfo1 = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);
    DestInfo2 = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

    // Convert the V1 addr to a V2 net address format

    MakeHostAddress((PUCHAR)&DestAddr, RTM_PROTOCOL_FAMILY_IP, &NetAddr);

    //
    // Get the best route to the input dest
    //

    Status = RtmGetMostSpecificDestination(V1Regn->Rtmv2RegHandle,
                                           &NetAddr,
                                           RTM_BEST_PROTOCOL,
                                           RTM_VIEW_MASK_UCAST,
                                           DestInfo1);

    while (Status == NO_ERROR)
    {
        //
        // Check if this route is a non-loopback one
        //

        if (CopyNonLoopbackIPRoute(V1Regn, DestInfo1, IPRoute))
        {
            break;
        }

        //
        // Backtrack up the tree for next best route
        //

        Status = RtmGetLessSpecificDestination(V1Regn->Rtmv2RegHandle,
                                               DestInfo1->DestHandle,
                                               RTM_BEST_PROTOCOL,
                                               RTM_VIEW_MASK_UCAST,
                                               DestInfo2);

        ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, DestInfo1)));

        SWAP_POINTERS(DestInfo1, DestInfo2);
    }

    if (Status == NO_ERROR)
    {
        ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, DestInfo1)));

        return TRUE;
    }

    SetLastError(Status);

    return FALSE;
}


BOOL
CopyNonLoopbackIPRoute (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_DEST_INFO              V2DestInfo,
    OUT         PVOID                       V1Route
    )

/*++

Routine Description:

    Check if the input destination has a non-
    loopback best route, and if so copy route to
    the output buffer after conversion to v1

Arguments:

    V1Regn     - RTMv1 Registration info of caller

    V2DestInfo - Dest whose route we are checking

    V1Route    - Best route is converted to V1
                 and filled if it is not-loopack

Return Value:

    TRUE if best route is non-loopback, or FALSE

--*/

{
    RTM_ROUTE_HANDLE  V2RouteHandle;
    PRTM_ROUTE_INFO   V2RouteInfo;
    BOOL              Match;
    ULONG             Address;
    DWORD             Status;

    //
    // Check if the destination addr is loopback
    // [ Optimized to avoid getting route info ]
    //

    Address = * (ULONG *) V2DestInfo->DestAddress.AddrBits;

    if ((Address & 0x000000FF) == 0x0000007F)
    {
        return FALSE;
    }

    V2RouteHandle = V2DestInfo->ViewInfo[0].Route;

    V2RouteInfo = 
        ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

    // Get the route's information from RTMv2

    Status = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                             V2RouteHandle,
                             V2RouteInfo,
                             NULL);

    if (Status != NO_ERROR)
    {
        return FALSE;
    };

    // If this is a non-loopback route, copy it

    Match = !(V2RouteInfo->Flags & RTM_ROUTE_FLAGS_LOOPBACK);

    if (Match)
    {
        Status = MakeV1RouteFromV2Route(V1Regn, V2RouteInfo, V1Route);

        if (Status != NO_ERROR)
        {
            Match = FALSE;
        }
    }

    Status = RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, V2RouteInfo);

    ASSERT(Status == NO_ERROR);

    return Match;
}


ULONG
WINAPI
RtmGetNetworkCount (
    IN      DWORD                           ProtocolFamily
    )

/*++

Routine Description:

    Get the number of networks (same as RTMv2 destinations)
    in the route table corr. to the input protocol family

Arguments:

    ProtocolFamily - Protocol family of the route table

Return Value:

    Number of destinations, or 0 (Use GetLastError() here)

--*/

{
    RTM_ADDRESS_FAMILY_INFO  AddrFamilyInfo;
    PV1_REGN_INFO            V1Regn;
    UINT                     NumEntities;
    DWORD                    Status;

    do
    {
        //
        // Validate incoming parameters before action
        //

        if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

        V1Regn = V1Globals.PfRegInfo[ProtocolFamily];

        if (V1Regn == NULL)
        {
            Status = ERROR_INVALID_HANDLE;
            break;
        }

        //
        // Query the appropriate table for reqd info
        //

        NumEntities = 0;

        Status = RtmGetAddressFamilyInfo(0, // v1 maps to default Instance
                                         ADDRESS_FAMILY[ProtocolFamily],
                                         &AddrFamilyInfo,
                                         &NumEntities,
                                         NULL);

        if (Status != NO_ERROR)
        {
            break;
        }

        return AddrFamilyInfo.NumDests;
    }
    while (FALSE);

    //
    // Some error occured - clean up and return 0
    //

    SetLastError(Status);

    return 0;
}


ULONG 
WINAPI
RtmGetRouteAge (
    IN          PVOID                       Route
    ) 

/*++

Routine Description:

    Computes the age of the route from its creation
    time and the current time in seconds.

    Assumes that the creation time of the route is
    correctly filled in, which is not the case as
    we are currently not keeping a FILETIME in the
    route to save space. If we do keep time, then
    this function would work without any changes.

Arguments:

    Route - Route whose age we want.

Return Value:

     Age of the route in seconds, or FFFFFFFF
     (GetLastError gives error in this case).

--*/

{
    ULONGLONG  CurTime;

    //
    // This code has been directly copied from RTMv1
    //

    GetSystemTimeAsFileTime((FILETIME *)&CurTime);

    CurTime -= * (PULONGLONG) &(((PRTM_IP_ROUTE)Route)->RR_TimeStamp);

    if (((PULARGE_INTEGER)&CurTime)->HighPart<10000000)
    {
        return (ULONG)(CurTime/10000000);
    }
    else 
    {
        SetLastError (ERROR_INVALID_PARAMETER);

        return 0xFFFFFFFF;
    }
}


//
// Common Helper routines
//


VOID 
MakeV2RouteFromV1Route (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PVOID                       V1Route,
    IN          PRTM_NEXTHOP_HANDLE         V2NextHop,
    OUT         PRTM_NET_ADDRESS            V2DestAddr  OPTIONAL,
    OUT         PRTM_ROUTE_INFO             V2RouteInfo OPTIONAL
    )

/*++

Routine Description:

    Converts a route in RTM v1 format to a route in
    the RTM v2 format (at present for IP only).

    The nexthop for the V2 route should have been
    computed before and passed in as a parameter.
    Also see function 'MakeV2NextHopFromV1Route'.

    The function also returns the destination addr
    along with the RTMv2 route info, as the route
    info itself does not contain the dest address.

Arguments:

    V1Regn      - RTMv1 Registration info of caller

    V1Route     - RTMv1 route being converted to V2

    V2NextHop   - The V2 nexthop for the V2 route

    V2DestAddr  - V2 destination addr is filled here

    V2RouteInfo - V2 route information is filled here

Return Value:

    None

--*/

{
    PRTM_IP_ROUTE  IPRoute;
    ULONG          TempUlong;

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;
    
    if (ARGUMENT_PRESENT(V2RouteInfo))
    {
        ZeroMemory(V2RouteInfo, sizeof(RTM_ROUTE_INFO));

        // Fill up the V2 Route Info with V1 info

        // Assumes caller is owner of the route
        V2RouteInfo->RouteOwner = V1Regn->Rtmv2RegHandle;

        V2RouteInfo->Neighbour = V2NextHop;

        // Should keep all the V1 flags in the V2 route

        V2RouteInfo->Flags1 = 
            (UCHAR) IPRoute->RR_FamilySpecificData.FSD_Flags;

        // The only flag we understand is the valid flag
        // If route is not valid, we add it to no views

#if DBG
        V2RouteInfo->BelongsToViews = RTM_VIEW_MASK_NONE;
#endif
        if (V2RouteInfo->Flags1 & IP_VALID_ROUTE)
        {
            V2RouteInfo->BelongsToViews = RTM_VIEW_MASK_UCAST;
        }

        if (IsRouteLoopback(IPRoute))
        {
            V2RouteInfo->Flags = RTM_ROUTE_FLAGS_LOOPBACK;
        }

        switch (IPRoute->RR_FamilySpecificData.FSD_Type)
        {
        case 3:
            V2RouteInfo->Flags |= RTM_ROUTE_FLAGS_LOCAL;
            break;

        case 4:
            V2RouteInfo->Flags |= RTM_ROUTE_FLAGS_REMOTE;
            break;            
        }

        V2RouteInfo->PrefInfo.Preference = 
            IPRoute->RR_FamilySpecificData.FSD_Priority;

        V2RouteInfo->PrefInfo.Metric = 
            IPRoute->RR_FamilySpecificData.FSD_Metric;

        // Only the first DWORD is copied by wrapper
        V2RouteInfo->EntitySpecificInfo =
            (PVOID) (ULONG_PTR) IPRoute->RR_ProtocolSpecificData.PSD_Data[0];

        V2RouteInfo->NextHopsList.NumNextHops = 1;
        V2RouteInfo->NextHopsList.NextHops[0] = V2NextHop;
    }
    
    // Fill up the V2 Dest Address with V1 info

    if (ARGUMENT_PRESENT(V2DestAddr))
    {
        MakeNetAddressForIP(&IPRoute->RR_Network, TempUlong, V2DestAddr);
    }

    return;
}


VOID 
MakeV2NextHopFromV1Route (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PVOID                       V1Route,
    OUT         PRTM_NEXTHOP_INFO           V2NextHopInfo
    )

/*++

Routine Description:

    Computes RTMv2 next hop info using the nexthop
    address and interface index in the RTMv1 route.

Arguments:

    V1Regn         - RTMv1 Registration info of caller

    V1Route        - V1 route that is being considered

    V2NextHopInfo  - V2 Next hop info for input route

Return Value:

    None

--*/

{
    PRTM_IP_ROUTE  IPRoute;
    ULONG          TempUlong;

    ZeroMemory(V2NextHopInfo, sizeof(RTM_NEXTHOP_INFO));

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;

    //
    // We ignore the next hop mask in the conversion
    //
    //
    // MakeNetAddressForIP(&IPRoute->RR_NextHopAddress, 
    //                    TempUlong,
    //                    &V2NextHopInfo->NextHopAddress);
    //

    UNREFERENCED_PARAMETER(TempUlong);

    MakeHostAddressForIP(&IPRoute->RR_NextHopAddress, 
                         &V2NextHopInfo->NextHopAddress);

    V2NextHopInfo->NextHopOwner = V1Regn->Rtmv2RegHandle;

    V2NextHopInfo->InterfaceIndex = IPRoute->RR_InterfaceID;

    return;
}


VOID
MakeV1RouteFromV2Dest (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_DEST_INFO              DestInfo,
    OUT         PVOID                       V1Route
    )

/*++

Routine Description:

    Fills a V1 route buffer with the destination addr
    from the V2 route.

Arguments:

    V1Regn         - RTMv1 Registration info of caller

    DestInfo       - Destination info in RTMv2

    V1Route        - V1 route that is being filled in

Return Value:

    None

--*/

{
    PRTM_IP_ROUTE    IPRoute;
    UINT             AddrLen;

    UNREFERENCED_PARAMETER(V1Regn);

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;
    
    ZeroMemory(IPRoute, sizeof(RTM_IP_ROUTE));

    //
    // Get the destination addr for this route
    //

    IPRoute->RR_Network.N_NetNumber = 
        * (ULONG *) DestInfo->DestAddress.AddrBits;

    AddrLen = DestInfo->DestAddress.NumBits;

    ASSERT(AddrLen <= 32);
    if (AddrLen != 0)
    {
        IPRoute->RR_Network.N_NetMask = 
            RtlUlongByteSwap((~0) << (32 - AddrLen));
    }

    //
    // Fill in dummy family specific data for route
    //
    // We make the route the least preferred - by
    // minimizing its priority and maximizing its
    // metric - we also treat the route as being
    // valid and added to the stack - this will
    // force router manager to delete the route
    // to this dest in the stack if all routes 
    // to this destination are deleted from RTM.
    //

    IPRoute->RR_FamilySpecificData.FSD_Priority = (ULONG) 0;

    IPRoute->RR_FamilySpecificData.FSD_Metric  = 
    IPRoute->RR_FamilySpecificData.FSD_Metric1 = (ULONG) ~0;

    IPRoute->RR_FamilySpecificData.FSD_Flags = (ULONG) ~0;

    return;
}


DWORD
MakeV1RouteFromV2Route (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_ROUTE_INFO             V2RouteInfo,
    OUT         PVOID                       V1Route
    )
/*++

Routine Description:

    Converts a route in the RTMv2 format to a V1 route
    ( at present for IP only ).

Arguments:

    V1Regn      - RTMv1 Registration info of caller

    V2RouteInfo - V2 route information being converted

    V1Route     - Buffer in which V1 route is filled

Return Value:

    Status of the operation

--*/

{
    RTM_ENTITY_INFO  EntityInfo;
    PRTM_DEST_INFO   DestInfo;
    PRTM_IP_ROUTE    IPRoute;
    RTM_NEXTHOP_INFO NextHopInfo;
    UINT             AddrLen;
    DWORD            Status;

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;
    
    ZeroMemory(IPRoute, sizeof(RTM_IP_ROUTE));

    //
    // Get the routing protocol for this route
    //

    Status = RtmGetEntityInfo(V1Regn->Rtmv2RegHandle,
                              V2RouteInfo->RouteOwner,
                              &EntityInfo);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    IPRoute->RR_RoutingProtocol = EntityInfo.EntityId.EntityProtocolId;

    Status = RtmReleaseEntityInfo(V1Regn->Rtmv2RegHandle,
                                  &EntityInfo);

    ASSERT(Status == NO_ERROR);


    //
    // Get the destination addr for this route
    //

    // Allocate this var-size dest-info on the stack
    DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

    Status = RtmGetDestInfo(V1Regn->Rtmv2RegHandle,
                            V2RouteInfo->DestHandle,
                            RTM_BEST_PROTOCOL,
                            RTM_VIEW_ID_UCAST,
                            DestInfo);

    if (Status != NO_ERROR)
    {
        return Status;
    }
    
    IPRoute->RR_Network.N_NetNumber = 
        * (ULONG *) DestInfo->DestAddress.AddrBits;

    AddrLen = DestInfo->DestAddress.NumBits;

    ASSERT(AddrLen <= 32);
    if (AddrLen != 0)
    {
        IPRoute->RR_Network.N_NetMask = 
            RtlUlongByteSwap((~0) << (32 - AddrLen));
    }

    Status = RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle,
                                DestInfo);

    ASSERT(Status == NO_ERROR);


    //
    // Get the next hop address and interface
    //

    ASSERT(V2RouteInfo->NextHopsList.NumNextHops > 0);

    Status = RtmGetNextHopInfo(V1Regn->Rtmv2RegHandle,
                               V2RouteInfo->NextHopsList.NextHops[0],
                               &NextHopInfo);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    IPRoute->RR_InterfaceID = NextHopInfo.InterfaceIndex;

    IPRoute->RR_NextHopAddress.N_NetNumber = 
         * (ULONG *) NextHopInfo.NextHopAddress.AddrBits;

    AddrLen = NextHopInfo.NextHopAddress.NumBits;
    ASSERT(AddrLen <= 32);
    if (AddrLen != 0)
    {
        IPRoute->RR_NextHopAddress.N_NetMask = 
            RtlUlongByteSwap((~0) >> (32 - AddrLen));
    }

    Status = RtmReleaseNextHopInfo(V1Regn->Rtmv2RegHandle,
                                   &NextHopInfo);

    ASSERT(Status == NO_ERROR);

    //
    // Get the family specific data for route
    //

    IPRoute->RR_FamilySpecificData.FSD_Priority = 
                        V2RouteInfo->PrefInfo.Preference;

    IPRoute->RR_FamilySpecificData.FSD_Metric  = 
    IPRoute->RR_FamilySpecificData.FSD_Metric1 = 
                            V2RouteInfo->PrefInfo.Metric;

    IPRoute->RR_FamilySpecificData.FSD_Flags = V2RouteInfo->Flags1; 

    if (V2RouteInfo->Flags & RTM_ROUTE_FLAGS_LOCAL)
    {
        IPRoute->RR_FamilySpecificData.FSD_Type = 3;
    }
    else
    if (V2RouteInfo->Flags & RTM_ROUTE_FLAGS_REMOTE)
    {
        IPRoute->RR_FamilySpecificData.FSD_Type = 4;
    }

    //
    // Get the protocol specific data for route
    //

    IPRoute->RR_ProtocolSpecificData.PSD_Data[0] =
                     PtrToUlong(V2RouteInfo->EntitySpecificInfo);

    return NO_ERROR;
}

#endif // WRAPPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\lookup.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lookup.h

Abstract:
    Contains interface for a generalized best
    matching prefix lookup data structure.

Author:
    Chaitanya Kodeboyina (chaitk) 20-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_LOOKUP_H__
#define __ROUTING_LOOKUP_H__

#ifdef __cplusplus
extern "C"
{
#endif

//
// Flags used to control the information dumped by the DumpTable func.
//
#define   SUMMARY       0x00
#define   STATS         0x01
#define   ITEMS         0x02
#define   VERBOSE       0xFF


//
// Field used to link the data item in the lookup structure
// [ Eg: A LIST_ENTRY field is used to link into a d-list ]
//
typedef struct _LOOKUP_LINKAGE
{
    PVOID           Pointer1;            // Usage depends on implementation
    PVOID           Pointer2;            // Usage depends on implementation
}
LOOKUP_LINKAGE, *PLOOKUP_LINKAGE;


//
// Context returned in Search useful in following Inserts and Deletes.
//
// This context remains valid after a search only until the
// read/write lock that is taken for the search is released.
//
typedef struct _LOOKUP_CONTEXT
{
    PVOID           Context1;           // Usage depends on implementation
    PVOID           Context2;           // Usage depends on implementation
    PVOID           Context3;           // Usage depends on implementation
    PVOID           Context4;           // Usage depends on implementation
}
LOOKUP_CONTEXT, *PLOOKUP_CONTEXT;


DWORD
WINAPI
CreateTable(
    IN       UINT                            MaxBytes,
    OUT      HANDLE                         *Table
    );

DWORD
WINAPI
InsertIntoTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    IN       PLOOKUP_LINKAGE                 Data
    );

DWORD
WINAPI
DeleteFromTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    );

DWORD
WINAPI
SearchInTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    );

DWORD
WINAPI
BestMatchInTable(
    IN       HANDLE                          Table,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_LINKAGE                *BestData
    );

DWORD
WINAPI
NextMatchInTable(
    IN       HANDLE                          Table,
    IN       PLOOKUP_LINKAGE                 BestData,
    OUT      PLOOKUP_LINKAGE                *NextBestData
    );

DWORD
WINAPI
EnumOverTable(
    IN       HANDLE                          Table,
    IN OUT   PUSHORT                         StartNumBits,
    IN OUT   PUCHAR                          StartKeyBits,
    IN OUT   PLOOKUP_CONTEXT                 Context     OPTIONAL,
    IN       USHORT                          StopNumBits OPTIONAL,
    IN       PUCHAR                          StopKeyBits OPTIONAL,
    IN OUT   PUINT                           NumItems,
    OUT      PLOOKUP_LINKAGE                *DataItems
    );

DWORD
WINAPI
DestroyTable(
    IN       HANDLE                          Table
    );

DWORD
WINAPI
GetStatsFromTable(
    IN       HANDLE                          Table,
    OUT      PVOID                           Stats
    );

BOOL
WINAPI
CheckTable(
    IN       HANDLE                          Table
    );

VOID
WINAPI
DumpTable(
    IN       HANDLE                          Table,
    IN       DWORD                           Flags
    );

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_LOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmchng.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmchng.c

Abstract:

    Contains routines for giving out change
    notification registrations to entities
    registered with the RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

DWORD
WINAPI
RtmRegisterForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_NOTIFY_FLAGS                NotifyFlags,
    IN      PVOID                           NotifyContext,
    OUT     PRTM_NOTIFY_HANDLE              NotifyHandle
    )

/*++

Routine Description:

    Creates a new change notification using which the caller can
    receive notifications to changes in best route information.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    TargetViews    - Set of views in which changes are tracked,

    NotifyFlags    - Flags that indicate the change types and 
                     dests (marked or all) caller is interested in,

    NotifyContext  - Context for callback to indicate new changes,

    NotifyHandle   - Handle to this notification info used in all
                     subsequent calls - to get changes and so on.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    BOOL            LockInited;
    UINT            i, j;
    DWORD           Status;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // Is he interested in any change types supported ?
    //

    if ((NotifyFlags & RTM_CHANGE_TYPES_MASK) == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Is he interested in any non-supported views ?
    //

    if (TargetViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Create and initialize a change notification block
    //

    Notif = (PNOTIFY_INFO) AllocNZeroObject(sizeof(NOTIFY_INFO) +
                                            AddrFamInfo->MaxHandlesInEnum *
                                            sizeof(PDEST_INFO));
    if (Notif == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if WRN
    Status = ERROR_GEN_FAILURE;
#endif

    do
    {
#if DBG_HDL
        Notif->NotifyHeader.ObjectHeader.TypeSign = NOTIFY_ALLOC;

        Notif->NotifyHeader.HandleType = NOTIFY_TYPE;
#endif
        Notif->OwningEntity = Entity;

        Notif->TargetViews = TargetViews;

        Notif->NumberOfViews = NUMBER_OF_BITS(TargetViews);

        Notif->ChangeTypes = NotifyFlags;

        LockInited = FALSE;

        try
        {
            InitializeCriticalSection(&Notif->NotifyLock);

            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Notif->NotifyContext = NotifyContext;

        InitializeQueue(&Notif->NotifyDests, AddrFamInfo->MaxHandlesInEnum);

        Notif->CNIndex = -1;

        ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

        do
        {
            //
            // Do we have any space for a new change notification ?
            //

            if (AddrFamInfo->NumChangeNotifs >= AddrFamInfo->MaxChangeNotifs)
            {
                Status = ERROR_NO_SYSTEM_RESOURCES;
                break;
            }

            //
            // Search for an unused change notification (CN) slot
            //

            for (i = 0; i < AddrFamInfo->MaxChangeNotifs; i++)
            {
                if (AddrFamInfo->ChangeNotifsDir[i] == 0)
                {
                    break;
                }
            }

            ASSERT(i < AddrFamInfo->MaxChangeNotifs);


            //
            // Reserve the CN index in the change notification dir
            //

            Notif->CNIndex = i;

            AddrFamInfo->ChangeNotifsDir[i] = Notif;

            AddrFamInfo->NumChangeNotifs++;

            //
            // Fill in the CN information for this index on AF
            //

            SET_BIT(AddrFamInfo->ChangeNotifRegns, i);

            // Do we indicate changes to marked dests only

            if (NotifyFlags & RTM_NOTIFY_ONLY_MARKED_DESTS)
            {
                SET_BIT(AddrFamInfo->CNsForMarkedDests, i);
            }

            //
            // Mark each view in which CN is interested
            //

            if (TargetViews == RTM_VIEW_MASK_ANY)
            {
                TargetViews = RTM_VIEW_MASK_ALL;
            }

            for (j = 0; TargetViews; j++)
            {
                if (TargetViews & 0x01)
                {
                    SET_BIT(AddrFamInfo->CNsForView[j], i);
                }
        
                TargetViews >>= 1;
            }

            //
            // Mark change types in which CN is interested
            //

            for (j = 0; j < RTM_NUM_CHANGE_TYPES; j++)
            {
                if (NotifyFlags & 0x01)
                {
                    SET_BIT(AddrFamInfo->CNsForChangeType[j], i);
                }

                NotifyFlags >>= 1;
            }
        }
        while (FALSE);

        RELEASE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

        if (Notif->CNIndex == -1)
        {
            break;
        }

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Notif->NotifyHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, NOTIFY_REF);

        //
        // Make a handle to the notify block and return
        //

        *NotifyHandle = MAKE_HANDLE_FROM_POINTER(Notif);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

    if (LockInited)
    {
        DeleteCriticalSection(&Notif->NotifyLock);
    }

#if DBG_HDL
    Notif->NotifyHeader.ObjectHeader.TypeSign = NOTIFY_FREED;
#endif

    FreeObject(Notif);

    *NotifyHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  ChangedDests
    )

/*++

Routine Description:

    Get the next set of destinations whose best route information
    has changed.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NotifyHandle   - Handle to the change notification,

    NumDests       - Num. of DestInfo's in output is passed in,
                     Num. of DestInfo's copied out is returned.

    ChangedDests   - Output buffer where destination info is retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    UINT            DestInfoSize;
    UINT            DestsInput;
    PDEST_INFO      Dest;
    INT             CnIndex;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    DestsInput = *NumDests;

    *NumDests = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    AddrFamInfo = Entity->OwningAddrFamily;

    if (DestsInput > AddrFamInfo->MaxHandlesInEnum)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(Notif->NumberOfViews);

    CnIndex = Notif->CNIndex;

    Status = NO_ERROR;

    //
    // Get changed dests from the local queue on CN
    //

    ACQUIRE_CHANGE_NOTIFICATION_LOCK(Notif);

    while (*NumDests < DestsInput)
    {
        //
        // Get the next destination from the queue
        //

        DequeueItem(&Notif->NotifyDests, &Dest);

        if (Dest == NULL)
        {
            break;
        }

#if DBG_TRACE
        if (TRACING_ENABLED(NOTIFY))
        {
            ULONG TempAddr, TempMask;
            
            RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
            Trace2(NOTIFY,"Returning dest %p to CN %d:", Dest, Notif->CNIndex);
            TracePrintAddress(NOTIFY, TempAddr, TempMask); Trace0(NOTIFY,"\n");
        }
#endif

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        // The queue bit for this CN should be set

        ASSERT(IS_BIT_SET(Dest->DestOnQueueBits, CnIndex));

        //
        // Do not copy dest if a change was ignored
        // after the dest was put on the queue - in which
        // case both Changed & OnQueue bits are set
        // 

        if (IS_BIT_SET(Dest->DestChangedBits, CnIndex))
        {
            RESET_BIT(Dest->DestChangedBits, CnIndex);
        }
        else
        {
            //
            // Copy the dest information to output
            //

            GetDestInfo(Entity,
                        Dest,
                        RTM_BEST_PROTOCOL,
                        Notif->TargetViews,
                        ChangedDests);

            (*NumDests)++;

            ChangedDests = 
                (PRTM_DEST_INFO) (DestInfoSize + (PUCHAR) ChangedDests);
        }

        // Reset bit as it has been pulled off the queue

        RESET_BIT(Dest->DestOnQueueBits, CnIndex);

        RELEASE_DEST_WRITE_LOCK(Dest);

        DEREFERENCE_DEST(Dest, NOTIFY_REF);
    }

    //
    // Do we have any more destinations in the queue ?
    //

    if ((*NumDests) == 0)
    {
        Status = ERROR_NO_MORE_ITEMS;
    }

    RELEASE_CHANGE_NOTIFICATION_LOCK(Notif);

    return Status;
}


DWORD
WINAPI
RtmReleaseChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  ChangedDests
)

/*++

Routine Description:

    Releases all handles present in the input dest info structures.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    NumDests          - Number of dest info structures in buffer,

    ChangedDests      - Array of dest info structures being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    UINT            NumViews;
    UINT            DestInfoSize;
    UINT            i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // De-registration could have happened by now
    // so do not validate the notification handle
    //

    UNREFERENCED_PARAMETER(NotifyHandle);

    //
    // Get size of dest info in info array
    //

    NumViews = ((PRTM_DEST_INFO) ChangedDests)->NumberOfViews;

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(NumViews);

    //
    // Dereference each dest info in array
    //

    for (i = 0; i < NumDests; i++)
    {
        RtmReleaseDestInfo(RtmRegHandle, ChangedDests);

        ChangedDests = (PRTM_DEST_INFO) (DestInfoSize + (PUCHAR) ChangedDests);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmIgnoreChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_HANDLE                ChangedDests
    )

/*++

Routine Description:

    Ignores the next change on each of the input destinations if
    it has already occurred.
    
    We do not take a lock on the notification here as we are not
    serializing this call with other RtmGetChangedDests calls.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    NumDests          - Number of dest handles in buffer below,

    ChangedDests      - Dests whose next change we are ignoring.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;
    INT             CnIndex;
    BOOL            ChangedBit;
    BOOL            OnQueueBit;
    UINT            i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    CnIndex = Notif->CNIndex;

    for (i = 0; i < NumDests; i++)
    {
        Dest = DEST_FROM_HANDLE(ChangedDests[i]);

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        ChangedBit = IS_BIT_SET(Dest->DestChangedBits, CnIndex);

        OnQueueBit = IS_BIT_SET(Dest->DestOnQueueBits, CnIndex);

        if (ChangedBit && !OnQueueBit)
        {
            //
            // Dest on a changed list - reset the changed bit
            //

            RESET_BIT(Dest->DestChangedBits, CnIndex);

            //
            // If there are no more "changed bits" set on dest,
            // it is removed from the change list when the list
            // is processed next (in ProcessChangedDests call)
            //
        }
        else
        if (!ChangedBit && OnQueueBit)
        {
            //
            // Dest on queue - Invalidate by setting changed bit
            //

            SET_BIT(Dest->DestChangedBits, CnIndex);
        }

        RELEASE_DEST_WRITE_LOCK(Dest);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetChangeStatus (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           ChangeStatus
    )

/*++

Routine Description:

    Checks if there are pending changes to be notified on a dest.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    DestHandle        - Dest whose change status we are querying,

    ChangedStatus     - Change Status of this dest is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;
    INT             CnIndex;
    BOOL            ChangedBit;
    BOOL            OnQueueBit;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);


    CnIndex = Notif->CNIndex;


    ACQUIRE_DEST_READ_LOCK(Dest);

    ChangedBit = IS_BIT_SET(Dest->DestChangedBits, CnIndex);

    OnQueueBit = IS_BIT_SET(Dest->DestOnQueueBits, CnIndex);

    RELEASE_DEST_READ_LOCK(Dest);

    if (ChangedBit)
    {
        if (OnQueueBit)
        {
            // The last change has been ignored

            *ChangeStatus = FALSE;
        }
        else
        {
            // A pending change to be notified

            *ChangeStatus = TRUE;
        }
    }
    else
    {
        if (OnQueueBit)
        {
            // A pending change to be notified

            *ChangeStatus = TRUE;
        }
        else
        {
            // No changes available on this dest
            
            *ChangeStatus = FALSE;
        }
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmMarkDestForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            MarkDest
    )

/*++

Routine Description:

    Marks a destination to request notifications to changes to its
    best route information on this change notification.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    DestHandle        - Dest that we are marking for notifications,

    MarkDest          - Mark dest if TRUE, Unmark dest if FALSE

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    // VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    Dest = DEST_FROM_HANDLE(DestHandle);
    if (!Dest)
    {
        return ERROR_INVALID_HANDLE;
    }
    
    //
    // We make this check so that we can avoid taking
    // the dest lock (which is dynamic) unnecessarily
    //

    if (IS_BIT_SET(Dest->DestMarkedBits, Notif->CNIndex))
    {
        //
        // Reset mark bit on dest for this CN if reqd
        //

        if (!MarkDest)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
            RESET_BIT(Dest->DestMarkedBits, Notif->CNIndex);
            RELEASE_DEST_WRITE_LOCK(Dest);
        }
    }
    else
    {
        //
        // Set mark bit on dest for this CN if reqd
        //

        if (MarkDest)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
            SET_BIT(Dest->DestMarkedBits,   Notif->CNIndex);
            RELEASE_DEST_WRITE_LOCK(Dest);
        }
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmIsMarkedForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           DestMarked
    )

/*++

Routine Description:

    Checks if a dest has been marked (by a CN handle) for receving 
    notifications to changes in its best route information.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    DestHandle        - Dest that we want to check is marked or not,

    DestMarked        - TRUE if marked, and FALSE if not.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    // VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    Dest = DEST_FROM_HANDLE(DestHandle);
    if (!Dest)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Return the state of mark bit on the dest for CN
    //

    *DestMarked = IS_BIT_SET(Dest->DestMarkedBits, Notif->CNIndex);

    return NO_ERROR;
}


DWORD
WINAPI
RtmDeregisterFromChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle
    )

/*++

Routine Description:

    Deregisters a change notification and frees all resources
    allocated to it. It also cleans up all information kept 
    in the destination for this particular notification index.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NotifyHandle   - Handle to notification being de-registered.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;
    UINT            NumDests;
    INT             CNIndex;
    UINT            i;
    DWORD           Status;
    RTM_NET_ADDRESS NetAddress;
    RTM_VIEW_SET    ViewSet;
    PLOOKUP_LINKAGE DestData[DEFAULT_MAX_HANDLES_IN_ENUM];


    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;


    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    //
    // Remove this notification from CN regn's mask
    // so that no more bits for this CN will be set
    //

    ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    CNIndex = Notif->CNIndex;

    ASSERT(AddrFamInfo->ChangeNotifsDir[CNIndex] == Notif);

    Notif->CNIndex = -1;

    RESET_BIT(AddrFamInfo->ChangeNotifRegns, CNIndex);

    //
    // Reset other bits that refer to the CN's state
    //

    // Unmark state whether this CN need marked dests

    RESET_BIT(AddrFamInfo->CNsForMarkedDests, CNIndex);

    // Unmark interest of this CN in each view

    ViewSet = RTM_VIEW_MASK_ALL;

    for (i = 0; ViewSet; i++)
    {
        if (ViewSet & 0x01)
        {
            RESET_BIT(AddrFamInfo->CNsForView[i], CNIndex);
        }
        
        ViewSet >>= 1;
    }

    // Unmark CN's interest in each change type

    for (i = 0; i < RTM_NUM_CHANGE_TYPES; i++)
    {
        RESET_BIT(AddrFamInfo->CNsForChangeType[i], CNIndex);
    }

    RELEASE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    //
    // Cleanup the notification's "DestChanged" bits
    //

    ProcessChangedDestLists(AddrFamInfo, FALSE);

    //
    // Reset the CN's marked bits on all the dests
    //

    ZeroMemory(&NetAddress, sizeof(RTM_NET_ADDRESS));

    do
    {
        NumDests = DEFAULT_MAX_HANDLES_IN_ENUM;

        ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

        Status = EnumOverTable(AddrFamInfo->RouteTable,
                               &NetAddress.NumBits,
                               NetAddress.AddrBits,
                               NULL,
                               0,
                               NULL,
                               &NumDests,
                               DestData);

        for (i = 0; i < NumDests; i++)
        {
            Dest = CONTAINING_RECORD(DestData[i], DEST_INFO, LookupLinkage);

            if (IS_BIT_SET(Dest->DestMarkedBits, CNIndex))
            {
                LOCKED_RESET_BIT(Dest->DestMarkedBits, CNIndex);
            }
        }

        RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);
    }
    while (SUCCESS(Status));

    //
    // Now remove the CN completely from dir of CNs
    //

    ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    AddrFamInfo->ChangeNotifsDir[CNIndex] = NULL;

    AddrFamInfo->NumChangeNotifs--;

    RELEASE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    //
    // Deference any destinations on the CN's queue
    //

    while (TRUE)
    {
        //
        // Get the next destination from the queue
        //

        DequeueItem(&Notif->NotifyDests, &Dest);

        if (Dest == NULL)
        {
            break;
        }

        // Reset the "on CN's queue" bit on dest

        if (IS_BIT_SET(Dest->DestOnQueueBits, CNIndex))
        {
            LOCKED_RESET_BIT(Dest->DestOnQueueBits, CNIndex);
        }

        DEREFERENCE_DEST(Dest, NOTIFY_REF);
    }

    //
    // Free all resources allocated to this CN
    //

    DeleteCriticalSection(&Notif->NotifyLock);

#if DBG_HDL
    //
    // Remove from the list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    RemoveEntryList(&Notif->NotifyHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    DEREFERENCE_ENTITY(Entity, NOTIFY_REF);

    // Free memory allocated for notification and return

#if DBG_HDL
    Notif->NotifyHeader.ObjectHeader.TypeSign = NOTIFY_FREED;
#endif

    FreeObject(Notif);

    return NO_ERROR;
}


DWORD
ComputeCNsToBeNotified (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      DWORD                           DestMarkedBits,
    IN      DWORD                          *ViewsForChangeType
    )

/*++

Routine Description:

    Computes the set of change notification registrations that
    need to be notified when the best route to a particular
    destination changes.

Arguments:

    AddrFamInfo    - Address family that has the CN regn info,

    DestMarkedBits - CN's that marked for changes this dest
                     or the dest's parent if it's a new dest

    ViewsForChangeType 
                   - Views in which change of a type occurred.

Return Value:

    CNs that need to be notified of this change.

Locks:

    Called with ChangeNotifsLock in AddrFamInfo in READ mode
    as this protects CN regn info from changing while we are
    reading it.

--*/

{
    RTM_VIEW_SET ViewSet;
    DWORD        FilterCNs;
    DWORD        CNsForCT;
    UINT         i, j;
    DWORD        NotifyCNs;

    //
    // Either a CN has marked the dest, or wants all changes
    //

    NotifyCNs = DestMarkedBits | ~AddrFamInfo->CNsForMarkedDests;

    if (NotifyCNs == 0)
    {
        return 0;
    }

    // The CNs not in this bit-mask should not be notified

    FilterCNs = NotifyCNs;


    NotifyCNs = 0;

    for (i = 0; i < RTM_NUM_CHANGE_TYPES; i++)
    {
        //
        // For each change type, get all CN's that can be notified
        //

        // See what views this change type (CT) applies to

        CNsForCT = 0;

        ViewSet = ViewsForChangeType[i];

        for (j = 0; ViewSet; j++)
        {
            // For each view, get all interested CN's

            if (ViewSet & 0x01)
            {
                CNsForCT |= AddrFamInfo->CNsForView[j];
            }
        
            ViewSet >>= 1;
        }

        // Now see which CNs are actually interested in CT

        CNsForCT &= AddrFamInfo->CNsForChangeType[i];

        // Add these CNs to the CNs need to be notified

        NotifyCNs |= CNsForCT;

        //
        // If we have to notify all CNs, we are done here
        //

        if (NotifyCNs == AddrFamInfo->ChangeNotifRegns)
        {
            break;
        }
    }

    //
    // Apply the filer of CNs you stored away earlier
    //

    NotifyCNs &= FilterCNs;

    return NotifyCNs;
}


DWORD
AddToChangedDestLists (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      PDEST_INFO                      Dest,
    IN      DWORD                           NotifyCNs
    )

/*++

Routine Description:

    Add a destination to a list of changed dests on address
    family, and sets the appropriate state in dest.

Arguments:

    AddrFamInfo  - The address family holding the change-list,

    Dest         - Pointer to the dest that has changed,

    NotifyCNs    - CNs that need to be notified of this change.

Return Value:

    Status of the operation

Locks:

    Called with destination lock held in WRITE mode as we are
    updating the DestChanged and DestOnQueue bits on it. This
    lock also protects the change list linkage.In other words
    you need to have the dest lock for inserting or removing
    from a change list.

    Also called with ChangeNotifsLock in AddrFamInfo in READ 
    mode as this protects CN registration info from changing
    while we are adding to the list. If we do not take this 
    lock, we might end up adding to the change list after an 
    entity has de-registered from notifications. See code in
    RtmDeregisterFromChangeNotification.

--*/

{
    SINGLE_LIST_ENTRY *ListPtr;
    UINT               ListNum;
    BOOL               Success;

    //
    // Set change bits to 1 if not already on queue
    //

    Dest->DestChangedBits |= (NotifyCNs & ~Dest->DestOnQueueBits);

    //
    // Reset change bits to 0 if already on queue
    //

    Dest->DestChangedBits &= ~(NotifyCNs & Dest->DestOnQueueBits);

    //
    // Push dest into the change list if it is not
    // already on the list and we have new changes
    //

    if ((Dest->ChangeListLE.Next == NULL) &&
        (Dest->DestChangedBits & ~Dest->DestOnQueueBits))
    {
        // Get the change list to insert the dest in

        ListNum = CHANGE_LIST_TO_INSERT(Dest);

        //
        // Note that we take a lock on changes list
        // only if the dest (which is locked) isn't
        // already on the list, else could deadlock
        // with the code in ProcessChangedDestLists
        //

#if DBG_TRACE
    if (TRACING_ENABLED(NOTIFY))
    {
        ULONG TempAddr, TempMask;
        
        RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
        Trace2(NOTIFY,"Adding dest %p to change list %d: ", Dest, ListNum);
        TracePrintAddress(NOTIFY, TempAddr, TempMask); Trace0(NOTIFY,"\n");
    }
#endif

        ACQUIRE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        //
        // Insert the item at the end of the list
        // and update the pointer to the list end
        //

        ListPtr = AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail;

        PushEntryList(ListPtr, &Dest->ChangeListLE);

        AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail = 
                                                 &Dest->ChangeListLE;

        RELEASE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        REFERENCE_DEST(Dest, NOTIFY_REF);

        //
        // Activate a timer if it is not already done.
        // This is done with the dest lock held so the
        // dest doesn't get removed before this code.
        //

        if (InterlockedIncrement(&AddrFamInfo->NumChangedDests) == 1)
        {
            //
            // Create a periodic notifications timer
            //

            ACQUIRE_NOTIF_TIMER_LOCK(AddrFamInfo);

            ASSERT(AddrFamInfo->ChangeNotifTimer == NULL);
            
            do
            {
                Success = CreateTimerQueueTimer(&AddrFamInfo->ChangeNotifTimer,
                                                AddrFamInfo->NotifTimerQueue,
                                                ProcessChangedDestLists,
                                                AddrFamInfo,
                                                TIMER_CALLBACK_DUETIME,
                                                1000000,
                                                0);
                if (Success)
                {
                    break;
                }

                // Should not happen - but try again

                Sleep(0);
            }
            while (TRUE);

            RELEASE_NOTIF_TIMER_LOCK(AddrFamInfo);
        }
    }

    return NO_ERROR;
}


VOID 
NTAPI
ProcessChangedDestLists (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    )

/*++

Routine Description:

    Processes the lists of changes on the address family, and 
    populates the per CN queues of changed destinations. If a
    dest is distributed to queues of all interested CNs, it is
    removed from the change list on address family to which it
    belonged.

Arguments:

    AddrFamInfo  - The address family holding the change-list.

    TimeOut      - TRUE if called from a timer, FALSE if not

Return Value:

    None

--*/

{
    PADDRFAM_INFO       AddrFamInfo;
    RTM_ENTITY_HANDLE   EntityHandle;
    PSINGLE_LIST_ENTRY  ListPtr, TempList;
    PSINGLE_LIST_ENTRY  Prev, Curr;
    RTM_EVENT_CALLBACK  NotifyCallback;
    PNOTIFY_INFO        Notif;
    PDEST_INFO          Dest;
    UINT                ListNum;
    UINT                NumDests, i;
    INT                 NumDestsRemoved;
    DWORD               ActualChangedBits;
    DWORD               NotifyChanges;
    BOOL                QueueEmpty, QueueFull;
    ULONG               ThreadId;
    PLONG               ListInUse;
    BOOL                Success;

    UNREFERENCED_PARAMETER(TimeOut);
    DBG_UNREFERENCED_LOCAL_VARIABLE(ThreadId);

#if DBG_TRACE
    ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);

    if (TRACING_ENABLED(NOTIFY))
    {
        Trace1(NOTIFY, "Entering ProcessChangedDestLists: %lu", ThreadId);
    }
#endif

    AddrFamInfo = (PADDRFAM_INFO) Context;

    NotifyChanges = 0;

    NumDestsRemoved = 0;

    ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

#if DBG_TRACE
    if (TRACING_ENABLED(NOTIFY))
    {
        Trace1(NOTIFY, 
                "ProcessChangedDestLists: Number of changed dests: %ld", 
                AddrFamInfo->NumChangedDests );
    }
#endif

    for (ListNum = 0; ListNum < NUM_CHANGED_DEST_LISTS; ListNum++)
    {
        //
        // Check if this list is already being processed
        //

        ListInUse = &AddrFamInfo->ChangeLists[ListNum].ChangesListInUse;

        if (InterlockedIncrement(ListInUse) != 1)
        {
            InterlockedDecrement(ListInUse);
            continue;
        }

        //
        // Move all items in the list to a temp list
        //

        ListPtr = &AddrFamInfo->ChangeLists[ListNum].ChangedDestsHead;

        ACQUIRE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        TempList = ListPtr->Next;
    
        ListPtr->Next = ListPtr;

        AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail = ListPtr;

        RELEASE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        //
        // Process each destination in the temp list
        //

        Prev = CONTAINING_RECORD(&TempList, SINGLE_LIST_ENTRY, Next);

        Curr = Prev->Next;

        NumDests = 0;

        while (Curr != ListPtr)
        {
            // Get the next destination on the list

            Dest = CONTAINING_RECORD(Curr, DEST_INFO, ChangeListLE);

#if DBG_TRACE
            if (TRACING_ENABLED(NOTIFY))
            {
                ULONG Addr, Mask;
                
                RTM_IPV4_GET_ADDR_AND_MASK(Addr, Mask, &Dest->DestAddress);
                Trace2(NOTIFY, "Next dest %p in list %d: ", Dest, ListNum);
                TracePrintAddress(NOTIFY, Addr, Mask); Trace0(NOTIFY,"\n");
            }
#endif
            ACQUIRE_DEST_WRITE_LOCK(Dest);

            //
            // Note that this dest can have no "changed bits" set,
            // yet be on the list because the changes were ignored
            // or because one of the entities deregistered its CN
            //

            // Remove bits obsoleted by any CN deregistrations

            Dest->DestChangedBits &= AddrFamInfo->ChangeNotifRegns;

            //
            // Process all CNs whose DestChanged bit is set on dest
            //

            ActualChangedBits = Dest->DestChangedBits & ~Dest->DestOnQueueBits;

            for (i = 0; i < AddrFamInfo->MaxChangeNotifs; i++)
            {
                if (!ActualChangedBits)
                {
                    break;
                }

                if (IS_BIT_SET(ActualChangedBits, i))
                {
                    Notif = AddrFamInfo->ChangeNotifsDir[i];

                    //
                    // Note that we take a lock on notify block
                    // only if the dest (which is locked) isn't
                    // already on the queue - otherwise we will
                    // deadlock with code in RtmGetChangedDests
                    //

                    ACQUIRE_CHANGE_NOTIFICATION_LOCK(Notif);

                    QueueEmpty = IsQueueEmpty(&Notif->NotifyDests);

                    //
                    // Enqueue this destination if the
                    // the CN's queue is not yet full
                    //

                    EnqueueItem(&Notif->NotifyDests, Dest, QueueFull);

                    if (!QueueFull)
                    {
                        //
                        // If we are adding changes to an
                        // empty queue, signal this event
                        //

                        if (QueueEmpty)
                        {
                            SET_BIT(NotifyChanges, i);
                        }

                        //
                        // Adjust dest change and queue bits
                        //

                        SET_BIT(Dest->DestOnQueueBits, i);

                        RESET_BIT(Dest->DestChangedBits, i);

                        RESET_BIT(ActualChangedBits, i);

                        REFERENCE_DEST(Dest, NOTIFY_REF);
                    }

                    RELEASE_CHANGE_NOTIFICATION_LOCK(Notif);
                }
            }

            //
            // Do we have any more changes to process on dest ?
            //

            if (ActualChangedBits == 0)
            {
                // Splice this dest from the changed list
                Prev->Next = Curr->Next;

                NumDestsRemoved++;

                // "Next" == NULL means it is not on list
                Curr->Next = NULL;
            }

            RELEASE_DEST_WRITE_LOCK(Dest);

            //
            // Do we have any more changes to process on dest ?
            //

            if (ActualChangedBits == 0)
            {
                DEREFERENCE_DEST(Dest, NOTIFY_REF);
            }
            else
            {
                // Advance the pointer to next dest in list
                Prev = Curr;
            }

            Curr = Prev->Next;

            if ((++NumDests == MAX_DESTS_TO_PROCESS_ONCE) || 
                (Curr == ListPtr))
            {
                //
                // Do we have any changes to inform to entities
                //

                for (i = 0; NotifyChanges != 0; i++)
                {
                    if (NotifyChanges & 0x01)
                    {
                        Notif = AddrFamInfo->ChangeNotifsDir[i];

                        NotifyCallback = Notif->OwningEntity->EventCallback;

                        EntityHandle = 
                            MAKE_HANDLE_FROM_POINTER(Notif->OwningEntity);

#if DBG_TRACE
                        if (TRACING_ENABLED(NOTIFY))
                        {
                            Trace1(NOTIFY, "Notifying CN %d BEGIN", i);
                        }
#endif
                        NotifyCallback(EntityHandle,
                                       RTM_CHANGE_NOTIFICATION,
                                       MAKE_HANDLE_FROM_POINTER(Notif),
                                       Notif->NotifyContext);
#if DBG_TRACE
                        if (TRACING_ENABLED(NOTIFY))
                        {
                            Trace1(NOTIFY, "Notifying CN %d END\n", i);
                        }
#endif
                    }

                    NotifyChanges >>= 1;
                }

                // Reset counter for number of dests processed
                NumDests = 0;
            }
        }

        if (TempList != ListPtr)
        {
            //
            // Merge back what is left of the temp list
            //

            ASSERT(Prev->Next == ListPtr);

            ACQUIRE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

            if (ListPtr->Next == ListPtr)
            {
                AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail = Prev;
            }

            Prev->Next = ListPtr->Next;

            ListPtr->Next = TempList;

            RELEASE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);
        }

        InterlockedDecrement(ListInUse);
    }

    //
    // Update number of destinations left to process on change list
    //

    if (NumDestsRemoved)
    {
        //
        // Do we have any more destinations to process ?
        //

        ACQUIRE_NOTIF_TIMER_LOCK(AddrFamInfo);

        if (InterlockedExchangeAdd(&AddrFamInfo->NumChangedDests, 
                                   (-1) * NumDestsRemoved) == NumDestsRemoved)
        {
            //
            // Delete timer as we have no items on change list
            //

            ASSERT(AddrFamInfo->ChangeNotifTimer);

            Success = DeleteTimerQueueTimer(AddrFamInfo->NotifTimerQueue,
                                            AddrFamInfo->ChangeNotifTimer,
                                            NULL);
            // ASSERT(Success);

            AddrFamInfo->ChangeNotifTimer = NULL;
        }

        RELEASE_NOTIF_TIMER_LOCK(AddrFamInfo);
    }

    //
    // Setup the notification timer to fire after the TIMER_CALLBACK_DUETIME
    //
    ACQUIRE_NOTIF_TIMER_LOCK(AddrFamInfo);
    
    if ( AddrFamInfo->ChangeNotifTimer ) {
        Success = ChangeTimerQueueTimer(AddrFamInfo->NotifTimerQueue,
                                        AddrFamInfo->ChangeNotifTimer,
                                        TIMER_CALLBACK_DUETIME,
                                        1000000);
                                        
        if ( !Success ) {
            if ( TRACING_ENABLED(NOTIFY) ) {
                Trace1(NOTIFY, "Unable to ChangeTimerQueueTimer. Error: %d", 
                            GetLastError());
            }
        }
    }
    
    RELEASE_NOTIF_TIMER_LOCK(AddrFamInfo);

    RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

#if DBG_TRACE
    if (TRACING_ENABLED(NOTIFY))
    {
        Trace1(NOTIFY, "ProcessChangedDestLists: Dests Removed: %ld", 
                        NumDestsRemoved);
                        
        Trace1(NOTIFY, "Leaving  ProcessChangedDestLists: %lu", ThreadId);
    }
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\pattrie.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    pattrie.h

Abstract:

    Contains interface for a best matching
    prefix lookup using an PATRICIA trie.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_PATLOOKUP_H__
#define __ROUTING_PATLOOKUP_H__

#include "lookup.h"

#define Print                       printf

#define BITS_IN_BYTE                     8 

#define NODE_KEY_SIZE        sizeof(ULONG)

//
// Direction in Iterator
//

#define    LCHILD                        0
#define    RCHILD                        1
#define    PARENT                        2

typedef INT PAT_CHILD, *PPAT_CHILD;

//
// A node in the PAT trie
//
typedef struct _PAT_NODE *PPAT_NODE;

typedef struct _PAT_NODE
{
    PPAT_NODE         Child[2];         // Pointers to left & right child nodes

    PVOID             Data;             // Opaque Pointer to data in the node

    USHORT            NumBits;          // Actual number of bits in this node
    ULONG             KeyBits;          // Value of bits to match in this node
}
PAT_NODE;

//
// PAT trie for prefix matching
//
typedef struct _PAT_TRIE
{
    PPAT_NODE         TrieRoot;         // Pointer to the PAT trie

    USHORT            MaxKeyBytes;      // Max num of bytes in key

    USHORT            NumNodes;         // Number of nodes in trie

#if PROF

    ULONG             MemoryInUse;      // Total memory in use now
    UINT              NumAllocs;        // Num of total allocations
    UINT              NumFrees;         // Num of total free allocs

    UINT              NumInsertions;    // Num of total insertions
    UINT              NumDeletions;     // Num of total deletions

#endif
}
PAT_TRIE, *PPAT_TRIE;

//
// Lookup context for a PAT trie
//
typedef struct _PAT_CONTEXT
{
    PVOID             BestNode;         // Node with best the matching prefix
    PVOID             InsPoint;         // Node to which new node is attached
    PAT_CHILD         InsChild;         // Node should attached as this child
}
PAT_CONTEXT, *PPAT_CONTEXT;

//
// Linkage Info Kept in Data
//
typedef struct _PAT_LINKAGE
{
    PPAT_NODE         NodePtr;          // Back pointer to the owning node
}
PAT_LINKAGE, *PPAT_LINKAGE;


#define SET_NODEPTR_INTO_DATA(Data, Node) ((PPAT_LINKAGE)Data)->NodePtr = Node

#define GET_NODEPTR_FROM_DATA(Data)       ((PPAT_LINKAGE)Data)->NodePtr


//
// Macros for doing bit operations on keys
//

//
// MaskBitsArr[i] = First 'i' bits set to 1
//

const ULONG MaskBitsArr[] =
{
    0x00000000, 0x80000000, 0xC0000000, 0xE0000000,
    0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,
    0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,
    0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,
    0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,
    0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,
    0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,
    0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE,
    0xFFFFFFFF
};

#define    PickMostSigNBits(ul, nb)       ((ul) >> (NODE_KEY_SIZE - nb))

#define    MaskBits(nb)                   MaskBitsArr[nb]

//
// Key Compare/Copy inlines
//

// Disable warnings for no return value
#pragma warning(disable:4035)

__inline 
ULONG
RtmUlongByteSwap(
    IN  ULONG    Value
    )
{
    __asm 
        {
            mov     eax, Value
            bswap   eax
        }
}

#pragma warning(default:4035)

#define RtlUlongByteSwap RtmUlongByteSwap

#endif //__ROUTING_PATLOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmchng.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmchng.h

Abstract:

    Contains defintions related to change
    notification registrations to entities
    registered with the RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMCHNG_H__
#define __ROUTING_RTMCHNG_H__

//
// Constants used in change notification processing
//

#define TIMER_CALLBACK_DUETIME        1000

#define MAX_DESTS_TO_PROCESS_ONCE     16

//
// Change type info must be consistent
// with this information in rtmv2.h
//

// Change types that we support

#define RTM_CHANGE_TYPE_ID_ALL         0
#define RTM_CHANGE_TYPE_ID_BEST        1
#define RTM_CHANGE_TYPE_ID_FORWARDING  2

#define RTM_CHANGE_TYPES_MASK     0x0007

//
// Queue data structure used below
//

typedef struct _QUEUE
{
    UINT              Front;
    UINT              Rear;
    UINT              Size;
    PVOID             Array[1];
} QUEUE, *PQUEUE;


//
// Change Notification Info Block
//

typedef struct _NOTIFY_INFO
{
    OPEN_HEADER       NotifyHeader;     // Signature, Type and Reference Count

    PENTITY_INFO      OwningEntity;     // Entity that opened this notification

    RTM_VIEW_SET      TargetViews;      // Views that we are interested in

    UINT              NumberOfViews;    // Num. of views we are interested in

    RTM_NOTIFY_FLAGS  ChangeTypes;      // Change types we are interested in

    INT               CNIndex;          // Index for this CN registration

    CRITICAL_SECTION  NotifyLock;       // Lock that serializes ops on CN

    HANDLE            NotifyContext;    // Context for the new changes callback

    QUEUE             NotifyDests;      // Dests to be notified to this CN
}
NOTIFY_INFO, *PNOTIFY_INFO;



//
// Macros for testing, setting and reseting CN related bits
//

#define  IS_BIT_SET(Value, Bit)   (Value  &  (1 << (Bit)))

#define  SET_BIT(Value, Bit)      (Value |=  (1 << (Bit)))

#define  RESET_BIT(Value, Bit)    (Value &= ~(1 << (Bit)))

#define  LOCKED_SET_BIT(Value, BitIndex)                             \
     InterlockedExchangeAdd((PLONG) &(Value),  +(1 << (BitIndex)))

#define  LOCKED_RESET_BIT(Value, BitIndex)                           \
     InterlockedExchangeAdd((PLONG) &(Value),  -(1 << (BitIndex)))

//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_CHANGE_NOTIFICATION_LOCK(Notification)               \
    ACQUIRE_LOCK(&Notification->NotifyLock)

#define RELEASE_CHANGE_NOTIFICATION_LOCK(Notification)               \
    RELEASE_LOCK(&Notification->NotifyLock)

//
// Other misc macros
//

#define CHANGE_LIST_TO_INSERT(Dest)                                  \
    (UINT)(((*(ULONG *)&Dest->DestAddress.AddrBits) >> 8)            \
             % NUM_CHANGED_DEST_LISTS)                               \

//
// Queue manipulation macros
//

#define InitializeQueue(Q, N)                                        \
    (Q)->Front = 0;                                                  \
    (Q)->Rear = 0;                                                   \
    (Q)->Size = (N);                                                 \

#define IsQueueEmpty(Q)                                              \
    ((Q)->Front == (Q)->Rear)                                        \

#define EnqueueItem(Q, I, S)                                         \
{                                                                    \
    UINT _R_;                                                        \
                                                                     \
    _R_ = ((Q)->Rear + 1) % (Q)->Size;                               \
                                                                     \
    if ((Q)->Front == (_R_))                                         \
    {                                                                \
        (S) = TRUE;                                                  \
    }                                                                \
    else                                                             \
    {                                                                \
        (Q)->Rear = (_R_);                                           \
                                                                     \
        (Q)->Array[(Q)->Rear] = I;                                   \
                                                                     \
        (S) = FALSE;                                                 \
    }                                                                \
}                                                                    \

#define DequeueItem(Q, I)                                            \
                                                                     \
    if ((Q)->Front == (Q)->Rear)                                     \
    {                                                                \
        (*(I)) = NULL;                                               \
    }                                                                \
    else                                                             \
    {                                                                \
        ((Q)->Front)++;                                              \
                                                                     \
        ((Q)->Front) %= (Q)->Size;                                   \
                                                                     \
        (*(I)) = (Q)->Array[(Q)->Front];                             \
    }                                                                \


//
// Change Notification Helper Functions
//

DWORD
ComputeCNsToBeNotified (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      DWORD                           DestMarkedBits,
    IN      DWORD                          *ViewsForChangeType
    );

DWORD
AddToChangedDestLists (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      PDEST_INFO                      Dest,
    IN      ULONG                           NotifyCNs
    );

VOID 
NTAPI
ProcessChangedDestLists (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    );

#endif //__ROUTING_RTMCHNG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmenum.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmenum.c

Abstract:

    Contains routines for managing any enumerations
    over destinations, routes and next hops in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmCreateDestEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    IN      ULONG                           ProtocolId,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration over the destinations in the route table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    TargetViews    - Set of views in which the enumeration is done,

    EnumFlags      - Flags that control the dests returned in enum,

    NetAddress     - Start and/or stop address of the enumeration,
                     [ See a description of RTM_ENUM_FLAGS ...]

    Protocol Id    - Protocol Id that determines the best route
                     information returned in 'GetEnumDests' call,

    RtmEnumHandle  - Handle to this enumeration, which is used
                     in subsequent calls to get dests, and so on.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_ENUM      Enum;
    PUCHAR          AddrBits;
    UINT            AddrSize;
    UINT            i, j;
    DWORD           Status;
    BOOL            LockInited;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if ((EnumFlags & RTM_ENUM_NEXT) && (EnumFlags & RTM_ENUM_RANGE))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if (EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
    {
        if (!NetAddress)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // Is he interested in any non-supported views ?
    //

    if (TargetViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Create and initialize an dest enumeration block
    //

    Enum = (PDEST_ENUM) AllocNZeroObject(sizeof(DEST_ENUM));
    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
#if DBG_HDL
        Enum->EnumHeader.ObjectHeader.TypeSign = DEST_ENUM_ALLOC;
#endif
        Enum->EnumHeader.HandleType = DEST_ENUM_TYPE;

        Enum->TargetViews = TargetViews;

        Enum->NumberOfViews = NUMBER_OF_BITS(TargetViews);

        Enum->ProtocolId = ProtocolId;

        Enum->EnumFlags = EnumFlags;

#if DBG
        // Initialize the first address in the enum

        if (Enum->EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
        {
            CopyMemory(&Enum->StartAddress,
                       NetAddress, 
                       sizeof(RTM_NET_ADDRESS));
        }
#endif

        AddrSize = AddrFamInfo->AddressSize;

        //
        // Initialize the last address in the enum
        //

        if (Enum->EnumFlags & RTM_ENUM_RANGE)
        {
            //
            // Convert the NetAddress a.b/n -> a.b.FF.FF/N where N = ADDRSIZE
            //

            Enum->StopAddress.AddressFamily = NetAddress->AddressFamily;

            Enum->StopAddress.NumBits = (USHORT) (AddrSize * BITS_IN_BYTE);

            AddrBits = Enum->StopAddress.AddrBits;

            for (i = 0; i < (NetAddress->NumBits / BITS_IN_BYTE); i++)
            {
                AddrBits[i] = NetAddress->AddrBits[i];
            }

            j = i;

            for (; i < AddrSize; i++)
            {
                AddrBits[i] = 0xFF;
            }

            if (j < AddrSize)
            {
                AddrBits[j] >>= (NetAddress->NumBits % BITS_IN_BYTE);

                AddrBits[j] |= NetAddress->AddrBits[j];
            }
        }

        LockInited = FALSE;
        
        try
        {
            InitializeCriticalSection(&Enum->EnumLock);
            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Initialize the next destination context

        if (EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
        {
            CopyMemory(&Enum->NextDest,
                       NetAddress,
                       sizeof(RTM_NET_ADDRESS));
        }

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Enum->EnumHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, ENUM_REF);

        //
        // Make a handle to the enum block and return
        //

        *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

#if DBG_HDL
    Enum->EnumHeader.ObjectHeader.TypeSign = DEST_ENUM_FREED;
#endif

    if (LockInited)
    {
        DeleteCriticalSection(&Enum->EnumLock);
    }
    
    FreeObject(Enum);

    *RtmEnumHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetEnumDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  DestInfos
    )

/*++

Routine Description:

    Gets the next set of destinations in the given enumeration
    on the route table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the destination enumeration,

    NumDests       - Num. of DestInfo's in output is passed in,
                     Num. of DestInfo's copied out is returned.

    DestInfos      - Output buffer where destination info is retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_ENUM      Enum;
    LOOKUP_CONTEXT  Context;
    PUCHAR          EndofBuffer;
    UINT            DestInfoSize;
    UINT            DestsInput;
    UINT            DestsCopied;
    UINT            DestsLeft;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE*DestData;
    PROUTE_INFO     Route;
    USHORT          StopNumBits;
    PUCHAR          StopKeyBits;
    UINT            i, j;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    DestsInput = *NumDests;

    *NumDests = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_DEST_ENUM_HANDLE(EnumHandle, &Enum);

    AddrFamInfo = Entity->OwningAddrFamily;

    if ((DestsInput > AddrFamInfo->MaxHandlesInEnum) ||
        (DestsInput < 1))
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Acquire lock to block other RtmGetEnumDests
    ACQUIRE_DEST_ENUM_LOCK(Enum);

    // Make sure enum is active at this point
    if (Enum->EnumDone)
    {
        RELEASE_DEST_ENUM_LOCK(Enum);

        return ERROR_NO_MORE_ITEMS;
    }


    //
    // Get the next set of destinations from table
    //

    // Initialize the lookup context before Enum
    ZeroMemory(&Context, sizeof(LOOKUP_CONTEXT));

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(Enum->NumberOfViews);

    EndofBuffer = (PUCHAR) DestInfos + DestsInput * DestInfoSize;

    DestsLeft = DestsInput;

    DestsCopied = 0;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    do
    {
        // Use the end of the caller's buffer as temp space

        DestData = (PLOOKUP_LINKAGE *) (EndofBuffer - 
                                        DestsLeft * sizeof(PLOOKUP_LINKAGE));

        if (Enum->EnumFlags & RTM_ENUM_RANGE)
        {
            StopNumBits = Enum->StopAddress.NumBits;
            StopKeyBits = Enum->StopAddress.AddrBits;
        }
        else
        {
            StopNumBits = 0;
            StopKeyBits = NULL;
        }

        Status = EnumOverTable(AddrFamInfo->RouteTable,
                               &Enum->NextDest.NumBits,
                               Enum->NextDest.AddrBits,
                               &Context,
                               StopNumBits,
                               StopKeyBits,
                               &DestsLeft,
                               DestData);

        for (i = 0; i < DestsLeft; i++)
        {
            Dest = CONTAINING_RECORD(DestData[i], DEST_INFO, LookupLinkage);
          
            if ((Enum->TargetViews == RTM_VIEW_MASK_ANY) || 
                (Dest->BelongsToViews & Enum->TargetViews))
            {
                if (Enum->EnumFlags & RTM_ENUM_OWN_DESTS)
                {
                    // Check if this dest is owned in any view by caller
                    
                    for (j = 0; j < AddrFamInfo->NumberOfViews; j++)
                    {
                        Route = Dest->ViewInfo[j].BestRoute;

                        if (Route)
                        {
                            if (Route->RouteInfo.RouteOwner == RtmRegHandle)
                            {
                                break;
                            }
                        }
                    }

                    if (j == AddrFamInfo->NumberOfViews)
                    {
                        continue;
                    }
                }

                //
                // Get the destination info from the dest
                //

                GetDestInfo(Entity, 
                            Dest, 
                            Enum->ProtocolId, 
                            Enum->TargetViews, 
                            DestInfos);

                DestsCopied++;

                DestInfos = (PRTM_DEST_INFO)(DestInfoSize + (PUCHAR)DestInfos);
            }
        }

        DestsLeft = DestsInput - DestsCopied;
    }
    while (SUCCESS(Status) && (DestsLeft > 0));

    //
    // We have no more dests, or we have filled output
    //

    ASSERT(!SUCCESS(Status) || ((PUCHAR) DestInfos == (PUCHAR) EndofBuffer));

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    // If we are at end of the enum, make enum as done

    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Enum->EnumDone = TRUE;
    }

    RELEASE_DEST_ENUM_LOCK(Enum);

    *NumDests = DestsCopied;

    return *NumDests ? NO_ERROR : ERROR_NO_MORE_ITEMS;
}


DWORD
WINAPI
RtmReleaseDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  DestInfos
    )

/*++

Routine Description:

    Release destination information obtained in other calls -
    like dest enumerations.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumDests       - Number of dest infos that are being released,

    DestInfos      - Array of dest infos that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    UINT            NumViews;
    UINT            DestInfoSize;
    UINT            i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Get the size of each info in dest info array
    //

    NumViews = ((PRTM_DEST_INFO) DestInfos)->NumberOfViews;

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(NumViews);

    //
    // Dereference each dest info in array
    //

    for (i = 0; i < NumDests; i++)
    {
        RtmReleaseDestInfo(RtmRegHandle, DestInfos);

        DestInfos = (PRTM_DEST_INFO)(DestInfoSize + (PUCHAR)DestInfos);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmCreateRouteEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle        OPTIONAL,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                StartDest         OPTIONAL,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRoute     OPTIONAL,
    IN      ULONG                           CriteriaInterface OPTIONAL,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration over the routes on a particular dest
    in the route table. If the dest is NULL, an enumeration is
    created over the whole route table.

    If matching flags are specified, only routes that match the
    criteria are returned.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    DestHandle     - The destination whose routes we are enum'ing,
                     Or NULL if we are enum'ing over all dests.

    TargetViews    - Set of views in which the enumeration is done,

    EnumFlags      - Flags that control the routes retd in enum,

    MatchingFlags  - Indicates the elements of the route to match,

    CriteriaRoute  - Values to match each route in the enum,

    CritInterface  - Interface on which routes should fall on,

    RtmEnumHandle  - Handle to this enumeration, which is used
                     in subsequent calls to get routes, and so on.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PROUTE_ENUM     Enum;
    PDEST_INFO      Dest;
    BOOL            LockInited;
    ULONG           NumBytes;
    DWORD           Status;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

#if WRN
    Dest = NULL;
#endif

    if (ARGUMENT_PRESENT(DestHandle))
    {
        // StartDest doesnt apply if enum'ing a dest
        if (ARGUMENT_PRESENT(StartDest))
        {
            return ERROR_INVALID_PARAMETER;
        }

        VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    }

    // If we have matching flags, we need corr. route
    if (MatchingFlags & ~RTM_MATCH_INTERFACE)
    {
        if (!ARGUMENT_PRESENT(CriteriaRoute))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Is he interested in any non-supported views ?
    //

    if (TargetViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Create and initialize a route enumeration block
    //

    Enum = (PROUTE_ENUM) AllocNZeroObject(sizeof(ROUTE_ENUM));

    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    LockInited = FALSE;

#if WRN
    Status = ERROR_GEN_FAILURE;
#endif

    do
    {
#if DBG_HDL
        Enum->EnumHeader.ObjectHeader.TypeSign = ROUTE_ENUM_ALLOC;
#endif
        Enum->EnumHeader.HandleType = ROUTE_ENUM_TYPE;

        Enum->TargetViews = TargetViews;

        Enum->EnumFlags = EnumFlags;

        if (MatchingFlags)
        {
            Enum->MatchFlags = MatchingFlags;

            if (MatchingFlags & ~RTM_MATCH_INTERFACE)
            {
                NumBytes = sizeof(RTM_ROUTE_INFO) +
                           (AddrFamInfo->MaxNextHopsInRoute - 1) *
                           sizeof(RTM_NEXTHOP_HANDLE);

                Enum->CriteriaRoute = AllocMemory(NumBytes);

                if (Enum->CriteriaRoute == NULL)
                {
                    break;
                }

                CopyMemory(Enum->CriteriaRoute, CriteriaRoute, NumBytes);
            }

            Enum->CriteriaInterface = CriteriaInterface;
        }

        //
        // Initialize the lock to serialize enum requests
        //

        try
        {
            InitializeCriticalSection(&Enum->EnumLock);
            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        //
        // Are we enumerating routes on all destinations ?
        //

        if (!ARGUMENT_PRESENT(DestHandle))
        {
            //
            // Create a temp dest info structure for enum
            //

            Enum->DestInfo = AllocDestInfo(AddrFamInfo->NumberOfViews);

            if (Enum->DestInfo == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            // Open a dest enumeration to get all dests
            //

            Status = RtmCreateDestEnum(RtmRegHandle,
                                       TargetViews,
                                       EnumFlags,
                                       StartDest,
                                       RTM_BEST_PROTOCOL,
                                       &Enum->DestEnum);

            if (!SUCCESS(Status))
            {
                break;
            }
        }
        else
        {
            //
            // Ref dest whose routes we are enum'ing
            //

            Enum->Destination = Dest;

            REFERENCE_DEST(Dest, ENUM_REF);
        }

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Enum->EnumHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, ENUM_REF);

        //
        // Make a handle to the enum block and return
        //

        *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

    if (Enum->DestInfo)
    {
        FreeMemory(Enum->DestInfo);
    }

    if (LockInited)
    {
        DeleteCriticalSection(&Enum->EnumLock);
    }

    if (Enum->CriteriaRoute)
    {
        FreeMemory(Enum->CriteriaRoute);
    }

    FreeObject(Enum);

    *RtmEnumHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Gets the next set of routes in the given enumeration on the
    route table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the route enumeration,

    NumRoutes      - Max. number of routes to fill is passed in,
                     Num. of routes actually copied is returned.

    RouteHandles   - Output buffer where route handles are retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PROUTE_ENUM     Enum;
    PDEST_INFO      Dest;
    PROUTE_INFO     Route;
    PROUTE_INFO    *NextRoute;
    UINT            NumDests;
    UINT            RoutesInput;
    UINT            RoutesCopied;
    UINT            RoutesOnDest;
    UINT            RoutesToCopy;
    PLIST_ENTRY     p;
    UINT            i;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    RoutesInput = *NumRoutes;

    *NumRoutes = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_ENUM_HANDLE(EnumHandle, &Enum);

    AddrFamInfo = Entity->OwningAddrFamily;

    if ((RoutesInput > AddrFamInfo->MaxHandlesInEnum) ||
        (RoutesInput < 1))
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Acquire lock to block other RtmGetEnumRoutes
    ACQUIRE_ROUTE_ENUM_LOCK(Enum);

    // Make sure enum is active at this point
    if (Enum->EnumDone)
    {
        RELEASE_ROUTE_ENUM_LOCK(Enum);

        return ERROR_NO_MORE_ITEMS;
    }


    //
    // Get more routes until you satisfy the request
    //

    Status = NO_ERROR;

    RoutesCopied = 0;

    do
    {
        //
        // Do we have any routes in current snapshot ?
        //

        RoutesOnDest = Enum->NumRoutes - Enum->NextRoute;

        if (RoutesOnDest == 0)
        {
            //
            // Destination value in the enum is not set if
            //
            //    1. we are doing an enum over the whole
            //       table, and 
            //
            //    2. we did not run out of memory in the
            //       previous attempt to take a snapshot
            //       ( if we did make an attempt before )
            //

            if (Enum->Destination == NULL)
            {
                ASSERT(Enum->DestEnum);

                //
                // Get the next destination in the table
                //

                NumDests = 1;

                Status = RtmGetEnumDests(RtmRegHandle,
                                         Enum->DestEnum,
                                         &NumDests,
                                         Enum->DestInfo);

                if (NumDests < 1)
                {
                    break;
                }

                Dest = DEST_FROM_HANDLE(Enum->DestInfo->DestHandle);

                Enum->Destination = Dest;

                REFERENCE_DEST(Dest, ENUM_REF);

                RtmReleaseDestInfo(RtmRegHandle,
                                   Enum->DestInfo);
            }
            else
            {
                Dest = Enum->Destination;
            }

            ASSERT(Enum->Destination != NULL);


            //
            // Allocate memory to hold snapshot of routes
            //

            ACQUIRE_DEST_READ_LOCK(Dest);

            if (Enum->MaxRoutes < Dest->NumRoutes)
            {
                //
                // Re-adjust the size of snapshot buffer
                //

                if (Enum->RoutesOnDest)
                {
                    FreeMemory(Enum->RoutesOnDest);
                }

                Enum->RoutesOnDest = (PROUTE_INFO *)
                                      AllocNZeroMemory(Dest->NumRoutes * 
                                                      sizeof(PROUTE_INFO));

                if (Enum->RoutesOnDest == NULL)
                {
                    RELEASE_DEST_READ_LOCK(Dest);

                    Enum->MaxRoutes = 0;
                    Enum->NumRoutes = 0;
                    Enum->NextRoute = 0;

                    Status = ERROR_NOT_ENOUGH_MEMORY;

                    break;
                }

                Enum->MaxRoutes = Dest->NumRoutes;
            }


            //
            // Get snapshot of all routes on this dest
            //

            Enum->NumRoutes = Enum->NextRoute = 0;

            for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p= p->Flink)
            {
                Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                //
                // Does this route belong one of interesting views ?
                //

                if ((Enum->TargetViews == RTM_VIEW_MASK_ANY) || 
                    (Route->RouteInfo.BelongsToViews & Enum->TargetViews))
                {
                    if (Enum->EnumFlags & RTM_ENUM_OWN_ROUTES)
                    {
                        // Check if this route is owned by the caller
                    
                        if (Route->RouteInfo.RouteOwner != RtmRegHandle)
                        {
                            continue;
                        }
                    }

                    // Does this route match the enumeration criteria ?

                    if (Enum->MatchFlags && 
                        !MatchRouteWithCriteria(Route,
                                                Enum->MatchFlags,
                                                Enum->CriteriaRoute,
                                                Enum->CriteriaInterface))
                    {
                        continue;
                    }

                    REFERENCE_ROUTE(Route, ENUM_REF);

                    //
                    // Reference the route and copy the handle to output
                    //

                    Enum->RoutesOnDest[Enum->NumRoutes++] = Route;
                }
            }

            ASSERT(Enum->NumRoutes <= Dest->NumRoutes);

            RELEASE_DEST_READ_LOCK(Dest);

            //
            // If we are enum'ing the whole table, we do
            // not need the dest whose snapshot is taken
            //

            if (Enum->DestEnum)
            {
                Enum->Destination = NULL;

                DEREFERENCE_DEST(Dest, ENUM_REF);
            }

            // Adjust the number of routes on the dest

            RoutesOnDest = Enum->NumRoutes - Enum->NextRoute;
        }

        //
        // Copy routes to output from the current snapshot
        //

        if (RoutesOnDest)
        {
            RoutesToCopy = RoutesInput - RoutesCopied;

            if (RoutesToCopy > RoutesOnDest)
            {
                RoutesToCopy = RoutesOnDest;
            }

            NextRoute = &Enum->RoutesOnDest[Enum->NextRoute];

            for (i = 0; i < RoutesToCopy; i++)
            {
#if DBG_REF
                REFERENCE_ROUTE(*NextRoute, HANDLE_REF);

                DEREFERENCE_ROUTE(*NextRoute, ENUM_REF);
#endif
                RouteHandles[RoutesCopied++] = 
                    MAKE_HANDLE_FROM_POINTER(*NextRoute++);
            }

            Enum->NextRoute += RoutesToCopy;

            RoutesOnDest -= RoutesToCopy;
        }

        //
        // Are we done with all the routes in snapshot ?
        //

        if (RoutesOnDest == 0)
        {
            //
            // If we are enum'ing a single dest, we are done
            //

            if (Enum->DestEnum == NULL)
            {
                Status = ERROR_NO_MORE_ITEMS;
                break;
            }
        }
    }
    while (SUCCESS(Status) && (RoutesCopied < RoutesInput));

    // If we are at end of the enum, make enum as done
    if ((Status == ERROR_NO_MORE_ITEMS) && (RoutesOnDest == 0))
    {
        Enum->EnumDone = TRUE;
    }

    RELEASE_ROUTE_ENUM_LOCK(Enum);

    //
    // Update output to reflect number of routes copied
    //

    *NumRoutes = RoutesCopied;

    return *NumRoutes ? NO_ERROR : ERROR_NO_MORE_ITEMS;
}


BOOL
MatchRouteWithCriteria (
    IN      PROUTE_INFO                     Route,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRouteInfo,
    IN      ULONG                           CriteriaInterface
    )

/*++

Routine Description:

    Matches a route with the input criteria given by input flags
    and the route to match.

Arguments:

    Route             - Route that we are matching criteria with,

    MatchingFlags     - Flags that indicate which fields to match,

    CriteriaRouteInfo - Route info that specifies match criteria,

    CriteriaInterface - Interface to match if MATCH_INTERFACE is set.

Return Value:

    TRUE if route matches criteria, FALSE if not

--*/

{
    PRTM_NEXTHOP_HANDLE NextHops;
    PNEXTHOP_INFO       NextHop;
    UINT                NumNHops;
    UINT                i;

    //
    // Try matching the route owner if flags say so
    //

    if (MatchingFlags & RTM_MATCH_OWNER)
    {
        if (Route->RouteInfo.RouteOwner != CriteriaRouteInfo->RouteOwner)
        {
            return FALSE;
        }
    }

    //
    // Try matching the neighbour if flags say so
    //

    if (MatchingFlags & RTM_MATCH_NEIGHBOUR)
    {
        if (Route->RouteInfo.Neighbour != CriteriaRouteInfo->Neighbour)
        {
            return FALSE;
        }
    }

    //
    // Try matching the preference if flags say so
    //

    if (MatchingFlags & RTM_MATCH_PREF)
    {
        if (!IsPrefEqual(&Route->RouteInfo, CriteriaRouteInfo))
        {
            return FALSE;
        }
    }

    //
    // Try matching the interface if flags say so
    //

    if (MatchingFlags & RTM_MATCH_INTERFACE)
    {
        NumNHops = Route->RouteInfo.NextHopsList.NumNextHops;
        NextHops = Route->RouteInfo.NextHopsList.NextHops;

        for (i = 0; i < NumNHops; i++)
        {
            NextHop = NEXTHOP_FROM_HANDLE(NextHops[i]);

            if (NextHop->NextHopInfo.InterfaceIndex == CriteriaInterface)
            {
                break;
            }
        }

        if (i == NumNHops)
        {
            return FALSE;
        }        
    }

    //
    // Try matching the nexthop if flags say so
    //

    if (MatchingFlags & RTM_MATCH_NEXTHOP)
    {
        NumNHops = Route->RouteInfo.NextHopsList.NumNextHops;
        NextHops = Route->RouteInfo.NextHopsList.NextHops;

        ASSERT(CriteriaRouteInfo->NextHopsList.NumNextHops == 1);

        for (i = 0; i < NumNHops; i++)
        {
            if (NextHops[i] == CriteriaRouteInfo->NextHopsList.NextHops[0])
            {
                break;
            }
        }

        if (i == NumNHops)
        {
            return FALSE;
        }
    }

    return TRUE;
}


DWORD
WINAPI
RtmReleaseRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Release (also called de-reference) handles to routes
    obtained in other RTM calls like route enumerations.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumRoutes      - Number of handles that are being released,

    RouteHandles   - An array of handles that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PROUTE_INFO      Route;
    UINT             i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each route handle in array
    //

    for (i = 0; i < NumRoutes; i++)
    {
        Route = ROUTE_FROM_HANDLE(RouteHandles[i]);

        DEREFERENCE_ROUTE(Route, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmCreateNextHopEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration over all the next-hops in table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumFlags      - Flags that control the nexthops retd in enum,

    NetAddress     - Start and/or stop address of the enumeration,
                      [ See a description of RTM_ENUM_FLAGS ...]

    RtmEnumHandle  - Handle to this enumeration, which is used in
                     subsequent calls to get next-hops, and so on.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNEXTHOP_ENUM   Enum;
    PUCHAR          AddrBits;
    UINT            AddrSize;
    UINT            i, j;
    DWORD           Status;
    BOOL            LockInited;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if ((EnumFlags & RTM_ENUM_NEXT) && (EnumFlags & RTM_ENUM_RANGE))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if (EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
    {
        if (!NetAddress)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Create and initialize an nexthop enumeration block
    //

    Enum = (PNEXTHOP_ENUM) AllocNZeroObject(sizeof(NEXTHOP_ENUM));
    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
#if DBG_HDL
        Enum->EnumHeader.ObjectHeader.TypeSign = NEXTHOP_ENUM_ALLOC;
#endif
        Enum->EnumHeader.HandleType = NEXTHOP_ENUM_TYPE;

        Enum->EnumFlags = EnumFlags;

#if DBG
        // Initialize the first address in the enum

        if (Enum->EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
        {
            CopyMemory(&Enum->StartAddress,
                       NetAddress, 
                       sizeof(RTM_NET_ADDRESS));
        }
#endif

        AddrSize = Entity->OwningAddrFamily->AddressSize;

        //
        // Initialize the last address in the enum
        //

        if (Enum->EnumFlags & RTM_ENUM_RANGE)
        {
            //
            // Convert the NetAddress a.b/n -> a.b.FF.FF/N where N = ADDRSIZE
            //

            Enum->StopAddress.AddressFamily = NetAddress->AddressFamily;

            Enum->StopAddress.NumBits = (USHORT) (AddrSize * BITS_IN_BYTE);

            AddrBits = Enum->StopAddress.AddrBits;

            for (i = 0; i < (NetAddress->NumBits / BITS_IN_BYTE); i++)
            {
                AddrBits[i] = NetAddress->AddrBits[i];
            }

            j = i;

            for (; i < AddrSize; i++)
            {
                AddrBits[i] = 0xFF;
            }

            if (j < AddrSize)
            {
                AddrBits[j] >>= (NetAddress->NumBits % BITS_IN_BYTE);

                AddrBits[j] |= NetAddress->AddrBits[j];
            }
        }

        LockInited = FALSE;
        try
        {
            InitializeCriticalSection(&Enum->EnumLock);
            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        // Initialize the next 'nexthop' context

        if (NetAddress)
        {
            CopyMemory(&Enum->NextAddress,
                       NetAddress,
                       sizeof(RTM_NET_ADDRESS));
        }

        Enum->NextIfIndex = START_IF_INDEX;

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Enum->EnumHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, ENUM_REF);

        //
        // Make a handle to the enum block and return
        //

        *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

#if DBG_HDL
    Enum->EnumHeader.ObjectHeader.TypeSign = NEXTHOP_ENUM_FREED;
#endif

    if (LockInited)
    {
        DeleteCriticalSection(&Enum->EnumLock);
    }
    
    FreeObject(Enum);

    *RtmEnumHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetEnumNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumNextHops,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandles
    )

/*++

Routine Description:

    Gets the next set of next-hops in the given enumeration
    on the next-hop table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the next-hop enumeration,

    NumNextHops    - Num. of next-hops in output is passed in,
                     Num. of next-hops copied out is returned.

    NextHopHandles - Output buffer where next-hop handles are retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNEXTHOP_ENUM   Enum;
    LOOKUP_CONTEXT  Context;
    PNEXTHOP_LIST   HopList;
    PNEXTHOP_INFO   NextHop;
    PLOOKUP_LINKAGE NextHopData;
    PLIST_ENTRY     NextHops, p;
    UINT            NextHopsInput;
    UINT            NextHopsCopied;
    UINT            NumHopLists;
    USHORT          StopNumBits;
    PUCHAR          StopKeyBits;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    NextHopsInput = *NumNextHops;

    *NumNextHops = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_ENUM_HANDLE(EnumHandle, &Enum);

    AddrFamInfo = Entity->OwningAddrFamily;

    if ((NextHopsInput > AddrFamInfo->MaxHandlesInEnum) ||
        (NextHopsInput < 1))
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Acquire lock to block other RtmGetEnumNextHops
    ACQUIRE_NEXTHOP_ENUM_LOCK(Enum);

    // Make sure enum is active at this point
    if (Enum->EnumDone)
    {
        RELEASE_NEXTHOP_ENUM_LOCK(Enum);

        return ERROR_NO_MORE_ITEMS;
    }


    // Initialize the lookup context before Enum
    ZeroMemory(&Context, sizeof(LOOKUP_CONTEXT));

    if (Enum->EnumFlags & RTM_ENUM_RANGE)
    {
        StopNumBits = Enum->StopAddress.NumBits;
        StopKeyBits = Enum->StopAddress.AddrBits;
    }
    else
    {
        StopNumBits = 0;
        StopKeyBits = NULL;
    }

    NextHopsCopied = 0;

    ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);

    do
    {
        //
        // Get the next list of next-hops from table
        //
        
        NumHopLists = 1;

        Status = EnumOverTable(Entity->NextHopTable,
                               &Enum->NextAddress.NumBits,
                               Enum->NextAddress.AddrBits,
                               &Context,
                               StopNumBits,
                               StopKeyBits,
                               &NumHopLists,
                               &NextHopData);

        if (NumHopLists < 1)
        {
            break;
        }

        HopList = CONTAINING_RECORD(NextHopData, NEXTHOP_LIST, LookupLinkage);

        NextHops = &HopList->NextHopsList;

        // Skip all the interface indices we have seen

        for (p = NextHops->Flink; p != NextHops; p = p->Flink)
        {
            NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

            if (NextHop->NextHopInfo.InterfaceIndex <= Enum->NextIfIndex)
            {
                break;
            }
        }

#if WRN
        NextHop = NULL;
#endif

        // Copy the rest of the next-hops in the list

        for ( ; p != NextHops; p = p->Flink)
        {
            NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

            if (NextHopsCopied == NextHopsInput)
            {
                break;
            }

            REFERENCE_NEXTHOP(NextHop, HANDLE_REF);

            NextHopHandles[NextHopsCopied++]=MAKE_HANDLE_FROM_POINTER(NextHop);
        }

        // If we are going to the next list, reset if index

        if (p == NextHops)
        {
            Enum->NextIfIndex = START_IF_INDEX;
        }
        else
        {
            // We have copied enough for this call

            ASSERT(NextHopsCopied == NextHopsInput);

            //
            // We still have next-hops on the list,
            // set back the next 'nexthop address'
            //

            Enum->NextAddress = NextHop->NextHopInfo.NextHopAddress;
            Enum->NextIfIndex = NextHop->NextHopInfo.InterfaceIndex;
                
            Status = NO_ERROR;
        }
    }
    while (SUCCESS(Status) && (NextHopsCopied < NextHopsInput));

    RELEASE_NHOP_TABLE_READ_LOCK(Entity);

    // If we are at end of the enum, make enum as done
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Enum->EnumDone = TRUE;
    }

    RELEASE_NEXTHOP_ENUM_LOCK(Enum);

    *NumNextHops = NextHopsCopied;

    return *NumNextHops ? NO_ERROR : ERROR_NO_MORE_ITEMS;
}


DWORD
WINAPI
RtmReleaseNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumNextHops,
    IN      PRTM_NEXTHOP_HANDLE             NextHopHandles
    )

/*++

Routine Description:

    Release (also called de-reference) handles to next-hops
    obtained in other RTM calls like next hop enumerations.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumNextHops    - Number of handles that are being released,

    NextHopHandles - An array of handles that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PNEXTHOP_INFO    NextHop;
    UINT             i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each nexthop handle in array
    //

    for (i = 0; i < NumNextHops; i++)
    {
        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandles[i]);

        DEREFERENCE_NEXTHOP(NextHop, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmDeleteEnumHandle (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle
    )

/*++

Routine Description:

    Deletes the enumeration handle and frees all resources
    allocated to the enumeration.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the enumeration.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    POPEN_HEADER     Enum;
    PROUTE_ENUM      RouteEnum;
    UCHAR            HandleType;
    UINT             i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Figure out the enum type and act accordingly
    //

    HandleType = GET_ENUM_TYPE(EnumHandle, &Enum);

#if DBG
    VALIDATE_OBJECT_HANDLE(EnumHandle, HandleType, &Enum);
#endif

    switch (HandleType)
    {

    case DEST_ENUM_TYPE:

        DeleteCriticalSection(&((PDEST_ENUM)Enum)->EnumLock);

        break;

    case ROUTE_ENUM_TYPE:

        RouteEnum = (PROUTE_ENUM) Enum;

        // Dereference the destination that we are enum'ing
        if (RouteEnum->Destination)
        {
            DEREFERENCE_DEST(RouteEnum->Destination, ENUM_REF);
        }

        //
        // Close the associated destination enum & resources
        //

        if (RouteEnum->DestInfo)
        {
            FreeMemory(RouteEnum->DestInfo);
        }

        if (RouteEnum->DestEnum)
        {
            RtmDeleteEnumHandle(RtmRegHandle, RouteEnum->DestEnum);
        }
       
        // Dereference all routes in the enum's snapshot
        for (i = RouteEnum->NextRoute; i < RouteEnum->NumRoutes; i++)
        {
            DEREFERENCE_ROUTE(RouteEnum->RoutesOnDest[i], ENUM_REF);
        }

        // Free memory associated with criteria matching
        if (RouteEnum->CriteriaRoute)
        {
            FreeMemory(RouteEnum->CriteriaRoute);
        }

        // Free memory allocated for the enum's snapshot
        FreeMemory(RouteEnum->RoutesOnDest);

        DeleteCriticalSection(&RouteEnum->EnumLock);

        break;

    case NEXTHOP_ENUM_TYPE:

        DeleteCriticalSection(&((PNEXTHOP_ENUM)Enum)->EnumLock);

        break;

    case LIST_ENUM_TYPE:

        //
        // Remove the enum's marker route from route list
        //

        ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

        RemoveEntryList(&((PLIST_ENUM)Enum)->MarkerRoute.RouteListLE);

        RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

#if DBG_HDL
    //
    // Remove from the list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    RemoveEntryList(&Enum->HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    DEREFERENCE_ENTITY(Entity, ENUM_REF);

    // Free the memory allocated for the enum and return

#if DBG_HDL
    Enum->ObjectHeader.Alloc = FREED;
#endif

    FreeObject(Enum);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmdbg.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmdbg.h

Abstract:
    Debugging in Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk) 1-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_RTMDBG_H__
#define __ROUTING_RTMDBG_H__

#if TESTING

//
// Bypass the system assert
//

#ifdef  ASSERT
#undef  ASSERT
#endif 
#define ASSERT(a)               { if ((a) == FALSE) DbgBreakPoint(); }

#endif

//
// Constants used for tracing
//

#define RTM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define RTM_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define RTM_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define RTM_TRACE_LEAVE           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define RTM_TRACE_LOCK            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define RTM_TRACE_REFS            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define RTM_TRACE_HANDLE          ((DWORD)0x00200000 | TRACE_USE_MASK)
#define RTM_TRACE_MEMORY          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define RTM_TRACE_START           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define RTM_TRACE_STOP            ((DWORD)0x01000000 | TRACE_USE_MASK)
#define RTM_TRACE_REGNS           ((DWORD)0x02000000 | TRACE_USE_MASK)
#define RTM_TRACE_ROUTE           ((DWORD)0x04000000 | TRACE_USE_MASK)
#define RTM_TRACE_QUERY           ((DWORD)0x08000000 | TRACE_USE_MASK)
#define RTM_TRACE_ENUM            ((DWORD)0x10000000 | TRACE_USE_MASK)
#define RTM_TRACE_NOTIFY          ((DWORD)0x20000000 | TRACE_USE_MASK)
#define RTM_TRACE_TIMER           ((DWORD)0x40080000 | TRACE_USE_MASK)
#define RTM_TRACE_CALLBACK        ((DWORD)0x80000000 | TRACE_USE_MASK)

//
// Macros used for tracing 
//

#define TRACEHANDLE         RtmGlobals.TracingHandle

#define START_TRACING()     TRACEHANDLE = TraceRegister("RTM")
            
#define STOP_TRACING()      TraceDeregister(TRACEHANDLE)

#define Trace0(l,a)             \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f, g)

#define Tracedump(l,a,b,c)      \
            TraceDumpEx(TRACEHANDLE,l,a,b,c,TRUE)

#if DBG_CAL

#define TraceEnter(X)    Trace0(ENTER, "Entered: "X)
#define TraceLeave(X)    Trace0(LEAVE, "Leaving: "X"\n")

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif

//
// Constants used in logging
//

#define RTM_LOGGING_NONE      0
#define RTM_LOGGING_ERROR     1
#define RTM_LOGGING_WARN      2
#define RTM_LOGGING_INFO      3

//
// Event logging macros
//

#define LOGHANDLE       RtmGlobals.LoggingHandle
#define LOGLEVEL        RtmGlobals.LoggingLevel
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData

//
// Error logging
//
#define START_LOGGING()     LOGHANDLE = RouterLogRegister("RTM")

#define STOP_LOGGING()      RouterLogDeregister(LOGHANDLE)

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

//
// Misc Debugging Macros
//

#define IPADDR_FORMAT(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define TracePrintAddress(ID, Dest, Mask)                   \
{                                                           \
    Trace2(ID, "Dest: %d.%d.%d.%d Mask: %d.%d.%d.%d",       \
           IPADDR_FORMAT(Dest),                             \
           IPADDR_FORMAT(Mask));                            \
}

#endif //__ROUTING_RTMDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmcnfg.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmcnfg.c

Abstract:
    Routines that operate on configuration
    information for RTM in the registry.

Author:
    Chaitanya Kodeboyina (chaitk) 21-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

DWORD
RtmWriteDefaultConfig (
    IN      USHORT                          RtmInstanceId
    )

/*++

Routine Description:

    Write default configuration information into the
    registry.
    
Arguments:

    RtmInstanceId  - Unique Id for this RTM instance

Return Value:

    Status of the operation.
    
--*/

{
    RTM_INSTANCE_CONFIG       InstanceConfig;
    RTM_ADDRESS_FAMILY_CONFIG AddrFamConfig;
    DWORD                     Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmWriteDefaultConfig");

    //
    // We have no RTM instance parameters at present
    //

    Status = RtmWriteInstanceConfig(RtmInstanceId, &InstanceConfig);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, "Default Config: Error %d writing instance key", Status);

        TraceLeave("RtmWriteDefaultConfig");

        return Status;
    }

    //
    // Set up default address family parameters
    //

    AddrFamConfig.AddressSize = DEFAULT_ADDRESS_SIZE;

    AddrFamConfig.MaxOpaqueInfoPtrs = DEFAULT_OPAQUE_INFO_PTRS;
    AddrFamConfig.MaxNextHopsInRoute = DEFAULT_NEXTHOPS_IN_ROUTE;

    AddrFamConfig.ViewsSupported = DEFAULT_VIEWS_SUPPORTED;
    
    AddrFamConfig.MaxHandlesInEnum = DEFAULT_MAX_HANDLES_IN_ENUM;
    AddrFamConfig.MaxChangeNotifyRegns = DEFAULT_MAX_NOTIFY_REGS;

    //
    // Write the default address family config
    //

    Status = RtmWriteAddressFamilyConfig(RtmInstanceId,
                                         AF_INET,
                                         &AddrFamConfig);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, 
               "Default Config: Error %d writing address family subkey",
               Status);
    }

    TraceLeave("RtmWriteDefaultConfig");

    return Status;
}


DWORD
WINAPI
RtmReadInstanceConfig (
    IN      USHORT                          RtmInstanceId,
    OUT     PRTM_INSTANCE_CONFIG            InstanceConfig
    )

/*++

Routine Description:

    Reads the configuration information for a particular
    instance at creation time.
    
Arguments:

    RtmInstanceId  - Unique Id for this instance,

    InstanceConfig - Buffer in which config info is retd.

Return Value:

    Status of the operation.
    
--*/

{
    HKEY     ConfigHandle;
    ULONG    KeySize;
    DWORD    Status;

    UNREFERENCED_PARAMETER(InstanceConfig);

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmReadInstanceConfig");

    //
    // Open the key that holds this instance's config
    //

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
             (MAX_CONFIG_KEY_SIZE - RTM_CONFIG_ROOT_SIZE)/sizeof(TCHAR),
              REG_KEY_INSTANCE_TEMPLATE,
              RtmInstanceId);

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          RtmGlobals.RegistryPath,
                          0,
                          KEY_READ,
                          &ConfigHandle);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, "Instance Config: Error %d opening instance key", Status);

        TraceLeave("RtmReadInstanceConfig");

        return Status;
    }

    do
    {
        //
        // Query values for parameters in instance config
        //

        KeySize = sizeof(DWORD);


        // Nothing in the instance config at present


        //
        // Close the instance key once you are done querying
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmReadInstanceConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error in the config - close handle and ret error
    //

    RegCloseKey(ConfigHandle);

    TraceLeave("RtmReadInstanceConfig");

    return (Status != NO_ERROR) ? Status: ERROR_BAD_CONFIGURATION;
}


DWORD
WINAPI
RtmWriteInstanceConfig (
    IN      USHORT                          RtmInstanceId,
    IN      PRTM_INSTANCE_CONFIG            InstanceConfig
    )

/*++

Routine Description:

    Write the input instance config information into the
    registry.
    
Arguments:

    RtmInstanceId  - Unique Id for this instance,

    InstanceConfig - Config info for this instance.

Return Value:

    Status of the operation.
    
--*/

{
    HKEY     ConfigHandle;
    DWORD    Status;

    UNREFERENCED_PARAMETER(InstanceConfig);

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmWriteInstanceConfig");

    //
    // Create a key (or open existing) to hold instance's config
    //

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              (MAX_CONFIG_KEY_SIZE - RTM_CONFIG_ROOT_SIZE)/sizeof(TCHAR),
              REG_KEY_INSTANCE_TEMPLATE,
              RtmInstanceId);

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            RtmGlobals.RegistryPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &ConfigHandle,
                            NULL);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, "Instance Config: Error %d creating instance key", Status);

        TraceLeave("RtmWriteInstanceConfig");

        return Status;
    }

    do
    {
        //
        // Write values in instance config into the registry
        //


        // Nothing in the instance config at present time


        //
        // Close the instance key once you are done writing
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmWriteInstanceConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Error writing values; close the handle and delete the key
    //

    Trace1(ERR, 
           "Instance Config: Error %d writing instance config parameters",
           Status);

    RegCloseKey(ConfigHandle);

    RegDeleteKey(HKEY_LOCAL_MACHINE, RtmGlobals.RegistryPath);

    TraceLeave("RtmWriteInstanceConfig");

    return Status;
}


DWORD
WINAPI
RtmReadAddressFamilyConfig (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    OUT     PRTM_ADDRESS_FAMILY_CONFIG      AddrFamilyConfig
    )

/*++

Routine Description:

    Reads the configuration information for a particular
    address family at creation time.
    
Arguments:

    RtmInstanceId    - ID (IPv4..) for this addr family info,

    AddrFamilyConfig - Buffer in which addr family info is retd.

Return Value:

    Status of the operation.
    
--*/

{
    HKEY     ConfigHandle;
    ULONG    KeySize;
    ULONG    KeyValue;
    ULONG    KeyType;
    DWORD    Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmReadAddressFamilyConfig");

    //
    // Open the key that holds this address family's config
    //
        
    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              (MAX_CONFIG_KEY_SIZE - RTM_CONFIG_ROOT_SIZE)/sizeof(TCHAR),
              REG_KEY_ADDR_FAMILY_TEMPLATE,
              RtmInstanceId,
              AddressFamily);
    
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          RtmGlobals.RegistryPath,
                          0,
                          KEY_READ,
                          &ConfigHandle);
    
    if (Status != NO_ERROR)
    {
        Trace1(ERR, 
               "Address Family Config: Error %d opening address family key", 
               Status);

        TraceLeave("RtmReadAddressFamilyConfig");

        return Status;
    }

    do
    {
        //
        // Query values for parameters in address family config
        //

        KeySize = sizeof(DWORD);

        //
        // Query the 'address size' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_ADDRESS_SIZE,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        if ((Status != NO_ERROR) || (KeyType != REG_DWORD))
        {
            Trace1(ERR, 
                   "Address Family Config: Error %d reading address size key",
                   Status);
            break;
        }

        if ((KeyValue < MINIMUM_ADDRESS_SIZE) ||
            (KeyValue > MAXIMUM_ADDRESS_SIZE))
        {
            Trace1(ERR, 
                   "Address Family Config: Address Size %d out of bounds", 
                   KeyValue);
            break;
        }
         
        AddrFamilyConfig->AddressSize = KeyValue;


        //
        // Query the 'views supported' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_VIEWS_SUPPORTED,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);
        
        AddrFamilyConfig->ViewsSupported = DEFAULT_VIEWS_SUPPORTED;

        if (Status == NO_ERROR)
        {
            if (KeyValue == 0)
            {
                Trace0(ERR, "Address Family Config: No supported views");
                break;
            }

            AddrFamilyConfig->ViewsSupported = KeyValue;
        }


        //
        // Query the 'max change notifications' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_MAX_NOTIFY_REGS,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxChangeNotifyRegns = DEFAULT_MAX_NOTIFY_REGS;

        if (Status == NO_ERROR)
        {
            if ((KeyValue < MIN_MAX_NOTIFY_REGS) ||
                (KeyValue > MAX_MAX_NOTIFY_REGS))
            {
                Trace1(ERR,
                       "Address Family Config: # notifications out of range",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxChangeNotifyRegns = KeyValue;
        }


        //
        // Query the 'max opaque info ptrs' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_OPAQUE_INFO_PTRS,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxOpaqueInfoPtrs = DEFAULT_OPAQUE_INFO_PTRS;

        if (Status == NO_ERROR)
        {
            if (((int)KeyValue < MIN_OPAQUE_INFO_PTRS) ||
                (KeyValue > MAX_OPAQUE_INFO_PTRS))
            {
                Trace1(ERR,
                       "Address Family Config: # opaque ptrs out of range",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxOpaqueInfoPtrs = KeyValue;
        }


        //
        // Query the 'max next hops per route' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_NEXTHOPS_IN_ROUTE,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxNextHopsInRoute = DEFAULT_NEXTHOPS_IN_ROUTE;

        if (Status == NO_ERROR)
        {
            if ((KeyValue < MIN_NEXTHOPS_IN_ROUTE) ||
                (KeyValue > MAX_NEXTHOPS_IN_ROUTE))
            {
                Trace1(ERR, 
                       "Address Family Config: # nexthops out of range",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxNextHopsInRoute = KeyValue;
        }


        //
        // Query the 'max handles returned in enum' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_MAX_HANDLES_IN_ENUM,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxHandlesInEnum = DEFAULT_MAX_HANDLES_IN_ENUM;

        if (Status == NO_ERROR)
        {
            if ((KeyValue < MIN_MAX_HANDLES_IN_ENUM) ||
                (KeyValue > MAX_MAX_HANDLES_IN_ENUM))
            {
                Trace1(ERR, 
                       "Address Family Config: # handles returned in enum",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxHandlesInEnum = KeyValue;
        }

        //
        // Close the instance key once you are done querying
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmReadAddressFamilyConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error in the config - close handle and ret error
    //

    RegCloseKey(ConfigHandle);

    TraceLeave("RtmReadAddressFamilyConfig");

    return (Status != NO_ERROR) ? Status: ERROR_BAD_CONFIGURATION;
}


DWORD
WINAPI
RtmWriteAddressFamilyConfig (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    IN      PRTM_ADDRESS_FAMILY_CONFIG      AddrFamilyConfig
    )

/*++

Routine Description:

    Write the input address family config information
    into the registry.
    
Arguments:

    RtmInstanceId    - Instance to which addr family belongs to,

    AddressFamily    - ID for this address family,

    AddrFamilyConfig - Configuration info for this address family.

Return Value:

    Status of the operation.
    
--*/

{
    TCHAR    AddressFamilySubKey[MAX_CONFIG_KEY_SIZE];
    HKEY     InstanceConfig;
    HKEY     ConfigHandle;
    ULONG    KeyValue;
    DWORD    Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmWriteAddressFamilyConfig");

    //
    // Open the existing key that holds this RTM instance's config
    //

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              (MAX_CONFIG_KEY_SIZE - RTM_CONFIG_ROOT_SIZE)/sizeof(TCHAR),
              REG_KEY_INSTANCE_TEMPLATE,
              RtmInstanceId);

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          RtmGlobals.RegistryPath,
                          0,
                          KEY_READ,
                          &InstanceConfig);

    if (Status != NO_ERROR)
    {
        //
        // Need to create an instance before creating addr family
        //

        Trace1(ERR, 
               "Address Family Config: Error %d opening instance key", 
               Status);

        TraceLeave("RtmWriteAddressFamilyConfig");

        return Status;
    }

    //
    // Create (or open existing) key to hold addr family's config
    //

    AddressFamilySubKey[MAX_CONFIG_KEY_SIZE - 1] = '\0';

    _snprintf(AddressFamilySubKey,
              (MAX_CONFIG_KEY_SIZE - 1)/sizeof(TCHAR),
              REG_KEY_ADDR_FAMILY_SUBKEY,
              AddressFamily);

    Status = RegCreateKeyEx(InstanceConfig,
                            AddressFamilySubKey,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &ConfigHandle,
                            NULL);

    // Close the instance key as you no longer need it
    RegCloseKey(InstanceConfig);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, 
               "Address Family Config: Error %d creating address family key",
               Status);

        TraceLeave("RtmWriteAddressFamilyConfig");

        return Status;
    }

    //
    // Write values in address family config into the registry
    //

    do
    {
        //
        // Write the 'address size' value into the registry
        //

        KeyValue = AddrFamilyConfig->AddressSize;
        if ((KeyValue < MINIMUM_ADDRESS_SIZE) ||
            (KeyValue > MAXIMUM_ADDRESS_SIZE))
        {
            Trace1(ERR, 
                   "Address Family Config: Address Size %d out of bounds", 
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_ADDRESS_SIZE,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Write the 'views supported' value into the registry
        //

        KeyValue = AddrFamilyConfig->ViewsSupported;
        if (KeyValue == 0)
        {
            Trace0(ERR, "Address Family Config: No supported views");
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_VIEWS_SUPPORTED,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max change notifications' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxChangeNotifyRegns;
        if ((KeyValue < MIN_MAX_NOTIFY_REGS) ||
            (KeyValue > MAX_MAX_NOTIFY_REGS))
        {
            Trace1(ERR,
                   "Address Family Config: # Change notify regs out of range",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_MAX_NOTIFY_REGS,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max opaque info ptrs' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxOpaqueInfoPtrs;
        if (((int)KeyValue < MIN_OPAQUE_INFO_PTRS) ||
            (KeyValue > MAX_OPAQUE_INFO_PTRS))
        {
            Trace1(ERR, 
                   "Address Family Config: # opaque ptrs out of range",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_OPAQUE_INFO_PTRS,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max next hops per route' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxNextHopsInRoute;
        if ((KeyValue < MIN_NEXTHOPS_IN_ROUTE) ||
            (KeyValue > MAX_NEXTHOPS_IN_ROUTE))
        {
            Trace1(ERR, 
                   "Address Family Config: # nexthops out of range",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_NEXTHOPS_IN_ROUTE,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max handles returned in enum' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxHandlesInEnum;
        if ((KeyValue < MIN_MAX_HANDLES_IN_ENUM) ||
            (KeyValue > MAX_MAX_HANDLES_IN_ENUM))
        {
            Trace1(ERR, 
                   "Address Family Config: # handles returned in enum",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_MAX_HANDLES_IN_ENUM,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Close the address family key once you are done writing
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmWriteAddressFamilyConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Were config values out of bounds ? Adjust err code
    //

    if (Status == NO_ERROR)
    {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // Error occured, close the handle and delete the key
    //

    Trace1(ERR, 
           "Address Family Config: Error %d writing address family params",
           Status);

    RegCloseKey(ConfigHandle);

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              (MAX_CONFIG_KEY_SIZE - RTM_CONFIG_ROOT_SIZE)/sizeof(TCHAR),
              REG_KEY_ADDR_FAMILY_TEMPLATE,
              RtmInstanceId,
              AddressFamily);

    RegDeleteKey(HKEY_LOCAL_MACHINE, RtmGlobals.RegistryPath);

    TraceLeave("RtmWriteAddressFamilyConfig");
        
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmconst.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmconst.c

Abstract:
    Private Constants used in the RTMv2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

//
// RTM supported view related constants
//
// const DWORD VIEW_MASK[] =
// {
//    RTM_VIEW_MASK_UCAST,
//    RTM_VIEW_MASK_MCAST
// };


#if DBG_HDL

//
// Type & Signature of allocated structures
//

const DWORD OBJECT_SIGNATURE[] = 
{ 
    GENERIC_ALLOC,
    INSTANCE_ALLOC,
    ADDRESS_FAMILY_ALLOC,
    ENTITY_ALLOC,
    DEST_ALLOC,
    ROUTE_ALLOC,
    NEXTHOP_ALLOC,
    DEST_ENUM_ALLOC,
    ROUTE_ENUM_ALLOC,
    NEXTHOP_ENUM_ALLOC,
    NOTIFY_ALLOC,
    ROUTE_LIST_ALLOC,
    LIST_ENUM_ALLOC,
    V1_REGN_ALLOC,
    V1_ENUM_ALLOC
};

#endif

#if _DBG_

//
// Names of the references
//

const CHAR *REF_NAME[MAX_REFS] =
{
    "Creation",
    "Addr Fam",
    "Entity",
    "Dest",
    "Route",
    "Nexthop",
    "Enum",
    "Notify",
    "List",
    "Hold",
    "Timer",
    "Temp Use",
    "Handle"
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmglob.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmglob.h

Abstract:
    Global Vars for Routing Table Manager DLL

Author:
    Chaitanya Kodeboyina (chaitk)  25-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMGLOB_H__
#define __ROUTING_RTMGLOB_H__

//
// Global Information common to all RTM instances
//

#define INSTANCE_TABLE_SIZE            1

typedef struct _RTMP_GLOBAL_INFO
{
    ULONG             TracingHandle;    //
    HANDLE            LoggingHandle;    // Handles to debugging functionality
    ULONG             LoggingLevel;     //

    DWORD             TracingFlags;     // Flags that control debug tracing

    HANDLE            GlobalHeap;       // Handle to the private memory heap

#if DBG_MEM
    CRITICAL_SECTION  AllocsLock;       // Protects the list of allocations

    LIST_ENTRY        AllocsList;       // List of all allocated mem blocks
#endif

    PCHAR             RegistryPath;     // Registry Key that has RTM config

    RTL_RESOURCE      InstancesLock;    // Protects the instances' table
                                        // and instance infos themselves
                                        // and RTM API Initialization too

    BOOL              ApiInitialized;   // TRUE if API has been initialized

    UINT              NumInstances;     // Global table of all RTM instances
    LIST_ENTRY        InstanceTable[INSTANCE_TABLE_SIZE];
} 
RTMP_GLOBAL_INFO, *PRTMP_GLOBAL_INFO;


//
// Externs for global variables for the RTMv2 DLL
//

extern RTMP_GLOBAL_INFO  RtmGlobals;


//
// Macros for acquiring various locks defined in this file
//

#if DBG_MEM

#define ACQUIRE_ALLOCS_LIST_LOCK()                           \
    ACQUIRE_LOCK(&RtmGlobals.AllocsLock)

#define RELEASE_ALLOCS_LIST_LOCK()                           \
    RELEASE_LOCK(&RtmGlobals.AllocsLock)

#endif


#define ACQUIRE_INSTANCES_READ_LOCK()                        \
    ACQUIRE_READ_LOCK(&RtmGlobals.InstancesLock)

#define RELEASE_INSTANCES_READ_LOCK()                        \
    RELEASE_READ_LOCK(&RtmGlobals.InstancesLock)

#define ACQUIRE_INSTANCES_WRITE_LOCK()                       \
    ACQUIRE_WRITE_LOCK(&RtmGlobals.InstancesLock)

#define RELEASE_INSTANCES_WRITE_LOCK()                       \
    RELEASE_WRITE_LOCK(&RtmGlobals.InstancesLock)

//
// Macros for controlling the amount of tracing in this dll
//

#if DBG_TRACE

#define TRACING_ENABLED(Type)                                \
    (RtmGlobals.TracingFlags & RTM_TRACE_ ## Type)

#endif 

//
// Other common helper functions
//

#if DBG_MEM

VOID
DumpAllocs (VOID);

#endif

#endif //__ROUTING_RTMGLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmconst.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmconst.h

Abstract:
    Private Constants used in the RTMv2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMCONST_H__
#define __ROUTING_RTMCONST_H__

//
// Registry Key Names & Limits for configuration parameters
//

#define MAX_CONFIG_KEY_SIZE           (260*sizeof(TCHAR))


#define RTM_CONFIG_ROOT               TEXT("SYSTEM"                      \
                                           "\\CurrentControlSet"         \
                                           "\\Services"                  \
                                           "\\RemoteAccess"              \
                                           "\\RoutingTableManager")

#define RTM_CONFIG_ROOT_SIZE          sizeof(RTM_CONFIG_ROOT)


#define REG_KEY_INSTANCE_SUBKEY       TEXT("Instance %05d")

#define REG_KEY_ADDR_FAMILY_SUBKEY    TEXT("AddressFamily %05d")


#define REG_KEY_INSTANCE_TEMPLATE     TEXT("\\Instance %05d")

#define REG_KEY_ADDR_FAMILY_TEMPLATE  TEXT("\\Instance %05d"            \
                                           "\\AddressFamily %05d")

#define DEFAULT_INSTANCE_ID           0

#define REG_KEY_VIEWS_SUPPORTED       TEXT("ViewsSupported")
#define DEFAULT_VIEWS_SUPPORTED       (RTM_VIEW_MASK_UCAST |            \
                                       RTM_VIEW_MASK_MCAST)


#define REG_KEY_ADDRESS_SIZE          TEXT("AddressSize")
#define MINIMUM_ADDRESS_SIZE          1
#define DEFAULT_ADDRESS_SIZE          4
#define MAXIMUM_ADDRESS_SIZE          RTM_MAX_ADDRESS_SIZE


#define REG_KEY_MAX_NOTIFY_REGS       TEXT("MaxChangeNotifyRegistrations")
#define MIN_MAX_NOTIFY_REGS           1
#define DEFAULT_MAX_NOTIFY_REGS       16
#define MAX_MAX_NOTIFY_REGS           32


#define REG_KEY_OPAQUE_INFO_PTRS      TEXT("MaxOpaqueInfoPointers")
#define MIN_OPAQUE_INFO_PTRS          0
#define DEFAULT_OPAQUE_INFO_PTRS      5
#define MAX_OPAQUE_INFO_PTRS          10


#define REG_KEY_NEXTHOPS_IN_ROUTE     TEXT("MaxNextHopsInRoute")
#define MIN_NEXTHOPS_IN_ROUTE         1
#define DEFAULT_NEXTHOPS_IN_ROUTE     3
#define MAX_NEXTHOPS_IN_ROUTE         10


#define REG_KEY_MAX_HANDLES_IN_ENUM   TEXT("MaxHandlesReturnedInEnum")
#define MIN_MAX_HANDLES_IN_ENUM       1
#define DEFAULT_MAX_HANDLES_IN_ENUM   25
#define MAX_MAX_HANDLES_IN_ENUM       100


//
// Number of bits in a byte (or an octet)
//
#define BITS_IN_BYTE          (UINT) 8


//
// RTM supported view related constants
//

#define VIEW_MASK(id) (DWORD) (1 << (id))


//
// RTM supported CN related constants
//

#define CN_MASK(id)   (DWORD) (1 << (id))

#define NUM_CHANGED_DEST_LISTS        16


//
// Types of various data structures
//

#define GENERIC_TYPE                0x00

#define INSTANCE_TYPE               0x01
#define ADDRESS_FAMILY_TYPE         0x02
#define ENTITY_TYPE                 0x03

#define DEST_TYPE                   0x04
#define ROUTE_TYPE                  0x05
#define NEXTHOP_TYPE                0x06

#define DEST_ENUM_TYPE              0x07
#define ROUTE_ENUM_TYPE             0x08
#define NEXTHOP_ENUM_TYPE           0x09

#define NOTIFY_TYPE                 0x0A

#define ROUTE_LIST_TYPE             0x0B
#define LIST_ENUM_TYPE              0x0C

#define V1_REGN_TYPE                0x0D
#define V1_ENUM_TYPE                0x0E


#if DBG_HDL

//
// Type & Signature of allocated structures
//

#define GENERIC_ALLOC              '+GN0'

#define INSTANCE_ALLOC             '+IN1'
#define ADDRESS_FAMILY_ALLOC       '+AF2'
#define ENTITY_ALLOC               '+EN3'

#define DEST_ALLOC                 '+DT4'
#define ROUTE_ALLOC                '+RT5'
#define NEXTHOP_ALLOC              '+NH6'

#define DEST_ENUM_ALLOC            '+DE7'
#define ROUTE_ENUM_ALLOC           '+RE8'
#define NEXTHOP_ENUM_ALLOC         '+NE9'

#define NOTIFY_ALLOC               '+NOA'

#define ROUTE_LIST_ALLOC           '+ELB'
#define LIST_ENUM_ALLOC            '+LEC'

#define V1_REGN_ALLOC              '+1RD'
#define V1_ENUM_ALLOC              '+1EE'

extern const DWORD OBJECT_SIGNATURE[];

//
// Type & Signature of internal structures
// previously allocated, but are now freed
//

#define INSTANCE_FREED             '-IN1'
#define ADDRESS_FAMILY_FREED       '-AF2'
#define ENTITY_FREED               '-EN3'

#define DEST_FREED                 '-DT4'
#define ROUTE_FREED                '-RT5'
#define NEXTHOP_FREED              '-NH6'

#define DEST_ENUM_FREED            '-DE7'
#define ROUTE_ENUM_FREED           '-RE8'
#define NEXTHOP_ENUM_FREED         '-NE9'

#define NOTIFY_FREED               '-NOA'

#define ROUTE_LIST_FREED           '-ELB'
#define LIST_ENUM_FREED            '-LEC'

#define V1_REGN_FREED              '-1RD'
#define V1_ENUM_FREED              '-1EE'

//
// Signature byte that indicates if memory
// allocated for an object has been freed
//

#define ALLOC                      '+'
#define FREED                      '-'

#endif // DBG_HDL


#if _DBG_

//
// Cleanup Functions for internal structures
//

#define DEFINE_DESTROY_FUNC(Name)      \
    DWORD                              \
    Name (PVOID);

DEFINE_DESTROY_FUNC(DestroyGeneric);
DEFINE_DESTROY_FUNC(DestroyInstance);
DEFINE_DESTROY_FUNC(DestroyAddressFamily);
DEFINE_DESTROY_FUNC(DestroyEntity);
DEFINE_DESTROY_FUNC(DestroyDest);
DEFINE_DESTROY_FUNC(DestroyRoute);
DEFINE_DESTROY_FUNC(DestroyNextHop);
DEFINE_DESTROY_FUNC(DestroyDestEnum);
DEFINE_DESTROY_FUNC(DestroyRouteEnum);
DEFINE_DESTROY_FUNC(DestroyNextHopEnum);
DEFINE_DESTROY_FUNC(DestroyChangeNotification);
DEFINE_DESTROY_FUNC(DestroyEntityList);
DEFINE_DESTROY_FUNC(DestroyEntityListEnum);

typedef DWORD (*DestroyFunc) (PVOID Pointer);

const DestroyFunc OBJECT_DESTROY_FUNCTION[] = 
{
    DestroyGeneric,
    DestroyInstance,
    DestroyAddressFamily,
    DestroyEntity,
    DestroyDest,
    DestroyRoute,
    DestroyNextHop,
    DestroyDestEnum,
    DestroyRouteEnum,
    DestroyNextHopEnum,
    DestroyChangeNotification
    DestroyEntityList,
    DestroyEntityListEnum
};

#endif // _DBG_

//
// Reference Counting related constants
//

#define MAX_REFS                   0x10

#define CREATION_REF               0x00
#define ADDR_FAMILY_REF            0x01
#define ENTITY_REF                 0x02

#define DEST_REF                   0x03
#define ROUTE_REF                  0x04
#define NEXTHOP_REF                0x05

#define ENUM_REF                   0x06
#define NOTIFY_REF                 0x07
#define LIST_REF                   0x08

#define HOLD_REF                   0x09

#define TIMER_REF                  0x0D
#define TEMP_USE_REF               0x0E
#define HANDLE_REF                 0x0F

extern const CHAR  *REF_NAME[MAX_REFS];

#endif //__ROUTING_RTMCONST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmenum.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmenum.h

Abstract:

    Contains definitions for managing enumerations
    over destinations, routes and next hops in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMENUM_H__
#define __ROUTING_RTMENUM_H__


//
// Enumeration Over Destinations
//

typedef struct _DEST_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    RTM_VIEW_SET      TargetViews;      // Views over which enum is active

    UINT              NumberOfViews;    // Num of views in which enum is active

    ULONG             ProtocolId;       // OSPF, RIP, BEST_PROTOCOL etc.

    RTM_ENUM_FLAGS    EnumFlags;        // See RTM_ENUM_FLAGS in rtmv2.h

#if DBG
    RTM_NET_ADDRESS   StartAddress;     // First NetAddress in the enum
#endif

    RTM_NET_ADDRESS   StopAddress;      // Last NetAddress in the enum

    CRITICAL_SECTION  EnumLock;         // Lock that protects the 'NextDest'

    BOOL              EnumDone;         // Set to TRUE once last item is got

    RTM_NET_ADDRESS   NextDest;         // Points to the next dest in the enum
}
DEST_ENUM, *PDEST_ENUM;



//
// Enumeration Over Routes
//

typedef struct _ROUTE_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    RTM_VIEW_SET      TargetViews;      // Views over which enum is active

    RTM_ENUM_FLAGS    EnumFlags;        // See RTM_ENUM_FLAGS in rtmv2.h

    RTM_MATCH_FLAGS   MatchFlags;       // See RTM_MATCH_FLAGS in rtmv2.h

    PRTM_ROUTE_INFO   CriteriaRoute;    // Match criteria used with flags above

    ULONG             CriteriaInterface;// Interface on which routes r enum'ed

    CRITICAL_SECTION  EnumLock;         // Lock that protects the fields below

    PDEST_ENUM        DestEnum;         // Enum over dests (if enum'ing routes
                                        // on all destinations in the table)

    PRTM_DEST_INFO    DestInfo;         // Temp buffer used in above dest enum

    BOOL              EnumDone;         // Set to TRUE once last item is got

    PDEST_INFO        Destination;      // Dest for routes that we r enum'ing,

    UINT              NextRoute;        // Route to be given next on the dest

    UINT              MaxRoutes;        // Number of route slots in this array
    UINT              NumRoutes;        // Actual number of routes in the array
    PROUTE_INFO      *RoutesOnDest;     // Array of routes on this destination
}
ROUTE_ENUM, *PROUTE_ENUM;



//
// Enumeration Over Next Hops
//

typedef struct _NEXTHOP_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    RTM_ENUM_FLAGS    EnumFlags;        // See RTM_ENUM_FLAGS

#if DBG
    RTM_NET_ADDRESS   StartAddress;     // First NetAddress in the enum
#endif

    RTM_NET_ADDRESS   StopAddress;      // Last NetAddress in the enum

    CRITICAL_SECTION  EnumLock;         // Lock that protects the 'NextNextHop'

    BOOL              EnumDone;         // Set to TRUE once last item is got

    RTM_NET_ADDRESS   NextAddress;      // Address of next next-hop in the enum

    ULONG             NextIfIndex;      // Interface of next next-hop in enum
}
NEXTHOP_ENUM, *PNEXTHOP_ENUM;

//
// Used to indicate the posn of 1st
// next-hop on a list of next-hops
//

#define START_IF_INDEX    (ULONG) (-1)

//
// Macro for determinining the type of enumeration handle
//

#define GET_ENUM_TYPE(EnumHandle, Enum)                                      \
  (                                                                          \
      *Enum = (POPEN_HEADER) GetObjectFromHandle(EnumHandle, GENERIC_TYPE),  \
      (*Enum)->HandleType                                                    \
  )
    

//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_DEST_ENUM_LOCK(DestEnum)                                     \
    ACQUIRE_LOCK(&DestEnum->EnumLock)

#define RELEASE_DEST_ENUM_LOCK(DestEnum)                                     \
    RELEASE_LOCK(&DestEnum->EnumLock)


#define ACQUIRE_ROUTE_ENUM_LOCK(RouteEnum)                                   \
    ACQUIRE_LOCK(&RouteEnum->EnumLock)

#define RELEASE_ROUTE_ENUM_LOCK(RouteEnum)                                   \
    RELEASE_LOCK(&RouteEnum->EnumLock)


#define ACQUIRE_NEXTHOP_ENUM_LOCK(RouteEnum)                                 \
    ACQUIRE_LOCK(&RouteEnum->EnumLock)

#define RELEASE_NEXTHOP_ENUM_LOCK(RouteEnum)                                 \
    RELEASE_LOCK(&RouteEnum->EnumLock)

//
// Enumeration helper functions
//

BOOL
MatchRouteWithCriteria (
    IN      PROUTE_INFO                     Route,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRouteInfo,
    IN      ULONG                           CriteriaInterface
    );

#endif //  __ROUTING_RTMENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtminfo.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtminfo.c

Abstract:

    Contains routines for getting information
    on various objects pointed to by handles.

Author:

    Chaitanya Kodeboyina (chaitk)  22-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmGetEntityInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    OUT     PRTM_ENTITY_INFO                EntityInfo
    )

/*++

Routine Description:

    Retrieves information pertaining to a registered entity.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityHandle      - RTM handle for entity whose info we want,

    EntityInfo        - Block in which the entity info is returned.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamilyInfo;
    PENTITY_INFO     Entity;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ENTITY_HANDLE(EntityHandle, &Entity);

    //
    // Copy the entity information to output buffer
    //

    AddrFamilyInfo = Entity->OwningAddrFamily;

    EntityInfo->RtmInstanceId = AddrFamilyInfo->Instance->RtmInstanceId;

    EntityInfo->AddressFamily = AddrFamilyInfo->AddressFamily;

    EntityInfo->EntityId = Entity->EntityId;

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetDestInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Retrieves information for a destination in the route table

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - RTM handle for dest whose info we want,

    ProtocolId        - Protocol whose best route info is retd,

    TargetViews       - Views in which best route info is retd,

    DestInfo          - Block in which the dest info is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    // VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    Dest = DEST_FROM_HANDLE(DestHandle);
    if (!Dest)
    {
        return ERROR_INVALID_HANDLE;
    }

    ACQUIRE_DEST_READ_LOCK(Dest);

    GetDestInfo(Entity, 
                Dest, 
                ProtocolId,
                TargetViews,
                DestInfo);

    RELEASE_DEST_READ_LOCK(Dest);

    return NO_ERROR;
}


VOID
GetDestInfo (
    IN      PENTITY_INFO                    Entity,
    IN      PDEST_INFO                      Dest,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
)

/*++

Routine Description:

    Retrieves information for a destination in the route table

Arguments:

    Entity            - RTM registration info for calling entity,

    Dest              - Pointer to the dest whose info we want,

    ProtocolId        - Protocol whose best route info is retd,

    TargetViews       - Views in which best route info is retd,

    DestInfo          - Block in which the dest info is returned.

Return Value:

    None

--*/

{
    PENTITY_INFO     Owner;
    PROUTE_INFO      Route;
    RTM_VIEW_SET     ViewsSeen;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     BelongsToViews;
    PLIST_ENTRY      p;
    UINT             i, j, k;

    // Limit caller's interest to set of views supported
    TargetViews &= Entity->OwningAddrFamily->ViewsSupported;

    //
    // Copy dest info to output and ref handles given out
    //

    DestInfo->DestHandle = MAKE_HANDLE_FROM_POINTER(Dest);

    REFERENCE_DEST(Dest, HANDLE_REF);

    CopyMemory(&DestInfo->DestAddress,
               &Dest->DestAddress,
               sizeof(RTM_NET_ADDRESS));

    DestInfo->LastChanged = Dest->LastChanged;

    DestInfo->BelongsToViews = Dest->BelongsToViews;

    //
    // Copy the holddown route out in all requested views
    //

    ViewSet = TargetViews;
    
    for (i = j = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            k = Entity->OwningAddrFamily->ViewIndexFromId[i];

            Route = Dest->ViewInfo[k].HoldRoute;

            //
            // Init view info and fill the holddown route
            //

            ZeroMemory(&DestInfo->ViewInfo[j], sizeof(DestInfo->ViewInfo[0]));

            DestInfo->ViewInfo[j].ViewId = i;

            if (Route)
            {
                DestInfo->ViewInfo[j].HoldRoute = 
                            MAKE_HANDLE_FROM_POINTER(Route);

                REFERENCE_ROUTE(Route, HANDLE_REF);
            }

            j++;
        }

        ViewSet >>= 1;
    }

    // Keep track of total number of view info slots filled in
    DestInfo->NumberOfViews = j;

    //
    // Fill up information in all the views he is interested in
    //

    if (TargetViews & Dest->BelongsToViews)
    {
        // Resolve the protocol id if it is RTM_THIS_PROTOCOL

        if (ProtocolId == RTM_THIS_PROTOCOL)
        {
            ProtocolId = Entity->EntityId.EntityProtocolId;
        }

        ViewsSeen = 0;

        //
        // Copy best route in each view & ref handles given out
        //

        for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p = p->Flink)
        {
            Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

            //
            // Make sure that this agrees with our protocol id
            //

            Owner = ENTITY_FROM_HANDLE(Route->RouteInfo.RouteOwner);

            if (ProtocolId != RTM_BEST_PROTOCOL)
            {
                if (Owner->EntityId.EntityProtocolId != ProtocolId)
                {
                    continue;
                }
            }   

            //
            // Does this route belong to any interested views
            //

            if ((TargetViews & Route->RouteInfo.BelongsToViews) == 0)
            {
                continue;
            }

            //
            // Update dest info in each view that route belongs to
            //

            BelongsToViews = Route->RouteInfo.BelongsToViews;

            ViewSet = TargetViews;

            for (i = j = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
            {
                if (ViewSet & 0x01)
                {
                    if (BelongsToViews & 0x01)
                    {
                        //
                        // Increment number of routes in this view
                        //

                        DestInfo->ViewInfo[j].NumRoutes++;

                        //
                        // If you not already seen this view (in
                        // other words got the best route in it)
                        // update the DestInfo for this view now
                        //

                        if (!(ViewsSeen & VIEW_MASK(i)))
                        {
                            DestInfo->ViewInfo[j].Route = 
                                    MAKE_HANDLE_FROM_POINTER(Route);

                            REFERENCE_ROUTE(Route, HANDLE_REF);


                            DestInfo->ViewInfo[j].Owner = 
                                    MAKE_HANDLE_FROM_POINTER(Owner);

                            REFERENCE_ENTITY(Owner, HANDLE_REF);


                            DestInfo->ViewInfo[j].DestFlags = 
                                            Route->RouteInfo.Flags;
                        }
                    }

                    j++;
                }

                ViewSet >>= 1;

                BelongsToViews >>= 1;
            }

            ViewsSeen |= Route->RouteInfo.BelongsToViews;
        }
    }

    return;
}


DWORD
WINAPI
RtmGetRouteInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                 RouteInfo   OPTIONAL,
    OUT     PRTM_NET_ADDRESS                DestAddress OPTIONAL
    )

/*++

Routine Description:

    Retrieves information for a route in the route table

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - RTM handle for route whose info we want,

    RouteInfo         - Block in which the route info is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PROUTE_INFO      Route;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

#if 1
    Route = ROUTE_FROM_HANDLE(RouteHandle);                         

    if (!Route)
    {                                                               
        return ERROR_INVALID_HANDLE;                                
    }                                                               

#else
    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);
#endif

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    // Get a consitent picture of the route

    ACQUIRE_DEST_READ_LOCK(Dest);

    if (ARGUMENT_PRESENT(RouteInfo))
    {
        GetRouteInfo(Dest, Route, RouteInfo);
    }

    RELEASE_DEST_READ_LOCK(Dest);

    // No lock reqd - dest addr is constant

    if (ARGUMENT_PRESENT(DestAddress))
    {
        CopyMemory(DestAddress, &Dest->DestAddress, sizeof(RTM_NET_ADDRESS));
    }

    return NO_ERROR;
}


VOID
WINAPI
GetRouteInfo (
    IN      PDEST_INFO                      Dest,
    IN      PROUTE_INFO                     Route,
    OUT     PRTM_ROUTE_INFO                 RouteInfo
    )

/*++

Routine Description:

    Retrieves information for a route in the route table

Arguments:

    Dest              - Pointer to the destination of the route,

    Route             - Pointer to the route whose info we want,

    RouteInfo         - Block in which the route info is returned.

Return Value:

    None

--*/

{
    PENTITY_INFO     Entity;
    PNEXTHOP_INFO    Neighbour;
    PNEXTHOP_INFO    NextHop;
    UINT             NumBytes;
    UINT             i;

    //
    // Copy the route information to output buffer
    //

    NumBytes = sizeof(RTM_ROUTE_INFO) + 
                    sizeof(RTM_NEXTHOP_HANDLE) *
                        (Route->RouteInfo.NextHopsList.NumNextHops - 1);

    CopyMemory(RouteInfo, &Route->RouteInfo, NumBytes);

    //
    // Reference handles that are given out in info
    //

    Entity = ENTITY_FROM_HANDLE(RouteInfo->RouteOwner);
    REFERENCE_ENTITY(Entity, HANDLE_REF);

    if (RouteInfo->Neighbour)
    {
        Neighbour = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);
        REFERENCE_NEXTHOP(Neighbour, HANDLE_REF);
    }

    for (i = 0; i < RouteInfo->NextHopsList.NumNextHops; i++)
    {
        NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->NextHopsList.NextHops[i]);
        REFERENCE_NEXTHOP(NextHop, HANDLE_REF);
    }

    REFERENCE_DEST(Dest, HANDLE_REF);

    return;
}


DWORD
WINAPI
RtmGetNextHopInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO               NextHopInfo
    )

/*++

Routine Description:

    Retrieves information for a next-hop in the route table

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - RTM handle for next-hop whose info we want,

    NextHopInfo       - Block in which the next-hop info is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PNEXTHOP_INFO    NextHop;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

    Entity = ENTITY_FROM_HANDLE(NextHop->NextHopInfo.NextHopOwner);

    ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);

    //
    // Copy the next-hop information to output buffer
    //

    CopyMemory(NextHopInfo, &NextHop->NextHopInfo, sizeof(RTM_NEXTHOP_INFO));

    //
    // Reference handles that are given out in info
    //

    if (NextHop->NextHopInfo.RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(NextHop->NextHopInfo.RemoteNextHop);
        REFERENCE_DEST(Dest, HANDLE_REF);
    }

    REFERENCE_ENTITY(Entity, HANDLE_REF);

    RELEASE_NHOP_TABLE_READ_LOCK(Entity);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseEntityInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ENTITY_INFO               EntityInfo
    )

/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityInfo        - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    UNREFERENCED_PARAMETER(RtmRegHandle);
    UNREFERENCED_PARAMETER(EntityInfo);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseDestInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_DEST_INFO                 DestInfo
    )

/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestInfo          - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PENTITY_INFO     Owner;
    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    for (i = 0; i < DestInfo->NumberOfViews; i++)
    {
        //
        // If a best route, dereference it and its owner
        //

        if (DestInfo->ViewInfo[i].Route)
        {
            Route = ROUTE_FROM_HANDLE(DestInfo->ViewInfo[i].Route);
            DEREFERENCE_ROUTE(Route, HANDLE_REF);

            Owner = ENTITY_FROM_HANDLE(DestInfo->ViewInfo[i].Owner);
            DEREFERENCE_ENTITY(Owner, HANDLE_REF);
        }

        //
        // If we have a holddown route, dereference it
        //

        if (DestInfo->ViewInfo[i].HoldRoute)
        {
            Route = ROUTE_FROM_HANDLE(DestInfo->ViewInfo[i].HoldRoute);
            DEREFERENCE_ROUTE(Route, HANDLE_REF);
        }
    }

    Dest = DEST_FROM_HANDLE(DestInfo->DestHandle);
    DEREFERENCE_DEST(Dest, HANDLE_REF);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseRouteInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ROUTE_INFO                RouteInfo
    )

/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteInfo         - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PNEXTHOP_INFO    Neighbour;
    PNEXTHOP_INFO    NextHop;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    for (i = 0; i < RouteInfo->NextHopsList.NumNextHops; i++)
    {
        NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->NextHopsList.NextHops[i]);
        DEREFERENCE_NEXTHOP(NextHop, HANDLE_REF);
    }

    if (RouteInfo->Neighbour)
    {
        Neighbour = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);
        DEREFERENCE_NEXTHOP(Neighbour, HANDLE_REF);
    }

    Entity = ENTITY_FROM_HANDLE(RouteInfo->RouteOwner);
    DEREFERENCE_ENTITY(Entity, HANDLE_REF);

    Dest = DEST_FROM_HANDLE(RouteInfo->DestHandle);
    DEREFERENCE_DEST(Dest, HANDLE_REF);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseNextHopInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO              NextHopInfo
    )
    
/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopInfo       - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if (NextHopInfo->RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(NextHopInfo->RemoteNextHop);

        if (Dest)
        {
            DEREFERENCE_DEST(Dest, HANDLE_REF);
        }
    }

    Entity = ENTITY_FROM_HANDLE(NextHopInfo->NextHopOwner);
    DEREFERENCE_ENTITY(Entity, HANDLE_REF);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmhndl.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmhndl.c

Abstract:

    Contains routines for operating on handles
    to RTM objects like routes and dests.


Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmReferenceHandles (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumHandles,
    IN      HANDLE                         *RtmHandles
    )

/*++

Routine Description:

    Increment the reference count on objects pointed to by
    input RTM handles.


Arguments:

    RtmRegHandle  - RTM registration handle for calling entity,

    NumHandles    - Number of handles that are being referenced,

    RtmHandles    - Array of handles that are being referenced.

Return Value:

    Status of the operation

--*/

{    
    PENTITY_INFO     Entity;
    POBJECT_HEADER   Object;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Reference each handle in input array
    //

    for (i = 0; i < NumHandles; i++)
    {
        Object = GET_POINTER_FROM_HANDLE(RtmHandles[i]);

#if DBG_HDL
        try
        {
            if (Object->TypeSign != OBJECT_SIGNATURE[atoi(&Object->Type)])
            {
                continue;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        { 
            continue;
        }
#endif

        ReferenceObject(Object, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmDereferenceHandles (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumHandles,
    IN      HANDLE                         *RtmHandles
    )

/*++

Routine Description:

    Decrement the reference count on objects pointed to by
    input RTM handles.

Arguments:

    RtmRegHandle  - RTM registration handle for calling entity,

    NumHandles    - Number of handles that are being dereferenced,

    RtmHandles    - Array of handles that are being dereferenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    POBJECT_HEADER   Object;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each handle in input array
    //

    for (i = 0; i < NumHandles; i++)
    {
        Object = GET_POINTER_FROM_HANDLE(RtmHandles[i]);

#if DBG_HDL
        try
        {
            if (Object->TypeSign != OBJECT_SIGNATURE[atoi(&Object->Type)])
            {
                continue;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        { 
            continue;
        }
#endif
        //
        // This function can be used only if you know
        // that the reference count does not go to 0
        //

        if (DereferenceObject(Object, HANDLE_REF) == 0)
        {
            ASSERT(FALSE); // ? Destroy which object ?
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtminfo.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtminfo.h

Abstract:

    Contains defines related to getting info
    on various objects pointed to by handles.

Author:

    Chaitanya Kodeboyina (chaitk)   04-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMINFO_H__
#define __ROUTING_RTMINFO_H__

//
// Macro to allocate the var-sized DestInfo structure
//

#define AllocDestInfo(_NumViews_)                                             \
          (PRTM_DEST_INFO) AllocNZeroMemory(RTM_SIZE_OF_DEST_INFO(_NumViews_))

//
// Info Helper Functions
//

VOID
GetDestInfo (
    IN      PENTITY_INFO                    Entity,
    IN      PDEST_INFO                      Dest,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
);


VOID
WINAPI
GetRouteInfo (
    IN      PDEST_INFO                      Dest,
    IN      PROUTE_INFO                     Route,
    OUT     PRTM_ROUTE_INFO                 RouteInfo
    );

#endif //__ROUTING_RTMINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmmain.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmain.c

Abstract:

    Contains routines that are invoked when
    the RTMv2 DLL is loaded or unloaded.

Author:

    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

// All Global variables
RTMP_GLOBAL_INFO  RtmGlobals;

BOOL
WINAPI
DllMain(
    IN      HINSTANCE                       Instance,
    IN      DWORD                           Reason,
    IN      PVOID                           Unused
    )

/*++

Routine Description:

    This is the DLL's main entrypoint handler which
    initializes RTMv1, RTMv2 and MGM components. 
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    static BOOL Rtmv1Initialized = FALSE;
    static BOOL RtmInitialized = FALSE;
    static BOOL MgmInitialized = FALSE;
    BOOL        Success;

    UNREFERENCED_PARAMETER(Unused);

    Success = FALSE;

    switch(Reason) 
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(Instance);

        //
        // Initialize the RTMv1, RTMv2 and MGM APIs
        //

        Rtmv1Initialized = Rtmv1DllStartup(Instance);

        if (Rtmv1Initialized)
        {
            RtmInitialized = RtmDllStartup();
            
            if (RtmInitialized)
            {
                MgmInitialized = MgmDllStartup();
            }
        }

        return MgmInitialized;

    case DLL_PROCESS_DETACH:

        //
        // Cleanup the MGM, RTMv2 and RTMv1 APIs
        //

        if (MgmInitialized)
        {
            MgmDllCleanup();
        }

        if (RtmInitialized)
        {
            Success = RtmDllCleanup();
        }

        if (Rtmv1Initialized)
        {
            Rtmv1DllCleanup();
        }

        break;

    default:

        Success = TRUE;

        break;
    }

    return Success;
}


BOOL
RtmDllStartup(
    VOID
    )

/*++

Routine Description:

    Called by DLL Main when the process is attached.
    We do minimal initialization here like creating
    a lock that protects all globals (including the
    'ApiInitialized' -- see RtmRegisterEntity func).
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    //
    // One can safely assume that globals have been set to 0
    //

    // ZeroMemory(&RtmGlobals, sizeof(RTMP_GLOBAL_INFO));

    //
    // Initialize lock to guard the global table of instances
    //

    try
    {
        CREATE_READ_WRITE_LOCK(&RtmGlobals.InstancesLock);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
        
    return TRUE;
}


DWORD
RtmApiStartup(
    VOID
    )

/*++

Routine Description:

    Initializes most global data structures in RTMv2.

    We initialize most variables here instead of in
    RtmDllStartup as it might not be safe to perform
    some operations in the context of DLL's DLLMain.

    For example, if we find no config information, we
    set up default config information in the registry.

    This function is called when the first RTMv2 API
    call, which is typically an entity registration,
    is made. See the invocation in RtmRegisterEntity.

Arguments:

    None

Return Value:

    Status of the operation

--*/

{
    RTM_INSTANCE_CONFIG InstanceConfig;
    BOOL                ListLockInited;
    DWORD               Status;
    UINT                i;

    ListLockInited = FALSE;

    Status = NO_ERROR;

    ACQUIRE_INSTANCES_WRITE_LOCK();

    do
    {
        //
        // If API has already been initialized, work is done
        //

        if (RtmGlobals.ApiInitialized)
        {
            break;
        }

        //
        // Enable logging and tracing for debugging purposes
        //
  
        START_TRACING();
        START_LOGGING();

#if DBG_TRACE
        RtmGlobals.TracingFlags = RTM_TRACE_ANY;
#endif

#if DBG_MEM

        //
        // Init a lock & list to hold mem allocs
        //

        try
        {
            InitializeCriticalSection(&RtmGlobals.AllocsLock);

            ListLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
      
            Trace1(ANY, 
                   "RTMApiStartup : Failed to init a critical section %x",
                   Status);
  
            LOGERR0(INIT_CRITSEC_FAILED, Status);

            break;
        }

        InitializeListHead(&RtmGlobals.AllocsList);
#endif

        //
        // Create a private heap for RTM's use
        //

        RtmGlobals.GlobalHeap = HeapCreate(0, 0, 0);
  
        if (RtmGlobals.GlobalHeap == NULL)
        {
            Status = GetLastError();

            Trace1(ANY, 
                   "RtmApiStartup: Failed to create a global private heap %x",
                   Status);

            LOGERR0(HEAP_CREATE_FAILED, Status);
            
            break;
        }

        //
        // Initialize the root of RTM's registry information
        //

        RtmGlobals.RegistryPath = AllocNZeroMemory(MAX_CONFIG_KEY_SIZE);

        if (RtmGlobals.RegistryPath == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(RtmGlobals.RegistryPath,
                   RTM_CONFIG_ROOT,
                   RTM_CONFIG_ROOT_SIZE);

        //
        // Initialize the global hash table of RTM instances
        //

        RtmGlobals.NumInstances = 0;
        for (i = 0; i < INSTANCE_TABLE_SIZE; i++)
        {
            InitializeListHead(&RtmGlobals.InstanceTable[i]);
        }

        //
        // You need to set this value to TRUE to avoid
        // any more recursive calls into this function
        //

        RtmGlobals.ApiInitialized = TRUE;

        //
        // Read config info if present ; else pick default
        //

        Status = RtmReadInstanceConfig(DEFAULT_INSTANCE_ID, &InstanceConfig);

        if (Status != NO_ERROR)
        {
            Status = RtmWriteDefaultConfig(DEFAULT_INSTANCE_ID);

            if (Status != NO_ERROR)
            {
                break;
            }
        }
    }
    while (FALSE);

    if (Status != NO_ERROR)
    {
        //
        // Some error occured - clean up and return the error code
        //

        if (RtmGlobals.RegistryPath != NULL)
        {
            FreeMemory(RtmGlobals.RegistryPath);
        }

        if (RtmGlobals.GlobalHeap != NULL)
        {
            HeapDestroy(RtmGlobals.GlobalHeap);
        }

#if DBG_MEM
        if (ListLockInited)
        {
            DeleteCriticalSection(&RtmGlobals.AllocsLock);
        }
#endif

        STOP_LOGGING();
        STOP_TRACING();

        //
        // We had prematurely set the value to TRUE above, reset it
        //

        RtmGlobals.ApiInitialized = FALSE;
    }

    RELEASE_INSTANCES_WRITE_LOCK();

    return Status;
}


BOOL
RtmDllCleanup(
    VOID
    )

/*++

Routine Description:

    Cleans up all global data structures at unload time.
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not

--*/

{
    PINSTANCE_INFO Instance;
    PLIST_ENTRY    Instances, p, r;
    UINT           NumInstances;
    PADDRFAM_INFO  AddrFamilyInfo;
    PLIST_ENTRY    AddrFamilies, q;
    PENTITY_INFO   Entity;
    PLIST_ENTRY    Entities, s;
    UINT           NumEntities;
    UINT           i, j, k, l;

    //
    // Do we have any instances and associated ref counts left ?
    //

    if (RtmGlobals.NumInstances != 0)
    {
        //
        // We need to stop all outstanding timers
        // on every address family as the RTM DLL
        // gets unloaded after this call returns.
        // We also forcefully destroy entities &
        // address families to reclaim resources.
        //

        ACQUIRE_INSTANCES_WRITE_LOCK();

        NumInstances = RtmGlobals.NumInstances;

        for (i = j = 0; i < INSTANCE_TABLE_SIZE; i++)
        {
            Instances = &RtmGlobals.InstanceTable[i];
        
            for (p = Instances->Flink; p != Instances; p = r)
            {
                Instance = CONTAINING_RECORD(p, INSTANCE_INFO, InstTableLE);

                AddrFamilies = &Instance->AddrFamilyTable;
#if WRN
                r = p->Flink;
#endif
                for (q = AddrFamilies->Flink; q != AddrFamilies; )
                {
                    AddrFamilyInfo = 
                        CONTAINING_RECORD(q, ADDRFAM_INFO, AFTableLE);

                    //
                    // Holding the instances lock while deleting
                    // timer queues (using blocking calls) can 
                    // result in a deadlock, so just reference
                    // the address family and release the lock.
                    //
                    
                    // Ref address family so that it does not disappear
                    REFERENCE_ADDR_FAMILY(AddrFamilyInfo, TEMP_USE_REF);

                    RELEASE_INSTANCES_WRITE_LOCK();

                    //
                    // Block until timers on address family are cleaned up
                    //

                    if (AddrFamilyInfo->RouteTimerQueue)
                    {
                        DeleteTimerQueueEx(AddrFamilyInfo->RouteTimerQueue, 
                                           (HANDLE) -1);

                        AddrFamilyInfo->RouteTimerQueue = NULL;
                    }

                    if (AddrFamilyInfo->NotifTimerQueue)
                    {
                        DeleteTimerQueueEx(AddrFamilyInfo->NotifTimerQueue, 
                                           (HANDLE) -1);

                        AddrFamilyInfo->NotifTimerQueue = NULL;
                    }

                    //
                    // We assume that we have no other code paths that
                    // access any data structures on this addr family
                    //

                    //
                    // Force destroy each entity on the address family
                    //

                    NumEntities = AddrFamilyInfo->NumEntities;

                    for (k = l = 0; k < ENTITY_TABLE_SIZE; k++)
                    {
                        Entities = &AddrFamilyInfo->EntityTable[k];

                        for (s = Entities->Flink; s != Entities; )
                        {
                            Entity = 
                              CONTAINING_RECORD(s, ENTITY_INFO, EntityTableLE);

                            s = s->Flink;

                            // To satisfy the asserts in DestroyEntity
                            Entity->ObjectHeader.RefCount = 0;

                            DestroyEntity(Entity);

                            l++;
                        }

                        if (l == NumEntities)
                        {
                            break;
                        }
                    }

                    //
                    // Also destroy entities that have deregistered
                    // but haven't been destroyed due to ref counts
                    //

                    while (!IsListEmpty(&AddrFamilyInfo->DeregdEntities))
                    {
                       Entity = 
                        CONTAINING_RECORD(AddrFamilyInfo->DeregdEntities.Flink,
                                          ENTITY_INFO, 
                                          EntityTableLE);

                       // To satisfy the asserts in DestroyEntity
                       Entity->ObjectHeader.RefCount = 0;

                       DestroyEntity(Entity);
                    }

                    ACQUIRE_INSTANCES_WRITE_LOCK();

                    // Get next address family before de-ref-ing current
                    q = q->Flink;

                    // Get next instance also as it might be deleted too
                    r = p->Flink;

                    // Remove the temporary reference use added earlier 
                    DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, TEMP_USE_REF);
                }

                j++;
            }

            if (j == NumInstances)
            {
                break;
            }
        }

        RELEASE_INSTANCES_WRITE_LOCK();
    }

    // We have freed all instances to avoid any leaks
    ASSERT(RtmGlobals.NumInstances == 0);

    //
    // Free resources allocated like locks and memory
    //

    if (RtmGlobals.ApiInitialized)
    {
        FreeMemory(RtmGlobals.RegistryPath);

        //
        // At this point we might have whole lots of dests,
        // routes, nexthops etc. that are have not been
        // freed because of outstanding ref counts; however
        // none of these objects have any locks (except
        // dest locks which are dynamic anyway and can
        // be unlocked and freed after deregistration),
        // so we can just blow the heap to reclaim memory.
        //

        HeapDestroy(RtmGlobals.GlobalHeap);

#if DBG_MEM
        DeleteCriticalSection(&RtmGlobals.AllocsLock);
#endif

        //
        // Stop debugging aids like tracing and logging
        //

        STOP_LOGGING();
        STOP_TRACING();
    }

    DELETE_READ_WRITE_LOCK(&RtmGlobals.InstancesLock);

    return TRUE;
}


#if DBG_MEM

VOID
DumpAllocs (VOID)

/*++

Routine Description:

    Debug tool to dump all objects that are
    allocated by RTMv2 at any instant.
    
Arguments:

    None

Return Value:

    None

--*/

{
    POBJECT_HEADER  Object;
    PLIST_ENTRY     p;
    UINT            i;

    printf("\n\n----------------Allocs Left Over------------------------\n");

    ACQUIRE_ALLOCS_LIST_LOCK();

    for (p = RtmGlobals.AllocsList.Flink; 
                           p != &RtmGlobals.AllocsList; 
                                                     p = p->Flink)
    {
        Object = CONTAINING_RECORD(p, OBJECT_HEADER, AllocLE);

        printf("Object @ %p: \n", Object);

#if DBG_HDL
        printf("Object Signature = %c%c%c%c\n",
                       Object->Type,
                       Object->Signature[0],
                       Object->Signature[1],
                       Object->Alloc);
#endif

#if DBG_REF
        printf("Object RefCounts: \n");

        for (i = 0; i < MAX_REFS; i++)
        {
            printf("%2lu", Object->RefTypes[i]);
        }
#endif

        printf("\n");
    }

    RELEASE_ALLOCS_LIST_LOCK();

    printf("\n--------------------------------------------------------\n\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmlog.h ===
//============================================================================
// Copyright (c) 1997 - 98, Microsoft Corporation
//
// File:    rtmlog.h
//
// History:
//  Chaitanya Kodeboyina Jun-1-1998     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in RTM's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define RTMLOG_BASE                           30000

#define RTMLOG_INIT_CRITSEC_FAILED            (RTMLOG_BASE + 1)
/*
 * RTM was unable to initialize a critical section.
 * The data is the exception code.
 */

#define RTMLOG_HEAP_CREATE_FAILED             (RTMLOG_BASE + 2)
/*
 * RTM was unable to create a heap.
 * The data is the error code.
 */

#define RTMLOG_HEAP_ALLOC_FAILED              (RTMLOG_BASE + 3)
/*
 * RTM was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define RTMLOG_RTM_ALREADY_STARTED          (RTMLOG_BASE + 4)
/*
 * RTM received a start request when it was already running.
 */

#define RTMLOG_CREATE_RWL_FAILED              (RTMLOG_BASE + 5)
/*
 * RTM was unable to create a synchronization object.
 * The data is the error code.
 */

#define RTMLOG_CREATE_EVENT_FAILED            (RTMLOG_BASE + 6)
/*
 * RTM was unable to create an event.
 * The data is the error code.
 */

#define RTMLOG_CREATE_SEMAPHORE_FAILED        (RTMLOG_BASE + 7)
/*
 * RTM was unable to create a semaphore.
 * The data is the error code.
 */

#define RTMLOG_RTM_STARTED                  (RTMLOG_BASE + 8)
/*
 * RTM has started successfully.
 */

#define RTMLOG_QUEUE_WORKER_FAILED            (RTMLOG_BASE + 9)
/*
 * RTM could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define RTMLOG_PROTOCOL_NOT_FOUND             (RTMLOG_BASE + 10)
/*
 * RTM could not find the protocol component (%1, %2)
 */

#define RTMLOG_PROTOCOL_ALREADY_PRESENT       (RTMLOG_BASE + 11)
/*
 * Protocol component has already registered with RTM 
 */

#define RTMLOG_CREATE_PROTOCOL_FAILED         (RTMLOG_BASE + 12)
/*
 * RTM failed to register the protocol component.
 * The data is in the error code.
 */

#define RTMLOG_INTERFACES_PRESENT             (RTMLOG_BASE + 13)
/*
 * The protocol component that is attempting to deregister is currently
 * enabled on one or more interfaces.   
 */

#define RTMLOG_IF_ALREADY_PRESENT             (RTMLOG_BASE + 14)
/*
 * This protocol component has already been enabled on this interface 
 */

#define RTMLOG_IF_NOT_FOUND                   (RTMLOG_BASE + 15)
/*
 * Specified interface was not present in MGM. 
 */

#define RTMLOG_IF_DIFFERENT_OWNER             (RTMLOG_BASE + 16)
/*
 * Another routing protocol component has already been enabled on
 * this interface.  Only one routing protocol component may be 
 * enabled on an interface at any time.
 */

#define RTMLOG_IF_IGMP_NOT_PRESENT            (RTMLOG_BASE + 17)
/*
 * IGMP is not enabled on this interface 
 */

#define RTMLOG_IF_PROTOCOL_NOT_PRESENT        (RTMLOG_BASE + 18)
/*
 * No routing protocol has been enabled on this interface 
 */

#define RTMLOG_INVALID_HANDLE                 (RTMLOG_BASE + 19)
/*
 * The handle specified by the protocol component is not valid. This
 * maybe because the protocol component is not registered with RTM
 */

#define RTMLOG_IF_IGMP_PRESENT                (RTMLOG_BASE + 17)
/*
 * Interface cannot be deleted because IGMP is still active on 
 * this interface. 
 */

#define RTMLOG_RTM_STOPPED                  (RTMLOG_BASE + 99)
/*
 * RTM has stopped.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmlist.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmlist.h

Abstract:

    Contains defines for managing entity-specific
    list of routes in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMLIST_H__
#define __ROUTING_RTMLIST_H__


//
// Entity Specific List of Routes
//

typedef struct _ROUTE_LIST 
{
    OPEN_HEADER       ListHeader;       // Signature, Type and Reference Count

    LIST_ENTRY        ListHead;         // Points to head of the list of routes
}
ROUTE_LIST , *PROUTE_LIST ;


//
// Enumeration on a Route List
//

typedef struct _LIST_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    PROUTE_LIST       RouteList;        // Route list on which enum is created

    ROUTE_INFO        MarkerRoute;      // Pointer to next route in route list
}
LIST_ENUM, *PLIST_ENUM;

#endif //  __ROUTING_RTMLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmmain.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmmain.h

Abstract:
    Private defs for Routing Table Manager DLL

Author:
    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/


#ifndef __ROUTING_RTMMAIN_H__
#define __ROUTING_RTMMAIN_H__

//
// Common Header for all RTM internal structures
//

// Disable warnings for unnamed structs
#pragma warning(disable : 4201)  

typedef struct _OBJECT_HEADER
{
#if DBG_HDL
    union
    {
        DWORD         TypeSign;        // Type & unique signature for object
        struct
        {
            CHAR      Type;            // Identifies type of the object
            CHAR      Signature[2];    // Pattern unique for an object type
            CHAR      Alloc;           // Set + if allocated, - if freed
        };
    };
#endif

#if DBG_MEM
    LIST_ENTRY        AllocLE;         // On list of all memory allocations
#endif

    LONG              RefCount;        // Reference count for this object

#if DBG_REF
    LONG              RefTypes[MAX_REFS]; // Nature of references on the object
#endif
}
OBJECT_HEADER, *POBJECT_HEADER;

#pragma warning(default : 4201)  


//
// Defns to validate handles & convert them to pointers
//

#define HANDLE_CONV_KEY                                                     \
            (ULONG_PTR)(('RTM2') | ('RTM2' << (sizeof(PVOID) - 4)))

#define MAKE_HANDLE_FROM_POINTER(ObjectHandle)                              \
            (HANDLE) (((ULONG_PTR) ObjectHandle) ^ HANDLE_CONV_KEY)

#define GET_POINTER_FROM_HANDLE(ObjectHandle)                               \
            (PVOID)  (((ULONG_PTR) ObjectHandle) ^ HANDLE_CONV_KEY)


PVOID
__inline
GetObjectFromHandle(HANDLE ObjectHandle, UCHAR ObjectType)
{
    POBJECT_HEADER ObjHdr = GET_POINTER_FROM_HANDLE(ObjectHandle);

    UNREFERENCED_PARAMETER(ObjectType);

#if DBG_HDL
    try
    {
        if (ObjHdr->TypeSign != OBJECT_SIGNATURE[ObjectType])
        {
            if (ObjectType != GENERIC_TYPE)
            {
                ObjHdr = NULL;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
        { 
            ObjHdr = NULL;
        }
#endif

    return ObjHdr;
}



#define OBJECT_FROM_HANDLE(ObjectHandle, ObjectType)                        \
          (POBJECT_HEADER) GetObjectFromHandle(ObjectHandle, ObjectType);

#define VALIDATE_OBJECT_HANDLE(ObjectHandle, ObjectType, pObject)           \
            *pObject = (PVOID) OBJECT_FROM_HANDLE(ObjectHandle, ObjectType);\
            if ((!*pObject))                                                \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ENTITY_FROM_HANDLE(EntityHandle)                                    \
            (PENTITY_INFO) GetObjectFromHandle(EntityHandle, ENTITY_TYPE)

#define VALIDATE_ENTITY_HANDLE(EntityHandle, pEntity)                       \
            *pEntity = ENTITY_FROM_HANDLE(EntityHandle);                    \
            if ((!*pEntity)||((*pEntity)->State==ENTITY_STATE_DEREGISTERED))\
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \

#define DBG_VALIDATE_ENTITY_HANDLE(EntityHandle, pEntity)                   \
            if (DBG_HDL)                                                    \
            {                                                               \
                VALIDATE_ENTITY_HANDLE(EntityHandle, pEntity)               \
            }


#define DEST_FROM_HANDLE(DestHandle)                                        \
            (PDEST_INFO) GetObjectFromHandle(DestHandle, DEST_TYPE)

#define VALIDATE_DEST_HANDLE(DestHandle, pDest)                             \
            *pDest = DEST_FROM_HANDLE(DestHandle);                          \
            if ((!(*pDest)) || ((*pDest)->State == DEST_STATE_DELETED))     \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ROUTE_FROM_HANDLE(RouteHandle)                                      \
            (PROUTE_INFO) GetObjectFromHandle(RouteHandle, ROUTE_TYPE)

#define VALIDATE_ROUTE_HANDLE(RouteHandle, pRoute)                          \
            *pRoute = ROUTE_FROM_HANDLE(RouteHandle);                       \
            if (                                                            \
                (!(*pRoute)) ||                                             \
                ((*pRoute)->RouteInfo.State == RTM_ROUTE_STATE_DELETED)     \
               )                                                            \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define NEXTHOP_FROM_HANDLE(NextHopHandle)                                  \
            (PNEXTHOP_INFO) GetObjectFromHandle(NextHopHandle, NEXTHOP_TYPE)

#define VALIDATE_NEXTHOP_HANDLE(NextHopHandle, pNextHop)                    \
            *pNextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);                 \
            if (!(*pNextHop))                                               \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define DEST_ENUM_FROM_HANDLE(DestEnumHandle)                               \
            (PDEST_ENUM) GetObjectFromHandle(DestEnumHandle, DEST_ENUM_TYPE)

#define VALIDATE_DEST_ENUM_HANDLE(DestEnumHandle, pDestEnum)                \
            *pDestEnum = DEST_ENUM_FROM_HANDLE(DestEnumHandle);             \
            if ((!*pDestEnum))                                              \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ROUTE_ENUM_FROM_HANDLE(RouteEnumHandle)                             \
         (PROUTE_ENUM) GetObjectFromHandle(RouteEnumHandle, ROUTE_ENUM_TYPE)

#define VALIDATE_ROUTE_ENUM_HANDLE(RouteEnumHandle, pRouteEnum)             \
            *pRouteEnum = ROUTE_ENUM_FROM_HANDLE(RouteEnumHandle);          \
            if ((!*pRouteEnum))                                             \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


#define NEXTHOP_ENUM_FROM_HANDLE(EnumHandle)                                \
          (PNEXTHOP_ENUM) GetObjectFromHandle(EnumHandle, NEXTHOP_ENUM_TYPE)

#define VALIDATE_NEXTHOP_ENUM_HANDLE(NextHopEnumHandle, pNextHopEnum)       \
            *pNextHopEnum = NEXTHOP_ENUM_FROM_HANDLE(NextHopEnumHandle);    \
            if ((!*pNextHopEnum))                                           \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define NOTIFY_FROM_HANDLE(NotifyHandle)                                    \
            (PNOTIFY_INFO) GetObjectFromHandle(NotifyHandle, NOTIFY_TYPE)

#define VALIDATE_NOTIFY_HANDLE(NotifyHandle, pNotify)                       \
            *pNotify = NOTIFY_FROM_HANDLE(NotifyHandle);                    \
            if ((!*pNotify) || ((*pNotify)->CNIndex < 0))                   \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ROUTE_LIST_FROM_HANDLE(ListHandle)                                 \
            (PROUTE_LIST) GetObjectFromHandle(ListHandle, ROUTE_LIST_TYPE)

#define VALIDATE_ROUTE_LIST_HANDLE(ListHandle, pList)                       \
            *pList = ROUTE_LIST_FROM_HANDLE(ListHandle);                    \
            if ((!*pList))                                                  \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


#define LIST_ENUM_FROM_HANDLE(ListEnumHandle)                               \
            (PLIST_ENUM) GetObjectFromHandle(ListEnumHandle, LIST_ENUM_TYPE)

#define VALIDATE_LIST_ENUM_HANDLE(ListEnumHandle, pListEnum)                \
            *pListEnum = LIST_ENUM_FROM_HANDLE(ListEnumHandle);             \
            if ((!*pListEnum))                                              \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


//
// Defns used to maintain reference count on structures
//


ULONG
__inline
InitializeObjectReference(POBJECT_HEADER Object, UCHAR RefType)
{
    UNREFERENCED_PARAMETER(RefType);

#if DBG_REF
    InterlockedIncrement(&Object->RefTypes[RefType]);
#endif

    return InterlockedIncrement(&Object->RefCount);
}


ULONG
__inline
ReferenceObject(POBJECT_HEADER Object, UCHAR RefType)
{
    UNREFERENCED_PARAMETER(RefType);

    // Once ref falls to 0, this should never happen
    ASSERT(Object->RefCount > 0);

#if DBG_REF
    ASSERT(Object->RefTypes[RefType] >= 0);

    InterlockedIncrement(&Object->RefTypes[RefType]);
#endif

    return InterlockedIncrement(&Object->RefCount);
}


ULONG
__inline
DereferenceObject(POBJECT_HEADER Object, UCHAR RefType)
{
    UNREFERENCED_PARAMETER(RefType);

    // Ref count should be +ve before we decrement it
    ASSERT(Object->RefCount > 0);

#if DBG_REF
    ASSERT(Object->RefTypes[RefType] > 0);

    InterlockedDecrement(&Object->RefTypes[RefType]);
#endif

    return InterlockedDecrement(&Object->RefCount);
}


#define INITIALIZE_INSTANCE_REFERENCE(Instance, RefType)                    \
            InitializeObjectReference(&Instance->ObjectHeader, RefType);

#define REFERENCE_INSTANCE(Instance, RefType)                               \
            ReferenceObject(&Instance->ObjectHeader, RefType);

#define DEREFERENCE_INSTANCE(Instance, RefType)                             \
            if (DereferenceObject(&Instance->ObjectHeader, RefType) == 0)   \
                DestroyInstance(Instance);


#define INITIALIZE_ADDR_FAMILY_REFERENCE(Instance, RefType)                 \
            InitializeObjectReference(&Instance->ObjectHeader, RefType);

#define REFERENCE_ADDR_FAMILY(AddrFamilyInfo, RefType)                      \
            ReferenceObject(&AddrFamilyInfo->ObjectHeader, RefType);

#define DEREFERENCE_ADDR_FAMILY(AddrFamInfo, RefType)                       \
            if (DereferenceObject(&AddrFamInfo->ObjectHeader,RefType) == 0) \
                DestroyAddressFamily(AddrFamInfo);


#define INITIALIZE_ENTITY_REFERENCE(Entity, RefType)                        \
            InitializeObjectReference(&Entity->ObjectHeader, RefType);

#define REFERENCE_ENTITY(Entity, RefType)                                   \
            ReferenceObject(&Entity->ObjectHeader, RefType);

#define DEREFERENCE_ENTITY(Entity, RefType)                                 \
            if (DereferenceObject(&Entity->ObjectHeader, RefType) == 0)     \
                DestroyEntity(Entity);


#define INITIALIZE_DEST_REFERENCE(Dest, RefType)                            \
            InitializeObjectReference(&(Dest)->ObjectHeader, RefType);

#define REFERENCE_DEST(Dest, RefType)                                       \
            ReferenceObject(&(Dest)->ObjectHeader, RefType);

#define DEREFERENCE_DEST(Dest, RefType)                                     \
            if (DereferenceObject(&(Dest)->ObjectHeader, RefType) == 0)     \
                DestroyDest(Dest);


#define INITIALIZE_ROUTE_REFERENCE(Route, RefType)                          \
            InitializeObjectReference(&(Route)->ObjectHeader, RefType);

#define REFERENCE_ROUTE(Route, RefType)                                     \
            ReferenceObject(&(Route)->ObjectHeader, RefType);

#define DEREFERENCE_ROUTE(Route, RefType)                                   \
            if (DereferenceObject(&(Route)->ObjectHeader, RefType) == 0)    \
                DestroyRoute(Route);


#define INITIALIZE_NEXTHOP_REFERENCE(NextHop, RefType)                      \
            InitializeObjectReference(&(NextHop)->ObjectHeader, RefType);

#define REFERENCE_NEXTHOP(NextHop, RefType)                                 \
            ReferenceObject(&(NextHop)->ObjectHeader, RefType);

#define DEREFERENCE_NEXTHOP(NextHop, RefType)                               \
            if (DereferenceObject(&(NextHop)->ObjectHeader, RefType) == 0)  \
                DestroyNextHop(NextHop);

//
// Macros used to lock structures using critical sections
//

#define CREATE_LOCK(Lock)                                                   \
            InitializeCriticalSection((Lock))

#define DELETE_LOCK(Lock)                                                   \
            DeleteCriticalSection((Lock))

#define ACQUIRE_LOCK(Lock)                                                  \
            EnterCriticalSection((Lock))

#define RELEASE_LOCK(Lock)                                                  \
            LeaveCriticalSection((Lock))


//
// Macros used to lock structures in read or write mode
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))

#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))

#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)

#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)

#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))

#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)

#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))

#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

//
// Macros to acquire and release dynamic R/W locks
// [ This has been borrowed from the MGM libary ]
//

#define ACQUIRE_DYNAMIC_READ_LOCK(ppRWL)                                    \
            AcquireReadLock((PMGM_READ_WRITE_LOCK *)ppRWL)

#define RELEASE_DYNAMIC_READ_LOCK(ppRWL)                                    \
            ReleaseReadLock((PMGM_READ_WRITE_LOCK *)ppRWL)

#define ACQUIRE_DYNAMIC_WRITE_LOCK(ppRWL)                                   \
            AcquireWriteLock((PMGM_READ_WRITE_LOCK *)ppRWL)

#define RELEASE_DYNAMIC_WRITE_LOCK(ppRWL)                                   \
            ReleaseWriteLock((PMGM_READ_WRITE_LOCK *)ppRWL)


//
// Macros used in allocating and operating on memory
//

#define ZeroMemory             RtlZeroMemory
#define CopyMemory             RtlCopyMemory
#define CompareMemory          RtlEqualMemory

#define AllocOnStack(nb)       _alloca((nb))

#define AllocMemory(nb)        HeapAlloc(RtmGlobals.GlobalHeap,  \
                                         0,                      \
                                         (nb))

#define AllocNZeroMemory(nb)   HeapAlloc(RtmGlobals.GlobalHeap,  \
                                         HEAP_ZERO_MEMORY,       \
                                         (nb))

#define FreeMemory(ptr)        HeapFree(RtmGlobals.GlobalHeap,   \
                                        0,                       \
                                        (ptr))

#if !DBG_MEM

#define AllocNZeroObject(nb)   AllocNZeroMemory(nb)

#else

PVOID
__inline
AllocNZeroObject(UINT NumBytes)
{
    OBJECT_HEADER *Object;

    Object = AllocNZeroMemory(NumBytes);

    if (Object)
    {

        ACQUIRE_ALLOCS_LIST_LOCK();
        InsertTailList(&RtmGlobals.AllocsList, &Object->AllocLE);
        RELEASE_ALLOCS_LIST_LOCK();
    }

    return Object;
}

#endif

#if !DBG_MEM

#define FreeObject(ptr)        FreeMemory(ptr)

#else

VOID
__inline
FreeObject(PVOID Object)
{
    ACQUIRE_ALLOCS_LIST_LOCK();
    RemoveEntryList(&((POBJECT_HEADER)Object)->AllocLE);
    RELEASE_ALLOCS_LIST_LOCK();

    FreeMemory(Object);
}

#endif

//
// Other Misc Macros
//


DWORD
__inline
NumBitsInDword (DWORD Dword)
{
    DWORD  NumBits = 0;

    while (Dword)
    {
        Dword &= (Dword - 1);

        NumBits++;
    }

    return NumBits;
}

#define NUMBER_OF_BITS  NumBitsInDword

//
// Error Handling and other related macros
//
#define SUCCESS(code)          (code == NO_ERROR)

//
// DLL Startup, Cleanup Functions and Macros
//

BOOL
RtmDllStartup(
    VOID
    );

BOOL
RtmDllCleanup(
    VOID
    );

DWORD
RtmApiStartup(
    VOID
    );

#define CHECK_FOR_RTM_API_INITIALIZED()                          \
    if (!RtmGlobals.ApiInitialized)                              \
    {                                                            \
        Status = RtmApiStartup();                                \
                                                                 \
        if (Status != NO_ERROR)                                  \
        {                                                        \
            return Status;                                       \
        }                                                        \
    }                                                            \

#endif //__ROUTING_RTMMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmlist.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmlist.c

Abstract:

    Contains routines for managing entity-specific
    list of routes in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmCreateRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    OUT     PRTM_ROUTE_LIST_HANDLE          RouteListHandle
    )

/*++

Routine Description:

    Creates a list in which the caller can keep routes owned
    by it.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity

    RouteListHandle   - Handle to the new route list is returned

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PROUTE_LIST     RouteList;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Create and initialize a new route list
    //

    RouteList = (PROUTE_LIST) AllocNZeroObject(sizeof(ROUTE_LIST));

    if (RouteList == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    RouteList->ListHeader.ObjectHeader.TypeSign = ROUTE_LIST_ALLOC;

    RouteList->ListHeader.HandleType = ROUTE_LIST_TYPE;
#endif

    InitializeListHead(&RouteList->ListHead);

#if DBG_HDL
    //
    // Insert into list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    InsertTailList(&Entity->OpenHandles, &RouteList->ListHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    REFERENCE_ENTITY(Entity, LIST_REF);

    //
    // Make a handle to the route list and return
    //

    *RouteListHandle = MAKE_HANDLE_FROM_POINTER(RouteList);

    return NO_ERROR;
}


DWORD
WINAPI
RtmInsertInRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Inserts a set of routes into the route list. If any route
    is already in another route list, it is removed from this
    old list in the process.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity

    RouteListHandle   - Handle to the route list into which we are
                        moving the routes to; if this argument is 
                        NULL then we are just removing the routes 
                        from the route lists to which they belonged

    NumRoutes         - Num. of route handles in the input buffer

    RouteHandles      - Array of handles to insert into the new list

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PROUTE_LIST     RouteList;
    PROUTE_INFO     Route;
    UINT            i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    RouteList = NULL;

    if (ARGUMENT_PRESENT(RouteListHandle))
    {
        VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);
    }

    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

    for (i = 0; i < NumRoutes; i++)
    {
        Route = ROUTE_FROM_HANDLE(RouteHandles[i]);

        ASSERT(Route->RouteInfo.RouteOwner == RtmRegHandle);

        //
        // Remove from old list if it was present in one
        //

        if (!IsListEmpty(&Route->RouteListLE))
        {
            RemoveEntryList(&Route->RouteListLE);

            DEREFERENCE_ROUTE(Route, LIST_REF);
        }

        //
        // Insert in the new list if a new list is specified
        //

        if (RouteList)
        {
            InsertTailList(&RouteList->ListHead, &Route->RouteListLE);

            REFERENCE_ROUTE(Route, LIST_REF);
        }
    }

    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

    return NO_ERROR;
}


DWORD
WINAPI
RtmCreateRouteListEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration on routes in the specified route list.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteListHandle   - Handle to route list whose routes we want,

    RtmEnumHandle     - Handle to this enumeration, which is used
                        in calls to get routes in the route list

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO  Entity;
    PROUTE_LIST   RouteList;
    PLIST_ENUM    Enum;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);

    //
    // Create and initialize an list enumeration block
    //

    Enum = (PLIST_ENUM) AllocNZeroObject(sizeof(LIST_ENUM));
    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    Enum->EnumHeader.ObjectHeader.TypeSign = LIST_ENUM_ALLOC;
#endif
    Enum->EnumHeader.HandleType = LIST_ENUM_TYPE;

    Enum->RouteList = RouteList;

    //
    // Insert marker into the route list
    //

    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);
    InsertHeadList(&RouteList->ListHead, &Enum->MarkerRoute.RouteListLE);
    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

#if DBG_HDL
    //
    // Insert into the list of handles opened by entity
    //
  
    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    InsertTailList(&Entity->OpenHandles,&Enum->EnumHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    REFERENCE_ENTITY(Entity, ENUM_REF);

    //
    // Make a handle to the enum block and return
    //
    
    *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetListEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Enumerates a set of routes in the route list starting from
    a specific route (if given) or the start of the route list.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EnumHandle        - Handle to enumeration on the route list,

    NumRoutes         - Max. number of routes to fill is passed in,
                        Num. of routes actually copied is returned.

    RouteHandles      - Output buffer where route handles are retd.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PLIST_ENUM      ListEnum;
    PROUTE_INFO     Route;
    UINT            RoutesInput;
    PLIST_ENTRY     p;

    RoutesInput = *NumRoutes;

    *NumRoutes = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_LIST_ENUM_HANDLE(EnumHandle, &ListEnum);

    if (RoutesInput > Entity->OwningAddrFamily->MaxHandlesInEnum)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // List routes starting from the enum's marker route
    //

    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);
    
    for (p = ListEnum->MarkerRoute.RouteListLE.Flink;
             p != &ListEnum->RouteList->ListHead;
                 p = p->Flink)
    {
        if (*NumRoutes >= RoutesInput)
        {
            break;
        }

        Route = CONTAINING_RECORD(p, ROUTE_INFO, RouteListLE);

        //
        // If this route is not a marker route, copy handle
        //

        if (Route->RouteInfo.DestHandle)
        {
            RouteHandles[(*NumRoutes)++] = MAKE_HANDLE_FROM_POINTER(Route);

            REFERENCE_ROUTE(Route, HANDLE_REF);
        }
    }

    //
    // Re-adjust the marker to reflect its new posn
    //

    RemoveEntryList(&ListEnum->MarkerRoute.RouteListLE);

    InsertTailList(p, &ListEnum->MarkerRoute.RouteListLE);

    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);
        
    return NO_ERROR;
}


DWORD
WINAPI
RtmDeleteRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle
    )

/*++

Routine Description:

    Removes all routes on an entity specific list and frees
    resources allocated to it.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteListHandle   - Handle to the route list to delete.

Return Value:

    Status of the operation

--*/
{
    PENTITY_INFO    Entity;
    PROUTE_LIST     RouteList;
    PLIST_ENUM      Enum;
    PROUTE_INFO     Route;
    PLIST_ENTRY     p;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);


    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

    //
    // Remove each route from the route list
    //

    while (!IsListEmpty(&RouteList->ListHead))
    {
        p = RemoveHeadList(&RouteList->ListHead);

        Route = CONTAINING_RECORD(p, ROUTE_INFO, RouteListLE);

        if (Route->RouteInfo.DestHandle)
        {
            // This is an actual route in the list

            DEREFERENCE_ROUTE(Route, LIST_REF);
        }
        else
        {
            // This is a marker route for an enum

            Enum = CONTAINING_RECORD(Route, LIST_ENUM, MarkerRoute);

#if DBG_HDL
            //
            // Remove from the list of handles opened by entity
            //
                
            ACQUIRE_OPEN_HANDLES_LOCK(Entity);
            RemoveEntryList(&Enum->EnumHeader.HandlesLE);
            RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

            DEREFERENCE_ENTITY(Entity, ENUM_REF);

            // Free the memory allocated for the enum and continue

#if DBG_HDL
            Enum->EnumHeader.ObjectHeader.TypeSign = LIST_ENUM_FREED;
#endif
            FreeObject(Enum);
        }
    }

    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

#if DBG_HDL
    //
    // Remove from the list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    RemoveEntryList(&RouteList->ListHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    DEREFERENCE_ENTITY(Entity, LIST_REF);

    // Free the memory allocated for the list and return

#if DBG_HDL
    RouteList->ListHeader.ObjectHeader.TypeSign = ROUTE_LIST_FREED;
#endif

    FreeObject(RouteList);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmobj2.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmobj2.c

Abstract:

    Contains routines for managing RTM objects
    like Destinations, Routes and Next Hops.

Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

DWORD
CreateDest (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      PRTM_NET_ADDRESS                DestAddress,
    OUT     PDEST_INFO                     *NewDest
    )

/*++

Routine Description:

    Creates a new destination info structure and initializes it.

Arguments:

    AddrFamilyInfo    - Address family that identifies route table,

    DestAddress       - Destination network address for new dest,

    NewDest           - Pointer to the destination info structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    PDEST_INFO      Dest;
    UINT            NumOpaquePtrs;
    UINT            NumBytes;
    UINT            NumViews;
    DWORD           Status;

    *NewDest = NULL;

    //
    // Allocate and initialize a new route info
    //

    NumOpaquePtrs = AddrFamilyInfo->MaxOpaquePtrs;

    NumViews = AddrFamilyInfo->NumberOfViews;

    NumBytes = sizeof(DEST_INFO) + 
                   NumOpaquePtrs * sizeof(PVOID) +
                       (NumViews - 1) * sizeof(Dest->ViewInfo);

    Dest = (PDEST_INFO) AllocNZeroObject(NumBytes);

    if (Dest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {

#if DBG_HDL
        Dest->ObjectHeader.TypeSign = DEST_ALLOC;
#endif

        // Will be removed when first route on dest is added
        INITIALIZE_DEST_REFERENCE(Dest, CREATION_REF);

        //
        // Initialize change notification bits and list entry
        //

        Dest->ChangeListLE.Next = NULL;

        //
        // Initialize the list of routes ont the destination
        //

        InitializeListHead(&Dest->RouteList);

        Dest->NumRoutes = 0;

        // Set the opaque ptr dir to memory at the end of dest

        Dest->OpaqueInfoPtrs = (PVOID *) ((PUCHAR) Dest  +
                                          NumBytes - 
                                          NumOpaquePtrs * sizeof(PVOID));

        // Set the destination address from the input parameter

        CopyMemory(&Dest->DestAddress,
                   DestAddress,
                   sizeof(RTM_NET_ADDRESS));

        *NewDest = Dest;

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error occured in the initialization , clean up
    //

#if DBG_HDL
    Dest->ObjectHeader.TypeSign = DEST_FREED;
#endif

    FreeObject(Dest);

    *NewDest = NULL;

    return Status;
}

DWORD
DestroyDest (
    IN      PDEST_INFO                      Dest
    )

/*++

Routine Description:

    Destroys the destination by freeing resources and
    deallocating it. This function is called when the
    reference count on the dest drops to 0.

Arguments:

    Dest   - Pointer to the dest being destroyed.

Return Value:

    None

--*/

{
    ASSERT(Dest->ObjectHeader.RefCount == 0);

    ASSERT(Dest->HoldRefCount == 0);

    //
    // Dynamic lock should have been freed
    //

    ASSERT(Dest->DestLock == NULL);

    //
    // Free the memory allocated for dest
    //

#if DBG_HDL
    Dest->ObjectHeader.TypeSign = DEST_FREED;
#endif

    FreeObject(Dest);

    return NO_ERROR;
}


DWORD
CreateRoute (
    IN      PENTITY_INFO                    Entity,    
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    OUT     PROUTE_INFO                    *NewRoute
    )

/*++

Routine Description:

    Creates a new route info structure and initializes it.

Arguments:

    Entity            - Entity creating the new route on a dest,

    RouteInfo         - Route info for the new route being created,

    NewRoute          - Pointer to the new route info structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    RTM_NEXTHOP_HANDLE NextHopHandle;
    PRTM_ROUTE_INFO    Info;
    PROUTE_INFO        Route;
    PNEXTHOP_INFO      NextHop;
    UINT               NumNextHops;
    UINT               i;
    DWORD              Status;

    *NewRoute = NULL;

    //
    // Allocate and initialize a new route info
    //

    NumNextHops = Entity->OwningAddrFamily->MaxNextHopsInRoute;

    Route = (PROUTE_INFO) AllocNZeroObject(sizeof(ROUTE_INFO) +
                                           (NumNextHops - 1) *
                                           sizeof(RTM_NEXTHOP_HANDLE));

    if (Route == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
#if DBG_HDL
        Route->ObjectHeader.TypeSign = ROUTE_ALLOC;
#endif
        INITIALIZE_ROUTE_REFERENCE(Route, CREATION_REF);

        InitializeListHead(&Route->DestLE);

        InitializeListHead(&Route->RouteListLE);

        //
        // Initialize the public half of route info 
        //

        Info = &Route->RouteInfo;

        Info->RouteOwner = MAKE_HANDLE_FROM_POINTER(Entity);

        REFERENCE_ENTITY(Entity, ROUTE_REF);

        if (RouteInfo->Neighbour)
        {
            NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);

            REFERENCE_NEXTHOP(NextHop, ROUTE_REF);

            // "Neighbour learnt from" entry is owned by caller

            ASSERT((NextHop) && 
                   (NextHop->NextHopInfo.NextHopOwner == Info->RouteOwner));

            Info->Neighbour = RouteInfo->Neighbour;
        }

        Info->State = RTM_ROUTE_STATE_CREATED;

        Info->Flags1 = RouteInfo->Flags1;

        Info->Flags = RouteInfo->Flags;

        Info->PrefInfo = RouteInfo->PrefInfo;

        Info->BelongsToViews = RouteInfo->BelongsToViews;

        Info->EntitySpecificInfo = RouteInfo->EntitySpecificInfo;

        //
        // Make a copy of the next hops list (as much as u can)
        //

        if (NumNextHops > RouteInfo->NextHopsList.NumNextHops)
        {
            NumNextHops = RouteInfo->NextHopsList.NumNextHops;
        }

        Info->NextHopsList.NumNextHops = (USHORT) NumNextHops;

        for (i = 0; i < NumNextHops; i++)
        {
            NextHopHandle = RouteInfo->NextHopsList.NextHops[i];

            // Make sure that the next-hop is owned by caller

            NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

            ASSERT((NextHop) && 
                   (NextHop->NextHopInfo.NextHopOwner == Info->RouteOwner));

            Info->NextHopsList.NextHops[i] = NextHopHandle;

            REFERENCE_NEXTHOP(NextHop, ROUTE_REF);
        }

        //
        // Return a pointer to the new initialized route
        //

        *NewRoute = Route;
      
        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error occured in the initialization , clean up
    //

#if DBG_HDL
    Route->ObjectHeader.TypeSign = ROUTE_FREED;
#endif

    FreeObject(Route);    

    *NewRoute = NULL;

    return Status;
}

VOID
ComputeRouteInfoChange(
    IN      PRTM_ROUTE_INFO                 OldRouteInfo,
    IN      PRTM_ROUTE_INFO                 NewRouteInfo,
    IN      ULONG                           PrefChanged,
    OUT     PULONG                          RouteInfoChanged,
    OUT     PULONG                          ForwardingInfoChanged
    )

/*++

Routine Description:

    Updates an exising route with new route info. Note that
    only the route's owner is allowed to do this.

Arguments:

    OldRoute         - Old route information (except the PrefInfo and
                       BelongsToViews info fields already updated),

    NewRoute         - New route information to update old route with,

    PrefChanged      - Whether PrefInfo values changed from old to new,

    RouteInfoChanged - Whether the route information has changed,

    ForwardingInfoChanged - Whether forwarding info has been changed.

Return Value:

    None

--*/

{
    ULONG  DiffFlags;
    UINT   i;

    *RouteInfoChanged = *ForwardingInfoChanged = 0;

    do
    {
        //
        // Has the preference changed from old to new ?
        //

        if (PrefChanged)
        {
            break;
        }

        //
        // Are the number and handles to next hops same ?
        //

        if (OldRouteInfo->NextHopsList.NumNextHops !=
            NewRouteInfo->NextHopsList.NumNextHops)
        {
            break;
        }

        for (i = 0; i < OldRouteInfo->NextHopsList.NumNextHops; i++)
        {
            if (OldRouteInfo->NextHopsList.NextHops[i] !=
                NewRouteInfo->NextHopsList.NextHops[i])
            {
                break;
            }
        }

        if (i != OldRouteInfo->NextHopsList.NumNextHops)
        {
            break;
        }

        //
        // Have the forwarding flags changed from old ?
        //

        DiffFlags = OldRouteInfo->Flags ^ NewRouteInfo->Flags;

        if (DiffFlags & RTM_ROUTE_FLAGS_FORWARDING)
        {
            break;
        }

        //
        // Have non forwarding flags changed from old ?
        //

        if (DiffFlags)
        {
            *RouteInfoChanged = 1;
        }
        
        return;
    } 
    while (FALSE);

    //
    // Forwarding info is a subset of route info
    //

    *ForwardingInfoChanged = *RouteInfoChanged = 1;

    return;
}

VOID
CopyToRoute (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      PROUTE_INFO                     Route
    )

/*++

Routine Description:

    Updates an exising route with new route info. Note that
    only the route's owner is allowed to do this.

Arguments:

    Entity      - Entity that is updating the existing route,

    RouteInfo   - Route info using which route is being updated,

    Route       - Route that is being updated with above info.

Return Value:

    None

--*/

{
    RTM_NEXTHOP_HANDLE NextHopHandle;
    PRTM_ROUTE_INFO    Info;
    PNEXTHOP_INFO      NextHop;
    UINT               NumNextHops;
    UINT               i;    

    Info = &Route->RouteInfo;

    //
    // Update the route with the new information
    //

    Info->State = RTM_ROUTE_STATE_CREATED;

    Info->Flags1 = RouteInfo->Flags1;

    Info->Flags = RouteInfo->Flags;

    Info->PrefInfo = RouteInfo->PrefInfo;

    Info->BelongsToViews = RouteInfo->BelongsToViews;

    Info->EntitySpecificInfo = RouteInfo->EntitySpecificInfo;

    //
    // Update the neighbour "learnt from" field
    //

    if (Info->Neighbour != RouteInfo->Neighbour)
    {
        // Free the previous "neighbour learnt from"

        if (Info->Neighbour)
        {
            NextHop = NEXTHOP_FROM_HANDLE(Info->Neighbour);

            DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
        }

        // Copy the new neighbour "learnt from" now

        if (RouteInfo->Neighbour)
        {
            NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);

            REFERENCE_NEXTHOP(NextHop, ROUTE_REF);

            // "Neighbour learnt from" entry is owned by caller

            ASSERT((NextHop) && 
                   (NextHop->NextHopInfo.NextHopOwner == Info->RouteOwner));
        }

        Info->Neighbour = RouteInfo->Neighbour;
    }

    //
    // Count the number of next-hops you can copy
    //

    NumNextHops = Entity->OwningAddrFamily->MaxNextHopsInRoute;

    if (NumNextHops > RouteInfo->NextHopsList.NumNextHops)
    {
        NumNextHops = RouteInfo->NextHopsList.NumNextHops;
    }

    //
    // Reference all next-hops that you will copy
    //

    for (i = 0; i < NumNextHops; i++)
    {
        NextHopHandle = RouteInfo->NextHopsList.NextHops[i];

        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

        REFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Dereference existing next-hops before update
    //

    for (i = 0; i < Info->NextHopsList.NumNextHops; i++)
    {
        NextHopHandle = Info->NextHopsList.NextHops[i];

        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

        DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Make a copy of the next hops in input list 
    //

    Info->NextHopsList.NumNextHops = (USHORT) NumNextHops;

    for (i = 0; i < NumNextHops; i++)
    {
        Info->NextHopsList.NextHops[i] = RouteInfo->NextHopsList.NextHops[i];
    }

    return;
}

DWORD
DestroyRoute (
    IN      PROUTE_INFO                     Route
    )

/*++

Routine Description:

    Destroys the route by freeing resources and
    deallocating it. This function is called when
    reference count on the route drops to 0.

Arguments:

    Route  - Pointer to the route being destroyed.

Return Value:

    None

--*/

{
    RTM_NEXTHOP_HANDLE NextHopHandle;
    PRTM_ROUTE_INFO    Info;
    PNEXTHOP_INFO      NextHop;
    PENTITY_INFO       Entity;
    PDEST_INFO         Dest;
    UINT               i;

    ASSERT(Route->ObjectHeader.RefCount == 0);

    Info = &Route->RouteInfo;

    //
    // Dereference all next-hops before delete
    //

    for (i = 0; i < Info->NextHopsList.NumNextHops; i++)
    {
        NextHopHandle = Info->NextHopsList.NextHops[i];

        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

        DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Dereference advertising neighbour handle
    //

    if (Info->Neighbour)
    {
        NextHop = NEXTHOP_FROM_HANDLE(Info->Neighbour);

        DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Dereference the owning entity handle
    //

    Entity = ENTITY_FROM_HANDLE(Info->RouteOwner);

    DEREFERENCE_ENTITY(Entity, ROUTE_REF);


    //
    // Dereference the destination for the route
    //

    if (Info->DestHandle)
    {
        Dest = DEST_FROM_HANDLE(Info->DestHandle);

        DEREFERENCE_DEST(Dest, ROUTE_REF);
    }

    //
    // Free the resources allocated for the route
    //

#if DBG_HDL
    Route->ObjectHeader.TypeSign = ROUTE_FREED;
#endif

    FreeObject(Route);

    return NO_ERROR;
}


DWORD
CreateNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PNEXTHOP_INFO                  *NewNextHop
    )

/*++

Routine Description:

    Creates a new nexthop info structure and initializes it.

Arguments:

    Entity      - Entity creating the new nexthop in table,

    NextHopInfo - Nexthop info for the nexthop being created,

    NewNextHop  - Pointer to the new nexthop info structure
                  will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    PRTM_NEXTHOP_INFO  HopInfo;
    PNEXTHOP_INFO      NextHop;
    PDEST_INFO         Dest;

    *NewNextHop = NULL;

    //
    // Allocate and initialize a new next hop info
    //

    NextHop = (PNEXTHOP_INFO) AllocNZeroObject(sizeof(NEXTHOP_INFO));
    if (NextHop == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    NextHop->ObjectHeader.TypeSign = NEXTHOP_ALLOC;
#endif

    INITIALIZE_NEXTHOP_REFERENCE(NextHop, CREATION_REF);

    HopInfo = &NextHop->NextHopInfo;

    HopInfo->NextHopAddress = NextHopInfo->NextHopAddress;

    HopInfo->NextHopOwner = MAKE_HANDLE_FROM_POINTER(Entity);

    HopInfo->InterfaceIndex = NextHopInfo->InterfaceIndex;

    REFERENCE_ENTITY(Entity, NEXTHOP_REF);

    HopInfo->State = RTM_NEXTHOP_STATE_CREATED;

    HopInfo->Flags = NextHopInfo->Flags;

    HopInfo->EntitySpecificInfo = NextHopInfo->EntitySpecificInfo;

    HopInfo->RemoteNextHop = NextHopInfo->RemoteNextHop;

    //
    // Reference the remote nexthop's destination
    //

    if (HopInfo->RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);

        REFERENCE_DEST(Dest, NEXTHOP_REF);
    }

    //
    // Return a pointer to the new initialized nexthop
    //

    *NewNextHop = NextHop;

    return NO_ERROR;
}


VOID
CopyToNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN      PNEXTHOP_INFO                   NextHop
    )

/*++

Routine Description:

    Updates an exising nexthop with new nexthop info. Note that
    only the nexthop's owner is allowed to do this.

Arguments:

    Entity      - Entity that is updating the existing nexthop,

    NextHopInfo - Info using which nexthop is being updated,

    NextHop     - Nexthop that is being updated with above info.

Return Value:

    None

--*/

{
    PRTM_NEXTHOP_INFO  HopInfo;
    PDEST_INFO         Dest;

    UNREFERENCED_PARAMETER(Entity);

    HopInfo = &NextHop->NextHopInfo;

    //
    // Update the nexthop with the new information
    //

    HopInfo->Flags = NextHopInfo->Flags;

    HopInfo->EntitySpecificInfo = NextHopInfo->EntitySpecificInfo;
        
    if (HopInfo->RemoteNextHop != NextHopInfo->RemoteNextHop)
    {
        // Dereference the old next hop and reference new one

        if (HopInfo->RemoteNextHop)
        {
            Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);
            DEREFERENCE_DEST(Dest, NEXTHOP_REF);
        }

        HopInfo->RemoteNextHop = NextHopInfo->RemoteNextHop;

        if (HopInfo->RemoteNextHop)
        {
            Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);
            REFERENCE_DEST(Dest, NEXTHOP_REF);
        }
    }

    return;
}


DWORD
DestroyNextHop (
    IN      PNEXTHOP_INFO                   NextHop
    )

/*++

Routine Description:

    Destroys the nexthop by freeing resources and
    deallocating it. This function is called when
    reference count on the nexthop drops to 0.

Arguments:

    Nexthop - Pointer to the nexthop being destroyed.

Return Value:

    None

--*/

{
    PRTM_NEXTHOP_INFO  HopInfo;
    PDEST_INFO         Dest;
    PENTITY_INFO       Entity;


    ASSERT(NextHop->ObjectHeader.RefCount == 0);

    HopInfo = &NextHop->NextHopInfo;

    //
    // Dereference remote nexthop's destination
    //

    if (HopInfo->RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);

        DEREFERENCE_DEST(Dest, NEXTHOP_REF);
    }

    Entity = ENTITY_FROM_HANDLE(HopInfo->NextHopOwner);

    DEREFERENCE_ENTITY(Entity, NEXTHOP_REF);

    //
    // Free the memory allocated for the next-hop
    //

#if DBG_HDL
    NextHop->ObjectHeader.TypeSign = NEXTHOP_FREED;
#endif
    
    FreeObject(NextHop);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmobj1.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmobj1.c

Abstract:

    Contains routines for managing RTM objects
    like Instances, AddrFamilies and Entities.

Author:

    Chaitanya Kodeboyina (chaitk)   21-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
GetInstance (
    IN      USHORT                          RtmInstanceId,
    IN      BOOL                            ImplicitCreate,
    OUT     PINSTANCE_INFO                 *RtmInstance
    )

/*++

Routine Description:

    Searches for an RTM instance with the input instance
    id. If an instance is not found and ImplicitCreate
    is TRUE, then a new instance is created and added to
    the table of instances.

Arguments:

    RtmInstanceId     - Id for RTM Instance being searched for,

    ImplicitCreate    - Create a new instance if not found or not,

    RtmInstance       - Pointer to the Instance Info Structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function. If ImplicitCreate is FALSE, a read lock would
    do, but if it is TRUE then a write lock should be held as we
    would need to insert a new instance into the instances list.

--*/

{
    PLIST_ENTRY    Instances;
    PINSTANCE_INFO Instance;
    PLIST_ENTRY    p;
    DWORD          Status;

    Instances = &RtmGlobals.InstanceTable[RtmInstanceId % INSTANCE_TABLE_SIZE];

#if WRN
    Instance = NULL;
#endif

    do
    {
        // Search the global list for a matching instance
        for (p = Instances->Flink; p != Instances; p = p->Flink)
        {
            Instance = CONTAINING_RECORD(p, INSTANCE_INFO, InstTableLE);
            
            if (Instance->RtmInstanceId >= RtmInstanceId)
            {
                break;
            }
        }

        if ((p == Instances) || (Instance == NULL) ||
                (Instance->RtmInstanceId != RtmInstanceId))
        {
            // We did not find an instance - create new one ?
            if (!ImplicitCreate)
            {
                Status = ERROR_NOT_FOUND;
                break;
            }

            // Create a new instance with input Instance id
            Status = CreateInstance(RtmInstanceId, &Instance);
            if (Status != NO_ERROR)
            {
                break;
            }

            // Insert into list in sorted Instance Id order
            InsertTailList(p, &Instance->InstTableLE);
        }

        Status = NO_ERROR;

        *RtmInstance = Instance;
    }
    while (FALSE);

    return Status;
}


DWORD
CreateInstance (
    IN      USHORT                          RtmInstanceId,
    OUT     PINSTANCE_INFO                 *NewInstance
    )

/*++

Routine Description:

    Creates a new instance info structure and initializes it.

Arguments:

    RtmInstanceId     - RTM Instance Id for the new RTM instance,

    InstConfig        - Configuration Info for the new instance,

    NewInstance       - Pointer to the Instance Info Structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    Need to be called with the instances WRITE lock as we are
    incrementing the number of instances here.

--*/

{
    RTM_INSTANCE_CONFIG InstConfig;
    PINSTANCE_INFO      Instance;
    DWORD               Status;

    *NewInstance = NULL;

    //
    // Read Instance Configuration from the registry
    //
    
    Status = RtmReadInstanceConfig(RtmInstanceId, &InstConfig);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Allocate and initialize a new instance info
    //

    Instance = (PINSTANCE_INFO) AllocNZeroObject(sizeof(INSTANCE_INFO));

    if (Instance == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    Instance->ObjectHeader.TypeSign = INSTANCE_ALLOC;
#endif

    // Will be removed when last addr family goes
    INITIALIZE_INSTANCE_REFERENCE(Instance, CREATION_REF);

    Instance->RtmInstanceId = RtmInstanceId;

    //
    // Linking instance to global list of instances is
    // done by caller, but pretend it is already done
    //

    RtmGlobals.NumInstances++;

    InitializeListHead(&Instance->InstTableLE);

    //
    // Initialize the table of address families
    //

    Instance->NumAddrFamilies = 0;

    InitializeListHead(&Instance->AddrFamilyTable);

    *NewInstance = Instance;
      
    return NO_ERROR;
}


DWORD
DestroyInstance (
    IN      PINSTANCE_INFO                  Instance
    )

/*++

Routine Description:

    Destroys an existing instance info structure. Assumes that
    no registered entities exist on this instance when called.

Arguments:

    Instance       - Pointer to the Instance Info Structure.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function as it removes an instance from that list. This
    is typically taken in DestroyEntity, but it can also happen
    that the lock is acquired in RtmRegisterEntity and an error
    occured.

--*/

{
    ASSERT(Instance->ObjectHeader.RefCount == 0);

    ASSERT(Instance->NumAddrFamilies == 0);

    //
    // Remove this instance from list of instances
    //

    RemoveEntryList(&Instance->InstTableLE);

    RtmGlobals.NumInstances--;

    //
    // Free resources allocated for this instance
    //

#if DBG_HDL
    Instance->ObjectHeader.TypeSign = INSTANCE_FREED;
#endif

    FreeObject(Instance);

    return NO_ERROR;
}


DWORD
GetAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    IN      BOOL                            ImplicitCreate,
    OUT     PADDRFAM_INFO                  *AddrFamilyInfo
    )

/*++

Routine Description:

    Searches for an address family in an RTM instance.
    If it is not found and ImplicitCreate is TRUE, then
    a new address family info is created and added to
    the list of address families.

Arguments:

    Instance          - RTM Instance that holds the address family,

    AddressFamily     - Address family for info being searched for,

    ImplicitCreate    - Create an addr family info if not found or not,

    AddrFamilyInfo    - Pointer to the new Address Family Info
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function. If ImplicitCreate is FALSE, a read lock would
    do, but if it is TRUE then a write lock should be held as we
    will need it to insert a new address family info into a list.

--*/

{
    PLIST_ENTRY    AddrFams;
    PADDRFAM_INFO  AddrFamInfo;
    PLIST_ENTRY    q;
    DWORD          Status;

    AddrFams = &Instance->AddrFamilyTable;

#if WRN
    AddrFamInfo = NULL;
#endif

    do
    {
        // Search the list of addr families on instance
        for (q = AddrFams->Flink; q != AddrFams; q = q->Flink)
        {
            AddrFamInfo = CONTAINING_RECORD(q, ADDRFAM_INFO, AFTableLE);
        
            if (AddrFamInfo->AddressFamily >= AddressFamily)
            {
                break;
            }      
        }

        if ((q == AddrFams) || (AddrFamInfo == NULL) ||
                (AddrFamInfo->AddressFamily != AddressFamily))
        {
            // We did not find an instance - create new one ?
            if (!ImplicitCreate)
            {
                Status = ERROR_NOT_FOUND;
                break;
            }

            // Create a new addr family info with input family
            Status = CreateAddressFamily(Instance,AddressFamily, &AddrFamInfo);
            if (Status != NO_ERROR)
            {
                break;
            }

            // Insert into list sorted in Address Family order
            InsertTailList(q, &AddrFamInfo->AFTableLE);
        }

        Status = NO_ERROR;

        *AddrFamilyInfo = AddrFamInfo;
    }
    while (FALSE);

    return Status;
}


DWORD
CreateAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    OUT     PADDRFAM_INFO                  *NewAddrFamilyInfo
    )

/*++

Routine Description:

    Creates a new address family info and initializes it

Arguments:

    Instance          - RTM Instance that owns addr family info,

    AddressFamily     - Address family  for the new info block,

    AddrFamilyInfo    - Pointer to the new Address Family Info
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    Need to be called with the instances WRITE lock as we are
    are incrementing number of address families on instance.

--*/

{
    RTM_ADDRESS_FAMILY_CONFIG  AddrFamConfig;
    PADDRFAM_INFO              AddrFamilyInfo;
    RTM_VIEW_SET               ViewsSupported;
    PSINGLE_LIST_ENTRY         ListPtr;
    UINT                       i;
    DWORD                      Status;

    *NewAddrFamilyInfo = NULL;

    //
    // Read AddressFamily Configuration from the registry
    //
    
    Status = RtmReadAddressFamilyConfig(Instance->RtmInstanceId,
                                        AddressFamily,
                                        &AddrFamConfig);
    if (Status != NO_ERROR)
    {
        if (Instance->NumAddrFamilies == 0)
        {
            DEREFERENCE_INSTANCE(Instance, CREATION_REF);
        }

        return Status;
    }


    //
    // Allocate and initialize a new address family info
    //

    AddrFamilyInfo = (PADDRFAM_INFO) AllocNZeroObject(sizeof(ADDRFAM_INFO));

    if (AddrFamilyInfo == NULL)
    {
        if (Instance->NumAddrFamilies == 0)
        {
            DEREFERENCE_INSTANCE(Instance, CREATION_REF);
        }
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    do
    {
#if DBG_HDL
        AddrFamilyInfo->ObjectHeader.TypeSign = ADDRESS_FAMILY_ALLOC;
#endif

        // Will be removed when last entity deregisters
        INITIALIZE_ADDR_FAMILY_REFERENCE(AddrFamilyInfo, CREATION_REF);

        AddrFamilyInfo->AddressFamily = AddressFamily;

        AddrFamilyInfo->AddressSize = AddrFamConfig.AddressSize;

        AddrFamilyInfo->Instance = Instance;

        REFERENCE_INSTANCE(Instance, ADDR_FAMILY_REF);

        //
        // Linking the address family to its owning instance
        // is done by caller, but pretend it is already done
        //

        Instance->NumAddrFamilies++;

        InitializeListHead(&AddrFamilyInfo->AFTableLE);

        //
        // Count number of views supported by this addr family
        // & setup the view id <-> view index in dest mappings
        //

        AddrFamilyInfo->ViewsSupported = AddrFamConfig.ViewsSupported;

        ViewsSupported = AddrFamConfig.ViewsSupported;
        AddrFamilyInfo->NumberOfViews  = 0;

        for (i = 0; i < RTM_MAX_VIEWS; i++)
        {
            AddrFamilyInfo->ViewIdFromIndex[i] = -1;
            AddrFamilyInfo->ViewIndexFromId[i] = -1;
        }

        for (i = 0; (i < RTM_MAX_VIEWS) && ViewsSupported; i++)
        {
           if (ViewsSupported & 0x01)
            {
                AddrFamilyInfo->ViewIdFromIndex[AddrFamilyInfo->NumberOfViews]
                                                   = i;

                AddrFamilyInfo->ViewIndexFromId[i] = 
                                                AddrFamilyInfo->NumberOfViews;

                AddrFamilyInfo->NumberOfViews++;
            }

            ViewsSupported >>= 1;
        }

        AddrFamilyInfo->MaxHandlesInEnum = AddrFamConfig.MaxHandlesInEnum;

        AddrFamilyInfo->MaxNextHopsInRoute = AddrFamConfig.MaxNextHopsInRoute;

        //
        // Initialize the opaque pointer's directory
        //

        AddrFamilyInfo->MaxOpaquePtrs = AddrFamConfig.MaxOpaqueInfoPtrs;
        AddrFamilyInfo->NumOpaquePtrs = 0;

        AddrFamilyInfo->OpaquePtrsDir = 
            AllocNZeroMemory(AddrFamilyInfo->MaxOpaquePtrs * sizeof(PVOID));

        if (AddrFamilyInfo->OpaquePtrsDir == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize the list of entities on this address family
        //

        AddrFamilyInfo->NumEntities = 0;
        for (i = 0; i < ENTITY_TABLE_SIZE; i++)
        {
            InitializeListHead(&AddrFamilyInfo->EntityTable[i]);
        }

        //
        // Init list of entities de-registered but not destroyed
        //

        InitializeListHead(&AddrFamilyInfo->DeregdEntities);

        //
        // Initialize the route table and route table lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&AddrFamilyInfo->RouteTableLock);

            AddrFamilyInfo->RoutesLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Status = CreateTable(AddrFamilyInfo->AddressSize,
                             &AddrFamilyInfo->RouteTable);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Initialize queue to hold notification timers
        //

        AddrFamilyInfo->NotifTimerQueue = CreateTimerQueue();

        if (AddrFamilyInfo->NotifTimerQueue == NULL)
        {
            Status = GetLastError();
            break;
        }

        //
        // Initialize queue to hold route timers on AF
        //

        AddrFamilyInfo->RouteTimerQueue = CreateTimerQueue();

        if (AddrFamilyInfo->RouteTimerQueue == NULL)
        {
            Status = GetLastError();
            break;
        }

        //
        // Initialize the change notification info and lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&AddrFamilyInfo->ChangeNotifsLock);

            AddrFamilyInfo->NotifsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        AddrFamilyInfo->MaxChangeNotifs = AddrFamConfig.MaxChangeNotifyRegns;
        AddrFamilyInfo->NumChangeNotifs = 0;

        //
        // Allocate memory for the max number of notifications
        //

        AddrFamilyInfo->ChangeNotifsDir = 
            AllocNZeroMemory(AddrFamilyInfo->MaxChangeNotifs * 
                             sizeof(PVOID));

        if (AddrFamilyInfo->ChangeNotifsDir == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize lock protecting the notification timer
        //

        try
        {
            InitializeCriticalSection(&AddrFamilyInfo->NotifsTimerLock);

            AddrFamilyInfo->TimerLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize each change list in the change list table
        //

        for (i = 0; i < NUM_CHANGED_DEST_LISTS; i++)
        {
            //
            // Initialize the list of changed dests and lock
            //

            // Init the change list to an empty circular list

            ListPtr = &AddrFamilyInfo->ChangeLists[i].ChangedDestsHead;

            ListPtr->Next = ListPtr;
                       
            AddrFamilyInfo->ChangeLists[i].ChangedDestsTail = ListPtr;

            try
            {
                InitializeCriticalSection
                      (&AddrFamilyInfo->ChangeLists[i].ChangesListLock);

                AddrFamilyInfo->ChangeLists[i].ChangesLockInited = TRUE;

            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

        }

        if (Status != NO_ERROR)
        {
            break;
        }

        *NewAddrFamilyInfo = AddrFamilyInfo;

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

    DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, CREATION_REF);

    return Status;
}


DWORD
DestroyAddressFamily (
    IN      PADDRFAM_INFO                   AddrFamilyInfo
    )

/*++

Routine Description:

    Destroys an address family info in an RTM instance.
    Assumes that no registered entities exist with this 
    address family in this RTM instance when invoked.

    This function has been written such that it can be 
    called when an error occurs in CreateAddressFamily.

Arguments:

    AddrFamilyInfo  - Pointer to the Rib Info Structure.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function as it removes an address family from the list
    of address families on the instance. This lock is typically
    taken in DestroyEntity, but it can also happen that the lock
    is acquired in RtmRegisterEntity and an error occured in the
    CreateAddressFamily function.

--*/

{
    PINSTANCE_INFO       Instance;
    PSINGLE_LIST_ENTRY   ListPtr;
    UINT                 i;

    ASSERT(AddrFamilyInfo->ObjectHeader.RefCount == 0);

    ASSERT(AddrFamilyInfo->NumEntities == 0);

    ASSERT(IsListEmpty(&AddrFamilyInfo->DeregdEntities));

    //
    // Block until timers on address family are cleaned up
    //

    if (AddrFamilyInfo->RouteTimerQueue)
    {
        DeleteTimerQueueEx(AddrFamilyInfo->RouteTimerQueue, (HANDLE) -1);
    }

    if (AddrFamilyInfo->NotifTimerQueue)
    {
        DeleteTimerQueueEx(AddrFamilyInfo->NotifTimerQueue, (HANDLE) -1);
    }

    //
    // Free resources allocated to the change lists (locks ..)
    //

    // No more dests in change list as all entities are gone

    ASSERT(AddrFamilyInfo->NumChangedDests == 0);

    for (i = 0; i < NUM_CHANGED_DEST_LISTS; i++)
    {
        ListPtr = &AddrFamilyInfo->ChangeLists[i].ChangedDestsHead;

        ASSERT(ListPtr->Next == ListPtr);

        ASSERT(AddrFamilyInfo->ChangeLists[i].ChangedDestsTail == ListPtr);

        if (AddrFamilyInfo->ChangeLists[i].ChangesLockInited)
        {
            DeleteCriticalSection
                (&AddrFamilyInfo->ChangeLists[i].ChangesListLock);
        }
    }

    //
    // Free the change notification info and the guarding lock
    //

    ASSERT(AddrFamilyInfo->NumChangeNotifs == 0);

    if (AddrFamilyInfo->ChangeNotifsDir)
    {
        FreeMemory(AddrFamilyInfo->ChangeNotifsDir);
    }

    if (AddrFamilyInfo->NotifsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&AddrFamilyInfo->ChangeNotifsLock);
    }

    //
    // Free the lock guarding the notification timer
    //

    if (AddrFamilyInfo->TimerLockInited)
    {
        DeleteCriticalSection(&AddrFamilyInfo->NotifsTimerLock);
    }

    //
    // Free the route table and the route table lock
    //

    ASSERT(AddrFamilyInfo->NumRoutes == 0);

    //
    // Because some hold's are left out - this count
    // might not be equal to zero. Need to fix this
    // memory leak by cleaning up before this point
    //
    // ASSERT(AddrFamilyInfo->NumDests == 0);

    if (AddrFamilyInfo->RouteTable)
    {
        DestroyTable(AddrFamilyInfo->RouteTable);
    }

    if (AddrFamilyInfo->RoutesLockInited)
    {
        DELETE_READ_WRITE_LOCK(&AddrFamilyInfo->RouteTableLock);
    }

    //
    // Free Opaque Ptrs directory (if it is allocated)
    //

    if (AddrFamilyInfo->OpaquePtrsDir)
    {
        FreeMemory(AddrFamilyInfo->OpaquePtrsDir);
    }

    //
    // Remove the address family from owning instance
    //

    Instance = AddrFamilyInfo->Instance;

    RemoveEntryList(&AddrFamilyInfo->AFTableLE);
    Instance->NumAddrFamilies--;
    DEREFERENCE_INSTANCE(Instance, ADDR_FAMILY_REF);

    // Reclaim the instance if it has no addr familes

    if (Instance->NumAddrFamilies == 0)
    {
        DEREFERENCE_INSTANCE(Instance, CREATION_REF);
    }

#if DBG_HDL
    AddrFamilyInfo->ObjectHeader.TypeSign = ADDRESS_FAMILY_FREED;
#endif

    FreeObject(AddrFamilyInfo);

    return NO_ERROR;
}


DWORD
GetEntity (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      ULONGLONG                       EntityId,
    IN      BOOL                            ImplicitCreate,
    IN      PRTM_ENTITY_INFO                RtmEntityInfo    OPTIONAL,
    IN      BOOL                            ReserveOpaquePtr OPTIONAL,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods    OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback    OPTIONAL,
    OUT     PENTITY_INFO                   *EntityInfo
    )

/*++

Routine Description:

    Searches for an entity with a certain protocol id and
    protocol instance. If it is not found and ImplicitCreate
    is TRUE, then a new entity is created and added to the
    table of entities on address family.

Arguments:

    AddrFamilyInfo    - Address family block that we are seaching,

    EntityId          - Entity protocol id and protocol instance,

    ImplicitCreate    - Create a new entity if not found or not,

    For all others    - See corresponding parametes in CreateEntity

    EntityInfo        - The entity info is returned in this param.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function. If ImplicitCreate is FALSE, a read lock would
    do, but if it is TRUE then a write lock should be held as we
    would need it to insert a new entity into the entities list.

--*/

{
    PLIST_ENTRY    Entities;
    PENTITY_INFO   Entity;
    PLIST_ENTRY    r;
    DWORD          Status;

    Entities = &AddrFamilyInfo->EntityTable[EntityId % ENTITY_TABLE_SIZE];

#if WRN
    Entity = NULL;
#endif

    do
    {
        // Search for an entity with the input Entity Id
        for (r = Entities->Flink; r != Entities; r = r->Flink)
        {
            Entity = CONTAINING_RECORD(r, ENTITY_INFO, EntityTableLE);
            
            if (Entity->EntityId.EntityId >= EntityId)
            {
                break;
            }      
        }

        if ((r != Entities) && (Entity->EntityId.EntityId == EntityId))
        {
            Status = ERROR_ALREADY_EXISTS;
            break;
        }

        // We did not find an entity - create a new one ?
        if (!ImplicitCreate)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        // Create a new entity with all the input RTM parameters

        Status = CreateEntity(AddrFamilyInfo,
                              RtmEntityInfo,
                              ReserveOpaquePtr,
                              ExportMethods,
                              EventCallback,
                              &Entity);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Inform all existing entities of this new entity
        //

        InformEntitiesOfEvent(AddrFamilyInfo->EntityTable,
                              RTM_ENTITY_REGISTERED,
                              Entity);

        // Insert to keep the list sorted Entity Id Order
        InsertTailList(r, &Entity->EntityTableLE);

        *EntityInfo = Entity;
    }
    while (FALSE);

    return Status;
}


DWORD
CreateEntity (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      PRTM_ENTITY_INFO                EntityInfo,
    IN      BOOL                            ReserveOpaquePtr,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    OUT     PENTITY_INFO                   *NewEntity
    )

/*++

Routine Description:

    Creates a new entity info structure and initializes it.

Arguments:

    AddrFamilyInfo    - Address Family the entity is registering with,

    EntityInfo        - Information for the entity being created,

    ReserveOpaquePtr  - Reserve a ptr in each destination or not,

    ExportMethods     - List of methods exported by this entity,

    EventCallback     - Callback invoked to inform of certain events
                        like entity registrations, de-registrations,

    NewEntity         - Pointer to the new Entity Info structure 
                        will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO  Entity;
    UINT          NumMethods, i;
    DWORD         Status;

    *NewEntity = NULL;

    //
    // Allocate and initialize a new entity info structure
    //

    NumMethods = ExportMethods ? ExportMethods->NumMethods : 0;

    Entity = (PENTITY_INFO) AllocNZeroObject(
                                sizeof(ENTITY_INFO) +
                                (NumMethods ? (NumMethods - 1) : 0 ) *
                                sizeof(RTM_ENTITY_EXPORT_METHOD));

    if (Entity == NULL)
    {
        if (AddrFamilyInfo->NumEntities == 0)
        {
            DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, CREATION_REF);
        }

        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    do
    {
#if DBG_HDL
        Entity->ObjectHeader.TypeSign = ENTITY_ALLOC;
#endif
        INITIALIZE_ENTITY_REFERENCE(Entity, CREATION_REF);

        Entity->EntityId = EntityInfo->EntityId;

        Entity->OwningAddrFamily = AddrFamilyInfo;
        REFERENCE_ADDR_FAMILY(AddrFamilyInfo, ENTITY_REF);

        //
        // Linking the entity to its owning address family is
        // done by caller,but pretend that it is already done
        //

        AddrFamilyInfo->NumEntities++;

        InitializeListHead(&Entity->EntityTableLE);

        //
        // Allocate an opaque pointer index if asked for
        //

        Entity->OpaquePtrOffset = -1;

        if (ReserveOpaquePtr)
        {
            if (AddrFamilyInfo->NumOpaquePtrs >= AddrFamilyInfo->MaxOpaquePtrs)
            {
                Status = ERROR_NO_SYSTEM_RESOURCES;
                break;
            }

            for (i = 0; i < AddrFamilyInfo->MaxOpaquePtrs; i++)
            {
                if (AddrFamilyInfo->OpaquePtrsDir[i] == NULL)
                {
                    break;
                }
            }

            AddrFamilyInfo->OpaquePtrsDir[i] = (PVOID) Entity;

            AddrFamilyInfo->NumOpaquePtrs++;

            Entity->OpaquePtrOffset = i;

            ASSERT(Entity->OpaquePtrOffset != -1);
        }

        //
        // Initialize lock guarding entity-specific route lists
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Entity->RouteListsLock);

            Entity->ListsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize the list of open handles and corresponding lock
        //

        try
        {
            InitializeCriticalSection(&Entity->OpenHandlesLock);

            Entity->HandlesLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        InitializeListHead(&Entity->OpenHandles);

        //
        // Initialize the next hop table and the next hop table lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Entity->NextHopTableLock);

            Entity->NextHopsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Status = CreateTable(AddrFamilyInfo->AddressSize,
                             &Entity->NextHopTable);

        if (Status != NO_ERROR)
        {
            break;
        }

        Entity->NumNextHops = 0;

        //
        // Initialize entity methods and the entity methods lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Entity->EntityMethodsLock);

            Entity->MethodsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        Entity->EventCallback = EventCallback;

        Entity->EntityMethods.NumMethods = NumMethods;

        if (ExportMethods)
        {
            CopyMemory(Entity->EntityMethods.Methods,
                       ExportMethods->Methods,
                       NumMethods * sizeof(RTM_ENTITY_EXPORT_METHOD));
        }

        *NewEntity = Entity;

        return NO_ERROR;
    }
    while(FALSE);

    //
    // Something failed - undo work done and return status
    //

    DEREFERENCE_ENTITY(Entity, CREATION_REF);

    return Status;
}


DWORD
DestroyEntity (
    IN      PENTITY_INFO                    Entity
    )

/*++

Routine Description:

    Destroys an existing entity info structure. Frees 
    all associated resources before de-allocation.

    This function has been written such that it can be
    called when an error occurs during CreateEntity.

Arguments:

    EntityInfo - Pointer to the Entity Info Structure.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamilyInfo;

    ASSERT(Entity->ObjectHeader.RefCount == 0);

    //
    // Take globals registrations lock while cleaning up
    //

    ACQUIRE_INSTANCES_WRITE_LOCK();

    //
    // Free lock used to block exported entity methods
    //

    if (Entity->MethodsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Entity->EntityMethodsLock);
    }

    //
    // Free the next hop table and the lock guarding it
    //

    ASSERT(Entity->NumNextHops == 0);

    if (Entity->NextHopTable)
    {
        DestroyTable(Entity->NextHopTable);
    }

    if (Entity->NextHopsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Entity->NextHopTableLock);
    }

    if (Entity->HandlesLockInited)
    {
        // There should not be any handles opened by entity

        ASSERT(IsListEmpty(&Entity->OpenHandles));

        DeleteCriticalSection(&Entity->OpenHandlesLock);
    }

    //
    // Free lock used to perform route list operations
    //

    if (Entity->ListsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Entity->RouteListsLock);
    }

    //
    // Free the opaque ptr index in the address family
    //

    AddrFamilyInfo = Entity->OwningAddrFamily;

    if (Entity->OpaquePtrOffset != -1)
    {
        AddrFamilyInfo->OpaquePtrsDir[Entity->OpaquePtrOffset] = NULL;

        AddrFamilyInfo->NumOpaquePtrs--;
    }

#if DBG_REF_BLOCKING

    //
    // Signal event on entity to unblock de-register
    // The evnt will be freed in RtmDeregisterEntity
    //

    if (Entity->BlockingEvent)
    {
        SetEvent(Entity->BlockingEvent);
    }

#endif
  
    //
    // Remove the entity from the owning address family
    //

    RemoveEntryList(&Entity->EntityTableLE);
    AddrFamilyInfo->NumEntities--;
    DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, ENTITY_REF);

    // Reclaim the addr family if it has no entities

    if (AddrFamilyInfo->NumEntities == 0)
    {
        DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, CREATION_REF);
    }

#if DBG_HDL
    Entity->ObjectHeader.TypeSign = ENTITY_FREED;
#endif

    FreeObject(Entity);

    RELEASE_INSTANCES_WRITE_LOCK();

    return NO_ERROR;
}


VOID
InformEntitiesOfEvent (
    IN      PLIST_ENTRY                     EntityTable,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PENTITY_INFO                    EntityThis
    )

/*++

Routine Description:

    Informs all entities in the entity table that a certain
    event has occured - like a new entity registered, or an
    existing entity de-registered.

Arguments:

    EntityTable - Pointer to the hash table of entities,

    EventType   - Type of the event being notified about,

    EntityThis  - Entity that caused the event to occur.

Return Value:

    None

Locks:

    The instances lock has to be held in either write or
    read mode as we are traversing the list of entities
    on the address family.

--*/

{
    RTM_ENTITY_HANDLE  EntityHandle;
    PADDRFAM_INFO      AddrFamInfo;
    RTM_ENTITY_INFO    EntityInfo;
    PENTITY_INFO       Entity;
    UINT               i;
    PLIST_ENTRY        Entities, q;

    //
    // Prepare arguments for the Event Callbacks in loop
    //

    AddrFamInfo = EntityThis->OwningAddrFamily;

    EntityInfo.RtmInstanceId = AddrFamInfo->Instance->RtmInstanceId;
    EntityInfo.AddressFamily = AddrFamInfo->AddressFamily;

    EntityInfo.EntityId = EntityThis->EntityId;

    EntityHandle = MAKE_HANDLE_FROM_POINTER(EntityThis);


    //
    // For each entity in table, call its event callback
    //

    for (i = 0; i < ENTITY_TABLE_SIZE; i++)
    {
        Entities = &EntityTable[i];
          
        for (q = Entities->Flink; q != Entities; q = q->Flink)
        {
            Entity = CONTAINING_RECORD(q, ENTITY_INFO, EntityTableLE);

            //
            // Inform the current entity of the event
            // if it has an event handler registered
            //

            if (Entity->EventCallback)
            {
                //
                // This callback should not call any of the registration
                // APIs as it might result in corrupting the entity list
                //
                
                Entity->EventCallback(MAKE_HANDLE_FROM_POINTER(Entity),
                                      EventType,
                                      EntityHandle,
                                      &EntityInfo);
            }
        }
    }
}


VOID
CleanupAfterDeregister (
    IN      PENTITY_INFO                    Entity
    )

/*++

Routine Description:

    Cleans up all enums, notifications and entity lists
    opened by an entity. Also deletes all nexthops and
    routes owned by this entity. Assumes that the entity
    is not making any other operations in parallel.

Arguments:

    Entity     - Pointer to the entity registration info.

Return Value:

    None

--*/

{
    RTM_ENTITY_HANDLE RtmRegHandle;
    PADDRFAM_INFO     AddrFamInfo;
    PHANDLE           Handles;
    RTM_ENUM_HANDLE   EnumHandle;
    UINT              NumHandles, i;
    DWORD             ChangeFlags;
    DWORD             Status;

    AddrFamInfo = Entity->OwningAddrFamily;

    RtmRegHandle = MAKE_HANDLE_FROM_POINTER(Entity);

#if DBG_HDL

    // ACQUIRE_OPEN_HANDLES_LOCK(Entity);

    while (!IsListEmpty(&Entity->OpenHandles))
    {
        POPEN_HEADER      OpenHeader;
        HANDLE            OpenHandle;
        PLIST_ENTRY       p;

        p = RemoveHeadList(&Entity->OpenHandles);

        OpenHeader = CONTAINING_RECORD(p, OPEN_HEADER, HandlesLE);

        OpenHandle = MAKE_HANDLE_FROM_POINTER(OpenHeader);

        switch (OpenHeader->HandleType)
        {
        case DEST_ENUM_TYPE:
        case ROUTE_ENUM_TYPE:
        case NEXTHOP_ENUM_TYPE:
        case LIST_ENUM_TYPE:

            Status = RtmDeleteEnumHandle(RtmRegHandle, OpenHandle);
            break;

        case NOTIFY_TYPE:

            Status = RtmDeregisterFromChangeNotification(RtmRegHandle,
                                                         OpenHandle);
            break;

        case ROUTE_LIST_TYPE:
                
            Status = RtmDeleteRouteList(RtmRegHandle, OpenHandle);
            break;

        default:

            Status = ERROR_INVALID_DATA;
        }

        ASSERT(Status == NO_ERROR);
    }

    // RELEASE_OPEN_HANDLES_LOCK(Entity);

#endif // DBG_HDL

    Handles = AllocMemory(AddrFamInfo->MaxHandlesInEnum * sizeof(HANDLE));
    if ( Handles == NULL )
    {
        return;
    }

    //
    // Delete all routes created by this entity regn
    //

    Status = RtmCreateRouteEnum(RtmRegHandle,
                                NULL,
                                RTM_VIEW_MASK_ANY,
                                RTM_ENUM_OWN_ROUTES,
                                NULL,
                                0,
                                NULL,
                                0,
                                &EnumHandle);

    while (Status == NO_ERROR)
    {
        NumHandles = AddrFamInfo->MaxHandlesInEnum;

        Status = RtmGetEnumRoutes(RtmRegHandle,
                                  EnumHandle,
                                  &NumHandles,
                                  Handles);

        for (i = 0; i < NumHandles; i++)
        {
            Status = RtmDeleteRouteToDest(RtmRegHandle,
                                          Handles[i],
                                          &ChangeFlags);
            ASSERT(Status == NO_ERROR);
        }
    }

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    ASSERT(Status == NO_ERROR);


    //
    // Delete all nexthops created by this entity regn
    //

    Status = RtmCreateNextHopEnum(RtmRegHandle,
                                  0,
                                  NULL,
                                  &EnumHandle);

    while (Status == NO_ERROR) 
    {
        NumHandles = AddrFamInfo->MaxHandlesInEnum;

        Status = RtmGetEnumNextHops(RtmRegHandle,
                                    EnumHandle,
                                    &NumHandles,
                                    Handles);
        
        for (i = 0; i < NumHandles; i++)
        {
            Status = RtmDeleteNextHop(RtmRegHandle,
                                      Handles[i],
                                      NULL);

            ASSERT(Status == NO_ERROR);
        }
    }

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    ASSERT(Status == NO_ERROR);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmquer.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmquer.c

Abstract:

    Contains routines for querying the 
    best route information in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmGetExactMatchDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Queries the route table for a destination with a particular
    network address.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestAddress       - Network Address of the destination we want,

    Protocol Id       - Protocol Id that determines the best route
                        information returned in 'DestInfo' param,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    DestInfo          - Information related to this dest is returned
                        in this structure for all the views requested.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE DestData;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Search route table using the dest address
    // 

    Status = SearchInTable(AddrFamInfo->RouteTable,
                           DestAddress->NumBits,
                           DestAddress->AddrBits,
                           NULL,
                           &DestData);

    if (SUCCESS(Status))
    {
        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        //
        // Check if the destination is in any of the input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) || 
            (Dest->BelongsToViews & TargetViews))
        {
            //
            // Get the destination info from the dest
            //

            GetDestInfo(Entity, Dest, ProtocolId, TargetViews, DestInfo);

            Status = NO_ERROR;
        }
        else
        {
            Status = ERROR_NOT_FOUND;
        }
    }

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmGetMostSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Queries the route table for a destination with the best
    (longest) match of a particular network address.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestAddress       - Network Address that we are searching for,

    Protocol Id       - Protocol Id that determines the best route
                        information returned in 'DestInfo' param,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    DestInfo          - Information related to this dest is returned
                        in this structure for all the views requested.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE DestData;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    Status = ERROR_NOT_FOUND;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Search the table for the best match in tree
    //

    SearchInTable(AddrFamInfo->RouteTable,
                  DestAddress->NumBits,
                  DestAddress->AddrBits,
                  NULL,
                  &DestData);

    while (DestData)
    {
        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        //
        // Check if the destination is in any of the input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) ||
            (Dest->BelongsToViews & TargetViews))
        {
            //
            // Get the destination info from the dest
            //

            GetDestInfo(Entity, Dest, ProtocolId, TargetViews, DestInfo);

            Status = NO_ERROR;

            break;
        }

        //
        // Get the next best prefix, and see if it is in view
        //

        NextMatchInTable(AddrFamInfo->RouteTable,
                         DestData,
                         &DestData);
    }

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmGetLessSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Queries the route table for a destination with the next best
    match (longest) prefix. (for a destination given by handle).

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - Destination whose next best match we want,

    Protocol Id       - Protocol Id that determines the best route
                        information returned in 'DestInfo' param,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    DestInfo          - Information related to this dest is returned
                        in this structure for all the views requested.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE DestData;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);

    DestData = &Dest->LookupLinkage;

    Status = ERROR_NOT_FOUND;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Go up the prefix tree till you have a dest in views
    //

    do
    {
        //
        // Get the next best prefix, and see if it is in views
        //

        NextMatchInTable(AddrFamInfo->RouteTable,
                         DestData,
                         &DestData);

        if (DestData == NULL)
        {
            break;
        }

        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        //
        // Check if the destination is in any of the input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) ||
            (Dest->BelongsToViews & TargetViews))
        {
            //
            // Get the destination info from the dest
            //

            GetDestInfo(Entity, Dest, ProtocolId, TargetViews, DestInfo);

            Status = NO_ERROR;

            break;
        }
    }
    while (TRUE);

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmGetExactMatchRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN OUT  PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           InterfaceIndex,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_ROUTE_HANDLE               RouteHandle
    )

/*++

Routine Description:

    Queries the route table for a route that matches certain
    criteria - a network address, preference and/or nexthop.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestAddress       - Network Address of the route we want,

    MatchingFlags     - Flags that tell how to match a route,
    
    RouteInfo         - Criteria that we need to match against,

    IntefaceIndex     - Interface on which route should be present
                        in case RTM_MATCH_INTERFACE is specified,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    RouteHandle       - Route handle (if an exact match exists),

    RouteInfo         - Information related to this route is retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PROUTE_INFO     Route;
    PLOOKUP_LINKAGE DestData;
    PLIST_ENTRY     p;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Search route table using the dest address
    // 

    Status = SearchInTable(AddrFamInfo->RouteTable,
                           DestAddress->NumBits,
                           DestAddress->AddrBits,
                           NULL,
                           &DestData);

    if (SUCCESS(Status))
    {
        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        Status = ERROR_NOT_FOUND;
    
        //
        // Check if the destination matches any input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) ||
            (Dest->BelongsToViews & TargetViews))
        {
#if DBG
            REFERENCE_DEST(Dest, TEMP_USE_REF);
#endif

            // 
            // At this point, we have the dest. So take the
            // dest lock, and release the route table lock.
            //

            ACQUIRE_DEST_READ_LOCK(Dest);

            RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

            //
            // Search routes on dest for a matching route
            //
            
            for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p= p->Flink)
            {
                Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                // Check if this route matches any input views

                if ((TargetViews != RTM_VIEW_MASK_ANY) &&
                    (Route->RouteInfo.BelongsToViews & TargetViews) == 0)
                {
                    continue;
                }

                // Check if this route matches input criteria

                if (MatchingFlags && 
                    !MatchRouteWithCriteria(Route, 
                                            MatchingFlags, 
                                            RouteInfo,
                                            InterfaceIndex))
                    {
                        continue;
                    }

                //
                // Found a matching route - copy the route info
                //

                REFERENCE_ROUTE(Route, HANDLE_REF);

                *RouteHandle = MAKE_HANDLE_FROM_POINTER(Route);


                if (ARGUMENT_PRESENT(RouteInfo))
                {
                    GetRouteInfo(Dest, Route, RouteInfo);
                }

                Status = NO_ERROR;

                break;
            }

            RELEASE_DEST_READ_LOCK(Dest);
#if DBG
            DEREFERENCE_DEST(Dest, TEMP_USE_REF);
#endif
            return Status;
        }
    }
    
    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmIsBestRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_VIEW_SET                   BestInViews
    )

/*++

Routine Description:

    Gives the set of views in which the route is the best route
    to its destination.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route whose info we want, 

    BestInViews       - Views that route is the best one in is retd.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PROUTE_INFO     Route;
    UINT            i;

    *BestInViews = 0;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    //
    // Set the bit in mask if the route is the best in the corr view
    //

    ACQUIRE_DEST_READ_LOCK(Dest);

    for (i = 0; i < Entity->OwningAddrFamily->NumberOfViews; i++)
    {
        if (Dest->ViewInfo[i].BestRoute == Route)
        {
            *BestInViews |= 
                VIEW_MASK(Entity->OwningAddrFamily->ViewIdFromIndex[i]);
        }
    }

    RELEASE_DEST_READ_LOCK(Dest);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmregn.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmregn.h

Abstract:
    Private defns relating to the registration
    and de-registration of entities with RTMv2

Author:
    Chaitanya Kodeboyina (chaitk) 17-Aug-1998

Revision History:

--*/


#ifndef __ROUTING_RTMREGN_H__
#define __ROUTING_RTMREGN_H__

//
// Forward declarations for various Info Blocks
//
typedef struct _ADDRFAM_INFO  ADDRFAM_INFO;

//
// Info related to an RTM instance
// 

typedef struct _INSTANCE_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    USHORT            RtmInstanceId;    // Unique ID for this RTM instance

    LIST_ENTRY        InstTableLE;      // Linkage on global table of instances

    UINT              NumAddrFamilies;  // Address Family Specific Info Blocks
    LIST_ENTRY        AddrFamilyTable;  // on this instance (like IPv4 n IPv6)
} 
INSTANCE_INFO, *PINSTANCE_INFO;


//
// Info related to an address family in an RTM instance
//

#define ENTITY_TABLE_SIZE              16

typedef struct _ADDRFAM_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    USHORT            AddressFamily;    // Address Family for this info block

    UINT              AddressSize;      // Address size in this address family

    PINSTANCE_INFO    Instance;         // Back pointer to the owning instance

    LIST_ENTRY        AFTableLE;        // Linkage on table of AFs on instance

    RTM_VIEW_SET      ViewsSupported;   // Views supported by this addr family

    UINT              NumberOfViews;    // Num. of views supported by this AF

    RTM_VIEW_ID       ViewIdFromIndex[RTM_MAX_VIEWS];
                                        // View Id -> Its Index in Dest mapping

    RTM_VIEW_ID       ViewIndexFromId[RTM_MAX_VIEWS];  
                                        // View Index in Dest -> Its Id mapping

    UINT              MaxHandlesInEnum; // Max. number of handles returned in
                                        // any RTMv2 call that returns handles 

    UINT              MaxNextHopsInRoute;// Max. number of equal cost next-hops

    UINT              MaxOpaquePtrs;    //
    UINT              NumOpaquePtrs;    // Directory of opaque info ptr offsets
    PVOID            *OpaquePtrsDir;    //

    UINT              NumEntities;      // Table of all the registered entities
    LIST_ENTRY        EntityTable[ENTITY_TABLE_SIZE];

    LIST_ENTRY        DeregdEntities;   // Table of all de-registered entities

    READ_WRITE_LOCK   RouteTableLock;   // Protects the route table of routes
    BOOL              RoutesLockInited; // Was the above lock initialized ?

    PVOID             RouteTable;       // Table of dests and routes on this AF
    LONG              NumDests;         // Number of dests in the route table
    LONG              NumRoutes;        // Number of routes in the route table
                                        // [Use interlocked ops as no locking]

    HANDLE            RouteTimerQueue;  // List of route timers being used

    HANDLE            NotifTimerQueue;  // List of notification timers used

    READ_WRITE_LOCK   ChangeNotifsLock; // Protects change notification info
    BOOL              NotifsLockInited; // Was the above lock initialized ?

    UINT              MaxChangeNotifs;  //
    UINT              NumChangeNotifs;  // Directory of change notifications
    PVOID            *ChangeNotifsDir;  //

    DWORD             ChangeNotifRegns; // Mask of regd change notifications

    DWORD             CNsForMarkedDests;// Mask of CNs requesing changes on 
                                        // only destinations marked by them

    DWORD             CNsForView[RTM_MAX_VIEWS];
                                        // CNs interested in a certain view

    DWORD             CNsForChangeType[RTM_NUM_CHANGE_TYPES];
                                        // CNs interested in a change type

    CRITICAL_SECTION  NotifsTimerLock;  // Lock the protects ops on CN timer
    BOOL              TimerLockInited;  // Was the above lock initialized ?

    HANDLE            ChangeNotifTimer; // Timer used to process changes list

    LONG              NumChangedDests;  // Num of destinations on change list
                                        // [Use interlocked ops as no locking]
    struct
    {
        LONG               ChangesListInUse;  // Is this change list in use ?
        CRITICAL_SECTION   ChangesListLock;   // Protects list of changed dests
        BOOL               ChangesLockInited; // Was above lock initialized ?
        SINGLE_LIST_ENTRY  ChangedDestsHead;  // Head of list of changed dests
        PSINGLE_LIST_ENTRY ChangedDestsTail;  // Pointer to tail of above list
    } 
    ChangeLists[NUM_CHANGED_DEST_LISTS]; // Multiple chng lists for concurrency
} 
ADDRFAM_INFO, *PADDRFAM_INFO;


//
// Entity Registration Info Block
//
typedef struct _ENTITY_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    RTM_ENTITY_ID     EntityId;         // Entity Proto ID and Instance
                                        // that make a unique Entity Id
  
    PADDRFAM_INFO     OwningAddrFamily; // Back pointer to the owning AF

    LIST_ENTRY        EntityTableLE;    // Linkage on AF's table of entities

    HANDLE            BlockingEvent;    // Event used to block ops on entity

    ULONG             State;            // See ENTITY_STATE_* values below

    INT               OpaquePtrOffset;  // Offset of reserved opaque ptr or -1

    READ_WRITE_LOCK   RouteListsLock;    // Protects all route lists of entity
    BOOL              ListsLockInited;   // Was the above lock initialized ?

    CRITICAL_SECTION  OpenHandlesLock;  // Protects list of enums and notifs
    BOOL              HandlesLockInited;// Was the above lock initialized ?
    LIST_ENTRY        OpenHandles;      // List of all enums & change notifs

    READ_WRITE_LOCK   NextHopTableLock; // Protects the next hop table.
    BOOL              NextHopsLockInited;// Was the above lock initialized ?
    PVOID             NextHopTable;     // Table of next-hops that all
                                        // routes of this entity share
    ULONG             NumNextHops;      // Number of next-hops in this table

    READ_WRITE_LOCK   EntityMethodsLock;// Used to block all methods
                                        // on owned dests and routes
    BOOL              MethodsLockInited;// Was above lock initialized ?

    RTM_EVENT_CALLBACK EventCallback;   // Entity Register/De-register
                                        // event inform callback

    RTM_ENTITY_EXPORT_METHODS
                      EntityMethods;    // Method set exported to get
                                        // entity specific information
}
ENTITY_INFO, *PENTITY_INFO;

#define ENTITY_STATE_REGISTERED         0x00000000
#define ENTITY_STATE_DEREGISTERED       0x00000001

//
// Common Header for all open blocks
// ( pointed to by active handles )
//

typedef struct _OPEN_HEADER
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    UCHAR             HandleType;       // Type of handle for this open block

#if DBG_HDL
    LIST_ENTRY        HandlesLE;        // On list of handles opened by entity
#endif
}
OPEN_HEADER, *POPEN_HEADER;


//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_ROUTE_TABLE_READ_LOCK(AF)                    \
    ACQUIRE_READ_LOCK(&AF->RouteTableLock)

#define RELEASE_ROUTE_TABLE_READ_LOCK(AF)                    \
    RELEASE_READ_LOCK(&AF->RouteTableLock)

#define ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AF)                   \
    ACQUIRE_WRITE_LOCK(&AF->RouteTableLock)

#define RELEASE_ROUTE_TABLE_WRITE_LOCK(AF)                   \
    RELEASE_WRITE_LOCK(&AF->RouteTableLock)


#define ACQUIRE_NOTIFICATIONS_READ_LOCK(AF)                  \
    ACQUIRE_READ_LOCK(&AF->ChangeNotifsLock);

#define RELEASE_NOTIFICATIONS_READ_LOCK(AF)                  \
    RELEASE_READ_LOCK(&AF->ChangeNotifsLock);

#define ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AF)                 \
    ACQUIRE_WRITE_LOCK(&AF->ChangeNotifsLock);

#define RELEASE_NOTIFICATIONS_WRITE_LOCK(AF)                 \
    RELEASE_WRITE_LOCK(&AF->ChangeNotifsLock);


#define ACQUIRE_NOTIF_TIMER_LOCK(AF)                         \
    ACQUIRE_LOCK(&AF->NotifsTimerLock)

#define RELEASE_NOTIF_TIMER_LOCK(AF)                         \
    RELEASE_LOCK(&AF->NotifsTimerLock)


#define ACQUIRE_CHANGED_DESTS_LIST_LOCK(AF, ListN)           \
    ACQUIRE_LOCK(&AF->ChangeLists[ListN].ChangesListLock)

#define RELEASE_CHANGED_DESTS_LIST_LOCK(AF, ListN)           \
    RELEASE_LOCK(&AF->ChangeLists[ListN].ChangesListLock)


#define ACQUIRE_ROUTE_LISTS_READ_LOCK(Entity)                \
    ACQUIRE_READ_LOCK(&Entity->RouteListsLock)

#define RELEASE_ROUTE_LISTS_READ_LOCK(Entity)                \
    RELEASE_READ_LOCK(&Entity->RouteListsLock)

#define ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity)               \
    ACQUIRE_WRITE_LOCK(&Entity->RouteListsLock)

#define RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity)               \
    RELEASE_WRITE_LOCK(&Entity->RouteListsLock)


#define ACQUIRE_OPEN_HANDLES_LOCK(Entity)                    \
    ACQUIRE_LOCK(&Entity->OpenHandlesLock)

#define RELEASE_OPEN_HANDLES_LOCK(Entity)                    \
    RELEASE_LOCK(&Entity->OpenHandlesLock)


#define ACQUIRE_NHOP_TABLE_READ_LOCK(Entity)                 \
    ACQUIRE_READ_LOCK(&Entity->NextHopTableLock)

#define RELEASE_NHOP_TABLE_READ_LOCK(Entity)                 \
    RELEASE_READ_LOCK(&Entity->NextHopTableLock)

#define ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity)                \
    ACQUIRE_WRITE_LOCK(&Entity->NextHopTableLock)

#define RELEASE_NHOP_TABLE_WRITE_LOCK(Entity)                \
    RELEASE_WRITE_LOCK(&Entity->NextHopTableLock)


#define ACQUIRE_ENTITY_METHODS_READ_LOCK(Entity)             \
    ACQUIRE_READ_LOCK(&Entity->NextHopTableLock)

#define RELEASE_ENTITY_METHODS_READ_LOCK(Entity)             \
    RELEASE_READ_LOCK(&Entity->NextHopTableLock)

#define ACQUIRE_ENTITY_METHODS_WRITE_LOCK(Entity)            \
    ACQUIRE_WRITE_LOCK(&Entity->NextHopTableLock)

#define RELEASE_ENTITY_METHODS_WRITE_LOCK(Entity)            \
    RELEASE_WRITE_LOCK(&Entity->NextHopTableLock)


//
// Registration Helper Functions
//

DWORD
CreateInstance (
    IN      USHORT                          InstanceId,
    OUT     PINSTANCE_INFO                 *NewInstance
    );

DWORD
GetInstance (
    IN      USHORT                          RtmInstanceId,
    IN      BOOL                            ImplicitCreate,
    OUT     PINSTANCE_INFO                 *RtmInstance
    );

DWORD
DestroyInstance (
    IN      PINSTANCE_INFO                  Instance
    );


DWORD
CreateAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    OUT     PADDRFAM_INFO                  *NewAddrFamilyInfo
    );

DWORD
GetAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    IN      BOOL                            ImplicitCreate,
    OUT     PADDRFAM_INFO                  *AddrFamilyInfo
    );

DWORD
DestroyAddressFamily (
    IN      PADDRFAM_INFO                   AddrFamilyInfo
    );


DWORD
CreateEntity (
    IN      PADDRFAM_INFO                   AddressFamily,
    IN      PRTM_ENTITY_INFO                EntityInfo,
    IN      BOOL                            ReserveOpaquePtr,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    OUT     PENTITY_INFO                   *NewEntity
    );

DWORD
GetEntity (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      ULONGLONG                       EntityId,
    IN      BOOL                            ImplicitCreate,
    IN      PRTM_ENTITY_INFO                RtmEntityInfo    OPTIONAL,
    IN      BOOL                            ReserveOpaquePtr OPTIONAL,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods    OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback    OPTIONAL,
    OUT     PENTITY_INFO                   *EntityInfo
    );

DWORD
DestroyEntity (
    IN      PENTITY_INFO                    Entity
    );

VOID
InformEntitiesOfEvent (
    IN      PLIST_ENTRY                     EntityTable,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PENTITY_INFO                    EntityThis
    );

VOID
CleanupAfterDeregister (
    IN      PENTITY_INFO                    Entity
    );

#endif //__ROUTING_RTMREGN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmmetd.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmetd.c

Abstract:

    Contains routines that deals with invocation
    of methods that entities export to other
    entities for the purpose of interpreting
    entity specific data.

Author:

    Chaitanya Kodeboyina (chaitk)  22-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmGetEntityMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN OUT  PUINT                           NumMethods,
    OUT     PRTM_ENTITY_EXPORT_METHOD       ExptMethods
    )

/*++

Routine Description:

    Retrieves the set of methods exported by a given entity.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityHandle      - RTM handle for entity whose methods we want,

    NumMethods        - Number of methods that can be filled
                        is passed in, and number of methods
                        exported by this entity is returned,

    ExptMethods       - Set of methods requested by the caller.

Return Value:

    Status of the operation

--*/

{
    PRTM_ENTITY_EXPORT_METHODS EntityMethods;
    PENTITY_INFO     Entity;
    DWORD            Status;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ENTITY_HANDLE(EntityHandle, &Entity);

    EntityMethods = &Entity->EntityMethods;


    //
    // Does the caller just need number of methods ?
    //

    if (*NumMethods == 0)
    {
        *NumMethods = EntityMethods->NumMethods;

        return NO_ERROR;
    }


    //
    // Check if we have space to copy all methods
    //

    if (EntityMethods->NumMethods > *NumMethods)
    {
        Status = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        Status = NO_ERROR;

        *NumMethods = EntityMethods->NumMethods;
    }

      
    //
    // Copy as many methods as u can fit in output
    //

    ASSERT(ExptMethods != NULL);

    CopyMemory(ExptMethods,
               EntityMethods->Methods, 
               *NumMethods * sizeof(RTM_ENTITY_EXPORT_METHOD));

    *NumMethods = EntityMethods->NumMethods;

    return Status;
}


DWORD
WINAPI
RtmInvokeMethod (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN      PRTM_ENTITY_METHOD_INPUT        Input,
    IN OUT  PUINT                           OutputSize,
    OUT     PRTM_ENTITY_METHOD_OUTPUT       Output
    )

/*++

Routine Description:

    Invokes a method exported by another entity

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityHandle      - Handle for entity whose method we are invoking,

    Input             - Input buffer with the following information
                          - Methods to be invoked,
                          - Common Input buffer to all these methods,

    OutputSize        - Size of the output buffer is passed in, and
                        the number of bytes filled in output is retd,

    Output            - Output buffer that is filled in the format of
                        a series of (Method Id, Corr. Output) tuples


Return Value:

    Status of the operation

--*/

{
    PRTM_ENTITY_EXPORT_METHODS EntityMethods;
    PENTITY_INFO     Entity;
    DWORD            MethodsCalled;
    DWORD            MethodsLeft;
    UINT             OutputHdrSize;
    UINT             OutBytes;
    UINT             BytesTotal;
    UINT             BytesLeft;
    UINT             i;

    BytesTotal = BytesLeft = *OutputSize;

    *OutputSize = 0;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Validate the entity and target handles passed in
    //

    VALIDATE_ENTITY_HANDLE(EntityHandle, &Entity);

    //
    // Call each method in 'methods to be called' mask.
    //

    MethodsCalled = MethodsLeft = Input->MethodType;

    ACQUIRE_ENTITY_METHODS_READ_LOCK(Entity);

    if (Entity->State == ENTITY_STATE_DEREGISTERED)
    {
        RELEASE_ENTITY_METHODS_READ_LOCK(Entity);
        
        return ERROR_INVALID_HANDLE;
    }

    OutputHdrSize = FIELD_OFFSET(RTM_ENTITY_METHOD_OUTPUT, OutputData);

    EntityMethods = &Entity->EntityMethods;

    for (i = 0; (i < EntityMethods->NumMethods) && (MethodsLeft); i++)
    {
        //
        // Do we have bytes left for next method's output ?
        //

        if (BytesLeft < OutputHdrSize)
        {
            break;
        }

        //
        // If next method in list, prepare input and invoke
        //

        if (MethodsLeft & 0x01)
        {
            Input->MethodType = Output->MethodType = (1 << i);

            Output->OutputSize = BytesLeft - OutputHdrSize;

            //
            // Initialize the output params of this method
            //

            Output->OutputSize = 0;

            Output->MethodStatus = ERROR_NOT_SUPPORTED;

            //
            // If method supported, invoke with input/output
            //

            if (EntityMethods->Methods[i])
            {
                EntityMethods->Methods[i](RtmRegHandle, 
                                          EntityHandle,
                                          Input, 
                                          Output);
            }

            OutBytes = Output->OutputSize + OutputHdrSize;
                  
            Output = (PRTM_ENTITY_METHOD_OUTPUT) (OutBytes + (PUCHAR) Output);
              
            BytesLeft -= OutBytes;
        }

        MethodsLeft >>= 1;
    }

    RELEASE_ENTITY_METHODS_READ_LOCK(Entity);

    Input->MethodType = MethodsCalled;

    *OutputSize = BytesTotal - BytesLeft;

    return NO_ERROR;
}


DWORD 
WINAPI
RtmBlockMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      HANDLE                          TargetHandle OPTIONAL,
    IN      UCHAR                           TargetType   OPTIONAL,
    IN      DWORD                           BlockingFlag
    )

/*++

Routine Description:

    Blocks or unblocks the execution of methods on the target
    handle or on all targets if the target handle is NULL.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    TargetHandle      - Destination, Route or NextHop Handle

    TargetType        - Type of the TargetHandle (DEST_TYPE, ...)

    BlockingFlag      - RTM_BLOCK_METHODS or RTM_RESUME_METHODS
                        to block, unblock method invocations resp.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    UNREFERENCED_PARAMETER(TargetType);
    UNREFERENCED_PARAMETER(TargetHandle);

#if DBG

    //
    // No method locks on the target used at present
    //

    if (ARGUMENT_PRESENT(TargetHandle))
    {
        PVOID            Target;

        VALIDATE_OBJECT_HANDLE(TargetHandle, TargetType, &Target);
    }

#endif


    if (BlockingFlag == RTM_BLOCK_METHODS)
    {
        ACQUIRE_ENTITY_METHODS_WRITE_LOCK(Entity);
    }
    else
    {
        RELEASE_ENTITY_METHODS_WRITE_LOCK(Entity);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmmgmt.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmgmt.c

Abstract:
    Routines used to perform various management
    functions on the Routing Table Manager v2.

Author:

    Chaitanya Kodeboyina (chaitk)   17-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#include "rtmmgmt.h"


DWORD
WINAPI
RtmGetInstances (
    IN OUT  PUINT                           NumInstances,
    OUT     PRTM_INSTANCE_INFO              InstanceInfos
    )

/*++

Routine Description:

    Enumerates all active RTM instances with their infos.

Arguments:

    NumInstances   - Num of Instance Info slots in the input
                     buffer is passed in, and the total number 
                     of active RTM instances is returned.

    RtmInstances   - Instance Infos that are active in RTMv2.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO Instance;
    PLIST_ENTRY    Instances, p;
    UINT           i, j;
    DWORD          Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmGetInstances");

    ACQUIRE_INSTANCES_READ_LOCK();

    //
    // Get next instance in table and copy info to output
    //

    for (i = j = 0; (i < INSTANCE_TABLE_SIZE) && (j < *NumInstances); i++)
    {
        Instances = &RtmGlobals.InstanceTable[i];
            
        for (p = Instances->Flink; p != Instances; p = p->Flink)
        {
            Instance = CONTAINING_RECORD(p, INSTANCE_INFO, InstTableLE);

            // Copy all relevant Instance information to output

            InstanceInfos[j].RtmInstanceId = Instance->RtmInstanceId;

            InstanceInfos[j].NumAddressFamilies = Instance->NumAddrFamilies;

            if (++j == *NumInstances)
            {
                break;
            }
        }
    }

    Status = (*NumInstances >= RtmGlobals.NumInstances)
                   ? NO_ERROR 
                   : ERROR_INSUFFICIENT_BUFFER;

    *NumInstances = RtmGlobals.NumInstances;

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetInstances");

    return Status;
}


VOID
CopyAddrFamilyInfo(
    IN      USHORT                          RtmInstanceId,
    IN      PADDRFAM_INFO                   AddrFamilyBlock,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfo
    )

/*++

Routine Description:

    Copies all public information from an address family
    to the output buffer.

Arguments:

    RtmInstanceId   - Instance for this addr family info

    AddrFamilyBlock - Actual address family info block

    AddrFamilyInfo  - Address family info is copied here

Return Value:

    None

Locks :

    The global instances lock is held to get a consistent
    view of the address family info in the instance.

--*/

{
    TraceEnter("CopyAddrFamilyInfo");

    AddrFamilyInfo->RtmInstanceId = RtmInstanceId;

    AddrFamilyInfo->AddressFamily = AddrFamilyBlock->AddressFamily;

    AddrFamilyInfo->ViewsSupported = AddrFamilyBlock->ViewsSupported;

    AddrFamilyInfo->MaxHandlesInEnum = AddrFamilyBlock->MaxHandlesInEnum;

    AddrFamilyInfo->MaxNextHopsInRoute = AddrFamilyBlock->MaxNextHopsInRoute;

    AddrFamilyInfo->MaxOpaquePtrs = AddrFamilyBlock->MaxOpaquePtrs;
    AddrFamilyInfo->NumOpaquePtrs = AddrFamilyBlock->NumOpaquePtrs;

    AddrFamilyInfo->NumEntities = AddrFamilyBlock->NumEntities;
        
    AddrFamilyInfo->NumDests = AddrFamilyBlock->NumDests;
    AddrFamilyInfo->NumRoutes = AddrFamilyBlock->NumRoutes;

    AddrFamilyInfo->MaxChangeNotifs = AddrFamilyBlock->MaxChangeNotifs;
    AddrFamilyInfo->NumChangeNotifs = AddrFamilyBlock->NumChangeNotifs;

    TraceLeave("CopyAddrFamilyInfo");

    return;
}


DWORD
WINAPI
RtmGetInstanceInfo (
    IN      USHORT                          RtmInstanceId,
    OUT     PRTM_INSTANCE_INFO              InstanceInfo,
    IN OUT  PUINT                           NumAddrFamilies,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfos OPTIONAL
    )

/*++

Routine Description:

    Get config and run time information of an RTM instance.

Arguments:

    RtmInstanceId   - ID identifying the RTM instance,

    InstanceInfo    - Buffer to return supported address families,

    NumAddrFamilies - Number of input address family info slots,
                      Actual number of address families is retd.

    AddrFamilyInfos - Address family infos are copied here.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO   Instance;
    PADDRFAM_INFO    AddrFamilyBlock;
    PLIST_ENTRY      AddrFamilies, q;
    UINT             i;
    DWORD            Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmGetInstanceInfo");

    ACQUIRE_INSTANCES_READ_LOCK();

    do
    {
        //
        // Search for the instance with input instance id
        //

        Status = GetInstance(RtmInstanceId, FALSE, &Instance);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Copy RTM instance information to output
        //

        InstanceInfo->RtmInstanceId = RtmInstanceId;

        InstanceInfo->NumAddressFamilies = Instance->NumAddrFamilies;

        //
        // Copy address family infomation if reqd
        //

        if (ARGUMENT_PRESENT(AddrFamilyInfos))
        {
            if (*NumAddrFamilies < Instance->NumAddrFamilies)
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // Copy info for as many addr families as possible
            //

            AddrFamilies = &Instance->AddrFamilyTable;

            for (q = AddrFamilies->Flink, i = 0;
                 (q != AddrFamilies) && (i < *NumAddrFamilies);
                 q = q->Flink)
            {
                AddrFamilyBlock =CONTAINING_RECORD(q, ADDRFAM_INFO, AFTableLE);

                CopyAddrFamilyInfo(RtmInstanceId, 
                                   AddrFamilyBlock, 
                                   &AddrFamilyInfos[i++]);
            }
        }

        *NumAddrFamilies = Instance->NumAddrFamilies;
    }
    while (FALSE);

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetInstanceInfo");

    return Status;
}


DWORD
WINAPI
RtmGetAddressFamilyInfo (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfo,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    )

/*++

Routine Description:

    Get config and run time information of an address family
    in an RTM instance.

Arguments:

    RtmInstanceId  - ID identifying the RTM instance

    AddressFamily  - Address family that we are interested in

    AddrFamilyInfo - Buffer to return output information in

    NumEntities    - Number of slots in the EntityIds buffer and
                     filled with num of regd entities on return.

    EntityInfos    - IDs of all registered entities is retd here.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO Instance;
    PADDRFAM_INFO  AddrFamilyBlock;
    PENTITY_INFO   Entity;
    PLIST_ENTRY    Entities, r;
    UINT           i, j;
    DWORD          Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmGetAddressFamilyInfo");

    ACQUIRE_INSTANCES_READ_LOCK();

    do
    {

        //
        // Search for an instance with the input RtmInstanceId
        //

        Status = GetInstance(RtmInstanceId, FALSE, &Instance);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Search for an address family info with input family
        //

        Status = GetAddressFamily(Instance,
                                  AddressFamily,
                                  FALSE,
                                  &AddrFamilyBlock);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Copy relevant address family information
        //

        CopyAddrFamilyInfo(RtmInstanceId, AddrFamilyBlock, AddrFamilyInfo);

        //
        // Is caller interested in entity info too ?
        //

        if (ARGUMENT_PRESENT(EntityInfos))
        {
            if (*NumEntities < AddrFamilyBlock->NumEntities)
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // Copy all relevant entity information to output
            //

            for (i = j = 0; (i < ENTITY_TABLE_SIZE) && (j < *NumEntities); i++)
            {
                Entities = &AddrFamilyBlock->EntityTable[i];
                    
                for (r = Entities->Flink; r != Entities; r = r->Flink)
                {
                    Entity = CONTAINING_RECORD(r, ENTITY_INFO, EntityTableLE);

                    EntityInfos[j].RtmInstanceId = RtmInstanceId;
                    EntityInfos[j].AddressFamily = AddressFamily;

                    EntityInfos[j].EntityId = Entity->EntityId;

                    if (++j == *NumEntities)
                    {
                        break;
                    }
                }
            }
        }

        *NumEntities = AddrFamilyBlock->NumEntities;
    }
    while (FALSE);

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetAddressFamilyInfo");

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmregn.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmregn.c

Abstract:

    Contains routines for managing registration
    of protocol & management entities with RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   20-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmRegisterEntity (
    IN      PRTM_ENTITY_INFO                RtmEntityInfo,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    IN      BOOL                            ReserveOpaquePtr,
    OUT     PRTM_REGN_PROFILE               RtmRegProfile,
    OUT     PRTM_ENTITY_HANDLE              RtmRegHandle
    )
/*++

Routine Description:

    Registers an entity with an RTM instance for a specific address
    family.

    A registration handle, and a profile of the RTM instance with
    with supported views, number of equal cost NHops / route etc.
    is returned.

    If registration is with a new instance and/or address family,
    then this instance/address family is created in this process.

Arguments:

    RtmEntityInfo     - Information (RtmInstance, Protocol ID etc.)
                        for the entity that is registering here,

    ExportMethods     - List of methods exported by this entity,

    EventCallback     - Callback invoked to inform of certain events
                        like entity registrations, de-registrations,

    ReserveOpaquePtr  - Reserve a ptr in each destination or not,

    RtmRegProfile     - RTM parameters that the entity will use in
                        RTM API calls [eg: No. of equal cost NHOPs],

    RtmRegHandle      - Identification handle for this entity used
                        in all API calls until its de-registration.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO Instance;
    PADDRFAM_INFO  AddrFamilyInfo;
    PENTITY_INFO   Entity;
    DWORD          Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmRegisterEntity");

    ACQUIRE_INSTANCES_WRITE_LOCK();

    do 
    {
        //
        // Search (or create) for an instance with the input RtmInstanceId
        //

        Status = GetInstance(RtmEntityInfo->RtmInstanceId,
                             TRUE,
                             &Instance);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Search (or create) for an address family info with input family
        //

        Status = GetAddressFamily(Instance,
                                  RtmEntityInfo->AddressFamily,
                                  TRUE,
                                  &AddrFamilyInfo);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Search (or create) for an entity with input protocol id, instance
        //

        Status = GetEntity(AddrFamilyInfo,
                           RtmEntityInfo->EntityId.EntityId,
                           TRUE,
                           RtmEntityInfo,
                           ReserveOpaquePtr,
                           ExportMethods,
                           EventCallback,
                           &Entity);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Collect all relevant information and build registration profile
        //

        RtmRegProfile->MaxNextHopsInRoute = AddrFamilyInfo->MaxNextHopsInRoute;

        RtmRegProfile->MaxHandlesInEnum = AddrFamilyInfo->MaxHandlesInEnum;

        RtmRegProfile->ViewsSupported = AddrFamilyInfo->ViewsSupported;

        RtmRegProfile->NumberOfViews = AddrFamilyInfo->NumberOfViews;

        //
        // Return a handle to this entity registration block 
        //

        *RtmRegHandle = MAKE_HANDLE_FROM_POINTER(Entity);
    }
    while (FALSE);

    RELEASE_INSTANCES_WRITE_LOCK();

    TraceLeave("RtmRegisterEntity");

    return Status;
}


DWORD
WINAPI
RtmDeregisterEntity (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle
    )
    
/*++

Routine Description:

    Deregisters an entity with its RTM instance and addr family.

    We assume that the entity is responsible for making sure
    that once this call is made, no other RTM calls will be
    made using this entity registration handle. In case such
    a thing happens, it might result in crashing the process.

    We make this assumption for performance reasons - else we
    we have to make sure that the entity handle passed in is
    valid in a try-except block (same with other handles) and
    this will lead to degradation in performance.

Arguments:

    RtmRegHandle      - RTM registration handle for the entity

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    HANDLE          Event;
    DWORD           Status;

    TraceEnter("RtmDeregisterEntity");

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Release all handles opened by entity
    //

    CleanupAfterDeregister(Entity);

    //
    // Mark the entity info as de-registered
    //

    Entity->State = ENTITY_STATE_DEREGISTERED;

    //
    // Make sure no more methods are invoked
    //

    ACQUIRE_ENTITY_METHODS_WRITE_LOCK(Entity);

    // At this time all entity methods are 
    // done - no more methods will be called
    // as we set the state to DEREGISTERED

    RELEASE_ENTITY_METHODS_WRITE_LOCK(Entity);

    //
    // Remove from entity table and inform others
    //

    AddrFamInfo = Entity->OwningAddrFamily;

    ACQUIRE_INSTANCES_WRITE_LOCK();

    //
    // Remove entity from the list of entities
    // even before ref counts on this entity
    // go to zero - this enables the entity to
    // re-register meanwhile as a new entity.
    //

    RemoveEntryList(&Entity->EntityTableLE);

    //
    // Insert in the list of entities to be
    // destroyed on the address family info.
    //

    InsertTailList(&AddrFamInfo->DeregdEntities,
                   &Entity->EntityTableLE);

    InformEntitiesOfEvent(AddrFamInfo->EntityTable,
                          RTM_ENTITY_DEREGISTERED,
                          Entity);

    RELEASE_INSTANCES_WRITE_LOCK();


    DBG_UNREFERENCED_LOCAL_VARIABLE(Event);

#if DBG_REF_BLOCKING

    //
    // Create an event on which to block on - this
    // event gets signalled when entity ref is 0.
    //

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    ASSERT(Event != NULL);

    Entity->BlockingEvent = Event;

#endif

    //
    // Remove the creation reference on the entity
    //

    DEREFERENCE_ENTITY(Entity, CREATION_REF);


    DBG_UNREFERENCED_LOCAL_VARIABLE(Status);

#if DBG_REF_BLOCKING

    //
    // Block until the reference count goes to zero
    //
    
    Status = WaitForSingleObject(Event, INFINITE);

    ASSERT(Status == WAIT_OBJECT_0);

    CloseHandle(Event);

#endif

    TraceLeave("RtmDeregisterEntity");
    
    return NO_ERROR;
}


DWORD
WINAPI
RtmGetRegisteredEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_HANDLE              EntityHandles,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    )

/*++

Routine Description:

    Retrieves information about all entities registered with an
    RTM instance.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NumEntities       - Number of entities that can be filled
                        is passed in, and number of entities
                        that exist in this address family is retd,

    RegdEntityHandles - Array to return the entity handles in,

    RegdEntityInfos   - Array to return the entity infos in

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PADDRFAM_INFO    AddrFamilyInfo;
    USHORT           RtmInstanceId;
    USHORT           AddressFamily;
    UINT             EntitiesCopied;
    UINT             i;
    PLIST_ENTRY      Entities;
    PLIST_ENTRY      p;
    DWORD            Status;

    TraceEnter("RtmGetRegisteredEntities");

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamilyInfo = Entity->OwningAddrFamily;

    //
    // Just cache the instance and address family
    // as it is identical for all entities infos.
    //

#if WRN
    RtmInstanceId = AddressFamily = 0;
#endif

    if (ARGUMENT_PRESENT(EntityInfos))
    {
        RtmInstanceId = AddrFamilyInfo->Instance->RtmInstanceId;
        AddressFamily = AddrFamilyInfo->AddressFamily;
    }

    //
    // Go over the entity table and copy out handles
    // If the OPTIONAL argument 'EntityInfos' is
    // given, copy out entity information as well.
    //

    EntitiesCopied = 0;

    ACQUIRE_INSTANCES_READ_LOCK();

    for (i = 0; (i < ENTITY_TABLE_SIZE) && (EntitiesCopied < *NumEntities);i++)
    {
        Entities = &AddrFamilyInfo->EntityTable[i];

        // 
        // Process the next bucket in the entities table
        //

        for (p = Entities->Flink; p != Entities; p = p->Flink)
        {
            Entity = CONTAINING_RECORD(p, ENTITY_INFO, EntityTableLE);

            //
            // Copy the next entity handle and info to output buffer
            //

            if (Entity->State != ENTITY_STATE_DEREGISTERED)
            {
                EntityHandles[EntitiesCopied]=MAKE_HANDLE_FROM_POINTER(Entity);

                REFERENCE_ENTITY(Entity, HANDLE_REF);

                if (ARGUMENT_PRESENT(EntityInfos))
                {
                    EntityInfos[EntitiesCopied].RtmInstanceId = RtmInstanceId;
                    EntityInfos[EntitiesCopied].AddressFamily = AddressFamily;
                    EntityInfos[EntitiesCopied].EntityId = Entity->EntityId;
                }

                if (++EntitiesCopied == *NumEntities)
                {
                    break;
                }
            }
        }
    }

    //
    // Set output to total entities present,
    // and also the appropriate return value
    //

    if (*NumEntities >= AddrFamilyInfo->NumEntities)
    {
        Status = NO_ERROR;
    }
    else
    {
        Status = ERROR_INSUFFICIENT_BUFFER;
    }

    *NumEntities = AddrFamilyInfo->NumEntities;

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetRegisteredEntities");

    return Status;
}


DWORD
WINAPI
RtmReleaseEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumEntities,
    IN      PRTM_ENTITY_HANDLE              EntityHandles
    )

/*++

Routine Description:

    Release (also called de-reference) handles to entities
    obtained in other RTM calls.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumEntities    - Number of handles that are being released,

    EntityHandles  - An array of handles that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each entity handle in array
    //

    for (i = 0; i < NumEntities; i++)
    {
        Entity = ENTITY_FROM_HANDLE(EntityHandles[i]);

        DEREFERENCE_ENTITY(Entity, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmLockDestination(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockDest
    )

/*++

Routine Description:

    Locks/unlocks a destination in the route table. This function 
    is used to guard the dest while opaque ptrs are being changed.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - Handle to the destination to be locked,

    Exclusive         - TRUE to lock in write mode, else read mode,

    LockDest          - Flag that tells whether to lock or unlock.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);

    // Lock or unlock the dest as the case may be

    if (LockDest)
    {
        if (Exclusive)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
        }
        else
        {
            ACQUIRE_DEST_READ_LOCK(Dest);
        }
    }
    else
    {
        if (Exclusive)
        {
            RELEASE_DEST_WRITE_LOCK(Dest);
        }
        else
        {
            RELEASE_DEST_READ_LOCK(Dest);
        }
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetOpaqueInformationPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PVOID                          *OpaqueInfoPtr
    )

/*++

Routine Description:

    Retrieves a pointer to the opaque info pointer field in a dest
    for this entity, or NULL if entity has not reserved such a ptr
    during registration.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - Handle to dest whose opaque info ptr we want,

    OpaqueInfoPtr     - Pointer to opaque info ptr is returned here 

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    DWORD            Status;

    TraceEnter("RtmGetOpaqueInformationPointer");

    *OpaqueInfoPtr = NULL;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    Status = ERROR_NOT_FOUND;

    //
    // If dest is valid and we have an opaque slot
    // reserved, do ptr arithmetic to get the addr
    //

    if (Entity->OpaquePtrOffset != (-1))
    {
        //
        // We do not check if the dest in deleted
        // as the entity will need to access its
        // opaque info even after dest is deleted.
        //

        Dest = DEST_FROM_HANDLE(DestHandle);

        if (Dest)
        {
            *OpaqueInfoPtr = &Dest->OpaqueInfoPtrs[Entity->OpaquePtrOffset];

            Status = NO_ERROR;
        }
        else
        {
            Status = ERROR_INVALID_HANDLE;
        }
    }

    TraceLeave("RtmGetOpaqueInformationPointer");

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmnhop.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmnhop.c

Abstract:

    Contains routines for managing RTM Next Hops.

Author:

    Chaitanya Kodeboyina (chaitk)   21-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmAddNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN OUT  PRTM_NEXTHOP_HANDLE             NextHopHandle OPTIONAL,
    OUT     PRTM_NEXTHOP_CHANGE_FLAGS       ChangeFlags
    )

/*++

    Adds or Updates a next hop entry to the entity's next-hop table.

    If the 'nexthop handle' argument is present, then this next-hop
    is updated. Otherwise a search is made for the address in the
    input 'nexthop info', and if a next-hop is found, it is updated.
    If no matching next-hop is found, the a new next-hop is added.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopInfo       - Info that corresponds to this next-hop,

    NextHopHandle     - Handle to the next-hop to update is passed 
                        in (or NULL), and if a next-hop is created 
                        a handle to this new next-hop is returned.

    ChangeFlags       - Flags whether this was a add or an update.

Return Value:

    Status of the operation

--*/

{
    PRTM_NET_ADDRESS  NextHopAddress;
    PENTITY_INFO      Entity;
    PDEST_INFO        Dest;
    PNEXTHOP_LIST     NewHopList;
    PNEXTHOP_INFO     NewNextHop;
    PNEXTHOP_INFO     NextHop;
    LOOKUP_CONTEXT    Context;
    PLIST_ENTRY       p;
    DWORD             Status;

    //
    // Validate incoming information before attempting an add
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if (NextHopInfo->RemoteNextHop)
    {
        VALIDATE_DEST_HANDLE(NextHopInfo->RemoteNextHop, &Dest);
    }

    //
    // If there is a next hop handle, we can avoid a search
    //

    NextHop = NULL;

    if (ARGUMENT_PRESENT(NextHopHandle) && (*NextHopHandle))
    {
        VALIDATE_NEXTHOP_HANDLE(*NextHopHandle, &NextHop);

        // Make sure that the caller owns this nexthop
        if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
        {
            return ERROR_ACCESS_DENIED;
        }
    }

#if WRN
    NewNextHop = NULL;
    NewHopList = NULL;
#endif

    *ChangeFlags = 0;

    ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity);

    do
    {
        //
        // Search for the next hop if we don't already have one
        //

        if (NextHop == NULL)
        {
            Status = FindNextHop(Entity, NextHopInfo, &Context, &p);

            if (SUCCESS(Status))
            {
                // The next hop already exists in the tree

                NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);
            }
            else
            {
                // Init new allocations in case we fail in between

                NewNextHop = NULL;
                NewHopList = NULL;

                //
                // Create a new next hop with the input information
                //

                Status = CreateNextHop(Entity, NextHopInfo, &NewNextHop);

                if (!SUCCESS(Status))
                {
                    break;
                }

                //
                // Do we need to create a new list of next hops too ?
                //

                if (p == NULL)
                {
                    NewHopList = AllocNZeroMemory(sizeof(NEXTHOP_LIST));

                    if (NewHopList == NULL)
                    {
                        break;
                    }

                    InitializeListHead(&NewHopList->NextHopsList);

                    // Insert the next-hop-list into the tree

                    NextHopAddress = &NextHopInfo->NextHopAddress;

                    Status = InsertIntoTable(Entity->NextHopTable,
                                             NextHopAddress->NumBits,
                                             NextHopAddress->AddrBits,
                                             &Context,
                                             &NewHopList->LookupLinkage);
                    if (!SUCCESS(Status))
                    {
                        break;
                    }

                    p = &NewHopList->NextHopsList;
                }

                // Insert the next hop in the list and ref it
                InsertTailList(p, &NewNextHop->NextHopsLE);

                Entity->NumNextHops++;

                NextHop = NewNextHop;

                *ChangeFlags = RTM_NEXTHOP_CHANGE_NEW;
            }
        }

        //
        // If this is an update, copy necessary information
        //

        if (*ChangeFlags != RTM_NEXTHOP_CHANGE_NEW)
        {
            CopyToNextHop(Entity, NextHopInfo, NextHop);
        }

        //
        // Return the next hop handle if not passed in
        //

        if (ARGUMENT_PRESENT(NextHopHandle))
        {
            if (*NextHopHandle == NULL)
            {
                *NextHopHandle = MAKE_HANDLE_FROM_POINTER(NextHop);

                REFERENCE_NEXTHOP(NextHop, HANDLE_REF);
            }
        }

        Status = NO_ERROR;
    }
    while(FALSE);

    RELEASE_NHOP_TABLE_WRITE_LOCK(Entity);

    if (!SUCCESS(Status))
    {
        // Some error occured - clean up

        if (NewHopList)
        {
            FreeMemory(NewHopList);
        }

        if (NewNextHop)
        {
            DEREFERENCE_NEXTHOP(NewNextHop, CREATION_REF);
        }
    }

    return Status;
}


DWORD
WINAPI
RtmDeleteNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle OPTIONAL,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo
    )

/*++

Routine Description:

    Deletes a next hop from the next-hop table. The next-hop
    memory remains in use until all reference counts go to 0.
    
Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - Handle to the next-hop we want to delete,

    NextHopInfo       - If no NextHopHandle is passed in, this is
                        used to match the next-hop to be deleted.

Return Value:

    Status of the operation

--*/

{
    PRTM_NET_ADDRESS  NextHopAddress;
    PLOOKUP_LINKAGE   Linkage;
    PENTITY_INFO      Entity;
    PNEXTHOP_LIST     HopList;
    PNEXTHOP_INFO     NextHop;
    PLOOKUP_CONTEXT   PContext;
    LOOKUP_CONTEXT    Context;
    PLIST_ENTRY       p;
    DWORD             Status;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // If there is a next hop handle, we can avoid a search
    //

    NextHop = NULL;

    if (ARGUMENT_PRESENT(NextHopHandle))
    {
        VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

        // Make sure that the caller owns this nexthop
        if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
        {
            return ERROR_ACCESS_DENIED;
        }
    }

#if WRN
    Status = ERROR_GEN_FAILURE;
#endif

    ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity);

    do
    {
        //
        // Search for the next hop if we don't already have one
        //

        if (NextHop == NULL)
        {
            Status = FindNextHop(Entity, 
                                 NextHopInfo, 
                                 &Context, 
                                 &p);

            if (!SUCCESS(Status))
            {
                break;
            }

            PContext = &Context;

            NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);
        }
        else
        {
            // Make sure that it has not already been deleted

            if (NextHop->NextHopInfo.State == RTM_NEXTHOP_STATE_DELETED)
            {
                break;
            }

            PContext = NULL;
        }
         
        // Get a 'possible' list entry that starts the hop list

        HopList = CONTAINING_RECORD(NextHop->NextHopsLE.Blink,
                                    NEXTHOP_LIST,
                                    NextHopsList);

        // Delete this next-hop from the nexthops list

        NextHop->NextHopInfo.State = RTM_NEXTHOP_STATE_DELETED;

        RemoveEntryList(&NextHop->NextHopsLE);
        

        // Do we have any more next hops on this list

        if (IsListEmpty(&HopList->NextHopsList))
        {
            // Remove the hop-list from the next hop table

            NextHopAddress = &NextHop->NextHopInfo.NextHopAddress;

            Status = DeleteFromTable(Entity->NextHopTable,
                                     NextHopAddress->NumBits,
                                     NextHopAddress->AddrBits,
                                     PContext,
                                     &Linkage);

            ASSERT(SUCCESS(Status) && (&HopList->LookupLinkage == Linkage));

            FreeMemory(HopList);
        }

        // Dereference the next-hop that was deleted

        Entity->NumNextHops--;

        DEREFERENCE_NEXTHOP(NextHop, CREATION_REF);

        if (ARGUMENT_PRESENT(NextHopHandle))
        {            
            DEREFERENCE_NEXTHOP(NextHop, HANDLE_REF);
        }

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_NHOP_TABLE_WRITE_LOCK(Entity);

    return Status;
}


DWORD
WINAPI
RtmFindNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    )

/*++

Routine Description:

    Finds a next hop, given its info, in entity's next-hop table.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopInfo       - Info for the next-hop we are searching for
                        ( NextHopOwner, NextHopAddress, IfIndex ),

    NextHopHandle     - Handle to next-hop is returned (if found),

    NextHopPointer    - A pointer to the next-hop is returned for
                        fast direct access by the next-hop's owner.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PNEXTHOP_INFO     NextHop;
    PLIST_ENTRY       p;
    DWORD             Status;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ENTITY_HANDLE(NextHopInfo->NextHopOwner, &Entity);
    
    if (ARGUMENT_PRESENT(NextHopPointer))
    {
        // Only the nexthop owner gets a direct ptr
        if (RtmRegHandle != NextHopInfo->NextHopOwner)
        {
            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Search for the next hop in the next hop table
    //

    ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);

    Status = FindNextHop(Entity, NextHopInfo, NULL, &p);

    if (SUCCESS(Status))
    {
        NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

        *NextHopHandle = MAKE_HANDLE_FROM_POINTER(NextHop);

        REFERENCE_NEXTHOP(NextHop, HANDLE_REF);

        if (ARGUMENT_PRESENT(NextHopPointer))
        {
            *NextHopPointer = &NextHop->NextHopInfo;
        }
    }

    RELEASE_NHOP_TABLE_READ_LOCK(Entity);

    return Status;
}


DWORD
FindNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT     PLIST_ENTRY                    *NextHopLE
    )

/*++

Routine Description:

    Finds a next hop, given its info, in entity's next-hop table.

    This is a helper function that is called by public functions 
    that add, delete or find a next hop in the next hop table.

Arguments:

    Entity            - Entity whose nexthop table we are searching,

    NextHopInfo       - Info for the next-hop we are searching for
                        ( NextHopOwner, NextHopAddress, IfIndex ),

    Context           - Search context for holding list of nexthops,

    NextHopLE         - List entry for the matching nexthop (if found)
                        (or) list entry before which it'll be inserted.

Return Value:

    Status of the operation

--*/

{
    PRTM_NET_ADDRESS  NextHopAddress;
    PNEXTHOP_LIST     NextHopsList;
    PNEXTHOP_INFO     NextHop;
    ULONG             IfIndex;
    PLOOKUP_LINKAGE   Linkage;
    PLIST_ENTRY       NextHops, p;
    DWORD             Status;

    *NextHopLE = NULL;

    //
    // Search for list of next hops, given the address
    //

    NextHopAddress = &NextHopInfo->NextHopAddress;

    Status = SearchInTable(Entity->NextHopTable,
                           NextHopAddress->NumBits,
                           NextHopAddress->AddrBits,
                           Context,
                           &Linkage);

    if (!SUCCESS(Status))
    {
        return Status;
    }

    NextHopsList = CONTAINING_RECORD(Linkage, NEXTHOP_LIST, LookupLinkage);

    //
    // Search for the nexthop with the interface idx
    //

    IfIndex = NextHopInfo->InterfaceIndex;

    NextHops = &NextHopsList->NextHopsList;

#if WRN
    NextHop = NULL;
#endif

    for (p = NextHops->Flink; p != NextHops; p = p->Flink)
    {
        NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

        if (NextHop->NextHopInfo.InterfaceIndex <= IfIndex)
        {
            break;
        }
    }

    *NextHopLE = p;

    if ((p == NextHops) || (NextHop->NextHopInfo.InterfaceIndex != IfIndex))
    {
        return ERROR_NOT_FOUND;
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetNextHopPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer
    )

/*++

Routine Description:

    Gets a direct pointer to the next-hop for read/write by its owner.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - Handle to the next-hop whose pointer we want,

    NextHopPointer    - A pointer to the next-hop is returned for
                        fast direct access by the caller, only if
                        the caller is the owner of this next-hop.
                       
Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PNEXTHOP_INFO     NextHop;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

    //
    // Return a pointer only if caller owns next-hop
    //

    if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    *NextHopPointer = &NextHop->NextHopInfo;

    return NO_ERROR;
}


DWORD
WINAPI
RtmLockNextHop(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockNextHop,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    )

/*++

Routine Description:

    Locks or Unlocks a next hop. This function is called by the
    next-hop's owner to lock the next-hop before making changes
    directly to the next-hop using a pointer to this next-hop.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - Handle to the next-hop that we want to lock,

    Exclusive         - TRUE to lock in write mode, else read mode,

    LockNextHop       - Lock nexthop if TRUE, Unlock it if FALSE,

    NextHopPointer    - A pointer to the next-hop is returned for
                        fast direct access by the next hop's owner.
                       
Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PNEXTHOP_INFO     NextHop;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

    //
    // Lock or unlock only if caller owns next-hop
    //

    if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    // Return a direct pointer for use in update

    if (ARGUMENT_PRESENT(NextHopPointer))
    {
        *NextHopPointer = &NextHop->NextHopInfo;
    }

    // Lock or unlock the nexthop as the case may be

    if (LockNextHop)
    {
        if (Exclusive)
        {
            ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity);
        }
        else
        {
            ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);
        }
    }
    else
    {
        if (Exclusive)
        {
            RELEASE_NHOP_TABLE_WRITE_LOCK(Entity);
        }
        else
        {
            RELEASE_NHOP_TABLE_READ_LOCK(Entity);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmtest.cxx ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmtest.cxx

Abstract:
    Contains routines for testing RTM v2 API DLL.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

extern "C" {

#define LOOKUP_TESTING 0

#include "rtmtest.h"

#include "apitest.c"

#include "lkuptst.c"

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmtimer.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmtimer.h

Abstract:

    Contains definitions for timer callbacks for 
    handling functions like aging out routes etc.
    
Author:

    Chaitanya Kodeboyina (chaitk)   14-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMTIMER_H__
#define __ROUTING_RTMTIMER_H__

VOID 
NTAPI
RouteExpiryTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    );

VOID 
NTAPI
RouteHolddownTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    );

#endif //__ROUTING_RTMTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmrout.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmrout.c

Abstract:

    Contains routines for adding and deleting
    routes in the RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmAddRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PRTM_ROUTE_HANDLE               RouteHandle     OPTIONAL,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                ChangeType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    IN OUT  PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    )

/*++

Routine Description:

    Adds a new route (or) updates an existing route to a destination. 

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route being updated (or NULL)
                        is passed in; Passing a route handle avoids
                        a search in the route table.

                        Handle to new or updated route is returned,

    DestAddress       - Destination network address for this route,

    RouteInfo         - Info for the new route/route being updated,

    TimeToLive        - Time (in ms) after which route is expired,

    RouteListHandle   - Route list to which route is being moved,

    Notify Type       -

    Notify Handle     - 

    ChangeFlags       - Whether to add a new route or update an
                        already existing one; 

                        The type of actual change (i.e) new add or
                        update, and if best route changed is retd,

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;
    PROUTE_LIST      RouteList;

    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    PROUTE_INFO      CurrRoute;
    PROUTE_INFO      BestRoute;

    BOOL             TableWriteLocked;
    LOOKUP_CONTEXT   Context;
    PLOOKUP_LINKAGE  DestData;
    BOOL             DestCreated;

    LONG             PrefChanged;
    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     BelongedToViews;
    RTM_VIEW_SET     WorseInViews;
    RTM_VIEW_SET     BetterInViews;
    RTM_VIEW_SET     RouteOldBestInViews;
    RTM_VIEW_SET     RouteNewBestInViews;
    RTM_VIEW_SET     RouteCurBestInViews;
    ULONG            RouteInfoChanged;
    ULONG            ForwardingInfoChanged;

    PROUTE_TIMER     TimerContext;

    DWORD            NotifyToCNs;
    PLOOKUP_LINKAGE  NextData;
    PDEST_INFO       NextDest;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];
    DWORD            DestMarkedBits;

    PLIST_ENTRY      p;
    UINT             i;
    DWORD            Status;
    BOOL             Success;

    UNREFERENCED_PARAMETER(ChangeType);
    UNREFERENCED_PARAMETER(NotifyHandle);

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // Validate input parameters before taking locks
    //

    // We should be adding only to supported views

    if (RouteInfo->BelongsToViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Check the route list handle for validity

    RouteList = NULL;
    if (ARGUMENT_PRESENT(RouteListHandle))
    {
        VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);
    }

    DestCreated = FALSE;

#if WRN
    Dest = NULL;
#endif

    //
    // Check if we have a route handle present
    //

    if (ARGUMENT_PRESENT(RouteHandle) && (*RouteHandle))
    {
        //
        // No flags apply here as this is an update
        //

        if (*ChangeFlags != 0)
        {
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Make sure that route handle is valid here
        //

        Route = ROUTE_FROM_HANDLE(*RouteHandle);

        if (Route == NULL)
        {
            return ERROR_INVALID_HANDLE;
        }

        //
        // Do further checking after acquiring lock
        //

        Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

        Status = NO_ERROR;

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        //
        // Only the owner has perms to modify the route
        //

        if (Route->RouteInfo.RouteOwner != RtmRegHandle)
        {
            Status = ERROR_ACCESS_DENIED;
        }

        //
        // Was this route already deleted ?
        //

        if (Route->RouteInfo.State == RTM_ROUTE_STATE_DELETED)
        {
            Status = ERROR_INVALID_HANDLE;
        }

        if (Status != NO_ERROR)
        {
            RELEASE_DEST_WRITE_LOCK(Dest);

            return Status;
        }
    }
    else
    {
        //
        // Search the table for the dest for this route
        //

        Route = NULL;

        TableWriteLocked = FALSE;

        ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

        Status = SearchInTable(AddrFamInfo->RouteTable,
                               DestAddress->NumBits,
                               DestAddress->AddrBits,
                               NULL,
                               &DestData);

        if (SUCCESS(Status))
        {
            Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);
        }
        else
        {
            //
            // We did'nt find a matching destination
            //

            RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

            TableWriteLocked = TRUE;

            ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);

            //
            // We upgraded our route table lock from a
            // read lock to a write lock. We need to
            // search again to see if the dest has been
            // added after we released the read lock.
            //
            // If we do not find a destination even now,
            // we create a new one and insert into table
            //

            Status = SearchInTable(AddrFamInfo->RouteTable,
                                   DestAddress->NumBits,
                                   DestAddress->AddrBits,
                                   &Context,
                                   &DestData);

            if (SUCCESS(Status))
            {
                Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);
            }
            else
            {
                //
                // Did not find the dest; so create new route and dest
                //

                Status = CreateRoute(Entity, RouteInfo, &Route);
                
                if (SUCCESS(Status))
                {
                    Status = CreateDest(AddrFamInfo, DestAddress, &Dest);

                    if (SUCCESS(Status))
                    {
                        Status = InsertIntoTable(AddrFamInfo->RouteTable,
                                                 DestAddress->NumBits,
                                                 DestAddress->AddrBits,
                                                 &Context,
                                                 &Dest->LookupLinkage);
                    
                        if (SUCCESS(Status))
                        {
                            *ChangeFlags = RTM_ROUTE_CHANGE_NEW;

                            AddrFamInfo->NumDests++;
#if DBG_REF
                            REFERENCE_DEST(Dest, ROUTE_REF);

                            DEREFERENCE_DEST(Dest, CREATION_REF);
#endif
                            DestCreated = TRUE;

                            Route->RouteInfo.DestHandle =
                                        MAKE_HANDLE_FROM_POINTER(Dest);
                        }
                        else
                        {
                            //
                            // Free alloc'ed memory as insert failed
                            //

                            DEREFERENCE_DEST(Dest, CREATION_REF);

                            DEREFERENCE_ROUTE(Route, CREATION_REF);
                        }
                    }
                    else
                    {
                        DEREFERENCE_ROUTE(Route, CREATION_REF);
                    }
                }
            }
        }

        if (SUCCESS(Status))
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
        }

        //
        // Release route table lock as you have the dest
        //

        if (!TableWriteLocked)
        {
            RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);
        }
        else
        {
            RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
        }
    }

    if (SUCCESS(Status))
    {
        //
        // We have found an existing dest, or created a new one
        // In any case, we have a write lock on the destination
        //

        if (Route == NULL)
        {
            //
            // Do we have to add a new route or can we update ?
            //

            if ((*ChangeFlags & RTM_ROUTE_CHANGE_NEW) == 0)
            {
                //
                // Search for a matching route to update
                //

                for (p = Dest->RouteList.Flink;
                                          p != &Dest->RouteList;
                                                              p = p->Flink)
                {
                    Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                    //
                    // Normally we consider two routes equal if
                    // they have the same owner and were learnt
                    // from the same neigbour, but if xxx_FIRST
                    // flag is set, we skip the neighbour check
                    //

                    if ((Route->RouteInfo.RouteOwner == RtmRegHandle) &&
                        ((*ChangeFlags & RTM_ROUTE_CHANGE_FIRST) ||
                         (Route->RouteInfo.Neighbour == RouteInfo->Neighbour)))
                    {
                        break;
                    }
                }
            }
            else
            {
                p = &Dest->RouteList;
            }

            if (p == &Dest->RouteList)
            {
                //
                // Need to create a new route on dest
                //

                Status = CreateRoute(Entity, RouteInfo, &Route);

                if (SUCCESS(Status))
                {
                    *ChangeFlags = RTM_ROUTE_CHANGE_NEW;

                    REFERENCE_DEST(Dest, ROUTE_REF);

                    Route->RouteInfo.DestHandle =
                                 MAKE_HANDLE_FROM_POINTER(Dest);
                }
                else
                {
                    RELEASE_DEST_WRITE_LOCK(Dest);

                    return Status;
                }
            }
        }

        //
        // At this point, we either created a new route
        // or found a existing route on the destination
        //

        if (*ChangeFlags == RTM_ROUTE_CHANGE_NEW)
        {
            //
            // New add -> route belonged to no views
            //

            BelongedToViews = 0;

            PrefChanged = +1;

            //
            // Actual insert is done after this block
            //

            InterlockedIncrement(&AddrFamInfo->NumRoutes);
        }
        else
        {
            BelongedToViews = Route->RouteInfo.BelongsToViews;

            PrefChanged = ComparePref(RouteInfo,
                                      &Route->RouteInfo);

            if (PrefChanged != 0)
            {
                Dest->NumRoutes--;

                RemoveEntryList(&Route->DestLE);
            }

            //
            // Update existing route with only information
            // needed to calc the new best route on dest.
            // The rest is updated at end of this function
            // after we determine what info has changed.
            //

            Route->RouteInfo.PrefInfo = RouteInfo->PrefInfo;
            Route->RouteInfo.BelongsToViews = RouteInfo->BelongsToViews;
        }

        if (PrefChanged)
        {
            //
            // Insert the route in sorted order of preference info
            //

            for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p= p->Flink)
            {
                CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                if (ComparePref(&CurrRoute->RouteInfo,
                                &Route->RouteInfo) < 0)
                {
                    break;
                }
            }        
                
            InsertTailList(p, &Route->DestLE);

            Dest->NumRoutes++;
        }

        //
        // Return the route handle if not passed in by the caller
        //

        if (ARGUMENT_PRESENT(RouteHandle))
        {
            if (*RouteHandle == NULL)
            {
                *RouteHandle = MAKE_HANDLE_FROM_POINTER(Route);

                REFERENCE_ROUTE(Route, HANDLE_REF);
            }
        }

        //
        // Adjust the best route information in each view
        //

        ViewIndices = AddrFamInfo->ViewIndexFromId;

        //
        // We have 3 cases that this add / update can trigger,
        // In a particular view -
        // 1) Route was the view's best route but not anymore,
        // 2) Route was and is still the best route after add,
        // 3) Route has become this view's "new" best route.
        //
        // If none of the above,
        // 4) Route was not the best before and is still not.
        //

        RouteCurBestInViews = 0;
        RouteNewBestInViews = 0;
        RouteOldBestInViews = 0;

        //
        // Compute all views in which this is the best route
        //

        ViewSet = BelongedToViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                // Update dest information in view i

                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                // Was this the best route in view ?
                if (BestRoute == Route)
                {
                    RouteCurBestInViews |= VIEW_MASK(i);
                }
            }
        
            ViewSet >>= 1;
        }

        //
        // Update views where route preference got better
        //

        if (PrefChanged > 0)
        {
            BetterInViews = RouteInfo->BelongsToViews;
        }
        else
        {
            BetterInViews = ~BelongedToViews & RouteInfo->BelongsToViews;
        }

        Dest->BelongsToViews |= BetterInViews;

        ViewSet = BetterInViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                //
                // Update dest information in view i
                //

                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                //
                // Is route most preferred now, while
                // it was not so before this update ?
                //
                
                if ((!BestRoute) || 
                        ((BestRoute != Route) &&
                            (ComparePref(RouteInfo,
                                         &BestRoute->RouteInfo) > 0)))
                {
                    Dest->ViewInfo[ViewIndices[i]].BestRoute = Route;

                    RouteNewBestInViews |= VIEW_MASK(i);
                }
            }
        
            ViewSet >>= 1;
        }

        //
        // Update in views where the route preference got worse
        //

        if (PrefChanged < 0)
        {
            WorseInViews = RouteCurBestInViews;
        }
        else
        {
            WorseInViews = RouteCurBestInViews & ~RouteInfo->BelongsToViews;
        }

        //
        // In the views that you were the best, update best route
        //

        for (p = Dest->RouteList.Flink; 
                        WorseInViews && (p != &Dest->RouteList); 
                                                          p = p->Flink)
        {
            CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

            ViewSet = CurrRoute->RouteInfo.BelongsToViews & WorseInViews;

            for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
            {
                if (ViewSet & 0x01)
                {
                    // Get best route in current view
                    BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                    if (BestRoute != CurrRoute)
                    {
                        Dest->ViewInfo[ViewIndices[i]].BestRoute = CurrRoute;

                        RouteOldBestInViews |= VIEW_MASK(i);
                    }
                }

                ViewSet >>= 1;
            }

            WorseInViews &= ~CurrRoute->RouteInfo.BelongsToViews;
        }

        //
        // For some views, we end up not having a best route
        //

        ViewSet = WorseInViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                Dest->ViewInfo[ViewIndices[i]].BestRoute = NULL;

                RouteOldBestInViews |= VIEW_MASK(i);
            }
        
            ViewSet >>= 1;
        }

        Dest->BelongsToViews &= ~WorseInViews;

        //
        // Update the views in which route remains the best
        //

        RouteCurBestInViews &= ~RouteOldBestInViews;

        //
        // The following bit masks as all mutually exclusive
        //
        
        ASSERT(!(RouteOldBestInViews & RouteCurBestInViews));
        ASSERT(!(RouteCurBestInViews & RouteNewBestInViews));
        ASSERT(!(RouteNewBestInViews & RouteOldBestInViews));

        //
        // Compute the views for each change type occurred
        //

        //
        // All views affected by this add are notified
        // -views route belonged to and now belongs to
        //

        ViewsForCT[RTM_CHANGE_TYPE_ID_ALL]  = 
            BelongedToViews | RouteInfo->BelongsToViews;

        //
        // If the route's posn as the best route changed,
        // then it is definitely a best and fwding change
        //

        ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] = 
        ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] = 
            RouteNewBestInViews | RouteOldBestInViews;

        if (RouteCurBestInViews)
        {
            //
            // Figure out what information has changed
            //

            ComputeRouteInfoChange(&Route->RouteInfo,
                                   RouteInfo,
                                   PrefChanged,
                                   &RouteInfoChanged,
                                   &ForwardingInfoChanged);
            //
            // If the route was and is still the best
            // route, then the change types depend on
            // kind of information that was modified.
            //

            ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] |= 
                RouteInfoChanged & RouteCurBestInViews;

            ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] |=
                ForwardingInfoChanged & RouteCurBestInViews;
        }

        //
        // If not a new route, update with new info
        //

        if (*ChangeFlags != RTM_ROUTE_CHANGE_NEW)
        {
            CopyToRoute(Entity, RouteInfo, Route);
        }

        //
        // Update output flags if best route changed
        //

        if (ViewsForCT[RTM_CHANGE_TYPE_ID_BEST])
        {
            *ChangeFlags |= RTM_ROUTE_CHANGE_BEST;
        }

        //
        // Calculate the CNs that need to be notified
        //

        ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        if (!DestCreated)
        {
            DestMarkedBits = Dest->DestMarkedBits;
        }
        else
        {
            DestMarkedBits = 0;

            NextMatchInTable(AddrFamInfo->RouteTable,
                             &Dest->LookupLinkage,
                             &NextData);

            if (NextData)
            {
                NextDest = 
                    CONTAINING_RECORD(NextData, DEST_INFO, LookupLinkage);

                DestMarkedBits = NextDest->DestMarkedBits;
            }
        }

        NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                             DestMarkedBits,
                                             ViewsForCT);

        //
        // Add to the global change list if required
        //
        
        if (NotifyToCNs)
        {
            AddToChangedDestLists(AddrFamInfo,
                                  Dest,
                                  NotifyToCNs);
        }

        RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        //
        // Remove from old route list, and put in the new one
        //
    
        if (RouteList)
        {
            ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

            if (!IsListEmpty(&Route->RouteListLE))
            {
                RemoveEntryList(&Route->RouteListLE);
            }
            else
            {
                REFERENCE_ROUTE(Route, LIST_REF);
            }

            InsertTailList(&RouteList->ListHead, &Route->RouteListLE);

            RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);
        }

        //
        // Set a timer if we want to age out the route
        //

        TimerContext = Route->TimerContext;

        if (TimeToLive == INFINITE)
        {
            Route->TimerContext = NULL;
        }
        else
        {
            Route->TimerContext = AllocMemory(sizeof(ROUTE_TIMER));

            if (Route->TimerContext)
            {
                Route->TimerContext->Route = Route;

                Success = CreateTimerQueueTimer(&Route->TimerContext->Timer,
                                                AddrFamInfo->RouteTimerQueue,
                                                RouteExpiryTimeoutCallback,
                                                Route->TimerContext,
                                                TimeToLive,
                                                0,
                                                0);

                if (Success)
                {
                    REFERENCE_ROUTE(Route, TIMER_REF);
                }
                else
                {
                    Status = GetLastError();

                    FreeMemory(Route->TimerContext);

                    Route->TimerContext = NULL;
                }
            }
        }

#if DBG_TRACE

        //
        // Print the route and the dest in the tracing
        //

        if (TRACING_ENABLED(ROUTE))
        {
            ULONG TempAddr, TempMask;
            
            RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
            Trace0(ROUTE, "Adding Route with address: ");
            TracePrintAddress(ROUTE, TempAddr, TempMask);
            Trace2(ROUTE, "Dest = %p and Route = %p\n", Dest, Route);
        }
#endif

        RELEASE_DEST_WRITE_LOCK(Dest);

        //
        // Cancel the timer that was attached to the route
        //

        if (TimerContext)
        {
            if (DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                      TimerContext->Timer,
                                      (HANDLE) -1))
            {
                // Timer cancelled - delete the context

                FreeMemory(TimerContext);

                DEREFERENCE_ROUTE(Route, TIMER_REF);
            }
        }

        return NO_ERROR;
    }

    return Status;
}


DWORD
WINAPI
RtmDeleteRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    )

/*++

Routine Description:

    Deletes a route from the route table, and updates the
    best route information on the corresponding dest.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route to be deleted,

    ChangeFlags       - Flags whether the best route info changed.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;

    PDEST_INFO       Dest;
    PROUTE_INFO      BestRoute;
    PROUTE_INFO      CurrRoute;
    PROUTE_INFO      Route;

    BOOL             TableLocked;
    PLOOKUP_LINKAGE  DestData;

    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     WorseInViews;
    RTM_VIEW_SET     RouteCurBestInViews;
    ULONG            MaxHoldTime;

    PROUTE_TIMER     TimerContext;

    ULONG            NotifyToCNs;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];

    PLIST_ENTRY      p;
    UINT             i, j;
    DWORD            Status;
    BOOL             Success;


    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);
    
    AddrFamInfo = Entity->OwningAddrFamily;


    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Only the owner has perms to delete the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

#if DBG_TRACE

    //
    // Print the route and the dest in the tracing
    //

    if (TRACING_ENABLED(ROUTE))
    {
        ULONG TempAddr, TempMask;
        
        RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
        Trace0(ROUTE, "Deleting Route with address: ");
        TracePrintAddress(ROUTE, TempAddr, TempMask);
        Trace2(ROUTE, "Dest = %p and Route = %p\n", Dest, Route);
    }

#endif

    //
    // We attempt to delete the route on the dest
    // without having to lock the entire table.
    // This is possible as long as the route is
    // not the only route on this destination.
    //

    TableLocked = FALSE;

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    //
    // Check if this is the last route on dest,
    // there is no holddown already that would 
    // prevent the dest from getting deleted,
    // and this route isnt going into holddown
    //

    if ((Dest->NumRoutes == 1) && 
        (Dest->HoldRefCount == 0) &&
        ((Dest->ToHoldInViews & Route->RouteInfo.BelongsToViews) == 0))
    {
        if (Route->RouteInfo.State != RTM_ROUTE_STATE_DELETED)
        {
            // Mark the state of the route as 'deleting'

            Route->RouteInfo.State = RTM_ROUTE_STATE_DELETING;

            //
            // Re-grab dest lock after locking route table
            //

            RELEASE_DEST_WRITE_LOCK(Dest);


            TableLocked = TRUE;
        
            ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);


            ACQUIRE_DEST_WRITE_LOCK(Dest);

            //
            // Was route updated while we re-acquired locks
            //

            if (Route->RouteInfo.State != RTM_ROUTE_STATE_DELETING)
            {
                RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);

                RELEASE_DEST_WRITE_LOCK(Dest);

                return NO_ERROR;
            }
        }
    }

    //
    // Get out if this route is already deleted
    //

    if (Route->RouteInfo.State != RTM_ROUTE_STATE_DELETED)
    {
        ASSERT(!IsListEmpty(&Route->DestLE));

        //
        // Remove the route from the list of routes on dest
        //

        Route->RouteInfo.State = RTM_ROUTE_STATE_DELETED;

        RemoveEntryList(&Route->DestLE);

        Dest->NumRoutes--;

        *ChangeFlags = 0;

        if (TableLocked)
        {
            //
            // Have u removed all routes on dest  ? 
            // Do we have any routes in holddown  ?
            // Is current delete causing holddown ?
            //

            if ((Dest->NumRoutes == 0) &&
                (Dest->HoldRefCount == 0) &&
                ((Dest->ToHoldInViews & Route->RouteInfo.BelongsToViews) == 0))
            {
                Dest->State = DEST_STATE_DELETED;

                Status = DeleteFromTable(AddrFamInfo->RouteTable,
                                         Dest->DestAddress.NumBits,
                                         Dest->DestAddress.AddrBits,
                                         NULL,
                                         &DestData);

                ASSERT(SUCCESS(Status));

                AddrFamInfo->NumDests--;
            }
        
            //
            // You no longer need to keep a lock to the table
            // [ You have a lock on the destination however ]
            //

            RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
        }

        ViewIndices = AddrFamInfo->ViewIndexFromId;

        //
        // Update best route in views the route was present
        //

        ViewSet = Route->RouteInfo.BelongsToViews;

        //
        // See if you are best route in any of these views
        //

        RouteCurBestInViews = 0;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                // Update dest information in view i
            
                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                // Was this the best route in view ?
                if (BestRoute == Route)
                {
                    RouteCurBestInViews |= VIEW_MASK(i);
                }
            }
        
            ViewSet >>= 1;
        }

        //
        // In the views that you were the best, update best route
        //

        WorseInViews = RouteCurBestInViews;

        for (p = Dest->RouteList.Flink; 
                   (p != &Dest->RouteList) && WorseInViews; 
                                                  p = p->Flink)
        {
            CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

            ViewSet = CurrRoute->RouteInfo.BelongsToViews & WorseInViews;

            for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
            {
                if (ViewSet & 0x01)
                {
                    // Update best route in current view

                    Dest->ViewInfo[ViewIndices[i]].BestRoute = CurrRoute;
                }

                ViewSet >>= 1;
            }

            WorseInViews &= ~CurrRoute->RouteInfo.BelongsToViews;
        }

        //
        // For some views, we end up not having a best route
        //

        ViewSet = WorseInViews;

        MaxHoldTime = 0;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                j = ViewIndices[i];

                ASSERT(Dest->ViewInfo[j].BestRoute == Route);

                Dest->ViewInfo[j].BestRoute = NULL;

                //
                // If dest is marked for holddown in this view,
                // store deleted route as the holddown route 
                // if there was no other held route before this
                //

                if (Dest->ViewInfo[j].HoldTime)
                {
                    if (Dest->ViewInfo[j].HoldRoute == NULL)
                    {
                        Dest->ViewInfo[j].HoldRoute = Route;

                        REFERENCE_ROUTE(Route, HOLD_REF);

                        if (MaxHoldTime < Dest->ViewInfo[j].HoldTime)
                        {
                            MaxHoldTime = Dest->ViewInfo[j].HoldTime;
                        }
                    }

                    Dest->ViewInfo[j].HoldTime = 0;
                }
            }
        
            ViewSet >>= 1;
        }

        Dest->BelongsToViews &= ~WorseInViews;

        Dest->ToHoldInViews  &= ~WorseInViews;

        //
        // Compute the views for each change type occurred
        //

        ViewsForCT[RTM_CHANGE_TYPE_ID_ALL] = Route->RouteInfo.BelongsToViews;

        ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] = 
        ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] = RouteCurBestInViews;

        //
        // Update output flags if best route changed
        //

        if (ViewsForCT[RTM_CHANGE_TYPE_ID_BEST])
        {
            *ChangeFlags |= RTM_ROUTE_CHANGE_BEST;
        }

        //
        // Calculate the CNs that need to be notified
        //

        ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                             Dest->DestMarkedBits,
                                             ViewsForCT);

        //
        // Add to the global change list if required
        //
        
        if (NotifyToCNs)
        {
            AddToChangedDestLists(AddrFamInfo,
                                  Dest,
                                  NotifyToCNs);
        }

        RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        //
        // Invalidate any outstanding timers on route
        //

        TimerContext = Route->TimerContext;

        Route->TimerContext = NULL;

        //
        // Did this route delete result in a holddown
        //

        if (MaxHoldTime)
        {
            //
            // We should not delete the destination
            // while we have its routes in holddown
            //

            Dest->HoldRefCount++;

            //
            // Create a timer to remove this hold
            //

            Route->TimerContext = AllocMemory(sizeof(ROUTE_TIMER));

            if (Route->TimerContext)
            {
                Route->TimerContext->Route = Route;

                Success = CreateTimerQueueTimer(&Route->TimerContext->Timer,
                                                AddrFamInfo->RouteTimerQueue,
                                                RouteHolddownTimeoutCallback,
                                                Route->TimerContext,
                                                MaxHoldTime,
                                                0,
                                                0);
                if (Success)
                {
                    REFERENCE_ROUTE(Route, TIMER_REF);
                }
                else
                {
                    Status = GetLastError();

                    FreeMemory(Route->TimerContext);

                    Route->TimerContext = NULL;
                }
            }
        }

        RELEASE_DEST_WRITE_LOCK(Dest);


        //
        // Cancel any outstanding timers on the route
        //

        if (TimerContext)
        {
            if (DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                      TimerContext->Timer,
                                      (HANDLE) -1))
            {
                // Timer cancelled - delete the context

                FreeMemory(TimerContext);

                DEREFERENCE_ROUTE(Route, TIMER_REF);
            }
        }


        //
        // Remove appropriate references on route
        //

        InterlockedDecrement(&AddrFamInfo->NumRoutes);

        DEREFERENCE_ROUTE(Route, CREATION_REF);

        DEREFERENCE_ROUTE(Route, HANDLE_REF);

        return NO_ERROR;
    }
    else
    {
        //
        // This route has already been deleted
        //

        if (TableLocked)
        {
            RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
        }

        RELEASE_DEST_WRITE_LOCK(Dest);

        return ERROR_INVALID_HANDLE;
    }
}


DWORD
WINAPI
RtmHoldDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      ULONG                           HoldTime
    )

/*++

Routine Description:

    Marks a destination to be put in the holddown state
    for a certain time once the last route in any view 
    gets deleted.

    When the last route in a view gets deleted, the old
    best route moved to the holddown route on the dest. 
    The holddown protocols continue to advertise this
    route until the hold expires, even if newer routes
    arrive in the meantime.

    To be perfectly right, we should have this hold time
    per view. But we trade off convergence time in favor
    of memory resources by holding on to the held routes 
    in all views for a single (the max) holddown time.

Arguments:

    RtmRegHandle - RTM registration handle for calling entity,

    DestHandle   - Handle to the dest that is being helddown,

    HoldTime     - Time for which dest is marked for holddown
                   (after the last route to this dest is gone).

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     ViewSet;
    UINT             i, j;
    DWORD            Status;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);

    // Limit caller's interest to set of views supported
    TargetViews &= Entity->OwningAddrFamily->ViewsSupported;

    if (HoldTime == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    //
    // Add a hold if dest is not already deleted
    //

    if (Dest->State != DEST_STATE_DELETED)
    {
        ViewIndices = Entity->OwningAddrFamily->ViewIndexFromId;

        ViewSet = TargetViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                j = ViewIndices[i];

                // Increase hold time in the view if needed

                if (Dest->ViewInfo[j].HoldTime < HoldTime)
                {
                    Dest->ViewInfo[j].HoldTime = HoldTime;
                }
            }
        
            ViewSet >>= 1;
        }

        Dest->ToHoldInViews |= TargetViews;

        Status = NO_ERROR;
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    RELEASE_DEST_WRITE_LOCK(Dest);

    return Status;
}


DWORD
WINAPI
RtmGetRoutePointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                *RoutePointer
    )

/*++

Routine Description:

    Gets a direct pointer to the route for read/write by its owner.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route whose pointer we want,

    RoutePointer      - A pointer to the route is returned for fast
                        direct access by the caller, only if the
                        caller is the owner of the route passed in.
                       
Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PROUTE_INFO       Route;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Return a pointer only if caller owns the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    *RoutePointer = &Route->RouteInfo;

    return NO_ERROR;
}


DWORD
WINAPI
RtmLockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockRoute,
    OUT     PRTM_ROUTE_INFO                *RoutePointer OPTIONAL
    )

/*++

Routine Description:

    Locks/unlocks a route in the route table. This function is
    used to guard the route while it is being updated in place.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route to be locked,

    Exclusive         - TRUE to lock in write mode, else read mode,

    LockRoute         - Flag that tells whether to lock or unlock.

    RoutePointer      - A pointer to the route is returned for fast
                        direct access by the owner of this route.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    DWORD            Status;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Only the owner has perms to lock the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    // Return a direct pointer for use in update

    if (ARGUMENT_PRESENT(RoutePointer))
    {
        *RoutePointer = &Route->RouteInfo;
    }

    //
    // Lock or unlock the route as the case may be
    //

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    Status = NO_ERROR;

    if (LockRoute)
    {
        if (Exclusive)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
        }
        else
        {
            ACQUIRE_DEST_READ_LOCK(Dest);
        }

        //
        // You are done if the route wasn't deleted
        //

        if (Route->RouteInfo.State == RTM_ROUTE_STATE_CREATED)
        {
            return NO_ERROR;
        }
        
        Status = ERROR_INVALID_HANDLE;
    }

    //
    // This is an unlock or a case of a failed lock
    //

    if (Exclusive)
    {
        RELEASE_DEST_WRITE_LOCK(Dest);
    }
    else
    {
        RELEASE_DEST_READ_LOCK(Dest);
    }

    return Status;
}


DWORD
WINAPI
RtmUpdateAndUnlockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                ChangeType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    )

/*++

Routine Description:

    Updates the position of the route on the list of routes on
    the dest, and adjusts best route information on the dest.

    This function invocation is part of the following sequence,

        The caller calls RtmLockRoute to lock the route.
        [ Actually this locks the route's destination ]

        The caller uses a direct pointer to the route
        to update the route in place. Only ceratin set of
        route fields can be changed using this method.

        The caller then calls RtmUpdateAndUnlockRoute to 
        inform RTM of the change, which causes the dest to
        be updated by RTM to reflect the new route info.

        Finally the caller releases the locks taken in
        RtmLockRoute by calling RtmLockRoute with FALSE.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Route that has been changed in place,

    ChangeFlags       - "If the best route changed" is returned,

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;
    PROUTE_LIST      RouteList;

    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    PROUTE_INFO      CurrRoute;
    PROUTE_INFO      BestRoute;

    LONG             PrefChanged;
    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     BelongedToViews;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     WorseInViews;
    RTM_VIEW_SET     BetterInViews;
    RTM_VIEW_SET     RouteNewBestInViews;
    RTM_VIEW_SET     RouteCurBestInViews;

    PROUTE_TIMER     TimerContext;

    ULONG            NotifyToCNs;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];

    PLIST_ENTRY      p;
    UINT             i;
    DWORD            Status;
    BOOL             Success;

    UNREFERENCED_PARAMETER(ChangeType);
    UNREFERENCED_PARAMETER(NotifyHandle);

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    //
    // Only the owner has perms to update the route
    //

    if (Route->RouteInfo.RouteOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Validate the updated route before re-adjusting
    //

    // We should be adding only to supported views

    Route->RouteInfo.BelongsToViews &= AddrFamInfo->ViewsSupported;

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    // Print the route and the dest in the traces

#if DBG_TRACE

        //
        // Print the route and the dest in the tracing
        //

        if (TRACING_ENABLED(ROUTE))
        {
            ULONG TempAddr, TempMask;
            
            RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
            Trace0(ROUTE, "Updating Route with address: ");
            TracePrintAddress(ROUTE, TempAddr, TempMask);
            Trace2(ROUTE, "Dest = %p and Route = %p\n", Dest, Route);
        }
#endif

    //
    // Route has been updated in place and the route's
    // PrefInfo and BelongsToViews values have changed
    //

    *ChangeFlags = 0;

    //
    // Check if route's preference has gone up or down
    //

    PrefChanged = 0;

    if (PrefChanged == 0)
    {
        // Compare the pref with that of the prev route in list

        if (Route->DestLE.Blink != &Dest->RouteList)
        {
            CurrRoute = CONTAINING_RECORD(Route->DestLE.Blink, 
                                          ROUTE_INFO,
                                          DestLE);

            if (ComparePref(&CurrRoute->RouteInfo,
                            &Route->RouteInfo) < 0)
            {
                // Preference has gone up from prev value

                PrefChanged = +1;

                //
                // Re-Insert the route in sorted pref order
                //

                RemoveEntryList(&Route->DestLE);

                for (p = CurrRoute->DestLE.Blink; 
                                         p != &Dest->RouteList; 
                                                            p = p->Blink)
                {
                    CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                    if (ComparePref(&CurrRoute->RouteInfo,
                                    &Route->RouteInfo) >= 0)
                    {
                        break;
                    }
                }        
                
                InsertHeadList(p, &Route->DestLE);
            }
        }
    }

    if (PrefChanged == 0)
    {
        // Compare the pref with that of the next route in list

        if (Route->DestLE.Flink != &Dest->RouteList)
        {
            CurrRoute = CONTAINING_RECORD(Route->DestLE.Flink, 
                                          ROUTE_INFO,
                                          DestLE);

            if (ComparePref(&CurrRoute->RouteInfo,
                            &Route->RouteInfo) > 0)
            {
                // Preference has gone down from prev value

                PrefChanged = -1;

                //
                // Re-Insert the route in sorted pref order
                //

                RemoveEntryList(&Route->DestLE);

                for (p = CurrRoute->DestLE.Flink; 
                                         p != &Dest->RouteList; 
                                                            p = p->Flink)
                {
                    CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                    if (ComparePref(&CurrRoute->RouteInfo,
                                    &Route->RouteInfo) <= 0)
                    {
                        break;
                    }
                }        
                
                InsertTailList(p, &Route->DestLE);
            }
        }
    }

    //
    // Adjust the best route information in each view
    //

    ViewIndices = AddrFamInfo->ViewIndexFromId;

    BelongedToViews = Dest->BelongsToViews;

    //
    // We have 3 cases that this add / update can trigger,
    // In a particular view -
    // 1) Route was the view's best route but not anymore,
    // 2) Route was and is still the best route after add,
    // 3) Route has become this view's "new" best route.
    //
    // As we have no idea what changed in the case of (2),
    // we will trigger best route and forwarding changes.
    //

    RouteCurBestInViews = 0;
    RouteNewBestInViews = 0;

    //
    // Check if this route is best in any view
    //

    ViewSet = BelongedToViews;

    for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            // Update dest information in view i

            // Get best route in current view
            BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

            // Was this the best route in view ?
            if (BestRoute == Route)
            {
                RouteCurBestInViews |= VIEW_MASK(i);
            }
        }
        
        ViewSet >>= 1;
    }

    //
    // Compute the views where route got worse
    //

    WorseInViews = RouteCurBestInViews;

    if (PrefChanged >= 0)
    {
        WorseInViews &= ~Route->RouteInfo.BelongsToViews;
    }

    //
    // In the views that you were the best, update best route
    //

    for (p = Dest->RouteList.Flink; 
                  WorseInViews && (p != &Dest->RouteList); 
                                                         p = p->Flink)
    {
        CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);
        
        ViewSet = CurrRoute->RouteInfo.BelongsToViews & WorseInViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                if (BestRoute != CurrRoute)
                {
                    Dest->ViewInfo[ViewIndices[i]].BestRoute = CurrRoute;
                }
            }

            ViewSet >>= 1;
        }

        WorseInViews &= ~CurrRoute->RouteInfo.BelongsToViews;
    }

    //
    // For some views, we end up not having a best route
    //

    ViewSet = WorseInViews;

    for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            Dest->ViewInfo[ViewIndices[i]].BestRoute = NULL;
        }
        
        ViewSet >>= 1;
    }

    Dest->BelongsToViews &= ~WorseInViews;


    //
    // Compute the views where route got better
    //

    BetterInViews = Route->RouteInfo.BelongsToViews;

    //
    // Check if route is best in any of its views
    //

    ViewSet = BetterInViews;
 
    for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            //
            // Update dest information in view i
            //

            // Get best route in current view
            BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

            //
            // Is route most preferred now, while
            // it was not so before this update ?
            //
                
            if ((!BestRoute) || 
                     ((BestRoute != Route) &&
                            (ComparePref(&Route->RouteInfo,
                                         &BestRoute->RouteInfo) > 0)))
            {
                Dest->ViewInfo[ViewIndices[i]].BestRoute = Route;

                RouteNewBestInViews |= VIEW_MASK(i);
            }
        }
        
        ViewSet >>= 1;
    }

    Dest->BelongsToViews |= BetterInViews;


    //
    // Compute the views for each change type occurred
    //

    //
    // All views affected by this add are notified
    // -views route belonged to and now belongs to
    //

    ViewsForCT[RTM_CHANGE_TYPE_ID_ALL]  = 
        BelongedToViews | Route->RouteInfo.BelongsToViews;

    //
    // If the route was or is now the best route then
    // it is considered a best and forwarding change
    // as we cannot tell better what exactly changed
    //

    ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] = 
    ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] = 
        RouteCurBestInViews | RouteNewBestInViews;

    //
    // Update output flags if best route changed
    //

    if (ViewsForCT[RTM_CHANGE_TYPE_ID_BEST])
    {
        *ChangeFlags |= RTM_ROUTE_CHANGE_BEST;
    }

    //
    // Calculate the CNs that need to be notified
    //

    ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                         Dest->DestMarkedBits,
                                         ViewsForCT);

    //
    // Add to the global change list if required
    //
        
    if (NotifyToCNs)
    {
        AddToChangedDestLists(AddrFamInfo,
                              Dest,
                              NotifyToCNs);
    }

    RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    //
    // Remove from old route list, and put in the new one
    //

    // Check the route list handle for validity

    if (ARGUMENT_PRESENT(RouteListHandle))
    {
        RouteList = ROUTE_LIST_FROM_HANDLE(RouteListHandle);
    
        if (RouteList)
        {
            ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);
        
            if (!IsListEmpty(&Route->RouteListLE))
            {
                RemoveEntryList(&Route->RouteListLE);
            }
            else
            {
                REFERENCE_ROUTE(Route, LIST_REF);
            }

            InsertTailList(&RouteList->ListHead, &Route->RouteListLE);

            RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);
        }
    }

    //
    // Set a timer if we want to age out the route
    //

    TimerContext = Route->TimerContext;

    if (TimeToLive == INFINITE)
    {
        Route->TimerContext = NULL;
    }
    else
    {
        Route->TimerContext = AllocMemory(sizeof(ROUTE_TIMER));

        if (Route->TimerContext)
        {
            Route->TimerContext->Route = Route;

            Success = CreateTimerQueueTimer(&Route->TimerContext->Timer,
                                            AddrFamInfo->RouteTimerQueue,
                                            RouteExpiryTimeoutCallback,
                                            Route->TimerContext,
                                            TimeToLive,
                                            0,
                                            0);
            if (Success)
            {
                REFERENCE_ROUTE(Route, TIMER_REF);
            }
            else
            {
                Status = GetLastError();

                FreeMemory(Route->TimerContext);

                Route->TimerContext = NULL;
            }
        }
    }

    RELEASE_DEST_WRITE_LOCK(Dest);

    //
    // Cancel the timer that was attached to the route
    //

    if (TimerContext)
    {
        if (DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                  TimerContext->Timer,
                                  (HANDLE) -1))
        {
            // Timer cancelled - delete the context

            FreeMemory(TimerContext);

            DEREFERENCE_ROUTE(Route, TIMER_REF);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmtest.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmtest.h

Abstract:
    Contains defines for the RTMv2 test program.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

#include <nt.h>

#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>

#include <stdlib.h>
#include <assert.h>
#include <malloc.h>

#include "lkuptst.h"

#include "apitest.h"

// Disable warnings for `do { ; } while (FALSE);'
#pragma warning(disable: 4127)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmtimer.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmtimer.c

Abstract:

    Contains timer callbacks for handling RTM
    functions like aging out routes etc.
    
Author:

    Chaitanya Kodeboyina (chaitk)   14-Sep-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


VOID 
NTAPI
RouteExpiryTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    )

/*++

Routine Description:

    This routine is invoked when the expiry timer 
    associated with a route fires. At this time, 
    the route needs to be aged out.

Arguments:

    Context           - Context for this timer callback 

    TimeOut           - TRUE if the timer fired,
                        FALSE if wait satisfied.

Return Value:

    None

--*/

{
    PRTM_ENTITY_HANDLE EntityHandle;
    PRTM_ROUTE_HANDLE  RouteHandle;
    PADDRFAM_INFO      AddrFamInfo;
    PENTITY_INFO       Entity;
    PDEST_INFO         Dest;
    PROUTE_INFO        Route;
    DWORD              ChangeFlags;
    BOOL               Success;
    DWORD              Status;

    UNREFERENCED_PARAMETER(TimeOut);

    Route = (PROUTE_INFO) ((PROUTE_TIMER)Context)->Route;

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    //
    // Has the timer has not been updated after it fired
    //

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    if (Route->TimerContext != Context)
    {
        RELEASE_DEST_WRITE_LOCK(Dest);

        //
        // The timer has been updated after it fired,
        // This timer context is freed by the update
        //

        return;
    }

    //
    // The timer is still valid for this route,
    // Indicate to entity and free the context
    //
    
    Route->TimerContext = NULL;
    
    RELEASE_DEST_WRITE_LOCK(Dest);

    //
    // Inform the owner that the route has expired
    //

    EntityHandle = Route->RouteInfo.RouteOwner;

    Entity = ENTITY_FROM_HANDLE(EntityHandle);

    AddrFamInfo = Entity->OwningAddrFamily;

    RouteHandle = MAKE_HANDLE_FROM_POINTER(Route);

    REFERENCE_ROUTE(Route, HANDLE_REF);

    Status = ERROR_NOT_SUPPORTED;

    if (Entity->EventCallback)
    {
        //
        // This callback can turn back and post RTM calls,
        // so release locks before invoking this callback
        //

        Status = Entity->EventCallback(EntityHandle,
                                       RTM_ROUTE_EXPIRED,
                                       RouteHandle,
                                       &Route->RouteInfo);
    }

    if (Status == ERROR_NOT_SUPPORTED)
    {
        //
        // Delete the route as the owner does not care
        //

        Status = RtmDeleteRouteToDest(EntityHandle,
                                      RouteHandle,
                                      &ChangeFlags);

        //
        // The route could already have been deleted here
        //

        ASSERT((Status == NO_ERROR) || 
               (Status == ERROR_NOT_FOUND) ||
               (Status == ERROR_INVALID_HANDLE));
    }

    //
    // Free the context as we do not need it now
    //

    Success = DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                    ((PROUTE_TIMER)Context)->Timer,
                                    NULL);
    // ASSERT(Success);

    FreeMemory(Context);

    DEREFERENCE_ROUTE(Route, TIMER_REF);

    return;
}


VOID 
NTAPI
RouteHolddownTimeoutCallback (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    )

/*++

Routine Description:

    This routine is invoked when holddown timer 
    associated with a route fires. At this time, 
    the route needs to be taken out of holddown.

Arguments:

    Context           - Context for this timer callback 

    TimeOut           - TRUE if the timer fired,
                        FALSE if wait satisfied.

Return Value:

    None

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    PROUTE_INFO      HoldRoute;
    PLOOKUP_LINKAGE  DestData;
    ULONG            NotifyToCNs;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];
    UINT             i;
    BOOL             Success;
    DWORD            Status;

    UNREFERENCED_PARAMETER(TimeOut);

    Route = (PROUTE_INFO) ((PROUTE_TIMER)Context)->Route;

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    Entity = ENTITY_FROM_HANDLE(Route->RouteInfo.RouteOwner);

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // The route must surely be in holddown by this time
    //

    ASSERT(Route->RouteInfo.State == RTM_ROUTE_STATE_DELETED);

    //
    // Has the timer has not been updated after it fired
    //

    ACQUIRE_DEST_WRITE_LOCK(Dest);

    if (Route->TimerContext != Context)
    {
        RELEASE_DEST_WRITE_LOCK(Dest);

        ASSERT(FALSE);

        //
        // The timer has been updated after it fired,
        // This timer context is freed by the update
        //

        return;
    }

    //
    // The timer is still valid for this route
    //

    //
    // Remove this holddown route from the dest
    //

    for (i = 0; i < AddrFamInfo->NumberOfViews; i++)
    {
        HoldRoute = Dest->ViewInfo[i].HoldRoute;

        if (HoldRoute == Route)
        {
            DEREFERENCE_ROUTE(HoldRoute, HOLD_REF); 

            Dest->ViewInfo[i].HoldRoute = NULL;
        }
    }

    //
    // We need to generate notifications for any
    // holddown protocols interesed in this dest
    //

    //
    // Calculate the CNs that need to be notified
    //

    ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    for (i = 0; i < RTM_NUM_CHANGE_TYPES; i++)
    {
        ViewsForCT[i] = AddrFamInfo->ViewsSupported;
    }

    NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                         Dest->DestMarkedBits,
                                         ViewsForCT);

    //
    // Add to the global change list if required
    //
        
    if (NotifyToCNs)
    {
        AddToChangedDestLists(AddrFamInfo,
                              Dest,
                              NotifyToCNs);
    }

    RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);


    //
    // Reset the timer context and free it later
    //

    Route->TimerContext = NULL;

    //
    // Reduce hold ref so that dest can be deleted
    //

    ASSERT(Dest->HoldRefCount > 0);

    if (Dest->NumRoutes || (Dest->HoldRefCount > 1))
    {
        Dest->HoldRefCount--;
    }
    else
    {
        //
        // Removal of hold might result in dest deletion
        //

        RELEASE_DEST_WRITE_LOCK(Dest);

        ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        Dest->HoldRefCount--;

        if ((Dest->NumRoutes == 0) && (Dest->HoldRefCount == 0))
        {
            Dest->State = DEST_STATE_DELETED;

            Status = DeleteFromTable(AddrFamInfo->RouteTable,
                                     Dest->DestAddress.NumBits,
                                     Dest->DestAddress.AddrBits,
                                     NULL,
                                     &DestData);
                
            ASSERT(SUCCESS(Status));

            AddrFamInfo->NumDests--;
        }

        RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
    }

    RELEASE_DEST_WRITE_LOCK(Dest);

    //
    // Free the context as we do not need it now
    //

    Success = DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                    ((PROUTE_TIMER)Context)->Timer,
                                    NULL);
    // ASSERT(Success);

    FreeMemory(Context);

    DEREFERENCE_ROUTE(Route, TIMER_REF);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\rtmv2\rtmrout.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmrout.h

Abstract:

    Contains definitions for RTM objects like
    destinations, routes and next hops.

Author:

    Chaitanya Kodeboyina (chaitk)   21-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMROUT_H__
#define __ROUTING_RTMROUT_H__

//
// Forward declarations for various Info Blocks
//
typedef struct _DEST_INFO     DEST_INFO;
typedef struct _ROUTE_INFO    ROUTE_INFO;
typedef struct _NEXTHOP_INFO  NEXTHOP_INFO;

//                                                                             
// Address Family independent dest structure                                   
//                                                                             
typedef struct _DEST_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    SINGLE_LIST_ENTRY ChangeListLE;     // Linkage on the list of changed dests

    LOOKUP_LINKAGE    LookupLinkage;    // Linkage into owning lookup structure

    PVOID             DestLock;         // Dynamic lock that protects this dest
 
    DWORD             DestMarkedBits;   // Bit N set => Nth CN has marked dest
    DWORD             DestChangedBits;  // Bit N set => Nth CN has a change
    DWORD             DestOnQueueBits;  // Bit N set => Dest on Nth CN's queue

    UINT              NumRoutes;        // Number of routes to destination
    LIST_ENTRY        RouteList;        // A list of routes to destination

    PVOID            *OpaqueInfoPtrs;   // Array of Opaque Info Pointers

    RTM_NET_ADDRESS   DestAddress;      // Network Address unique to this dest

    FILETIME          LastChanged;      // Last time destination was modified 

    USHORT            State;            // State of the destination

    USHORT            HoldRefCount;     // RefCount != 0 => Dest In Holddown

    RTM_VIEW_SET      BelongsToViews;   // View that this dest belongs too

    RTM_VIEW_SET      ToHoldInViews;    // Views in which holddown will apply

    struct 
    {                                   //
        ROUTE_INFO   *BestRoute;        // Best route to dest in each view
        ROUTE_INFO   *HoldRoute;        // The holddown route in each view
        ULONG         HoldTime;         // Time for which route is in held
    }                   ViewInfo[1];    //
}
DEST_INFO, *PDEST_INFO;

//
// Destination State
//
#define DEST_STATE_CREATED            0
#define DEST_STATE_DELETED            1


//
// Context used in timing out a route
//

typedef struct _ROUTE_TIMER
{
    HANDLE           Timer;             // Handle to the timer used for expiry

    PVOID            Route;             // Route being expired by this timer
}
ROUTE_TIMER, *PROUTE_TIMER;


//
// Address Family Independent route structure
//
typedef struct _ROUTE_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    LIST_ENTRY        DestLE;           // Linkage on list of routes on dest

    LIST_ENTRY        RouteListLE;      // Linkage on an entity's route list

    PROUTE_TIMER      TimerContext;     // Timer used to age-out or holddown

    RTM_ROUTE_INFO    RouteInfo;        // Part exposed directly to the owner
}
ROUTE_INFO, *PROUTE_INFO;


//
// Node in the next hop tree of which all the
// next-hops with a particular addr hang off
//
typedef struct _NEXTHOP_LIST
{
    LOOKUP_LINKAGE    LookupLinkage;    // Linkage into owning lookup structure

    LIST_ENTRY        NextHopsList;     // Head of the list of next hops
}
NEXTHOP_LIST, *PNEXTHOP_LIST;


//
// Address Family Independent next-hop structure
//
typedef struct _NEXTHOP_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    LIST_ENTRY        NextHopsLE;       // Linkage into holding nexthops list
    
    RTM_NEXTHOP_INFO  NextHopInfo;      // Part exposed directly to the owner
}
NEXTHOP_INFO, *PNEXTHOP_INFO;


//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_DEST_READ_LOCK(Dest)                         \
    ACQUIRE_DYNAMIC_READ_LOCK(&Dest->DestLock)

#define RELEASE_DEST_READ_LOCK(Dest)                         \
    RELEASE_DYNAMIC_READ_LOCK(&Dest->DestLock)

#define ACQUIRE_DEST_WRITE_LOCK(Dest)                        \
    ACQUIRE_DYNAMIC_WRITE_LOCK(&Dest->DestLock)

#define RELEASE_DEST_WRITE_LOCK(Dest)                        \
    RELEASE_DYNAMIC_WRITE_LOCK(&Dest->DestLock)

//
// Macros for comparing two routes using their preferences
//

BOOL
__inline
IsPrefEqual (
    IN      PRTM_ROUTE_INFO                 RouteInfo1, 
    IN      PRTM_ROUTE_INFO                 RouteInfo2
    )
{
 return ((RouteInfo1->PrefInfo.Metric == RouteInfo2->PrefInfo.Metric) &&
         (RouteInfo1->PrefInfo.Preference == RouteInfo2->PrefInfo.Preference));
}

LONG
__inline
ComparePref (
    IN      PRTM_ROUTE_INFO                 RouteInfo1, 
    IN      PRTM_ROUTE_INFO                 RouteInfo2
    )
{
    // Lower preference means "more preferred"

    if (RouteInfo1->PrefInfo.Preference < RouteInfo2->PrefInfo.Preference)
    { return +1; }
    else
    if (RouteInfo1->PrefInfo.Preference > RouteInfo2->PrefInfo.Preference)
    { return -1; }
    else
    if (RouteInfo1->PrefInfo.Metric < RouteInfo2->PrefInfo.Metric)
    { return +1; }
    else
    if (RouteInfo1->PrefInfo.Metric > RouteInfo2->PrefInfo.Metric)
    { return -1; }

    return  0;
}


//
// Dest, Route, NextHop Helper Functions
//

DWORD
CreateDest (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      PRTM_NET_ADDRESS                DestAddress,
    OUT     PDEST_INFO                     *Dest
    );

DWORD
DestroyDest (
    IN      PDEST_INFO                      Dest
    );

DWORD
CreateRoute (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    OUT     PROUTE_INFO                    *Route
    );

VOID
ComputeRouteInfoChange(
    IN      PRTM_ROUTE_INFO                 OldRouteInfo,
    IN      PRTM_ROUTE_INFO                 NewRouteInfo,
    IN      ULONG                           PrefChanged,
    OUT     PULONG                          RouteInfoChanged,
    OUT     PULONG                          ForwardingInfoChanged
    );

VOID
CopyToRoute (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      PROUTE_INFO                     Route
    );

DWORD
DestroyRoute (
    IN      PROUTE_INFO                     Route
    );

DWORD
CreateNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PNEXTHOP_INFO                  *NextHop
    );

VOID
CopyToNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN      PNEXTHOP_INFO                   NextHop
    );

DWORD
DestroyNextHop (
    IN      PNEXTHOP_INFO                   NextHop
    );

DWORD
FindNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT     PLIST_ENTRY                    *NextHopLE
    );

#endif //__ROUTING_RTMROUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\dhcp.c ===
/*
    File    dhcp.c

    Implementation of the upgrade of dhcp relay agent from 
    nt 4.0 to nt 5.0 router.

    Paul Mayfield, 9/15/97


    Reference files:    routing\inc\ipbootp.h

    DHCP Relay Agent parameter mapping table:
    Relay Agent         per Interface           Global
    ===========         =============           ======
    "HopsThreshold"     Max Hop Count
    "SecsThreshold"     Min Secs Since Boot
    "LogMessages"                               Logging Level			
    "DHCPServers"                               Servers
*/

#include "upgrade.h"
#include <ipbootp.h>
#include <winsock2.h>
#include <routprot.h>

static WCHAR szTempKey[] = L"DeleteMe";
static HKEY hkRouter = NULL;
static HKEY hkTemp = NULL;

// Restore the registry from from backup 
// and make sure all global handles are opened
DWORD DhcpPrepareRegistry(
        IN PWCHAR BackupFileName) 
{
	DWORD dwErr, dwDisposition;

	// Get access to the router registry key
	dwErr = UtlAccessRouterKey(&hkRouter);
	if (dwErr != ERROR_SUCCESS) {
		PrintMessage(L"Unable to access router key.\n");
		return dwErr;
	}

	// Restore the Dhcp parameters from backup
	__try {
		// Open up the temporary key
		dwErr = RegCreateKeyEx(
		            hkRouter,
		            szTempKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkTemp,
		            &dwDisposition);
		if (dwErr!=ERROR_SUCCESS)
			return dwErr;

		// Restore saved registry info to the temp key
		UtlSetupRestorePrivilege(TRUE);
		dwErr = RegRestoreKeyW(
		            hkTemp,
		            BackupFileName,
		            0);
		if (dwErr != ERROR_SUCCESS) 
			return dwErr;
	}
	__finally {
		UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

// Cleanup the work done in the registry
DWORD DhcpCleanupRegistry() {

	if (hkTemp) 
		RegCloseKey(hkTemp);
		
	if (hkRouter) {
		RegDeleteKey(hkRouter,szTempKey);
		RegCloseKey(hkRouter);
	}
	
    hkTemp = NULL;
    hkRouter = NULL;
    
	return NO_ERROR;
}

// Reads in the list of configured dhcp servers
DWORD DhcpReadServerList(
        IN LPBYTE * ppServerList, 
        HKEY hkParams) 
{
    DWORD dwErr, dwType, dwSize = 0;
    LPSTR szServerValName = "DHCPServers";

    if (!ppServerList)
        return ERROR_INVALID_PARAMETER;

    dwErr = RegQueryValueExA(
                hkParams,
                szServerValName,
                NULL,
                &dwType,
                NULL,
                &dwSize);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    if (dwSize == 0)
    {
        *ppServerList = NULL;
        return NO_ERROR;
    }

    *ppServerList = (LPBYTE) UtlAlloc(dwSize);
    if (! (*ppServerList))
        return ERROR_NOT_ENOUGH_MEMORY;

    dwErr = RegQueryValueExA(
                hkParams,
                szServerValName,
                NULL,
                &dwType,
                *ppServerList,
                &dwSize);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    return NO_ERROR;
}

// Frees the resources associated with a list of dhcp servers
DWORD DhcpFreeServerList(LPBYTE * ppServerList) {

    if ((ppServerList) && (*ppServerList))
        UtlFree(*ppServerList);
        
    return NO_ERROR;
}

// Gets the count of dhcp servers from this list read from 
// the registry
DWORD DhcpGetServerCount(
        IN LPBYTE pServerList, 
        LPDWORD lpdwSrvCount) 
{
    LPBYTE ptr = pServerList;

    if (!lpdwSrvCount)
        return ERROR_INVALID_PARAMETER;

    *lpdwSrvCount = 0;
    if (ptr) {
        while (*ptr) {
            (*lpdwSrvCount)++;
            ptr += strlen(ptr);
        }
    }

    return NO_ERROR;
}

// Converts a server string to a dword ip address
DWORD DhcpAnsiSrvToDwordSrv(
        IN LPSTR AnsiIpAddr, 
        OUT LPDWORD pAddr) 
{
    *pAddr = inet_addr(AnsiIpAddr);
    
    return NO_ERROR;
}

// Updates the Dhcp global information
DWORD DhcpUpgradeGlobalInfo(
        IN dwt * DhcpParams, 
        IN LPBYTE pServerList) 
{
    DWORD dwErr, dwSrvCount, dwVal, dwConfigSize, dwTransSize;
    DWORD dwNewSize;
    LPBYTE pSrvList = pServerList;
    LPDWORD pAddr;

    IPBOOTP_GLOBAL_CONFIG DhcpGlobalConfig = {
        IPBOOTP_LOGGING_ERROR,              // Logging level
        1024 * 1024,                        // Max recv-queue size
        0                                   // Server count
    };
    
    PIPBOOTP_GLOBAL_CONFIG pNewConfig = NULL;
    LPBYTE pTransInfo = NULL, pNewTransInfo = NULL;
    HANDLE hSvrConfig = NULL, hTransport = NULL;

    __try {
        // Initialize the parameters with what was read from previous config
        dwErr = dwtGetValue(DhcpParams, L"LogMessages", &dwVal);
        if (dwErr == NO_ERROR)
            DhcpGlobalConfig.GC_LoggingLevel = dwVal;
            
        dwErr = DhcpGetServerCount(pServerList, &dwSrvCount);
        if (dwErr != NO_ERROR)
            return dwErr;
        DhcpGlobalConfig.GC_ServerCount = dwSrvCount;

        // Prepare a global information variable length structure
        dwConfigSize = IPBOOTP_GLOBAL_CONFIG_SIZE(&DhcpGlobalConfig);
        pNewConfig = (PIPBOOTP_GLOBAL_CONFIG) UtlAlloc(dwConfigSize);
        if (!pNewConfig)
            return ERROR_NOT_ENOUGH_MEMORY;
        memset(pNewConfig, 0, dwConfigSize);
        memcpy(pNewConfig, &DhcpGlobalConfig, sizeof(IPBOOTP_GLOBAL_CONFIG));

        // Fill in the Dhcp Server Addresss
        pSrvList = pServerList;
        pAddr = (LPDWORD)
                    (((ULONG_PTR)pNewConfig) + sizeof(IPBOOTP_GLOBAL_CONFIG));
        while ((pSrvList) && (*pSrvList)) 
        {
            dwErr = DhcpAnsiSrvToDwordSrv(pSrvList, pAddr);
            if (dwErr != ERROR_SUCCESS)
                return dwErr;
            pSrvList += strlen(pSrvList);
            pAddr++;
        }
    
        // Set the new global configuration
        dwErr = MprConfigServerConnect(NULL, &hSvrConfig);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetHandle(hSvrConfig, PID_IP, &hTransport);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetInfo(
                    hSvrConfig,
                    hTransport,
                    &pTransInfo,
                    &dwTransSize,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = UtlUpdateInfoBlock(
                    TRUE,
                    pTransInfo,
                    MS_IP_BOOTP,
                    dwConfigSize,
                    1,
                    (LPBYTE)pNewConfig,
                    &pNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportSetInfo(
                    hSvrConfig,
                    hTransport,
                    pNewTransInfo,
                    dwNewSize,
                    NULL,
                    0,
                    NULL);
        if (dwErr != NO_ERROR)
            return NO_ERROR;

    }
    __finally {
        if (pNewConfig) 
            UtlFree(pNewConfig);
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
        if (hSvrConfig)
            MprConfigServerDisconnect(hSvrConfig);
    }
    
    return NO_ERROR;
}

//
// Callback interface enumeration function that updates the if
// with a dhcp if configuration blob.
//
// Return TRUE to continue enumeration, FALSE to stop.
//
BOOL DhcpInstallInterface(
        IN HANDLE hConfig,
        IN MPR_INTERFACE_0 * pIf,
        IN HANDLE hUserData)
{
    IPBOOTP_IF_CONFIG * pConfig = (IPBOOTP_IF_CONFIG*)hUserData;
    LPBYTE pTransInfo = NULL, pNewTransInfo = NULL;
    HANDLE hTransport = NULL;
    DWORD dwErr, dwTransSize, dwNewSize; 
    
    // Is this a LAN or a WAN interface 
    if (pIf->dwIfType != ROUTER_IF_TYPE_DEDICATED   &&
        pIf->dwIfType != ROUTER_IF_TYPE_HOME_ROUTER &&
        pIf->dwIfType != ROUTER_IF_TYPE_FULL_ROUTER)
        return TRUE;

    // Get the handle to ip info
    dwErr = MprConfigInterfaceTransportGetHandle(
                hConfig,
                pIf->hInterface,
                PID_IP,
                &hTransport);
    if (dwErr != NO_ERROR)
        return TRUE;

    // Get the ip info
    dwErr = MprConfigInterfaceTransportGetInfo(
                hConfig,
                pIf->hInterface,
                hTransport,
                &pTransInfo,
                &dwTransSize);
    if (dwErr != NO_ERROR)
        return TRUE;

    do {
        // Update the DHCP info
        dwErr = UtlUpdateInfoBlock(
                    TRUE,
                    pTransInfo,
                    MS_IP_BOOTP,
                    sizeof(IPBOOTP_IF_CONFIG),
                    1,
                    (LPBYTE)pConfig,
                    &pNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR)
            break;
            
        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    pNewTransInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR)
            break;
            
    } while (FALSE);            

    // Cleanup
    {
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
    }

    return TRUE;
}


// Upgrade all of the interfaces to have dhcp information
DWORD DhcpUpgradeInterfaces(
        IN dwt * DhcpParams) 
{
    DWORD dwErr, dwVal;
    
    IPBOOTP_IF_CONFIG DhcpIfConfig = 
    {
        0,                          // State (read-only)
        IPBOOTP_RELAY_ENABLED,      // Relay-mode
        4,                          // Max hop-count
        4                           // Min seconds-since-boot
    };

    // Initialize the hops threshold
    dwErr = dwtGetValue(DhcpParams, L"HopsThreshold", &dwVal);
    if (dwErr == NO_ERROR)
        DhcpIfConfig.IC_MaxHopCount = dwVal;

    // Initialize the seconds threshold        
    dwErr = dwtGetValue(DhcpParams, L"SecsThreshold", &dwVal);
    if (dwErr == NO_ERROR)
        DhcpIfConfig.IC_MinSecondsSinceBoot = dwVal;

    // Loop through the interfaces, adding the dhcp blob as
    // appropriate
    dwErr = UtlEnumerateInterfaces(
                DhcpInstallInterface,
                (HANDLE)&DhcpIfConfig);

    return dwErr;
}

//
// Restores the Dhcp parameters that were saved before upgrade.
// assumes that the pre-upgrade parameters are being stored 
// temporarily in hkTemp
//
DWORD DhcpMigrateParams() 
{
	DWORD dwErr, dwVal;
	dwt DhcpParams;
    LPBYTE ServerList;

	__try {
    	// Load in the parameters that were set for Dhcp
		dwErr = dwtLoadRegistyTable(&DhcpParams, hkTemp);
		if (dwErr != NO_ERROR)
			return dwErr;

        // Load in the list of dhcp servers
        dwErr = DhcpReadServerList(&ServerList, hkTemp);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Migrate the various types of paramters
        dwErr = DhcpUpgradeGlobalInfo(&DhcpParams, ServerList);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Migrate the per-interface parameters
        dwErr = DhcpUpgradeInterfaces(&DhcpParams);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
	__finally {
		dwtCleanup(&DhcpParams);
        DhcpFreeServerList(&ServerList);
	}

	return NO_ERROR;
}

//
// Upgrades Dhcp relay agent into nt 5.0 router
// 
DWORD DhcpToRouterUpgrade(
        IN PWCHAR FileName) 
{
	DWORD dwErr;

	__try {
		// Restore the registry from the backup file
		dwErr = DhcpPrepareRegistry(FileName);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Migrate Dhcp's parameters to the appropriate 
		// new locations
		dwErr = DhcpMigrateParams();
		if (dwErr != NO_ERROR)
			return dwErr;

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
			return dwErr;
		}
			
	}
	__finally {
		DhcpCleanupRegistry();
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\radius.c ===
/*
    File: radius.c

    Upgrades radius configuration from nt4 steelhead to win2k rras.

    Paul Mayfield, 2/8/99
*/

#include "upgrade.h"

// 
// Information describing a radius server
//
typedef struct _RAD_SERVER_NODE
{
    PWCHAR pszName;
    
    DWORD dwTimeout;
    DWORD dwAuthPort;
    DWORD dwAcctPort;
    DWORD dwScore;
    BOOL  bEnableAuth;
    BOOL  bEnableAcct;
    BOOL  bAccountingOnOff;
    
    struct _RAD_SERVER_NODE * pNext;
    
} RAD_SERVER_NODE;

//
// A radius server list
//
typedef struct _RAD_SERVER_LIST
{
    RAD_SERVER_NODE* pHead;
    DWORD dwCount;
    
} RAD_SERVER_LIST;

//
// Info used by routines that manipulate the nt5 radius registry hive
//
typedef struct _RAD_CONFIG_INFO
{
    HKEY hkAuthServers;
    HKEY hkAuthProviders;

    HKEY hkAcctServers;
    HKEY hkAcctProviders;
    
} RAD_CONFIG_INFO;

//
// Registry value names
//
// The all caps ones were taken from nt40 src.
//
static const WCHAR PSZTIMEOUT[]          = L"Timeout";
static const WCHAR PSZAUTHPORT[]         = L"AuthPort";
static const WCHAR PSZACCTPORT[]         = L"AcctPort";
static const WCHAR PSZENABLEACCT[]       = L"EnableAccounting";
static const WCHAR PSZENABLEACCTONOFF[]  = L"EnableAccountingOnOff";
static const WCHAR PSZENABLEAUTH[]       = L"EnableAuthentication";
static const WCHAR PSZSCORE[]            = L"Score";

static const WCHAR pszTempRegKey[]       = L"Temp";
static const WCHAR pszAccounting[]       = L"Accounting\\Providers";        
static const WCHAR pszAuthentication[]   = L"Authentication\\Providers";
static const WCHAR pszActiveProvider[]   = L"ActiveProvider";
static const WCHAR pszRadServersFmt[]    = L"%s\\Servers";
static const WCHAR pszServers[]          = L"Servers";

static const WCHAR pszGuidRadAuth[]      = 
    L"{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}";

static const WCHAR pszGuidRadAcct[]      = 
    L"{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}";

    
// Defaults
//
#define DEFTIMEOUT                              5
#define DEFAUTHPORT                             1645
#define DEFACCTPORT                             1646
#define MAXSCORE                                30

RAD_SERVER_NODE g_DefaultRadNode = 
{
    NULL,

    DEFTIMEOUT,
    DEFAUTHPORT,
    DEFACCTPORT,
    MAXSCORE,
    TRUE,
    TRUE,
    TRUE,

    NULL
};

//
// Loads a radius server node's configuration from the registry
// (assumed nt4 format and that defaults are assigned to pNode)
//
DWORD
RadNodeLoad(
    IN  HKEY hKey,
    OUT RAD_SERVER_NODE* pNode)
{
    RTL_QUERY_REGISTRY_TABLE paramTable[8]; 
    BOOL bTrue = TRUE;
    DWORD i;

    // Initialize the table of parameters
    RtlZeroMemory(&paramTable[0], sizeof(paramTable));
    
    paramTable[0].Name = (PWCHAR)PSZTIMEOUT;
    paramTable[0].EntryContext = &(pNode->dwTimeout);
        
    paramTable[1].Name = (PWCHAR)PSZAUTHPORT;
    paramTable[1].EntryContext = &(pNode->dwAuthPort);

    paramTable[2].Name = (PWCHAR)PSZACCTPORT;
    paramTable[2].EntryContext = &(pNode->dwAcctPort);

    paramTable[3].Name = (PWCHAR)PSZENABLEAUTH;
    paramTable[3].EntryContext = &(pNode->bEnableAuth);

    paramTable[4].Name = (PWCHAR)PSZENABLEACCT;
    paramTable[4].EntryContext = &(pNode->bEnableAcct);

    paramTable[5].Name = (PWCHAR)PSZENABLEACCTONOFF;
    paramTable[5].EntryContext = &(pNode->bAccountingOnOff);

    paramTable[6].Name = (PWCHAR)PSZSCORE;
    paramTable[6].EntryContext = &(pNode->dwScore);

    // We're reading all dwords, set the types
    // accordingly
    //
    for (i = 0; i < (sizeof(paramTable) / sizeof(*paramTable)) - 1;  i++)
    {
        paramTable[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[i].DefaultType = REG_DWORD;
        paramTable[i].DefaultLength = sizeof(DWORD);
        paramTable[i].DefaultData = paramTable[i].EntryContext;
    }

    // Read in the values
    //
    RtlQueryRegistryValues(
		 RTL_REGISTRY_HANDLE,
		 (PWSTR)hKey,
		 paramTable,
		 NULL,
		 NULL);

    return NO_ERROR;
}

// Add the authentication server node
//
DWORD
RadNodeSave(
    IN HKEY hKey,
    IN RAD_SERVER_NODE* pNode,
    IN BOOL bAuth)
{    
    DWORD dwErr = NO_ERROR;
    HKEY hkServer = NULL;

    do
    {
        // Create the server key in which to store the info
        //
        dwErr = RegCreateKeyExW(
                    hKey,
                    pNode->pszName,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hkServer,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        if (bAuth)
        {
            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZAUTHPORT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwAuthPort,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZSCORE,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwScore,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZTIMEOUT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwTimeout,
                sizeof(DWORD));
        }
        else
        {
            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZACCTPORT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwAcctPort,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZSCORE,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwScore,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZTIMEOUT,
                0,
                REG_DWORD,
                (BYTE*)&pNode->dwTimeout,
                sizeof(DWORD));

            RegSetValueExW(
                hkServer,
                (PWCHAR)PSZENABLEACCTONOFF,
                0,
                REG_DWORD,
                (BYTE*)&pNode->bAccountingOnOff,
                sizeof(DWORD));
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkServer)
        {
            RegCloseKey(hkServer);
        }
    }

    return dwErr;
}

//
// Callback from registry key enumerator that adds the server at the given key
// to the list of radius servers.
//
DWORD 
RadSrvListAddNodeFromKey(
    IN PWCHAR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    RAD_SERVER_LIST * pList = (RAD_SERVER_LIST*)hData;
    RAD_SERVER_NODE * pNode = NULL;
	
	do
	{
	    // Initialize the new node
	    //
	    pNode = (RAD_SERVER_NODE*) UtlAlloc(sizeof(RAD_SERVER_NODE));
	    if (pNode == NULL)
	    {
	        dwErr = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }
        CopyMemory(pNode, &g_DefaultRadNode, sizeof(RAD_SERVER_NODE));

        // Initialize the name
        //
        pNode->pszName = UtlDupString(pszName);
	    if (pNode->pszName == NULL)
	    {
	        dwErr = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

	    // Load in the registry settings
	    //
	    dwErr = RadNodeLoad(hKey, pNode);
	    if (dwErr != NO_ERROR)
	    {
	        break;
	    }

	    // Add the node to the list
	    //
        pNode->pNext   = pList->pHead;
        pList->pHead   = pNode;
        pList->dwCount += 1;
		
	} while (FALSE); 

    // Cleanup
	{
	} 
		
	return dwErr;
} 

//
// Generates a RAD_SERVER_LIST based on the configuration (assumed
// nt4 format) in the given registry key
//
DWORD
RadSrvListGenerate(
    IN  HKEY hkSettings,
    OUT RAD_SERVER_LIST** ppList)
{
    RAD_SERVER_LIST* pList = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Alloc/Init the list
        pList = (RAD_SERVER_LIST*) UtlAlloc(sizeof(RAD_SERVER_LIST));
        if (pList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        ZeroMemory(pList, sizeof(RAD_SERVER_LIST));

        // Build the list
        //
        dwErr = UtlEnumRegistrySubKeys(
                    hkSettings,
                    NULL,
                    RadSrvListAddNodeFromKey,
                    (HANDLE)pList);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Assign the return value
        //
        *ppList = pList;
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Cleans up a radius server list
//
DWORD
RadSrvListCleanup(
    IN RAD_SERVER_LIST* pList)
{
    RAD_SERVER_NODE* pNode = NULL;

    if (pList)
    {
        for (pNode = pList->pHead; pNode; pNode = pList->pHead)
        {
            if (pNode->pszName)
            {
                UtlFree(pNode->pszName);
            }
            pList->pHead = pNode->pNext;
            UtlFree(pNode);
        }
        UtlFree(pList);
    }

    return NO_ERROR;
}

//
// Opens the registry keys required by pNode
//
DWORD 
RadOpenRegKeys(
    IN     HKEY hkRouter,
    IN     RAD_SERVER_NODE* pNode,
    IN OUT RAD_CONFIG_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszPath[MAX_PATH];

    do
    {
        // Open the authentication keys as needed
        //
        if (pNode->bEnableAuth)
        {
            if (pInfo->hkAuthProviders == NULL)
            {
                // Open the auth providers key
                //
                dwErr = RegOpenKeyExW(
                            hkRouter,
                            pszAuthentication,
                            0,
                            KEY_ALL_ACCESS,
                            &pInfo->hkAuthProviders);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                // Generate the servers key name
                //
                wsprintfW(pszPath, pszRadServersFmt, pszGuidRadAuth);
                
                // Open the auth servers key
                //
                dwErr = RegCreateKeyExW(
                            pInfo->hkAuthProviders,
                            pszPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &pInfo->hkAuthServers,
                            NULL);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
        }

        // Open the accounting keys
        //
        if (pNode->bEnableAcct)
        {
            if (pInfo->hkAcctProviders == NULL)
            {
                // Open the auth providers key
                //
                dwErr = RegOpenKeyExW(
                            hkRouter,
                            pszAccounting,
                            0,
                            KEY_ALL_ACCESS,
                            &pInfo->hkAcctProviders);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                // Generate the servers key name
                //
                wsprintfW(pszPath, pszRadServersFmt, pszGuidRadAcct);
                
                // Open the auth servers key
                //
                dwErr = RegCreateKeyExW(
                            pInfo->hkAcctProviders,
                            pszPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &pInfo->hkAcctServers,
                            NULL);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Cleans up info from radius installation
//
DWORD
RadCloseRegKeys(
    IN RAD_CONFIG_INFO* pInfo)
{
    if (pInfo)
    {
        if (pInfo->hkAuthServers)
        {   
            RegCloseKey(pInfo->hkAuthServers);
            pInfo->hkAuthServers = NULL;
        }
        
        if (pInfo->hkAuthProviders)
        {
            RegCloseKey(pInfo->hkAuthProviders);
            pInfo->hkAuthProviders = NULL;
        }

        if (pInfo->hkAcctServers)
        {
            RegCloseKey(pInfo->hkAcctServers);
            pInfo->hkAcctServers = NULL;
        }
        
        if (pInfo->hkAcctProviders)
        {
            RegCloseKey(pInfo->hkAcctProviders);
            pInfo->hkAcctProviders = NULL;
        }
    }
    
    return NO_ERROR;
}

//
// Adds the given server to the win2k section of the registry
//
DWORD
RadInstallServer(
    IN     HKEY hkRouter,
    IN     RAD_SERVER_NODE* pNode,
    IN OUT RAD_CONFIG_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        // Based on the node, open or create any neccessary
        // registry keys.
        //
        dwErr = RadOpenRegKeys(hkRouter, pNode, pInfo);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if (pNode->bEnableAuth)
        {
            // Add the authentication server node
            //
            dwErr = RadNodeSave(
                        pInfo->hkAuthServers,
                        pNode, 
                        TRUE);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Set the active authentication provider
            //
            dwErr = RegSetValueExW(
                        pInfo->hkAuthProviders,
                        (PWCHAR)pszActiveProvider,
                        0,
                        REG_SZ,
                        (BYTE*)pszGuidRadAuth,
                        (wcslen(pszGuidRadAuth) + 1) * sizeof(WCHAR));
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
                    
        if (pNode->bEnableAcct)
        {
            // Add the accounting server node
            //
            dwErr = RadNodeSave(
                        pInfo->hkAcctServers,
                        pNode,
                        FALSE);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Set the active accounting provider
            //
            dwErr = RegSetValueExW(
                        pInfo->hkAcctProviders,
                        (PWCHAR)pszActiveProvider,
                        0,
                        REG_SZ,
                        (BYTE*)pszGuidRadAcct,
                        (wcslen(pszGuidRadAcct) + 1) * sizeof(WCHAR));
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Migrates radius settings from the settings key into the 
// router key.
//
DWORD
RadMigrateSettings(
    IN HKEY hkRouter, 
    IN HKEY hkSettings)
{
    DWORD dwErr = NO_ERROR;
    RAD_SERVER_LIST* pList = NULL;
    RAD_CONFIG_INFO* pInfo = NULL;
    RAD_SERVER_NODE* pNode = NULL;

    do
    {
        // Generate the list of servers based on 
        // the loaded settings
        dwErr = RadSrvListGenerate(hkSettings, &pList);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // If there were no servers, then there's nothing
        // to do
        //
        if (pList->pHead == NULL)
        {
            dwErr = NO_ERROR;
            break;
        }

        // Allocate and init the info blob that will be
        // used by the install funcs.
        //
        pInfo = (RAD_CONFIG_INFO*) UtlAlloc(sizeof(RAD_CONFIG_INFO));
        if (pInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        ZeroMemory(pInfo, sizeof(RAD_CONFIG_INFO));

        // Install all of the servers
        //
        for (pNode = pList->pHead; pNode; pNode = pNode->pNext)
        {
            RadInstallServer(hkRouter, pNode, pInfo);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pList)
        {
            RadSrvListCleanup(pList);
        }
        if (pInfo)
        {
            RadCloseRegKeys(pInfo);
            UtlFree(pInfo);
        }
    }

    return dwErr;
}

//
//  Performs the upgrade work
//
DWORD
RadiusToRouterUpgrade(
    IN PWCHAR pszFile) 
{
	DWORD dwErr = NO_ERROR;
	HKEY hkRouter = NULL, hkTemp = NULL, hkSettings = NULL;

	do
	{
        // Get the Router subkey
        //
        dwErr = UtlAccessRouterKey(&hkRouter);
        if (dwErr != NO_ERROR)
        {
            break;
        }
	
		// Load registry data that has been saved off
		//
		dwErr = UtlLoadSavedSettings(
		            hkRouter, 
		            (PWCHAR)pszTempRegKey, 
		            pszFile, 
		            &hkTemp);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to load radius settings.\n");
			break;
		}

		// Load the settings key
		//
		dwErr = RegOpenKeyExW(
                    hkTemp,
                    pszServers,
                    0,
                    KEY_ALL_ACCESS,
                    &hkSettings);
        if (dwErr != NO_ERROR)
        {
            break;
        }

		// Migrate radius information
		//
		dwErr = RadMigrateSettings(hkRouter, hkSettings);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to migrate radius settings.\n");
			break;
		}

	} while (FALSE);

	// Cleanup
	{
	    if (hkSettings)
	    {
	        RegCloseKey(hkSettings);
	    }
	    if (hkTemp)
	    {
	        UtlDeleteRegistryTree(hkTemp);
	        RegCloseKey(hkTemp);
	        RegDeleteKey(hkRouter, pszTempRegKey);
	    }
	    if (hkRouter)
	    {
	        RegCloseKey(hkRouter);
	    }
	}

	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\upgrade.c ===
/*
	File	upgrade.c
	
	Implementation of functions to update the registry when an
	NT 4.0  to NT 5.0 upgrade takes place.

	Paul Mayfield, 8/11/97

	Copyright 1997 Microsoft.
*/

#include "upgrade.h"

static const WCHAR szSteelheadKey[] = L"PreUpgradeRouter";
static const WCHAR szSapKey[]       = L"Sap.Parameters";
static const WCHAR szIpRipKey[]     = L"IpRip.Parameters";
static const WCHAR szDhcpKey[]      = L"RelayAgent.Parameters";
static const WCHAR szRadiusKey[]    = L"Radius.Parameters";
static const WCHAR szIpxRipKey[]    = L"IpxRip";

// Dll entry
BOOL 
WINAPI 
RtrUpgradeDllEntry (
    IN HINSTANCE hInstDll,
    IN DWORD fdwReason,
    IN LPVOID pReserved) 
{
    switch (fdwReason) 
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDll);
            break;
    }

    return TRUE;
}

//
// Performs the various router upgrade scenarios
//
DWORD 
DispatchSetupWork(
    IN PWCHAR szAnswerFileName, 
    IN PWCHAR szSectionName) 
{
	HINF hInf = NULL;
	BOOL DoUpgrade;
	WCHAR szBuf[1024];
	DWORD dwSize = 1024;
	DWORD dwErr, dwRet = NO_ERROR;

	// Open the answer file
	hInf = SetupOpenInfFileW(
	        szAnswerFileName, 
	        NULL, 
	        INF_STYLE_OLDNT, 
	        NULL);
	if (hInf == INVALID_HANDLE_VALUE)
	{
		return GetLastError();
    }

	// Perform a steelhead upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szSteelheadKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = SteelheadToNt5Upgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	// Perform an ipx sap upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szSapKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = SapToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }

	}

	// Perform an ip rip upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szIpRipKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = IpRipToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	// Perform a dhcp relay agent upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szDhcpKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = DhcpToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	// Perform a radius upgrade
	//
	dwSize = sizeof(szBuf) / sizeof(WCHAR);
	if (SetupGetLineTextW(
	        NULL,
	        hInf,
	        szSectionName,
	        szRadiusKey,
	        szBuf,
	        dwSize,
	        &dwSize)) 
    {
		dwErr = RadiusToRouterUpgrade(szBuf);
		if (dwErr != NO_ERROR)
		{
			dwRet = dwErr;
	    }
	}

	SetupCloseInfFile(hInf);

	return dwRet;
}

//
//	This is the entry point to upgrade mpr v1 and steelhead to
//	NT 5.0.  
//
HRESULT 
WINAPI 
RouterUpgrade (
    IN DWORD dwUpgradeFlag,
    IN DWORD dwUpgradeFromBuildNumber,
    IN PWCHAR szAnswerFileName,
    IN PWCHAR szSectionName) 
{
	DWORD dwErr;
	
	dwErr = DispatchSetupWork(szAnswerFileName, szSectionName);
	if (dwErr == NO_ERROR)
	{
		return S_OK;
    }

	UtlPrintErr(dwErr);
    
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\rip.c ===
/*
    File:	Rip.c

    Performs an upgrade of ip rip to nt5 router by munging registry values.

    Paul Mayfield, 9/3/97


    The following steps are neccessary to upgrade rip:
        Params = HKLM/SYS/CCS/Services/IpRip/Parameters
    1. Get the global info block for IP w/ MprConfigTransportGetInfo
        - Add a IPRIP_GLOBAL_CONFIG (ipriprm.h) block 
          initialized as in routemon (rip.c, protocol.c)
        - Type is MS_IP_RIP as in sdk/inc/ipinfoid.h
        - Mappings
        	Params.LoggingLevel to this global config blob

    2. Get Interface info for each ras or lan ip interface
    - Add an IPRIP_IF_CONFIG (ipriprm.h) block (type MS_IP_RIP)
    - Initialize as per routemon
    - Mappings
    	Params.AcceptHostRoutes - IC_ProtocolFlags (0=disable,1=enable)
    	Params.UpdateFreq...=FullUpdateInterval
    	Params.*Timeouts=

    3. "SilentRip" param rules
    - If wks->srv, ignore this and set announce to disabled. accept=rip1
    - If srv->srv, map announce to this value. accept=rip1


    IP Rip Parameter Mapping
    ========================

    Rip Listener                IpRip in Router			        
    RIP_PARAMETERS              IPRIP_IF_CONFIG			        	
    ==============              ===============			        
    "SilentRIP"                 IC_AcceptMode,IC_AnnounceMode
    "AcceptHostRoutes"          IC_ProtocolFlags
    "AnnounceHostRoutes"        IC_ProtocolFlags	
    "AcceptDefaultRoutes"       IC_ProtocolFlags
    "AnnounceDefaultRoutes"     IC_ProtocolFlags
    "EnableSplitHorizon"        IC_ProtocolFlags
    "EnablePoisonedReverse"     IC_ProtocolFlags
    "RouteTimeout"              IC_RouteExpirationInterval
    "GarbageTimeout"            IC_RouteRemovalInterval
    "UpdateFrequency"           IC_FullUpdateInterval
    "EnableTriggeredUpdates"    IC_ProtocolFlags
    "MaxTriggeredUpdateFrequency"   NOT MIGRATED
    "OverwriteStaticRoutes"     IC_ProtocolFlags


    IpRip in Router
    IPRIP_GLOBAL_CONFIG
    ===============
    "LoggingLevel"              GC_LoggingLevel
    
    REGVAL_ACCEPT_HOST      "AcceptHostRoutes"
    REGVAL_ANNOUNCE_HOST    "AnnounceHostRoutes"
    REGVAL_ACCEPT_DEFAULT   "AcceptDefaultRoutes"
    REGVAL_ANNOUNCE_DEFAULT "AnnounceDefaultRoutes"
    REGVAL_SPLITHORIZON     "EnableSplitHorizon"
    REGVAL_POISONREVERSE    "EnablePoisonedReverse"
    REGVAL_LOGGINGLEVEL     "LoggingLevel"
    REGVAL_ROUTETIMEOUT     "RouteTimeout"
    REGVAL_GARBAGETIMEOUT   "GarbageTimeout"
    REGVAL_UPDATEFREQUENCY  "UpdateFrequency"
    REGVAL_TRIGGEREDUPDATES "EnableTriggeredUpdates"
    REGVAL_TRIGGERFREQUENCY "MaxTriggeredUpdateFrequency"
    REGVAL_OVERWRITESTATIC  "OverwriteStaticRoutes"
*/

#include "upgrade.h"
#include <ipriprm.h>
#include <routprot.h>
#include <mprapi.h>

// Definition of table that migrates rip parameters
typedef struct _PARAM_TO_FLAG {
    PWCHAR pszParam;
    DWORD dwFlag;
} PARAM_TO_FLAG;

// Definition of user data passed to interface enumeration 
// callback
typedef struct _RIP_IF_DATA {
    IPRIP_IF_CONFIG * pLanConfig;
    IPRIP_IF_CONFIG * pWanConfig;
} RIP_IF_DATA;    

// Types of upgrade
#define SRV_TO_SRV 0
#define WKS_TO_SRV 1

// Globals
static const WCHAR szTempKey[] = L"DeleteMe";
static HKEY hkRouter = NULL;
static HKEY hkTemp = NULL;

PARAM_TO_FLAG ParamFlagTable[] = 
{
    {L"AcceptHostRoutes",       IPRIP_FLAG_ACCEPT_HOST_ROUTES},
    {L"AnnounceHostRoutes",     IPRIP_FLAG_ANNOUNCE_HOST_ROUTES},
    {L"AcceptDefaultRoutes",    IPRIP_FLAG_ACCEPT_DEFAULT_ROUTES},
    {L"AnnounceDefaultRoutes",  IPRIP_FLAG_ANNOUNCE_DEFAULT_ROUTES},
    {L"EnableSplitHorizon",     IPRIP_FLAG_SPLIT_HORIZON},
    {L"EnablePoisonedReverse",  IPRIP_FLAG_POISON_REVERSE},
    {L"EnableTriggeredUpdates", IPRIP_FLAG_TRIGGERED_UPDATES},
    {L"OverwriteStaticRoutes",  IPRIP_FLAG_OVERWRITE_STATIC_ROUTES},
    {NULL,  0}
};

// Restore the registry from from 
// backup and make sure all global handles are opened
DWORD IpRipPrepareRegistry(
        IN PWCHAR BackupFileName) 
{
	DWORD dwErr,dwDisposition;

	// Get access to the router registry key
	dwErr = UtlAccessRouterKey(&hkRouter);
	if (dwErr != ERROR_SUCCESS) {
		PrintMessage(L"Unable to access router key.\n");
		return dwErr;
	}

	// Restore the rip parameters from backup
	__try {
		// Open up the temporary key
		dwErr = RegCreateKeyEx(
		            hkRouter,
		            szTempKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkTemp,
		            &dwDisposition);
		if (dwErr!=ERROR_SUCCESS)
			return dwErr;

		// Restore the saved registry information to 
		// the temp key
		UtlSetupRestorePrivilege(TRUE);
		dwErr = RegRestoreKeyW(
		            hkTemp,
		            BackupFileName,
		            0);
		if (dwErr != ERROR_SUCCESS) 
			return dwErr;
	}
	__finally {
		UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

// Function initializes the rip global information based 
// on the parameters saved from the iprip service.
//
//	1. Get the global info block for IP w/ MprConfigTransportGetInfo
//		- Add a IPRIP_GLOBAL_CONFIG (ipriprm.h) 
//        block initialized as in routemon (rip.c, protocol.c)
//		- Type is MS_IP_RIP as in sdk/inc/ipinfoid.h
//		- Mappings
//			Params.LoggingLevel to this global config blob
DWORD IpRipUpgradeGlobalInfo(
        IN dwt * RipParams) 
{
    DWORD dwErr, dwTransSize, dwVal, dwNewSize = 0;
    LPBYTE lpTransInfo=NULL, lpNewTransInfo=NULL;
    HANDLE hSvrConfig=NULL, hTransport=NULL;
    
    // Create/initialize an IPRIP_GLOBAL_CONFIG block
    IPRIP_GLOBAL_CONFIG RipGlobalConfig = {
        IPRIP_LOGGING_ERROR,        // Logging level
        1024 * 1024,                // Max recv-queue size
        1024 * 1024,                // Max send-queue size
        5,                          // Minimum triggered-update interval
        IPRIP_FILTER_DISABLED,      // Peer-filter mode
        0                           // Peer-filter count
    };    

    // Reset any values read from the previous iprip configuration
    dwErr = dwtGetValue(
                RipParams, 
                L"LoggingLevel", 
                &dwVal);
    if (dwErr == NO_ERROR) 
        RipGlobalConfig.GC_LoggingLevel=dwVal;

    __try {
        // Add the rip global config to ip's global config
        dwErr = MprConfigServerConnect(
                    NULL, 
                    &hSvrConfig);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetHandle(
                    hSvrConfig,
                    PID_IP,
                    &hTransport);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprConfigTransportGetInfo(
                    hSvrConfig,
                    hTransport,
                    &lpTransInfo,
                    &dwTransSize,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = UtlUpdateInfoBlock(
                    TRUE,
                    lpTransInfo,
                    MS_IP_RIP,
                    sizeof(IPRIP_GLOBAL_CONFIG),
                    1,
                    (LPBYTE)&RipGlobalConfig,
                    &lpNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Commit the information
        dwErr = MprConfigTransportSetInfo(
                    hSvrConfig,
                    hTransport,
                    lpNewTransInfo,
                    dwNewSize,
                    NULL,
                    0,
                    NULL);
                
        if (dwErr != NO_ERROR)
            return NO_ERROR;
    }
    __finally {
        if (lpTransInfo)
            MprConfigBufferFree(lpTransInfo);
        if (lpNewTransInfo)
            MprConfigBufferFree(lpNewTransInfo);
        if (hSvrConfig)
            MprConfigServerDisconnect(hSvrConfig);
    }

    return NO_ERROR;
}

// Returns whether this is a wks->srv or srv->srv upgrade
DWORD IpRipGetUpgradeType() {
    return SRV_TO_SRV;
}

// Migrates the silent rip parameter.
//	3. "SilentRip" param rules
//		- If wks->srv, announce=disabled, accept=rip1
//		- If srv->srv, announce=SilentRip, accept=rip1
DWORD IpRipMigrateRipSilence(
        IN OUT IPRIP_IF_CONFIG * RipIfConfig, 
        IN DWORD dwSilence, 
        IN BOOL IsWan) 
{
    DWORD UpgradeType = IpRipGetUpgradeType();
    if (IsWan) {
        if (UpgradeType == WKS_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1_COMPAT;
            RipIfConfig->IC_AnnounceMode = IPRIP_ACCEPT_DISABLED;
        }
        else if (UpgradeType == SRV_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1_COMPAT;
            RipIfConfig->IC_AnnounceMode = dwSilence;
        }
    }
    else {
        if (UpgradeType == WKS_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1;
            RipIfConfig->IC_AnnounceMode = IPRIP_ACCEPT_DISABLED;
        }
        else if (UpgradeType == SRV_TO_SRV) {
            RipIfConfig->IC_AcceptMode = IPRIP_ACCEPT_RIP1;
            RipIfConfig->IC_AnnounceMode = dwSilence;
        }
    }

    return NO_ERROR;
}

DWORD IpRipSetParamFlag(
        IN  dwt * RipParams, 
        IN  PWCHAR ValName, 
        IN  DWORD dwFlag, 
        OUT DWORD * dwParam) 
{
    DWORD dwVal, dwErr;

    dwErr = dwtGetValue(RipParams, ValName, &dwVal);
    if (dwErr == NO_ERROR) {
        if (dwVal)
            *dwParam |= dwFlag;
        else
            *dwParam &= ~dwFlag;
    }

    return NO_ERROR;
}

// Update the lan interface parameters from previous config
DWORD IpRipUpdateIfConfig(
        IN  dwt * RipParams, 
        OUT IPRIP_IF_CONFIG * RipIfConfig, 
        IN  BOOL IsWan) 
{
    DWORD dwErr, dwVal;
    PARAM_TO_FLAG * pCurFlag;

    // Loop through all the parameter mappings, 
    // setting the appripriate flag in the rip config
    pCurFlag = &(ParamFlagTable[0]);
    while (pCurFlag->pszParam) {
        // Set the flag as appropriate
        IpRipSetParamFlag(
            RipParams, 
            pCurFlag->pszParam, 
            pCurFlag->dwFlag, 
            &(RipIfConfig->IC_ProtocolFlags));

        // Increment the enumeration
        pCurFlag++;
    }

    // Set the parameters migrated as parameters
    dwErr = dwtGetValue(RipParams, L"UpdateFrequency", &dwVal);
    if (dwErr == NO_ERROR) 
        RipIfConfig->IC_FullUpdateInterval = dwVal;
        
    dwErr = dwtGetValue(RipParams, L"RouteTimeout", &dwVal);
    if (dwErr == NO_ERROR) 
        RipIfConfig->IC_RouteExpirationInterval = dwVal;
        
    dwErr = dwtGetValue(RipParams, L"GarbageTimeout", &dwVal);
    if (dwErr == NO_ERROR) 
        RipIfConfig->IC_RouteRemovalInterval = dwVal;

    // Upgrade the silence parameter
    dwErr = dwtGetValue(RipParams, L"SilentRIP", &dwVal);
    if (dwErr == NO_ERROR)
        IpRipMigrateRipSilence(RipIfConfig, dwVal, IsWan);

    return NO_ERROR;
}

//
// Callback function takes an interface and updates
// its rip configuration.
//
// Returns TRUE to continue the enumerate, FALSE to 
// stop it
//
DWORD IpRipUpgradeInterface(
        IN HANDLE hConfig,
        IN MPR_INTERFACE_0 * pIf,
        IN HANDLE hUserData)
{
    RIP_IF_DATA * pData = (RIP_IF_DATA*)hUserData;
    IPRIP_IF_CONFIG * pConfig;
    HANDLE hTransport = NULL;
    LPBYTE pTransInfo=NULL, pNewTransInfo=NULL;
    DWORD dwErr, dwIfSize, dwNewTransSize = 0;

    // Validate lan and wan interfaces
    if ((hConfig == NULL) || 
        (pIf == NULL)     || 
        (pData == NULL))
    {
        return FALSE;
    }

    // Is this a LAN or a WAN interface 
    if (pIf->dwIfType == ROUTER_IF_TYPE_DEDICATED)
        pConfig = pData->pLanConfig;
    else if (pIf->dwIfType == ROUTER_IF_TYPE_HOME_ROUTER ||
             pIf->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
        pConfig = pData->pWanConfig;
    else
        return TRUE;

    do {
        // Get the handle to ip info associated with this if
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    pIf->hInterface,
                    PID_IP,
                    &hTransport);
        if (dwErr != NO_ERROR)
            break;

        // Get the ip info associated with this if
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwIfSize);
        if (dwErr != NO_ERROR)
            break;

        // Update the info block with the rip data
        dwErr = UtlUpdateInfoBlock (
                    TRUE,
                    pTransInfo,
                    MS_IP_RIP,
                    sizeof(IPRIP_IF_CONFIG),
                    1,
                    (LPBYTE)pConfig,
                    &pNewTransInfo,
                    &dwNewTransSize);
        if (dwErr != NO_ERROR)
            break;

        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    pNewTransInfo,
                    dwNewTransSize);
        if (dwErr != NO_ERROR)
            break;
            
    } while (FALSE);   

    // Cleanup
    {
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
    }

    return TRUE;
}
        


// Initializes the rip per-interface information based on the 
// parameters saved from the iprip service.
//
//	2. Get Interface info for each ras or lan ip interface
//      - Add an IPRIP_IF_CONFIG (ipriprm.h) block (type MS_IP_RIP)
//      - Initialize as per routemon
//      - Mappings
//          Params.AcceptHostRoutes - IC_ProtocolFlags (0=disable,1=enable)
//          Params.UpdateFreq...=FullUpdateInterval
//          Params.*Timeouts=
DWORD IpRipUpgradeInterfaces(
        IN dwt * RipParams) 
{
    DWORD dwErr;
    
    // Create/initialize an rip info blocks
    IPRIP_IF_CONFIG RipLanConfig = {
        0,                                  // State (read-only)
        1,                                  // Metric
        IPRIP_UPDATE_PERIODIC,              // Update mode
        IPRIP_ACCEPT_RIP1,                  // Accept mode
        IPRIP_ANNOUNCE_RIP1,                // Announce mode
        IPRIP_FLAG_SPLIT_HORIZON |
        IPRIP_FLAG_POISON_REVERSE |
        IPRIP_FLAG_GRACEFUL_SHUTDOWN |
        IPRIP_FLAG_TRIGGERED_UPDATES,       // Protocol flags
        180,                                // Route-expiration interval
        120,                                // Route-removal interval
        30,                                 // Full-update interval
        IPRIP_AUTHTYPE_NONE,                // Authentication type
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},  // Authentication key
        0,                                  // Route tag
        IPRIP_PEER_DISABLED,                // Unicast-peer mode
        IPRIP_FILTER_DISABLED,              // Accept-filter mode
        IPRIP_FILTER_DISABLED,              // Announce-filter mode
        0,                                  // Unicast-peer count
        0,                                  // Accept-filter count
        0                                   // Announce-filter count
    };
    
    IPRIP_IF_CONFIG RipWanConfig = {
        0,
        1,
        IPRIP_UPDATE_DEMAND,                // Update mode for WAN
        IPRIP_ACCEPT_RIP1,
        IPRIP_ANNOUNCE_RIP1,
        IPRIP_FLAG_SPLIT_HORIZON |
        IPRIP_FLAG_POISON_REVERSE |
        IPRIP_FLAG_GRACEFUL_SHUTDOWN,
        180,
        120,
        30,
        IPRIP_AUTHTYPE_NONE,
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        0,
        IPRIP_PEER_DISABLED,
        IPRIP_FILTER_DISABLED,
        IPRIP_FILTER_DISABLED,
        0,
        0,
        0
    };

    RIP_IF_DATA RipBlobs = 
    {
        &RipLanConfig,
        &RipWanConfig
    };

    // Update the lan config blob with values from previous 
    // installation of rip service.
    dwErr = IpRipUpdateIfConfig(RipParams, RipBlobs.pLanConfig, FALSE);
    if (dwErr != NO_ERROR)
        return dwErr;
        
    // Update the wan config blob with values from previous 
    // installation of rip service.
    dwErr = IpRipUpdateIfConfig(RipParams, RipBlobs.pWanConfig, TRUE);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Enumerate the interfaces, updating each one with 
    // rip config as you go.
    dwErr = UtlEnumerateInterfaces(
                IpRipUpgradeInterface,
                &RipBlobs);
    if (dwErr != NO_ERROR)
        return dwErr;
        
    return NO_ERROR;
}

// Restores the Rip parameters that were saved before upgrade.  
// This function assumes that those parameters are being stored 
// temporarily in hkTemp
DWORD IpRipMigrateParams() {
	DWORD dwErr, dwVal;
	dwt RipParams;

	__try {
    	// Load in the parameters that were set for Rip
		dwErr = dwtLoadRegistyTable(&RipParams, hkTemp);
		if (dwErr != NO_ERROR)
			return dwErr;

        // Migrate the various types of paramters
        dwErr = IpRipUpgradeGlobalInfo(&RipParams);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Migrate the per-interface parameters
        dwErr = IpRipUpgradeInterfaces(&RipParams);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
	__finally {
		dwtCleanup(&RipParams);
	}

	return NO_ERROR;
}

// Cleanup the work done in the registry
DWORD IpRipCleanupRegistry() {
	if (hkTemp) 
		RegCloseKey(hkTemp);
	if (hkRouter) {
		RegDeleteKey(hkRouter, szTempKey);
		RegCloseKey(hkRouter);
	}
    hkTemp = NULL;
    hkRouter = NULL;
	return NO_ERROR;
}

// Upgrades iprip to nt 5.0 router
DWORD IpRipToRouterUpgrade(
        IN PWCHAR FileName) 
{
	DWORD dwErr;

	__try {
		// Restore the registry from the backup file
		dwErr = IpRipPrepareRegistry(FileName);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Migrate rip's parameters to the appropriate 
		// new locations
		dwErr = IpRipMigrateParams();
		if (dwErr != NO_ERROR)
			return dwErr;

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
			return dwErr;
		}
			
	}
	__finally {
		IpRipCleanupRegistry();
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\steelhead.c ===
/*
	File	Steelhead.c
	
	Implementation of functions to update the registry when an
	NT 4.0 Steelhead to NT 5.0 upgrade takes place.

	Paul Mayfield, 8/11/97

	Copyright 1997 Microsoft.
*/

#include "upgrade.h"
#include <wchar.h>
#include <rtcfg.h>

// 
// Macro for convenience
//
#define BREAK_ON_ERROR(_err) if ((_err)) break

//
// Defines a function to get nt4.0 interface name from a
// guid.
//
typedef HRESULT (*GetGuidFromInterfaceNameProc)(PWCHAR,LPGUID);

//
// The following define what is needed to infer guids from 4.0 
// interface names.
//
WCHAR NetCfgLibName[]           = L"netshell.dll";
CHAR  GuidProcName[]            = "HrGetInstanceGuidOfPreNT5NetCardInstance";
static const WCHAR c_szwInternalAdapter []  = L"Internal";
static const WCHAR c_szwLoopbackAdapter []  = L"Loopback";

GetGuidFromInterfaceNameProc GetGuid = NULL;

//  Function uses the application defined parameter to initialize the 
//  system of mapping old interface names to new ones.
//
DWORD SeedInterfaceNameMapper(
        OUT PHANDLE phParam) 
{
	HINSTANCE hLibModule;

	// Load the library
	hLibModule = LoadLibraryW(NetCfgLibName);
	if (hLibModule == NULL) {
		PrintMessage(L"Unable to load NetCfgLibName\n");
		return GetLastError();
	}

	// Get the appropriate function pointers
	GetGuid = (GetGuidFromInterfaceNameProc) 
	                GetProcAddress(hLibModule, GuidProcName);
	if (GetGuid == NULL) {
		PrintMessage(L"Unable to get GuidProcName\n");
		return ERROR_CAN_NOT_COMPLETE;
	}

	// Assign the return value
	*phParam = (HANDLE)hLibModule;

	return NO_ERROR;
}

//
// Cleans up the interface name mapper.
//
DWORD CleanupInterfaceNameMapper(HANDLE hParam) {
	HINSTANCE hLibModule = (HINSTANCE)hParam;
	
	if (hLibModule) {
		if (! FreeLibrary(hLibModule))
			PrintMessage(L"Unable to free library\n");
	}

	return NO_ERROR;
}

//
// Determines whether the type of interface being examined 
// should have its name changed.
//
BOOL IfNeedsNameUpdate(
        IN MPR_INTERFACE_0 * If) 
{
	// Validate parameters
	if (!If) {
		PrintMessage(L"Null interface passed to IfNeedsNameUpdate.\n");
		return FALSE;
	}

	// Only lan interfaces can have their names updated
    if (If->dwIfType == ROUTER_IF_TYPE_DEDICATED)
        return TRUE;

	return FALSE;
}

//
// Returns a pointer to the packet name portion of the 
// interface name if it exists.
//
PWCHAR FindPacketName(
        IN PWCHAR IfName) 
{
	PWCHAR res;
	
	if ((res = wcsstr(IfName,L"/Ethernet_SNAP")) != NULL)
		return res;
		
	if ((res = wcsstr(IfName,L"/Ethernet_II")) != NULL)
		return res;
		
	if ((res = wcsstr(IfName,L"/Ethernet_802.2")) != NULL)
		return res;
		
	if ((res = wcsstr(IfName,L"/Ethernet_802.3")) != NULL)
		return res;

	return NULL;
}

//
// Upgrades a packet name from the 4.0 convention to 
// the nt5 convention.
//
PWCHAR UpgradePktName(
            IN PWCHAR PacketName) 
{
	PWCHAR res;
	
	if ((res = wcsstr(PacketName,L"/Ethernet_SNAP")) != NULL)
		return L"/SNAP";
		
	if ((res = wcsstr(PacketName,L"/Ethernet_II")) != NULL)
		return L"/EthII";
		
	if ((res = wcsstr(PacketName,L"/Ethernet_802.2")) != NULL)
		return L"/802.2";
		
	if ((res = wcsstr(PacketName,L"/Ethernet_802.3")) != NULL)
		return L"/802.3";

	return L"";
}


//
// Provides the mapping between old interface names and new guid
// interface names.
//
DWORD UpdateInterfaceName(
        IN PWCHAR IName) 
{
	HRESULT hResult;
	GUID Guid;
	PWCHAR GuidName=NULL;
	PWCHAR PacketName=NULL;
	WCHAR SavedPacketName[MAX_INTEFACE_NAME_LEN];
	WCHAR SavedIName[MAX_INTEFACE_NAME_LEN];
	PWCHAR ptr;

	// Validate parameters
	if (! IName) {
		PrintMessage(L"Invalid parameter to UpdateInterfaceName.\n");
		return ERROR_INVALID_PARAMETER;
	}

	// Save off the packet name if it exists and remove if from the 
	// interface name
	wcscpy(SavedIName, IName);
	PacketName = FindPacketName(SavedIName);
	if (PacketName) {
		wcscpy(SavedPacketName, PacketName);
		*PacketName = 0;
	}

	// Get the guid of the interface name
	hResult = (*GetGuid)(SavedIName,&Guid);
	if (hResult != S_OK) {
		PrintMessage(L"Unable to get guid function.\n");
		return ERROR_CAN_NOT_COMPLETE;
	}
	
	// Format the guid as a string
	if (UuidToStringW(&Guid, &GuidName) != RPC_S_OK) {
		PrintMessage(L"Not enough memory to create guid string.\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	
	// Capitalize the guid string (all letters are hexidecimal
	// string characters)
	ptr = GuidName;
	while (ptr && *ptr) {
		if ((*ptr <= L'z') && (*ptr >= L'a'))
			*ptr = towupper(*ptr);
		ptr++;
	}

	// Change the interface name according to the new mapping
	if (PacketName) {
        wsprintf(IName, L"{%s}%s", GuidName, UpgradePktName(SavedPacketName)); 
	}
	else
		wsprintfW(IName,L"{%s}", GuidName);

	// Cleanup
	if (GuidName)
		RpcStringFreeW(&GuidName);

	return NO_ERROR;
}

//
// Provides the mapping between old interface names and new guid
// interface names.
//
DWORD UpdateIpxAdapterName(PWCHAR AName) {
	HRESULT hResult;
	GUID Guid;
	PWCHAR GuidName = NULL;
	PWCHAR PacketName = NULL;
	WCHAR SavedAName[MAX_INTEFACE_NAME_LEN];
	PWCHAR ptr = NULL;

	// Validate parameters
	if (!AName) {
		PrintMessage(L"Invalid parameter to UpdateIpxAdapterName.\n");
		return ERROR_INVALID_PARAMETER;
	}

	// Adapter names do not have packet types associated with them
	if (FindPacketName(AName)) 
	    return ERROR_CAN_NOT_COMPLETE;

	// Get the guid of the interface name
	hResult = (*GetGuid)(AName,&Guid);
	if (hResult!=S_OK) {
		PrintMessage(L"GetGuid function returned failure.\n");
		return ERROR_CAN_NOT_COMPLETE;
	}
	
	// Format the guid as a string
	if (UuidToStringW(&Guid,&GuidName) != RPC_S_OK) {
		PrintMessage(L"Uuid to string failed.\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	// Capitalize the guid string
	ptr = GuidName;
	while (ptr && *ptr) {
		if ((*ptr <= L'z') && (*ptr >= L'a'))
			*ptr = towupper(*ptr);
		ptr++;
	}

	// Change the adapter name according to the new mapping
	wsprintfW(AName, L"{%s}", GuidName);

	// Cleanup
	if (GuidName)
		RpcStringFreeW(&GuidName);

	return NO_ERROR;
}

//
// Update the interface name stored in the adapter info blob
//
DWORD UpdateIpxAdapterInfo(
        IN  PIPX_ADAPTER_INFO AdapterInfop, 
        OUT PIPX_ADAPTER_INFO * NewAdapterInfop,
        OUT DWORD * NewSize) 
{
	DWORD dwErr;

	// Validate parameters
	if (! (AdapterInfop && NewAdapterInfop && NewSize)) {
		PrintMessage(L"Invalid params to UpdateIpxAdapterInfo.\n");
		return ERROR_INVALID_PARAMETER;
	}
	
	// Allocate a new adapter
	*NewAdapterInfop = (PIPX_ADAPTER_INFO) 
	                        UtlAlloc(sizeof(IPX_ADAPTER_INFO));
	if (! (*NewAdapterInfop)) {
		PrintMessage(L"Unable to allocate NewAdapterInfo.\n");
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	
	// Copy into the new interface name
	(*NewAdapterInfop)->PacketType = AdapterInfop->PacketType;
	wcscpy(
	    (*NewAdapterInfop)->AdapterName, 
	    AdapterInfop->AdapterName);	

	// Update the interface name
	dwErr = UpdateIpxAdapterName((*NewAdapterInfop)->AdapterName);
	if (dwErr != NO_ERROR) {
		PrintMessage(L"UpdateIpxAdapterName failed.\n");
		return dwErr;
	}
	*NewSize = sizeof(IPX_ADAPTER_INFO);

	return NO_ERROR;
}

//
// Update all of the ipx related interface 
// information in the router configuration
//
DWORD UpdateIpxIfData(
        IN HANDLE hConfig,
        IN HANDLE hInterface)
{
	PIPX_ADAPTER_INFO AdapterInfop;
	PIPX_ADAPTER_INFO NewAdapterInfop;
	DWORD dwErr, dwCount, dwSize, dwNewSize, dwTransSize;
	HANDLE hTransport;
	LPBYTE pTransInfo = NULL, pNewInfo = NULL;

	// Validate parameters
	if (!hConfig || !hInterface) 
	{
		PrintMessage(L"Invalid params passed to UpdateIpxIfData.\n");
		return ERROR_INVALID_PARAMETER;
	}

    do {
        // Update the ipx interface info since this protocol
        // stores interface specific info in the transport
        // info blob (shame shame).
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    hInterface,
                    PID_IPX,
                    &hTransport);
        if (dwErr != NO_ERROR)
    	    break;
            
        // Update the adapter info blob
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwTransSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to get transport info for ipx.\n");
    	    break;
        }

    	// Get the adapter info associated with this interface
    	dwErr = MprInfoBlockFind(
    	            pTransInfo,
    	            IPX_ADAPTER_INFO_TYPE,
    	            &dwSize,
    	            &dwCount,
    	            (LPBYTE*)&AdapterInfop);
        if (dwErr != NO_ERROR) {	            
    		PrintMessage(L"ERROR - null adapter information.\n");
    		break;
    	}

    	// Change the name of the referenced adapter
    	dwErr = UpdateIpxAdapterInfo(AdapterInfop, &NewAdapterInfop, &dwNewSize);
    	if (dwErr != NO_ERROR) {
    		PrintMessage(L"UpdateIpxAdapterInfo failed.\n");
    		break;
    	}
    	
    	dwErr = MprInfoBlockSet(
    	            pTransInfo,
    	            IPX_ADAPTER_INFO_TYPE,
    	            dwNewSize,
    	            1,
    	            (LPVOID)NewAdapterInfop,
    	            &pNewInfo);
    	            
    	if (dwErr != NO_ERROR) {
    		PrintMessage(L"MprInfoBlockSet failed.\n");
    		break;
    	}

        dwNewSize = ((PRTR_INFO_BLOCK_HEADER)pNewInfo)->Size;

        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    pNewInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to set ipx transport info.\n");
    	    break;
        }
    } while (FALSE);

    // Cleanup
    {
        if (pTransInfo)
    	    MprConfigBufferFree(pTransInfo);
    	if (pNewInfo)
    	    MprConfigBufferFree(pNewInfo);
    }    	    

	return dwErr;
}

//
// Updates the ip interface info
//
DWORD
UpdateIpIfData(
        IN HANDLE hConfig,
        IN HANDLE hInterface)
{
    PMIB_IPFORWARDROW   pRoutes;
	DWORD dwErr, dwCount, dwSize, dwNewSize, dwTransSize, dwInd;
	HANDLE hTransport;
	LPBYTE pTransInfo = NULL, pNewInfo = NULL;

    pRoutes = NULL;

	// Validate parameters
	if (!hConfig || !hInterface) 
	{
		PrintMessage(L"Invalid params passed to UpdateIpIfData.\n");
		return ERROR_INVALID_PARAMETER;
	}

    do {
        // Update the ipx interface info since this protocol
        // stores interface specific info in the transport
        // info blob (shame shame).
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    hInterface,
                    PID_IP,
                    &hTransport);
        if (dwErr != NO_ERROR)
    	    break;
            
        // Update the adapter info blob
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwTransSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to get transport info for ip.\n");
    	    break;
        }

    	// Get the adapter info associated with this interface
    	dwErr = MprInfoBlockFind(
    	            pTransInfo,
    	            IP_ROUTE_INFO,
    	            &dwSize,
    	            &dwCount,
    	            (LPBYTE*)&pRoutes);
        if (dwErr != NO_ERROR) {	            
    		PrintMessage(L"Unable to find ip route info.\n");
    		break;
    	}

        // Update the protocol id's
        for(dwInd = 0; dwInd < dwCount; dwInd++)
        {
            if((pRoutes[dwInd].dwForwardProto == MIB_IPPROTO_LOCAL) ||
               (pRoutes[dwInd].dwForwardProto == MIB_IPPROTO_NETMGMT))
            {
                pRoutes[dwInd].dwForwardProto = MIB_IPPROTO_NT_STATIC;
            }
        }

        // Commit the info
    	dwErr = MprInfoBlockSet(
    	            pTransInfo,
    	            IP_ROUTE_INFO,
    	            dwSize,
    	            dwCount,
    	            (LPVOID)pRoutes,
    	            &pNewInfo);
    	            
    	if (dwErr != NO_ERROR) {
    		PrintMessage(L"MprInfoBlockSet failed.\n");
    		break;
    	}

        dwNewSize = ((PRTR_INFO_BLOCK_HEADER)pNewInfo)->Size;

        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    hInterface,
                    hTransport,
                    pNewInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR) {
    	    PrintMessage(L"Unable to set ip transport info.\n");
    	    break;
        }
    } while (FALSE);

    // Cleanup
    {
        if (pTransInfo)
    	    MprConfigBufferFree(pTransInfo);
    	if (pNewInfo)
    	    MprConfigBufferFree(pNewInfo);
    }    	    

	return dwErr;
}

//
// Flushes the name in given interface name to the registry.
//
DWORD CommitInterfaceNameChange(
        IN MPR_INTERFACE_0 * If) 
{
	DWORD dwErr;
	WCHAR c_szInterfaceName[] = L"InterfaceName";
    INTERFACECB* pinterface;

	// Validate parameters
	if (!If) {
		PrintMessage(L"Invalid param to CommitInterfaceNameChange.\n");
		return ERROR_INVALID_PARAMETER;
	}
	
    // Set the name
    pinterface = (INTERFACECB*)If->hInterface;
    dwErr = RegSetValueExW(
                pinterface->hkey, 
                c_szInterfaceName, 
                0, 
                REG_SZ,
                (LPCSTR)(If->wszInterfaceName),
                (lstrlen(If->wszInterfaceName)+1)*sizeof(WCHAR)); 

	if (dwErr != ERROR_SUCCESS)
		PrintMessage(L"RegSetValueEx err in CommitIfNameChange.\n");

	if (dwErr == ERROR_SUCCESS)
		return NO_ERROR;

	return dwErr;
}

//
// Creates a default ip interface blob
//
DWORD 
IpCreateDefaultInterfaceInfo(
    OUT LPBYTE* ppInfo,
    OUT LPDWORD lpdwSize)
{
    PBYTE pInfo = NULL, pNewInfo = NULL;
    DWORD dwErr = NO_ERROR;
    //MIB_IPFORWARDROW RouteInfo;
    INTERFACE_STATUS_INFO StatusInfo;
    RTR_DISC_INFO DiscInfo;

    do
    {
        // Create the blob
        //
        dwErr = MprInfoCreate(RTR_INFO_BLOCK_VERSION, &pInfo);
        BREAK_ON_ERROR(dwErr);

        // Add an the route info 
        //
        //ZeroMemory(&RouteInfo, sizeof(RouteInfo));        
        //dwErr = MprInfoBlockAdd(
        //            pInfo,
        //            IP_ROUTE_INFO,
        //            sizeof(MIB_IPFORWARDROW),
        //            1,
        //            (LPBYTE)&RouteInfo,
        //            &pNewInfo);
        //MprConfigBufferFree(pInfo);
        //pInfo = pNewInfo;
        //pNewInfo = NULL;
        //BREAK_ON_ERROR(dwErr);
        
        // Add an the status info 
        //
        ZeroMemory(&StatusInfo, sizeof(StatusInfo));        
        StatusInfo.dwAdminStatus = MIB_IF_ADMIN_STATUS_UP;
        dwErr = MprInfoBlockAdd(
                    pInfo,
                    IP_INTERFACE_STATUS_INFO,
                    sizeof(INTERFACE_STATUS_INFO),
                    1,
                    (LPBYTE)&StatusInfo,
                    &pNewInfo);
        MprConfigBufferFree(pInfo);
        pInfo = pNewInfo;
        pNewInfo = NULL;
        BREAK_ON_ERROR(dwErr);
        
        // Add an the disc info 
        //
        ZeroMemory(&DiscInfo, sizeof(DiscInfo));        
        DiscInfo.bAdvertise        = FALSE;
        DiscInfo.wMaxAdvtInterval  = DEFAULT_MAX_ADVT_INTERVAL;
        DiscInfo.wMinAdvtInterval  = (WORD) 
            (DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
        DiscInfo.wAdvtLifetime     = (WORD)
            (DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
        DiscInfo.lPrefLevel        = DEFAULT_PREF_LEVEL;
        dwErr = MprInfoBlockAdd(
                    pInfo,
                    IP_ROUTER_DISC_INFO,
                    sizeof(PRTR_DISC_INFO),
                    1,
                    (LPBYTE)&DiscInfo,
                    &pNewInfo);
        MprConfigBufferFree(pInfo);
        pInfo = pNewInfo;
        pNewInfo = NULL;
        BREAK_ON_ERROR(dwErr);

        // Assign the return value
        //
        *ppInfo = pInfo;                    
        *lpdwSize = ((PRTR_INFO_BLOCK_HEADER)pInfo)->Size;

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

// 
// Adds an ip interface blob to the given interface
//
DWORD
IpAddDefaultInfoToInterface(
    IN HANDLE hConfig,
    IN HANDLE hIf)
{
    HANDLE hIfTrans = NULL;
    LPBYTE pInfo = NULL;
    DWORD dwErr = 0, dwSize = 0;

    do 
    {
        // If the transport blob already exists, there's
        // nothing to do.
        //
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    hIf,
                    PID_IP,
                    &hIfTrans);
        if ((dwErr == NO_ERROR) || (hIfTrans != NULL))
        {
            dwErr = NO_ERROR;
            break;
        }
    
        // Create the info blob
        //
        dwErr = IpCreateDefaultInterfaceInfo(&pInfo, &dwSize);
        BREAK_ON_ERROR(dwErr);

        // Add the ip transport to the interface
        //
        dwErr = MprConfigInterfaceTransportAdd(
                    hConfig,
                    hIf,
                    PID_IP,
                    NULL,
                    pInfo, 
                    dwSize,
                    &hIfTrans);
        BREAK_ON_ERROR(dwErr);                    

    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            MprConfigBufferFree(pInfo);
        }
    }

    return dwErr;
}

//
// Function called to add the loopback and internal interfaces which
// are required if IP was installed and which wouldn't be installed
// in nt4.
//
DWORD
IpCreateLoopbackAndInternalIfs(
    IN HANDLE hConfig)
{
    DWORD dwErr = NO_ERROR;
    MPR_INTERFACE_0 If0, *pIf0 = &If0;
    HANDLE hIf = NULL;
    
    do
    {
        // If the loopback interface is not already installed,
        // go ahead and create it
        //
        dwErr = MprConfigInterfaceGetHandle(
                    hConfig,
                    (PWCHAR)c_szwLoopbackAdapter,
                    &hIf);
        if (dwErr != NO_ERROR)
        {
            // Initialize the loopback interface info
            //
            ZeroMemory(pIf0, sizeof(MPR_INTERFACE_0));
            wcscpy(pIf0->wszInterfaceName, c_szwLoopbackAdapter);
            pIf0->hInterface = INVALID_HANDLE_VALUE;
            pIf0->fEnabled = TRUE;
            pIf0->dwIfType = ROUTER_IF_TYPE_LOOPBACK;

            // Create the loopback interface        
            dwErr = MprConfigInterfaceCreate(hConfig, 0, (LPBYTE)pIf0, &hIf);
            BREAK_ON_ERROR(dwErr);
        }

        // Add an ip interface blob to the interface if not already there
        //
        dwErr = IpAddDefaultInfoToInterface(hConfig, hIf);   
        BREAK_ON_ERROR(dwErr);
        hIf = NULL;

        // Make sure internal interface gets installed
        // (will be there if IPX was installed)
        //
        dwErr = MprConfigInterfaceGetHandle(
                    hConfig,
                    (PWCHAR)c_szwInternalAdapter,
                    &hIf);
        if (dwErr != NO_ERROR)
        {
            // Initialize the internal interface info
            //
            ZeroMemory(pIf0, sizeof(MPR_INTERFACE_0));
            wcscpy(pIf0->wszInterfaceName, c_szwInternalAdapter);
            pIf0->hInterface = INVALID_HANDLE_VALUE;
            pIf0->fEnabled = TRUE;
            pIf0->dwIfType = ROUTER_IF_TYPE_INTERNAL;

            // Create the internal interface        
            dwErr = MprConfigInterfaceCreate(hConfig, 0, (LPBYTE)pIf0, &hIf);
            BREAK_ON_ERROR(dwErr);
        }

        // Add an ip interface blob to the interface if not already there
        //
        dwErr = IpAddDefaultInfoToInterface(hConfig, hIf);   
        BREAK_ON_ERROR(dwErr);
        
    } while (FALSE);        

    // Cleanup
    {
    }

    return dwErr;
}

//
// Callback to interface enumeration function that upgrades
// the interface names.
//
// Returns TRUE to continue the enumeration, FALSE to stop 
// it.
//
BOOL SteelHeadUpgradeInterface (
        IN HANDLE hConfig,          
        IN MPR_INTERFACE_0 * pIf,   
        IN HANDLE hUserData)
{
    DWORD dwErr;

    do {
        if (IfNeedsNameUpdate(pIf))
        {
    	    // Update the interface name
    	    dwErr = UpdateInterfaceName(pIf->wszInterfaceName);
    	    if (dwErr != NO_ERROR) {
    		    PrintMessage(L"UpdateIfName failed -- returning error.\n");
    		    UtlPrintErr(GetLastError());
    		    break;
    	    }

    	    // Commit the changed interface name
    	    dwErr = CommitInterfaceNameChange(pIf);  
    	    if (dwErr != NO_ERROR) {
    		    PrintMessage(L"CommitInterfaceNameChange failed.\n");
    		    break;
    	    }

    	    // Update the ipx data
    	    UpdateIpxIfData(
                hConfig,
                pIf->hInterface);
        }    	    

	    // Update the ip data
	    UpdateIpIfData(
            hConfig,
            pIf->hInterface);

    } while (FALSE);

    // Cleanup
    {
    }

    return TRUE;
}

//
//	Function	UpdateIpxInterfaces
//
//	Updates all of the interfaces as needed to 
//  upgrade the router from steelhead to nt5
//
DWORD UpdateInterfaces() {
    DWORD dwErr = NO_ERROR;
    HANDLE hConfig = NULL;

    do
    {
        // Enumerate the interfaces, upgrading the interface 
        // names, etc as we go.
        //
        dwErr = UtlEnumerateInterfaces(
                    SteelHeadUpgradeInterface,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        
        // If ip is installed, we need to add the loopback and
        // internal interface for ip.
        dwErr = MprConfigServerConnect(NULL, &hConfig);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        dwErr = IpCreateLoopbackAndInternalIfs(hConfig);
        if (dwErr != NO_ERROR)
        {
            break;
        }
            
    } while (FALSE);        

    // Cleanup
    {
        if (hConfig)
        {
            MprConfigServerDisconnect(hConfig);
        }
    }

    return dwErr;
}

// Copy any values that are in hkSrc but not in hkDst into hkDst.
DWORD MergeRegistryValues(HKEY hkDst, HKEY hkSrc) {
    DWORD dwErr, dwCount, dwNameSize, dwDataSize;
    DWORD dwType, i, dwCurNameSize, dwCurValSize;
    PWCHAR pszNameBuf, pszDataBuf;
    
    // Find out how many values there are in the source
    dwErr = RegQueryInfoKey (hkSrc,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &dwCount,
                             &dwNameSize,
                             &dwDataSize,
                             NULL,
                             NULL);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    dwNameSize++;
    dwDataSize++;

    __try {
        // Allocate the buffers
        pszNameBuf = (PWCHAR) UtlAlloc(dwNameSize * sizeof(WCHAR));
        pszDataBuf = (PWCHAR) UtlAlloc(dwDataSize * sizeof(WCHAR));
        if (!pszNameBuf || !pszDataBuf)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Loop through the values
        for (i = 0; i < dwCount; i++) {
            dwCurNameSize = dwNameSize;
            dwCurValSize = dwDataSize;

            // Get the current source value 
            dwErr = RegEnumValueW(
                        hkSrc, 
                        i, 
                        pszNameBuf, 
                        &dwCurNameSize,
                        0,
                        &dwType,
                        (LPBYTE)pszDataBuf,
                        &dwCurValSize);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Find out if a value of the same name exists 
            // in the destination key. If it does, we don't 
            // overwrite it.
            dwErr = RegQueryValueExW(
                        hkDst, 
                        pszNameBuf, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr == ERROR_SUCCESS)
                continue;

            // Copy the value over
            RegSetValueExW(
                hkDst, 
                pszNameBuf, 
                0, 
                dwType, 
                (LPBYTE)pszDataBuf, 
                dwCurValSize);
        }
    }
    __finally {
        if (pszNameBuf)
            UtlFree(pszNameBuf);
        if (pszDataBuf)
            UtlFree(pszDataBuf);
    }

    return NO_ERROR;
}

// Recursively copies all of the subkeys of the given registry source to the
// given registry destination.
DWORD CopyRegistryKey(
        IN HKEY hkDst, 
        IN HKEY hkSrc, 
        IN PWCHAR pszSubKey, 
        IN LPSTR pszTempFile) 
{
    DWORD dwErr;
    HKEY hkSrcTemp;

    // Open the subkey in the source
    dwErr = RegOpenKeyExW(hkSrc, pszSubKey, 0, KEY_ALL_ACCESS, &hkSrcTemp);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    // Save off that subkey in a temporary file
    if ((dwErr = RegSaveKeyA(hkSrcTemp, pszTempFile, NULL)) != ERROR_SUCCESS)
        return dwErr;

    // Copy the saved information into the new key
    RegRestoreKeyA(hkDst, pszTempFile, 0);

    // Close off the temporary source key
    RegCloseKey(hkSrcTemp);

    // Delete the temp file
    DeleteFileA(pszTempFile);

    return NO_ERROR;
}

// Filters which subkeys in the router registry hive should be
// overwritten with saved off values during upgrade.
BOOL OverwriteThisSubkey(PWCHAR pszSubKey) {
    if (_wcsicmp(pszSubKey, L"Interfaces") == 0)
        return TRUE;
        
    if (_wcsicmp(pszSubKey, L"RouterManagers") == 0)
        return TRUE;
        
    return FALSE;
}

// Copy all keys that are in hkSrc but not in hkDst into hkDst.  
// By copy we mean all subkeys and values are propagated over.
DWORD MergeRegistryKeys(HKEY hkDst, HKEY hkSrc) {
    DWORD dwErr, dwCount, dwNameSize, dwType, i;
    DWORD dwCurNameSize, dwDisposition;
    char pszTempFile[512], pszTempPath[512];
    PWCHAR pszNameBuf;
    HKEY hkTemp;

    // Create the path to the temp file directory
    if (!GetTempPathA(512, pszTempPath))
        return GetLastError();

    // Create the temp file name
    if (!GetTempFileNameA(pszTempPath, "rtr", 0, pszTempFile))
        return GetLastError();

    // Delete the temp file created with GetTempFileName(...)
    DeleteFileA(pszTempFile);

    // Find out how many keys there are in the source
    dwErr = RegQueryInfoKey (
                hkSrc,
                NULL,
                NULL,
                NULL,
                &dwCount,
                &dwNameSize,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    dwNameSize++;

    __try {
        // Allocate the buffers
        pszNameBuf = (PWCHAR) UtlAlloc(dwNameSize * sizeof(WCHAR));
        if (!pszNameBuf)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Loop through the keys
        for (i = 0; i < dwCount; i++) {
            dwCurNameSize = dwNameSize;

            // Get the current source key 
            dwErr = RegEnumKeyExW(
                        hkSrc, 
                        i, 
                        pszNameBuf, 
                        &dwCurNameSize,
                        0,
                        NULL,
                        NULL,
                        NULL);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Create the new subkey in the destination
            dwErr = RegCreateKeyExW(
                        hkDst, 
                        pszNameBuf, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkTemp, 
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // If the subkey was created (not opened), 
            // copy over the key from hkSrc
            if (dwDisposition == REG_CREATED_NEW_KEY) {
                CopyRegistryKey(
                    hkTemp, 
                    hkSrc, 
                    pszNameBuf, 
                    pszTempFile);
            }                    
            
            // Otherwise, if this is one of the keys that we 
            // should overwrite, do so now.
            else {
                if (OverwriteThisSubkey(pszNameBuf)) {
                    CopyRegistryKey(
                        hkTemp, 
                        hkSrc, 
                        pszNameBuf, 
                        pszTempFile);
                }                        
            }

            // Close up the temporary handles
            RegCloseKey(hkTemp);
            hkTemp = NULL;
        }
    }
    __finally {
        if (pszNameBuf)
            UtlFree(pszNameBuf);
    }

    return NO_ERROR;
}

// Restore the registry from from backup
//
DWORD 
RestoreRegistrySteelhead(
    IN PWCHAR pszBackup) 
{
	HKEY hkRouter = NULL, hkRestore = NULL;
	DWORD dwErr = NO_ERROR, dwDisposition;
    PWCHAR pszRestore = L"Temp";

	// Merge the router key values and sub keys with the 
	// remote access key
	do
	{
	    // Get access to the router registry key
	    //
	    dwErr = UtlAccessRouterKey(&hkRouter);
	    if (dwErr != NO_ERROR) 
	    {
		    PrintMessage(L"Unable to access router key.\n");
		    break;
	    }

        // Load in the saved router settings
        //
        dwErr = UtlLoadSavedSettings(
                    hkRouter,
                    pszRestore,
                    pszBackup,
                    &hkRestore);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

        // Merge all of the values in the restored key
        //
        dwErr = MergeRegistryValues(hkRouter, hkRestore);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Give yourself backup and restore privilege
        //
        UtlSetupBackupPrivelege (TRUE);
        UtlSetupRestorePrivilege(TRUE);

        // Merge all of the keys in the restored key
        //
        dwErr = MergeRegistryKeys(hkRouter, hkRestore);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

	} while (FALSE);

    // Cleanup
	{
        if (hkRestore)
        {
            UtlDeleteRegistryTree(hkRestore);
            RegCloseKey(hkRestore);
            RegDeleteKey(hkRouter, pszRestore);
        }
        if (hkRouter)
        {
		    RegCloseKey(hkRouter);
		}
        UtlSetupBackupPrivelege (FALSE);
        UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

//
// Upgrades the remoteaccess registry with the router 
// configuration from nt4.
//
DWORD SteelheadToNt5Upgrade (PWCHAR BackupFileName) {
	DWORD dwErr = NO_ERROR;
	HANDLE hMapperParam;

	do
	{
		// Prepare the old interface name -> new if name mapper
		dwErr = SeedInterfaceNameMapper(&hMapperParam);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to seed if name mapper.\n");
		}
		else
		{
    		// Copy all of registry data that has been backed up.
    		dwErr = RestoreRegistrySteelhead(BackupFileName);
    		if (dwErr != NO_ERROR) 
    		{
    			PrintMessage(L"Unable to restore registry.\n");
    		}
    		else
    		{
        		// Update all of the interfaces accordingly
        		dwErr = UpdateInterfaces();
        		if (dwErr != NO_ERROR) 
        		{
        			PrintMessage(L"Unable to update interfaces.\n");
        		}
    		}
		}

		// Add 'router' usage to all ports
		//
		dwErr = MprPortSetUsage(MPRFLAG_PORT_Router);
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to update interfaces.\n");
		}

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
		}

	} while (FALSE);

	// Cleanup
	{
		CleanupInterfaceNameMapper(hMapperParam);
	}

	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\tools\b3rasace\dsrights.h ===
/*
    File    dsrights.h

    header for project that establishes a ras server 
    in a domain.

    Paul Mayfield, 4/20/98
*/    

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#define INC_OLE2
#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <tchar.h>
#define SECURITY_WIN32
#include <sspi.h>

#include <activeds.h>
#include <adsi.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>
#include <aclapi.h>

#ifdef __cplusplus
extern "C" {
#endif

DWORD DsrTraceInit();
DWORD DsrTraceCleanup();

DWORD DsrTraceEx (DWORD dwErr, LPSTR pszTrace, ...);

#define DSR_ERROR(e) ((HRESULT_FACILITY((e)) == FACILITY_WIN32) ? HRESULT_CODE((e)) : (e));
#define DSR_FREE(s) if ((s)) DsrFree ((s))
#define DSR_RELEASE(s) if ((s)) (s)->Release();
#define DSR_BREAK_ON_FAILED_HR(_hr) {if (FAILED((_hr))) break;}

//
// Typedefs
//
typedef struct _DSRINFO 
{
    PWCHAR pszMachineDN;
    PWCHAR pszGroupDN;    
} DSRINFO;

//
// Memory management routines
//
PVOID 
DsrAlloc (
        IN DWORD dwSize, 
        IN BOOL bZero);
        
DWORD 
DsrFree (
        IN PVOID pvBuf);

//
// Searches given domain for a computer account 
// with the given name and returns its ADsPath
// if found.
//
DWORD 
DsrFindDomainComputer (
        IN  PWCHAR  pszDomain,
        IN  PWCHAR  pszComputer,
        OUT PWCHAR* ppszADsPath);

//
// Searches given domain for the well known 
// "RAS and IAS Servers" group and returns 
// its ADsPath if found.
//
DWORD 
DsrFindRasServersGroup (
        IN  PWCHAR  pszDomain,
        OUT PWCHAR* ppszADsPath);
        
//
// Adds or removes a given object from a given group.
//
DWORD 
DsrGroupAddRemoveMember(
        IN PWCHAR pszGroupDN,
        IN PWCHAR pszNewMemberDN,
        IN BOOL bAdd);

//
// Returns whether the given object is a member of
// the given group.
//
DWORD 
DsrGroupIsMember(
        IN  PWCHAR pszGroupDN, 
        IN  PWCHAR pszObjectName, 
        OUT PBOOL  pbIsMember);

// 
// Sets the ACES in the given domain to enable nt4 servers
//
DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags);

//
// Discovers whether security is such that nt4 ras servers
// can authenticate.
//
DWORD
DsrDomainQueryAccess(
    IN  PWCHAR pszDomain, 
    OUT LPDWORD lpdwAccessFlags);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\sap.c ===
/*
	File:	sap.c

	Performs an upgrade of ipx sap to nt5 router 
	by munging registry values.

	Paul Mayfield, 9/3/97
*/

#include "upgrade.h"

// Structure for data passed to the enumeration 
// function.
typedef struct _SAP_ENUM_DATA {
    PSAP_IF_CONFIG pDefaults;
} SAP_ENUM_DATA;


// Globals
static WCHAR szIpxSapKey[] = 
    L"System\\CurrentControlSet\\Services\\RemoteAccess\\RouterManagers\\IPX\\RoutingProtocols\\IPXSAP\\Parameters";
static WCHAR szTempKey[] = L"DeleteMe";
static HKEY hkRouter = NULL;
static HKEY hkTemp = NULL;    
static HKEY hkIpxSap = NULL;
static PWCHAR IpxSapParams[] = 
{   
    L"SendTime", 
    L"EntryTimeout", 
    L"WANFilter", 
    L"WANUpdateTime", 
    L"MaxRecvBufferLookAhead", 
    L"RespondForInternalServers", 
    L"DelayRespondToGeneral", 
    L"DelayChangeBroadcast", 
    L"NameTableReservedHeapSize", 
    L"NameTableSortLatency", 
    L"MaxUnsortedNames", 
    L"TriggeredUpdateCheckInterval", 
    L"MaxTriggeredUpdateRequests", 
    L"ShutdownBroadcastTimeout", 
    L"RequestsPerInterface", 
    L"MinimumRequests" 
};


//
// Restore the registry from from backup and make sure 
// all global handles are opened
//
DWORD SapPrepareRegistry(
        IN PWCHAR BackupFileName) 
{
	DWORD dwErr, dwDisposition;

	// Get access to the router registry key
	dwErr = UtlAccessRouterKey(&hkRouter);
	if (dwErr != ERROR_SUCCESS) {
		PrintMessage(L"Unable to access router key.\n");
		return dwErr;
	}

	// Restore the router key from backup
	__try {
		// Open up the temporary key
		dwErr = RegCreateKeyEx(
		            hkRouter,
		            szTempKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkTemp,
		            &dwDisposition);
		if (dwErr != ERROR_SUCCESS)
			return dwErr;

		// Restore the saved registry information 
		// to the temp key
		UtlSetupRestorePrivilege(TRUE);
		dwErr = RegRestoreKeyW(
		            hkTemp,
		            BackupFileName,
		            0);
		if (dwErr != ERROR_SUCCESS) 
			return dwErr;

		// Open up the ipx sap params key
		dwErr = RegCreateKeyEx(
		            HKEY_LOCAL_MACHINE,
		            szIpxSapKey,
		            0,
		            NULL,
		            0,
		            KEY_ALL_ACCESS,
		            NULL,
		            &hkIpxSap,
		            &dwDisposition);
		if (dwErr != ERROR_SUCCESS)
			return dwErr;
	}
	__finally {
		UtlSetupRestorePrivilege(FALSE);
	}
	
	return NO_ERROR;
}

//
// Cleanup the work done in the registry
//
DWORD SapCleanupRegistry() {
	if (hkIpxSap)
		RegCloseKey(hkIpxSap);
	if (hkTemp) 
		RegCloseKey(hkTemp);
	if (hkRouter) {
		RegDeleteKey(hkRouter,szTempKey);
		RegCloseKey(hkRouter);
	}
	
    hkIpxSap = NULL;
    hkTemp = NULL;
    hkRouter = NULL;
    
	return NO_ERROR;
}

//
// Restores the sap parameters that were saved before upgrade.  
// Assumes those parameters are being stored temporarily in hkTemp
//
DWORD SapRestoreParameters() {
	DWORD dwErr, dwVal;
	PWCHAR* IpxSapParamPtr = IpxSapParams;
	dwt NwSapParams;

	// Load in the parameters that were set for nwsap
	__try {
		dwErr = dwtLoadRegistyTable(&NwSapParams, hkTemp);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Loop through the ipx params copying over any that applied 
		// to nwsap
		while (IpxSapParamPtr && *IpxSapParamPtr) {
		    dwErr = dwtGetValue(&NwSapParams, *IpxSapParamPtr, &dwVal);
			if (dwErr == NO_ERROR) {
				dwErr = RegSetValueEx(
				            hkIpxSap,
				            *IpxSapParamPtr,
				            0,
				            REG_DWORD,
				            (LPBYTE)&dwVal,
				            sizeof(DWORD));
				if (dwErr != ERROR_SUCCESS)
					return dwErr;
			}
			IpxSapParamPtr++;
		}
	}
	__finally {
		dwtCleanup(&NwSapParams);
	}

	return NO_ERROR;
}

//
// Installs sap in the router by initializing the 
// sap global info blob.
//
DWORD SapInstallTransportInfo(
        IN SAP_GLOBAL_INFO * pGlobal,
        IN SAP_IF_CONFIG * pIfDefaults) 
{
    LPBYTE pGlobalInfo = NULL, pDialinInfo = NULL;
    LPBYTE pNewGlobalInfo = NULL, pNewDialinInfo = NULL;
    HANDLE hConfig = NULL, hTrans = NULL;
    SAP_IF_CONFIG SapCfg, *pDialinCfg = &SapCfg;
    DWORD dwErr, dwGlobalInfoSize = 0, dwDialinInfoSize = 0;
    DWORD dwNewGlobSize = 0, dwNewDialSize = 0;

    do {
        // Connect to config server
        dwErr = MprConfigServerConnect(NULL, &hConfig);
        if (dwErr != NO_ERROR)
            break;

        // Get handle to global ipx tranport info
    	dwErr = MprConfigTransportGetHandle (
    				hConfig,
    				PID_IPX,
    				&hTrans);
        if (dwErr != NO_ERROR)
            break;

        // Get global ipx tranport info
        dwErr = MprConfigTransportGetInfo(
                    hConfig,
                    hTrans,
                    &pGlobalInfo,
                    &dwGlobalInfoSize,
                    &pDialinInfo,
                    &dwDialinInfoSize,
                    NULL);
        if (dwErr != NO_ERROR)
            break;

        // Initialize the global info blob
        dwErr = UtlUpdateInfoBlock(
                    FALSE,
                    pGlobalInfo,
                    IPX_PROTOCOL_SAP,
                    sizeof(SAP_GLOBAL_INFO),
                    1,
                    (LPBYTE)pGlobal,
                    &pNewGlobalInfo,
                    &dwNewGlobSize);
        if (dwErr != NO_ERROR) {
            if (dwErr != ERROR_ALREADY_EXISTS)
                break;
            pNewGlobalInfo = NULL;
            dwNewGlobSize = 0;
        }

        // Initialize the dialin info blob
        CopyMemory(pDialinCfg, pIfDefaults, sizeof(SAP_IF_CONFIG));
        pDialinCfg->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
        dwErr = UtlUpdateInfoBlock(
                    FALSE,
                    pDialinInfo,
                    IPX_PROTOCOL_SAP,
                    sizeof(SAP_IF_CONFIG),
                    1,
                    (LPBYTE)pDialinCfg,
                    &pNewDialinInfo,
                    &dwNewDialSize);
        if (dwErr != NO_ERROR) {
            if (dwErr != ERROR_ALREADY_EXISTS)
                break;
            pNewDialinInfo = NULL;
            dwNewDialSize = 0;
        }
                            
        // Set global ipx tranport info
        dwErr = MprConfigTransportSetInfo(
                    hConfig,
                    hTrans,
                    pNewGlobalInfo,
                    dwNewGlobSize,
                    pNewDialinInfo,
                    dwNewDialSize,
                    NULL);
        if (dwErr != NO_ERROR)
            break;
        
    } while (FALSE);

    // Cleanup
    {
        if (hConfig)
            MprConfigServerDisconnect(hConfig);
        if (pGlobalInfo)
            MprConfigBufferFree(pGlobalInfo);
        if (pDialinInfo)
            MprConfigBufferFree(pDialinInfo);
        if (pNewDialinInfo)
            MprConfigBufferFree(pNewDialinInfo);
        if (pNewGlobalInfo)
            MprConfigBufferFree(pNewGlobalInfo);
    }
    
    return dwErr;
}

//
// Callback function takes an interface and updates
// its ipx sap configuration.
//
// Returns TRUE to continue the enumerate, FALSE to 
// stop it
//
DWORD SapUpgradeInterface(
        IN HANDLE hConfig,
        IN MPR_INTERFACE_0 * pIf,
        IN HANDLE hUserData)
{
    SAP_ENUM_DATA* pData = (SAP_ENUM_DATA*)hUserData;
    SAP_IF_CONFIG SapCfg, *pConfig = &SapCfg;
    LPBYTE pTransInfo=NULL, pNewTransInfo=NULL;
    HANDLE hTransport = NULL;
    DWORD dwErr, dwSize, dwNewSize = 0;

    // Validate input
    if ((hConfig == NULL) || 
        (pIf == NULL)     || 
        (pData == NULL))
    {
        return FALSE;
    }

    // Initalize the config blob
    CopyMemory(pConfig, pData->pDefaults, sizeof(SAP_IF_CONFIG));

    // Customize the update mode for the router interface
    // type
    switch (pIf->dwIfType) {
        case ROUTER_IF_TYPE_DEDICATED:
            pConfig->SapIfInfo.UpdateMode = IPX_STANDARD_UPDATE;
            break;
            
        case ROUTER_IF_TYPE_INTERNAL:
        case ROUTER_IF_TYPE_CLIENT:
            pConfig->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
            break;
            
        case ROUTER_IF_TYPE_HOME_ROUTER:
        case ROUTER_IF_TYPE_FULL_ROUTER:
            pConfig->SapIfInfo.UpdateMode = IPX_AUTO_STATIC_UPDATE;
            break;
            
        case ROUTER_IF_TYPE_LOOPBACK:
        case ROUTER_IF_TYPE_TUNNEL1:
        default:
            return TRUE;
    }

    do {
        // Get the handle to ipx info associated with this if
        dwErr = MprConfigInterfaceTransportGetHandle(
                    hConfig,
                    pIf->hInterface,
                    PID_IPX,
                    &hTransport);
        if (dwErr != NO_ERROR)
            break;

        // Get the ipx info associated with this if
        dwErr = MprConfigInterfaceTransportGetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    &pTransInfo,
                    &dwSize);
        if (dwErr != NO_ERROR)
            break;

        // Update the info block
        dwErr = UtlUpdateInfoBlock(
                    FALSE,
                    pTransInfo,
                    IPX_PROTOCOL_SAP,
                    dwSize,
                    1,
                    (LPBYTE)pConfig,
                    &pNewTransInfo,
                    &dwNewSize);
        if (dwErr != NO_ERROR) {
            if (dwErr != ERROR_ALREADY_EXISTS)
                break;
            pNewTransInfo = NULL;
            dwNewSize = 0;
        }
        
        // Commit the change
        dwErr = MprConfigInterfaceTransportSetInfo(
                    hConfig,
                    pIf->hInterface,
                    hTransport,
                    pNewTransInfo,
                    dwNewSize);
        if (dwErr != NO_ERROR)
            break;
    } while (FALSE);   

    // Cleanup
    {
        if (pNewTransInfo)
            MprConfigBufferFree(pNewTransInfo);
        if (pTransInfo)
            MprConfigBufferFree(pTransInfo);
    }

    return TRUE;
}

// 
// Installs ipx sap in the router registry tree.
//
DWORD SapInstallInRouter()
{
    DWORD dwErr;
    SAP_IF_CONFIG SapConfig, * pSap = &SapConfig;
    SAP_ENUM_DATA SapBlobs = 
    {
        pSap
    };
    SAP_GLOBAL_INFO SapGlobal = 
    {
        EVENTLOG_ERROR_TYPE         // event log mask
    };

    // Clear all structures
    ZeroMemory (pSap, sizeof(SAP_IF_CONFIG));

    // Default lan configuration
    pSap->SapIfInfo.AdminState             = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.UpdateMode             = IPX_STANDARD_UPDATE;
    pSap->SapIfInfo.PacketType             = IPX_STANDARD_PACKET_TYPE;
    pSap->SapIfInfo.Supply                 = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.Listen                 = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.GetNearestServerReply  = ADMIN_STATE_ENABLED;
    pSap->SapIfInfo.PeriodicUpdateInterval = 60;
    pSap->SapIfInfo.AgeIntervalMultiplier  = 3;
    pSap->SapIfFilters.SupplyFilterAction  = IPX_SERVICE_FILTER_DENY;
    pSap->SapIfFilters.SupplyFilterCount   = 0;
    pSap->SapIfFilters.ListenFilterAction  = IPX_SERVICE_FILTER_DENY;
    pSap->SapIfFilters.ListenFilterCount   = 0;

    // Install default sap global info
    dwErr = SapInstallTransportInfo(&SapGlobal, pSap);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Enumerate the interfaces, updating each one with 
    // sap config as you go.
    dwErr = UtlEnumerateInterfaces(
                SapUpgradeInterface,
                &SapBlobs);
    if (dwErr != NO_ERROR)
        return dwErr;
        
    return NO_ERROR;
}


//
//	Performs all of the registry updating associated with an 
//  upgrade from ipx sap to router.
//
//	These are the steps:
//	1. Restore the parameters saved in FileName to szIpxSapKey.
//	2. Remove all parameters that ipx sap does not implement.
//
DWORD SapToRouterUpgrade(
        IN PWCHAR FileName) 
{
	DWORD dwErr;

	__try {
		// Restore the registry from the backup file
		dwErr = SapPrepareRegistry(FileName);
		if (dwErr != NO_ERROR)
			return dwErr;

		// Set the new registry parameters
		dwErr = SapRestoreParameters();
		if (dwErr != NO_ERROR)
			return dwErr;

	    // Install default sap global config and set default
	    // values in all router interfaces.
	    dwErr = SapInstallInRouter();
	    if (dwErr != NO_ERROR)
	        return dwErr;

		// Mark the computer as having been configured
		//
        dwErr = UtlMarkRouterConfigured();
		if (dwErr != NO_ERROR) 
		{
			PrintMessage(L"Unable to mark router as configured.\n");
			return dwErr;
		}
			
	}
	__finally {
		SapCleanupRegistry();
	}

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\utils.c ===
/*
	File	uitls.c

	A set of utilities useful for upgrading mpr v1 to NT 5.0.

	Paul Mayfield, 9/11/97
*/

#include "upgrade.h"
#include <rtcfg.h>
#include <mprapip.h>

CONST WCHAR c_szSystemCCSServices[] = L"System\\CurrentControlSet\\Services";
static const WCHAR c_szConfigurationFlags[] = L"ConfigurationFlags";
CONST WCHAR c_szRouter[] = L"RemoteAccess";

//
// Initializes a dword table with given initial count
// and maximum string size;
//
DWORD dwtInitialize(
        OUT dwt *This, 
        IN  DWORD dwCount, 
        IN  DWORD dwMaxSize) 
{
	DWORD i;
	
	if (!This)
		return ERROR_INVALID_PARAMETER;

    // Initialize the structure
    ZeroMemory(This, sizeof(dwt));
	This->dwCount = 0;
	This->dwSize = dwCount;

	// Allocate the table
	This->pValues = (dwValueNode *) UtlAlloc(
	                                dwCount * sizeof(dwValueNode));
	if (!This->pValues)
		return ERROR_NOT_ENOUGH_MEMORY;
	
	// Allocate all of the name strings
	for (i = 0; i < (DWORD)This->dwSize; i++) {
		This->pValues[i].Name = (PWCHAR) UtlAlloc(
		                                    dwMaxSize * sizeof(WCHAR));
		if (!This->pValues[i].Name)
		{
			return ERROR_NOT_ENOUGH_MEMORY;
	    }
	}

	return NO_ERROR;
}

//
// Free's resources held by the given dword table.
//
DWORD dwtCleanup(
        IN dwt * This) 
{
	DWORD i;
	
	if (!This)
	{
		return NO_ERROR;
    }

	for (i = 0; i < (DWORD)This->dwSize; i++) 
	{
		if (This->pValues[i].Name)
		{
			UtlFree(This->pValues[i].Name);
	    }
	}

	if (This->pValues)
	{
    	UtlFree(This->pValues);
    }
    
    return NO_ERROR;
}

// 
// Retrieves the given value from the table
//
DWORD dwtGetValue(
        IN  dwt * This, 
        IN  PWCHAR ValName, 
        OUT LPDWORD pValue) 
{
	DWORD i;

	if (!ValName || !pValue)
	{
		return ERROR_INVALID_PARAMETER;
    }

	for (i = 0; i < This->dwCount; i++) 
	{
		if (wcscmp(ValName,This->pValues[i].Name) == 0) 
		{
			*pValue = This->pValues[i].Value;
			return NO_ERROR;
		}
	}

	return ERROR_NOT_FOUND;
}

// 
// Loads all of the dword values of a given registry 
// key into a dword table.
//
DWORD dwtLoadRegistyTable(
        OUT dwt *This, 
        IN  HKEY hkParams) 
{
	DWORD dwErr, dwMaxSize, dwSize, dwCount, i;
	DWORD dwDataSize = sizeof(DWORD), dwType = REG_DWORD;

    if (!This)
        return ERROR_INVALID_PARAMETER;

    // Initialize the structure
    ZeroMemory(This, sizeof(dwt));

	// Find out how many parameters there are.
	dwErr = RegQueryInfoKey(
	            hkParams, 
	            NULL, 
	            NULL, 
	            NULL, 
	            NULL, 
	            NULL, 
	            NULL,
				&dwCount, 
				&dwMaxSize,
				NULL, 
				NULL, 
				NULL);
	if (dwErr != ERROR_SUCCESS)
		return dwErr;

	if (dwCount == 0) 
	{
		This->dwCount = This->dwSize = 0;
		return NO_ERROR;
	}
	dwMaxSize += 1;

    do 
    {
    	// Fill in the table
    	dwtInitialize(This, dwCount, dwMaxSize);
    	for (i = 0; i < dwCount; i++) 
    	{
    		dwSize = dwMaxSize;
    		dwErr = RegEnumValueW(
    		            hkParams,
    		             i,
    		             This->pValues[This->dwCount].Name,
    		             &dwSize,
    		             0,
    		             &dwType,
    		             NULL,
    		             NULL);
    		if (dwErr != ERROR_SUCCESS)
    		{
    			break;
    	    }
    	    if (dwType != REG_DWORD)
    	    {
    	        continue;
    	    }

    		dwErr = RegQueryValueExW(
    		            hkParams,
    		            This->pValues[This->dwCount].Name,
    		            0,
    		            &dwType,
    		            (LPBYTE)&(This->pValues[This->dwCount].Value),
    		            &dwDataSize);
    		if (dwErr != ERROR_SUCCESS)
    		{
    			break;
    	    }
    	    This->dwCount++;
        }    	    
        
	} while (FALSE);

	return dwErr;
}

DWORD dwtPrint(
        IN dwt *This) 
{
	DWORD i;

	if (!This)
		return ERROR_INVALID_PARAMETER;

	return NO_ERROR;
}

//
// Enumerates all of the subkeys of a given key
//
DWORD
UtlEnumRegistrySubKeys(
    IN HKEY hkRoot,
    IN PWCHAR pszPath,
    IN RegKeyEnumFuncPtr pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, i, dwNameSize = 0, dwCurSize = 0;
    DWORD dwCount = 0;
    HKEY hkKey = NULL, hkCurKey = NULL;
    PWCHAR pszName = NULL;
    BOOL bCloseKey = FALSE;

    do
    {
        if (pszPath)
        {
            bCloseKey = TRUE;
            // Open the key to enumerate
            //
            dwErr = RegOpenKeyExW(
                        hkRoot,
                        pszPath,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }     
        else
        {
            bCloseKey = FALSE;
            hkKey = hkRoot;
        }

        // Find out how many sub keys there are
        //
        dwErr = RegQueryInfoKeyW(
                    hkKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwCount,
                    &dwNameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }
        dwNameSize++;

        // Allocate the name buffer
        //
        pszName = (PWCHAR) UtlAlloc(dwNameSize * sizeof(WCHAR));
        if (pszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Loop through the keys
        //
        for (i = 0; i < dwCount; i++)
        {
            dwCurSize = dwNameSize;
            
            // Get the name of the current key
            //
            dwErr = RegEnumKeyExW(
                        hkKey, 
                        i, 
                        pszName, 
                        &dwCurSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Open the subkey
            //
            dwErr = RegOpenKeyExW(
                        hkKey,
                        pszName,
                        0,
                        KEY_ALL_ACCESS,
                        &hkCurKey);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Call the callback
            //
            dwErr = pCallback(pszName, hkCurKey, hData);
            RegCloseKey(hkCurKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }            

    } while (FALSE);

    // Cleanup
    {
        if ((hkKey != NULL) && (bCloseKey))
        {
            RegCloseKey(hkKey);
        }
        if (pszName)
        {
            UtlFree(pszName);
        }
    }

    return dwErr;
}

// 
// Enumerates interfaces from the registry
//
DWORD UtlEnumerateInterfaces (
        IN IfEnumFuncPtr pCallback,
        IN HANDLE hUserData)
{
    DWORD dwErr, i, dwIfCount, dwIfTot, dwResume = 0;
    DWORD dwPrefBufSize = sizeof(MPR_INTERFACE_0) * 100; 
    MPR_INTERFACE_0 * pIfs = NULL;
    HANDLE hConfig;
    BOOL bContinue = TRUE;

    // Validate parameters
    if (pCallback == NULL)
        return ERROR_INVALID_PARAMETER;

    // Connect to the configuration server
    dwErr = MprConfigServerConnect(NULL, &hConfig);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Get list of all interfaces
    dwErr = MprConfigInterfaceEnum(
                hConfig,
                0,
                (LPBYTE*)&pIfs,
                dwPrefBufSize,
                &dwIfCount,
                &dwIfTot,
                &dwResume);
    if (dwErr == ERROR_NO_MORE_ITEMS)
        return NO_ERROR;
    else if ((dwErr != NO_ERROR) && (dwErr != ERROR_MORE_DATA))
        return dwErr;

    // Loop through the interfaces
    do {
        // Call the callback for each interface as long
        // as we're instructed to continue
        for (i = 0; i < dwIfCount; i++) {
            if (bContinue) {
                bContinue = (*pCallback)(
                                hConfig, 
                                &(pIfs[i]), 
                                hUserData);
            }                                
        }
        if (bContinue == FALSE)
            break;
        
        // Free up the interface list buffer
	    if (pIfs)
		    MprConfigBufferFree(pIfs);
        pIfs = NULL;

        // Get list of all ip interfaces
        dwErr = MprConfigInterfaceEnum(
                    hConfig,
                    0,
                    (LPBYTE*)&pIfs,
                    dwPrefBufSize,
                    &dwIfCount,
                    &dwIfTot,
                    &dwResume);
                    
        if (dwErr == ERROR_NO_MORE_ITEMS) {
            dwErr = NO_ERROR;
            break;
        }
	    else if ((dwErr != NO_ERROR) && (dwErr != ERROR_MORE_DATA))
		    break;
		else
		    continue;
    } while (TRUE);        

    // Cleanup
    {
	    if (pIfs)
		    MprConfigBufferFree(pIfs);
        if (hConfig)
            MprConfigServerDisconnect(hConfig);
    }

    return dwErr;
}

//
// If the given info blob exists in the given toc header
// reset it with the given information, otherwise add
// it as an entry in the TOC.
//
DWORD UtlUpdateInfoBlock (
        IN  BOOL    bOverwrite,
        IN  LPVOID  pHeader,
        IN  DWORD   dwEntryId,
        IN  DWORD   dwSize,
        IN  DWORD   dwCount,
        IN  LPBYTE  pEntry,
        OUT LPVOID* ppNewHeader,
        OUT LPDWORD lpdwNewSize)
{
    PRTR_INFO_BLOCK_HEADER pNewHeader;
    DWORD dwErr;
    
    // Attempt to find the entry
    dwErr = MprInfoBlockFind(
                pHeader,
                dwEntryId,
                NULL,
                NULL,
                NULL);

    // If we find it, reset it
    if (dwErr == NO_ERROR) {
        if (bOverwrite) {
            dwErr = MprInfoBlockSet(
                        pHeader,
                        dwEntryId,
                        dwSize,
                        dwCount,
                        pEntry,
                        ppNewHeader);
            if (dwErr == NO_ERROR) {
                pNewHeader = (PRTR_INFO_BLOCK_HEADER)(*ppNewHeader);
                *lpdwNewSize = pNewHeader->Size;
            }
        }                        
        else {
            return ERROR_ALREADY_EXISTS;
        }
    }

    // Otherwise, create it
    else if (dwErr == ERROR_NOT_FOUND) {
        dwErr = MprInfoBlockAdd(
                    pHeader,
                    dwEntryId,
                    dwSize,
                    dwCount,
                    pEntry,
                    ppNewHeader);
        if (dwErr == NO_ERROR) {
            pNewHeader = (PRTR_INFO_BLOCK_HEADER)(*ppNewHeader);
            *lpdwNewSize = pNewHeader->Size;
        }
    }

    return dwErr;
}


// Common allocation routine
PVOID UtlAlloc (DWORD dwSize) {
    return RtlAllocateHeap (RtlProcessHeap (), 0, dwSize);
}

// Common deallocation routine
VOID UtlFree (PVOID pvBuffer) {
    RtlFreeHeap (RtlProcessHeap (), 0, pvBuffer);
}

// Copies a string
//
PWCHAR
UtlDupString(
    IN PWCHAR pszString)
{
    PWCHAR pszRet = NULL;

    if ((pszString == NULL) || (*pszString == L'\0'))
    {
        return NULL;
    }

    pszRet = (PWCHAR) UtlAlloc((wcslen(pszString) + 1) * sizeof(WCHAR));
    if (pszRet == NULL)
    {
        return NULL;
    }

    wcscpy(pszRet, pszString);
    
    return pszRet;
}

// Error reporting
void UtlPrintErr(DWORD err) {
	WCHAR buf[1024];
	FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,0,buf,1024,NULL);
	PrintMessage(buf);
	PrintMessage(L"\n");
}


//----------------------------------------------------------------------------
// Function:    UtlAccessRouterKey
//
// Creates/opens the Router key on HKEY_LOCAL_MACHINE.
//----------------------------------------------------------------------------
DWORD UtlAccessRouterKey(HKEY* hkeyRouter) {
    LPWSTR lpwsPath;
    DWORD dwErr, dwSize;

    if (!hkeyRouter) 
		return ERROR_INVALID_PARAMETER; 

    *hkeyRouter = NULL;

    //
    // compute the length of the string 
    //
    dwSize = lstrlen(c_szSystemCCSServices) + 1 + lstrlen(c_szRouter) + 1;

    //
    // allocate space for the path
    //
    lpwsPath = (LPWSTR)UtlAlloc(dwSize * sizeof(WCHAR));
    if (!lpwsPath) 
		return ERROR_NOT_ENOUGH_MEMORY;

    wsprintf(lpwsPath, L"%s\\%s", c_szSystemCCSServices, c_szRouter);

    //
    // open the router key
    //
    dwErr = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE, lpwsPath, 0, KEY_ALL_ACCESS, hkeyRouter
                );
	if (dwErr!=ERROR_SUCCESS) {
		PrintMessage(L"ERROR in UtlAccessRouterKey\n");
	}

    UtlFree(lpwsPath);
    return dwErr;
}

//----------------------------------------------------------------------------
// Function:    UtlSetupBackupPrivelege
//
// Enables/disables backup privilege for the current process.
//----------------------------------------------------------------------------
DWORD UtlEnablePrivilege(PWCHAR pszPrivilege, BOOL bEnable) {
    LUID luid;
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;

    OpenProcessToken(
            GetCurrentProcess(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
            &hToken);

    if (! LookupPrivilegeValueW(NULL, pszPrivilege, &luid))
    {
        return GetLastError();
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (! AdjustTokenPrivileges(
            hToken, 
            !bEnable, 
            &tp, 
            sizeof(TOKEN_PRIVILEGES), 
            NULL, 
            NULL)) 
    {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD UtlSetupBackupPrivelege(BOOL bEnable) {
    return UtlEnablePrivilege(SE_BACKUP_NAME, bEnable);
}

DWORD UtlSetupRestorePrivilege(BOOL bEnable) {
    return UtlEnablePrivilege(SE_RESTORE_NAME, bEnable);
}

// Loads the given saved off settings into a temporary key 
// and returns a handle to that key.
//
DWORD 
UtlLoadSavedSettings(
    IN  HKEY   hkRoot,
    IN  PWCHAR pszTempKey,
    IN  PWCHAR pszFile,
    OUT HKEY*  phkTemp) 
{
	HKEY hkRestore = NULL;
	DWORD dwErr = NO_ERROR, dwDisposition = 0;
    BOOL bBackup = FALSE, bRestore = FALSE;

	do
	{
        // Enable the backup and restore priveleges
        //
        bBackup  = (UtlSetupBackupPrivelege (TRUE) == NO_ERROR);
        bRestore = (UtlSetupRestorePrivilege(TRUE) == NO_ERROR);
        if (!bBackup || !bRestore)
        {
            return ERROR_CAN_NOT_COMPLETE;
        }

        // Create a temporary key into which the saved config
        // can be loaded.
        //
        if ((dwErr = RegCreateKeyExW(
                        hkRoot, 
                        pszTempKey, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, 
                        NULL,
                        &hkRestore,
                        &dwDisposition)) != NO_ERROR) 
        {
            PrintMessage(L"Unable to create restore key.\n");
            break;
        }

        // Load the saved configuration
        //
        dwErr = RegRestoreKey(hkRestore, pszFile, 0);
        if (dwErr != ERROR_SUCCESS)
        {
             break;
        }

        // Assign the return value
        //
        *phkTemp = hkRestore;

	} while (FALSE);

    // Cleanup
	{
        if (bBackup)
        {
            UtlSetupBackupPrivelege(FALSE);
        }
        if (bRestore)
        {
            UtlSetupRestorePrivilege(FALSE);
        }
	}
	
	return NO_ERROR;
}

//
// Delete the tree of registry values starting at hkRoot
//
DWORD 
UtlDeleteRegistryTree(
    IN HKEY hkRoot) 
{
    DWORD dwErr, dwCount, dwNameSize, dwDisposition;
    DWORD i, dwCurNameSize;
    PWCHAR pszNameBuf;
    HKEY hkTemp;
    
    // Find out how many keys there are in the source
    dwErr = RegQueryInfoKey (
                hkRoot,
                NULL,
                NULL,
                NULL,
                &dwCount,
                &dwNameSize,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;
    
    dwNameSize++;

    __try {
        // Allocate the buffers
        pszNameBuf = (PWCHAR) 
                        UtlAlloc(dwNameSize * sizeof(WCHAR));
        if (!pszNameBuf)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Loop through the keys -- deleting all subkey trees
        for (i = 0; i < dwCount; i++) {
            dwCurNameSize = dwNameSize;

            // Get the current source key 
            dwErr = RegEnumKeyExW(
                        hkRoot, 
                        i, 
                        pszNameBuf, 
                        &dwCurNameSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Open the subkey
            dwErr = RegCreateKeyExW(
                        hkRoot, 
                        pszNameBuf, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL, 
                        &hkTemp, 
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Delete the subkey tree
            UtlDeleteRegistryTree(hkTemp);

            // Close the temp handle
            RegCloseKey(hkTemp);
        }

        // Loop through the keys -- deleting all subkeys themselves
        for (i = 0; i < dwCount; i++) 
        {
            dwCurNameSize = dwNameSize;

            // Get the current source key 
            dwErr = RegEnumKeyExW(
                        hkRoot, 
                        0, 
                        pszNameBuf, 
                        &dwCurNameSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
                continue;

            // Delete the subkey tree
            dwErr = RegDeleteKey(hkRoot, pszNameBuf);
        }
    }
    __finally {
        if (pszNameBuf)
            UtlFree(pszNameBuf);
    }

    return NO_ERROR;
}

DWORD
UtlMarkRouterConfigured()
{
    DWORD dwErr, dwVal;
	HKEY hkRouter = NULL;

    dwErr = UtlAccessRouterKey(&hkRouter);
    if (dwErr == NO_ERROR)
    {
        dwVal = 1;
        
        RegSetValueEx(
            hkRouter,
            c_szConfigurationFlags,
            0,
            REG_DWORD,
            (CONST BYTE*)&dwVal,
            sizeof(DWORD));
            
	    RegCloseKey(hkRouter);
    }
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\upgrade.h ===
/*
	File	upgrade.h
	
	Implementation of functions to update the registry when an
	NT 4.0 to NT 5.0 upgrade takes place.

	Paul Mayfield, 8/11/97

	Copyright 1997 Microsoft.
*/

#ifndef __Rtrupgrade_h
#define __Rtrupgrade_h

#define UNICODE
#define MPR50 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <rpc.h>
#include <setupapi.h>
#include <mprapi.h>
#include <mprapip.h>
#include <routprot.h>
#include "utils.h"
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <fltdefs.h>
#include <iprtinfo.h>

#define GUIDLENGTH 45
#define MAX_INTEFACE_NAME_LEN 256

//
// Entry point for doing router upgrades
//
HRESULT 
WINAPI 
RouterUpgrade (
    DWORD dwUpgradeFlag,
    DWORD dwUpgradeFromBuildNumber,
    PWCHAR szAnswerFileName,
    PWCHAR szSectionName);

//
// Functions that do the actual upgrading
//
DWORD 
SteelheadToNt5Upgrade (
    PWCHAR FileName);
    
DWORD 
IpRipToRouterUpgrade(
    PWCHAR FileName);
    
DWORD 
SapToRouterUpgrade(
    PWCHAR FileName);
    
DWORD 
DhcpToRouterUpgrade(
    PWCHAR FileName);

DWORD
RadiusToRouterUpgrade(
    IN PWCHAR pszFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\steelhead2nt5\utils.h ===
/*
	File	uitls.h

	A set of utilities useful for upgrading mpr v1 to NT 5.0.

	Paul Mayfield, 9/11/97
*/

#ifndef _rtrupg_utils_h
#define _rtrupg_utils_h

// 
// Definitions for a DWORD table (dwt)
// 
typedef struct _tag_dwValueNode 
{
	PWCHAR Name;
	DWORD Value;
} dwValueNode;

typedef struct _tag_DWordTable 
{
	DWORD dwCount;
	DWORD dwSize;
	dwValueNode * pValues;
} dwt, *pdwt;

//
// Typedef for callback functions in interface enumeration.
// Return TRUE to continue the enumeration, FALSE to stop it.
//
typedef 
BOOL 
(*IfEnumFuncPtr)(
    IN HANDLE hConfig,          // MprConfig handle
    IN MPR_INTERFACE_0 * pIf,   // Interface reference
    IN HANDLE hUserData);       // User defined

//
// Typedef for callback functions for enumerating registry sub keys.
// Return NO_ERROR to continue, error code to stop.
//
typedef 
DWORD
(*RegKeyEnumFuncPtr)(
    IN PWCHAR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData);

//
// Functions that manipulate dword tables
//
DWORD 
dwtInitialize(
    IN dwt *This, 
    IN DWORD dwCount, 
    IN DWORD dwMaxSize);
    
DWORD 
dwtCleanup(
    IN dwt *This);
    
DWORD 
dwtPrint(IN dwt *This);

DWORD 
dwtGetValue(
    IN  dwt *This, 
    IN  PWCHAR ValName, 
    OUT LPDWORD pValue);
    
DWORD 
dwtLoadRegistyTable(
    IN dwt *This, 
    IN HKEY hkParams);

// 
// Enumerates interfaces from the registry
//
DWORD 
UtlEnumerateInterfaces (
    IN IfEnumFuncPtr pCallback,
    IN HANDLE hUserData);

DWORD
UtlEnumRegistrySubKeys(
    IN HKEY hkRoot,
    IN PWCHAR pszPath,
    IN RegKeyEnumFuncPtr pCallback,
    IN HANDLE hData);

//
// If the given info blob exists in the given toc header
// reset it with the given information, otherwise add
// it as an entry in the TOC.
//
DWORD 
UtlUpdateInfoBlock (
    IN  BOOL    bOverwrite,
    IN  LPVOID  pHeader,
    IN  DWORD   dwEntryId,
    IN  DWORD   dwSize,
    IN  DWORD   dwCount,
    IN  LPBYTE  pEntry,
    OUT LPVOID* ppNewHeader,
    OUT LPDWORD lpdwNewSize);

//
// Other handy definitions
//
#if DBG
	#define PrintMessage OutputDebugStringW
#else
	#define PrintMessage 
#endif

// Common allocation routine
PVOID 
UtlAlloc (
    IN DWORD dwSize);

// Common deallocation routine
VOID 
UtlFree (
    PVOID pvBuffer);

PWCHAR
UtlDupString(
    IN PWCHAR pszString);
    
// Error printing
void 
UtlPrintErr(
    DWORD err);

// Helper functions
DWORD 
UtlAccessRouterKey(
    HKEY* hkeyRouter);
    
DWORD 
UtlSetupBackupPrivelege(
    BOOL bEnable);
    
DWORD 
UtlSetupRestorePrivilege(
    BOOL bEnable);

DWORD 
UtlLoadSavedSettings(
    IN  HKEY   hkRoot,
    IN  PWCHAR pszTempKey,
    IN  PWCHAR pszFile,
    OUT PHKEY  phTemp);

DWORD 
UtlDeleteRegistryTree(
    IN HKEY hkRoot);

DWORD
UtlMarkRouterConfigured();

      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\tools\b3rasace\main.c ===
/*
    File:   main.c, main.cpp

    Simple test shell.

    Paul Mayfield, 4/13/98
*/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <mprapi.h>
#include <rtutils.h>

#define DWERR_BREAK(dwErr) {if (dwErr != NO_ERROR) break;}

DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags);

//
// Initializes the trace mechanism
//
DWORD 
DsrTraceInit()
{
    return NO_ERROR;
}

//
// Cleans up the trace mechansim
//
DWORD 
DsrTraceCleanup()
{
    return NO_ERROR;
}

//
// Sends debug trace and returns the given error
//
DWORD 
DsrTraceEx (
    IN DWORD dwErr, 
    IN LPSTR pszTrace, 
    IN ...) 
{
    va_list arglist;
    char szTemp[1024];

    va_start(arglist, pszTrace);
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    printf("%s\n", szTemp);

    return dwErr;
}

void
Usage(char* pszExe)
{
    printf("\n");
    printf("Tool for cleaning up ACEs added by Windows 2000 Beta3 and RC1 setup\n");
    printf("to grant user account access to legacy RAS servers.\n");
    printf("\n");
    printf("Usage\n");
    printf("\t%s -d <domain>\n", pszExe);
    printf("\n");
}

int __cdecl main(int argc, char** argv) 
{
    DWORD dwErr = NO_ERROR, iErr = 0;
    WCHAR pszDomain[512];
    int iSize = sizeof(pszDomain) / sizeof(WCHAR);

    if (argc != 3)
    {
        Usage(argv[0]);
        return 0;
    }

    if (strcmp(argv[1], "-d") != 0)
    {
        Usage(argv[0]);
        return 0;
    }
    
    // Parse out the domain
    //
    iErr = MultiByteToWideChar(CP_ACP, 0, argv[2], -1, pszDomain, iSize);
    if (iErr == 0)
    {
        printf("Unable to convert %s to unicode.\n", argv[2]);
        printf("Error: 0x%x\n", GetLastError());
        return 0;
    }

    // Set the access
    //
    DsrTraceInit();
    dwErr = DsrDomainSetAccess(pszDomain, 0);
    DsrTraceCleanup();

    // Display results
    //
    if (dwErr == NO_ERROR)
    {
        printf("Success.\n");
    }
    else
    {
        printf("Error.\n");
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\inc\events.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	events.h
//
// Description: Text and corresponding values of events are defined here.
//
// History: 	May 11,1992.	NarenG		Created original version.
//


// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define AFP_LOG_BASE			10000

#define AFPLOG_CANT_START		(AFP_LOG_BASE+1)
/*
 *Unable to start the File Server for Macintosh service.
 *A system specific error has occured.
 *The error code is in the data 
 */

#define AFPLOG_CANT_INIT_RPC		(AFP_LOG_BASE+2)
/*
 *The File Server for Macintosh service failed to start. Unable to setup
 *the server to accept Remote Procedure Calls.
 */

#define AFPLOG_CANT_CREATE_SECOBJ	(AFP_LOG_BASE+3)
/*
 *The File Server for Macintosh service failed to start. 
 * Security access checking of administrators could not be setup correctly.
 */

#define AFPLOG_CANT_OPEN_REGKEY		(AFP_LOG_BASE+4)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry could not be opened.
 */

#define AFPLOG_CANT_OPEN_FSD		(AFP_LOG_BASE+5)
/*
 *The File Server for Macintosh service failed to start. 
 *Unable to open the Appletalk Filing Protocol file system driver (SfmSrv.sys).
 */

#define AFPLOG_INVALID_SERVERNAME	(AFP_LOG_BASE+6)
/*
 *The Registry contains an invalid value for the server name parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_SRVOPTION	(AFP_LOG_BASE+7)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the server options parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_MAXSESSIONS	(AFP_LOG_BASE+8)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the maximum sessions parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_LOGINMSG		(AFP_LOG_BASE+9)
/*
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the logon message parameter.
 *Verify the value of this parameter through the Computer Managerment Console 
 *and in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_MAXPAGEDMEM	(AFP_LOG_BASE+10)
/*
 *Obsolete:
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the maximum paged memory.
 *Change the value of this parameter in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_INVALID_MAXNONPAGEDMEM	(AFP_LOG_BASE+11)
/*
 *Obsolete:
 *The File Server for Macintosh service failed to start. 
 *The Registry contains an invalid value for the maximum non-paged memory
 *parameter.
 *Change the value of this parameter in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters Registry key.
 */

#define AFPLOG_CANT_INIT_SRVR_PARAMS    (AFP_LOG_BASE+12)
/*
 *The File Server for Macintosh service failed to start.
 *An error occurred while trying to initialize the AppleTalk Filing Protocol 
 *driver (SfmSrv.sys) with server parameters.
 */

#define AFPLOG_CANT_INIT_VOLUMES	(AFP_LOG_BASE+13)
/*
 *The File Server for Macintosh service failed to start.
 *An error occurred while trying to initialize Macintosh-Accessible volumes.
 *The error code is in the data.
 */

#define AFPLOG_CANT_ADD_VOL		(AFP_LOG_BASE+14)
/*
 *Failed to register volume "%1" with the File Server for Macintosh service.
 *This volume may be removed from the Registry by using the Server Manager or
 *File Manager tools.
 */

#define AFPLOG_CANT_INIT_ETCINFO	(AFP_LOG_BASE+15)
/*
 *The File Server for Macintosh service failed to start. 
 *An error occurred while trying to initialize the AppleTalk Filing 
 *Protocol driver (SfmSrv.sys) with the extension/creator/type associations.
 */

#define AFPLOG_CANT_INIT_ICONS		(AFP_LOG_BASE+16)
/*
 *The File Server for Macintosh service failed to start.
 *An error occurred while trying to initialize the AppleTalk Filing Protocol 
 *driver (SfmSrv.sys) with the server icons.
 */

#define AFPLOG_CANT_ADD_ICON		(AFP_LOG_BASE+17)
/*
 *Failed to register icon "%1" with the File Server for Macintosh service.
 *This icon can no longer be used by the service.
 */

#define AFPLOG_CANT_CREATE_SRVRHLPR	(AFP_LOG_BASE+18)
/*
 *A system resouce could not be allocated for the File Server for Macintosh service.
 *Unable to create a Server Helper thread.
 *The error code is in the data.
 */

#define AFPLOG_OPEN_FSD			(AFP_LOG_BASE+19)
/*
 *The File Server for Macintosh service was unable to open a handle to the 
 *AppleTalk Filing Protocol file system driver (Sfmsrv.sys).
 */

#define AFPLOG_OPEN_LSA			(AFP_LOG_BASE+20)
/*
 *The File Server for Macintosh service was unable to open a handle to the 
 *Local Security Authority.
 */

#define AFPLOG_CANT_GET_DOMAIN_INFO	(AFP_LOG_BASE+21)
/*
 *The File Server for Macintosh service was unable to contact a 
 *domain controller to obtain domain information.
 */

#define AFPLOG_CANT_INIT_DOMAIN_INFO	(AFP_LOG_BASE+22)
/*
 *The File Server for Macintosh service was unable to send domain information 
 *to the AppleTalk Filing Protocol file system driver.
 */

#define AFPLOG_CANT_CHECK_ACCESS        (AFP_LOG_BASE+23)
/*
 *An error occured while checking user's credentials.
 *Operation was not completed.
 */

#define AFPLOG_INVALID_EXTENSION	(AFP_LOG_BASE+24)
/*
 *A corrupt extension "%1" was detected in the Registry.
 *This value was ignored and processing was continued.
 *Change the value for this extension in the 
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters\Extensions Registry key.
 *Restart the service if the corrected extension is to be used.
 */

#define AFPLOG_CANT_STOP		(AFP_LOG_BASE+25)
/*
 *Unable to stop the File Server for Macintosh service.
 *A system specific error has occured.
 *The error code is in the data.
 */

#define AFPLOG_INVALID_CODEPAGE		(AFP_LOG_BASE+26)
/*
 *Not used
 *The Registry contains an invalid value for the path to the Macintosh
 *code-page file.
 */

#define AFPLOG_CANT_INIT_SRVRHLPR	(AFP_LOG_BASE+27)
/*
 *An error occurred while initializing the File Server for Macintosh service.
 *A Server Helper thread could not be initialized.
 *The specific error code is in the data.
 */

#define AFPLOG_CANT_LOAD_FSD		(AFP_LOG_BASE+28)
/*
 *The File Server for Macintosh service failed to start.
 *Unable to load the AppleTalk Filing Protocol file system driver.
 *The specific error code is in the data.
 */

#define AFPLOG_INVALID_VOL_REG		(AFP_LOG_BASE+29)
/*
 *The Registry contains invalid information for the volume "%1". 
 *The value was ignored and processing was continued.
 *Change the value for this volume in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters\Volumes Registry key.
 *Restart the service if the corrected information is to be used
 *for the volume.
 */

#define AFPLOG_CANT_LOAD_RESOURCE	(AFP_LOG_BASE+30)
/*
 *The File Server for Macintosh service was unable to load resource
 *strings.
 */

#define AFPLOG_INVALID_TYPE_CREATOR	(AFP_LOG_BASE+31)
/*
 *A corrupt Creator/Type pair with creator "%2" and type "%1" was detected
 *in the Registry. This value was ignored and processing was continued.
 *Change the value for this Creator/Type pair in the
 *SYSTEM\CurrentControlSet\Services\MacFile\Parameters\Type_Creators Registry key.
 *Restart the service if the corrected information is to be used
 *for the Creator/Type pair.
 */

#define AFPLOG_DOMAIN_INFO_RETRY	(AFP_LOG_BASE+32)
/*
 *The File Server for Macintosh service was unable to contact a domain controler.
 *The service will continue to retry periodically until it succeeds or
 *until the service is manually stopped.
 */

#define AFPLOG_SFM_STARTED_OK	(AFP_LOG_BASE+33)
/*
 *The File Server for Macintosh service started successfully.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\inc\srvmsg.h ===
/********************************************************************/
/**               Copyright(c) 1992 Microsoft Corporation.	       **/
/********************************************************************/
//Jameel: please check all these, especially those that have comments to you.
//***
//
// Filename:	srvmsg.h
//
// Description: Text and corresponding values of AFP Server events are
//              defined here.
//
// History: 	Nov 23,1992.	SueA		Created original version.
//				Jan 28,1993.	SueA		Logging now done from user mode
//											so %1 is no longer \Device\AfpSrv
//


// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define AFPSRV_MSG_BASE					12000

#define AFPSRVMSG_DELETE_NWTRASH		(AFPSRV_MSG_BASE+1)
/*
 * Unable to delete the directory "Network Trash Folder" from volume "%1".
 */

#define AFPSRVMSG_CREATE_NWTRASH		(AFPSRV_MSG_BASE+2)
/*
 * Unable to create the directory "Network Trash Folder" on volume "%1".
 */

#define AFPSRVMSG_CANT_READ				(AFPSRV_MSG_BASE+3)
/*
 * Unable to read internal server information from file "%1".
 */

#define AFPSRVMSG_CANT_WRITE			(AFPSRV_MSG_BASE+4)
/*
 * Unable to write internal server information to file "%1".
 */

#define AFPSRVMSG_CANT_LOCK				(AFPSRV_MSG_BASE+5)
/*
 * Not used.
 * Unable to lock a range of bytes for "%1".
 */

#define AFPSRVMSG_CANT_UNLOCK			(AFPSRV_MSG_BASE+6)
/*
 * Unable to unlock a range of bytes for "%1".
 */

#define AFPSRVMSG_CANT_GET_FILESIZE		(AFPSRV_MSG_BASE+7)
/*
 * Unable to query the file size for "%1".
 */

#define AFPSRVMSG_CANT_SET_FILESIZE		(AFPSRV_MSG_BASE+8)
/*
 * Unable to set the file size for "%1".
 */

#define AFPSRVMSG_CANT_GET_TIMESNATTR	(AFPSRV_MSG_BASE+9)
/*
 * Unable to query time/date information for "%1".
 */

#define AFPSRVMSG_CANT_SET_TIMESNATTR	(AFPSRV_MSG_BASE+10)
/*
 * Unable to set time/date information for "%1".
 */

#define AFPSRVMSG_CANT_GET_STREAMS		(AFPSRV_MSG_BASE+11)
/*
 * Unable to query alternate data stream names for "%1".
 */

#define AFPSRVMSG_CANT_GET_FILENAME		(AFPSRV_MSG_BASE+12)
/*
 * Unable to query the short (MS-DOS compatible) filename for "%1".
 */

#define AFPSRVMSG_CANT_GET_ACCESS_INFO	(AFPSRV_MSG_BASE+13)
/*
 * Not used.
 * Unable to obtain security information.
 */

#define AFPSRVMSG_CANT_GET_FSNAME		(AFPSRV_MSG_BASE+16)
/*
 * Unable to query the file system type for directory "%1".
 */

#define AFPSRVMSG_READ_DESKTOP			(AFPSRV_MSG_BASE+17)
/*
 * Desktop database for volume "%1" could not be loaded. Reconstructing the database.
 */

#define AFPSRVMSG_MSV1_0				(AFPSRV_MSG_BASE+18)
/*
 * Not used.
 * Unable to load the MSV1_0 authentication package.
 */

#define AFPSRVMSG_MAC_CODEPAGE			(AFPSRV_MSG_BASE+19)
/*
 * Unable to load the Macintosh character set.
 */

#define AFPSRVMSG_REGISTER_NAME			(AFPSRV_MSG_BASE+20)
/*
 * Unable to register the server name with the network. Make sure no other server is using this name.
 */

#define AFPSRVMSG_POST_REQUEST			(AFPSRV_MSG_BASE+21)
/*
 * Not used.
 * An error occurred on the network.
 */

#define AFPSRVMSG_DFRD_REQUEST			(AFPSRV_MSG_BASE+22)
/*
 * Unable to process requests due to insufficient resources.
 */

#define AFPSRVMSG_SEND_ATTENTION		(AFPSRV_MSG_BASE+23)
/*
 * Unable to send attention to a connected user.
 */

#define AFPSRVMSG_ALLOC_IRP				(AFPSRV_MSG_BASE+24)
/*
 * Unable to allocate a system resource (IRP).
 * System may be low on memory.
 */

#define AFPSRVMSG_ALLOC_MDL				(AFPSRV_MSG_BASE+25)
/*
 * Unable to allocate a system resouces (Memory Descriptor List - MDL).
 * System may be low on memory.
 */

#define AFPSRVMSG_WAIT4SINGLE			(AFPSRV_MSG_BASE+26)
/*
 * An internal error occurred.
 * Error occured while waiting on single object to change state.
 */

#define AFPSRVMSG_CREATE_THREAD			(AFPSRV_MSG_BASE+27)
/*
 * Unable to create a new thread.
 */

#define AFPSRVMSG_CREATE_PROCESS		(AFPSRV_MSG_BASE+28)
/*
 * Not used.
 * Unable to create a process.
 */

#define AFPSRVMSG_ENUMERATE				(AFPSRV_MSG_BASE+29)
/*
 * Unable to query contents of directory "%1".
 */

#define AFPSRVMSG_CREATE_ATKADDR		(AFPSRV_MSG_BASE+30)
/*
 * Error in creating File object for current Appletalk address.
 */

#define AFPSRVMSG_CREATE_ATKCONN		(AFPSRV_MSG_BASE+31)
/*
 * Not used.
 * An error occured on the network.
 */

#define AFPSRVMSG_ASSOC_ADDR			(AFPSRV_MSG_BASE+32)
/*
 * Not used.
 * An error occurred on the network.
 */

#define AFPSRVMSG_SET_STATUS			(AFPSRV_MSG_BASE+33)
/*
 * An error occured while setting the File Server status block during initialization. The File Server was not started.
 */

 #define AFPSRVMSG_GET_SESSION			(AFPSRV_MSG_BASE+34)
/*
 * Not used.
 * An error occurred on the network.
 */

#define AFPSRVMSG_INIT_IDDB				(AFPSRV_MSG_BASE+35)
/*
 * Volume %1 is being reindexed.
 * The volume will be available for use after indexing is over.
 */

#define AFPSRVMSG_PROCESS_TOKEN			(AFPSRV_MSG_BASE+36)
/*
 * An error occured while creating the system-level process token during
 * the File Server driver initialization.
 * The File Server could not be started.
 */

#define AFPSRVMSG_LSA					(AFPSRV_MSG_BASE+37)
/*
 * Not used.
 * Unable to register with the Local Security Authority.
 */

#define AFPSRVMSG_CREATE_DEVICE			(AFPSRV_MSG_BASE+38)
/*
 * Not used.
 * Unable to create a device object.
 */

#define AFPSRVMSG_USER_GROUPS			(AFPSRV_MSG_BASE+39)
/*
 * Unable to query group membership for the user.
 */

#define AFPSRVMSG_MACANSI2UNICODE		(AFPSRV_MSG_BASE+40)
/*
 * Unable to translate Macintosh used ANSI characters into Unicode characters.
 * The specfic error is in the data.
 */

#define AFPSRVMSG_UNICODE2MACANSI		(AFPSRV_MSG_BASE+41)
/*
 * Unable to translate Unicode characters into Macintosh used ANSI characters.
 * The specfic error is in the data.
 */

#define AFPSRVMSG_AFPINFO				(AFPSRV_MSG_BASE+42)
/*
 * Internal server information for file "%1" was corrupted. Setting default information.
 */

#define AFPSRVMSG_WRITE_DESKTOP			(AFPSRV_MSG_BASE+43)
/*
 * Unable to update the Desktop database for volume "%1". There may not be enough disk space.
 */

#define AFPSRVMSG_IMPERSONATE			(AFPSRV_MSG_BASE+44)
/*
 * Not used.
 * Unable to impersonate a client.
 */

#define AFPSRVMSG_REVERTBACK			(AFPSRV_MSG_BASE+45)
/*
 * Not used.
 * Unable to revert from impersonating a client.
 */

#define AFPSRVMSG_PAGED_POOL			(AFPSRV_MSG_BASE+46)
/*
 * Unable to allocate paged memory resource.
 */

#define AFPSRVMSG_NONPAGED_POOL			(AFPSRV_MSG_BASE+47)
/*
 * Unable to allocate nonpaged memory resources.
 */

#define AFPSRVMSG_LSA_CHALLENGE			(AFPSRV_MSG_BASE+48)
/*
 * Not used.
 * Unable to authenticate user.
 */

#define AFPSRVMSG_LOGON					(AFPSRV_MSG_BASE+49)
/*
 * Unable to logon user "%1".
 */

#define AFPSRVMSG_MAX_DIRID				(AFPSRV_MSG_BASE+50)
/*
 * The maximum directory ID has been reached on volume "%1". No more files or directories can be created on this volume.
 */

#define AFPSRVMSG_WRITE_IDDB			(AFPSRV_MSG_BASE+51)
/*
 * Unable to update the index database for the Macintosh-Accessible volume "%1". There may not be enough disk space.
 */

#define AFPSRVMSG_MISSED_NOTIFY			(AFPSRV_MSG_BASE+52)
/*
 * A directory change notification was missed on volume "%1".
 */

#define AFPSRVMSG_DISCONNECT			(AFPSRV_MSG_BASE+53)
/*
 * Session from user "%2" was timed out and disconnected by the server.
 * The AppleTalk address of the Macintosh workstation is in the data.
 */

#define AFPSRVMSG_DISCONNECT_GUEST			(AFPSRV_MSG_BASE+54)
/*
 * Guest session was timed out and disconnected by the server.
 * The AppleTalk address of the Macintosh workstation is in the data.
 */

#define AFPSRVMSG_UPONMP			(AFPSRV_MSG_BASE+55)
/*
 * Not used.
 * A uniprocessor driver was loaded on a multiprocessor system. 
 * The driver could not load.
 */

#define AFPSRVMSG_UPDATE_DESKTOP_VERSION			(AFPSRV_MSG_BASE+56)
/*
 * Updating the Desktop database version for volume "%1".
 */

#define AFPSRVMSG_TOO_MANY_FOLDERS      (AFPSRV_MSG_BASE+57)
/*
 * Number of files and folders in volume "%1" is greater than 65535.
 * Older Macintosh clients may not function correctly in this situation due
 * to Macintosh volume limitation.
 */

#define AFPSRVMSG_START_VOLUME          (AFPSRV_MSG_BASE+58)
/*
 * Unable to activate the volume "%1"
 */

#define AFPSRVMSG_VOLUME_INIT_FAILED    (AFPSRV_MSG_BASE+59)
/*
 * Unable to activate volume "%1".  The available non-paged memory in the system * is not adequate to handle the large number of folders within this volume.  
 * Reducing the number of folders can help.
 */

#define AFPSRVMSG_VIRTMEM_ALLOC_FAILED    (AFPSRV_MSG_BASE+60)
/*
 * Unable to allocate virtual memory.  
 * Reducing the number of folders can help.
 */

#define AFPSRVMSG_DISCONNECT_TCPIP			(AFPSRV_MSG_BASE+61)
/*
 * Session from user "%2" was timed out and disconnected by the server.
 * The IP address of the Macintosh workstation is in the data.
 */

#define AFPSRVMSG_DISCONNECT_GUEST_TCPIP			(AFPSRV_MSG_BASE+62)
/*
 * Guest session was timed out and disconnected by the server.
 * The IP address of the Macintosh workstation is in the data.
 */
#define AFPSRVMSG_UPDATE_INDEX_VERSION      (AFPSRV_MSG_BASE+63)
/*
 * Index database for volume %1 is being updated because the server detected an older
 * version.  The volume will be visible on the network after indexing is complete.  For
 * very large volumes, this can take several minutes.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\upgrade\tools\b3rasace\adsi.cpp ===
/*
	File	adsi.cpp

	Com interaction with adsi

	Paul Mayfield, 4/14/98
*/

#include "dsrights.h"
#include "sddl.h"
#include "mprapip.h"
#include "dsgetdc.h"

// Definition for convenience
//
#define DSR_ADS_RIGHT_GENERIC_READ (ADS_RIGHT_READ_CONTROL    | \
                                    ADS_RIGHT_DS_LIST_OBJECT  | \
                                    ADS_RIGHT_DS_READ_PROP    | \
                                    ADS_RIGHT_ACTRL_DS_LIST   )

#define DSR_ADS_ACE_INHERITED (ADS_ACEFLAG_INHERIT_ONLY_ACE   | \
                               ADS_ACEFLAG_INHERIT_ACE)


//
// Describes an Access control entry
//
typedef struct _DSR_ACE_DESCRIPTOR
{
    LONG   dwAccessMask;
    LONG   dwAceType;
    LONG   dwAceFlags;
    LONG   dwFlags;
    BSTR   bstrTrustee;
    BSTR   bstrObjectType;
    BSTR   bstrInheritedObjectType;
} DSR_ACE_DESCRIPTOR;

//
// Structure maps a domain object to the ACES that should be
// added or removed from it in order to enable/disable NT4
// ras servers in the domain
//
typedef struct _DSR_ACE_APPLICATION
{
    IADs* pObject;
    DSR_ACE_DESCRIPTOR Ace;

} DSR_ACE_APPLICATION;

//
// Parameters used to generate a DSR_ACE_APPLICATION
//
typedef struct _DSR_ACE_APPLICATION_DESC
{
    PWCHAR pszObjectCN;         // NULL means domain root
    PWCHAR pszObjectClass;
    DSR_ACE_DESCRIPTOR Ace;

} DSR_ACE_APPLICATION_DESC;

//
// Structure contains the information needed to have
// ACL's in the AD of a given domain adjusted such that 
// the various modes (MPR_DOMAIN_*) of access are granted.
//
typedef struct _DSR_DOMAIN_ACCESS_INFO
{
    // The name of a DC in the target domain
    //
    PWCHAR pszDC;

    // Aces derived from the default user SD
    // These are added in all modes but never removed.
    //
    DSR_ACE_APPLICATION* pAcesUser;
    DWORD dwAceCountUser;

    // Aces for MPRFLAG_DOMAIN_NT4_SERVERS mode
    //
    DSR_ACE_APPLICATION* pAcesNt4;
    DWORD dwAceCountNt4;

    // Aces for MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS mode
    //
    DSR_ACE_APPLICATION* pAcesW2k;
    DWORD dwAceCountW2k;

    // Stored here for convenience, pointers
    // to common ds objects
    //
    IADs* pDomain;      
    IADs* pRootDse;
    IADs* pUserClass;

} DSR_DOMAIN_ACCESS_INFO;

//
// Strings used in DS queries
//
static const WCHAR pszLdapPrefix[]           = L"LDAP://";
static const WCHAR pszLdap[]                 = L"LDAP:";
static const WCHAR pszCN[]                   = L"CN=";
static const WCHAR pszGCPrefix[]             = L"GC://";
static const WCHAR pszGC[]                   = L"GC:";
static const WCHAR pszRootDse[]              = L"RootDSE";
static const WCHAR pszSecurityDesc[]         = L"ntSecurityDescriptor";
static const WCHAR pszDefSecurityDesc[]      = L"defaultSecurityDescriptor";
static const WCHAR pszDn[]                   = L"distinguishedName";
static const WCHAR pszSid[]                  = L"objectSid";
static const WCHAR pszEveryone[]             = L"S-1-1-0";
static const WCHAR pszDefaultNamingContext[] = L"defaultNamingContext";
static const WCHAR pszSchemaNamingCtx[]      = L"schemaNamingContext";

static const WCHAR pszBecomeSchemaMaster[]  = L"becomeSchemaMaster";
static const WCHAR pszUpdateSchemaCache[]   = L"schemaUpdateNow";
static const WCHAR pszRegValSchemaLock[]    = L"Schema Update Allowed";
static const WCHAR pszRegKeySchemaLock[]
    = L"System\\CurrentControlSet\\Services\\NTDS\\Parameters";

static const WCHAR pszSystemClass[]          = L"Container";
static const WCHAR pszSystemCN[]             = L"CN=System";

static const WCHAR pszBuiltinClass[]         = L"builtinDomain";
static const WCHAR pszBuiltinCN[]            = L"CN=Builtin";

static const WCHAR pszSamSvrClass[]          = L"samServer";
static const WCHAR pszSamSvrCN[]             = L"CN=Server,CN=System";

static const WCHAR pszUserClass[]            = L"classSchema";
static const WCHAR pszUserCN[]               = L"CN=user";

static const WCHAR pszAccessChkClass[]       = L"Container";
static const WCHAR pszAccessChkCN[]          = 
    L"CN=RAS and IAS Servers Access Check,CN=System";

static const WCHAR pszGuidUserParms[]        =
    L"{BF967A6D-0DE6-11D0-A285-00AA003049E2}";

static const WCHAR pszGuidUserClass[]        =
    L"{BF967ABA-0DE6-11D0-A285-00aa003049E2}";

//
// This GUID is the property set of the following
// attributes needed for w2k level access.
//
// Token-Groups
// msNPAllowDialin
// msNPCallingStationID
// msRADIUSCallbackNumber
// msRADIUSFramedIPAddress
// msRADIUSFramedRoute
// msRADIUSServiceType
// 
static const WCHAR pszGuidRasPropSet1[]      =
    L"{037088F8-0AE1-11D2-B422-00A0C968F939}";

//
// This GUID is the property set of the following
// attributes needed for w2k level access
//
// User-Account-Control
// Account-Expires
//
static const WCHAR pszGuidRasPropSet2[]      =
    L"{4C164200-20C0-11D0-A768-00AA006E0529}";

//
// This GUID is the property of the following
// attribute needed for w2k level access
//
// Logon-Hours
//
static const WCHAR pszGuidLogonHours[]      =
    L"{BF9679AB-0DE6-11D0-A285-00AA003049E2}";

//
// This GUID is the value of the samAccountName 
// attribute needed for w2k level access.
//
// samAccountName
//
static const WCHAR pszGuidSamAccountName[]  =
    L"{3E0ABFD0-126A-11D0-A060-00AA006C33ED}";

// The optimal means for searching for a computer
// in a domain is to lookup its sam account name which
// is indexed.  The optimal means for searching for a
// group of a given sid is to lookup its SID which is indexed.
//
const WCHAR pszCompFilterFmt[]       = L"(samaccountname=%s$)";
const WCHAR pszGroupFilterFmt[]      = L"(objectSid=%s)";
const WCHAR pszUserClassFmt[]        =
                L"(&(objectClass=user)(!(objectClass=computer)))";

//
// The table of aces to be applied for MPRFLAG_DOMAIN_NT4_SERVERS
//
DSR_ACE_APPLICATION_DESC g_pAcesNt4[] =
{
    // Grant list options to everyone for the root domain
    // object
    //
    {
        NULL,                               // Object (NULL = root)
        NULL,                               // Object class
        {
            ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Grant list contents to everyone for the builtin
    // object
    //
    {
        (PWCHAR)pszBuiltinCN,               // Object
        (PWCHAR)pszBuiltinClass,            // Object class
        {
            ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Grant generic read to everyone on the sam server
    // object
    //
    {
        (PWCHAR)pszSamSvrCN,                // Object
        (PWCHAR)pszSamSvrClass,             // Object class
        {
            DSR_ADS_RIGHT_GENERIC_READ,     // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Allow everyone to read the userparms property of the
    // user class by enabling this inheritable ACE to the
    // root domain object
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidUserParms,               // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    }

};

//
// The table of aces to be applied for 
// MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS
//
DSR_ACE_APPLICATION_DESC g_pAcesW2k[] =
{
    // Grant list contents to Everyone for the System
    // container
    //
    {
        (PWCHAR)pszSystemCN,                // Object
        (PWCHAR)pszSystemClass,             // Object class
        {
            ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Grant generic read to Everyone for the 'RAS and IAS Servers
    // Access Check' container
    //
    {
        (PWCHAR)pszAccessChkCN,             // Object
        (PWCHAR)pszAccessChkClass,          // Object class
        {
            DSR_ADS_RIGHT_GENERIC_READ,     // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
            0,                              // dwAceFlags
            0,                              // dwFlags
            (PWCHAR)pszEveryone,            // bstrTrustee
            NULL,                           // bstrObjectType
            NULL                            // bstrInheritedObjectType
        }
    },

    // Users should expose their RAS properties
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidRasPropSet1,             // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    },

    // Users should expose their RAS properties
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidRasPropSet2,             // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    },

    // Users should expose their logon hours property
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidLogonHours,              // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    },

    // Grant list contents to everything in the domain.
    //
    //{
    //    NULL,                               // Object
    //    NULL,                               // Object class
    //    {
    //        ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
    //        ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
    //        DSR_ADS_ACE_INHERITED,          // dwAceFlags
    //        0,                              // dwFlags
    //        (PWCHAR)pszEveryone,            // bstrTrustee
    //        NULL,                           // bstrObjectType
    //        NULL                            // bstrInheritedObjectType
    //    }
    //},


    // Users should expose their samAccountName
    //
    {
        NULL,                                       // Object (NULL = root)
        NULL,                                       // Object class
        {
            ADS_RIGHT_DS_READ_PROP,                 // dwAccessMask
            ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,      // dwAceType
            DSR_ADS_ACE_INHERITED,                  // dwAceFlags
            ADS_FLAG_OBJECT_TYPE_PRESENT |
            ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT, // dwFlags
            (PWCHAR)pszEveryone,                    // bstrTrustee
            (PWCHAR)pszGuidSamAccountName,          // bstrObjectType
            (PWCHAR)pszGuidUserClass                // bstrInheritedObjectType
        }
    }
};

DWORD
DsrAccessInfoCleanup(
    IN DSR_DOMAIN_ACCESS_INFO* pSecurityInfo);

DWORD
DsrAceDescClear(
    IN DSR_ACE_DESCRIPTOR* pParams);

HRESULT
DsrAceDescCopy(
    OUT DSR_ACE_DESCRIPTOR* pDst,
    IN  DSR_ACE_DESCRIPTOR* pSrc);
    
VOID
DsrAceDescTrace(
    IN IADs* pIads,
    IN DSR_ACE_DESCRIPTOR* pA);
    
HRESULT
DsrAceAdd(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams);
    
HRESULT
DsrAceCreate(
    IN  DSR_ACE_DESCRIPTOR * pAceParams,
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceFind(
    IN  PWCHAR pszDC,
    IN  IADs* pObject,
    IN  DSR_ACE_DESCRIPTOR* pAceParams,
    OUT VARIANT* pVarSD,
    OUT IADsSecurityDescriptor** ppSD,
    OUT IADsAccessControlList** ppAcl,
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceFindInAcl(
    IN  PWCHAR pszDC,
    IN  IADsAccessControlList* pAcl,
    IN  DSR_ACE_DESCRIPTOR* pAceDesc, 
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceRemove(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams);
    
HRESULT
DsrDomainQueryAccessEx(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo);

//
// Allocates memory for use with dsr functions
//
PVOID DsrAlloc(DWORD dwSize, BOOL bZero) {
    return GlobalAlloc (bZero ? GPTR : GMEM_FIXED, dwSize);
}

//
// Free memory used by dsr functions
//
DWORD DsrFree(PVOID pvBuf) {
    GlobalFree(pvBuf);
    return NO_ERROR;
}
    
//
// Compares to optional strings
//
INT
DsrStrCompare(
    IN BSTR bstrS1,
    IN BSTR bstrS2)
{
    if ((!!bstrS1) != (!!bstrS2))
    {
        return -1;
    }

    if (bstrS1 == NULL)
    {
        return 0;
    }

    return lstrcmpi(bstrS1, bstrS2);
}

//
// Adds or removes a substring from the given string
//
HRESULT
DsrStrAddRemoveSubstring(
    IN  BSTR bstrSrc,
    IN  PWCHAR pszSubString,
    IN  BOOL bAdd,
    OUT BSTR* pbstrResult)
{
    HRESULT hr = S_OK;
    PWCHAR pszBuffer = NULL, pszStart = NULL, pszEnd = NULL;
    PWCHAR pszSrc, pszDst;
    DWORD dwSize = 0, dwLen = 0;

    // Find out if the sub string is already in the
    // string
    pszStart = wcsstr(bstrSrc, pszSubString);

    // The substring already exists in the string
    //
    if (pszStart)
    {
        // No need to add it since it's already there.
        if (bAdd)
        {
            *pbstrResult = SysAllocString(bstrSrc);
        }

        // Remove the substring
        else
        {
            dwLen = wcslen(pszSubString);
            pszEnd = pszStart + dwLen;
            dwSize = (DWORD)(pszStart - bstrSrc) + wcslen(pszEnd) + 1;
            dwSize *= sizeof(WCHAR);

            pszBuffer = (PWCHAR) DsrAlloc(dwSize, FALSE);
            if (pszBuffer == NULL)
            {
                return E_OUTOFMEMORY;
            }

            // Copy everything up to the substring
            //
            for (pszSrc = bstrSrc, pszDst = pszBuffer;
                 pszSrc != pszStart;
                 pszSrc++, pszDst++)
            {
                *pszDst = *pszSrc;
            }

            // Copy everything after the substring
            for (pszSrc = pszEnd; *pszSrc; pszSrc++, pszDst++)
            {
                *pszDst = *pszSrc;
            }

            // Null terminate
            *pszDst = L'\0';

            *pbstrResult = SysAllocString(pszBuffer);
            DsrFree(pszBuffer);
        }
    }

    // The substring does not already exist in the
    // string
    else
    {
        // Append the string
        //
        if (bAdd)
        {
            dwSize = wcslen(bstrSrc) + wcslen(pszSubString) + 1;
            dwSize *= sizeof(WCHAR);

            pszBuffer = (PWCHAR) DsrAlloc(dwSize, FALSE);
            if (pszBuffer == NULL)
            {
                return E_OUTOFMEMORY;
            }

            wcscpy(pszBuffer, bstrSrc);
            wcscat(pszBuffer, pszSubString);
            *pbstrResult = SysAllocString(pszBuffer);
            DsrFree(pszBuffer);
        }

        // Or nothing to do since the substring was
        // already removed
        else
        {
            *pbstrResult = SysAllocString(bstrSrc);
        }
    }

    return (*pbstrResult) ? S_OK : E_OUTOFMEMORY;
}

//
// Converts a SID into a buffer
//
DWORD
DsrStrFromSID(
    IN  PSID pSid,
    OUT PWCHAR pszString,
    IN  DWORD dwSize)
{
    NTSTATUS nStatus = STATUS_SUCCESS;  
    UNICODE_STRING UnicodeString;

    // Initialize the unicode string
    //
    RtlInitUnicodeString(&UnicodeString, NULL);

    do
    {
        // Convert the string
        //
        nStatus = RtlConvertSidToUnicodeString(
                    &UnicodeString,
                    pSid,
                    TRUE);
        if (! NT_SUCCESS(nStatus))
        {
            break;
        }

        // Validate the result
        //
        if (UnicodeString.Buffer == NULL)
        {
            nStatus = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (UnicodeString.Length > dwSize)
        {
            nStatus = STATUS_BUFFER_OVERFLOW;
            break;
        }

        // Copy the result
        //
        wcscpy(pszString, UnicodeString.Buffer);
        nStatus = STATUS_SUCCESS;
        
    } while (FALSE);        

    // Cleanup
    {
        if (UnicodeString.Buffer != NULL)
        {
            RtlFreeUnicodeString(&UnicodeString);
        }            
    }

    return RtlNtStatusToDosError(nStatus);
}


//
// Generates an LDAP path based on a domain and a 
// distinguished name
//
// Form of value returned: LDAP://<domain or dc>/dn
HRESULT
DsrDomainGenLdapPath(
    IN  PWCHAR pszDomain, 
    IN  PWCHAR pszDN, 
    OUT PWCHAR* ppszObject)
{    
    DWORD dwSize;

    // Calculate the size needed
    //
    dwSize = (wcslen(pszLdapPrefix) + wcslen(pszDN) + 1) * sizeof(WCHAR);
    if (pszDomain)
    {
        dwSize += (wcslen(pszDomain) + 1) * sizeof(WCHAR); // +1 for '/'
    }

    // Allocate the return value
    //
    *ppszObject = (PWCHAR) DsrAlloc(dwSize, FALSE);
    if (*ppszObject == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Format the return value
    if (pszDomain == NULL)
    {
        wsprintfW(*ppszObject, L"%s%s", pszLdapPrefix, pszDN);
    }
    else
    {
        wsprintfW(*ppszObject, L"%s%s/%s", pszLdapPrefix, pszDomain, pszDN);
    }

    return S_OK;
}        

//
// Returns a reference to rootDse of the given
// domain
//
HRESULT
DsrDomainGetRootDse(
    IN  PWCHAR pszDomain,
    OUT IADs** ppRootDse)
{
    HRESULT hr = S_OK;
    PWCHAR pszPath = NULL;
    DWORD dwSize = 0;

    do
    {
        // Get the object path
        //
        hr = DsrDomainGenLdapPath(pszDomain, (PWCHAR)pszRootDse, &pszPath);
        DSR_BREAK_ON_FAILED_HR(hr);
    
        // Get RootDSE
        //
        hr = ADsGetObject(pszPath, IID_IADs, (VOID**)ppRootDse);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    {
        DSR_FREE(pszPath);

        if (FAILED (hr))
        {
            DSR_RELEASE(*ppRootDse);
        }
    }

    return hr;
}

//
// Returns a reference to the root domain object
//
HRESULT
DsrDomainGetContainers(
    IN  PWCHAR pszDomain,
    OUT IADs** ppRootDse,
    OUT IADsContainer** ppDomain,
    OUT IADsContainer** ppSchema)
{
    PWCHAR pszDomainObj = NULL, pszSchemaObj = NULL;
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    VARIANT var;

    // Iniatialize
    //
    {
        *ppRootDse = NULL;
        *ppDomain = NULL;
        *ppSchema = NULL;
        VariantInit(&var);
    }

    do
    {
        // Get RootDSE
        //
        hr = DsrDomainGetRootDse(pszDomain, ppRootDse);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Use RootDSE to figure out the name of the domain object
        // to query
        hr = (*ppRootDse)->Get((PWCHAR)pszDefaultNamingContext, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Compute the distinguished name of the root domain object
        //
        hr = DsrDomainGenLdapPath(pszDomain, V_BSTR(&var), &pszDomainObj);
        DSR_BREAK_ON_FAILED_HR(hr);
        
        // Use RootDSE to figure out the name of the schema context
        //
        VariantClear(&var);
        hr = (*ppRootDse)->Get((PWCHAR)pszSchemaNamingCtx, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Compute the distinguished name of the root schema object
        //
        hr = DsrDomainGenLdapPath(pszDomain, V_BSTR(&var), &pszSchemaObj);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Get the objects
        //
        hr = ADsGetObject(pszDomainObj, IID_IADsContainer, (VOID**)ppDomain);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = ADsGetObject(pszSchemaObj, IID_IADsContainer, (VOID**)ppSchema);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    //
    {
        if (FAILED( hr ))
        {
            DSR_RELEASE(*ppRootDse);
            DSR_RELEASE(*ppDomain);
            DSR_RELEASE(*ppSchema);
            *ppRootDse = NULL;
            *ppDomain = NULL;
            *ppSchema = NULL;
        }

        DSR_FREE(pszDomainObj);
        DSR_FREE(pszSchemaObj);
        VariantClear(&var);
    }

    return hr;
}

//
// Initializes COM
//
HRESULT
DsrComIntialize()
{
    HRESULT hr;

    hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED);
    if (hr == RPC_E_CHANGED_MODE)
    {
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    }

    if ((hr != S_FALSE) && (FAILED(hr)))
    {
        return hr;
    }

    return NO_ERROR;
}

//
// Unitializes COM
//
VOID
DsrComUninitialize()
{
    CoUninitialize();
}

//
// Creates a SID based on the array of bytes
// stored in a variant.
//
DWORD
DsrSidInit (
    IN  VARIANT * pVar,
    OUT PBYTE* ppbSid)
{
    SAFEARRAY * pArray = V_ARRAY(pVar);
    DWORD dwSize, dwLow, dwHigh, i;
    HRESULT hr;
    BYTE* pbRet = NULL;
    VARIANT var;

    DsrTraceEx (0, "DsrSidInit: entered.");

    // Get the array of bytes
    i = 0;
    hr = SafeArrayGetElement(pArray, (LONG*)&i, (VOID*)&var);
    if (FAILED (hr))
        return hr;

    // Initialize the return buffer accordingly
    pArray = V_ARRAY(&var);
    dwSize = SafeArrayGetDim(pArray);
    hr = SafeArrayGetLBound(pArray, 1, (LONG*)&dwLow);
    if (FAILED (hr))
        return DsrTraceEx(hr, "DsrSidInit: %x unable to get lbound", hr);

    hr = SafeArrayGetUBound(pArray, 1, (LONG*)&dwHigh);
    if (FAILED (hr))
        return DsrTraceEx(hr, "DsrSidInit: %x unable to get ubound", hr);

    DsrTraceEx (
            0,
            "DsrSidInit: Dim=%d, Low=%d, High=%d",
            dwSize,
            dwLow,
            dwHigh);

    // Allocate the sid
    if ((pbRet = (BYTE*)DsrAlloc((dwHigh - dwLow) + 2, TRUE)) == NULL) {
        return DsrTraceEx (
                    ERROR_NOT_ENOUGH_MEMORY,
                    "DsrSidInit: Unable to alloc");
    }

    // Copy in the bytes of the SID
    i = dwLow;
    while (TRUE) {
        hr = SafeArrayGetElement(pArray, (LONG*)&i, (VOID*)(&(pbRet[i])));
        if (FAILED (hr))
            break;
        i++;
    }

    DsrTraceEx(0, "DsrSidInit: copied %d bytes", i);

    *ppbSid = pbRet;

    {
        PUCHAR puSA;

        DsrTraceEx (0, "DsrSidInit: Sid Length: %d", GetLengthSid(pbRet));

        puSA = GetSidSubAuthorityCount(pbRet);
        if (puSA)
            DsrTraceEx (0, "DsrSidInit: Sid SA Count: %d", *puSA);
    }

    return NO_ERROR;
}

//
// Generates the ascii equivalent (suitable for submission as part of
// a query against the DS) of a SID based on a base SID and a sub authority
// to be appeneded.
//
HRESULT
DsrSidInitAscii(
    IN  LPBYTE pBaseSid,
    IN  DWORD dwSubAuthority,
    OUT PWCHAR* ppszSid)
{
    DWORD dwLen, dwSidLen, i;
    WCHAR* pszRet = NULL;
    PUCHAR puCount;
    LPBYTE pByte;

    // Calculate the length of the returned buffer
    dwSidLen = GetLengthSid(pBaseSid);
    dwLen = (dwSidLen * 2) + sizeof(DWORD) + 1;
    dwLen *= sizeof (WCHAR);

    // we put '\' before each byte, so double the size
    dwLen *= 2;

    // Allocate the return buffer
    pszRet = (PWCHAR) DsrAlloc(dwLen, TRUE);
    if (pszRet == NULL)
        return E_OUTOFMEMORY;

    // Increment the sub authority count
    puCount = GetSidSubAuthorityCount(pBaseSid);
    *puCount = *puCount + 1;

    // Copy the bytes
    for (i = 0; i < dwSidLen; i++) {
        pszRet[i*3] = L'\\';
        wsprintfW(&(pszRet[i*3+1]), L"%02x", (DWORD)pBaseSid[i]);
    }

    // Append the bytes for the new sub authority
    pByte = (LPBYTE)&(dwSubAuthority);
    for (; i < dwSidLen + sizeof(DWORD); i++) {
        pszRet[i*3] = L'\\';
        wsprintfW(&(pszRet[i*3+1]), L"%02x", (DWORD)pByte[i-dwSidLen]);
    }

    // Decrement the sub authority count -- restoring the
    // base sid.
    *puCount = *puCount - 1;

    *ppszSid = pszRet;

    return NO_ERROR;
}

//
// Searches given domain for a computer account
// with the given name and returns its ADsPath
// if found.
//
DWORD
DsrFindDomainComputer (
        IN  PWCHAR  pszDomain,
        IN  PWCHAR  pszComputer,
        OUT PWCHAR* ppszADsPath)
{
    HRESULT hr = S_OK;
    DWORD dwLen, dwSrchAttribCount;
    IDirectorySearch * pSearch = NULL;
    PWCHAR pszDomainPath = NULL, pszFilter = NULL;
    PWCHAR pszBase, pszPrefix;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN adsColumn;
    PWCHAR ppszSrchAttribs[] =
    {
        (PWCHAR)pszDn,
        NULL
    };
    BOOL bSearchGC = FALSE;

    do {
        // Validate parameters
        if (!pszDomain || !pszComputer || !ppszADsPath) {
            hr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Decide whether to search the GC or the domain
        // object
        if (bSearchGC) {
            pszBase = (PWCHAR)pszGC;
            pszPrefix = (PWCHAR)pszGCPrefix;
        }
        else {
            pszBase = (PWCHAR)pszLdap;
            pszPrefix = (PWCHAR)pszLdapPrefix;
        }

        // Allocate the domain path
        dwLen = (pszDomain) ? wcslen(pszDomain) : 0;
        dwLen += wcslen(pszPrefix) + 1;
        dwLen *= sizeof(WCHAR);
        pszDomainPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszDomainPath == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Format the domain path
        if (pszDomain) {
            wcscpy(pszDomainPath, pszPrefix);
            wcscat(pszDomainPath, pszDomain);
        }
        else
            wcscpy(pszDomainPath, pszBase);

        // Get a reference to the object to search
        // (either domain object or GC)
    	hr = ADsGetObject (
    	        pszDomainPath,
    	        IID_IDirectorySearch,
    	        (VOID**)&pSearch);
        if (FAILED (hr))
            break;

        // Prepare the search filter
        //
        dwLen = wcslen(pszCompFilterFmt) + wcslen(pszComputer) + 1;
        dwLen *= sizeof(WCHAR);
        pszFilter = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszFilter == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wsprintfW(pszFilter, pszCompFilterFmt, pszComputer);

        // Count the number of attributes we're searching
        // for
        if (ppszSrchAttribs == NULL)
            dwSrchAttribCount = (DWORD)-1;
        else {
            for (dwSrchAttribCount = 0;
                 ppszSrchAttribs[dwSrchAttribCount];
                 dwSrchAttribCount++);
        }

        // Search the DS
        hr = pSearch->ExecuteSearch(
                pszFilter,
                ppszSrchAttribs,
                dwSrchAttribCount,
                &hSearch);
        if (FAILED (hr))
            break;

        // Get the first result
        hr = pSearch->GetNextRow(hSearch);
        if (hr == S_ADS_NOMORE_ROWS) {
            hr = ERROR_NOT_FOUND;
            break;
        }

        // Get the attribute we're interested in
        hr = pSearch->GetColumn(hSearch, (PWCHAR)pszDn, &adsColumn);
        if (SUCCEEDED (hr)) {
            dwLen = wcslen(adsColumn.pADsValues[0].PrintableString) +
                    wcslen(pszLdapPrefix)                           +
                    1;
            dwLen *= 2;
            *ppszADsPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszADsPath == NULL)
            {
                pSearch->FreeColumn(&adsColumn);
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wcscpy(*ppszADsPath, pszLdapPrefix);
            wcscat(*ppszADsPath, adsColumn.pADsValues[0].PrintableString);
            pSearch->FreeColumn (&adsColumn);
            hr = NO_ERROR;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hSearch)
            pSearch->CloseSearchHandle(hSearch);
        DSR_FREE (pszDomainPath);
        DSR_FREE (pszFilter);
        DSR_RELEASE (pSearch);
    }

    return DSR_ERROR(hr);
}

//
// Searches given domain for the well known
// "RAS and IAS Servers" group and returns
// its ADsPath if found.
//
DWORD
DsrFindRasServersGroup (
        IN  PWCHAR  pszDomain,
        OUT PWCHAR* ppszADsPath)
{
    HRESULT hr = S_OK;
    DWORD dwLen, dwSrchAttribCount, dwErr;
    IDirectorySearch * pSearch = NULL;
    IADs * pIads = NULL;
    PWCHAR pszDomainPath = NULL, pszFilter = NULL;
    PWCHAR pszBase, pszPrefix, pszGroupSid = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN adsColumn;
    PWCHAR ppszSrchAttribs[] =
    {
        (PWCHAR)pszDn,
        NULL
    };
    BOOL bSearchGC = FALSE;
    VARIANT var;
    LPBYTE pDomainSid = NULL;
    BSTR bstrSid = NULL;

    do {
        // Validate parameters
        if (!pszDomain || !ppszADsPath) {
            hr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Decide whether to search the GC or the domain
        // object
        if (bSearchGC) {
            pszBase = (PWCHAR)pszGC;
            pszPrefix = (PWCHAR)pszGCPrefix;
        }
        else {
            pszBase = (PWCHAR)pszLdap;
            pszPrefix = (PWCHAR)pszLdapPrefix;
        }

        // Allocate the domain path
        dwLen = wcslen(pszDomain) + wcslen(pszPrefix) + 1;
        dwLen *= sizeof(WCHAR);
        pszDomainPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszDomainPath == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Format the domain path
        wcscpy(pszDomainPath, pszPrefix);
        wcscat(pszDomainPath, pszDomain);

        // Get a reference to the object to search
        // (either domain object or GC)
    	hr = ADsGetObject (
    	        pszDomainPath,
    	        IID_IDirectorySearch,
    	        (VOID**)&pSearch);
        if (FAILED (hr))
            break;

        // Get IADs reference to domain object
        hr = pSearch->QueryInterface(IID_IADs, (VOID**)&pIads);
        if (FAILED (hr))
            break;

        // Get the SID of the domain object
        VariantInit(&var);
        bstrSid = SysAllocString(pszSid);
        if (bstrSid == NULL)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }            
        hr = pIads->GetEx(bstrSid, &var);
        if (FAILED (hr))
        {
            break;
        }
        dwErr = DsrSidInit(&var, &pDomainSid);
        if (dwErr != NO_ERROR) {
            hr = dwErr;
            break;
        }
        VariantClear(&var);

        // Prepare the ascii version of the "RAS and IAS Servers" SID
        // for use in querying the DC
        hr = DsrSidInitAscii(
                pDomainSid,
                DOMAIN_ALIAS_RID_RAS_SERVERS,
                &pszGroupSid);
        if (FAILED (hr))
            break;
        DsrTraceEx(0, "GroupSid = %ls", pszGroupSid);

        // Prepare the search filter
        //
        dwLen = (wcslen(pszGroupFilterFmt) + wcslen(pszGroupSid) + 1);
        dwLen *= sizeof(WCHAR);
        pszFilter = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszFilter == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wsprintfW(pszFilter, pszGroupFilterFmt, pszGroupSid);

        // Count the number of attributes we're searching
        // for
        if (ppszSrchAttribs == NULL)
            dwSrchAttribCount = (DWORD)-1;
        else 
        {
            for (dwSrchAttribCount = 0;
                 ppszSrchAttribs[dwSrchAttribCount];
                 dwSrchAttribCount++);
        }

        // Search the DS
        hr = pSearch->ExecuteSearch(
                pszFilter,
                ppszSrchAttribs,
                dwSrchAttribCount,
                &hSearch);
        if (FAILED (hr))
            break;

        // Get the first result
        hr = pSearch->GetNextRow(hSearch);
        if (hr == S_ADS_NOMORE_ROWS) {
            hr = ERROR_NOT_FOUND;
            break;
        }

        // Get the attribute we're interested in
        hr = pSearch->GetColumn(hSearch, (PWCHAR)pszDn, &adsColumn);
        if (SUCCEEDED (hr)) 
        {
            dwLen = wcslen(adsColumn.pADsValues[0].PrintableString) +
                    wcslen(pszLdapPrefix)                           +
                    1;
            dwLen *= sizeof(WCHAR);
            *ppszADsPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszADsPath == NULL)
            {
                pSearch->FreeColumn(&adsColumn);
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wsprintfW(
                *ppszADsPath,
                L"%s%s",
                pszLdapPrefix,
                adsColumn.pADsValues[0].PrintableString);
            pSearch->FreeColumn(&adsColumn);
            hr = NO_ERROR;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hSearch)
            pSearch->CloseSearchHandle(hSearch);
        DSR_FREE (pszDomainPath);
        DSR_FREE (pszFilter);
        DSR_FREE (pDomainSid);
        DSR_FREE (pszGroupSid);
        DSR_RELEASE (pSearch);
        DSR_RELEASE (pIads);
        if (bstrSid)
            SysFreeString(bstrSid);
    }

    return DSR_ERROR(hr);
}

//
// Adds or removes a given object from a given group.
//
DWORD 
DsrGroupAddRemoveMember(
    IN PWCHAR pszGroupDN,
    IN PWCHAR pszNewMemberDN,
    IN BOOL bAdd)
{
    VARIANT_BOOL vbIsMember = VARIANT_FALSE;
    IADsGroup* pGroup = NULL;
    HRESULT hr = S_OK;

    DsrTraceEx (
        0,
        "DsrGroupAddRemoveMember entered for [%S] [%S]",
        pszGroupDN,
        pszNewMemberDN);

    do
    {
        // Get a reference to the group
        hr = ADsGetObject (pszGroupDN, IID_IADsGroup, (VOID**)&pGroup);
        if (FAILED (hr)) 
        {
         	DsrTraceEx(
     	        hr,
     	        "DsrGroupAddRemoveMember: %x from ADsGetObject(%S)",
     	        hr,
     	        pszGroupDN);
     	    break;
        }         	
         	
        // Find out if the given new member is in the group
        hr = pGroup->IsMember (pszNewMemberDN, &vbIsMember);
        if (FAILED (hr)) 
        {
            DsrTraceEx (
                hr,
                "DsrGroupAddRemoveMember: %x from IsMember\n",
                hr);
            break;
        }

        // Add the object to the group and flush the cache
        if (bAdd) 
        {
            if (vbIsMember == VARIANT_FALSE)
            {
                hr = pGroup->Add (pszNewMemberDN);
            }
        }
        else 
        {
            if (vbIsMember == VARIANT_TRUE)
            {
                hr = pGroup->Remove (pszNewMemberDN);
            }
        }

        // If the new member is already in the group, the error code
        // is ERROR_DS_CONSTRAINT_VIOLATION.  I suspect this may change.
        //
        if (hr == ERROR_DS_CONSTRAINT_VIOLATION)
        {
            hr = ERROR_ALREADY_EXISTS;
            break;
        }

        if (FAILED (hr)) 
        {
         	DsrTraceEx(
 	            hr,
 	            "DsrGroupAddRemoveMember: %x from Add/Remove",
 	            hr);
            break; 	            
        }         	
        
    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE(pGroup);
    }

    return DSR_ERROR(hr);
}

//
// Returns whether the given object is a member of
// the given group.
//
DWORD 
DsrGroupIsMember(
    IN  PWCHAR pszGroupDN,
    IN  PWCHAR pszObjectDN,
    OUT PBOOL  pbIsMember)
{
    IADsGroup * pGroup = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL vbIsMember = VARIANT_FALSE;

    DsrTraceEx (
        0,
        "DsrGroupIsMember: entered [%S] [%S].",
        pszGroupDN,
        pszObjectDN);

    do
    {
        // Get a reference to the group
        hr = ADsGetObject (pszGroupDN, IID_IADsGroup, (VOID**)&pGroup);
        if (FAILED (hr)) 
        {
            DsrTraceEx (
                hr,
                "DsrGroupIsMember: %x returned when opening %S", 
                hr, 
                pszGroupDN);
            *pbIsMember = FALSE;
            hr = NO_ERROR;
            break;
        }

        // Find out if the object is a member
        hr = pGroup->IsMember (pszObjectDN, &vbIsMember);
        if (FAILED (hr)) 
        {
            DsrTraceEx (hr, "DsrGroupIsMember: %x from IsMember\n", hr);
            break;
         }

        *pbIsMember = (vbIsMember == VARIANT_TRUE) ? TRUE : FALSE;
        
    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE(pGroup);
    }

    return DSR_ERROR(hr);
}

//
// Applies the aces in the given access settings to the 
// appropriate domain.
//
HRESULT
DsrAceAppAdd(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount)
{    
    HRESULT hr = S_OK;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i;
    
    // Output the aces that we'll set
    //
    DsrTraceEx(0, "Adding %d aces...", dwCount);

    do
    {
        // Add the ACES to the domain objects
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = DsrAceAdd(
                    pszDC,
                    pAceApp->pObject,
                    &(pAceApp->Ace));
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Commit the ACE's to the domain objects.
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = pAceApp->pObject->SetInfo();
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

// 
// Releases the resources held by an ace application
//
HRESULT
DsrAceAppCleanup(
    IN DSR_ACE_APPLICATION* pAces,
    IN DWORD dwCount)
{
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i;

    if (pAces)
    {
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            DSR_RELEASE(pAceApp->pObject);
            DsrAceDescClear(&(pAceApp->Ace));
        }

        DSR_FREE(pAces);
    }        

    return NO_ERROR;
}

// 
// Generates a list of ace applications based on a list
// of ace application descriptions
//
HRESULT
DsrAceAppFromAppDesc(
    IN  DSR_ACE_APPLICATION_DESC* pDesc,
    IN  DWORD dwCount,
    IN  IADsContainer* pContainer,
    IN  IADs* pDefault,
    OUT DSR_ACE_APPLICATION** ppAceApp,
    OUT LPDWORD lpdwCount)
{
    DSR_ACE_APPLICATION* pAceApp = NULL, *pCurApp = NULL;
    DSR_ACE_APPLICATION_DESC* pAceAppDesc = NULL;
    IDispatch* pDispatch = NULL;
    HRESULT hr = S_OK;                
    DWORD i;

    do
    {
        // Allocate and zero the ACE list
        //
        pAceApp = (DSR_ACE_APPLICATION*) 
            DsrAlloc(sizeof(DSR_ACE_APPLICATION) * dwCount, TRUE);
        if (pAceApp == NULL)
        {
           DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
        }

        // Set up the ACE applications
        //
        for (i = 0, pAceAppDesc = pDesc, pCurApp = pAceApp;
             i < dwCount;
             i++, pAceAppDesc++, pCurApp++)
        {
            // Get the desired object in the DS
            //
            if (pAceAppDesc->pszObjectCN)
            {
                hr = pContainer->GetObject(
                        pAceAppDesc->pszObjectClass,
                        pAceAppDesc->pszObjectCN,
                        &pDispatch);
                DSR_BREAK_ON_FAILED_HR( hr );

                hr = pDispatch->QueryInterface(
                        IID_IADs,
                        (VOID**)&(pCurApp->pObject));
                DSR_BREAK_ON_FAILED_HR( hr );

                pDispatch->Release();
                pDispatch = NULL;
            }
            else
            {
                pCurApp->pObject = pDefault;
                pCurApp->pObject->AddRef();
            }

            // Copy over the ACE information
            hr = DsrAceDescCopy(
                    &(pCurApp->Ace),
                    &(pAceAppDesc->Ace));
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return values
        *ppAceApp = pAceApp;
        *lpdwCount = dwCount;
        
    } while (FALSE);        

    // Cleanup
    {
        if (FAILED(hr))
        {
            DsrAceAppCleanup(pAceApp, i);
        }
    }

    return hr;
}

// 
// Discovers whether a set of aces is present in the given 
// domain.
//
HRESULT
DsrAceAppQueryPresence(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount,
    OUT PBOOL pbPresent)
{
    DSR_ACE_APPLICATION* pAceApp = NULL;
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IDispatch* pAce = NULL;
    VARIANT varSD;
    HRESULT hr = S_OK;
    BOOL bEnabled = FALSE, bOk = TRUE;
    DWORD i;

    do
    {
        // Initialize
        *pbPresent = FALSE;
        VariantInit(&varSD);

        // Find out if the ACES are set
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = DsrAceFind(
                    pszDC,
                    pAceApp->pObject,
                    &(pAceApp->Ace),
                    &varSD,
                    &pSD,
                    &pAcl,
                    &pAce);
            DSR_BREAK_ON_FAILED_HR( hr );

            // We're enabled so long as we don't find
            // a missing ACE
            //
            bOk = (pAce != NULL);

            // Cleanup
            //
            DSR_RELEASE( pAce );
            DSR_RELEASE( pAcl );
            DSR_RELEASE( pSD );
            VariantClear(&varSD);
            pAce = NULL;
            pAcl = NULL;
            pSD  = NULL;

            // Break if we find out we're not enabled
            //
            if (bOk == FALSE)
            {
                break;
            }
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        *pbPresent = bOk;
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

//
// Applies the aces in the given access settings to the 
// appropriate domain.
//
HRESULT
DsrAceAppRemove(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount)
{    
    HRESULT hr = S_OK;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i;
    
    // Output the aces that we'll set
    //
    DsrTraceEx(0, "Removing %d aces...", dwCount);

    do
    {
        // Add/Del the ACES to the domain objects
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = DsrAceRemove(
                    pszDC,
                    pAceApp->pObject,
                    &(pAceApp->Ace));
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Commit the ACE's to the domain objects.
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = pAceApp->pObject->SetInfo();
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

//
// Clear the dsr ace parameters
//
DWORD
DsrAceDescClear(
    IN DSR_ACE_DESCRIPTOR* pParams)
{
    if (pParams)
    {
        if (pParams->bstrTrustee)
        {
            SysFreeString(pParams->bstrTrustee);
        }
        if (pParams->bstrObjectType)
        {
            SysFreeString(pParams->bstrObjectType);
        }
        if (pParams->bstrInheritedObjectType)
        {
            SysFreeString(pParams->bstrInheritedObjectType);
        }

        ZeroMemory(pParams, sizeof(DSR_ACE_DESCRIPTOR));
    }

    return NO_ERROR;
}

//
// Returns 0 if ACE descriptors are describing the same ACE.
// FALSE, otherwise.
//
HRESULT
DsrAceDescCompare(
    IN DSR_ACE_DESCRIPTOR* pAce1,
    IN DSR_ACE_DESCRIPTOR* pAce2)
{
    DWORD dw1, dw2;
    
    // Compare the non-string fields so that we can rule things
    // out w/o string compares if possible
    //
    if (
        (pAce1->dwAccessMask != pAce2->dwAccessMask) ||
        (pAce1->dwAceFlags   != pAce2->dwAceFlags)   ||
        (pAce1->dwAceType    != pAce2->dwAceType)    ||
        (pAce1->dwFlags      != pAce2->dwFlags)
       )
    {
        return 1;
    }

    // Compare the strings
    //
    if ((DsrStrCompare(pAce1->bstrTrustee, pAce2->bstrTrustee))       ||
        (DsrStrCompare(pAce1->bstrObjectType, pAce2->bstrObjectType)) ||
        (DsrStrCompare(pAce1->bstrInheritedObjectType,
                       pAce2->bstrInheritedObjectType))
       )
    {
        return 1;
    }

    // Return success
    //
    return 0;
}

//
// Copy over the ACE information
//
HRESULT
DsrAceDescCopy(
    OUT DSR_ACE_DESCRIPTOR* pDst,
    IN  DSR_ACE_DESCRIPTOR* pSrc)
{
    HRESULT hr = S_OK;

    do
    {
        // Initialize the ACE parameters
        *pDst = *pSrc;

        if (pSrc->bstrTrustee)
        {
            pDst->bstrTrustee =
                SysAllocString(pSrc->bstrTrustee);

            if (pDst->bstrTrustee == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

        if (pSrc->bstrObjectType)
        {
            pDst->bstrObjectType =
                SysAllocString(pSrc->bstrObjectType);

            if (pDst->bstrObjectType == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

        if (pSrc->bstrInheritedObjectType)
        {
            pDst->bstrInheritedObjectType =
                SysAllocString(pSrc->bstrInheritedObjectType);

            if (pDst->bstrInheritedObjectType == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

    } while (FALSE);

    // Cleanup
    {
        if (FAILED( hr ))
        {
            if (pDst->bstrTrustee)
            {
               SysFreeString(pDst->bstrTrustee);
            }
            if (pDst->bstrObjectType)
            {
               SysFreeString(pDst->bstrObjectType);
            }
            if (pDst->bstrInheritedObjectType)
            {
               SysFreeString(pDst->bstrInheritedObjectType);
            }
        }
    }

    return hr;
}

//
// Populates the given ACE descriptor with the values from
// the given ACE.
//
HRESULT
DsrAceDescFromIadsAce(
    IN PWCHAR pszDC,
    IN IADsAccessControlEntry* pAce,
    IN DSR_ACE_DESCRIPTOR* pAceParams)
{
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    WCHAR pszSid[1024], pszDomain[1024];
    BYTE pbSid[1024];
    DWORD dwSidSize, dwDomainSize;
    BOOL bOk;
    SID_NAME_USE SidNameUse;

    do
    {
        hr = pAce->get_AccessMask(&(pAceParams->dwAccessMask));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_AceType(&(pAceParams->dwAceType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_AceFlags(&(pAceParams->dwAceFlags));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_Flags(&(pAceParams->dwFlags));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_ObjectType(&(pAceParams->bstrObjectType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_InheritedObjectType(
                &(pAceParams->bstrInheritedObjectType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_Trustee(&bstrTrustee);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the SID of the trustee
        //
        dwSidSize = sizeof(pbSid);
        dwDomainSize = sizeof(pszDomain) / sizeof(WCHAR);
        bOk = LookupAccountName(
                    pszDC,
                    bstrTrustee,
                    (PSID)pbSid,
                    &dwSidSize,
                    pszDomain,
                    &dwDomainSize,
                    &SidNameUse);
        if (bOk == FALSE)
        {
            hr = GetLastError();
            break;
        }

        // Convert the sid to a string
        //
        hr = DsrStrFromSID((PSID)pbSid, pszSid, sizeof(pszSid));
        if (hr != NO_ERROR)
        {
            break;
        }

        // Create the trustee accordingly
        //
        pAceParams->bstrTrustee = SysAllocString(pszSid);
        if (pAceParams->bstrTrustee == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (bstrTrustee)
        {
            SysFreeString(bstrTrustee);
        }

        if (FAILED(hr))
        {
            DsrAceDescClear(pAceParams);
        }
    }

    return hr;
}
            
//
// Initialize an ace descriptor from a W2K Ace
//
HRESULT
DsrAceDescFromW2KAce(
    IN  PWCHAR pszDC,
    IN  PVOID pvAce,
    OUT DSR_ACE_DESCRIPTOR* pAceDesc)
{
    PACCESS_ALLOWED_ACE pAaAce = NULL;
    PACCESS_DENIED_ACE pAdAce = NULL;
    PACCESS_ALLOWED_OBJECT_ACE pAaoAce = NULL;
    PACCESS_DENIED_OBJECT_ACE pAdoAce = NULL;
    PSID pSID = NULL;
    DWORD dwFlags = 0, dwNameSize, dwDomainSize, dwAccessMask;
    BYTE bAceType, bAceFlags;
    SID_NAME_USE SidNameUse;
    WCHAR pszGuid[64], pszName[512], pszDomain[512], pszTrustee[1024];
    HRESULT hr = S_OK;
    GUID* pgObj = NULL, *pgInhObj = NULL;
    BOOL bOk = TRUE;

    // Read in the ace values
    //
    bAceType  = ((ACE_HEADER *)pvAce)->AceType;
    bAceFlags = ((ACE_HEADER *)pvAce)->AceFlags;
    switch (bAceType)
    {
        case ACCESS_ALLOWED_ACE_TYPE:
            pAaAce = (PACCESS_ALLOWED_ACE)pvAce;
            dwAccessMask = pAaAce->Mask;
            pSID = (PSID)&(pAaAce->SidStart);
            break;
            
        case ACCESS_DENIED_ACE_TYPE:
            pAdAce = (PACCESS_DENIED_ACE)pvAce;
            dwAccessMask = pAdAce->Mask;
            pSID = (PSID)&(pAdAce->SidStart);
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            pAaoAce = (PACCESS_ALLOWED_OBJECT_ACE)pvAce;
            dwAccessMask = pAaoAce->Mask;
            dwFlags = pAaoAce->Flags;

            // Determine the location of the guids
            // and SIDs.  They are arranged such that they
            // take up as little memory as possible
            //
            if (dwFlags & ACE_OBJECT_TYPE_PRESENT)
            {
                pgObj = (GUID*)&(pAaoAce->ObjectType);
                pSID = (PSID)&(pAaoAce->InheritedObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAaoAce->InheritedObjectType);
                    pSID = (PSID)&(pAaoAce->SidStart);
                }
            }
            else 
            {
                pSID = (PSID)&(pAaoAce->ObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAaoAce->ObjectType);
                    pSID = (PSID)&(pAaoAce->InheritedObjectType);
                }
            }
            break;
            
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            pAdoAce = (PACCESS_DENIED_OBJECT_ACE)pvAce;
            dwAccessMask = pAdoAce->Mask;
            dwFlags = pAdoAce->Flags;

            // Determine the location of the guids
            // and SIDs.  They are arranged such that they
            // take up as little memory as possible
            //
            if (dwFlags & ACE_OBJECT_TYPE_PRESENT)
            {
                pgObj = (GUID*)&(pAdoAce->ObjectType);
                pSID = (PSID)&(pAdoAce->InheritedObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAdoAce->InheritedObjectType);
                    pSID = (PSID)&(pAdoAce->SidStart);
                }
            }
            else 
            {
                pSID = (PSID)&(pAdoAce->ObjectType);
                if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    pgInhObj = (GUID*)&(pAdoAce->ObjectType);
                    pSID = (PSID)&(pAdoAce->InheritedObjectType);
                }
            }
            break;
            
        default:
            DsrTraceEx(0, "Unknown ACE TYPE %x", bAceType);
            bOk = FALSE;
            break;
    }
    if (bOk == FALSE)
    {
        return E_FAIL;
    }

    // Lookup the account name of the sid
    //
    hr = DsrStrFromSID(pSID, pszTrustee, sizeof(pszTrustee));
    if (hr != NO_ERROR)
    {
        return HRESULT_FROM_WIN32(hr);
    }

    // Fill in the ACE fields
    pAceDesc->dwAceType    = (LONG)bAceType;
    pAceDesc->dwAceFlags   = (LONG)bAceFlags;
    pAceDesc->dwAccessMask = (LONG)dwAccessMask;
    pAceDesc->dwFlags      = (LONG)dwFlags;
    pAceDesc->bstrTrustee  = SysAllocString(pszTrustee);
    if (pgObj)
    {
        StringFromGUID2(
            *pgObj, 
            pszGuid, 
            sizeof(pszGuid)/sizeof(WCHAR)); 
            
        pAceDesc->bstrObjectType = SysAllocString(pszGuid);
    }
    if (pgInhObj)
    {
        StringFromGUID2(
            *pgInhObj, 
            pszGuid, 
            sizeof(pszGuid)/sizeof(WCHAR)); 
            
        pAceDesc->bstrInheritedObjectType = SysAllocString(pszGuid);
    }

    return hr;
}

//
// Generates a list of ace descriptors based on a stringized
// SD
//
HRESULT 
DsrAceDescListFromString(
    IN  PWCHAR pszDC,
    IN  PWCHAR pszSD,
    OUT DSR_ACE_DESCRIPTOR** ppAceList, 
    OUT LPDWORD lpdwAceCount)
{
    BOOL bOk = TRUE, bPresent = FALSE, bDefaulted = FALSE;
    DSR_ACE_DESCRIPTOR* pAceList = NULL, *pCurAce = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PVOID pvAce = NULL;
    ULONG ulSize = 0;
    PACL pDacl = NULL;
    HRESULT hr = S_OK;
    DWORD i;

    do 
    {
        // First, convert the stringized security descriptor to a 
        // plain old vanilla security descriptor.  ADSI doesn't 
        // support this for W2K, so we have to do it with SDDL 
        // api's
        //
        bOk = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                    pszSD, 
                    SDDL_REVISION_1,
                    &pSD,
                    &ulSize);
        if (bOk == FALSE)
        {
            hr = E_FAIL;
            break;
        }

        // Get the DACL from the SD.
        //
        bOk = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
        if (bOk == FALSE)
        {
            hr = E_FAIL;
            break;
        }

        // If there are no aces, then there's nothing to do
        // 
        if (pDacl->AceCount == 0)
        {
            break;
        }

        // Allocate the list that we'll return if everything goes well.
        //
        pAceList = (DSR_ACE_DESCRIPTOR*) 
            DsrAlloc(pDacl->AceCount * sizeof(DSR_ACE_DESCRIPTOR), TRUE);
        if (pAceList == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        // Initialize the list of aces
        // 
        for (i = 0, pCurAce = pAceList; i < pDacl->AceCount; i++, pCurAce++)
        {
            // Get a reference to the current
            // ACE
            //
            if (! GetAce(pDacl, i, &pvAce))
            {
                continue;
            }

            // Initialize the ACE descriptor accordingly
            //
            hr = DsrAceDescFromW2KAce(pszDC, pvAce, pCurAce);
            DSR_BREAK_ON_FAILED_HR(hr);

            //DsrAceDescTrace(pCurAce);
        }
        DSR_BREAK_ON_FAILED_HR(hr);

        // Set the return values. Clear pAceList so it doesn't
        // get cleaned up.
        //
        *ppAceList = pAceList;
        *lpdwAceCount = pDacl->AceCount;
        pAceList = NULL;

    } while (FALSE);                           

    // Cleanup
    {
        if (pSD)
        {
            LocalFree(pSD);
        }

        if (pAceList)
        {
            for (i = 0; i < pDacl->AceCount; i++)
            {
                DsrAceDescClear(&(pAceList[i]));
            }
            DsrFree(pAceList);
        }
    }
    
    return hr;
}

PWCHAR 
DsrAceAttrToString(
    IN PWCHAR pszObjectType)
{
    if (pszObjectType == NULL)
    {
        return L"All";
    }
    else if (lstrcmpi(pszObjectType, pszGuidUserParms) == 0)
    {
        return L"UserParms (BF967A6D-0DE6-11D0-A285-00AA003049E2)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidRasPropSet1) == 0)
    {
        return L"Ras user properties (037088F8-0AE1-11D2-B422-00A0C968F939)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidRasPropSet2) == 0)
    {
        return L"Misc user properties (4C164200-20C0-11D0-A768-00AA006E0529)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidLogonHours) == 0)
    {
        return L"Logon-Hours (BF9679AB-0DE6-11D0-A285-00AA003049E2)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidSamAccountName) == 0)
    {
        return L"Sam account name (3E0ABFD0-126A-11D0-A060-00AA006C33ED)";
    }

    return pszObjectType;
}

PWCHAR 
DsrAceApplyToString(
    IN PWCHAR pszApply)
{
    if (pszApply == NULL)
    {
        return L"This object";
    }
    else if (lstrcmpi(pszApply, pszGuidUserClass) == 0)
    {
        return L"User objects (BF967ABA-0DE6-11D0-A285-00aa003049E2)";
    }

    return pszApply;
} 

PWCHAR
DsrAceMaskToString(
    IN DWORD dwType,
    IN DWORD dwMask,
    IN PWCHAR pszBuf)
{
    WCHAR pszTemp[64];
    *pszBuf = L'\0';

    switch (dwType)
    {
        case ADS_ACETYPE_ACCESS_ALLOWED:
            wcscpy(pszBuf, L"Allow:       ");
            break;
            
    	case ADS_ACETYPE_ACCESS_DENIED:
            wcscpy(pszBuf, L"Deny:        ");
            break;
            
    	case ADS_ACETYPE_SYSTEM_AUDIT:
            wcscpy(pszBuf, L"Audit:       ");
            break;
            
    	case ADS_ACETYPE_ACCESS_ALLOWED_OBJECT:
            wcscpy(pszBuf, L"Allow obj:   ");
            break;
            
    	case ADS_ACETYPE_ACCESS_DENIED_OBJECT:
            wcscpy(pszBuf, L"Deny obj:    ");
            break;
            
    	case ADS_ACETYPE_SYSTEM_AUDIT_OBJECT:
            wcscpy(pszBuf, L"Audit obj:   ");
            break;
    }    	

    wsprintfW(pszTemp, L"(%x): ", dwMask);
    wcscat(pszBuf, pszTemp);

    if (dwMask == DSR_ADS_RIGHT_GENERIC_READ)
    {
        wcscat(pszBuf, L"Generic read");
    }
    else if (dwMask == 0xffffffff)
    {
        wcscat(pszBuf, L"Full control");
    }
    else
    {
    	if (dwMask & ADS_RIGHT_READ_CONTROL)
    	    wcscat(pszBuf, L"R ctrl, ");
    	if (dwMask & ADS_RIGHT_WRITE_DAC)
    	    wcscat(pszBuf, L"R/W dac, ");
    	if (dwMask & ADS_RIGHT_WRITE_OWNER)
    	    wcscat(pszBuf, L"W own, ");
    	if (dwMask & ADS_RIGHT_SYNCHRONIZE)
    	    wcscat(pszBuf, L"Sync, ");
    	if (dwMask & ADS_RIGHT_ACCESS_SYSTEM_SECURITY)
    	    wcscat(pszBuf, L"Sys, ");
    	if (dwMask & ADS_RIGHT_GENERIC_READ)
    	    wcscat(pszBuf, L"R (gen), ");
    	if (dwMask & ADS_RIGHT_GENERIC_WRITE)
    	    wcscat(pszBuf, L"W (gen), ");
    	if (dwMask & ADS_RIGHT_GENERIC_EXECUTE)
    	    wcscat(pszBuf, L"Ex, ");
    	if (dwMask & ADS_RIGHT_GENERIC_ALL)
    	    wcscat(pszBuf, L"All, ");
    	if (dwMask & ADS_RIGHT_DS_CREATE_CHILD)
    	    wcscat(pszBuf, L"Cr cld, ");
    	if (dwMask & ADS_RIGHT_DS_DELETE_CHILD)
    	    wcscat(pszBuf, L"Del cld, ");
    	if (dwMask & ADS_RIGHT_ACTRL_DS_LIST)
    	    wcscat(pszBuf, L"List, ");
    	if (dwMask & ADS_RIGHT_DS_SELF)
    	    wcscat(pszBuf, L"Self, ");
    	if (dwMask & ADS_RIGHT_DS_READ_PROP)
    	    wcscat(pszBuf, L"R prop, ");
    	if (dwMask & ADS_RIGHT_DS_WRITE_PROP)
    	    wcscat(pszBuf, L"W prop, ");
    	if (dwMask & ADS_RIGHT_DS_DELETE_TREE)
    	    wcscat(pszBuf, L"Del tree, ");
    	if (dwMask & ADS_RIGHT_DS_LIST_OBJECT)
    	    wcscat(pszBuf, L"List obj, ");
    	if (dwMask & ADS_RIGHT_DS_CONTROL_ACCESS)
    	    wcscat(pszBuf, L"Ctrl acc, ");
    }

    return pszBuf;
}

PWCHAR
DsrAceFlagsToString(
    IN DWORD dwAceFlags,
    IN PWCHAR pszBuf)
{   
    WCHAR pszTemp[64];
    *pszBuf = L'\0';

    switch (dwAceFlags)
    {
        case 0:
            wcscpy(pszBuf, L"This object only");
    	    break;
        
        case ADS_ACEFLAG_INHERIT_ACE:
            wcscpy(pszBuf, L"This object and children");
    	    break;
    	    
    	case ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE:
            wcscpy(pszBuf, L"No-prop inherit");
    	    break;
    	    
    	case ADS_ACEFLAG_INHERIT_ONLY_ACE:
            wcscpy(pszBuf, L"Inherit-only");
    	    break;
    	    
    	case ADS_ACEFLAG_INHERITED_ACE:
    	    wcscpy(pszBuf, L"Inherited");
    	    break;
    	    
    	case ADS_ACEFLAG_VALID_INHERIT_FLAGS:
    	    wcscpy(pszBuf, L"Valid inherit flags");
    	    break;
    	    
    	case ADS_ACEFLAG_SUCCESSFUL_ACCESS:
    	    wcscpy(pszBuf, L"Successful access");
    	    break;
    	    
    	case ADS_ACEFLAG_FAILED_ACCESS:
    	    wcscpy(pszBuf, L"Failed access");
    	    break;
    }  

    wsprintfW(pszTemp, L" (%x)", dwAceFlags);
    wcscat(pszBuf, pszTemp);

    return pszBuf;
}   	

//
// Traces out the contents of an ACE
//
VOID
DsrAceDescTrace(
    IN IADs* pIads,
    IN DSR_ACE_DESCRIPTOR* pA)
{
    VARIANT var;
    BSTR bstrProp = SysAllocString(pszDn);
    HRESULT hr = S_OK;
    WCHAR pszBuf[1024];

    do
    {
        VariantInit(&var);

        if (bstrProp == NULL)
        {
            hr = E_FAIL;
            break;
        }

        hr = pIads->Get(bstrProp, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        DsrTraceEx(0, "%ls", V_BSTR(&var));
        DsrTraceEx(0, "%ls", 
            DsrAceMaskToString(pA->dwAceType, pA->dwAccessMask, pszBuf));
        DsrTraceEx(0, "To:          %ls", pA->bstrTrustee);
        DsrTraceEx(0, "Attribute:   %ls", 
            DsrAceAttrToString(pA->bstrObjectType));
        DsrTraceEx(0, "ApplyTo:     %ls", 
            DsrAceApplyToString(pA->bstrInheritedObjectType));
        DsrTraceEx(0, "Inheritance: %ls", 
            DsrAceFlagsToString(pA->dwAceFlags, pszBuf));
        DsrTraceEx(0, "Flags:       %x", pA->dwFlags);
        DsrTraceEx(0, " ");

    } while (FALSE);

    // Cleanup
    //
    {
        SysFreeString(bstrProp);
        VariantClear(&var);        
    }        

    if (FAILED(hr))
    {
        DsrTraceEx(
            0, 
            "{ %-8x %-2x %-2x %-2x %-40ls %ls %ls }",
            pA->dwAccessMask,
            pA->dwAceType,
            pA->dwAceFlags,
            pA->dwFlags,
            pA->bstrTrustee,
            pA->bstrObjectType,
            pA->bstrInheritedObjectType);
    }
}

//
// Adds the given ace to the given ds object
//
HRESULT
DsrAceAdd(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams)
{
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IDispatch* pAce = NULL;
    IDispatch* pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT var;

    // Initialize
    VariantInit(&var);

    do
    {
        // Get the security descriptor
        //
        pIads->Get((PWCHAR)pszSecurityDesc, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the appropriate interface to the sd
        //
        V_DISPATCH(&var)->QueryInterface(
            IID_IADsSecurityDescriptor,
            (VOID**)&pSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get a reference to the discretionary acl
        //
        hr = pSD->get_DiscretionaryAcl(&pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pDispatch->QueryInterface(
                IID_IADsAccessControlList,
                (VOID**)&pAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Don't add the ACE if it's already there.
        //
        hr = DsrAceFindInAcl(
                pszDC,                
                pAcl,
                pAceParams,
                &pAce);
        if (SUCCEEDED(hr) && pAce)
        {
            hr = S_OK;
            break;
        }

        // Trace out the ACE
        DsrAceDescTrace(pIads, pAceParams);

        // Create the ACE
        hr = DsrAceCreate(pAceParams, &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Add the newly created ACE to the ACL
        //
        hr = pAcl->AddAce(pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Now commit the result in the ACL
        //
        hr = pSD->put_DiscretionaryAcl(pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Finally, commit the result in the ds object
        //
        hr = pIads->Put((PWCHAR)pszSecurityDesc, var);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAce );
        DSR_RELEASE( pAcl );
        DSR_RELEASE( pDispatch );
        DSR_RELEASE( pSD );

        VariantClear(&var);
    }

    return DSR_ERROR(hr);
}

//
// Creates a new ACE object from the given parameters
//
HRESULT
DsrAceCreate(
    IN  DSR_ACE_DESCRIPTOR * pAceParams,
    OUT IDispatch** ppAce)
{
    IADsAccessControlEntry* pAce = NULL;
    IDispatch* pRet = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Create the new ACE
        //
        hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (VOID**) &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Initialize the values
        //
        hr = pAce->put_Trustee(pAceParams->bstrTrustee);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AceFlags(pAceParams->dwAceFlags);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_Flags(pAceParams->dwFlags);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AceType(pAceParams->dwAceType);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AccessMask(pAceParams->dwAccessMask);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_ObjectType(pAceParams->bstrObjectType);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_InheritedObjectType(
                        pAceParams->bstrInheritedObjectType);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Query the return value
        //
        hr = pAce->QueryInterface(IID_IDispatch, (VOID**)&pRet);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return value
        *ppAce = pRet;

    } while (FALSE);

    // Cleanup
    {
        if (FAILED (hr))
        {
            DSR_RELEASE(pRet);
        }
        DSR_RELEASE(pAce);
    }

    return hr;
}

//
// Finds the given ace in the given acl
//
HRESULT
DsrAceFind(
    IN  PWCHAR pszDC,
    IN  IADs* pObject,
    IN  DSR_ACE_DESCRIPTOR* pAceParams,
    OUT VARIANT* pVarSD,
    OUT IADsSecurityDescriptor** ppSD,
    OUT IADsAccessControlList** ppAcl,
    OUT IDispatch** ppAce)
{
    IDispatch* pAcl = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Get the security descriptor
        //
        pObject->Get((PWCHAR)pszSecurityDesc, pVarSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the appropriate interface to the sd
        //
        V_DISPATCH(pVarSD)->QueryInterface(
            IID_IADsSecurityDescriptor,
            (VOID**)ppSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get a reference to the discretionary acl
        //
        hr = (*ppSD)->get_DiscretionaryAcl(&pAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAcl->QueryInterface(
                IID_IADsAccessControlList,
                (VOID**)ppAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = DsrAceFindInAcl(
                pszDC,
                *ppAcl,
                pAceParams,
                ppAce);
        DSR_BREAK_ON_FAILED_HR(hr);                

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAcl );

        if (*ppAce == NULL)
        {
            VariantClear(pVarSD);
            DSR_RELEASE(*ppAcl);
            DSR_RELEASE(*ppSD);
            *ppAcl = NULL;
            *ppSD = NULL;
        }
    }

    return hr;
}

//
// Finds the given ACE in the given ACL
//
HRESULT
DsrAceFindInAcl(
    IN  PWCHAR pszDC,
    IN  IADsAccessControlList* pAcl,
    IN  DSR_ACE_DESCRIPTOR* pAceDesc, 
    OUT IDispatch** ppAce)
{    
    DSR_ACE_DESCRIPTOR CurAceParams, *pCurAceDesc = &CurAceParams;
    IADsAccessControlEntry* pCurAce = NULL;
    HRESULT hr = S_OK;
    IUnknown* pUnknown = NULL;
    IEnumVARIANT* pEnumVar = NULL;
    IDispatch* pRet = NULL;
    DWORD dwRetrieved;
    VARIANT var;

    do
    {
        // Get an enumerator of the aces
        //
        hr = pAcl->get__NewEnum(&pUnknown);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the right interface to enumerate the aces
        //
        hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (VOID**)&pEnumVar);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Enumerate
        //
        pEnumVar->Reset();
        VariantInit(&var);
        ZeroMemory(pCurAceDesc, sizeof(DSR_ACE_DESCRIPTOR));
        while ((pEnumVar->Next(1, &var, &dwRetrieved) == S_OK) &&
               (dwRetrieved == 1)
              )
        {
            // Get the reference to the ace
            //
            hr = V_DISPATCH(&var)->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (VOID**)&pCurAce);

            if (SUCCEEDED (hr))
            {
                // Read the ACE parameters
                //
                hr = DsrAceDescFromIadsAce(pszDC, pCurAce, pCurAceDesc);
                if (SUCCEEDED (hr))
                {
                    // Assign the ace if we have a match
                    //
                    if (DsrAceDescCompare(pCurAceDesc, pAceDesc) == 0)
                    {
                        pRet = V_DISPATCH(&var);
                    }

                    DsrAceDescClear(pCurAceDesc);
                }
                pCurAce->Release();
            }

            if (pRet == NULL)
            {
                VariantClear(&var);
            }
            else
            {
                break;
            }
        }

        // Assign the return value
        //
        *ppAce = pRet;
        
    } while (FALSE);        

    // Cleanup
    {
        DSR_RELEASE( pEnumVar );
        DSR_RELEASE( pUnknown );
    }

    return hr;
}    

//
// Removes the given ace from the given ds object
//
HRESULT
DsrAceRemove(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams)
{
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IADsAccessControlEntry* pIadsAce = NULL;
    IDispatch* pAce = NULL;
    DSR_ACE_DESCRIPTOR CurAceParams;
    HRESULT hr = S_OK;
    VARIANT varSD;

    do
    {
        VariantInit(&varSD);

        hr = DsrAceFind(pszDC, pIads, pAceParams, &varSD, &pSD, &pAcl, &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        if (pAce)
        {
            // Make sure the ace is the same as we think
            //
            hr = pAce->QueryInterface(
                    IID_IADsAccessControlEntry, 
                    (VOID**)&pIadsAce);
            if (SUCCEEDED(hr))
            {
                DsrTraceEx(0, "ACE to be removed!");
                DsrAceDescFromIadsAce(pszDC, pIadsAce, &CurAceParams);
                DsrAceDescTrace(pIads, &CurAceParams);
                DsrAceDescClear(&CurAceParams);
            }
            else
            {
                DsrTraceEx(0, "Unable to trace ACE that will be removed!\n");
            }
        
            // Remove the ace found if any.
            //
            // Trace out the ACE
            hr = pAcl->RemoveAce(pAce);
            DSR_BREAK_ON_FAILED_HR( hr );

            // Now commit the result in the ACL
            //
            hr = pSD->put_DiscretionaryAcl(pAcl);
            DSR_BREAK_ON_FAILED_HR( hr );

            // Finally, commit the result in the ds object
            //
            hr = pIads->Put((PWCHAR)pszSecurityDesc, varSD);
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        else
        {
            DsrTraceEx(0, "DsrAceRemove: unable to match ACE for removal:");
            DsrAceDescTrace(pIads, pAceParams);
        }

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAce );
        DSR_RELEASE( pIadsAce );
        DSR_RELEASE( pAcl );
        DSR_RELEASE( pSD );
        VariantClear(&varSD);
    }

    return DSR_ERROR(hr);
}

//
// Cleans up after DsrAccessInfoInit
//
DWORD
DsrAccessInfoCleanup(
    IN DSR_DOMAIN_ACCESS_INFO* pInfo)
{
    if (pInfo)
    {
        // Cleanup the name of the DC
        //
        if (pInfo->pszDC)
        {
            DsrFree(pInfo->pszDC);
        }
    
        // Cleanup the ace applications
        //
        DsrAceAppCleanup(pInfo->pAcesUser, pInfo->dwAceCountUser);
        DsrAceAppCleanup(pInfo->pAcesNt4, pInfo->dwAceCountNt4);
        DsrAceAppCleanup(pInfo->pAcesW2k, pInfo->dwAceCountW2k);

        // Release the hold on domain objects
        //
        DSR_RELEASE(pInfo->pUserClass);
        DSR_RELEASE(pInfo->pRootDse);
        DSR_RELEASE(pInfo->pDomain);

        DsrFree(pInfo);
    }

    return NO_ERROR;
}

// 
// Generates aces from the default user SD
//
HRESULT
DsrAccessInfoGenerateUserAces(
    IN OUT DSR_DOMAIN_ACCESS_INFO* pInfo)
{
    DSR_ACE_DESCRIPTOR* pAceSrc = NULL, *pAceList = NULL;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i, dwAceCount = 0;
    HRESULT hr = S_OK;
    VARIANT var;

    VariantInit(&var);

    do 
    {
        // Read in the default user SD
        //
        hr = pInfo->pUserClass->Get((PWCHAR)pszDefSecurityDesc, &var);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Generate a list of ACE descriptors based on the
        // default user SD.
        //
        hr = DsrAceDescListFromString(
                pInfo->pszDC,
                V_BSTR(&var), 
                &pAceList, 
                &dwAceCount);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Initialize a new array of ace applications big enough
        // to hold the hard coded ones plus the ones we just read
        // from the default SD of the user class.
        //
        pInfo->pAcesUser = (DSR_ACE_APPLICATION*)
            DsrAlloc((sizeof(DSR_ACE_APPLICATION) * dwAceCount), TRUE);
        if (pInfo->pAcesUser == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // Add the ACEs we read from the default user SD
        //
        pAceApp = pInfo->pAcesUser;
        for (i = 0, pAceSrc = pAceList; 
             i < dwAceCount; 
             i++, pAceSrc++, pAceApp++)
        {   
            pAceApp->pObject = pInfo->pDomain;
            pAceApp->pObject->AddRef();
            CopyMemory(
                &(pAceApp->Ace), 
                pAceSrc,
                sizeof(DSR_ACE_DESCRIPTOR));
            pInfo->dwAceCountUser++;

            // As we append the aces, we need to modify them
            // so that they apply only to user objects in the 
            // domain.
            pAceApp->Ace.bstrInheritedObjectType = 
                SysAllocString(pszGuidUserClass);
            pAceApp->Ace.dwAceFlags = DSR_ADS_ACE_INHERITED;
            pAceApp->Ace.dwFlags |= ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT;
            if (pAceApp->Ace.dwAceType == ADS_ACETYPE_ACCESS_ALLOWED)
            {
                pAceApp->Ace.dwAceType = 
                    ADS_ACETYPE_ACCESS_ALLOWED_OBJECT;
            }
            else if (pAceApp->Ace.dwAceType == ADS_ACETYPE_ACCESS_DENIED)
            {
                pAceApp->Ace.dwAceType = 
                    ADS_ACETYPE_ACCESS_DENIED_OBJECT;
            }
        }
    
    } while (FALSE);

    // Cleanup
    {
        DSR_FREE(pAceList);
        VariantClear(&var);
    }

    return hr;
}

//
// Generates the information needed to enable nt4 ras
// servers in a domain
//
HRESULT
DsrAccessInfoInit(
    IN  PWCHAR pszDomain,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    IADsContainer* pDomContainer = NULL, *pSchemaContainer = NULL;
    IADs* pDomain = NULL;
    IDispatch* pDispatch = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Allocate and zero the return value
        //
        pInfo = (DSR_DOMAIN_ACCESS_INFO*)
                    DsrAlloc(sizeof(DSR_DOMAIN_ACCESS_INFO), TRUE);
        if (pInfo == NULL)
        {
           DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
        }

        // Get the name of a DC to query when needed
        //
        hr = DsGetDcNameW(
                NULL,
                pszDomain,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED,
                &pDomainInfo);
        if (hr != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(hr);
            break;
        }

        // Copy the string
        //
        pInfo->pszDC = (PWCHAR)
            DsrAlloc(
                (wcslen(pDomainInfo->DomainControllerName) + 1) * 
                sizeof(WCHAR),
                FALSE);
        if (pInfo->pszDC == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        wcscpy(pInfo->pszDC, pDomainInfo->DomainControllerName);

        // Get the well known domain containers
        //
        hr = DsrDomainGetContainers(
                pszDomain,
                &(pInfo->pRootDse),
                &pDomContainer,
                &pSchemaContainer);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the interface to the domain object
        //
        hr = pDomContainer->QueryInterface(
                IID_IADs,
                (VOID**)&pDomain);
        DSR_BREAK_ON_FAILED_HR( hr );
        pInfo->pDomain = pDomain;
        pInfo->pDomain->AddRef();

        // Get the reference to the user class in the
        // schema
        hr = pSchemaContainer->GetObject(
                (PWCHAR)pszUserClass,
                (PWCHAR)pszUserCN,
                &pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );
        hr = pDispatch->QueryInterface(
                IID_IADs,
                (VOID**)&(pInfo->pUserClass));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Generate the ACEs from the default user SD
        //
        hr = DsrAccessInfoGenerateUserAces(pInfo);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Create ace applications for all of the nt4
        // aces
        hr = DsrAceAppFromAppDesc(
                g_pAcesNt4,
                sizeof(g_pAcesNt4) / sizeof(*g_pAcesNt4),
                pDomContainer,
                pDomain,
                &(pInfo->pAcesNt4),
                &(pInfo->dwAceCountNt4));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Create ace applications for all of the w2k
        // aces
        hr = DsrAceAppFromAppDesc(
                g_pAcesW2k,
                sizeof(g_pAcesW2k) / sizeof(*g_pAcesW2k),
                pDomContainer,
                pDomain,
                &(pInfo->pAcesW2k),
                &(pInfo->dwAceCountW2k));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return value
        *ppInfo = pInfo;

    } while (FALSE);

    // Cleanup
    //
    {
        DSR_RELEASE(pDomain);
        DSR_RELEASE(pDomContainer);
        DSR_RELEASE(pSchemaContainer);
        DSR_RELEASE(pDispatch);
        if (FAILED (hr))
        {
            DsrAccessInfoCleanup(pInfo);
        }
        if (pDomainInfo)
        {
            NetApiBufferFree(pDomainInfo);
        }
    }

    return hr;
}

//
// Discovers the access mode of the domain currently.
//
// Assumes COM is initialized
//
HRESULT
DsrDomainQueryAccessEx(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;
    BOOL bOk = FALSE;

    if (lpdwAccessFlags == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        // Initialize
        //
        *lpdwAccessFlags = 0;
        
        // Read in the info that tells us what ACE's
        // need to be set.
        //
        hr = DsrAccessInfoInit(
                pszDomain, 
                &pInfo);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Check for nt4 level access
        //
        bOk = FALSE;
        hr = DsrAceAppQueryPresence(
                pInfo->pszDC,
                pInfo->pAcesNt4,
                pInfo->dwAceCountNt4,
                &bOk);
        DSR_BREAK_ON_FAILED_HR(hr);

        // If we don't have nt4 access, we have no access
        //
        if (bOk == FALSE)
        {
            *lpdwAccessFlags = 0;
            break;
        }
        *lpdwAccessFlags |= MPRFLAG_DOMAIN_NT4_SERVERS;

        // Check for w2k level access
        //
        bOk = FALSE;
        hr = DsrAceAppQueryPresence(
                pInfo->pszDC,
                pInfo->pAcesW2k,
                pInfo->dwAceCountW2k,
                &bOk);
        DSR_BREAK_ON_FAILED_HR(hr);

        // If we don't have w2k access, no need to proceed
        //
        if (bOk == FALSE)
        {
            break;
        }
        *lpdwAccessFlags |= MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS;

    } while (FALSE);

    // Cleanup
    {
        if (FAILED(hr))
        {
            if (pInfo)
            {
                DsrAccessInfoCleanup(pInfo);
            }
        }
        else
        {
            *ppInfo = pInfo;
        }
    }

    return hr;
}

//
// Returns the access level of the given domain
//
DWORD
DsrDomainQueryAccess(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Initialize
        hr = DsrComIntialize();
        DSR_BREAK_ON_FAILED_HR( hr );

        // Query the access
        hr = DsrDomainQueryAccessEx(
                pszDomain,
                lpdwAccessFlags,
                &pInfo);
        DSR_BREAK_ON_FAILED_HR(hr);
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            DsrAccessInfoCleanup(pInfo);
        }

        DsrComUninitialize();
    }

    return DSR_ERROR(hr);
}

//
// Sets the ACES in the given domain to enable nt4 servers
//
DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;
    BOOL bClean = TRUE;
    DWORD dwCurAccess = 0;

    do
    {
        // Initialize 
        hr = DsrComIntialize();
        DSR_BREAK_ON_FAILED_HR( hr );

        DsrTraceEx(
            0, 
            "DsrDomainSetAccess: Req: %x", 
            dwAccessFlags);
            
        // W2k mode always implies nt4 mode as well
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
        {
            dwAccessFlags |= MPRFLAG_DOMAIN_NT4_SERVERS;
        }

        // Discover the current access on the domain and 
        // initialize the info we need
        //
        hr = DsrDomainQueryAccessEx(
                pszDomain,
                &dwCurAccess,
                &pInfo);
        DSR_BREAK_ON_FAILED_HR(hr);

        DsrTraceEx(
            0, 
            "DsrDomainSetAccess: Cur: %x", 
            dwCurAccess);

        // Remove all appropriate aces if the requested access
        // is none.
        if (dwAccessFlags == 0)
        {
            // Remove the nt4 mode aces if needed
            //
            if (dwCurAccess & MPRFLAG_DOMAIN_NT4_SERVERS)
            {
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesUser,
                        pInfo->dwAceCountUser);
                DSR_BREAK_ON_FAILED_HR(hr);
                
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesNt4,
                        pInfo->dwAceCountNt4);
                DSR_BREAK_ON_FAILED_HR(hr);
            }

            // Remove the w2k mode aces if needed
            //
            if (dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
            {
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesW2k,
                        pInfo->dwAceCountW2k);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }

        // Set nt4 mode if needed
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_NT4_SERVERS)
        {
            // Remove w2k level access if needed
            //
            if ((!(dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)) &&
                (dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS))
            {
                hr = DsrAceAppRemove(
                        pInfo->pszDC,
                        pInfo->pAcesW2k,
                        pInfo->dwAceCountW2k);
                DSR_BREAK_ON_FAILED_HR(hr);
            }

            // Add nt4 level access if needed
            //
            if (! (dwCurAccess & MPRFLAG_DOMAIN_NT4_SERVERS))
            {
                hr = DsrAceAppAdd(
                        pInfo->pszDC,
                        pInfo->pAcesUser,
                        pInfo->dwAceCountUser);
                DSR_BREAK_ON_FAILED_HR(hr);
            
                hr = DsrAceAppAdd(
                        pInfo->pszDC,
                        pInfo->pAcesNt4,
                        pInfo->dwAceCountNt4);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }

        // Set w2k mode if needed
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
        {
            if (!(dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS))
            {
                hr = DsrAceAppAdd(
                        pInfo->pszDC,
                        pInfo->pAcesW2k,
                        pInfo->dwAceCountW2k);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            DsrAccessInfoCleanup(pInfo);
        }
        
        DsrComUninitialize();
    }

    return DSR_ERROR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\inc\uimsgs.h ===
/********************************************************************/
/**               Copyright(c) 1992 Microsoft Corporation.	       **/
/********************************************************************/
//Jameel: please check all these, especially those that have comments to you.
//***
//
// Filename:	srvmsg.h
//
// Description: Text and corresponding values of AFP Server events are
//              defined here.
//
// History: 	Nov 23,1992.	SueA		Created original version.
//				Jan 28,1993.	SueA		Logging now done from user mode
//											so %1 is no longer \Device\AfpSrv
//


// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define AFPMACFILE_MSG_BASE					6000

#define AFPMACFILEMSG_InvalidVolumeName		(AFPMACFILE_MSG_BASE+1)
/*
 * The Macintosh-Accessible volume name specified is invalid.
 * Specify a valid volume name without colons.
 */

#define AFPMACFILEMSG_InvalidId		(AFPMACFILE_MSG_BASE+2)
/*
 * A system resource could not be accessed for the current descriptor.
 * Try the operation again.
 */

#define AFPMACFILEMSG_InvalidParms		(AFPMACFILE_MSG_BASE+3)
/*
 * The parameter entered was invalid. 
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_CodePage		(AFPMACFILE_MSG_BASE+4)
/*
 * Error in accessing Macintosh Code Page.
 * Check if the Code Page file name specified in
 * SYSTEM\CurrentControlSet\Control\Nls\CodePage\MACCP is valid and exists.
 * Stop and restart the service if the code page information is modified.
 */

#define AFPMACFILEMSG_InvalidServerName		(AFPMACFILE_MSG_BASE+5)
/*
 * The server name specified is invalid.
 * Specify a valid server name without colons.
 */

#define AFPMACFILEMSG_DuplicateVolume		(AFPMACFILE_MSG_BASE+6)
/*
 * A volume with this name already exists.
 * Specify another name for the new volume.
 */

#define AFPMACFILEMSG_VolumeBusy		(AFPMACFILE_MSG_BASE+7)
/*
 * The selected Macintosh-Accessible volume is currently in use by Macintoshes.
 * The selected volume may be removed only when no Macintosh workstations are
 * connected to it.
 */

#define AFPMACFILEMSG_VolumeReadOnly		(AFPMACFILE_MSG_BASE+8)
/*
 * Not used
 * An internal error 6008 (VolumeReadOnly) occurred.
 */

#define AFPMACFILEMSG_DirectoryNotInVolume		(AFPMACFILE_MSG_BASE+9)
/*
 * The selected directory does not belong to a Macintosh-Accessible volume.
 * The Macintosh view of directory permissions is only available for
 * directories that are part of a Macintosh-Accessible volume.
 */

#define AFPMACFILEMSG_SecurityNotSupported		(AFPMACFILE_MSG_BASE+10)
/*
 * The Macintosh view of directory permissions is not available for directories
 * on CD-ROM disks.
 */

#define AFPMACFILEMSG_BufferSize		(AFPMACFILE_MSG_BASE+11)
/*
 * Insufficient memory resources to complete the operation.
 * Try the operation again.
 */

#define AFPMACFILEMSG_DuplicateExtension		(AFPMACFILE_MSG_BASE+12)
/*
 * This file extension is already associated with a Creator/Type item.
 */

#define AFPMACFILEMSG_UnsupportedFS		(AFPMACFILE_MSG_BASE+13)
/*
 * File Server for Macintosh service only supports NTFS partitions.
 * Choose a directory on an NTFS partition.
 */

#define AFPMACFILEMSG_InvalidSessionType		(AFPMACFILE_MSG_BASE+14)
/*
 * The message has been sent, but not all of the connected workstations have
 * received it. Some workstations are running an unsupported version of
 * system software.
 */

#define AFPMACFILEMSG_InvalidServerState		(AFPMACFILE_MSG_BASE+15)
/*
 * The File Server is in an invalid state for the operation being performed.
 * Check the status of the File Server for Macintosh service and retry the 
 * operation.
 */

#define AFPMACFILEMSG_NestedVolume		(AFPMACFILE_MSG_BASE+16)
/*
 * Cannot create a Macintosh-Accessible volume within another volume.
 * Choose a directory that is not within a volume.
 */

#define AFPMACFILEMSG_InvalidComputername		(AFPMACFILE_MSG_BASE+17)
/*
 * The target server is not setup to accept Remote Procedure Calls.
 */

#define AFPMACFILEMSG_DuplicateTypeCreator		(AFPMACFILE_MSG_BASE+18)
/*
 * The selected Creator/Type item already exists.
 */

#define AFPMACFILEMSG_TypeCreatorNotExistant		(AFPMACFILE_MSG_BASE+19)
/*
 * The selected Creator/Type item no longer exists.
 * This item may have been deleted by another administrator.
 */

#define AFPMACFILEMSG_CannotDeleteDefaultTC		(AFPMACFILE_MSG_BASE+20)
/*
 * The default Creator/Type item cannot be deleted.
 */

#define AFPMACFILEMSG_CannotEditDefaultTC		(AFPMACFILE_MSG_BASE+21)
/*
 * The default Creator/Type item may not be edited.
 */

#define AFPMACFILEMSG_InvalidTypeCreator		(AFPMACFILE_MSG_BASE+22)
/*
 * The Creator/Type item is invalid and will not be use by the File Server
 * for Macintosh service.
 * The invalid Creator/Type item is in the data.
 */

#define AFPMACFILEMSG_InvalidExtension		(AFPMACFILE_MSG_BASE+23)
/*
 * The file extension is invalid.
 * The invalid file extension is in the data.
 */

#define AFPMACFILEMSG_TooManyEtcMaps		(AFPMACFILE_MSG_BASE+24)
/*
 * Too many Extension/Type Creator mappings than the system can handle.
 * System limit is 2147483647 mappings.
 */

#define AFPMACFILEMSG_InvalidPassword		(AFPMACFILE_MSG_BASE+25)
/*
 * The password specified is invalid.
 * Specify a valid password less than 8 characters.
 */

#define AFPMACFILEMSG_VolumeNonExist		(AFPMACFILE_MSG_BASE+26)
/*
 * The selected Macintosh-Accessible volume no longer exists.
 * Another administrator may have removed the selected volume.
 */

#define AFPMACFILEMSG_NoSuchUserGroup		(AFPMACFILE_MSG_BASE+27)
/*
 * Neither the Owner nor the Primary Group account names are valid.
 * Specify valid account names for the Owner and Primary Group of
 * this directory.
 */

#define AFPMACFILEMSG_NoSuchUser		(AFPMACFILE_MSG_BASE+28)
/*
 * The Owner account name is invalid. 
 * Specify a valid account name or the Owner of this directory.
 */

#define AFPMACFILEMSG_NoSuchGroup		(AFPMACFILE_MSG_BASE+29)
/*
 * The Primary Group account name is invalid. 
 * Specify a valid account name for the Primary Group of this directory.
 */

#define AFPMACFILEMSG_InvalidParms_LoginMsg		(AFPMACFILE_MSG_BASE+30)
/*
 * The Logon Message entered for the File Server for Macintosh was invalid. 
 * Logon Message should not be greater than 199 characters.
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_InvalidParms_MaxVolUses	(AFPMACFILE_MSG_BASE+31)
/*
 * The User Limit entered for the Share Volume was invalid. 
 * Enter a number between 0 and 4294967295.
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_InvalidParms_MaxSessions	(AFPMACFILE_MSG_BASE+32)
/*
 * The Sessions Limit field entered for the File Server was invalid. 
 * Enter a number between 0 and 4294967295.
 * Make the appropriate changes and retry the operation.
 */

#define AFPMACFILEMSG_InvalidServerName_Length		(AFPMACFILE_MSG_BASE+33)
/*
 * The server name specified is not of valid length.
 * Specify a server name containing not more than 31 single-byte characters 
 * or not more than 15 double-byte characters.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\inc\admin.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

    admin.h

Abstract:

    This module contains admin interface for server service. All data
    strucutures anc constants shared between the AFP service and the
    AFP server service will be contained in this file.

Author:

    Jameel Hyder (microsoft!jameelh)


Revision History:
    25 Apr  1992 JameelH    Initial Version
    2  Sept 1992 NarenG     Added structure to pass security information
                            between the service and the server.
    1  Feb  1993 SueA       Added structure to pass evenlog infomation
                            from the server to the service.
--*/

#ifndef _ADMIN_
#define _ADMIN_

#include <lmcons.h>     // Need DNLEN and LM20_UNLEN
#include <crypt.h>      // Need LM_OWF_PASSWORD_LENGTH
#include <ntsam.h>
#include <ntsamp.h>
#include <nbtioctl.h>   // DNS_MAX_NAME_LENGTH

#define AFP_API_BASE    1000

#define AFP_CC(_request_, _Method_)     CTL_CODE(FILE_DEVICE_NETWORK, \
                            _request_ + AFP_API_BASE,                 \
                            _Method_, FILE_ANY_ACCESS)

#define AFP_CC_BASE(ControlCode)    ((((ControlCode) >> 2) - AFP_API_BASE) & 0xFF)
#define AFP_CC_METHOD(ControlCode)  ((ControlCode) & 0x03)

// Do not change this table without also changing the table in SERVER\FSD.C
#define CC_BASE_SERVICE_START               0x01
#define CC_BASE_SERVICE_STOP                0x02
#define CC_BASE_SERVICE_PAUSE               0x03
#define CC_BASE_SERVICE_CONTINUE            0x04
#define CC_BASE_GET_STATISTICS              0x05
#define CC_BASE_GET_STATISTICS_EX           0x06
#define CC_BASE_CLEAR_STATISTICS            0x07
#define CC_BASE_GET_PROF_COUNTERS           0x08
#define CC_BASE_CLEAR_PROF_COUNTERS         0x09
#define CC_BASE_SERVER_ADD_SID_OFFSETS      0x0A
#define CC_BASE_SERVER_GET_INFO             0x0B
#define CC_BASE_SERVER_SET_INFO             0x0C
#define CC_BASE_SERVER_ADD_ETC              0x0D
#define CC_BASE_SERVER_SET_ETC              0x0E
#define CC_BASE_SERVER_DELETE_ETC           0x0F
#define CC_BASE_SERVER_ADD_ICON             0x10
#define CC_BASE_VOLUME_ADD                  0x11
#define CC_BASE_VOLUME_DELETE               0x12
#define CC_BASE_VOLUME_GET_INFO             0x13
#define CC_BASE_VOLUME_SET_INFO             0x14
#define CC_BASE_VOLUME_ENUM                 0x15
#define CC_BASE_SESSION_ENUM                0x16
#define CC_BASE_SESSION_CLOSE               0x17
#define CC_BASE_CONNECTION_ENUM             0x18
#define CC_BASE_CONNECTION_CLOSE            0x19
#define CC_BASE_DIRECTORY_GET_INFO          0x1A
#define CC_BASE_DIRECTORY_SET_INFO          0x1B
#define CC_BASE_FORK_ENUM                   0x1C
#define CC_BASE_FORK_CLOSE                  0x1D
#define CC_BASE_MESSAGE_SEND                0x1E
#define CC_BASE_FINDER_SET                  0x1F
#define CC_BASE_GET_FSD_COMMAND             0x20
#define CC_BASE_MAX                         0x21


#define OP_SERVICE_START            AFP_CC(CC_BASE_SERVICE_START, METHOD_BUFFERED)
#define OP_SERVICE_STOP             AFP_CC(CC_BASE_SERVICE_STOP, METHOD_BUFFERED)
#define OP_SERVICE_PAUSE            AFP_CC(CC_BASE_SERVICE_PAUSE, METHOD_BUFFERED)
#define OP_SERVICE_CONTINUE         AFP_CC(CC_BASE_SERVICE_CONTINUE,METHOD_BUFFERED)
#define OP_GET_STATISTICS           AFP_CC(CC_BASE_GET_STATISTICS,METHOD_IN_DIRECT)
#define OP_GET_STATISTICS_EX        AFP_CC(CC_BASE_GET_STATISTICS_EX,METHOD_IN_DIRECT)
#define OP_CLEAR_STATISTICS         AFP_CC(CC_BASE_CLEAR_STATISTICS,METHOD_BUFFERED)
#define OP_GET_PROF_COUNTERS        AFP_CC(CC_BASE_GET_PROF_COUNTERS,METHOD_IN_DIRECT)
#define OP_CLEAR_PROF_COUNTERS      AFP_CC(CC_BASE_CLEAR_PROF_COUNTERS,METHOD_BUFFERED)
#define OP_SERVER_ADD_SID_OFFSETS   AFP_CC(CC_BASE_SERVER_ADD_SID_OFFSETS,METHOD_BUFFERED)
#define OP_SERVER_GET_INFO          AFP_CC(CC_BASE_SERVER_GET_INFO,METHOD_IN_DIRECT)
#define OP_SERVER_SET_INFO          AFP_CC(CC_BASE_SERVER_SET_INFO,METHOD_BUFFERED)
#define OP_SERVER_ADD_ETC           AFP_CC(CC_BASE_SERVER_ADD_ETC,METHOD_BUFFERED)
#define OP_SERVER_SET_ETC           AFP_CC(CC_BASE_SERVER_SET_ETC,METHOD_BUFFERED)
#define OP_SERVER_DELETE_ETC        AFP_CC(CC_BASE_SERVER_DELETE_ETC,METHOD_BUFFERED)
#define OP_SERVER_ADD_ICON          AFP_CC(CC_BASE_SERVER_ADD_ICON,METHOD_BUFFERED)
#define OP_VOLUME_ADD               AFP_CC(CC_BASE_VOLUME_ADD,METHOD_BUFFERED)
#define OP_VOLUME_DELETE            AFP_CC(CC_BASE_VOLUME_DELETE,METHOD_BUFFERED)
#define OP_VOLUME_GET_INFO          AFP_CC(CC_BASE_VOLUME_GET_INFO,METHOD_IN_DIRECT)
#define OP_VOLUME_SET_INFO          AFP_CC(CC_BASE_VOLUME_SET_INFO,METHOD_BUFFERED)
#define OP_VOLUME_ENUM              AFP_CC(CC_BASE_VOLUME_ENUM,METHOD_IN_DIRECT)
#define OP_SESSION_ENUM             AFP_CC(CC_BASE_SESSION_ENUM,METHOD_IN_DIRECT)
#define OP_SESSION_CLOSE            AFP_CC(CC_BASE_SESSION_CLOSE,METHOD_BUFFERED)
#define OP_CONNECTION_ENUM          AFP_CC(CC_BASE_CONNECTION_ENUM,METHOD_IN_DIRECT)
#define OP_CONNECTION_CLOSE         AFP_CC(CC_BASE_CONNECTION_CLOSE,METHOD_BUFFERED)
#define OP_DIRECTORY_GET_INFO       AFP_CC(CC_BASE_DIRECTORY_GET_INFO,METHOD_IN_DIRECT)
#define OP_DIRECTORY_SET_INFO       AFP_CC(CC_BASE_DIRECTORY_SET_INFO,METHOD_BUFFERED)
#define OP_FORK_ENUM                AFP_CC(CC_BASE_FORK_ENUM,METHOD_IN_DIRECT)
#define OP_FORK_CLOSE               AFP_CC(CC_BASE_FORK_CLOSE,METHOD_BUFFERED)
#define OP_MESSAGE_SEND             AFP_CC(CC_BASE_MESSAGE_SEND,METHOD_BUFFERED)
#define OP_FINDER_SET               AFP_CC(CC_BASE_FINDER_SET,METHOD_BUFFERED)
#define OP_GET_FSD_COMMAND          AFP_CC(CC_BASE_GET_FSD_COMMAND,METHOD_BUFFERED)

#define POINTER_TO_OFFSET(val,start)               \
    (val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) - (ULONG_PTR)(start) )

#define OFFSET_TO_POINTER(val,start)               \
    (val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) + (ULONG_PTR)(start) )

#define AFPSERVER_DEVICE_NAME       TEXT("\\Device\\MacFile")
#define AFPSERVER_REGISTRY_KEY      TEXT("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MacSrv")
#define AFPSERVER_VOLUME_ICON_FILE  { L'I', L'C', L'O', L'N', 0xF00D, 0000 }

// Number of wchars in above string, including terminating null
#define AFPSERVER_VOLUME_ICON_FILE_SIZE 6
#define AFPSERVER_RESOURCE_STREAM   L":AFP_Resource"

// The following data structures are used exclusively by the
// user-mode/kernel-mode interface.

typedef enum _AFP_SID_TYPE
{
    AFP_SID_TYPE_DOMAIN,
    AFP_SID_TYPE_PRIMARY_DOMAIN,
    AFP_SID_TYPE_WELL_KNOWN,
    AFP_SID_TYPE_LOGON

} AFP_SID_TYPE;

typedef struct _AFP_SID_OFFSET
{
    DWORD               Offset;
    AFP_SID_TYPE        SidType;
    PBYTE               pSid;           // Actually an Offset from the
                                        // beginning of this structure.
} AFP_SID_OFFSET, *PAFP_SID_OFFSET;

// Packet used to add the SID/OFFSET pairs
typedef struct _AFP_SID_OFFSET_DESC
{
    ULONG               CountOfSidOffsets;  // Number of Sid-Offset pairs
    ULONG               QuadAlignDummy1;
    AFP_SID_OFFSET      SidOffsetPairs[1];
}AFP_SID_OFFSET_DESC, *PAFP_SID_OFFSET_DESC;

// Packet used by ServerEtcSet and ServerEtcDelete.
typedef struct _EtcMapInfo2
{
    UCHAR   etc_type[AFP_TYPE_LEN];
    UCHAR   etc_creator[AFP_CREATOR_LEN];
    WCHAR   etc_extension[AFP_EXTENSION_LEN+1];

} ETCMAPINFO2, *PETCMAPINFO2;

// once passed by Service, this is used by Server internally
typedef struct _EtcMapInfo
{
    UCHAR   etc_type[AFP_TYPE_LEN];
    UCHAR   etc_creator[AFP_CREATOR_LEN];
    UCHAR   etc_extension[AFP_EXTENSION_LEN+1];   // extension in ANSI

} ETCMAPINFO, *PETCMAPINFO;

typedef struct _SrvIconInfo
{
    UCHAR   icon_type[AFP_TYPE_LEN];
    UCHAR   icon_creator[AFP_CREATOR_LEN];
    DWORD   icon_icontype;
    DWORD   icon_length;

    // Icon data follows
} SRVICONINFO, *PSRVICONINFO;

// Packet used by ServerEtcAdd.
typedef struct _ServerEtcPacket
{
    DWORD       retc_NumEtcMaps;    // Number of type creator mappings
    ETCMAPINFO2 retc_EtcMaps[1];    // List of Etc mappings

} SRVETCPKT, *PSRVETCPKT;


// The following is the generic enumerate request packet.
typedef struct _EnumRequestPacket
{
    DWORD   erqp_Index;             // Starting index from which the
                                    // enum should start. 0 => beginning
    DWORD   erqp_Filter;            // AFP_FILTER_ON_VOLUME_ID
                                    // or AFP_FILTER_ON_SESSION_ID
    DWORD   erqp_ID;                // Volume ID or sessions ID.

    DWORD   QuadAlignDummy;         // Quad Word Alignment enforcement

} ENUMREQPKT, *PENUMREQPKT;


// The following is the generic enumerate response packet.

typedef struct _EnumResponsePacket
{
    DWORD   ersp_cTotEnts;          // Total number of available entries
    DWORD   ersp_cInBuf;            // Number of entries in buffer union
    DWORD   ersp_hResume;           // Index of the first entry that will be
                                    // read on the subsequent call. Valid only
                                    // if the return code is AFPERR_MORE_DATA.

    DWORD   QuadAlignDummy;         // Quad Word Alignment enforcement

    // Will contain an array of AFP_FILE_INFO, AFP_SESSION_INFO,
    // AFP_CONNECTION_INFO or AFP_VOLUME_INFO structures.
} ENUMRESPPKT, *PENUMRESPPKT;

// The following is the generic set info. request packet.
typedef struct _SetInfoRequestPacket
{
    DWORD   sirqp_parmnum;          // Mask of bits representing fields
    DWORD   dwAlignDummy;           // For QWORD alignment

    // Will be followed by AFP_VOLUME_INFO or AFP_DIRECTORY_INFO structure
} SETINFOREQPKT, *PSETINFOREQPKT;

// The following data structures are used to send security information
// from the service down to the server; or to send eventlog information from
// the server up to the service.

#define MAX_FSD_CMD_SIZE                4096
#define NUM_SECURITY_UTILITY_THREADS    4

typedef enum _AFP_FSD_CMD_ID
{
    AFP_FSD_CMD_NAME_TO_SID,
    AFP_FSD_CMD_SID_TO_NAME,
    AFP_FSD_CMD_CHANGE_PASSWORD,
    AFP_FSD_CMD_LOG_EVENT,
    AFP_FSD_CMD_TERMINATE_THREAD
} AFP_FSD_CMD_ID;


// These used to live in afpconst.h, but now the service needs some of these
// to do the native AppleUam stuff
//
// UAMs strings and values
#define AFP_NUM_UAMS                7
#define NO_USER_AUTHENT             0
#define NO_USER_AUTHENT_NAME        "No User Authent"
#define CLEAR_TEXT_AUTHENT          1
#define CLEAR_TEXT_AUTHENT_NAME     "ClearTxt Passwrd"
#define CUSTOM_UAM_V1               2
#define CUSTOM_UAM_NAME_V1          "Microsoft V1.0"
#define CUSTOM_UAM_V2               3
#define CUSTOM_UAM_NAME_V2          "MS2.0"
#define CUSTOM_UAM_V3               4
#define CUSTOM_UAM_NAME_V3          "MS3.0"
#define RANDNUM_EXCHANGE            5
#define RANDNUM_EXCHANGE_NAME       "Randnum Exchange"
#define TWOWAY_EXCHANGE             6
#define TWOWAY_EXCHANGE_NAME        "2-Way Randnum exchange"

// how many bytes of response comes back
#define RANDNUM_RESP_LEN            8
#define TWOWAY_RESP_LEN             16

// this define stolen from ntsam.h
#define SAM_MAX_PASSWORD_LENGTH     (256)

#define  SFM_CHANGE_PASSWORD_SIGNATURE "ChP" // 4 bytes including NULL

typedef struct _SFM_PASSWORD_CHANGE_MESSAGE_HEADER
{
    UCHAR Signature[sizeof(SFM_CHANGE_PASSWORD_SIGNATURE)];
    ULONG cbMessage;
    ULONG Version;
} SFM_PASSWORD_CHANGE_MESSAGE_HEADER, * PSFM_PASSWORD_CHANGE_MESSAGE_HEADER;

typedef struct _SFM_PASSWORD_CHANGE_MESSAGE_1_SHORT
{
    UCHAR Signature[sizeof(SFM_CHANGE_PASSWORD_SIGNATURE)];
    ULONG cbMessage;   // sizeof(SFM_PASSWORD_CHANGE_MESSAGE_1_SHORT) including signature
    ULONG Version;     // version 1 without LM
    UCHAR NewPasswordEncryptedWithOldNt[sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) / 2];
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt;
} SFM_PASSWORD_CHANGE_MESSAGE_1_SHORT, * PSFM_PASSWORD_CHANGE_MESSAGE_1_SHORT;

typedef struct _SFM_PASSWORD_CHANGE_MESSAGE_1
{
    UCHAR Signature[sizeof(SFM_CHANGE_PASSWORD_SIGNATURE)];
    ULONG cbMessage;   // sizeof(SFM_PASSWORD_CHANGE_MESSAGE_1) including signature
    ULONG Version;     // version 1 without LM
    SAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt;
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt;
} SFM_PASSWORD_CHANGE_MESSAGE_1, * PSFM_PASSWORD_CHANGE_MESSAGE_1;

typedef struct _SFM_PASSWORD_CHANGE_MESSAGE_2
{
    UCHAR Signature[sizeof(SFM_CHANGE_PASSWORD_SIGNATURE)];
    ULONG cbMessage;   // sizeof(SFM_PASSWORD_CHANGE_MESSAGE_2) including signature
    ULONG Version;     // version 2 with LM
    SAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt;
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt;
    SAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm;
    ENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt;
} SFM_PASSWORD_CHANGE_MESSAGE_2, * PSFM_PASSWORD_CHANGE_MESSAGE_2;

typedef struct _SFM_PASSWORD_CHANGE_MESSAGE
{
    union
    {
        SFM_PASSWORD_CHANGE_MESSAGE_HEADER h;
        SFM_PASSWORD_CHANGE_MESSAGE_1 m1;
        SFM_PASSWORD_CHANGE_MESSAGE_2 m2;
    };
} SFM_PASSWORD_CHANGE_MESSAGE, * PSFM_PASSWORD_CHANGE_MESSAGE;

typedef struct _AFP_PASSWORD_CHANGE_NT
{
    SFM_PASSWORD_CHANGE_MESSAGE Ciphers;
} AFP_PASSWORD_CHANGE_NT, * PAFP_PASSWORD_CHANGE_NT;

typedef struct _AFP_PASSWORD_DESC
{
    ULONG        AuthentMode;
    union
    {
        AFP_PASSWORD_CHANGE_NT NtEncryptedBuff;
        struct _AFP_PASSWORD_BUFF_LM
        {
            BYTE        OldPassword[LM_OWF_PASSWORD_LENGTH + 2];
            BYTE        NewPassword[(SAM_MAX_PASSWORD_LENGTH * 2) + 4];
            DWORD       OldPasswordLen;
            DWORD       NewPasswordLen;
            BYTE        bPasswordLength;
        };
    };

    //
    // allow longer names in NTLMv2
    //

    WCHAR DomainName[DNS_MAX_NAME_LENGTH + 4]; // allow DNS name
    WCHAR UserName[UNLEN + 1];

    #if 0
    WCHAR       DomainName[DNLEN + 1];
    WCHAR       UserName[LM20_UNLEN + 1];
    #endif 0
} AFP_PASSWORD_DESC, *PAFP_PASSWORD_DESC;

typedef struct _AFP_EVENTLOG_DESC
{
    DWORD                   MsgID;
    USHORT                  EventType;
    USHORT                  StringCount;
    DWORD                   DumpDataLen;
    DWORD                   QuadAlignDummy; // Quad Word Alignment enforcement
    PVOID                   pDumpData;
    LPWSTR *                ppStrings;
    // Pointer to an array of string pointers that will follow the DumpData.
} AFP_EVENTLOG_DESC, *PAFP_EVENTLOG_DESC;

typedef struct _AFP_FSD_CMD_HEADER
{
    AFP_FSD_CMD_ID          FsdCommand;
    ULONG                   ntStatus;
    DWORD                   dwId;
    DWORD                   QuadAlignDummy; // Quad Word Alignment enforcement
} AFP_FSD_CMD_HEADER, *PAFP_FSD_CMD_HEADER;

typedef struct _AFP_FSD_CMD_PKT
{
    AFP_FSD_CMD_HEADER          Header;

    union
    {
        BYTE                Sid[1];
        BYTE                Name[1];
        AFP_PASSWORD_DESC   Password;
        AFP_EVENTLOG_DESC   Eventlog;
    } Data;
} AFP_FSD_CMD_PKT, *PAFP_FSD_CMD_PKT;


// The following definitions and macros are used both by the service as well as the
// server. DO NOT CHANGE THIS w/o LOOKING at both the uses.

// Directory Access Permissions
#define DIR_ACCESS_SEARCH           0x01    // See Folders
#define DIR_ACCESS_READ             0x02    // See Files
#define DIR_ACCESS_WRITE            0x04    // Make Changes
#define DIR_ACCESS_OWNER            0x80    // Only for user
                                            // if he has owner rights

#define DIR_ACCESS_ALL              (DIR_ACCESS_READ    | \
                                     DIR_ACCESS_SEARCH  | \
                                     DIR_ACCESS_WRITE)

#define OWNER_RIGHTS_SHIFT          0
#define GROUP_RIGHTS_SHIFT          8
#define WORLD_RIGHTS_SHIFT          16
#define USER_RIGHTS_SHIFT           24

#define AFP_READ_ACCESS     (READ_CONTROL        |  \
                            FILE_READ_ATTRIBUTES |  \
                            FILE_TRAVERSE        |  \
                            FILE_LIST_DIRECTORY  |  \
                            FILE_READ_EA)

#define AFP_WRITE_ACCESS    (FILE_ADD_FILE       |  \
                            FILE_ADD_SUBDIRECTORY|  \
                            FILE_WRITE_ATTRIBUTES|  \
                            FILE_WRITE_EA        |  \
                            DELETE)

#define AFP_OWNER_ACCESS    (WRITE_DAC            | \
                             WRITE_OWNER)

#define AFP_MIN_ACCESS      (FILE_READ_ATTRIBUTES | \
                             READ_CONTROL)

#define AfpAccessMaskToAfpPermissions(Rights, Mask, Type)                   \
                if ((Type) == ACCESS_ALLOWED_ACE_TYPE)                      \
                {                                                           \
                    if (((Mask) & AFP_READ_ACCESS) == AFP_READ_ACCESS)      \
                         (Rights) |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH); \
                    if (((Mask) & AFP_WRITE_ACCESS) == AFP_WRITE_ACCESS)    \
                        (Rights) |= DIR_ACCESS_WRITE;                       \
                }                                                           \
                else                                                        \
                {                                                           \
                    ASSERT((Type) == ACCESS_DENIED_ACE_TYPE);               \
                    if ((Mask) & AFP_READ_ACCESS)                           \
                        (Rights) &= ~(DIR_ACCESS_READ | DIR_ACCESS_SEARCH); \
                    if ((Mask) & AFP_WRITE_ACCESS)                          \
                        (Rights) &= ~DIR_ACCESS_WRITE;                      \
                }

#endif  // _ADMIN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\messages\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\messages\makefile.inc ===
$(O)\afpmsg.mc: ..\inc\events.h ..\inc\srvmsg.h
    mapmsg AFP AFP_LOG_BASE ..\inc\events.h > $(O)\afpmsg.mc
    mapmsg -a $(O)\afpmsg.mc AFP AFPSRV_MSG_BASE ..\inc\srvmsg.h
    mapmsg -a $(O)\afpmsg.mc AFP AFPMACFILE_MSG_BASE ..\inc\uimsgs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\access.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	access.h

Abstract:

	This module contains prototypes for access related routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	20 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _ACCESS_
#define _ACCESS_

#define	AFP_READ_ACCESS		(READ_CONTROL		 |	\
							FILE_READ_ATTRIBUTES |	\
							FILE_TRAVERSE		 |	\
							FILE_LIST_DIRECTORY	 |	\
							FILE_READ_EA)

#define	AFP_WRITE_ACCESS	(FILE_ADD_FILE		 |	\
							FILE_ADD_SUBDIRECTORY|	\
							FILE_WRITE_ATTRIBUTES|	\
							FILE_WRITE_EA		 |	\
							DELETE)

#define	AFP_OWNER_ACCESS	(WRITE_DAC			  | \
							 WRITE_OWNER)

#define	AFP_MIN_ACCESS		(FILE_READ_ATTRIBUTES | \
							 READ_CONTROL)


#ifdef	i386
#pragma warning(disable:4010)
#endif

GLOBAL	SID		AfpSidWorld			EQU	\
			{ 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
GLOBAL	SID		AfpSidSystem		EQU	\
			{ 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
GLOBAL	SID		AfpSidNull			EQU	\
			{ 1, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };

GLOBAL	SID		AfpSidBuiltIn		EQU \
			{ 1, 1, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID };
GLOBAL	PSID	AfpSidAdmins		EQU NULL;
GLOBAL	LONG	AfpSizeSidAdmins	EQU	0;
GLOBAL  PSID	AfpSidNone			EQU NULL;
GLOBAL  LONG	AfpSizeSidNone		EQU 0;

#ifdef 	OPTIMIZE_GUEST_LOGONS

#ifdef	INHERIT_DIRECTORY_PERMS
GLOBAL	DWORD	AfpIdWorld			EQU 0;
#else
GLOBAL	PISECURITY_DESCRIPTOR		AfpGuestSecDesc EQU NULL;
#endif

#endif

#define	AfpAccessMask2AfpPermissions(Rights, Mask, Type)					\
				if ((Type) == ACCESS_ALLOWED_ACE_TYPE)						\
				{															\
					if (((Mask) & AFP_READ_ACCESS) == AFP_READ_ACCESS)		\
						 (Rights) |= (DIR_ACCESS_READ | DIR_ACCESS_SEARCH);	\
					if (((Mask) & AFP_WRITE_ACCESS) == AFP_WRITE_ACCESS)	\
						(Rights) |= DIR_ACCESS_WRITE;						\
					if (((Mask) & AFP_OWNER_ACCESS) == AFP_OWNER_ACCESS)	\
						(Rights) |= DIR_ACCESS_OWNER;						\
				}															\
				else														\
				{															\
					ASSERT((Type) == ACCESS_DENIED_ACE_TYPE);				\
					if ((Mask) & AFP_READ_ACCESS)							\
						(Rights) &= ~(DIR_ACCESS_READ | DIR_ACCESS_SEARCH); \
					if ((Mask) & AFP_WRITE_ACCESS)							\
						(Rights) &= ~DIR_ACCESS_WRITE;						\
					if ((Mask) & AFP_OWNER_ACCESS)							\
						(Rights) &= ~DIR_ACCESS_OWNER;						\
				}

extern
NTSTATUS
AfpGetUserAndPrimaryGroupSids(
	IN	PSDA						pSda
);


extern
AFPSTATUS
AfpMakeSecurityDescriptorForUser(
	IN	PSID					OwnerSid,
	IN	PSID					GroupSid,
	OUT	PISECURITY_DESCRIPTOR *	ppSecDesc
);


extern
AFPSTATUS
AfpGetAfpPermissions(
	IN	PSDA						pSda,
	IN	HANDLE						DirHandle,
	IN OUT struct _FileDirParms *	pFDParm
);


extern
AFPSTATUS
AfpSetAfpPermissions(
	IN	HANDLE						DirHandle,
	IN	DWORD						Bitmap,
	IN OUT struct _FileDirParms *	pFDParm
);

#if DBG

extern
VOID
AfpDumpSid(
	IN	PBYTE						pString,
	IN	PISID						pSid
);

extern
VOID
AfpDumpSidnMask(
	IN	PBYTE						pString,
	IN	PISID						pSid,
	IN	DWORD						Mask,
	IN	UCHAR						Type,
	IN	UCHAR						Flags
);

#else

#define	AfpDumpSid(pString, pSid)
#define	AfpDumpSidnMask(pString, pSid, Mask, Type, Flags)

#endif

#define	ALLOC_ACCESS_MEM(x)	AfpAllocNonPagedMemory(x)

#ifdef	_ACCESS_LOCALS

LOCAL	ACCESS_MASK
afpPermissions2NtMask(
	IN	BYTE						AfpPermissions
);

LOCAL	PACCESS_ALLOWED_ACE
afpAddAceToAcl(
	IN	PACL						pAcl,
	IN	PACCESS_ALLOWED_ACE			pAce,
	IN	ACCESS_MASK					Mask,
	IN	PSID						pSid,
	IN	BOOLEAN						fInherit
);

LOCAL PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL						pOldDacl,
	IN	PACCESS_ALLOWED_ACE			pAceStart,
	IN	PSID						pSidOldOwner,
	IN	PSID						pSidNewOwner,
	IN	PSID						pSidOldGroup,
	IN	PSID						pSidNewGroup,
	IN	BOOLEAN						DenyAces,
	IN	BOOLEAN						InheritedAces,
	IN	OUT PACL					pNewDacl
);

#endif	// _ACCESS_LOCALS

#endif	// _ACCESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\access.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	access.c

Abstract:

	This module contains the routines for handling access related stuff.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	20 Sep 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_ACCESS

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#define	_ACCESS_LOCALS
#include <access.h>
#include <client.h>
#include <secutil.h>
#include <seposix.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpGetUserAndPrimaryGroupSids)
#pragma alloc_text( PAGE, AfpMakeSecurityDescriptorForUser)
#pragma alloc_text( PAGE, AfpGetAfpPermissions)
#pragma alloc_text( PAGE, afpMoveAces)
#pragma alloc_text( PAGE, AfpSetAfpPermissions)
#pragma alloc_text( PAGE, afpPermissions2NtMask)
#pragma alloc_text( PAGE, afpAddAceToAcl)
#if DBG
#pragma alloc_text( PAGE, AfpDumpSid)
#pragma alloc_text( PAGE, AfpDumpSidnMask)
#endif
#endif

#define ACCESS_CHECK_ACCESS_MASK        0x01
#define GRPS_BUFFER_SIZE                1024


/***	AfpMakeSecDescForAccessCheck
 *
 *	Create a security descriptor for a SID. The security descriptor has the
 *	Aces for the User alone.
 */
AFPSTATUS
AfpMakeSecDescForAccessCheck(
	IN	PSID	OwnerSid,
	OUT	PISECURITY_DESCRIPTOR *	ppSecDesc
)
{
    AFPSTATUS			Status = AFP_ERR_MISC;
    PISECURITY_DESCRIPTOR		pSecDesc;
    int				DaclSize;
    PACCESS_ALLOWED_ACE		pAce;

    PAGED_CODE( );
	
    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
            ("AfpMakeSecDescForAccessCheck: Entered\n"));

    do
    {
		// Allocate a security descriptor
		pSecDesc = (PISECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(sizeof(SECURITY_DESCRIPTOR));

		*ppSecDesc = pSecDesc;
		if (pSecDesc == NULL)
		{
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			    ("ALLOC_ACCESS_MEM error for pSecDesc\n"));
		    break;
		}

		// Initialize the security descriptor
		RtlCreateSecurityDescriptor(pSecDesc, SECURITY_DESCRIPTOR_REVISION);
		pSecDesc->Control = SE_DACL_PRESENT;

		// Set the owner and group Ids in the descriptor
		pSecDesc->Owner = OwnerSid;

		// Determine the size of the Dacl needed. The sizeof(DWORD) offsets the
		// SidStart field in the ACE. 
		//
		// 2 ACEs for the owner (owner+inherit for owner)
		DaclSize = sizeof(ACL) + 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									RtlLengthSid(OwnerSid));

		if ((pSecDesc->Dacl = (PACL)ALLOC_ACCESS_MEM(DaclSize)) == NULL)
		{
		    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
			    ("ALLOC_ACCESS_MEM error for pSecDesc->Dacl\n"));
		    break;
		}

		// Initialize the ACL with one ACE corres. to Owner getting all the
		// privileges. Add another ace which is identical to the first ace but is
		// a inheritance ACE.
		RtlCreateAcl(pSecDesc->Dacl, DaclSize, ACL_REVISION);

		// we will be adding to this as we add aces, so set it to the min here
		pSecDesc->Dacl->AclSize = sizeof(ACL);

		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pSecDesc->Dacl + sizeof(ACL));

		// Add the ALLOWED_ACE and the corres. inherit Ace for owner
		pAce = afpAddAceToAcl(pSecDesc->Dacl,
			pAce,
			ACCESS_CHECK_ACCESS_MASK,
			OwnerSid,
			True);

		Status = AFP_ERR_NONE;
    } while (False);

    // Do any cleanup on error
    if (!NT_SUCCESS(Status) && (pSecDesc != NULL))
    {
		if (pSecDesc->Dacl != NULL)
			AfpFreeMemory(pSecDesc->Dacl);
		AfpFreeMemory(pSecDesc);
		pSecDesc = NULL;
    }

    return Status;
}


/***	afpCheckUserMemberOfGroup
 *
 *	Determine if the User is member of the given group, if it is a group.
 */
LOCAL	BOOLEAN
afpCheckUserMemberOfGroup(
	IN	PSDA            pSda,
	IN	PSID			pSidGroup
)
{
    DWORD			i;
    BOOLEAN			IsAMember = False;
    PISECURITY_DESCRIPTOR       pSecDesc = NULL;
    SECURITY_SUBJECT_CONTEXT    SecSubjectContext = {0};
    ACCESS_MASK     CheckAccessMaskIn = 0, CheckAccessMaskOut = 0;
    BOOLEAN         fAccessCheckSuccess = False;
    BOOLEAN         fRevertImpersonation = False;
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE( );

    ASSERT ((pSda != NULL) && (pSidGroup != NULL));

    AfpDumpSid("afpCheckUserMemberOfGroup: Checking", pSidGroup);

    do
    {

		// Create SecurityDescriptor out of the Sid provided
		Status = AfpMakeSecDescForAccessCheck(pSidGroup, &pSecDesc);
		if (!NT_SUCCESS(Status))
		{
	    	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
		    	("AfpMakeSecDescForAccessCheck failed error (%0xld)\n", Status));
	    	break;
		}
   	 
		AfpImpersonateClient(pSda);
		fRevertImpersonation = True;
	
		SeCaptureSubjectContext(&SecSubjectContext);
		CheckAccessMaskIn = ACCESS_CHECK_ACCESS_MASK;
		fAccessCheckSuccess = SeAccessCheck (
			pSecDesc,
			&SecSubjectContext,
			FALSE,
			CheckAccessMaskIn,
			0,
			NULL,
			IoGetFileObjectGenericMapping(),
			UserMode,
			&CheckAccessMaskOut,
			&Status
			);
   	 
		if (fAccessCheckSuccess && NT_SUCCESS(Status))
		{
	    	IsAMember = True;
	    	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		    	("SeAccessCheck good : Status= (%0x), RetCode= (%ld), AccessOut= (%ld)\n", Status, fAccessCheckSuccess, CheckAccessMaskOut));
		}
		else
		{
	    	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		    	("SeAccessCheck failed: Status = (%0x), RetCode= (%ld)\n", Status, fAccessCheckSuccess));
		}
		SeReleaseSubjectContext(&SecSubjectContext);
    }
    while (FALSE);
        
    if (fRevertImpersonation)
    	AfpRevertBack();

    if (pSecDesc != NULL)
    {
	if (pSecDesc->Dacl != NULL)
	    AfpFreeMemory(pSecDesc->Dacl);
	AfpFreeMemory(pSecDesc);
    }

    return IsAMember;
}


/***	afpGetUserAccess
 *
 *	Determine the Access that is permitted for the user
 */
LOCAL	NTSTATUS
afpGetUserAccess(
	IN	PSDA            pSda,
	IN	PISECURITY_DESCRIPTOR	pSecDesc,
	OUT	PACCESS_MASK	pGrantedAccess
)
{
    DWORD			i;
    SECURITY_SUBJECT_CONTEXT    SecSubjectContext = {0};
    ACCESS_MASK     DesiredAccess = 0;
    BOOLEAN         fAccessCheckSuccess = False;
    BOOLEAN         fRevertImpersonation = False;
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE( );

    ASSERT ((pSda != NULL) && (pSecDesc != NULL));

    do
    {
		AfpImpersonateClient(pSda);
		fRevertImpersonation = True;
	
		SeCaptureSubjectContext(&SecSubjectContext);
		DesiredAccess = MAXIMUM_ALLOWED;
		fAccessCheckSuccess = SeAccessCheck (
			pSecDesc,
			&SecSubjectContext,
			FALSE,
			DesiredAccess,
			0,
			NULL,
			IoGetFileObjectGenericMapping(),
			UserMode,
			pGrantedAccess,
			&Status
			);
   	 
		if (fAccessCheckSuccess && NT_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		    	("SeAccessCheck good : Status= (%0x), RetCode= (%ld), AccessOut= (%0x)\n", Status, fAccessCheckSuccess, *pGrantedAccess));
		}
		else
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
		    	("SeAccessCheck failed: Status = (%0x), RetCode= (%0x)\n", Status, fAccessCheckSuccess));
		}
		SeReleaseSubjectContext(&SecSubjectContext);
    }
    while (FALSE);
        
    if (fRevertImpersonation)
	AfpRevertBack();

    return Status;
}


/***	AfpGetUserAndPrimaryGroupSids
 *
 *	Get the Sids corres. to the user and his primary group.
 */
NTSTATUS
AfpGetUserAndPrimaryGroupSids(
	IN	PSDA	pSda
)
{
	DWORD				i, j;
	NTSTATUS			Status = STATUS_SUCCESS;
	DWORD				SidLength, SizeNeeded, ExtraSpace, Offset;
	PSID_AND_ATTRIBUTES	pSidnAttr;
	PTOKEN_GROUPS		pGroups = NULL;
	PBYTE				pGrpsBuffer = NULL;
	BYTE				Buffer[256];		// We should not need a buffer larger
											// than this for User SID_AND_ATTRIBUTES

	PAGED_CODE( );

	do
	{
		pGrpsBuffer = (PBYTE)ALLOC_ACCESS_MEM(GRPS_BUFFER_SIZE);
		if (pGrpsBuffer == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pGroups = (PTOKEN_GROUPS)pGrpsBuffer;
		pSda->sda_pGroups = NULL;
		if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
		{
			pSda->sda_UserSid = &AfpSidWorld;
			pSda->sda_GroupSid = &AfpSidWorld;	// Primary group of Guest is also 'World'
			break;
		}

		pSidnAttr = (PSID_AND_ATTRIBUTES)Buffer;

		// Get the Owner Sid out of the User token and copy it into the Sda
		Status = NtQueryInformationToken(pSda->sda_UserToken,
										 TokenOwner,
										 pSidnAttr,
										 sizeof(Buffer),
										 &SizeNeeded);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		AfpDumpSid("AfpGetUserAndPrimaryGroupSids: LOGON Owner Sid", pSidnAttr->Sid);

		SidLength = RtlLengthSid(pSidnAttr->Sid);

		pSda->sda_UserSid = (PSID)ALLOC_ACCESS_MEM(SidLength);
		if (pSda->sda_UserSid == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		RtlCopyMemory(pSda->sda_UserSid, pSidnAttr->Sid, SidLength);

		// Get the primary group of this user
		Status = NtQueryInformationToken(pSda->sda_UserToken,
										 TokenPrimaryGroup,
										 pSidnAttr,
										 sizeof(Buffer),
										 &SizeNeeded);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		AfpDumpSid("AfpGetUserAndPrimaryGroupSids: LOGON Group Sid", pSidnAttr->Sid);

		SidLength = RtlLengthSid(pSidnAttr->Sid);
		pSda->sda_GroupSid = (PSID)ALLOC_ACCESS_MEM(SidLength);
		if (pSda->sda_GroupSid == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
		RtlCopyMemory(pSda->sda_GroupSid, pSidnAttr->Sid, SidLength);

		// Get the User Sid out of the User token. This will be added to the
		// list of groups that we query later, if this is different from
		// the Owner Sid (which is now in sda_UserSid).
		Status = NtQueryInformationToken(pSda->sda_UserToken,
										 TokenUser,
										 pSidnAttr,
										 sizeof(Buffer),
										 &SizeNeeded);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			break;
		}

		AfpDumpSid("AfpGetUserAndPrimaryGroupSids: LOGON User Sid", pSidnAttr->Sid);

		// Get the list of groups this user is member of
		SizeNeeded = GRPS_BUFFER_SIZE;
		do
		{
			if (Status != STATUS_SUCCESS)
			{
				if (pGroups != (PTOKEN_GROUPS)pGrpsBuffer)
					AfpFreeMemory(pGroups);

				if ((pGroups = (PTOKEN_GROUPS)ALLOC_ACCESS_MEM(SizeNeeded)) == NULL)
				{
					Status = AFP_ERR_MISC;
					if (pSda->sda_ClientType == SDA_CLIENT_ADMIN)
					{
						Status = STATUS_INSUFFICIENT_RESOURCES;
					}
					break;
				}
			}
			Status = NtQueryInformationToken(pSda->sda_UserToken,
											 TokenGroups,
											 pGroups,
											 SizeNeeded,
											 &SizeNeeded);
		} while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_ERROR(AFPSRVMSG_USER_GROUPS, Status, NULL, 0, NULL);
			break;
		}

		// Allocate enough memory to copy the group information in the sda. If
		// the User and Owner Sids in the user token are not the same then we
		// want to add the user sid to the list of groups. This is especially
		// the case where an ADMIN logs on but his Owner Sid is Administrators.
		// Also fix up the pointers appropriately !!!

		ExtraSpace = 0; Offset = 0; j = 0;
		if (!RtlEqualSid(pSidnAttr->Sid, pSda->sda_UserSid))
		{
			ExtraSpace = (RtlLengthSid(pSidnAttr->Sid) + sizeof(pSidnAttr->Attributes));
			Offset = sizeof(SID_AND_ATTRIBUTES);
			j = 1;
		}

		if ((pSda->sda_pGroups = (PTOKEN_GROUPS)AfpAllocPagedMemory(2*SizeNeeded+2*ExtraSpace)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		// If we are not copying the User Sid in sda_pGroups, then copy pGroups to sda_pGroups
		// directly and then fixup the individual pSid pointers. If we are then make the User
		// Sid as the first one in the list and copy the actual sid at the tail end of the
		// buffer.
        pSda->sda_pGroups->GroupCount = pGroups->GroupCount;
		RtlCopyMemory(&pSda->sda_pGroups->Groups[j],
					  &pGroups->Groups[0],
					  SizeNeeded - sizeof(DWORD));	// DWORD accounts for GroupCount
		if (ExtraSpace > 0)
		{
			pSda->sda_pGroups->Groups[0].Sid = (PSID)((PBYTE)(pSda->sda_pGroups) + SizeNeeded);
			RtlCopyMemory(pSda->sda_pGroups->Groups[0].Sid,
						  pSidnAttr->Sid,
						  RtlLengthSid(pSidnAttr->Sid));

			pSda->sda_pGroups->Groups[0].Attributes = pSidnAttr->Attributes;
			pSda->sda_pGroups->GroupCount ++;

			AfpDumpSid("AfpGetUserAndPrimaryGroupSids: Member of ",
						pSda->sda_pGroups->Groups[0].Sid);
		}
		for (i = 0; i < pGroups->GroupCount; i++, j++)
		{
			pSda->sda_pGroups->Groups[j].Sid = (PSID)((PBYTE)(pGroups->Groups[i].Sid) -
														(PBYTE)pGroups +
														(PBYTE)(pSda->sda_pGroups) +
														Offset);
			AfpDumpSid("AfpGetUserAndPrimaryGroupSids: Member of ",
						pSda->sda_pGroups->Groups[j].Sid);
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetUserAndPrimaryGroupSids: Attributes %lx\n",
						pSda->sda_pGroups->Groups[j].Attributes));
		}
	} while (False);

	if (pGroups != (PTOKEN_GROUPS)pGrpsBuffer)
		if (pGroups)
		    AfpFreeMemory(pGroups);

    if (pGrpsBuffer != NULL)
        AfpFreeMemory(pGrpsBuffer);

	return Status;
}



/***	AfpMakeSecurityDescriptorForUser
 *
 *	Create a security descriptor for a user. The security descriptor has the
 *	Owner Sid, Primary Group Sid and Aces for the User alone.
 */
AFPSTATUS
AfpMakeSecurityDescriptorForUser(
	IN	PSID					OwnerSid,
	IN	PSID					GroupSid,
	OUT	PISECURITY_DESCRIPTOR *	ppSecDesc
)
{
	AFPSTATUS				Status = AFP_ERR_MISC;
	PISECURITY_DESCRIPTOR	pSecDesc;
	int						DaclSize;
	PACCESS_ALLOWED_ACE		pAce;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			("AfpMakeSecurityDescriptorForUser: Entered\n"));

	do
	{
		// Allocate a security descriptor
		pSecDesc = (PISECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(sizeof(SECURITY_DESCRIPTOR));

		*ppSecDesc = pSecDesc;
		if (pSecDesc == NULL)
			break;

		// Initialize the security descriptor
		RtlCreateSecurityDescriptor(pSecDesc, SECURITY_DESCRIPTOR_REVISION);

		pSecDesc->Control = SE_DACL_PRESENT;

		// Set the owner and group Ids in the descriptor
		pSecDesc->Owner = OwnerSid;
		pSecDesc->Group = GroupSid;

		// Determine the size of the Dacl needed. The sizeof(DWORD) offsets the
		// SidStart field in the ACE. There are 7 aces in this security descriptor:
		//
		// 2 for the owner (owner+inherit for owner)
		// 2 for world (1 for world and 1 inherit for world).
		// 2 for system
		DaclSize = sizeof(ACL) + 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									RtlLengthSid(OwnerSid)) +
								 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									sizeof(AfpSidWorld)) +
								 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									AfpSizeSidAdmins) +
								 2*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) +
									RtlLengthSid(&AfpSidSystem));

		if ((pSecDesc->Dacl = (PACL)ALLOC_ACCESS_MEM(DaclSize)) == NULL)
			break;

		// Initialize the ACL with one ACE corres. to Owner getting all the
		// privileges. Add another ace which is identical to the first ace but is
		// a inheritance ACE.
		// JH - Add another ace for world with minumum permissions and for administrators
		//		with FullControl
		RtlCreateAcl(pSecDesc->Dacl, DaclSize, ACL_REVISION);

        // we will be adding to this as we add aces, so set it to the min here
        pSecDesc->Dacl->AclSize = sizeof(ACL);

		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pSecDesc->Dacl + sizeof(ACL));

		// Add the ALLOWED_ACE and the corres. inherit Ace for owner
		pAce = afpAddAceToAcl(pSecDesc->Dacl,
							  pAce,
							  (AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS | FILE_DELETE_CHILD),
							  OwnerSid,
							  True);

		if (AfpSidAdmins != NULL)
		{
			// Add the ALLOWED_ACE and the corres. inherit Ace for 'Administrators'
			pAce = afpAddAceToAcl(pSecDesc->Dacl,
								  pAce,
								  (AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS | FILE_DELETE_CHILD),
								  AfpSidAdmins,
								  True);
		}

		// Add a min. permission ace for world, but only if the owner is
		// not world already
		if (!RtlEqualSid(OwnerSid, &AfpSidWorld))
		{
			pAce = afpAddAceToAcl(pSecDesc->Dacl,
								  pAce,
								  (AFP_MIN_ACCESS),
								  &AfpSidWorld,
								  True);
		}

		// Now add Aces for System
		pAce = afpAddAceToAcl(pSecDesc->Dacl,
							  pAce,
							  AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS,
							  &AfpSidSystem,
							  True);
		Status = AFP_ERR_NONE;
	} while (False);

	// Do any cleanup on error
	if (!NT_SUCCESS(Status) && (pSecDesc != NULL))
	{
		if (pSecDesc->Dacl != NULL)
			AfpFreeMemory(pSecDesc->Dacl);
		AfpFreeMemory(pSecDesc);
	}

	return Status;

}


/***	AfpGetAfpPermissions
 *
 *	Read the security descriptor for this directory and obtain the SIDs for
 *	Owner and Primary group. Determine if this user is a member of the directory
 *	primary group. Finally obtain Owner,Group and World permissions.
 *
 *	OwnerId, GroupId and permissions will always be valid if this call succeeds.
 */
NTSTATUS
AfpGetAfpPermissions(
	IN	PSDA			pSda,
	IN	HANDLE			DirHandle,
	IN OUT PFILEDIRPARM	pFDParm
)
{
	NTSTATUS				Status = STATUS_SUCCESS;
	DWORD					SizeNeeded;
	PISECURITY_DESCRIPTOR	pSecDesc = NULL;
	PBYTE                   pAbsSecDesc = NULL; // Used in conversion of
												// sec descriptor to 
												// absolute format
	BOOLEAN					SawOwnerAce = False,
							SawGroupAce = False,
							SawWorldAce = False,
							CheckUserRights = False;
	ACCESS_MASK				OwnerGranted = 0, OwnerDenied = 0,
							GroupGranted = 0, GroupDenied = 0,
							WorldGranted = 0, WorldDenied = 0,
							UserGranted = 0, UserDenied = 0,
							UserAccess = 0;


#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_GetPermsCount);
	AfpGetPerfCounter(&TimeS);
#endif

	// Read the security descriptor for this directory and determine the
	// rights for owner/group/world.We want to optimize on how much memory
	// we need to read this in. Its a pain to make a call just to get that.
	// So just make a guess. If that turns out to be short then do the exact
	// allocation.
	do
	{
		// 4096 has been emperically chosen
		SizeNeeded = 4096 - POOL_OVERHEAD;
		do
		{
			if (pSecDesc != NULL)
			{
				AfpFreeMemory(pSecDesc);
			}
			if ((pSecDesc = (PSECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(SizeNeeded)) == NULL)
			{
				Status = AFP_ERR_MISC;
				if (pSda->sda_ClientType == SDA_CLIENT_ADMIN)
				{
					Status = STATUS_INSUFFICIENT_RESOURCES;
				}
				break;
			}
			Status = NtQuerySecurityObject(DirHandle,
										OWNER_SECURITY_INFORMATION |
										GROUP_SECURITY_INFORMATION |
										DACL_SECURITY_INFORMATION,
										pSecDesc,
										SizeNeeded,
										&SizeNeeded);
		} while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		// If the security descriptor is in self-relative form, convert to absolute

		pSecDesc = (PISECURITY_DESCRIPTOR)((PBYTE)pSecDesc);
		if (pSecDesc->Control & SE_SELF_RELATIVE)
		{

		    DWORD AbsoluteSizeNeeded;

		    // An absolute SD is not necessarily the same size as a relative
		    // SD, so an in-place conversion may not be possible.
		    AbsoluteSizeNeeded = SizeNeeded;            
		    Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &AbsoluteSizeNeeded);
		    if (Status == STATUS_BUFFER_TOO_SMALL)
		    {
			// Allocate a new buffer in which to store the absolute
			// security descriptor, copy the contents of the relative
			// descriptor in and try again

			pAbsSecDesc = (PBYTE)ALLOC_ACCESS_MEM(AbsoluteSizeNeeded);
			if (pAbsSecDesc == NULL)
			{
			    Status = STATUS_NO_MEMORY;
			    DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				    ("AfpGetAfpPermissions: ALLOC_ACCESS_MEM error\n"));
			}
			else
			{
			    RtlCopyMemory(pAbsSecDesc, pSecDesc, SizeNeeded);
			    Status = RtlSelfRelativeToAbsoluteSD2 (pAbsSecDesc,
				    &AbsoluteSizeNeeded);
			    if (NT_SUCCESS(Status))
			    {
				// We don't need relative form anymore, 
				// we will work with the Absolute form
				if (pSecDesc != NULL)
				{
				    AfpFreeMemory(pSecDesc);
				}
				pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
			    }
			    else
			    {
				// We cannot use Absolute Form, throw it away
				AfpFreeMemory(pAbsSecDesc);
				pAbsSecDesc = NULL;
			    }
			}

		    }
		    if (!NT_SUCCESS(Status))
		    {
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
				("AfpGetAfpPermissions: RtlSelfRelativeToAbsoluteSD2: returned error %lx\n", Status));
			break;
		    }
		}

		// Now determine if the user is a member of the directories primary group.
		pFDParm->_fdp_OwnerId = 0;
		pFDParm->_fdp_GroupId = 0;
		pFDParm->_fdp_UserIsOwner = False;
		pFDParm->_fdp_UserIsMemberOfDirGroup = False;

		if (pSecDesc->Owner != NULL)
		{
		    AfpDumpSid("AfpGetAfpPermissions: OwnerSid", pSecDesc->Owner);

		    pFDParm->_fdp_UserIsOwner =
			(RtlEqualSid(pSecDesc->Owner, pSda->sda_UserSid) ||
			 ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
			  (pSda->sda_ClientType != SDA_CLIENT_ADMIN) &&
			  afpCheckUserMemberOfGroup(pSda,
				  pSecDesc->Owner)));
			 DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			     ("AfpGetAfpPermissions: User %s Owner\n",
			      pFDParm->_fdp_UserIsOwner ? "is" : "isnt"));

			 if (!NT_SUCCESS(Status = AfpSidToMacId(pSecDesc->Owner,
				     &pFDParm->_fdp_OwnerId)))
			 {
			 	// If we cant map the Sid, return Id SE_NULL_POSIX_ID
			 	pFDParm->_fdp_OwnerId = SE_NULL_POSIX_ID;
				Status = AFP_ERR_NONE;
			}
		}

		if (pSecDesc->Group != NULL)
		{
			AfpDumpSid("AfpGetAfpPermissions: GroupSid", pSecDesc->Group);

			if (!pFDParm->_fdp_UserIsOwner)
			    pFDParm->_fdp_UserIsMemberOfDirGroup =
				(RtlEqualSid(pSecDesc->Group, pSda->sda_UserSid) ||
				 ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
				  (pSda->sda_ClientType != SDA_CLIENT_ADMIN) &&
				  afpCheckUserMemberOfGroup(pSda,
					  pSecDesc->Group)));

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
			    ("AfpGetAfpPermissions: Group %s member of PrimaryGroup\n",
			     pFDParm->_fdp_UserIsMemberOfDirGroup ? "is" : "isnt"));

			if (!NT_SUCCESS(Status = AfpSidToMacId(pSecDesc->Group,
				    &pFDParm->_fdp_GroupId)))
			{
				// If we cant map the Sid, return Id SE_NULL_POSIX_ID
				pFDParm->_fdp_GroupId = SE_NULL_POSIX_ID;
				Status = AFP_ERR_NONE;
			}
		}

		// Walk through the ACL list and determine Owner/Group/World and User
		// permissions. For Owner/Group and User, if the specific ace's are
		// not present then they inherit the world permissions.
		//
		// A NULL Acl => All rights to everyone. An empty Acl on the other
		// hand => no access for anyone.

		pFDParm->_fdp_UserRights = 0;
		pFDParm->_fdp_WorldRights = 0;

		if ((pSecDesc->Control & SE_DACL_PRESENT) &&
			(pSecDesc->Dacl != NULL))
		{
			USHORT				i;
			PSID				pSid;
			PACL				pAcl;
			PACCESS_ALLOWED_ACE pAce;

			pAcl = pSecDesc->Dacl;
			pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAcl + sizeof(ACL));
			CheckUserRights =  ((pSda->sda_ClientType != SDA_CLIENT_GUEST) &&
				(pSda->sda_ClientType != SDA_CLIENT_ADMIN));
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetAfpPermissions: # of aces %d\n", pSecDesc->Dacl->AceCount));
			for (i = 0; i < pSecDesc->Dacl->AceCount; i++)
			{
			    if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) &&
				    (pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE))
			    {
				DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpGetAfpPermissions: Skipping ACE of type (%ld)\n", pAce->Header.AceType));
				pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
				continue;
			    }

			    pSid = (PSID)(&pAce->SidStart);

			    // Ignore inherit-only aces, & system
			    if (pAce->Header.AceFlags & INHERIT_ONLY_ACE)
			    {
				AfpDumpSidnMask("AfpGetAfpPermissions: Skipping",
					pSid,
					pAce->Mask,
					pAce->Header.AceType,
					pAce->Header.AceFlags);
			    }
			    else
			    {
				AfpDumpSidnMask("AfpGetAfpPermissions: ACE",
					pSid,
					pAce->Mask,
					pAce->Header.AceType,
					pAce->Header.AceFlags);

				if ((pSecDesc->Owner != NULL) &&
					RtlEqualSid(pSid, pSecDesc->Owner))
				{
					if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
					{
						OwnerGranted |= (pAce->Mask & ~OwnerDenied);
					}
					else
					{
						OwnerDenied |= (pAce->Mask & ~OwnerGranted);
					}
					DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
						("Owner: %s Ace Mask %lx\n",
						 (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
						 "Allow" : "Deny",
						 pAce->Mask));
					SawOwnerAce = True;
				}

				if ((pSecDesc->Group != NULL) &&
					RtlEqualSid(pSid, pSecDesc->Group))
				{
					if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
					{
						GroupGranted |= (pAce->Mask & ~GroupDenied);
					}
					else
					{
						GroupDenied |= (pAce->Mask & ~GroupGranted);
					}
						
					DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
						("Group: %s Ace Mask %lx\n",
						(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
						"Allow" : "Deny",
						pAce->Mask));
					SawGroupAce = True;
				}

				if ((RtlEqualSid(pSid, (PSID)&AfpSidWorld)))
				{
					if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
					{
						WorldGranted |= (pAce->Mask & ~WorldDenied);
					}
					else
					{
						WorldDenied |= (pAce->Mask & ~WorldGranted);
					}
					DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
						("World: %s Ace Mask %lx\n",
						(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ?
						"Allow" : "Deny",
						pAce->Mask));
					SawWorldAce = True;
				}
			    }

			    pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
			}
		}
		else	// Security descriptor not present, party time
		{
			pFDParm->_fdp_WorldRights = DIR_ACCESS_ALL;
			pFDParm->_fdp_UserRights = DIR_ACCESS_ALL | DIR_ACCESS_OWNER;
		}

		if (!SawGroupAce)
			pFDParm->_fdp_GroupRights = pFDParm->_fdp_WorldRights;

		if (SawOwnerAce)
		{
			AfpAccessMask2AfpPermissions(pFDParm->_fdp_OwnerRights,
				OwnerGranted,
				ACCESS_ALLOWED_ACE_TYPE);
		}
				    
		if (SawGroupAce)
		{
			AfpAccessMask2AfpPermissions(pFDParm->_fdp_GroupRights,
				GroupGranted,
				ACCESS_ALLOWED_ACE_TYPE);
		}
				    
		if (SawWorldAce)
		{
			AfpAccessMask2AfpPermissions(pFDParm->_fdp_WorldRights,
				WorldGranted,
				ACCESS_ALLOWED_ACE_TYPE);
		}

		// Get the ACCESS_MASK allowed for the user

		Status = afpGetUserAccess(
					pSda,
					pSecDesc,
					&UserAccess);
		if (NT_SUCCESS(Status))
		{
			UserGranted = UserAccess;
		}
		else
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
					("afpGetUserAccess failed with error %0x\n",
					 Status));
			Status = AFP_ERR_NONE;
		}

		AfpAccessMask2AfpPermissions(pFDParm->_fdp_UserRights,
			UserGranted,
			ACCESS_ALLOWED_ACE_TYPE);

		// If this is a standalone server and the primary group of the
		// directory is MACHINE\None, do not return this information to
		// the caller.
		if (AfpServerIsStandalone		&&
			(pSecDesc->Group != NULL)	&&
			RtlEqualSid(pSecDesc->Group, AfpSidNone))
		{
			pFDParm->_fdp_GroupRights = 0;
			pFDParm->_fdp_GroupId = 0;
		}

		if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
			pFDParm->_fdp_UserRights = pFDParm->_fdp_WorldRights;

	} while (False);

	if (pSecDesc != NULL)
		AfpFreeMemory(pSecDesc);

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_GetPermsTime,
		TimeD,
		&AfpStatisticsLock);
#endif
	return Status;
}



/***	afpMoveAces
 *
 *	Move a bunch of aces from the old security descriptor to the new security
 *	descriptor.
 */
LOCAL PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL				pOldDacl,
	IN	PACCESS_ALLOWED_ACE	pAceStart,
	IN	PSID				pSidOldOwner,
	IN	PSID				pSidNewOwner,
	IN	PSID				pSidOldGroup,
	IN	PSID				pSidNewGroup,
	IN	BOOLEAN				DenyAces,
	IN	BOOLEAN				InheritedAces,
	IN	OUT PACL			pNewDacl
)
{
	USHORT				i;
	PACCESS_ALLOWED_ACE	pAceOld;
	PSID				pSidAce;

	PAGED_CODE( );

	for (i = 0, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pOldDacl + sizeof(ACL));
		 i < pOldDacl->AceCount;
		 i++, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pAceOld + pAceOld->Header.AceSize))
	{
		if (InheritedAces && ((pAceOld->Header.AceFlags & INHERITED_ACE) != INHERITED_ACE))
			continue;

		if ((!InheritedAces) && ((pAceOld->Header.AceFlags & INHERITED_ACE) == INHERITED_ACE))
			continue;

		// Note: All deny aces are ahead of the grant aces.
		if (DenyAces && (pAceOld->Header.AceType != ACCESS_DENIED_ACE_TYPE))
			break;

		if (!DenyAces && (pAceOld->Header.AceType == ACCESS_DENIED_ACE_TYPE))
			continue;

		pSidAce = (PSID)(&pAceOld->SidStart);
		if (!RtlEqualSid(pSidAce, &AfpSidWorld)		&&
			!RtlEqualSid(pSidAce, &AfpSidSystem)	&&
			!RtlEqualSid(pSidAce, pSidOldOwner)		&&
			!RtlEqualSid(pSidAce, pSidNewOwner)		&&
			!RtlEqualSid(pSidAce, pSidOldGroup)		&&
			!RtlEqualSid(pSidAce, pSidNewGroup))
		{
			RtlCopyMemory(pAceStart, pAceOld, pAceOld->Header.AceSize);
            pNewDacl->AclSize += pAceOld->Header.AceSize;
			pNewDacl->AceCount ++;
			pAceStart = (PACCESS_ALLOWED_ACE)((PBYTE)pAceStart +
													pAceStart->Header.AceSize);
		}
	}
	return pAceStart;
}


/***	AfpSetAfpPermissions
 *
 *	Set the permissions on this directory. Also optionally set the owner and
 *	group ids. For setting the owner and group ids verify if the user has the
 *	needed access. This access is however not good enough. We check for this
 *	access but do the actual setting of the permissions in the special server
 *	context (RESTORE privilege is needed).
 */
AFPSTATUS
AfpSetAfpPermissions(
	IN	HANDLE			DirHandle,
	IN	DWORD			Bitmap,
	IN	PFILEDIRPARM	pFDParm
)
{
	AFPSTATUS				Status = STATUS_SUCCESS;
	DWORD					SizeNeeded;
	PISECURITY_DESCRIPTOR	pSecDesc;
	PBYTE                   pAbsSecDesc = NULL; // Used in conversion of
												// sec descriptor to 
												// absolute format
	SECURITY_INFORMATION	SecInfo = DACL_SECURITY_INFORMATION;
	PSID					pSidOwner = NULL, pSidGroup = NULL;
	PSID					pSidOldOwner, pSidOldGroup;
	BOOLEAN					SawOwnerAce = False, SawGroupAce = False;
	BOOLEAN					OwnerIsWorld = False, GroupIsWorld = False;
	BOOLEAN					fDir = IsDir(pFDParm);
	PACL					pDaclNew = NULL;
	PACCESS_ALLOWED_ACE		pAce;
	LONG					SizeNewDacl;
#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SetPermsCount);
	AfpGetPerfCounter(&TimeS);
#endif
	do
	{
		// Read the security descriptor for this directory
		SizeNeeded = 4096 - POOL_OVERHEAD;
		pSecDesc = NULL;

		do
		{
			if (pSecDesc != NULL)
			{
				AfpFreeMemory(pSecDesc);
			}

			SizeNewDacl = SizeNeeded;
			if ((pSecDesc = (PSECURITY_DESCRIPTOR)ALLOC_ACCESS_MEM(SizeNeeded)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}

			Status = NtQuerySecurityObject(DirHandle,
										OWNER_SECURITY_INFORMATION |
										GROUP_SECURITY_INFORMATION |
										DACL_SECURITY_INFORMATION,
										pSecDesc,
										SizeNeeded,
										&SizeNeeded);
		} while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));

		if (!NT_SUCCESS(Status))
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			break;
		}


		pSecDesc = (PISECURITY_DESCRIPTOR)((PBYTE)pSecDesc);
		// If the security descriptor is in self-relative form, convert to absolute
		if (pSecDesc->Control & SE_SELF_RELATIVE)
		{
			DWORD AbsoluteSizeNeeded;

			// An absolute SD is not necessarily the same size as a relative
			// SD, so an in-place conversion may not be possible.
						
			AbsoluteSizeNeeded = SizeNeeded;            
			Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &AbsoluteSizeNeeded);
			if (Status == STATUS_BUFFER_TOO_SMALL)
			{
					// Allocate a new buffer in which to store the absolute
					// security descriptor, copy the contents of the relative
					// descriptor in and try again

					pAbsSecDesc = (PBYTE)ALLOC_ACCESS_MEM(AbsoluteSizeNeeded);
					if (pAbsSecDesc == NULL)
					{
							Status = STATUS_NO_MEMORY;
							DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
								("AfpSetAfpPermissions: ALLOC_ACCESS_MEM 2 error\n"));
					}
					else
					{
							RtlCopyMemory(pAbsSecDesc, pSecDesc, SizeNeeded);
							Status = RtlSelfRelativeToAbsoluteSD2 (pAbsSecDesc,
											&AbsoluteSizeNeeded);
							if (NT_SUCCESS(Status))
							{
									// We don't need relative form anymore, 
									// we will work with the Absolute form
									if (pSecDesc != NULL)
									{
										AfpFreeMemory(pSecDesc);
									}
									pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
							}
							else
							{
									// We cannot use Absolute Form, throw it away
									AfpFreeMemory(pAbsSecDesc);
									pAbsSecDesc = NULL;
							}
					}
			}

            		if (!NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
					("AfpSetAfpPermissions: RtlSelfRelativeToAbsoluteSD2: returned error %lx\n", Status));
				break;
			}
			SizeNeeded = AbsoluteSizeNeeded;
		}
		SizeNewDacl = SizeNeeded;

		// Add SE_DACL_AUTO_INHERIT_REQ
		pSecDesc->Control |= SE_DACL_AUTO_INHERIT_REQ;

		// Save the old Owner and Group Sids
		pSidOldOwner = pSecDesc->Owner;
		pSidOldGroup = pSecDesc->Group;

		// Convert the owner/group ids, if any to be set to their corres. sids
		if (Bitmap & DIR_BITMAP_OWNERID)
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Setting Owner to ID %lx\n",
				pFDParm->_fdp_OwnerId));

			if (AfpMacIdToSid(pFDParm->_fdp_OwnerId, &pSidOwner) != STATUS_SUCCESS)
			{
				Status = AFP_ERR_MISC;
				break;
			}

			// Don't allow owner sid to be set as the NULL sid, or
			// to what it is presently set to
			if (!RtlEqualSid(pSecDesc->Owner, pSidOwner) &&
				!RtlEqualSid(&AfpSidNull, pSidOwner))
			{
				AfpDumpSid("AfpSetAfpPermissions: Setting Owner Sid to ", pSidOwner);
				pSecDesc->Owner = pSidOwner;
				SecInfo |= OWNER_SECURITY_INFORMATION;
			}
		}

		if (Bitmap & DIR_BITMAP_GROUPID)
		{
			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Setting Group to ID %lx\n",
					pFDParm->_fdp_GroupId));

			if (AfpMacIdToSid(pFDParm->_fdp_GroupId, &pSidGroup) != STATUS_SUCCESS)
			{
				Status = AFP_ERR_MISC;
				break;
			}

			// Don't allow group sid to be set as the NULL or None sid, or
			// to what it is presently set to
			if (!RtlEqualSid(pSecDesc->Group, pSidGroup)	&&
				!RtlEqualSid(&AfpSidNull, pSidGroup)		&&
				(!AfpServerIsStandalone || !RtlEqualSid(AfpSidNone, pSidGroup)))
			{
				AfpDumpSid("AfpSetAfpPermissions: Setting Group Sid to ", pSidGroup);
				pSecDesc->Group = pSidGroup;
				SecInfo |= GROUP_SECURITY_INFORMATION;
			}

		}

		// If either the owner or group or both is 'EveryOne' then coalesce the
		// permissions
		if (RtlEqualSid(pSecDesc->Owner, pSecDesc->Group))
		{
			pFDParm->_fdp_OwnerRights |= pFDParm->_fdp_GroupRights;
			pFDParm->_fdp_GroupRights |= pFDParm->_fdp_OwnerRights;
		}

		if (RtlEqualSid(pSecDesc->Owner, &AfpSidWorld))
		{
			pFDParm->_fdp_WorldRights |= (pFDParm->_fdp_OwnerRights | DIR_ACCESS_OWNER);
			OwnerIsWorld = True;
		}

		if (RtlEqualSid(pSecDesc->Group, &AfpSidWorld))
		{
			pFDParm->_fdp_WorldRights |= pFDParm->_fdp_GroupRights;
			GroupIsWorld = True;
		}

		// Construct the new Dacl. This consists of Aces for World, Owner and Group
		// followed by Old Aces for everybody else, but with Aces for World, OldOwner
		// and OldGroup stripped out. First determine space for the new Dacl and
		// allocated space for the new Dacl. Lets be exteremely conservative. We
		// have two aces each for owner/group/world.

		SizeNewDacl +=
				(RtlLengthSid(pSecDesc->Owner) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(pSecDesc->Group) + sizeof(ACCESS_ALLOWED_ACE) +
				 sizeof(AfpSidSystem) + sizeof(ACCESS_ALLOWED_ACE) +
				 sizeof(AfpSidWorld) + sizeof(ACCESS_ALLOWED_ACE)) * 2;

		if ((pDaclNew = (PACL)ALLOC_ACCESS_MEM(SizeNewDacl)) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		RtlCreateAcl(pDaclNew, SizeNewDacl, ACL_REVISION);

        // we will be adding to this as we add aces, so set it to the min here
        pDaclNew->AclSize = sizeof(ACL);

		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pDaclNew + sizeof(ACL));

		// At this time the Acl list is empty, i.e. no access for anybody

		// Start off by copying the Explicit/Non-inherited Deny Aces from 
		// the original Dacl list
		// weeding out the Aces for World, old and new owner, new and old
		// group, creator owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl,
							   pAce,
							   pSidOldOwner,
							   pSecDesc->Owner,
							   pSidOldGroup,
							   pSecDesc->Group,
							   True,
							   False,
							   pDaclNew);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added (%d) old Non-inherited Deny Aces\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now add Allowed Aces for System, World, Group & Owner - in that order

		pAce = afpAddAceToAcl(pDaclNew,
							  pAce,
							  AFP_READ_ACCESS | AFP_WRITE_ACCESS | AFP_OWNER_ACCESS,
							  &AfpSidSystem,
							  fDir);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Added Aces for System (%d)\n",
				pDaclNew->AceCount));

		ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);

		// Now add Ace for World
		pAce = afpAddAceToAcl(pDaclNew,
							  pAce,
							  afpPermissions2NtMask(pFDParm->_fdp_WorldRights),
							  &AfpSidWorld,
							  fDir);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
				("AfpSetAfpPermissions: Added Aces for World (%d)\n",
				pDaclNew->AceCount));

		ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);

		// Now add Ace for Group
		if (!GroupIsWorld &&
			!RtlEqualSid(pSecDesc->Group, &AfpSidNull) &&
			(!AfpServerIsStandalone || !RtlEqualSid(pSecDesc->Group, AfpSidNone)))
		{
			pAce = afpAddAceToAcl(pDaclNew,
					   pAce,
					   afpPermissions2NtMask(pFDParm->_fdp_GroupRights),
					   pSecDesc->Group,
					   fDir);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added Aces for Group (%d)\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		if (!OwnerIsWorld && !RtlEqualSid(pSecDesc->Owner, &AfpSidNull))
		{
			pFDParm->_fdp_OwnerRights |= DIR_ACCESS_OWNER;
			pAce = afpAddAceToAcl(pDaclNew,
								  pAce,
								  afpPermissions2NtMask(pFDParm->_fdp_OwnerRights),
								  pSecDesc->Owner,
								  fDir);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added Aces for Owner (%d)\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}


		// Now add in the Explicit/Non-inherited Grant Aces from the 
		// original Dacl list weeding out
		// the Aces for World, old and new owner, new and old group, creator
		// owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl,
							   pAce,
							   pSidOldOwner,
							   pSecDesc->Owner,
							   pSidOldGroup,
							   pSecDesc->Group,
							   False,
							   False,
							   pDaclNew);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added (%d) old Non-inherited Grant Aces\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now add in the Non-explicit/Inherited Deny Aces from 
		// the original Dacl list
		// weeding out the Aces for World, old and new owner, new and old
		// group, creator owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl,
							   pAce,
							   pSidOldOwner,
							   pSecDesc->Owner,
							   pSidOldGroup,
							   pSecDesc->Group,
							   True,
							   True,
							   pDaclNew);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added (%d) old Inherited Deny Aces\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now add in the Explicit/Non-inherited Grant Aces from the 
		// original Dacl list weeding out
		// the Aces for World, old and new owner, new and old group, creator
		// owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl,
							   pAce,
							   pSidOldOwner,
							   pSecDesc->Owner,
							   pSidOldGroup,
							   pSecDesc->Group,
							   False,
							   True,
							   pDaclNew);

			DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("AfpSetAfpPermissions: Added (%d) old Inherited Grant Aces (%d)\n",
					pDaclNew->AceCount));

			ASSERT(((PBYTE)pAce - (PBYTE)pDaclNew) < SizeNewDacl);
		}

		// Now set the new security descriptor
		pSecDesc->Dacl = pDaclNew;

		// We need to impersonate the FspToken while we do this
		AfpImpersonateClient(NULL);
		Status = NtSetSecurityObject(DirHandle, SecInfo, pSecDesc);
		if (!NT_SUCCESS(Status))
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
		AfpRevertBack();
	} while (False);

	// Free the allocated buffers before we return
	if (pSecDesc != NULL)
		AfpFreeMemory(pSecDesc);
	if (pDaclNew != NULL)
		AfpFreeMemory(pDaclNew);


#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SetPermsTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return Status;
}


/***	afpPermissions2NtMask
 *
 *	Map Afp permissions to Nt access mask. FILE_DELETE_CHILD is added ONLY
 *	when all the Afp bits are set. This is in line with the FileManager
 *	which only sets this bit if "Full Control" is specified. Also under
 *	NT security model, FILE_DELETE_CHILD overrides any child access control
 * 	as far as the ability to delete that entity goes.
 */
LOCAL	ACCESS_MASK
afpPermissions2NtMask(
	IN  BYTE	AfpPermissions
)
{
	ACCESS_MASK	NtAccess = 0;

	PAGED_CODE( );

	if (AfpPermissions & DIR_ACCESS_OWNER)
		NtAccess |= AFP_OWNER_ACCESS;

	if ((AfpPermissions & DIR_ACCESS_ALL) == DIR_ACCESS_ALL)
		NtAccess |= AFP_READ_ACCESS | AFP_WRITE_ACCESS | FILE_DELETE_CHILD;
	else
	{
		if (AfpPermissions & (DIR_ACCESS_READ | DIR_ACCESS_SEARCH))
			NtAccess |= AFP_READ_ACCESS;

		if (AfpPermissions & DIR_ACCESS_WRITE)
			NtAccess |= AFP_WRITE_ACCESS;
	}
	return NtAccess;
}


/***	afpAddAceToAcl
 *
 *	Build an Ace corres. to the Sid(s) and mask and add these to the Acl. It is
 *	assumed that the Acl has space for the Aces. If the mask is 0 i.e. no access
 *	we give AFP_MIN_ACCESS. This is so that the file/dir permissions can be
 *	queried and a belted icon is generated instead of nothing.
 */
LOCAL	PACCESS_ALLOWED_ACE
afpAddAceToAcl(
	IN  PACL				pAcl,
	IN  PACCESS_ALLOWED_ACE	pAce,
	IN  ACCESS_MASK			Mask,
	IN  PSID				pSid,
	IN	BOOLEAN				fInherit
)
{
	USHORT	SidLen;

	PAGED_CODE( );

	SidLen = (USHORT)RtlLengthSid(pSid);

	// Add a vanilla ace
	pAcl->AceCount ++;
	pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
	pAce->Header.AceFlags = 0;
	pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
	pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) +
									sizeof(ACCESS_MASK) +
									SidLen);

	RtlCopyMemory((PSID)(&pAce->SidStart), pSid, SidLen);

    pAcl->AclSize += pAce->Header.AceSize;

	AfpDumpSidnMask("afpAddAceToAcl ",
					pSid,
					pAce->Mask,
					ACCESS_ALLOWED_ACE_TYPE,
					pAce->Header.AceFlags);

	// Now add an inherit ace
	if (fInherit)
	{
		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
		pAcl->AceCount ++;
		pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
								OBJECT_INHERIT_ACE |
								INHERIT_ONLY_ACE;
		pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
		pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) +
										sizeof(ACCESS_MASK) +
										SidLen);
		RtlCopyMemory((PSID)(&pAce->SidStart), pSid, SidLen);

        pAcl->AclSize += pAce->Header.AceSize;

		AfpDumpSidnMask("afpAddAceToAcl (Inherit) ",
						pSid,
						pAce->Mask,
						ACCESS_ALLOWED_ACE_TYPE,
						pAce->Header.AceFlags);
	}

	return ((PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize));
}


#if DBG

/***	AfpDumpSid
 *
 */
VOID
AfpDumpSid(
	IN	PBYTE	pString,
	IN	PISID	pSid
)
{
	WCHAR			Buffer[128];
	UNICODE_STRING	SidStr;

	PAGED_CODE( );

	AfpSetEmptyUnicodeString(&SidStr, sizeof(Buffer), Buffer);
	if ((AfpDebugComponent & DBG_COMP_SECURITY) && (DBG_LEVEL_INFO >= AfpDebugLevel))
	{
		RtlConvertSidToUnicodeString(&SidStr, pSid, False);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("%s %ws\n", pString, SidStr.Buffer));
	}
}

/***	AfpDumpSidnMask
 *
 */
VOID
AfpDumpSidnMask(
	IN	PBYTE	pString,
	IN	PISID	pSid,
	IN	DWORD	Mask,
	IN	UCHAR	Type,
	IN	UCHAR	Flags
)
{
	WCHAR			Buffer[128];
	UNICODE_STRING	SidStr;

	PAGED_CODE( );

	AfpSetEmptyUnicodeString(&SidStr, sizeof(Buffer), Buffer);
	if ((AfpDebugComponent & DBG_COMP_SECURITY) && (DBG_LEVEL_INFO >= AfpDebugLevel))
	{
		RtlConvertSidToUnicodeString(&SidStr, pSid, False);

		DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_INFO,
					("%s Sid %ws, Mask %lx, Type %x, Flags %x\n",
					pString, SidStr.Buffer, Mask, Type, Flags));
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afpadmin.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	afpadmin.h

Abstract:

	This module contains definitions relating to the admin
	routines.

Author:

	Sue Adams

Revision History:
	25 Jun 1992             Initial Version

--*/

extern
VOID
AfpAdminDeInit(
	VOID
);

extern
AFPSTATUS
AfpAdmServiceStart(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServiceStop(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServicePause(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServiceContinue(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmGetStatistics(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmGetStatisticsEx(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmClearStatistics(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmGetProfCounters(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmClearProfCounters(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerSetParms(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerAddEtc(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerSetEtc(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerGetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerDeleteEtc(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmServerAddIcon(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeAdd(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeSetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeGetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmVolumeEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmSessionEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmConnectionEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmWDirectoryGetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmWDirectorySetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmWFinderSetInfo(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmForkEnum(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmMessageSend(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
AFPSTATUS
AfpAdmSystemShutdown(
	IN	OUT	PVOID 	Inbuf OPTIONAL,
	IN	LONG		OutBufLen OPTIONAL,
	OUT	PVOID 		Outbuf OPTIONAL
);

extern
PETCMAPINFO
AfpLookupEtcMapEntry(
	PUCHAR	pExt
);

#ifdef	AFPADMIN_LOCALS

// Manifests for the FieldDesc
#define	DESC_NONE		0			// Don't bother with the validation
#define	DESC_STRING		1			// Its an offset to a string
#define	DESC_ETC		2			// Its the count of # of etc mappings
#define	DESC_ICON		3			// This field specifies the size of icon
#define	DESC_SID		4			// This field points to a Sid
#define	DESC_SPECIAL	5			// This needs special handling
#define	MAX_FIELDS		3			// Max. number of fields to validate

// Structure used for queueing admin requests to a worker thread
typedef	struct _AdminQRequest
{
	PIRP			aqr_pIrp;
	ADMINAPIWORKER	aqr_AdminApiWorker;
	WORK_ITEM		aqr_WorkItem;
} ADMQREQ, *PADMQREQ;

LOCAL NTSTATUS
afpFsdHandleAdminRequest(
	IN PIRP			pIrp
);


LOCAL NTSTATUS
afpFsdHandleShutdownRequest(
	IN PIRP			pIrp
);

LOCAL VOID FASTCALL
afpHandleQueuedAdminRequest(
	IN	PADMQREQ	pAdmQReq
);

LOCAL VOID
afpQueueAdminWorkItem(
	IN	PLIST_ENTRY	pAdmQListEntry
);

LOCAL NTSTATUS
afpFsdDispatchAdminRequest(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp
);

NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT	DriverObject,
	IN PUNICODE_STRING	RegistryPath
);

NTSTATUS
afpInitServer (
	VOID
);

LOCAL VOID
afpAdminThread(
	IN	PVOID			pContext
);

LOCAL VOID
afpFsdUnloadServer(
	IN	PDRIVER_OBJECT 	DeviceObject
);

LOCAL VOID
afpStartStopAdminRequest(
	IN	PIRP			pIrp,
	IN	BOOLEAN			Start
);

#define	afpStartAdminRequest(pIrp)	afpStartStopAdminRequest(pIrp, True)
#define	afpStopAdminRequest(pIrp)	afpStartStopAdminRequest(pIrp, False)

// This is the dispatch table for admin apis.
typedef struct
{
	BYTE	_FieldDesc;				// One of the above DESC_ values
	BYTE	_FieldOffset;			// Offset of the field
} DESCRIPTOR;

typedef	struct _AdminApiDispatchTable
{
	SHORT					_MinBufLen;
	BYTE					_OffToStruct;
	BOOLEAN					_CausesChange;
	DWORD					_OpCode;
	ADMINAPIWORKER			_AdminApiWorker;
	ADMINAPIWORKER			_AdminApiQueuedWorker;
	/*
	 * The following fields are used by the validation code. Since the
	 * structures have variable length fields in it, we need to make sure
	 * that
	 *		a, The offsets point within the buffer
	 *		b, The last unicode character in the buffer is a NULL
	 * This ensures that when the worker does a wstrlen, it does not
	 * access memory beyond the InputBuffer.
	 *
	 * We also deal with variable length data which is not a string.
	 * Fortunately there are only three APIs that use such a structure.
	 * We special-case these apis. The APIs are
	 *		a, ServerAddIcon
	 *			We need to make sure that the icon buffer and icon length are
	 *			kosher. The worker will do the rest of the validation.
	 *		b, ServerAddEtc
	 *			We need to make sure that the buffer is consistent with the
	 *			number of etc mappings specified.
	 */
	 DESCRIPTOR				_Fields[MAX_FIELDS];

} ADMIN_DISPATCH_TABLE, *PADMIN_DISPATCH_TABLE;

extern	ADMIN_DISPATCH_TABLE	AfpAdminDispatchTable[];

#endif	// AFPADMIN_LOCALS

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afp.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afp.h

Abstract:

	This file defines some server globals as well as include all relevant
	header files.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _AFP_
#define _AFP_

#include <ntosp.h>
#include <zwapi.h>
#include <security.h>
#include <ntlmsp.h>

#include <string.h>
#include <wcstr.h>
#include <ntiologc.h>
#include <tdi.h>
#include <tdikrnl.h>

#if DBG
/* Disable FASTCALLs for checked builds */
#undef	FASTCALL
#define	FASTCALL
#define LOCAL
#else
#define LOCAL
#endif

#ifdef	_GLOBALS_
#define	GLOBAL
#define	EQU				=
#else
#define	GLOBAL			extern
#define	EQU				; / ## /
#endif

#include <atalktdi.h>
#include <afpconst.h>
#include <fwddecl.h>
#include <intrlckd.h>
#include <macansi.h>
#include <macfile.h>
#include <admin.h>
#include <swmr.h>
#include <fileio.h>
#include <server.h>
#include <forks.h>
#include <sda.h>
#include <afpinfo.h>
#include <idindex.h>
#include <desktop.h>
#include <atalkio.h>
#include <volume.h>
#include <afpmem.h>
#include <errorlog.h>
#include <srvmsg.h>
#include <time.h>
#include <lists.h>
#include <filenums.h>
#include <rasfmsub.h>
#include <tcp.h>

#endif  // _AFP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afpconst.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpconst.h

Abstract:

	This module contains the Afp API function codes and error codes.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _AFPCONST_
#define _AFPCONST_

/* The real AFP Function codes */
#define	AFP_BYTE_RANGE_LOCK			0x01
#define	AFP_CLOSE_VOL				0x02
#define	AFP_CLOSE_DIR				0x03
#define	AFP_CLOSE_FORK				0x04
#define	AFP_COPY_FILE				0x05
#define	AFP_CREATE_DIR				0x06
#define	AFP_CREATE_FILE			 	0x07
#define	AFP_DELETE					0x08
#define	AFP_ENUMERATE				0x09
#define	AFP_FLUSH					0x0A
#define	AFP_FLUSH_FORK				0x0B
/*************		0C-0D ARE UNDEFINED	*************/
#define	AFP_GET_FORK_PARMS			0x0E
#define	AFP_GET_SRVR_INFO			0x0F
#define	AFP_GET_SRVR_PARMS			0x10
#define	AFP_GET_VOL_PARMS			0x11
#define	AFP_LOGIN					0x12
#define	AFP_LOGIN_CONT				0x13
#define	AFP_LOGOUT					0x14
#define	AFP_MAP_ID					0x15
#define	AFP_MAP_NAME				0x16
#define	AFP_MOVE_AND_RENAME		 	0x17
#define	AFP_OPEN_VOL				0x18
#define	AFP_OPEN_DIR				0x19
#define	AFP_OPEN_FORK				0x1A
#define	AFP_READ					0x1B
#define	AFP_RENAME					0x1C
#define	AFP_SET_DIR_PARMS			0x1D
#define	AFP_SET_FILE_PARMS			0x1E
#define	AFP_SET_FORK_PARMS			0x1F
#define	AFP_SET_VOL_PARMS			0x20
#define	AFP_WRITE					0x21
#define	AFP_GET_FILE_DIR_PARMS		0x22
#define	AFP_SET_FILE_DIR_PARMS		0x23
#define	AFP_CHANGE_PASSWORD		 	0x24
#define	AFP_GET_USER_INFO			0x25
#define	AFP_GET_SRVR_MSG			0x26
#define	AFP_CREATE_ID				0x27
#define	AFP_DELETE_ID				0x28
#define	AFP_RESOLVE_ID				0x29
#define	AFP_EXCHANGE_FILES			0x2A
#define	AFP_CAT_SEARCH				0x2B
/*************	2C-2F ARE UNDEFINED	*************/
#define	AFP_OPEN_DT				 	0x30
#define	AFP_CLOSE_DT				0x31
/*************	32 IS UNDEFINED	*************/
#define	AFP_GET_ICON				0x33
#define	AFP_GET_ICON_INFO			0x34
#define	AFP_ADD_APPL				0x35
#define	AFP_REMOVE_APPL			 	0x36
#define	AFP_GET_APPL				0x37
#define	AFP_ADD_COMMENT			 	0x38
#define	AFP_REMOVE_COMMENT			0x39
#define	AFP_GET_COMMENT			 	0x3A
/*************	3B-BF ARE UNDEFINED	*************/
#define	AFP_ADD_ICON				0xC0
/*************	C1-FE ARE UNDEFINED	*************/
#define	AFF_GET_DOMAIN_LIST			0xFF



/* AFP Error codes */

#define	AFP_ERR_NONE					0
#define	AFP_ERR_BASE				(-5000)
#define	AFP_ERR_ACCESS_DENIED		(AFP_ERR_BASE-0)
#define	AFP_ERR_AUTH_CONTINUE		(AFP_ERR_BASE-1)
#define	AFP_ERR_BAD_UAM				(AFP_ERR_BASE-2)
#define	AFP_ERR_BAD_VERSION			(AFP_ERR_BASE-3)
#define	AFP_ERR_BITMAP				(AFP_ERR_BASE-4)
#define	AFP_ERR_CANT_MOVE			(AFP_ERR_BASE-5)
#define	AFP_ERR_DENY_CONFLICT		(AFP_ERR_BASE-6)
#define	AFP_ERR_DIR_NOT_EMPTY		(AFP_ERR_BASE-7)
#define	AFP_ERR_DISK_FULL			(AFP_ERR_BASE-8)
#define	AFP_ERR_EOF					(AFP_ERR_BASE-9)
#define	AFP_ERR_FILE_BUSY			(AFP_ERR_BASE-10)
#define	AFP_ERR_FLAT_VOL			(AFP_ERR_BASE-11)
#define	AFP_ERR_ITEM_NOT_FOUND		(AFP_ERR_BASE-12)
#define	AFP_ERR_LOCK				(AFP_ERR_BASE-13)
#define	AFP_ERR_MISC				(AFP_ERR_BASE-14)
#define	AFP_ERR_NO_MORE_LOCKS		(AFP_ERR_BASE-15)
#define	AFP_ERR_NO_SERVER			(AFP_ERR_BASE-16)
#define	AFP_ERR_OBJECT_EXISTS		(AFP_ERR_BASE-17)
#define	AFP_ERR_OBJECT_NOT_FOUND	(AFP_ERR_BASE-18)
#define	AFP_ERR_PARAM				(AFP_ERR_BASE-19)
#define	AFP_ERR_RANGE_NOT_LOCKED	(AFP_ERR_BASE-20)
#define	AFP_ERR_RANGE_OVERLAP		(AFP_ERR_BASE-21)
#define	AFP_ERR_SESS_CLOSED			(AFP_ERR_BASE-22)
#define	AFP_ERR_USER_NOT_AUTH		(AFP_ERR_BASE-23)
#define	AFP_ERR_CALL_NOT_SUPPORTED	(AFP_ERR_BASE-24)
#define	AFP_ERR_OBJECT_TYPE			(AFP_ERR_BASE-25)
#define	AFP_ERR_TOO_MANY_FILES_OPEN	(AFP_ERR_BASE-26)
#define	AFP_ERR_SERVER_GOING_DOWN	(AFP_ERR_BASE-27)
#define	AFP_ERR_CANT_RENAME			(AFP_ERR_BASE-28)
#define	AFP_ERR_DIR_NOT_FOUND		(AFP_ERR_BASE-29)
#define	AFP_ERR_ICON_TYPE			(AFP_ERR_BASE-30)
#define	AFP_ERR_VOLUME_LOCKED		(AFP_ERR_BASE-31)
#define	AFP_ERR_OBJECT_LOCKED		(AFP_ERR_BASE-32)
/*************	-5033 IS Undefined	*************/
#define	AFP_ERR_ID_NOT_FOUND		(AFP_ERR_BASE-34)
#define	AFP_ERR_ID_EXISTS			(AFP_ERR_BASE-35)
#define	AFP_ERR_DIFF_VOL			(AFP_ERR_BASE-36)	// AfpExchangeFiles
#define	AFP_ERR_CATALOG_CHANGED		(AFP_ERR_BASE-37)	// AfpCatSearch
#define	AFP_ERR_SAME_OBJECT			(AFP_ERR_BASE-38)	// AfpExchangeFiles
#define	AFP_ERR_BAD_ID				(AFP_ERR_BASE-39)
#define	AFP_ERR_PWD_SAME			(AFP_ERR_BASE-40)
#define	AFP_ERR_PWD_TOO_SHORT		(AFP_ERR_BASE-41)
#define	AFP_ERR_PWD_EXPIRED			(AFP_ERR_BASE-42)
#define	AFP_ERR_INSIDE_SHARE		(AFP_ERR_BASE-43)	// Specific to AppleShare
#define	AFP_ERR_INSIDE_TRASH		(AFP_ERR_BASE-44)	// Specific to AppleShare
#define	AFP_ERR_PWD_NEEDS_CHANGE	(AFP_ERR_BASE-45)	// Specific to AppleShare

// The following error codes are used internally and never returned to the
// client.
#define	AFP_ERR_QUEUE				-7000
#define	AFP_ERR_DEFER				-7001
#define AFP_ERR_WRITE_LOCK_REQUIRED -7002
#define	AFP_ERR_EXTENDED			-7003
#define	AFP_ERR_REQUEUE				-7004


// The following codes are used with the custom UAM to indicate exact
// reasons for logon failures and change password failures
#define	AFP_ERR_EXTENDED_ERRORS			-13000
#define	AFP_ERR_ACCOUNT_DISABLED		-13002
#define	AFP_ERR_INVALID_WORKSTATION		-13003
#define	AFP_ERR_INVALID_LOGON_HOURS		-13004
#define	AFP_ERR_PASSWORD_EXPIRED		-13005
#define	AFP_ERR_PASSWORD_CANT_CHANGE	-13006
#define	AFP_ERR_PASSWORD_HIST_CONFLICT	-13007  	
#define	AFP_ERR_PASSWORD_TOO_SHORT		-13008
#define	AFP_ERR_PASSWORD_TOO_RECENT		-13009
#define	AFP_ERR_PASSWORD_RESTRICTED		-13010
#define	AFP_ERR_ACCOUNT_RESTRICTED		-13011

// The following error is returned from a logon when the LsaLogonUser
// call returns STATUS_LICENSE_QUOTA_EXCEEDED.  The mac will map this
// to the correct dialog no matter what UAM is used.
#define ASP_SERVER_BUSY					-1071


// This is GROSS but we need to do it. Else we get TONS of warnings
#define	True		(BOOLEAN)TRUE
#define	False		(BOOLEAN)FALSE

typedef	LONG			AFPSTATUS;
typedef	LONG			AFPTIME, *PAFPTIME;
typedef	LARGE_INTEGER	FORKOFFST, *PFORKOFFST;
typedef	LARGE_INTEGER	FORKSIZE, *PFORKSIZE;

#ifndef	DWORD
typedef	ULONG			DWORD;
typedef	DWORD			*PDWORD;
typedef	DWORD			*LPDWORD;
#endif
#ifndef	BYTE
typedef	UCHAR			BYTE;
typedef	BYTE			*PBYTE;
typedef	BYTE			*LPBYTE;
#endif

/*
 * The following macros deal with on-the-wire integer and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04. Similarly an int value of 0x0102 is
 * represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = (USHORT) (*(PBYTE)(SrcPtr))

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2DWORD(DstPtr, SrcPtr)	\
		*(PDWORD)(DstPtr) = (DWORD) (*(PBYTE)(SrcPtr))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2DWORD(DstPtr, SrcPtr)	\
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2SHORT(DstPtr, SrcPtr)	\
		*(PUSHORT)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +	\
							  (*((PBYTE)(SrcPtr)+1)		))

// Get a dword from on-the-wire format to a dword in the host format
#define GETDWORD2DWORD(DstPtr, SrcPtr)   \
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 24) + \
							  (*((PBYTE)(SrcPtr)+1) << 16) + \
							  (*((PBYTE)(SrcPtr)+2) << 8)  + \
							  (*((PBYTE)(SrcPtr)+3)	))

// Get a dword from on-the-wire format to a dword in the same format but
// also watch out for alignment
#define GETDWORD2DWORD_NOCONV(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0); \
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1); \
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2); \
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3);

// Put a dword from the host format to a short to on-the-wire format
#define PUTBYTE2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2BYTE(DstPtr, Src)   \
		*((PBYTE)(DstPtr)) = ((USHORT)(Src) % 256)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((USHORT)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE)(Src)

// Put a dword from the host format to a byte to on-the-wire format
#define PUTDWORD2BYTE(DstPtr, Src)   \
		*(PBYTE)(DstPtr) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTDWORD2SHORT(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 8), \
		*((PBYTE)(DstPtr)+1) = (BYTE) (Src)

// Put a dword from the host format to a dword to on-the-wire format
#define PUTDWORD2DWORD(DstPtr, Src)   \
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 24), \
		*((PBYTE)(DstPtr)+1) = (BYTE) ((DWORD)(Src) >> 16), \
		*((PBYTE)(DstPtr)+2) = (BYTE) ((DWORD)(Src) >>  8), \
		*((PBYTE)(DstPtr)+3) = (BYTE) (Src)

// Put a BYTE[4] array into another BYTE4 array.
#define PUTBYTE42BYTE4(DstPtr, SrcPtr)   \
		*((PBYTE)(DstPtr)+0) = *((PBYTE)(SrcPtr)+0),	\
		*((PBYTE)(DstPtr)+1) = *((PBYTE)(SrcPtr)+1),	\
		*((PBYTE)(DstPtr)+2) = *((PBYTE)(SrcPtr)+2),	\
		*((PBYTE)(DstPtr)+3) = *((PBYTE)(SrcPtr)+3)

/* AFP Miscellaneous values */

#define	AFP_SHORTNAME				1
#define	AFP_LONGNAME				2
#define	VALIDPATHTYPE(PathType)	\
			(PathType == AFP_LONGNAME || PathType == AFP_SHORTNAME)

#define AFP_HARDCREATE_FLAG			0x80

#define	AFP_VOLUMES_MAX				255	// Count of volumes that fit in a byte
#define	AFP_FILENAME_LEN			31	// Maximum file name length
#define	AFP_SHORTNAME_LEN			12	// 8.3
#define	AFP_LONGNAME_LEN			31
#define	AFP_MAXCOMMENTSIZE			199
#define	AFP_MAXPWDSIZE				8	// Cleartext password length
#define	BEGINNING_OF_TIME 			0x80000000
#define	DAYS_FROM_1980_2000			7305L			// (20*365 + 5)
#define	SECONDS_PER_DAY				86400L			// 24*60*60
#define	SECONDS_FROM_1980_2000		SECONDS_PER_DAY * DAYS_FROM_1980_2000
#define	NUM_100ns_PER_SECOND		10000000L

#define	ASP_MAX_STATUS_BUF			512
#define	ASP_QUANTUM					4624

#define AFP_SERVER_SIGNATURE		*(PDWORD)"AFP"
#define AFP_SERVER_SIGNATURE_INITIDDB		*(PDWORD)"INI"
#define AFP_SERVER_SIGNATURE_MANUALSTOP		*(PDWORD)"MAN"
#define	AFP_SERVER_VERSION			0x00010000
#define	AFP_SERVER_VERSION2			0x00020000

// AFP Version strings and values
#define	AFP_NUM_VERSIONS			3
#define	AFP_VER_20					0
#define	AFP_VER_20_NAME				"AFPVersion 2.0"
#define	AFP_VER_21					1
#define	AFP_VER_21_NAME				"AFPVersion 2.1"
#define	AFP_VER_22					2
#define	AFP_VER_22_NAME				"AFP2.2"

// Name to use for the Logon Process
#define	AFP_LOGON_PROCESS_NAME		"MSAfpSrv"

#define	AFP_MACHINE_TYPE_STR		"Windows NT"
#define	AFP_MACHINE_TYPE_LEN		sizeof(AFP_MACHINE_TYPE_STR) - 1
#define	AFP_DEFAULT_WORKSTATION		L"Macintosh"
#define	AFP_DEFAULT_WORKSTATION_A	"Macintosh"

#define AFPSERVER_VOLUME_ICON_FILE_ANSI {'I','C','O','N', 0x0D}

#define AFP_ID_PARENT_OF_ROOT		1
#define AFP_ID_ROOT					2
#define AFP_ID_NETWORK_TRASH		3
#define AFP_FIRST_DIRID				4
#define AFP_MAX_DIRID				MAXULONG

// NTFS Stream names
#define AFP_IDDB_STREAM				L":AFP_IdIndex"
#define AFP_DT_STREAM				L":AFP_DeskTop"
#define	AFP_RESC_STREAM				L":AFP_Resource"
#define	AFP_INFO_STREAM				L":AFP_AfpInfo"
#define	AFP_COMM_STREAM				L":Comments"
#define	AFP_DATA_STREAM				L""
#define	AFP_MAX_STREAMNAME			sizeof(AFP_RESC_STREAM)/sizeof(WCHAR)
#define	BIG_PATH_LEN				(4*(AFP_FILENAME_LEN + 1))

#define FULL_DATA_STREAM_NAME		L"::$DATA"
#define FULL_COMMENT_STREAM_NAME	L":Comments:$DATA"
#define FULL_RESOURCE_STREAM_NAME	L":AFP_Resource:$DATA"
#define FULL_INFO_STREAM_NAME		L":AFP_AfpInfo:$DATA"


// Supported file system names
#define AFP_NTFS					L"NTFS"
#define AFP_CDFS					L"CDFS"
#define AFP_AHFS					L"AHFS"

// Length of unicode string Buffer to send when querying the FS name
#define AFP_FSNAME_BUFLEN			30

#if DBG
#define	POOL_OVERHEAD		(12+8)		// 12 for AfpAllocMemory() & 8 for ExAllocatePool()
#else
#define	POOL_OVERHEAD		(8+8)		// 8 for AfpAllocMemory() & 8 for ExAllocatePool()
#endif

// Length of buffer to use for enumeration of directories
#define AFP_ENUMBUF_SIZE			(16*1024)

// Prepended to full path of volume root in order to open the volume root dir
#define AFP_DOSDEVICES				L"\\DOSDEVICES\\"

// Name of the Macintosh System 7.x network trash directory
#define AFP_NWTRASH_NAME			L"Network Trash Folder"
#define AFP_NWTRASH_NAME_U			L"Network Trash Folder"
#define AFP_NWTRASH_NAME_A			"Network Trash Folder"

// Default Type/Creator and Extensions
#define	AFP_DEFAULT_ETC_EXT			"*  "
#define	AFP_DEFAULT_ETC_CREATOR		"LMAN"
#define	AFP_DEFAULT_ETC_TYPE		"TEXT"

#define	AFP_MAX_ETCMAP_ENTRIES		MAXLONG
#define AFP_MAX_FREE_ETCMAP_ENTRIES	16


#define	AFP_SERVER_TYPE				"AFPServer"
#define	AFP_SERVER_ZONE				"*"


typedef	struct _PascalString
{
	BYTE	ps_Length;
	BYTE	ps_String[1];
} *PASCALSTR;

#define	SIZE_PASCALSTR(Len)	((Len) + sizeof(struct _PascalString) - 1)

typedef struct _AfpPathString
{
	BYTE	aps_PathType;
	BYTE	aps_Length;
	BYTE	aps_Path[1];
} *AFPPATHSTR;


// Mac Finder Information layout

// see pg. 9-37 of Inside Macintosh vol. 6
#define	FINDER_FLAG_INVISIBLE		0x40		// fd_Attr1
#define	FINDER_FLAG_SET				0x01		// fd_Attr1
#define FINDER_FLAG_HAS_CUSTOM_ICON 0x04	    // fd_Attr1

#define FINDER_INFO_SIZE			32
typedef struct _FinderInfo
{
	// Force DWORD alignment
	union
	{
		BYTE	fd_Type[4];
		DWORD	fd_TypeD;
	};
	union
	{
		BYTE	fd_Creator[4];
		DWORD	fd_CreatorD;
	};
	BYTE	fd_Attr1;			// Bits 8-15
	BYTE	fd_Attr2;			// Bits 0-7
	BYTE	fd_Location[4];
	BYTE	fd_FDWindow[2];
	BYTE	fd_OtherStuff[16];
} FINDERINFO, *PFINDERINFO;

// Apple-II (ProDOS) information.

// default values for newly discovered items
#define	PRODOS_TYPE_FILE	0x04	// corresponds to finder fdType 'TEXT'
#define PRODOS_TYPE_DIR		0x0F
#define PRODOS_AUX_DIR		0x02	// actually 0x0200

// some other finder fdType to prodos FileType mapping values
#define PRODOS_FILETYPE_PSYS	0xFF
#define PRODOS_FILETYPE_PS16	0xB3

#define PRODOS_INFO_SIZE			6
typedef struct
{
	BYTE pd_FileType[2];
	BYTE pd_AuxType[4];
} PRODOSINFO, *PPRODOSINFO;

#endif	// _AFPCONST_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\admin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    admin.c

Abstract:

    This module implements the top level admin request routines. All
    routines within this module execute in the context of the server
    service (or equivalent calling user mode process).

    A routine that can complete an entire admin request
    in the caller's context will return an appropriate AFP error to
    the admin dispatch layer above.

    A routine that must queue a worker to the FSP Admin queue will return
    STATUS_PENDING to the admin dispatch layer above. This will indicate
    to the dispatch layer that it should queue up the appropriate request.
    In these cases, the routine's job is to merely validate any appropriate
    input and return the STATUS_PENDING error code.

Author:

    Sue Adams (microsoft!suea)

Revision History:
    25 Jun 1992     Initial Version

--*/

#define FILENUM FILE_ADMIN

#include <afp.h>
#include <afpadmin.h>
#include <secutil.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <access.h>
#include <secutil.h>
#include <gendisp.h>

// This is the duration that we sleep before rescanning for the enumerate apis
#define AFP_SLEEP_TIMER_TICK    -(1*NUM_100ns_PER_SECOND/100)   // 10ms

LOCAL
NTSTATUS
afpConvertAdminPathToMacPath(
    IN  PVOLDESC        pVolDesc,
    IN  PUNICODE_STRING AdminPath,
    OUT PANSI_STRING    MacPath
);

LOCAL
PETCMAPINFO
afpGetNextFreeEtcMapEntry(
    IN OUT PLONG    StartIndex
);

LOCAL
VOID
afpEtcMapDelete(
    PETCMAPINFO pEtcEntry
);

LOCAL
NTSTATUS
afpCopyMapInfo2ToMapInfo(
    OUT PETCMAPINFO     pEtcDest,
    IN  PETCMAPINFO2    pEtcSource
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpAdminDeInit)
#pragma alloc_text( PAGE, AfpSleepAWhile)
#pragma alloc_text( PAGE, AfpAdmServiceStart)
#pragma alloc_text( PAGE, AfpAdmServiceStop)
#pragma alloc_text( PAGE, AfpAdmServicePause)
#pragma alloc_text( PAGE, AfpAdmServiceContinue)
#pragma alloc_text( PAGE, AfpAdmServerGetInfo)
#pragma alloc_text( PAGE, AfpAdmClearProfCounters)
#pragma alloc_text( PAGE, AfpAdmServerSetParms)
#pragma alloc_text( PAGE, AfpAdmServerAddEtc)
#pragma alloc_text( PAGE, AfpAdmServerSetEtc)
#pragma alloc_text( PAGE, AfpAdmServerDeleteEtc)
#pragma alloc_text( PAGE, AfpAdmServerAddIcon)
#pragma alloc_text( PAGE, AfpAdmVolumeAdd)
#pragma alloc_text( PAGE, AfpAdmWDirectoryGetInfo)
#pragma alloc_text( PAGE, AfpAdmWDirectorySetInfo)
#pragma alloc_text( PAGE, AfpAdmWFinderSetInfo)
#pragma alloc_text( PAGE, AfpLookupEtcMapEntry)
#pragma alloc_text( PAGE, afpEtcMapDelete)
#pragma alloc_text( PAGE, afpGetNextFreeEtcMapEntry)
#pragma alloc_text( PAGE, afpConvertAdminPathToMacPath)
#pragma alloc_text( PAGE_AFP, AfpAdmGetStatistics)
#pragma alloc_text( PAGE_AFP, AfpAdmClearStatistics)
#pragma alloc_text( PAGE_AFP, AfpAdmGetProfCounters)
#pragma alloc_text( PAGE_AFP, AfpAdmVolumeGetInfo)
#pragma alloc_text( PAGE_AFP, AfpAdmVolumeSetInfo)
#pragma alloc_text( PAGE_AFP, AfpAdmVolumeEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmSessionEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmConnectionEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmForkEnum)
#pragma alloc_text( PAGE_AFP, AfpAdmMessageSend)
#endif

//
// macro to ensure that the extension in a type/creator mapping is padded
// with nulls by the server service so we don't end up in la-la land on a
// lookup by extension
//
#define afpIsValidExtension(ext)    (((ext)[AFP_EXTENSION_LEN] == '\0') && \
                                     ((ext)[0] != '\0') )

//
// invalid entries in AfpEtcMaps table are denoted by a null extension field
//
#define afpIsValidEtcMapEntry(ext)  ((ext)[0] != '\0')

#define afpCopyEtcMap(pdst,psrc)    (RtlCopyMemory(pdst,psrc,sizeof(ETCMAPINFO)))

#define afpIsServerIcon(picon)      ((picon)->icon_icontype == 0)


/***    AfpAdminDeInit
 *
 *  De-initialize the data structures for admin APIs.
 */
VOID
AfpAdminDeInit(
    VOID
)
{
    PAGED_CODE( );

    // Free memory for server icon
    if (AfpServerIcon != NULL)
        AfpFreeMemory(AfpServerIcon);

    // Free memory used for global icons
    AfpFreeGlobalIconList();

    // Free memory used for ETC mappings
    if (AfpEtcMaps != NULL)
    {
        AfpFreeMemory(AfpEtcMaps);
    }

    // Free memory used for server name
    if (AfpServerName.Buffer != NULL)
    {
        AfpFreeMemory(AfpServerName.Buffer);
    }

    // Free any Server/Login Messages
    if (AfpServerMsg != NULL)
    {
        AfpFreeMemory(AfpServerMsg);
    }

    if (AfpLoginMsg.Buffer != NULL)
    {
        AfpFreeMemory(AfpLoginMsg.Buffer);
    }

    if (AfpLoginMsgU.Buffer != NULL)
    {
        AfpFreeMemory(AfpLoginMsgU.Buffer);
    }

    // Free the memory allocated for the admin sid
    if (AfpSidAdmins != NULL)
        AfpFreeMemory(AfpSidAdmins);

    // Free the memory allocated for the None sid (standalone only)
    if (AfpSidNone != NULL)
        AfpFreeMemory(AfpSidNone);
}



/***    AfpSleepAWhile
 *
 *  Sleep for a multiple of AFP_SLEEP_TIMER_TICK ticks.
 */
VOID
AfpSleepAWhile(
    IN  DWORD   SleepDuration
)
{
    KTIMER          SleepTimer;
    LARGE_INTEGER   TimerValue;

    PAGED_CODE( );

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    KeInitializeTimer(&SleepTimer);

    TimerValue.QuadPart = (SleepDuration * AFP_SLEEP_TIMER_TICK);
    KeSetTimer(&SleepTimer,
               TimerValue,
               NULL);

    AfpIoWait(&SleepTimer, NULL);
}



/***    AfpAdmServiceStart
 *
 *  This is the service start code. The following is done as part of the service
 *  startup.
 *
 *  Registration of NBP Name.
 *  Posting listens
 *  And finally the server status block is set.
 */
AFPSTATUS
AfpAdmServiceStart(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    AFPSTATUS   Status = AFP_ERR_NONE;

    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
            ("AfpAdmServiceStart entered\n"));

    do
    {
        // make sure serversetinfo has been called
        if ((AfpServerState != AFP_STATE_IDLE) ||
            (AfpServerName.Length == 0))
        {
            Status = AFPERR_InvalidServerState;
            break;
        }

        AfpServerState = AFP_STATE_START_PENDING;

        if (AfpServerBoundToAsp || AfpServerBoundToTcp)
        {
            // Det the server status block
            Status = AfpSetServerStatus();

            if (!NT_SUCCESS(Status))
            {
                DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                    ("AfpAdmServiceStart: AfpSetServerStatus returned %lx\n",Status));
                AFPLOG_ERROR(AFPSRVMSG_SET_STATUS, Status, NULL, 0, NULL);
                break;
            }

            if (AfpServerBoundToAsp)
            {
                // Register our name on this address
                Status = AfpSpRegisterName(&AfpServerName, True);

                if (!NT_SUCCESS(Status))
                {
                    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                        ("AfpAdmServiceStart: AfpSpRegisterName returned %lx\n",Status));
                    break;
                }
            }

            // Enable listens now that we are ready for it.
            AfpSpEnableListens();

            // Set the server start time
            AfpGetCurrentTimeInMacFormat((PAFPTIME)&AfpServerStatistics.stat_ServerStartTime);
        }

        // server is ready to go
        AfpServerState = AFP_STATE_RUNNING;

    } while (False);

    if (!NT_SUCCESS(Status))
    {
        AfpServerState = AFP_STATE_IDLE;    // Set state back to idle so we can be stopped
    }
    else
    {
        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR, ("SFM Service started\n"));
    }

    return Status;
}


/***    AfpAdmServiceStop
 *
 *  This is the service stop code.
 */
AFPSTATUS
AfpAdmServiceStop(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    NTSTATUS            Status;
    AFP_SESSION_INFO    SessInfo;

    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
            ("AfpAdmServiceStop entered\n"));

    do
    {
        if ((AfpServerState != AFP_STATE_RUNNING) &&
            (AfpServerState != AFP_STATE_PAUSED)  &&
            (AfpServerState != AFP_STATE_IDLE))
        {
            Status = AFPERR_InvalidServerState;
            break;
        }

        AfpServerState = AFP_STATE_STOP_PENDING;

        if (AfpServerBoundToAsp)
        {
            // First de-register our name from the network
            DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
                        ("AfpAdmServiceStop: De-registering Name\n"));
            AfpSpRegisterName(&AfpServerName, False);

            if (AfpTdiNotificationHandle)
            {
                Status = TdiDeregisterPnPHandlers(AfpTdiNotificationHandle);

                if (!NT_SUCCESS(Status))
                {
                    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                        ("AfpAdmServiceStop: TdiDeregisterNotificationHandler failed with %lx\n",Status));
                }

                AfpTdiNotificationHandle = NULL;
            }
            else
            {
                DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                    ("AfpAdmServiceStop: BoundToAsp but no Tdi handle!!\n"));
                ASSERT(0);
            }
        }

        // Disable listens now that we are about to stop
        AfpSpDisableListens();

        // De-register our shutdown notification
        IoUnregisterShutdownNotification(AfpDeviceObject);

        // Now walk the list of active sessions and kill them
        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
                    ("AfpAdmServiceStop: Shutting down sessions\n"));

        KeClearEvent(&AfpStopConfirmEvent);

        SessInfo.afpsess_id = 0;    // Shutdown all sessions
        AfpAdmWSessionClose(&SessInfo, 0, NULL);

        Status = STATUS_TIMEOUT;

        // Wait for the sessions to complete, if there were active sessions
        if (AfpNumSessions > 0) do
        {
            if (AfpNumSessions == 0)
            {
                break;
            }

            Status = AfpIoWait(&AfpStopConfirmEvent, &FiveSecTimeOut);
            if (Status == STATUS_TIMEOUT)
            {
                DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                        ("AfpAdmServiceStop: Timeout Waiting for %ld sessions to die, re-waiting\n",
                        AfpNumSessions));
            }
        } while (Status == STATUS_TIMEOUT);

        // bring down the DSI-TCP interface
        DsiDestroyAdapter();

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
            ("AfpAdmServiceStop: blocked, waiting for DsiDestroyAdapter to finish...\n"));

        // wait until DSI cleans up its interface with TCP
        AfpIoWait(&DsiShutdownEvent, NULL);

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
            ("AfpAdmServiceStop: ..... DsiDestroyAdapter finished.\n"));

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
                    ("AfpAdmServiceStop: Stopping Volumes\n"));

        // Set flag to indicate "net stop macfile" occured
        // The volume will be re-indexed on startup
        fAfpAdminStop = TRUE;

        // Now tell each of the volume scavengers to shut-down
        AfpVolumeStopAllVolumes();

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
                    ("AfpAdmServiceStop: Stopping Security threads\n"));

        // Release all security utility threads.
        AfpTerminateSecurityUtility();

#ifdef  OPTIMIZE_GUEST_LOGONS
        // Close the 'cached' Guest token and security descriptor
        if (AfpGuestToken != NULL)
        {
            NtClose(AfpGuestToken);
            AfpGuestToken = NULL;
#ifndef INHERIT_DIRECTORY_PERMS
            if (AfpGuestSecDesc->Dacl != NULL)
                AfpFreeMemory(AfpGuestSecDesc->Dacl);
            AfpFreeMemory(AfpGuestSecDesc);
            AfpGuestSecDesc = NULL;
#endif
        }
#endif

        DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
                    ("AfpAdmServiceStop: All Done\n"));

        // Now shutdown the appletalk socket
        DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_INFO,
                        ("AfpAdmServerStop: Closing appletalk socket\n"));

        if (AfpServerBoundToAsp)
        {
            AfpSpCloseAddress();
        }
        else
        {
            DBGPRINT(DBG_COMP_ADMINAPI, DBG_LEVEL_ERR,
                        ("AfpAdmServerStop: No binding, so didn't close appletalk socket\n"));
        }

        // Make sure we do not have resource leaks
        ASSERT(AfpServerStatistics.stat_CurrentFileLocks == 0);
        ASSERT(AfpServerStatistics.stat_CurrentFilesOpen == 0);
        ASSERT(AfpServerStatistics.stat_CurrentSessions == 0);
        ASSERT(AfpServerStatistics.stat_CurrentInternalOpens == 0);
#ifdef  PROFILING
        // Make sure we do not have resource leaks
        ASSERT(AfpServerProfile->perf_cAllocatedIrps == 0);
        ASSERT(AfpServerProfile->perf_cAllocatedMdls == 0);
#endif

        ASSERT(IsListEmpty(&AfpDebugDelAllocHead));
        ASSERT(AfpDbgMdlsAlloced == 0);
        ASSERT(AfpDbgIrpsAlloced == 0);

#if DBG
        if ((AfpReadCMAlloced != 0) || (AfpWriteCMAlloced != 0))
        {
            DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                ("WARNING: AfpReadCMAlloced = %ld, AfpWriteCMAlloced %ld\n",
                AfpReadCMAlloced, AfpWriteCMAlloced));
        }
#endif

        AfpServerState = AFP_STATE_STOPPED;
    } while (False);

    return STATUS_SUCCESS;
}


/***    AfpAdmServicePause
 *
 *  Pause the server. Disconnect all outstanding sessions.
 */
AFPSTATUS
AfpAdmServicePause(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
            ("AfpAdmServicePause entered\n"));

    // make sure we are in the running state
    if (AfpServerState != AFP_STATE_RUNNING)
    {
        return AFPERR_InvalidServerState;
    }

    AfpServerState = AFP_STATE_PAUSE_PENDING;

    if (AfpServerBoundToAsp)
    {
        // Deregister our name on this address. Should we do this at all ? What
        // if we cannot re-register ourselves on CONTINUE ?
        AfpSpRegisterName(&AfpServerName, False);
    }

    // Disable listens now that we are paused
    AfpSpDisableListens();

    AfpServerState = AFP_STATE_PAUSED;


    return STATUS_SUCCESS;
}


/***    AfpAdmServiceContinue
 *
 *  Continue (release pause) the server. Just re-post all the listens that were
 *  disconnected when the server was paused.
 */
AFPSTATUS
AfpAdmServiceContinue(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    AFPSTATUS   Status;

    DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_INFO,
            ("AfpAdmServiceContinue entered\n"));

    // make sure we are in the paused state
    if (AfpServerState != AFP_STATE_PAUSED)
    {
        return AFPERR_InvalidServerState;
    }

    AfpServerState = AFP_STATE_RUNNING;

    // Enable listens now that we are ready for it.
    AfpSpEnableListens();

    if (AfpServerBoundToAsp)
    {
        // Reregister our name on this address
        Status = AfpSpRegisterName(&AfpServerName, True);

        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_ADMINAPI_SC, DBG_LEVEL_ERR,
                ("AfpAdmServiceContinue: AfpSpRegisterName fails %lx\n",Status));
            return AFPERR_InvalidServerName;
        }
    }

    return STATUS_SUCCESS;
}


/***    AfpAdmServerGetInfo
 *
 *  Return the current setting of the server parameters.
 *
 *  NOTE: The following fields are not returned:
 *      PagedLimit
 *      NonPagedLimit
 *      CodePage
 */
AFPSTATUS
AfpAdmServerGetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PAFP_SERVER_INFO    pSrvrInfo = (PAFP_SERVER_INFO)OutBuf;
    UNICODE_STRING      us;

    if ((DWORD)OutBufLen < (sizeof(AFP_SERVER_INFO) +
                     (AfpServerName.Length + 1)*sizeof(WCHAR) +
                     AfpLoginMsgU.MaximumLength))
        return AFPERR_BufferSize;

    pSrvrInfo->afpsrv_max_sessions = AfpServerMaxSessions;
    pSrvrInfo->afpsrv_options = AfpServerOptions;
    pSrvrInfo->afpsrv_name = NULL;
    pSrvrInfo->afpsrv_login_msg = NULL;

    if (AfpServerName.Length > 0)
    {
        pSrvrInfo->afpsrv_name = us.Buffer =
            (LPWSTR)((PBYTE)pSrvrInfo + sizeof(AFP_SERVER_INFO));
        us.MaximumLength = (AfpServerName.Length + 1) * sizeof(WCHAR);
        AfpConvertStringToUnicode(&AfpServerName, &us);
        POINTER_TO_OFFSET(pSrvrInfo->afpsrv_name, pSrvrInfo);
    }


    if ((AfpLoginMsgU.Length) > 0)
    {
        pSrvrInfo->afpsrv_login_msg = (PWCHAR)((PBYTE)pSrvrInfo + sizeof(AFP_SERVER_INFO) +
                                    ((AfpServerName.Length + 1) * sizeof(WCHAR)));

        RtlCopyMemory(pSrvrInfo->afpsrv_login_msg,
                      AfpLoginMsgU.Buffer,
                      AfpLoginMsgU.Length);
        pSrvrInfo->afpsrv_login_msg[AfpLoginMsgU.Length/sizeof(WCHAR)] = UNICODE_NULL;
        POINTER_TO_OFFSET(pSrvrInfo->afpsrv_login_msg, pSrvrInfo);
    }

    return AFP_ERR_NONE;
}


/***    AfpAdmGetStatistics
 *
 *  Return a copy of the server global statistics (NT 3.1 only) in the output buffer
 *
 *  LOCKS:  AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpAdmGetStatistics(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    KIRQL       OldIrql;
    NTSTATUS    Status = STATUS_SUCCESS;
    AFPTIME     TimeNow;

    InBuf;

    DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
            ("AfpAdmGetStatistics entered\n"));

    if (OutBufLen >= sizeof(AFP_STATISTICS_INFO))
    {
        ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
        RtlCopyMemory(OutBuf, &AfpServerStatistics, sizeof(AFP_STATISTICS_INFO));
        RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

        AfpGetCurrentTimeInMacFormat(&TimeNow);
        ((PAFP_STATISTICS_INFO)OutBuf)->stat_ServerStartTime =
                TimeNow - ((PAFP_STATISTICS_INFO)OutBuf)->stat_ServerStartTime;
        ((PAFP_STATISTICS_INFO)OutBuf)->stat_TimeStamp =
                TimeNow - ((PAFP_STATISTICS_INFO)OutBuf)->stat_TimeStamp;
    }
    else
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    return Status;
}


/***    AfpAdmGetStatisticsEx
 *
 *  Return a copy of the server global statistics in the output buffer
 *
 *  LOCKS:  AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpAdmGetStatisticsEx(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    KIRQL       OldIrql;
    NTSTATUS    Status = STATUS_SUCCESS;
    AFPTIME     TimeNow;

    InBuf;

    DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
            ("AfpAdmGetStatistics entered\n"));

    if (OutBufLen >= sizeof(AFP_STATISTICS_INFO_EX))
    {
        ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
        RtlCopyMemory(OutBuf, &AfpServerStatistics, sizeof(AFP_STATISTICS_INFO_EX));

        RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

        AfpGetCurrentTimeInMacFormat(&TimeNow);
        ((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_ServerStartTime =
                TimeNow - ((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_ServerStartTime;
        ((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_TimeStamp =
                TimeNow - ((PAFP_STATISTICS_INFO_EX)OutBuf)->stat_TimeStamp;
    }
    else
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    return Status;
}


/***    AfpAdmClearStatistics
 *
 *  Reset the server global statistics to their respective initial values
 */
AFPSTATUS
AfpAdmClearStatistics(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    KIRQL   OldIrql;

    DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
            ("AfpAdmClearStatistics entered\n"));

    ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
    AfpServerStatistics.stat_Errors = 0;
    RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);

    return STATUS_SUCCESS;
}


/***    AfpAdmGetProfCounters
 *
 *  Return a copy of the server profile counters.
 *
 *  LOCKS:  AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpAdmGetProfCounters(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
#ifdef  PROFILING
    KIRQL       OldIrql;

    DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
            ("AfpAdmGetProfCounters entered\n"));

    if (OutBufLen >= sizeof(AFP_PROFILE_INFO))
    {
        ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
        RtlCopyMemory(OutBuf, AfpServerProfile, sizeof(AFP_PROFILE_INFO));
        RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
    }
    else
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
#else
    RtlZeroMemory(OutBuf, sizeof(AFP_PROFILE_INFO));
#endif
    return Status;
}


/***    AfpAdmClearProfCounters
 *
 *  Reset the server profile counters
 */
AFPSTATUS
AfpAdmClearProfCounters(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    InBuf;
    OutBufLen;
    OutBuf;

    // Currently a NOP
    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_STAT, DBG_LEVEL_INFO,
            ("AfpAdmClearProfCounters entered\n"));

    return STATUS_SUCCESS;
}


/***    AfpAdmServerSetParms
 *
 *  This routine sets various server globals with data supplied by the admin.
 *  The following server globals are set by this routine:
 *
 *  - List of trusted domains and their Posix offsets.
 */
AFPSTATUS
AfpAdmServerSetParms(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PAFP_SID_OFFSET_DESC    pSrvrParms = (PAFP_SID_OFFSET_DESC)InBuf;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmServerSetParms entered\n"));

    return (AfpInitSidOffsets(pSrvrParms->CountOfSidOffsets,
                              pSrvrParms->SidOffsetPairs));
}


/***    AfpAdmServerAddEtc
 *
 *  This routine adds a set of Extension/Type-Creator mappings to the global
 *  list. This list can be changed while the server is in any state. It is
 *  an error to add the default type creator mapping. The default mapping
 *  can only be modified with AfpAdmServerSetEtc, never added nor deleted.
 *  It is an error to try to add zero entries.
 *
 *  This routine will complete in the context of the caller, and not be queued
 *  to a worker thread.
 *
 *  LOCKS: AfpEtcMapLock (SWMR, Exclusive)
**/
AFPSTATUS
AfpAdmServerAddEtc(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    LONG            NumToAdd = ((PSRVETCPKT)InBuf)->retc_NumEtcMaps;
    PETCMAPINFO2    pEtcList = ((PSRVETCPKT)InBuf)->retc_EtcMaps;
    PETCMAPINFO     ptemptable,pnextfree;
    LONG            numfree, newtablesize, nextfreehint, i;
    UNICODE_STRING  udefaultext,ulookupext;
    AFPSTATUS       Status = AFPERR_InvalidParms;
    BOOLEAN         UnlockSwmr = False;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmServerAddEtc entered\n"));

    if (NumToAdd != 0) do
    {
        //
        // make sure all the entries passed have valid extensions. We want to
        // add all or nothing, so we have to validate all of the data first thing.
        //
        RtlInitUnicodeString(&udefaultext, AFP_DEF_EXTENSION_W);
        for (i = 0; i < NumToAdd; i++)
        {
            if (!afpIsValidExtension(pEtcList[i].etc_extension))
            {
                break;
            }
            RtlInitUnicodeString(&ulookupext,pEtcList[i].etc_extension);
            if (RtlEqualUnicodeString(&udefaultext, &ulookupext,True))
            {
                break;
            }
        }

        if (i != NumToAdd)
            break;

        AfpSwmrAcquireExclusive(&AfpEtcMapLock);
        UnlockSwmr = True;

        if ((NumToAdd + AfpEtcMapCount) > AFP_MAX_ETCMAP_ENTRIES)
        {
            Status = AFPERR_TooManyEtcMaps;
            break;
        }

        if ((numfree = AfpEtcMapsSize - AfpEtcMapCount) < NumToAdd)
        {
            ASSERT(numfree >= 0);
            //
            // we need to add some room to the table
            //
            newtablesize = AfpEtcMapsSize +
                           ((NumToAdd / AFP_MAX_FREE_ETCMAP_ENTRIES) + 1) * AFP_MAX_FREE_ETCMAP_ENTRIES;
            if ((ptemptable = (PETCMAPINFO)AfpAllocZeroedPagedMemory(newtablesize * sizeof(ETCMAPINFO))) == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            if (AfpEtcMaps != NULL)
            {
                RtlCopyMemory(ptemptable, AfpEtcMaps, AfpEtcMapsSize * sizeof(ETCMAPINFO));
                AfpFreeMemory(AfpEtcMaps);
            }
            AfpEtcMaps = ptemptable;
            AfpEtcMapsSize = newtablesize;
        }

        nextfreehint = 0;
        for (i = 0; i < NumToAdd; i++)
        {
            pnextfree = afpGetNextFreeEtcMapEntry(&nextfreehint);
            ASSERT(pnextfree != NULL);
            afpCopyMapInfo2ToMapInfo(pnextfree, &pEtcList[i]);
            AfpEtcMapCount ++;
        }

        Status = STATUS_SUCCESS;

        DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
                ("AfpAdmServerAddEtc successful\n"));
    } while (False);

    if (UnlockSwmr)
        AfpSwmrRelease(&AfpEtcMapLock);

    return Status;
}


/***    AfpAdmServerSetEtc
 *
 *  This routine changes an existing entry in the server global
 *  Extension/Type-Creator mapping list for a given file extension, or the
 *  default type/creator mapping.
 *  An entry can be changed while the server is in any state.
 *
 *  This routine will complete in the context of the caller, and not be queued
 *  to a worker thread.
 *
 *  LOCKS: AfpEtcMapLock (SWMR, Exclusive)
 */
AFPSTATUS
AfpAdmServerSetEtc(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    // ignore the parmnum field
    PETCMAPINFO2    pEtc = (PETCMAPINFO2)((PBYTE)InBuf+sizeof(SETINFOREQPKT));
    PETCMAPINFO     petcentry;
    ETCMAPINFO      TmpEtcEntry;
    AFPSTATUS       rc = STATUS_SUCCESS;
    BOOLEAN         setdefaultetc;
    UNICODE_STRING  ulookupext,udefaultext;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmServerSetEtc entered\n"));

    if (!afpIsValidExtension(pEtc->etc_extension))
    {
        return AFPERR_InvalidExtension;
    }

    RtlInitUnicodeString(&udefaultext,AFP_DEF_EXTENSION_W);
    RtlInitUnicodeString(&ulookupext,pEtc->etc_extension);
    setdefaultetc = RtlEqualUnicodeString(&udefaultext, &ulookupext,True);

    if (setdefaultetc)
    {
        petcentry = &AfpDefaultEtcMap;
    }

    AfpSwmrAcquireExclusive(&AfpEtcMapLock);

    afpCopyMapInfo2ToMapInfo(&TmpEtcEntry,pEtc);

    if (!setdefaultetc)
    {
        petcentry = AfpLookupEtcMapEntry(TmpEtcEntry.etc_extension);
        if (petcentry == NULL)
        {
            AfpSwmrRelease(&AfpEtcMapLock);
            return AFPERR_InvalidParms;
        }
    }

    RtlCopyMemory(petcentry, &TmpEtcEntry, sizeof(ETCMAPINFO));

    AfpSwmrRelease(&AfpEtcMapLock);

    return rc;
}


/***    AfpAdmServerDeleteEtc
 *
 *  This routine deletes the server global Extension/Type-Creator mapping entry
 *  for a given extension. The default type creator mapping can never be
 *  deleted (since it is not kept in the table).
 *
 *  This routine will complete in the context of the caller, and not be queued
 *  to a worker thread.
 *
 *  LOCKS: AfpEtcMapLock (SWMR, Exclusive)
 *
 */
AFPSTATUS
AfpAdmServerDeleteEtc(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PETCMAPINFO2    petc = (PETCMAPINFO2)InBuf;
    PETCMAPINFO     petcentry;
    ETCMAPINFO      TmpEtcEntry;
    AFPSTATUS       rc = STATUS_SUCCESS;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmServerDeleteEtc entered\n"));

    if (!afpIsValidExtension(petc->etc_extension))
    {
        return AFPERR_InvalidParms;
    }

    AfpSwmrAcquireExclusive(&AfpEtcMapLock);

    afpCopyMapInfo2ToMapInfo(&TmpEtcEntry,petc);

    petcentry = AfpLookupEtcMapEntry(TmpEtcEntry.etc_extension);
    if (petcentry != NULL)
    {
        afpEtcMapDelete(petcentry);
    }
    else
    {
        rc = AFPERR_InvalidParms;
    }

    AfpSwmrRelease(&AfpEtcMapLock);

    return rc;
}


// Mapping icon types to their sizes
LOCAL   DWORD   afpIconSizeTable[MAX_ICONTYPE] =
    {
    ICONSIZE_ICN ,
    ICONSIZE_ICN ,
    ICONSIZE_ICN4,
    ICONSIZE_ICN8,
    ICONSIZE_ICS ,
    ICONSIZE_ICS4,
    ICONSIZE_ICS8
    };


/***    AfpAdmServerAddIcon
 *
 *  This routine adds an icon of a given type, creator and icon type to the server
 *  desktop. This supplements the volume desktop of every volume. An icon type
 *  of 0 special cases to the server icon.
 *
 *  This routine will complete in the context of the caller, and not be queued
 *  to a worker thread.
 *
 */
AFPSTATUS
AfpAdmServerAddIcon(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    DWORD           icontypeafp;
    PSRVICONINFO    pIcon = (PSRVICONINFO)InBuf;

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmServerAddIcon entered\n"));

    if (pIcon->icon_icontype > MAX_ICONTYPE ||
        afpIconSizeTable[pIcon->icon_icontype] != pIcon->icon_length)
    {
        return AFPERR_InvalidParms;
    }

    //
    // check for the server icon (type is zero)
    //
    if (afpIsServerIcon(pIcon))
    {
        // Allocate memory for server icon
        if ((AfpServerIcon == NULL) &&
            (AfpServerIcon = AfpAllocNonPagedMemory(ICONSIZE_ICN)) == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;

        RtlCopyMemory(AfpServerIcon,
                      (PBYTE)pIcon+sizeof(SRVICONINFO),
                      ICONSIZE_ICN);
        return((AfpServerState != AFP_STATE_IDLE) ?
                AfpSetServerStatus() : STATUS_SUCCESS);
    }
    else
    {
        icontypeafp = 1 << (pIcon->icon_icontype-1);
        return(AfpAddIconToGlobalList(*(PDWORD)(&pIcon->icon_type),
                                      *(PDWORD)(&pIcon->icon_creator),
                                      icontypeafp,
                                      pIcon->icon_length,
                                      (PBYTE)pIcon+sizeof(SRVICONINFO)));
    }
}


/***    AfpAdmVolumeAdd
 *
 *  This routine adds a volume to the server global list of volumes headed by
 *  AfpVolumeList. The volume descriptor is created and initialized. The ID
 *  index is read in (or created). The same is true with the desktop.
 *
 *  It is assumed that all volume info fields are set in the input buffer
 *
 *  ADMIN   QUEUE WORKER: AfpAdmWVolumeAdd
 *
 */
AFPSTATUS
AfpAdmVolumeAdd(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    UNICODE_STRING  uname,upwd;
    ULONG           ansinamelen, ansipwdlen;
    PAFP_VOLUME_INFO pVolInfo = (PAFP_VOLUME_INFO)InBuf;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
            ("AfpAdmVolumeAdd entered\n"));

    //
    // validate the input data
    //

    RtlInitUnicodeString(&uname, pVolInfo->afpvol_name);
    ansinamelen = RtlUnicodeStringToAnsiSize(&uname) - 1;

    //
    // check length of volume name and that no ":" exist in the name
    //
    if ((ansinamelen > AFP_VOLNAME_LEN) || (ansinamelen == 0) ||
        (wcschr(uname.Buffer, L':') != NULL))
    {
        return AFPERR_InvalidVolumeName;
    }

    if (pVolInfo->afpvol_props_mask & ~AFP_VOLUME_ALL)
        return AFPERR_InvalidParms;

    if ((pVolInfo->afpvol_max_uses == 0) ||
        (pVolInfo->afpvol_max_uses > AFP_VOLUME_UNLIMITED_USES))
    {
        return AFPERR_InvalidParms_MaxVolUses;
    }

    RtlInitUnicodeString(&upwd, pVolInfo->afpvol_password);
    ansipwdlen = RtlUnicodeStringToAnsiSize(&upwd) - 1;
    if (ansipwdlen > AFP_VOLPASS_LEN)
    {
        return AFPERR_InvalidPassword;
    }
    else if (ansipwdlen > 0)
    {
        pVolInfo->afpvol_props_mask |= AFP_VOLUME_HASPASSWORD;
    }

    //
    // Force this to be queued up to a worker thread.
    //
    return STATUS_PENDING;
}


/***    AfpAdmVolumeSetInfo
 *
 *  The volume parameters that can be changed by this call are the volume
 *  password, max_uses and volume properties mask.
 *
 *  LOCKS: AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *  LOCK ORDER: vds_VolLock after AfpVolumeListLock
 *
 */
AFPSTATUS
AfpAdmVolumeSetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    WCHAR           upcasebuf[AFP_VOLNAME_LEN+1];
    UNICODE_STRING  upwd,uname, upcasename;
    BYTE            apwdbuf[AFP_VOLPASS_LEN+1];
    ANSI_STRING     apwd;
    PVOLDESC        pVolDesc;
    AFPSTATUS       status;
    KIRQL           OldIrql;
    DWORD           parmflags = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;
    PAFP_VOLUME_INFO pVolInfo = (PAFP_VOLUME_INFO)((PCHAR)InBuf+sizeof(SETINFOREQPKT));

    DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
            ("AfpAdmVolumeSetInfo entered\n"));

    AfpSetEmptyAnsiString(&apwd, AFP_VOLPASS_LEN+1, apwdbuf);
    AfpSetEmptyUnicodeString(&upcasename, sizeof(upcasebuf), upcasebuf);
    if ((parmflags & ~AFP_VOL_PARMNUM_ALL) ||
        ((parmflags & AFP_VOL_PARMNUM_PROPSMASK) &&
         (pVolInfo->afpvol_props_mask & ~AFP_VOLUME_ALL)) ||
        ((parmflags & AFP_VOL_PARMNUM_MAXUSES) &&
         ((pVolInfo->afpvol_max_uses == 0) ||
          (pVolInfo->afpvol_max_uses > AFP_VOLUME_UNLIMITED_USES))))
    {
        return AFPERR_InvalidParms;
    }

    if (parmflags & AFP_VOL_PARMNUM_PASSWORD)
    {
        RtlInitUnicodeString(&upwd,pVolInfo->afpvol_password);

        if ((!NT_SUCCESS(AfpConvertStringToAnsi(&upwd, &apwd))) ||
            (apwd.Length > AFP_VOLPASS_LEN))
        {
            return AFPERR_InvalidPassword;
        }
    }

    RtlInitUnicodeString(&uname, pVolInfo->afpvol_name);
    if (!NT_SUCCESS(RtlUpcaseUnicodeString(&upcasename, &uname, False)))
    {
        return AFPERR_InvalidVolumeName;
    }

    // Will reference the volume if successful
    if ((pVolDesc = AfpVolumeReferenceByUpCaseName(&upcasename)) == NULL)
    {
        return AFPERR_VolumeNonExist;
    }

    // Acquire the lock for the volume itself (we already have a reference)

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    do
    {
        status = STATUS_SUCCESS;

        if (parmflags & AFP_VOL_PARMNUM_PROPSMASK)
        {
            //
            // set or clear the desired volume property bits
            //
            pVolDesc->vds_Flags = (USHORT)((pVolDesc->vds_Flags & ~AFP_VOLUME_ALL) |
                                            (pVolInfo->afpvol_props_mask));
        }

        if (parmflags & AFP_VOL_PARMNUM_PASSWORD)
        {
            if (apwd.Length == 0)
            {
                pVolDesc->vds_MacPassword.Length = 0;
                pVolDesc->vds_Flags &= ~AFP_VOLUME_HASPASSWORD;
                pVolDesc->vds_MacPassword.Length = 0;
            }
            else
            {
                RtlZeroMemory(pVolDesc->vds_MacPassword.Buffer, AFP_VOLPASS_LEN);
                AfpCopyAnsiString(&pVolDesc->vds_MacPassword, &apwd);
                pVolDesc->vds_MacPassword.Length = AFP_VOLPASS_LEN;
                pVolDesc->vds_Flags |= AFP_VOLUME_HASPASSWORD;
            }
        }

        if (parmflags & AFP_VOL_PARMNUM_MAXUSES)
            pVolDesc->vds_MaxUses = pVolInfo->afpvol_max_uses;

    } while (False);
    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock,OldIrql);
    AfpVolumeDereference(pVolDesc);

    return status;
}


/***    AfpAdmVolumeGetInfo
 *
 *
 *  LOCKS: AfpVolumeListLock (SPIN), vds_VolLock (SPIN)
 *  LOCK ORDER: vds_VolLock after AfpVolumeListLock
 */
AFPSTATUS
AfpAdmVolumeGetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PVOLDESC            pVolDesc;
    AFPSTATUS           Status;
    KIRQL               OldIrql;
    PCHAR               pCurStr;
    WCHAR               upcasebuf[AFP_VOLNAME_LEN+1];
    UNICODE_STRING      uvolpass, uname, upcasename;
    PAFP_VOLUME_INFO    pVolInfo = (PAFP_VOLUME_INFO)OutBuf;
    BOOLEAN             copypassword = False;
    ANSI_STRING         avolpass;
    CHAR                avolpassbuf[AFP_VOLPASS_LEN + 1];
    USHORT              extrabytes;

    DBGPRINT(DBG_COMP_ADMINAPI_VOL, DBG_LEVEL_INFO,
            ("AfpAdmVolumeGetInfo entered\n"));

    AfpSetEmptyUnicodeString(&upcasename, sizeof(upcasebuf), upcasebuf);
    RtlInitUnicodeString(&uname, ((PAFP_VOLUME_INFO)InBuf)->afpvol_name);
    if (!NT_SUCCESS(RtlUpcaseUnicodeString(&upcasename, &uname, False)))
    {
        return AFPERR_InvalidVolumeName;
    }

    // Will reference the volume if successful
    if ((pVolDesc = AfpVolumeReferenceByUpCaseName(&upcasename)) == NULL)
    {
        return AFPERR_VolumeNonExist;
    }

    // Acquire the lock for the volume itself

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    do
    {
        if ((OutBufLen - sizeof(AFP_VOLUME_INFO)) <
                (pVolDesc->vds_Name.Length + sizeof(UNICODE_NULL) +
                 (pVolDesc->vds_MacPassword.Length + 1) * sizeof(WCHAR) +
                 pVolDesc->vds_Path.Length +
                 (extrabytes =
            (pVolDesc->vds_Path.Buffer[(pVolDesc->vds_Path.Length / sizeof(WCHAR)) - 2] == L':' ?
                    sizeof(WCHAR) : 0)) + sizeof(UNICODE_NULL)))
        {
            Status = AFPERR_BufferSize;
            break;
        }

        Status = STATUS_SUCCESS;

        pVolInfo->afpvol_max_uses = pVolDesc->vds_MaxUses;
        pVolInfo->afpvol_props_mask = (pVolDesc->vds_Flags & AFP_VOLUME_ALL_DOWNLEVEL);
        pVolInfo->afpvol_id = pVolDesc->vds_VolId;
        pVolInfo->afpvol_curr_uses = pVolDesc->vds_UseCount;

        pCurStr = (PBYTE)OutBuf + sizeof(AFP_VOLUME_INFO);
        RtlCopyMemory(pCurStr, pVolDesc->vds_Name.Buffer,
                                                pVolDesc->vds_Name.Length);
        *(LPWSTR)(pCurStr + pVolDesc->vds_Name.Length) = UNICODE_NULL;
        pVolInfo->afpvol_name = (LPWSTR)pCurStr;
        POINTER_TO_OFFSET(pVolInfo->afpvol_name,pVolInfo);

        pCurStr += pVolDesc->vds_Name.Length + sizeof(WCHAR);
        RtlCopyMemory(pCurStr, pVolDesc->vds_Path.Buffer,
                                                pVolDesc->vds_Path.Length);
        // replace trailing backslash of path with a unicode null unless the
        // next to last char is ':', then keep it and add a trailing null
        *(LPWSTR)(pCurStr + pVolDesc->vds_Path.Length + extrabytes - sizeof(WCHAR)) = UNICODE_NULL;
        pVolInfo->afpvol_path = (LPWSTR)pCurStr;
        POINTER_TO_OFFSET(pVolInfo->afpvol_path,pVolInfo);

        pCurStr += pVolDesc->vds_Path.Length + extrabytes;
        copypassword = True;
        uvolpass.Buffer = (LPWSTR)pCurStr;
        uvolpass.MaximumLength = (pVolDesc->vds_MacPassword.Length + 1) * sizeof(WCHAR);
        AfpSetEmptyAnsiString(&avolpass, sizeof(avolpassbuf), avolpassbuf);
        AfpCopyAnsiString(&avolpass, &pVolDesc->vds_MacPassword);
    } while(False);

    RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock,OldIrql);

    AfpVolumeDereference(pVolDesc);

    if (copypassword == True)
    {
        AfpConvertStringToUnicode(&avolpass, &uvolpass);
        *(LPWSTR)(pCurStr + uvolpass.Length) = UNICODE_NULL;
        pVolInfo->afpvol_password = (LPWSTR)pCurStr;
        POINTER_TO_OFFSET(pVolInfo->afpvol_password,pVolInfo);
    }
    return Status;
}


/***    AfpAdmVolumeEnum
 *
 *  Enumerate the list of configured volumes.
 *
 *  LOCKS: AfpVolumeListLock (SPIN)
 *
 */
AFPSTATUS
AfpAdmVolumeEnum(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    LONG                startindex = (LONG)(((PENUMREQPKT)InBuf)->erqp_Index);
    PENUMRESPPKT        pErsp = (PENUMRESPPKT)OutBuf;
    PAFP_VOLUME_INFO    pnextvol = (PAFP_VOLUME_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
    PBYTE               pCurStr = (PBYTE)OutBuf+OutBufLen; // 1 past eob
    KIRQL               OldIrql;
    AFPSTATUS           status = STATUS_SUCCESS;
    PVOLDESC            pVolDesc;
    LONG                bytesleft, curvolindex, nextvollen, deadvolumes = 0, extrabytes;

    if (startindex == 0)
    {
        startindex ++;
    }
    else if (startindex < 0)
    {
        return AFPERR_InvalidParms;
    }

    pErsp->ersp_cInBuf = 0;
    pErsp->ersp_hResume = 1;

    ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

    if (startindex > afpLargestVolIdInUse)
    {
        RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);
        if (pErsp->ersp_cTotEnts != 0)
        {
            status = AFPERR_InvalidParms;
        }
        return status;
    }

    curvolindex = 1;
    for (pVolDesc = AfpVolumeList;
         pVolDesc != NULL;
         curvolindex++, pVolDesc = pVolDesc->vds_Next)
    {
        ASSERT(pVolDesc != NULL);

        ACQUIRE_SPIN_LOCK_AT_DPC(&pVolDesc->vds_VolLock);

        if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED | VOLUME_INTRANSITION))
        {
            deadvolumes ++;
            RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
            continue;
        }

        if (curvolindex < startindex)
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
            continue;
        }

        bytesleft = (LONG)((PBYTE)pCurStr - (PBYTE)pnextvol);

        nextvollen = sizeof(AFP_VOLUME_INFO) +
                     pVolDesc->vds_Name.MaximumLength +
                     // replace trailing backslash with a null when copying
                     // unless the next to last char is ':', then keep it and
                     // add a trailing null
                     pVolDesc->vds_Path.Length + (extrabytes =
                    (pVolDesc->vds_Path.Buffer[(pVolDesc->vds_Path.Length / sizeof(WCHAR)) - 2] == L':' ?
                                            sizeof(WCHAR) : 0));


        if (nextvollen > bytesleft)
        {
            if (pErsp->ersp_cInBuf == 0)
                status = AFPERR_BufferSize;
            RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
            break;
        }

        pnextvol->afpvol_max_uses = pVolDesc->vds_MaxUses;
        pnextvol->afpvol_props_mask = (pVolDesc->vds_Flags & AFP_VOLUME_ALL_DOWNLEVEL);
        pnextvol->afpvol_id = pVolDesc->vds_VolId;
        pnextvol->afpvol_curr_uses = pVolDesc->vds_UseCount;

        pCurStr -= pVolDesc->vds_Path.Length + extrabytes;
        RtlCopyMemory(pCurStr,pVolDesc->vds_Path.Buffer,
                        pVolDesc->vds_Path.Length);
        *(LPWSTR)(pCurStr + pVolDesc->vds_Path.Length + extrabytes - sizeof(WCHAR)) = L'\0';
        pnextvol->afpvol_path = (LPWSTR)pCurStr;
        POINTER_TO_OFFSET(pnextvol->afpvol_path,pnextvol);

        pnextvol->afpvol_password = NULL;

        pCurStr -= pVolDesc->vds_Name.MaximumLength;
        RtlCopyMemory(pCurStr,pVolDesc->vds_Name.Buffer,
                        pVolDesc->vds_Name.MaximumLength);

        pnextvol->afpvol_name = (LPWSTR)pCurStr;
        POINTER_TO_OFFSET(pnextvol->afpvol_name,pnextvol);

        pnextvol++;
        pErsp->ersp_cInBuf++;
        RELEASE_SPIN_LOCK_FROM_DPC(&pVolDesc->vds_VolLock);
    }

    pErsp->ersp_cTotEnts = AfpVolCount - deadvolumes;

    RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

    if (curvolindex <= (LONG)pErsp->ersp_cTotEnts)
    {
        status = STATUS_MORE_ENTRIES;
        pErsp->ersp_hResume = curvolindex;
    }
    else
        pErsp->ersp_hResume = 1;

    return status;
}


/***    AfpAdmSessionEnum
 *
 *  Enumerate the list of active sessions. This is a linear list rooted
 *  at AfpSessionList and protected by AfpSdaLock. This list is potentially
 *  pretty long (Unlimited # of sessions with the super ASP stuff).
 *
 *  The resume handle returned is the session id of the last session returned.
 *  Session Id of 0 implies restart scan.
 *
 *  The output buffer is constructed as follows.
 *
 *      +---------------------------+
 *      |   Session_Info_1          |
 *      +---------------------------+
 *      |   Session_Info_2          |
 *      +---------------------------+
 *      .                           .
 *      .                           .
 *      +---------------------------+
 *      |   Session_Info_n          |
 *      +---------------------------+
 *      .                           .
 *      .                           .
 *      +---------------------------+
 *      |                           |
 *      |...........................|
 *      |           Strings         |
 *      |...........................|
 *      |                           |
 *      |                           |
 *      +---------------------------+
 *
 *  LOCKS:      AfpSdaLock (SPIN)
 */
AFPSTATUS
AfpAdmSessionEnum(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PENUMRESPPKT        pErsp = (PENUMRESPPKT)OutBuf;
    PAFP_SESSION_INFO   pSessInfo = (PAFP_SESSION_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
    PSDA                pSda;
    PBYTE               pString = (PBYTE)OutBuf+OutBufLen; // 1 past eob
    DWORD               StartId = (LONG)(((PENUMREQPKT)InBuf)->erqp_Index);
    DWORD               DeadSessions = 0;
    KIRQL               OldIrql;
    AFPSTATUS           Status = AFP_ERR_NONE;

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmSessionEnum entered\n"));

    if (OutBufLen < (sizeof(ENUMRESPPKT) + sizeof(PAFP_SESSION_INFO)))
        return AFPERR_BufferSize;

    if (StartId == 0)
        StartId = MAXULONG;

    // Initialize the response packet header
    pErsp->ersp_cInBuf = 0;
    pErsp->ersp_hResume = 0;

    ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);

    for (pSda = AfpSessionList; pSda != NULL; pSda = pSda->sda_Next)
    {
        LONG    BytesLeft;
        LONG    BytesNeeded;

        // Skip entries that are marked to die
        if ((pSda->sda_Flags & SDA_CLOSING) ||
            !(pSda->sda_Flags & SDA_USER_LOGGEDIN))
        {
            DeadSessions++;
            continue;
        }

        // Skip all entries we have looked at before
        if (pSda->sda_SessionId > StartId)
            continue;

        // If there is not enough space in the buffer, abort now and
        // initialize pErsp->ersp_hResume with the current session id
        BytesLeft = (LONG)((PBYTE)pString - (PBYTE)pSessInfo);
        BytesNeeded = sizeof(AFP_SESSION_INFO) +
                     pSda->sda_UserName.Length + sizeof(WCHAR) +
                     pSda->sda_WSName.Length + sizeof(WCHAR);

        if ((BytesLeft <= 0) || (BytesNeeded > BytesLeft))
        {
            pErsp->ersp_hResume = pSda->sda_SessionId;
            Status = STATUS_MORE_ENTRIES;
            break;
        }

        StartId = pSda->sda_SessionId;
        pSessInfo->afpsess_id = pSda->sda_SessionId;
        pSessInfo->afpsess_num_cons = pSda->sda_cOpenVolumes;
        pSessInfo->afpsess_num_opens = pSda->sda_cOpenForks;
        pSessInfo->afpsess_logon_type = pSda->sda_ClientType;
        if (pSda->sda_Flags & SDA_GUEST_LOGIN)
        {
            pSessInfo->afpsess_logon_type = SDA_CLIENT_GUEST;
        }
        AfpGetCurrentTimeInMacFormat(&pSessInfo->afpsess_time);
        pSessInfo->afpsess_time -= pSda->sda_TimeLoggedOn;

        // Copy the strings here
        pSessInfo->afpsess_username = NULL;
        pSessInfo->afpsess_ws_name = NULL;

        if (pSda->sda_UserName.Length > 0)
        {
            pString -= (pSda->sda_UserName.Length + sizeof(WCHAR));
            if (pSda->sda_UserName.Length > 0)
                RtlCopyMemory(pString, pSda->sda_UserName.Buffer, pSda->sda_UserName.Length);
            *(LPWSTR)(pString + pSda->sda_UserName.Length) = L'\0';
            pSessInfo->afpsess_username = (LPWSTR)pString;
            POINTER_TO_OFFSET(pSessInfo->afpsess_username, pSessInfo);
        }

        if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
            (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
        {
            pString -= (pSda->sda_WSName.Length + sizeof(WCHAR));
            if (pSda->sda_WSName.Length > 0)
                RtlCopyMemory(pString, pSda->sda_WSName.Buffer, pSda->sda_WSName.Length);
            *(LPWSTR)(pString + pSda->sda_WSName.Length) = L'\0';
            pSessInfo->afpsess_ws_name = (LPWSTR)pString;
            POINTER_TO_OFFSET(pSessInfo->afpsess_ws_name, pSessInfo);
        }

        pSessInfo ++;
        pErsp->ersp_cInBuf ++;
    }

    // Fill up the response packet header
    pErsp->ersp_cTotEnts = (DWORD)AfpNumSessions - DeadSessions;

    RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);

    return Status;
}


/***    AfpAdmConnectionEnum
 *
 *  Enumerate the list of active connections. This is a linear list rooted
 *  at AfpConnList and protected by AfpConnLock. This list is potentially
 *  pretty long (Unlimited # of sessions with the super ASP stuff).
 *
 *  For that reason once every pass we check to see if we must forego the lock
 *  and restart scan again. The assumption here is that the admin operation can
 *  take a hit.
 *
 *  The resume handle returned is the connection id of the last connection
 *  returned. connection Id of 0 implies restart scan.
 *
 *  The output buffer is constructed as follows.
 *
 *      +---------------------------+
 *      |   Connection_Info_1       |
 *      +---------------------------+
 *      |   Connection_Info_2       |
 *      +---------------------------+
 *      .                           .
 *      .                           .
 *      +---------------------------+
 *      |   Connection_Info_n       |
 *      +---------------------------+
 *      .                           .
 *      .                           .
 *      +---------------------------+
 *      |                           |
 *      |...........................|
 *      |           Strings         |
 *      |...........................|
 *      |                           |
 *      |                           |
 *      +---------------------------+
 *
 *  The connections can be filtered based on either sessions or volumes.
 *
 *  LOCKS:      AfpConnLock (SPIN)
 */
AFPSTATUS
AfpAdmConnectionEnum(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PENUMRESPPKT        pErsp = (PENUMRESPPKT)OutBuf;
    PENUMREQPKT         pErqp = (PENUMREQPKT)InBuf;
    PAFP_CONNECTION_INFO pConnInfo = (PAFP_CONNECTION_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
    PCONNDESC           pConnDesc;
    PBYTE               pString = (PBYTE)OutBuf+OutBufLen; // 1 past eob
    LONG                cTotal = 0;
    DWORD               DeadConns = 0;
    KIRQL               OldIrql;
    AFPSTATUS           Status = AFP_ERR_NONE;

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmConnectionEnum entered\n"));

    if ((((pErqp->erqp_Filter == AFP_FILTER_ON_SESSION_ID) ||
          (pErqp->erqp_Filter == AFP_FILTER_ON_VOLUME_ID)) &&
         (pErqp->erqp_ID == 0)) ||
        ((pErqp->erqp_Filter != 0) &&
         (pErqp->erqp_Filter != AFP_FILTER_ON_SESSION_ID) &&
         (pErqp->erqp_Filter != AFP_FILTER_ON_VOLUME_ID)))
        return AFPERR_InvalidParms;

    if (OutBufLen < (sizeof(ENUMRESPPKT) + sizeof(PAFP_CONNECTION_INFO)))
        return AFPERR_BufferSize;

    if (pErqp->erqp_Index == 0)
        pErqp->erqp_Index = MAXULONG;

    // Initialize the response packet header
    pErsp->ersp_cInBuf = 0;
    pErsp->ersp_hResume = 0;

    ACQUIRE_SPIN_LOCK(&AfpConnLock, &OldIrql);

    for (pConnDesc = AfpConnList;
         pConnDesc != NULL;
         pConnDesc = pConnDesc->cds_NextGlobal)
    {
        PSDA        pSda;
        PVOLDESC    pVolDesc;
        LONG        BytesLeft;
        LONG        BytesNeeded;

        // We do not need to either lock or reference pSda and pVolDesc
        // since we have implicit references to them via the pConnDesc.

        pSda = pConnDesc->cds_pSda;
        ASSERT(pSda != NULL);

        pVolDesc = pConnDesc->cds_pVolDesc;
        ASSERT(pVolDesc != NULL);

        // If we are filtering, make sure we get the total count
        // Skip this entry, if any filtering is requested and this does not
        // match
        if (pErqp->erqp_Filter != 0)
        {
            if (pErqp->erqp_Filter == AFP_FILTER_ON_SESSION_ID)
            {
                if (pSda->sda_SessionId != pErqp->erqp_ID)
                    continue;
                cTotal = pSda->sda_cOpenVolumes;
            }
            else // if (pErqp->erqp_Filter == AFP_FILTER_ON_VOLUME_ID)
            {
                if (pVolDesc->vds_VolId != (LONG)pErqp->erqp_ID)
                    continue;
                cTotal = pVolDesc->vds_UseCount;
            }
        }
        else cTotal = AfpNumSessions;

        // Skip all entries that are marked for death
        if (pConnDesc->cds_Flags & CONN_CLOSING)
        {
            DeadConns++;
            continue;
        }

        // Skip all entries we have looked at before
        if (pConnDesc->cds_ConnId > pErqp->erqp_Index)
            continue;

        // If there is not enough space in the buffer, abort now and
        // initialize pErsp->ersp_hResume with the current connection id
        BytesLeft = (LONG)((PBYTE)pString - (PBYTE)pConnInfo);
        BytesNeeded = sizeof(AFP_CONNECTION_INFO) +
                     pSda->sda_UserName.Length + sizeof(WCHAR) +
                     pVolDesc->vds_Name.Length + sizeof(WCHAR);

        if ((BytesLeft <= 0) || (BytesNeeded > BytesLeft))
        {
            pErsp->ersp_hResume = pConnDesc->cds_ConnId;
            Status = STATUS_MORE_ENTRIES;
            break;
        }


        pErqp->erqp_Index = pConnDesc->cds_ConnId;
        pConnInfo->afpconn_id = pConnDesc->cds_ConnId;
        pConnInfo->afpconn_num_opens = pConnDesc->cds_cOpenForks;
        AfpGetCurrentTimeInMacFormat((PAFPTIME)&pConnInfo->afpconn_time);
        pConnInfo->afpconn_time -= pConnDesc->cds_TimeOpened;

        // Copy the username name string
        pConnInfo->afpconn_username = (LPWSTR)NULL;
        if (pSda->sda_UserName.Length > 0)
        {
            pString -= (pSda->sda_UserName.Length + sizeof(WCHAR));
            RtlCopyMemory(pString, pSda->sda_UserName.Buffer, pSda->sda_UserName.Length);
            *(LPWSTR)(pString + pSda->sda_UserName.Length) = L'\0';
            pConnInfo->afpconn_username = (LPWSTR)pString;
            POINTER_TO_OFFSET(pConnInfo->afpconn_username, pConnInfo);
        }

        // Copy the volume name string
        pString -= (pVolDesc->vds_Name.Length + sizeof(WCHAR));
        RtlCopyMemory(pString, pVolDesc->vds_Name.Buffer, pVolDesc->vds_Name.Length);
        *(LPWSTR)(pString + pVolDesc->vds_Name.Length) = L'\0';
        pConnInfo->afpconn_volumename = (LPWSTR)pString;
        POINTER_TO_OFFSET(pConnInfo->afpconn_volumename, pConnInfo);

        pConnInfo ++;
        pErsp->ersp_cInBuf ++;
    }

    // Fill up the response packet header
    pErsp->ersp_cTotEnts = (DWORD)cTotal - DeadConns;

    RELEASE_SPIN_LOCK(&AfpConnLock, OldIrql);

    return Status;
}


/***    AfpAdmForkEnum
 *
 *  Enumerate the list of open forks. This is a linear list rooted
 *  at AfpOpenForksList and protected by AfpForksLock. This list is potentially
 *  pretty long (Unlimited # of sessions with the super ASP stuff).
 *
 *  The resume handle returned is the connection id of the last connection
 *  returned. connection Id of 0 implies restart scan.
 *
 *  The output buffer is constructed as follows.
 *
 *      +---------------------------+
 *      |       File_Info_1         |
 *      +---------------------------+
 *      |       File_Info_2         |
 *      +---------------------------+
 *      .                           .
 *      .                           .
 *      +---------------------------+
 *      |       File_Info_n         |
 *      +---------------------------+
 *      .                           .
 *      .                           .
 *      +---------------------------+
 *      |                           |
 *      |...........................|
 *      |           Strings         |
 *      |...........................|
 *      |                           |
 *      |                           |
 *      +---------------------------+
 *
 *  LOCKS:      AfpForksLock (SPIN)
 */
AFPSTATUS
AfpAdmForkEnum(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PENUMRESPPKT    pErsp = (PENUMRESPPKT)OutBuf;
    PAFP_FILE_INFO  pFileInfo = (PAFP_FILE_INFO)((PBYTE)OutBuf+sizeof(ENUMRESPPKT));
    POPENFORKENTRY  pOpenForkEntry;
    POPENFORKDESC   pOpenForkDesc;
    PBYTE           pString = (PBYTE)OutBuf+OutBufLen; // 1 past eob
    DWORD           StartId = (LONG)(((PENUMREQPKT)InBuf)->erqp_Index);
    DWORD           DeadForks = 0;
    KIRQL           OldIrql;
    AFPSTATUS       Status = AFP_ERR_NONE;

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmForkEnum entered\n"));

    if (OutBufLen < (sizeof(ENUMRESPPKT) + sizeof(PAFP_FILE_INFO)))
        return AFPERR_BufferSize;

    if (StartId == 0)
        StartId = MAXULONG;

    // Initialize the response packet header
    pErsp->ersp_cInBuf = 0;
    pErsp->ersp_hResume = 0;

    ACQUIRE_SPIN_LOCK(&AfpForksLock, &OldIrql);

    for (pOpenForkEntry = AfpOpenForksList; pOpenForkEntry != NULL;
         pOpenForkEntry = pOpenForkEntry->ofe_Next)
    {
        LONG        BytesLeft;
        LONG        BytesNeeded;
        PSDA        pSda;
        PVOLDESC    pVolDesc = pOpenForkEntry->ofe_pOpenForkDesc->ofd_pVolDesc;

        // Skip all entries that are marked for death
        if (pOpenForkEntry->ofe_Flags & OPEN_FORK_CLOSING)
        {
            DeadForks ++;
            continue;
        }

        // Skip all entries we have looked at before
        if (pOpenForkEntry->ofe_ForkId > StartId)
            continue;

        pSda = pOpenForkEntry->ofe_pSda;
        pOpenForkDesc = pOpenForkEntry->ofe_pOpenForkDesc;

        // If there is not enough space in the buffer, abort now and
        // initialize pErsp->ersp_hResume with the current session id
        BytesLeft = (LONG)((PBYTE)pString - (PBYTE)pFileInfo);
        BytesNeeded = sizeof(AFP_FILE_INFO) + pSda->sda_UserName.Length +
                        sizeof(WCHAR) + /* NULL terminate username */
                        pVolDesc->vds_Path.Length +
                        pOpenForkDesc->ofd_FilePath.Length +
                        sizeof(WCHAR); /* NULL terminate path */

        if ((BytesLeft <= 0) || (BytesNeeded > BytesLeft))
        {
            pErsp->ersp_hResume = pOpenForkEntry->ofe_ForkId;
            Status = STATUS_MORE_ENTRIES;
            break;
        }

        StartId = pOpenForkEntry->ofe_ForkId;
        pFileInfo->afpfile_id = pOpenForkEntry->ofe_ForkId;
        pFileInfo->afpfile_num_locks = pOpenForkEntry->ofe_cLocks;
        pFileInfo->afpfile_fork_type = RESCFORK(pOpenForkEntry);

#if AFP_OPEN_MODE_NONE != FORK_OPEN_NONE
#error  (AFP_OPEN_MODE_NONE != FORK_OPEN_NONE)
#endif
#if AFP_OPEN_MODE_READ != FORK_OPEN_READ
#error  (AFP_OPEN_MODE_READ != FORK_OPEN_READ)
#endif
#if AFP_OPEN_MODE_WRITE != FORK_OPEN_WRITE
#error  (AFP_OPEN_MODE_WRITE != FORK_OPEN_WRITE)
#endif
        pFileInfo->afpfile_open_mode = (DWORD)pOpenForkEntry->ofe_OpenMode;

        // Copy the strings here.
        pFileInfo->afpfile_username = NULL;
        pFileInfo->afpfile_path = NULL;

        if (pSda->sda_UserName.Length > 0)
        {
            pString -= (pSda->sda_UserName.Length + sizeof(WCHAR));
            RtlCopyMemory(pString, pSda->sda_UserName.Buffer, pSda->sda_UserName.Length);
            *(LPWSTR)(pString + pSda->sda_UserName.Length) = L'\0';
            pFileInfo->afpfile_username = (LPWSTR)pString;
            POINTER_TO_OFFSET(pFileInfo->afpfile_username, pFileInfo);
        }

        if (pOpenForkDesc->ofd_FilePath.Length > 0)
        {

            pString -= pVolDesc->vds_Path.Length +
                       pOpenForkDesc->ofd_FilePath.Length +
                       sizeof(WCHAR);
            pFileInfo->afpfile_path = (LPWSTR)pString;
            POINTER_TO_OFFSET(pFileInfo->afpfile_path, pFileInfo);

            RtlCopyMemory(pString, pVolDesc->vds_Path.Buffer,
                          pVolDesc->vds_Path.Length);
            RtlCopyMemory(pString + pVolDesc->vds_Path.Length,
                          pOpenForkDesc->ofd_FilePath.Buffer,
                          pOpenForkDesc->ofd_FilePath.Length);
            *(LPWSTR)(pString + pVolDesc->vds_Path.Length +
                      pOpenForkDesc->ofd_FilePath.Length) = L'\0';

        }

        pFileInfo ++;
        pErsp->ersp_cInBuf ++;
    }

    // Fill up the response packet header
    pErsp->ersp_cTotEnts = (DWORD)AfpNumOpenForks - DeadForks;

    RELEASE_SPIN_LOCK(&AfpForksLock, OldIrql);

    return Status;
}


/***    AfpAdmMessageSend
 *
 *  Send a message to a specific session, or broadcast to all sessions.
 *  If session id is 0, this indicates a broadcast, and the message is copied
 *  to AfpServerMsg.  Otherwise, the message is copied to the particular
 *  session's SDA.  A message can be a max of 199 chars.  It is an error to
 *  attempt to send a message of length 0. A message can only be sent to an
 *  AFP 2.1 client as a AFP 2.0 client has no capability to accept a message.
 *
 *  LOCKS:      AfpServerGlobalLock (SPIN)
 */
AFPSTATUS
AfpAdmMessageSend(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PAFP_MESSAGE_INFO   pMsgInfo = (PAFP_MESSAGE_INFO)InBuf;
    PSDA                pSda;
    UNICODE_STRING      umsg;
    PANSI_STRING        amsg;
    USHORT              msglen;
    DWORD               SessId;
    KIRQL               OldIrql;
    AFPSTATUS           Status = AFP_ERR_NONE;

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmMessageSend entered\n"));

    SessId = pMsgInfo->afpmsg_session_id;
    RtlInitUnicodeString(&umsg, pMsgInfo->afpmsg_text);
    msglen = (USHORT)RtlUnicodeStringToAnsiSize(&umsg)-1;

    if ((msglen > AFP_MESSAGE_LEN) || (msglen == 0))
    {
        return AFPERR_InvalidParms;
    }

    if ((amsg =
        (PANSI_STRING)AfpAllocNonPagedMemory(msglen + 1 + sizeof(ANSI_STRING))) == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    amsg->Length = msglen;
    amsg->MaximumLength = msglen + 1;
    amsg->Buffer = (PBYTE)amsg + sizeof(ANSI_STRING);
    Status = RtlUnicodeStringToAnsiString(amsg, &umsg, False);
    if (!NT_SUCCESS(Status))
    {
        return AFPERR_InvalidParms;
    }
    else AfpConvertHostAnsiToMacAnsi(amsg);

    DBGPRINT(DBG_COMP_ADMINAPI_SRV, DBG_LEVEL_INFO,
            ("AfpAdmMessageSend: session id is 0x%x, message <%s>\n",
             pMsgInfo->afpmsg_session_id, amsg->Buffer));

    // If this is a broadcast message, initialize the global message
    if (SessId == 0)
    {
        ACQUIRE_SPIN_LOCK(&AfpServerGlobalLock, &OldIrql);
        // If there is a message there already, blow it
        if (AfpServerMsg != NULL)
            AfpFreeMemory(AfpServerMsg);
        AfpServerMsg = amsg;
        RELEASE_SPIN_LOCK(&AfpServerGlobalLock, OldIrql);

        // Walk the session list and send attention to all AFP 2.1 clients
        ACQUIRE_SPIN_LOCK(&AfpSdaLock, &OldIrql);
        for (pSda = AfpSessionList; pSda != NULL; pSda = pSda->sda_Next)
        {
            ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

            if ((pSda->sda_ClientVersion >= AFP_VER_21) &&
                ((pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED)) == 0))
            {
                // We are using the async version of AfpSpSendAttention since
                // we are calling with spin-lock held.
                AfpSpSendAttention(pSda, ATTN_SERVER_MESSAGE, False);
            }

            else if (pSda->sda_ClientVersion < AFP_VER_21)
            {
                Status = AFPERR_InvalidSessionType;
            }

            RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
        }
        RELEASE_SPIN_LOCK(&AfpSdaLock, OldIrql);
    }
    else
    {
        // Find the session matching the session id and, if found and the client is AFP v2.1,
        // copy the message to the SDA and send an attention to the client.
        // Error if the session either does not exist or it is not an AFP 2.1

        Status = AFPERR_InvalidId;
        if ((pSda = AfpSdaReferenceSessionById(SessId)) != NULL)
        {
            Status = AFPERR_InvalidSessionType;
            if (pSda->sda_ClientVersion >= AFP_VER_21)
            {
                ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
                if (pSda->sda_Message != NULL)
                    AfpFreeMemory(pSda->sda_Message);
                pSda->sda_Message = amsg;
                AfpSpSendAttention(pSda, ATTN_SERVER_MESSAGE, False);
                RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
                Status = AFP_ERR_NONE;
            }
            AfpSdaDereferenceSession(pSda);
        }
        if (Status != AFP_ERR_NONE)
        {
            AfpFreeMemory(amsg);
        }
    }

    return Status;
}


/***    AfpAdmWDirectoryGetInfo
 *
 *  Query a directory's permissions.
 */
AFPSTATUS
AfpAdmWDirectoryGetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PAFP_DIRECTORY_INFO pDirInfo = (PAFP_DIRECTORY_INFO)OutBuf;
    PSID                pSid = (PSID)((PBYTE)OutBuf + sizeof(AFP_DIRECTORY_INFO));
    UNICODE_STRING      VolumePath;
    ANSI_STRING         MacAnsiDirPath;
    SDA                 Sda;
    CONNDESC            ConnDesc;
    PVOLDESC            pVolDesc;
    FILEDIRPARM         FDParm;
    PATHMAPENTITY       PME;
    AFPSTATUS           Status;

    PAGED_CODE( );

    DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
            ("AfpAdmWDirectoryGetInfo entered for %ws\n",
            ((PAFP_DIRECTORY_INFO)InBuf)->afpdir_path));

    // validate the output buffer length
    if (OutBufLen < sizeof(AFP_DIRECTORY_INFO))
        return AFPERR_BufferSize;

    MacAnsiDirPath.Length = 0;
    MacAnsiDirPath.MaximumLength = 0;
    MacAnsiDirPath.Buffer = NULL;

    OutBufLen -= sizeof(AFP_DIRECTORY_INFO);

    // First find the volume that this directory is path of
    RtlInitUnicodeString(&VolumePath, ((PAFP_DIRECTORY_INFO)InBuf)->afpdir_path);

    if (!NT_SUCCESS(Status = AfpVolumeReferenceByPath(&VolumePath, &pVolDesc)))
    {
        DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_ERR,
                ("AfpAdmWDirectoryGetInfo: AfpVolumeReferenceByPath returned error %ld\n",
                Status));
        return Status;
    }

    // Now get the volume relative path of the directory.
    VolumePath.Buffer = (LPWSTR)((PBYTE)VolumePath.Buffer +
                                pVolDesc->vds_Path.Length);
    VolumePath.Length -= pVolDesc->vds_Path.Length;
    VolumePath.MaximumLength -= pVolDesc->vds_Path.Length;
    if ((SHORT)(VolumePath.Length) < 0)
    {
        VolumePath.Length = 0;
        VolumePath.MaximumLength = sizeof(WCHAR);
    }

    do
    {
        AfpInitializePME(&PME, 0, NULL);
        if (!NT_SUCCESS(Status = afpConvertAdminPathToMacPath(pVolDesc,
                                                              &VolumePath,
                                                              &MacAnsiDirPath)))
        {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

        // AfpMapAfpPathForLookup requires an Sda to figure out User's
        // permission. For this API, we do not really need the User's
        // permission, so kludge it up. Note that it is important to
        // set the client type to SDA_CLIENT_ADMIN to avoid references
        // to other sda fields. See access.c/fdparm.c/afpinfo.c for details.
        RtlZeroMemory(&Sda, sizeof(Sda));
#if DBG
        Sda.Signature = SDA_SIGNATURE;
#endif
        Sda.sda_ClientType = SDA_CLIENT_ADMIN;
        Sda.sda_UserSid = &AfpSidWorld;
        Sda.sda_GroupSid = &AfpSidWorld;

        // pathmap requires a ConnDesc to determine the VolDesc and Sda, so
        // kludge up a fake one here
        RtlZeroMemory(&ConnDesc, sizeof(ConnDesc));
#if DBG
        ConnDesc.Signature = CONNDESC_SIGNATURE;
#endif
        ConnDesc.cds_pSda = &Sda;
        ConnDesc.cds_pVolDesc = pVolDesc;

        AfpInitializeFDParms(&FDParm);

        Status = AfpMapAfpPathForLookup(&ConnDesc,
                                        AFP_ID_ROOT,
                                        &MacAnsiDirPath,
                                        AFP_LONGNAME,
                                        DFE_DIR,
                                        FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET |
                                            DIR_BITMAP_ACCESSRIGHTS |
                                            FD_BITMAP_ATTR,
                                        &PME,
                                        &FDParm);
        if (!NT_SUCCESS(Status))
        {
            if (Status == AFP_ERR_ACCESS_DENIED)
            {
                Status = STATUS_ACCESS_DENIED;
            }
            else
            {
                Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            break;
        }
    } while (False);

    if (PME.pme_Handle.fsh_FileHandle != NULL)
        AfpIoClose(&PME.pme_Handle);

    if (MacAnsiDirPath.Buffer != NULL)
    {
        AfpFreeMemory(MacAnsiDirPath.Buffer);
    }

    AfpVolumeDereference(pVolDesc);

    // All is hunky-dory so far. Now convert the information we have so far
    // into the form accepted by the API
    if (NT_SUCCESS(Status))
    {
        PSID    pSidUG;         // Sid of user or group

        pDirInfo->afpdir_perms =
                ((FDParm._fdp_OwnerRights & ~DIR_ACCESS_OWNER) << OWNER_RIGHTS_SHIFT) +
                ((FDParm._fdp_GroupRights & ~DIR_ACCESS_OWNER) << GROUP_RIGHTS_SHIFT) +
                ((FDParm._fdp_WorldRights & ~DIR_ACCESS_OWNER) << WORLD_RIGHTS_SHIFT);

        if ((FDParm._fdp_Attr &
             (FD_BITMAP_ATTR_RENAMEINH | FD_BITMAP_ATTR_DELETEINH)) ==
                        (FD_BITMAP_ATTR_RENAMEINH | FD_BITMAP_ATTR_DELETEINH))
            pDirInfo->afpdir_perms |= AFP_PERM_INHIBIT_MOVE_DELETE;

        DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
                ("AfpAdmWDirectoryGetInfo: Perms %lx\n", pDirInfo->afpdir_perms));

        pDirInfo->afpdir_path = NULL;

        // Translate the owner and group ids to Sids. The name fields actually
        // get the sids and the user mode code is responsible to convert it
        // to names.
        pDirInfo->afpdir_owner = NULL;
        pDirInfo->afpdir_group = NULL;
        do
        {
            LONG    LengthSid;

            //
            // Convert the owner ID to SID
            //
            if (FDParm._fdp_OwnerId != 0)
            {
                Status = AfpMacIdToSid(FDParm._fdp_OwnerId, &pSidUG);
                if (!NT_SUCCESS(Status))
                {
                    Status = STATUS_NONE_MAPPED;
                    break;
                }
                AfpDumpSid("AfpAdmWDirectoryGetInfo: User Sid:", pSidUG);

                LengthSid = RtlLengthSid(pSidUG);
                if (OutBufLen < LengthSid)
                    Status = AFPERR_BufferSize;
                else
                {
                    RtlCopyMemory(pSid, pSidUG, LengthSid);
                    pDirInfo->afpdir_owner = pSid;
                    POINTER_TO_OFFSET(pDirInfo->afpdir_owner, pDirInfo);
                    pSid = (PSID)((PBYTE)pSid + LengthSid);
                    OutBufLen -= LengthSid;
                }

                if (!NT_SUCCESS(Status))
                    break;
            }

            //
            // Convert the group ID to SID
            //
            if (FDParm._fdp_GroupId != 0)
            {
                Status = AfpMacIdToSid(FDParm._fdp_GroupId, &pSidUG);
                if (!NT_SUCCESS(Status))
                {
                    Status = STATUS_NONE_MAPPED;
                    break;
                }
                AfpDumpSid("AfpAdmWDirectoryGetInfo: Group Sid:", pSidUG);

                LengthSid = RtlLengthSid(pSidUG);
                if (OutBufLen < LengthSid)
                    Status = AFPERR_BufferSize;
                else
                {
                    RtlCopyMemory(pSid, pSidUG, LengthSid);
                    pDirInfo->afpdir_group = pSid;
                    POINTER_TO_OFFSET(pDirInfo->afpdir_group, pDirInfo);
                    // pSid = (PSID)((PBYTE)pSid + LengthSid);
                    // OutBufLen -= LengthSid;
                }
            }

        } while (False);
    }
    return Status;
}


/***    AfpAdmWDirectorySetInfo
 *
 *  Set a directory's permissions.
 */
AFPSTATUS
AfpAdmWDirectorySetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PAFP_DIRECTORY_INFO pDirInfo;
    DWORD               ParmNum, Bitmap = 0;
    UNICODE_STRING      VolumePath;
    SDA                 Sda;
    CONNDESC            ConnDesc;
    PVOLDESC            pVolDesc;
    AFPSTATUS           Status;
    BYTE                ParmBlock[4 * sizeof(DWORD)];
    FILEDIRPARM         FDParm;

    PAGED_CODE( );

    ParmNum = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;
    pDirInfo = (PAFP_DIRECTORY_INFO)((PBYTE)InBuf + sizeof(SETINFOREQPKT));

    DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
            ("AfpAdmWDirectorySetInfo entered for %ws (%lx)\n",
            pDirInfo->afpdir_path, ParmNum));

    // Convert the parmnum to a bitmap for use by AfpSetFileDirParms
    if (ParmNum & AFP_DIR_PARMNUM_PERMS)
        Bitmap |= (DIR_BITMAP_ACCESSRIGHTS | FD_BITMAP_ATTR);

    if (ParmNum & AFP_DIR_PARMNUM_OWNER)
    {
        if (pDirInfo->afpdir_owner == NULL)
            return STATUS_INVALID_PARAMETER;
        else
            Bitmap |= DIR_BITMAP_OWNERID;
    }

    if (ParmNum & AFP_DIR_PARMNUM_GROUP)
    {
        if (pDirInfo->afpdir_group == NULL)
            return STATUS_INVALID_PARAMETER;
        else
            Bitmap |= DIR_BITMAP_GROUPID;
    }

    // Find the volume that this directory is path of
    RtlInitUnicodeString(&VolumePath, pDirInfo->afpdir_path);

    if (!NT_SUCCESS(Status = AfpVolumeReferenceByPath(&VolumePath, &pVolDesc)))
        return Status;

    // Now get the volume relative path of the directory. Consume the leading
    // '\' character
    VolumePath.Buffer = (LPWSTR)((PBYTE)VolumePath.Buffer +
                                pVolDesc->vds_Path.Length);
    VolumePath.Length -= pVolDesc->vds_Path.Length;
    VolumePath.MaximumLength -= pVolDesc->vds_Path.Length;
    if ((SHORT)(VolumePath.Length) < 0)
    {
        VolumePath.Length = 0;
        VolumePath.MaximumLength = sizeof(WCHAR);
    }


    RtlZeroMemory(&Sda, sizeof(Sda));

    if (Bitmap) do
    {
        if (!NT_SUCCESS(Status = afpConvertAdminPathToMacPath(pVolDesc,
                                                              &VolumePath,
                                                              &Sda.sda_Name1)))
        {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

        // Kludge up a FILEDIRPARMS structure to call AfpPackFDParms with
        AfpInitializeFDParms(&FDParm);

        if (Bitmap & FD_BITMAP_ATTR)
        {
            FDParm._fdp_Attr =  FD_BITMAP_ATTR_RENAMEINH |
                                FD_BITMAP_ATTR_DELETEINH;

            if (pDirInfo->afpdir_perms & AFP_PERM_INHIBIT_MOVE_DELETE)
            {
                FDParm._fdp_Attr |= FD_BITMAP_ATTR_SET;
            }

            DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
                    ("AfpAdmWDirectorySetInfo: Changing Attributes to %lx\n",
                    FDParm._fdp_Attr));
        }

        if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
        {
            FDParm._fdp_OwnerRights = (BYTE)(pDirInfo->afpdir_perms >> OWNER_RIGHTS_SHIFT);
            FDParm._fdp_GroupRights = (BYTE)(pDirInfo->afpdir_perms >> GROUP_RIGHTS_SHIFT);
            FDParm._fdp_WorldRights = (BYTE)(pDirInfo->afpdir_perms >> WORLD_RIGHTS_SHIFT);

            DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
                    ("AfpAdmWDirectorySetInfo: Setting Permissions %x,%x,%x\n",
                    FDParm._fdp_OwnerRights,
                    FDParm._fdp_GroupRights,
                    FDParm._fdp_WorldRights));
        }

        // See if we need to change owner and group ids
        if (Bitmap & DIR_BITMAP_OWNERID)
        {
            Status = AfpSidToMacId((PSID)(pDirInfo->afpdir_owner),
                                          &FDParm._fdp_OwnerId);
            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_NONE_MAPPED;
                break;
            }

            AfpDumpSid("AfpAdmWDirectorySetInfo: Changing Owner to:",
                                            (PSID)(pDirInfo->afpdir_owner));
        }

        if (Bitmap & DIR_BITMAP_GROUPID)
        {
            Status = AfpSidToMacId((PSID)(pDirInfo->afpdir_group),
                                          &FDParm._fdp_GroupId);
            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_NONE_MAPPED;
                break;
            }

            AfpDumpSid("AfpAdmWDirectorySetInfo: Changing Group to:",
                                            (PSID)(pDirInfo->afpdir_group));
        }
        FDParm._fdp_Flags = DFE_FLAGS_DIR;
        AfpPackFileDirParms(&FDParm, Bitmap, ParmBlock);

        // AfpQueryFileDirParms requires an Sda to figure out User's
        // permission. For this API, we do not really need the User's
        // permission, so kludge it up. Note that it is important to
        // set the client type to SDA_CLIENT_ADMIN to avoid references
        // to other sda fields. See access.c/fdparm.c/afpinfo.c for details.

        Sda.sda_ClientType = SDA_CLIENT_ADMIN;
        Sda.sda_UserSid = &AfpSidWorld;
        Sda.sda_GroupSid = &AfpSidWorld;

        *((PULONG_PTR)Sda.sda_ReqBlock) = (ULONG_PTR)&ConnDesc;
        //if (sizeof (DWORD) != sizeof (ULONG_PTR))
#ifdef _WIN64
        // Create 64-bit space at start of buffer to hold ConnDesc pointer
            // 64-bit specifics
            Sda.sda_ReqBlock[2] = AFP_ID_ROOT;
            Sda.sda_ReqBlock[3] = Bitmap;
#else
            Sda.sda_ReqBlock[1] = AFP_ID_ROOT;
            Sda.sda_ReqBlock[2] = Bitmap;
#endif

        Sda.sda_PathType = AFP_LONGNAME;
        Sda.sda_Name2.Buffer = ParmBlock;
        Sda.sda_Name2.Length = Sda.sda_Name2.MaximumLength = sizeof(ParmBlock);

        // pathmap requires a ConnDesc to determine the VolDesc and Sda, so
        // kludge up a fake one here
        RtlZeroMemory(&ConnDesc, sizeof(ConnDesc));
#if DBG
        ConnDesc.Signature = CONNDESC_SIGNATURE;
        Sda.Signature = SDA_SIGNATURE;
#endif
        ConnDesc.cds_pSda = &Sda;
        ConnDesc.cds_pVolDesc = pVolDesc;

        if (!NT_SUCCESS(Status = AfpFspDispSetDirParms(&Sda)))
        {
            DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
                    ("AfpAdmWDirectorySetInfo: AfpFspDispSetDirParms failed 0x%lx\n",
                    Status));

            if (Status == AFP_ERR_ACCESS_DENIED)
            {
                Status = STATUS_ACCESS_DENIED;
            }
            else
            {
                Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        }

    } while (False);

    if (Sda.sda_Name1.Buffer != NULL)
    {
        AfpFreeMemory(Sda.sda_Name1.Buffer);
    }

    AfpVolumeDereference(pVolDesc);

    return Status;
}

/***    AfpAdmWFinderSetInfo
 *
 *  Set the type and/or creator of a file.
 *  (Note this routine can be expanded later to set other Finder info if
 *  needed)
 *
 *  LOCKS: vds_IdDbAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAdmWFinderSetInfo(
    IN  OUT PVOID   InBuf       OPTIONAL,
    IN  LONG        OutBufLen   OPTIONAL,
    OUT PVOID       OutBuf      OPTIONAL
)
{
    PAFP_FINDER_INFO    pAdmFDInfo;
    DWORD               ParmNum, Bitmap = 0;
    UNICODE_STRING      VolumePath, UTypeCreatorString;
    ANSI_STRING         MacAnsiFileDirPath, ATypeCreatorString;
    SDA                 Sda;
    CONNDESC            ConnDesc;
    PVOLDESC            pVolDesc;
    AFPSTATUS           Status;
    FILEDIRPARM         FDParm;
    PATHMAPENTITY       PME;
    BYTE                Type[AFP_TYPE_LEN] = "    ";        // Pad with spaces
    BYTE                Creator[AFP_CREATOR_LEN] = "    ";  // Pad with spaces

    PAGED_CODE( );

    pAdmFDInfo = (PAFP_FINDER_INFO)((PBYTE)InBuf + sizeof(SETINFOREQPKT));
    ParmNum = ((PSETINFOREQPKT)InBuf)->sirqp_parmnum;

    DBGPRINT(DBG_COMP_ADMINAPI_DIR, DBG_LEVEL_INFO,
            ("AfpAdmWFinderSetInfo entered for %ws (%lx)\n",
            pAdmFDInfo->afpfd_path, ParmNum));

    if ((ParmNum & ~AFP_FD_PARMNUM_ALL) || !ParmNum)
    {
        return AFPERR_InvalidParms;
    }

    // Convert the parmnum to a bitmap for use by pathmap to retrieve current
    // settings of FinderInfo, and convert type and creator to space padded
    // mac ansi
    if (ParmNum & AFP_FD_PARMNUM_TYPE)
    {
        Bitmap |= FD_BITMAP_FINDERINFO;
        RtlInitUnicodeString(&UTypeCreatorString, pAdmFDInfo->afpfd_type);
        if ((UTypeCreatorString.Length == 0) ||
            (UTypeCreatorString.Length/sizeof(WCHAR) > AFP_TYPE_LEN))
        {
            return AFPERR_InvalidParms;
        }
        ATypeCreatorString.Length = 0;
        ATypeCreatorString.MaximumLength = sizeof(Type);
        ATypeCreatorString.Buffer = Type;
        Status = AfpConvertStringToAnsi(&UTypeCreatorString,
                                        &ATypeCreatorString);
        if (!NT_SUCCESS(Status))
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (ParmNum & AFP_FD_PARMNUM_CREATOR)
    {
        Bitmap |= FD_BITMAP_FINDERINFO;
        RtlInitUnicodeString(&UTypeCreatorString, pAdmFDInfo->afpfd_creator);
        if ((UTypeCreatorString.Length == 0) ||
            (UTypeCreatorString.Length/sizeof(WCHAR) > AFP_CREATOR_LEN))
        {
            return AFPERR_InvalidParms;
        }
        ATypeCreatorString.Length = 0;
        ATypeCreatorString.MaximumLength = sizeof(Creator);
        ATypeCreatorString.Buffer = Creator;
        Status = AfpConvertStringToAnsi(&UTypeCreatorString,
                                        &ATypeCreatorString);
        if (!NT_SUCCESS(Status))
        {
            return STATUS_UNSUCCESSFUL;
        }
    }


    MacAnsiFileDirPath.Length = 0;
    MacAnsiFileDirPath.MaximumLength = 0;
    MacAnsiFileDirPath.Buffer = NULL;

    // First find the volume that this directory is path of
    RtlInitUnicodeString(&VolumePath, pAdmFDInfo->afpfd_path);

    if (!NT_SUCCESS(Status = AfpVolumeReferenceByPath(&VolumePath, &pVolDesc)))
        return Status;

    // Now get the volume relative path of the file/directory.
    VolumePath.Buffer = (LPWSTR)((PBYTE)VolumePath.Buffer +
                                pVolDesc->vds_Path.Length);
    VolumePath.Length -= pVolDesc->vds_Path.Length;
    VolumePath.MaximumLength -= pVolDesc->vds_Path.Length;
    if ((SHORT)(VolumePath.Length) < 0)
    {
        VolumePath.Length = 0;
        VolumePath.MaximumLength = sizeof(WCHAR);
    }

    if (Bitmap) do
    {
        AfpInitializeFDParms(&FDParm);
        AfpInitializePME(&PME, 0, NULL);
        if (!NT_SUCCESS(Status = afpConvertAdminPathToMacPath(pVolDesc,
                                                              &VolumePath,
                                                              &MacAnsiFileDirPath)))
        {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            break;
        }

        // pathmap requires a ConnDesc to determine the VolDesc and Sda, so
        // kludge up a fake one here
        RtlZeroMemory(&ConnDesc, sizeof(ConnDesc));
#if DBG
        ConnDesc.Signature = CONNDESC_SIGNATURE;
#endif
        Sda.sda_ClientType = SDA_CLIENT_ADMIN;
        ConnDesc.cds_pSda = &Sda;
        ConnDesc.cds_pVolDesc = pVolDesc;

        Status = AfpMapAfpPathForLookup(&ConnDesc, AFP_ID_ROOT,
                                        &MacAnsiFileDirPath,
                                        AFP_LONGNAME,
                                        DFE_ANY,
                                        FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET |
                                        FD_BITMAP_LONGNAME | Bitmap,
                                        &PME,
                                        &FDParm);
        if (!NT_SUCCESS(Status))
        {
            if (Status == AFP_ERR_ACCESS_DENIED)
            {
                Status = STATUS_ACCESS_DENIED;
            }
            else
            {
                Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
            break;
        }

        // Copy the input Finder info into the FDParms structure
        if (ParmNum & AFP_FD_PARMNUM_TYPE)
            RtlCopyMemory(&FDParm._fdp_FinderInfo.fd_Type,
                          Type, AFP_TYPE_LEN);

        if (ParmNum & AFP_FD_PARMNUM_CREATOR)
            RtlCopyMemory(&FDParm._fdp_FinderInfo.fd_Creator,
                          Creator, AFP_CREATOR_LEN);

        // Set the AfpInfo
        AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
        Status = AfpSetAfpInfo(&PME.pme_Handle, Bitmap, &FDParm, pVolDesc, NULL);
        AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

    } while (False);

    if (PME.pme_Handle.fsh_FileHandle != NULL)
        AfpIoClose(&PME.pme_Handle);

    if (MacAnsiFileDirPath.Buffer != NULL)
    {
        AfpFreeMemory(MacAnsiFileDirPath.Buffer);
    }

    AfpVolumeDereference(pVolDesc);

    return Status;
}

/***    AfpLookupEtcMapEntry
 *
 *  Lookup a type/creator mapping in the global table by comparing the
 *  extension to the desired extension.  Note the default type creator
 *  mapping is not kept in the table.
 *
 *  LOCKS_ASSUMED: AfpEtcMapLock (SWMR, Shared)
 */
PETCMAPINFO
AfpLookupEtcMapEntry(
    PUCHAR  pExt
)
{
    PETCMAPINFO petc = NULL;
    ANSI_STRING alookupext, atableext;
    int i;

    PAGED_CODE( );

    if (AfpEtcMapCount == 0)
    {
        return NULL;
    }

    ASSERT ((AfpEtcMapsSize > 0) && (AfpEtcMaps != NULL));

    RtlInitString(&alookupext,pExt);
    for (i=0;i<AfpEtcMapsSize;i++)
    {
        RtlInitString(&atableext,AfpEtcMaps[i].etc_extension);
        if (RtlEqualString(&atableext, &alookupext,True))
        {
            petc = &(AfpEtcMaps[i]);
            break;
        }
    }

    return petc;
}


/***    afpEtcMapDelete
 *
 *  Mark the extension/type/creator table entry as deleted by setting the
 *  extension field to null.  Decrement the count of valid entries.  If
 *  the number of free entries goes above a certain level, shrink the
 *  table down to a reasonable size.
 *
 *  LOCKS_ASSUMED: AfpEtcMapLock (SWMR, Exclusive)
 *
 */
VOID
afpEtcMapDelete(
    PETCMAPINFO pEtcEntry
)
{
    PETCMAPINFO ptemptable;
    LONG        newtablesize, nextnewentry, i;

    PAGED_CODE( );

    //
    // a null extension denotes an invalid ext/type/creator mapping table entry
    //
    pEtcEntry->etc_extension[0] = '\0';
    AfpEtcMapCount --;
    ASSERT (AfpEtcMapCount >= 0);

    if ((AfpEtcMapsSize - AfpEtcMapCount) > AFP_MAX_FREE_ETCMAP_ENTRIES)
    {
        //
        // shrink the type/creator table by AFP_MAX_FREE_ETCMAP_ENTRIES
        //
        newtablesize = (AfpEtcMapsSize - AFP_MAX_FREE_ETCMAP_ENTRIES);

        if ((ptemptable = (PETCMAPINFO)AfpAllocZeroedPagedMemory(newtablesize * sizeof(ETCMAPINFO))) == NULL)
        {
            return;
        }

        nextnewentry = 0;
        for (i=0;i<AfpEtcMapsSize;i++)
        {
            if (afpIsValidEtcMapEntry(AfpEtcMaps[i].etc_extension))
            {
                ASSERT(nextnewentry < AfpEtcMapCount);
                RtlCopyMemory(&ptemptable[nextnewentry++], &AfpEtcMaps[i], sizeof(ETCMAPINFO));
            }
        }
        AfpFreeMemory(AfpEtcMaps);
        AfpEtcMaps = ptemptable;
        AfpEtcMapsSize = newtablesize;
    }
}


/***    afpGetNextFreeEtcMapEntry
 *
 *  Look for an empty entry in the extension/type/creator table starting
 *  at the entry StartIndex.
 *
 *  LOCKS_ASSUMED: AfpEtcMapLock (SWMR, Exclusive)
 */
PETCMAPINFO
afpGetNextFreeEtcMapEntry(
    IN OUT PLONG    StartIndex
)
{
    PETCMAPINFO tempptr = NULL;
    LONG        i;

    PAGED_CODE( );

    for (i = *StartIndex; i < AfpEtcMapsSize; i++)
    {
        if (!afpIsValidEtcMapEntry(AfpEtcMaps[i].etc_extension))
        {
            tempptr = &AfpEtcMaps[i];
            *StartIndex = i++;
            break;
        }
    }
    return tempptr;
}


/*** afpCopyMapInfo2ToMapInfo
 *
 *  Copy the etc info structure given to us by the Service into our structure, after
 *  converting the etc_extension field from Unicode to Ansi.
 *
 */
NTSTATUS
afpCopyMapInfo2ToMapInfo(
    OUT PETCMAPINFO     pEtcDest,
    IN  PETCMAPINFO2    pEtcSource
)
{

    UCHAR           ext[AFP_EXTENSION_LEN+1];
    WCHAR           wext[AFP_EXTENSION_LEN+1];
    ANSI_STRING     aext;
    NTSTATUS        Status;
    UNICODE_STRING  uext;


    AfpSetEmptyAnsiString(&aext, sizeof(ext), ext);

    uext.Length = uext.MaximumLength = sizeof(pEtcSource->etc_extension);
    uext.Buffer = pEtcSource->etc_extension;
    Status = AfpConvertMungedUnicodeToAnsi(&uext, &aext);
    ASSERT(NT_SUCCESS(Status));

    RtlCopyMemory(pEtcDest->etc_extension, aext.Buffer, AFP_EXTENSION_LEN);
    pEtcDest->etc_extension[AFP_EXTENSION_LEN] = 0;

    // Copy the other two fields as-is

    RtlCopyMemory(pEtcDest->etc_type, pEtcSource->etc_type, AFP_TYPE_LEN);
    RtlCopyMemory(pEtcDest->etc_creator, pEtcSource->etc_creator, AFP_CREATOR_LEN);

    return STATUS_SUCCESS;
}

/*** afpConvertAdminPathToMacPath
 *
 *  Convert an admin volume relative NTFS path which may contain
 *  components > 31 chars, or may contain shortnames, to the
 *  equivalent mac path (in mac ANSI) so that the path may be sent thru the
 *  pathmap code.  Caller must free path buffer if success is returned.
 */
NTSTATUS
afpConvertAdminPathToMacPath(
    IN  PVOLDESC        pVolDesc,
    IN  PUNICODE_STRING AdminPath,
    OUT PANSI_STRING    MacPath
)
{
    USHORT          tempAdminPathlen = 0, numchars, numcomponents, i;
    WCHAR           wbuf[AFP_LONGNAME_LEN + 1];
    UNICODE_STRING  component, component2;
    UNICODE_STRING  pathSoFar, pathToParent;
    NTSTATUS        Status = STATUS_SUCCESS;
    CHAR            abuf[AFP_LONGNAME_LEN + 1];
    ANSI_STRING     macansiComponent;
    PWSTR           tempptr;
    FILESYSHANDLE   hComponent;
    BOOLEAN         NTFSShortname;

    PAGED_CODE( );

    // ASSERT(IS_VOLUME_NTFS(pVolDesc));

    // assert that the path does not begin with a backslash
    ASSERT((AdminPath->Length == 0) || (AdminPath->Buffer[0] != L'\\'));

    component2.Length = 0;
    component2.MaximumLength = sizeof(wbuf);
    component2.Buffer = wbuf;

    macansiComponent.Length = 0;
    macansiComponent.MaximumLength = sizeof(abuf);
    macansiComponent.Buffer = abuf;

    MacPath->Length = MacPath->MaximumLength = 0;
    MacPath->Buffer = NULL;

    // return success if no path components
    if (AdminPath->Length == 0)
    {
        return STATUS_SUCCESS;
    }

    numchars = AdminPath->Length / sizeof(WCHAR);
    // strip a trailing path separator if it exists
    if (AdminPath->Buffer[numchars - 1] == L'\\')
    {
        AdminPath->Length -= sizeof(WCHAR);
    }

    for (numcomponents = 1, i = 0; i < numchars; i++)
    {
        if (AdminPath->Buffer[i] == L'\\')
        {
            numcomponents++;
        }
    }

    // allocate a buffer to hold the mac (in mac ANSI) version of the path and
    // path separators
    MacPath->MaximumLength = numcomponents * AFP_LONGNAME_LEN + numcomponents;
    if ((MacPath->Buffer = (PCHAR)AfpAllocPagedMemory(MacPath->MaximumLength))
                                                                        == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pathSoFar = *AdminPath;
    pathSoFar.Length = 0;
    tempptr = AdminPath->Buffer;

    while (numcomponents)
    {
        hComponent.fsh_FileHandle = NULL;
        component.Buffer = tempptr;
        component2.Length = macansiComponent.Length = 0;
        NTFSShortname = False;
        numchars = 0;

        while (True)
        {
            if (tempptr[numchars] == L'~')
            {
                NTFSShortname = True;
            }

            if ((tempptr[numchars] == L'\\') ||
                ((numcomponents == 1) &&
                 (pathSoFar.Length + numchars * sizeof(WCHAR)
                                            == AdminPath->Length)))
            {
                break;
            }
            numchars ++;
        }

        component.Length = component.MaximumLength = numchars * sizeof(WCHAR);
        pathToParent = pathSoFar;
        pathSoFar.Length += component.Length;
        tempptr += numchars + 1;


        if ((numchars > AFP_LONGNAME_LEN) || (NTFSShortname))
        {
            // open a handle to the directory so we can query the name;
            // to query the shortname we need a handle to the actual
            // directory; to query the longname, we need a handle to the
            // parent directory because of the way we have to
            // get the longname by enumerating the parent for one entry
            // with the name we are looking for
            if (NT_SUCCESS(Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
                                              AFP_STREAM_DATA,
                                              FILEIO_OPEN_DIR,
                                              ((numchars <= AFP_LONGNAME_LEN) && NTFSShortname) ?
                                                &pathToParent : &pathSoFar,
                                              FILEIO_ACCESS_NONE,
                                              FILEIO_DENY_NONE,
                                              False,
                                              &hComponent)))
            {
                if (numchars > AFP_LONGNAME_LEN)
                {
                    // query the shortname
                    Status = AfpIoQueryShortName(&hComponent, &macansiComponent);
                }
                else
                {
                    // we saw a tilde and are assuming it is the shortname,
                    // and the path is 31 chars or less; query the longname
                    if (NT_SUCCESS(Status = AfpIoQueryLongName(&hComponent,
                                                               &component,
                                                               &component2)))
                    {
                        Status = AfpConvertMungedUnicodeToAnsi(&component2,
                                                               &macansiComponent);
                    }
                }
                AfpIoClose(&hComponent);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
            }
            else
            {
                // open failed
                break;
            }
        }
        else
        {
            // use the component name as it was given by admin
            if (!NT_SUCCESS(Status = AfpConvertMungedUnicodeToAnsi(&component,
                                                                   &macansiComponent)))
            {
                break;
            }
        }

        Status = RtlAppendStringToString(MacPath, &macansiComponent);
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        // include the path separator in the admin path seen so far
        pathSoFar.Length += sizeof(WCHAR);

        // add a path separator to the mac ansi path
        MacPath->Buffer[MacPath->Length++] = AFP_PATHSEP;
        ASSERT(MacPath->Length <= MacPath->MaximumLength);

        numcomponents --;
    } // while numcomponents

    if (!NT_SUCCESS(Status) && (MacPath->Buffer != NULL))
    {
        AfpFreeMemory(MacPath->Buffer);
        MacPath->Buffer = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afpinfo.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpinfo.c

Abstract:

	This module contains the routines for manipulating the afpinfo stream.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4

--*/


#define	FILENUM	FILE_AFPINFO

#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <afpadmin.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpSetAfpInfo)
#pragma alloc_text( PAGE, AfpReadAfpInfo)
#pragma alloc_text( PAGE, AfpSetFinderInfoByExtension)
#pragma alloc_text( PAGE, AfpProDosInfoFromFinderInfo)
#pragma alloc_text( PAGE, AfpFinderInfoFromProDosInfo)
#pragma alloc_text( PAGE, AfpSlapOnAfpInfoStream)
#pragma alloc_text( PAGE, AfpCreateAfpInfoStream)
#pragma alloc_text( PAGE, AfpExamineAndClearROAttr)
#pragma alloc_text( PAGE, AfpQueryProDos)
#endif

/***	AfpSetAfpInfo
 *
 *	Sets the values specified by Bitmap in the AFP_AfpInfo stream of a file
 *	or directory.  If FinderInfo is specified without ProDosInfo, or
 *	vice-versa, the one not specified is deduced from the other and also set.
 *	If the file/dir is marked ReadOnly, we must clear the readonly bit in order
 *	to write to the Afp_AfpInfo stream, and then set the RO bit back again.
 *  If pVolDesc is specified, then also update the cached AfpInfo in the
 *  IdDb DFENTRY.
 *
  */
AFPSTATUS
AfpSetAfpInfo(
	IN	PFILESYSHANDLE	pfshData,				// handle to data stream of object
	IN	DWORD			Bitmap,
	IN	PFILEDIRPARM	pFDParms,
	IN	PVOLDESC		pVolDesc	OPTIONAL,	// if present, update cached afpinfo
	IN	PDFENTRY	*	ppDFE		OPTIONAL	// pVolDesc must also be specified
)
{
	NTSTATUS		Status;
	DWORD			crinfo, NTAttr = 0;
	AFPINFO			afpinfo;
	FILESYSHANDLE	fshAfpInfo;
	BOOLEAN			isdir, WriteBackROAttr = False, mapprodos = False;
	PDFENTRY		pDfEntry = NULL;

	PAGED_CODE( );

	fshAfpInfo.fsh_FileHandle = NULL;

	isdir = IsDir(pFDParms);

	if (ARGUMENT_PRESENT(pVolDesc))
	{
		ASSERT(AfpSwmrLockedExclusive(&pVolDesc->vds_IdDbAccessLock));
		pDfEntry = AfpFindDfEntryById(pVolDesc,
									  pFDParms->_fdp_AfpId,
									  isdir ? DFE_DIR : DFE_FILE);
		if (pDfEntry == NULL)
		{
			return AFP_ERR_OBJECT_NOT_FOUND;
		}
	}

	do
	{
		if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, &fshAfpInfo, &crinfo)))
		{
			if (Status == STATUS_ACCESS_DENIED)
			{
				// We may have failed to open the AFP_Afpinfo stream because
				// the file/dir is marked ReadOnly.  Clear the ReadOnly bit
				// and try to open it again.
				Status = AfpExamineAndClearROAttr(pfshData,
												  &WriteBackROAttr,
												  NULL,
												  NULL);
				if (NT_SUCCESS(Status))
				{
					if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, &fshAfpInfo, &crinfo)))
					{
						AfpPutBackROAttr(pfshData, WriteBackROAttr);
						Status = AfpIoConvertNTStatusToAfpStatus(Status);
						break;
					}
				}
				else
				{
					Status = AFP_ERR_MISC;
					break;
				}
			}
			else
			{
				Status = AfpIoConvertNTStatusToAfpStatus(Status);
				break;
			}
		}

		// If it was newly created or it existed but was corrupted, then initialize
		// it with default data.  Otherwise read in the current data
		if ((crinfo == FILE_CREATED) ||
			(!NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &afpinfo))))
		{
			UNICODE_STRING	UName;
			WCHAR			NameBuf[AFP_LONGNAME_LEN+1];

			if (crinfo != FILE_CREATED)
			{
				AFPLOG_HERROR(AFPSRVMSG_AFPINFO,
							  0,
							  NULL,
							  0,
							  pfshData->fsh_FileHandle);
			}

			if (!isdir)
			{
				AfpSetEmptyUnicodeString(&UName, sizeof(NameBuf), NameBuf);
				AfpConvertStringToMungedUnicode(&pFDParms->_fdp_LongName, &UName);
			}

			// All callers of this routine must have the FD_BITMAP_LONGNAME
			// bit forced in their bitmap to pathmap, so that in this case
			// where the afpinfo stream must be recreated for a *file*, we
			// will always have a valid _fdp_Longname set in FDParm and can
			// deduce the type/creator
			if (!NT_SUCCESS(AfpSlapOnAfpInfoStream(NULL,
												   NULL,
												   pfshData,
												   &fshAfpInfo,
												   pFDParms->_fdp_AfpId,
												   isdir,
												   isdir ? NULL : &UName,
												   &afpinfo)))
			{
				Status = AFP_ERR_MISC;
				break;
			}
			else if (pDfEntry != NULL)
				DFE_UPDATE_CACHED_AFPINFO(pDfEntry, &afpinfo);
		}

		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			afpinfo.afpi_BackupTime = pFDParms->_fdp_BackupTime;
			if (pDfEntry != NULL)
				pDfEntry->dfe_BackupTime = afpinfo.afpi_BackupTime;
		}

		if (Bitmap & FD_BITMAP_FINDERINFO)
		{	// Only map new ProDOS info if there has been a change in the
			// type/creator, and FD_BITMAP_PRODOSINFO is not set (files only)
			if (!(Bitmap & FD_BITMAP_PRODOSINFO) &&
				!isdir &&
				((RtlCompareMemory(afpinfo.afpi_FinderInfo.fd_Type,
								   pFDParms->_fdp_FinderInfo.fd_Type,
								   AFP_TYPE_LEN) != AFP_TYPE_LEN) ||
				 (RtlCompareMemory(afpinfo.afpi_FinderInfo.fd_Creator,
								   pFDParms->_fdp_FinderInfo.fd_Creator,
								   AFP_CREATOR_LEN) != AFP_CREATOR_LEN)))
			{
				mapprodos = True;
			}

			afpinfo.afpi_FinderInfo = pFDParms->_fdp_FinderInfo;

			if (mapprodos)
			{
				AfpProDosInfoFromFinderInfo(&afpinfo.afpi_FinderInfo,
											&afpinfo.afpi_ProDosInfo);
			}

			if (pDfEntry != NULL)
				pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
		}

		if (Bitmap & FD_BITMAP_PRODOSINFO)
		{
			if ((IsDir(pFDParms)) &&
				(pFDParms->_fdp_ProDosInfo.pd_FileType[0] != PRODOS_TYPE_DIR))
			{
				Status = AFP_ERR_ACCESS_DENIED;
				break;
			}

			afpinfo.afpi_ProDosInfo = pFDParms->_fdp_ProDosInfo;

			if (!(Bitmap & FD_BITMAP_FINDERINFO) && !isdir)
			{
				AfpFinderInfoFromProDosInfo(&afpinfo.afpi_ProDosInfo,
											&afpinfo.afpi_FinderInfo);
				if (pDfEntry != NULL)
					pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
			}
		}

		if (Bitmap & FD_BITMAP_ATTR)
		{
			afpinfo.afpi_Attributes =
							pFDParms->_fdp_EffectiveAttr & ~FD_BITMAP_ATTR_SET;
			if (pDfEntry != NULL)
				pDfEntry->dfe_AfpAttr = afpinfo.afpi_Attributes;
		}

		if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
		{
			ASSERT(isdir == True);
			afpinfo.afpi_AccessOwner = pFDParms->_fdp_OwnerRights;
			afpinfo.afpi_AccessGroup = pFDParms->_fdp_GroupRights;
			afpinfo.afpi_AccessWorld = pFDParms->_fdp_WorldRights;

			if (pDfEntry != NULL)
			{
				DFE_OWNER_ACCESS(pDfEntry) = afpinfo.afpi_AccessOwner;
				DFE_GROUP_ACCESS(pDfEntry) = afpinfo.afpi_AccessGroup;
				DFE_WORLD_ACCESS(pDfEntry) = afpinfo.afpi_AccessWorld;
			}
		}

		// FILE_BITMAP_FILENUM can ONLY be set by the internal CopyFile code
		// and internal ExchangeFiles code
		if (Bitmap & FILE_BITMAP_FILENUM)
		{
			ASSERT(isdir == False);
			afpinfo.afpi_Id = pFDParms->_fdp_AfpId;
		}

		Status = AfpWriteAfpInfo(&fshAfpInfo, &afpinfo);
		if (!NT_SUCCESS(Status))
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
	} while (False);

	AfpPutBackROAttr(pfshData, WriteBackROAttr);
	if (fshAfpInfo.fsh_FileHandle != NULL)
		AfpIoClose(&fshAfpInfo);

	if (ARGUMENT_PRESENT(ppDFE))
	{
		ASSERT(ARGUMENT_PRESENT(pVolDesc));
		*ppDFE = pDfEntry;
	}

	return Status;
}

/***	AfpReadAfpInfo
 *
 *	When discovering a file/dir that has the AfpInfo stream, read it in
 *
 */
NTSTATUS FASTCALL
AfpReadAfpInfo(
	IN	PFILESYSHANDLE	pfshAfpInfo,
	OUT PAFPINFO		pAfpInfo
)
{
	NTSTATUS	Status;
	LONG		sizeRead;

	PAGED_CODE( );

	Status = AfpIoRead(pfshAfpInfo,
					   &LIZero,
					   sizeof(AFPINFO),
					   &sizeRead,
					   (PBYTE)pAfpInfo);

	if (!NT_SUCCESS(Status)									||
		(sizeRead != sizeof(AFPINFO))						||
		(pAfpInfo->afpi_Signature != AFP_SERVER_SIGNATURE)	||
		(pAfpInfo->afpi_Version != AFP_SERVER_VERSION))
	{
		if (NT_SUCCESS(Status) &&
			(sizeRead != 0)	   &&
			((pAfpInfo->afpi_Signature != AFP_SERVER_SIGNATURE)	||
			 (pAfpInfo->afpi_Version != AFP_SERVER_VERSION)))
		{
			AFPLOG_HERROR(AFPSRVMSG_AFPINFO,
						  Status,
						  NULL,
						  0,
						  pfshAfpInfo->fsh_FileHandle);
		}

		if ((sizeRead != sizeof(AFPINFO)) && (sizeRead != 0))
		{
			DBGPRINT(DBG_COMP_AFPINFO, DBG_LEVEL_ERR,
					 ("AfpReadAfpInfo: sizeRead (%d) != sizeof AFPINFO (%d)",
					 sizeRead, sizeof(AFPINFO)));
		}
		AfpIoSetSize(pfshAfpInfo, 0);
		Status = STATUS_UNSUCCESSFUL;
	}

	return Status;
}

/***	AfpSetFinderInfoByExtension
 *
 *	Set the finder info (type/creator) based on the file extension. Only long
 *	name is used for this mapping.
 *
 *	LOCKS: AfpEtcMapLock (SWMR, Shared)
 */
VOID FASTCALL
AfpSetFinderInfoByExtension(
	IN	PUNICODE_STRING	pFileName,
	OUT	PFINDERINFO		pFinderInfo
)
{
	PETCMAPINFO		pEtcMap = NULL;
	PWCHAR			pch;
	DWORD			len, i = AFP_EXTENSION_LEN;
	UCHAR			ext[AFP_EXTENSION_LEN+1];
	WCHAR			wext[AFP_EXTENSION_LEN+1];
	ANSI_STRING		aext;
	UNICODE_STRING	uext;

	PAGED_CODE( );

    RtlZeroMemory(ext, sizeof(ext));

	ASSERT(pFileName != NULL);

	// Find the last character of the filename
	pch = pFileName->Buffer + (pFileName->Length - sizeof(WCHAR))/sizeof(WCHAR);
	len = pFileName->Length/sizeof(WCHAR);

	AfpSwmrAcquireShared(&AfpEtcMapLock);

	while ((AFP_EXTENSION_LEN - i) < len)
	{
		if (*pch == L'.')
		{
			if (i < AFP_EXTENSION_LEN)
			{
				AfpSetEmptyAnsiString(&aext, sizeof(ext), ext);
				AfpInitUnicodeStringWithNonNullTerm(&uext,
													(USHORT)((AFP_EXTENSION_LEN - i)*sizeof(WCHAR)),
													&wext[i]);
				AfpConvertMungedUnicodeToAnsi(&uext, &aext);
				pEtcMap = AfpLookupEtcMapEntry(ext);
			}
			break;
		}
		if (i == 0)
			break;
		wext[--i] = *(pch--);
	}

	if (pEtcMap == NULL)
		pEtcMap = &AfpDefaultEtcMap;

	RtlCopyMemory(&pFinderInfo->fd_Type, &pEtcMap->etc_type, AFP_TYPE_LEN);
	RtlCopyMemory(&pFinderInfo->fd_Creator, &pEtcMap->etc_creator, AFP_CREATOR_LEN);
	AfpSwmrRelease(&AfpEtcMapLock);
}

/***	AfpProDosInfoFromFinderInfo
 *
 *	Given finder info, deduce the corresponding prodos info. It is up to the
 *	caller to decide whether or not FinderInfo type/creator is actually
 *	changing (if client is just resetting the same values or not), in which
 *	case the prodos info should be left untouched. (Inside Appletalk p. 13-19)
 *	NOTE: see layout of ProDOS info on p. 13-18 of Inside Appletalk, 2nd Ed.)
 */
VOID FASTCALL
AfpProDosInfoFromFinderInfo(
	IN	PFINDERINFO	pFinderInfo,
	OUT PPRODOSINFO pProDosInfo
)
{
	CHAR		buf[3];
	ULONG		filetype;
	NTSTATUS	Status;

	PAGED_CODE( );

	RtlZeroMemory(pProDosInfo, sizeof(PRODOSINFO));
	if (RtlCompareMemory(pFinderInfo->fd_Type, "TEXT", AFP_TYPE_LEN) == AFP_TYPE_LEN)
	{
		pProDosInfo->pd_FileType[0] = PRODOS_TYPE_FILE;
	}
	else if (RtlCompareMemory(pFinderInfo->fd_Creator,
							  "pdos",
							  AFP_CREATOR_LEN) == AFP_CREATOR_LEN)
	{
		if (RtlCompareMemory(pFinderInfo->fd_Type,
							 "PSYS",
							 AFP_TYPE_LEN) == AFP_TYPE_LEN)
		{
			pProDosInfo->pd_FileType[0] = PRODOS_FILETYPE_PSYS;
		}
		else if (RtlCompareMemory(pFinderInfo->fd_Type,
								  "PS16",
								  AFP_TYPE_LEN) == AFP_TYPE_LEN)
		{
			pProDosInfo->pd_FileType[0] = PRODOS_FILETYPE_PS16;
		}
		else if (pFinderInfo->fd_Type[0] == 'p')
		{
			pProDosInfo->pd_FileType[0] = pFinderInfo->fd_Type[1];
			pProDosInfo->pd_AuxType[0] = pFinderInfo->fd_Type[3];
			pProDosInfo->pd_AuxType[1] = pFinderInfo->fd_Type[2];
		}
		else if ((pFinderInfo->fd_Type[2] == ' ') &&
				 (pFinderInfo->fd_Type[3] == ' ') &&
				 (isxdigit(pFinderInfo->fd_Type[0])) &&
				 (isxdigit(pFinderInfo->fd_Type[1])))
		{
			buf[0] = pFinderInfo->fd_Type[0];
			buf[1] = pFinderInfo->fd_Type[1];
			buf[2] = 0;
			Status = RtlCharToInteger(buf, 16, &filetype);
			ASSERT(NT_SUCCESS(Status));
			pProDosInfo->pd_FileType[0] = (BYTE)filetype;
		}
	}
}

/***	AfpFinderInfoFromProDosInfo
 *
 *	Given the prodos info, deduce the corresponding finder info.
 */
VOID FASTCALL
AfpFinderInfoFromProDosInfo(
	IN	PPRODOSINFO	pProDosInfo,
	OUT PFINDERINFO	pFinderInfo
)
{
	PAGED_CODE( );

	RtlCopyMemory(pFinderInfo->fd_Creator,"pdos",AFP_CREATOR_LEN);
	if ((pProDosInfo->pd_FileType[0] == PRODOS_TYPE_FILE) &&
		(pProDosInfo->pd_AuxType[0] == 0) &&
		(pProDosInfo->pd_AuxType[1] == 0))
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"TEXT",AFP_TYPE_LEN);
	}
	else if (pProDosInfo->pd_FileType[0] == PRODOS_FILETYPE_PSYS)
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"PSYS",AFP_TYPE_LEN);
	}
	else if (pProDosInfo->pd_FileType[0] == PRODOS_FILETYPE_PS16)
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"PS16",AFP_TYPE_LEN);
	}
	else if (pProDosInfo->pd_FileType[0] == 0)
	{
		RtlCopyMemory(&pFinderInfo->fd_Type,"BINA",AFP_TYPE_LEN);
	}
	else
	{
		pFinderInfo->fd_Type[0] = 'p';
		pFinderInfo->fd_Type[1] = pProDosInfo->pd_FileType[0];
		pFinderInfo->fd_Type[2] = pProDosInfo->pd_AuxType[1];
		pFinderInfo->fd_Type[3] = pProDosInfo->pd_AuxType[0];
	}
}

/***	AfpSlapOnAfpInfoStream
 *
 *	When creating a file or directory, this is called to add the AFP_AfpInfo
 *	stream.  No client impersonation is done to open/read/write this stream.
 *	If pfshAfpInfoStream is supplied, that handle is used, else a handle is
 *	opened (and pfshData MUST be supplied);
 */
NTSTATUS
AfpSlapOnAfpInfoStream(
	IN	PVOLDESC	   	pVolDesc			OPTIONAL,	// only if catching
	IN	PUNICODE_STRING	pNotifyPath			OPTIONAL,	// changes to size of
	                                                    // Afpinfo stream
	IN	PFILESYSHANDLE	pfshData			OPTIONAL,
	IN	PFILESYSHANDLE	pfshAfpInfoStream	OPTIONAL,
	IN	DWORD			AfpId,
	IN	BOOLEAN			IsDirectory,
	IN	PUNICODE_STRING	pName				OPTIONAL,	// needed for files
	OUT PAFPINFO		pAfpInfo
)
{
	NTSTATUS		Status;
	FILESYSHANDLE	fshAfpInfo;
	BOOLEAN			WriteBackROAttr = False;

	PAGED_CODE( );

	ASSERT((pfshData != NULL) || (pfshAfpInfoStream != NULL));

	if (!ARGUMENT_PRESENT(pfshAfpInfoStream))
	{
		if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, &fshAfpInfo, NULL)))
		{
			if (Status == STATUS_ACCESS_DENIED)
			{
				// We may have failed to open the AFP_Afpinfo stream because
				// the file/dir is marked ReadOnly.  Clear the ReadOnly bit
				// and try to open it again.
				Status = AfpExamineAndClearROAttr(pfshData,
												  &WriteBackROAttr,
												  pVolDesc,
												  pNotifyPath);
				if (NT_SUCCESS(Status))
				{
					if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData,
															  &fshAfpInfo,
															  NULL)))
					{
						AfpPutBackROAttr(pfshData, WriteBackROAttr);
					}
				}
			}
			if (!NT_SUCCESS(Status))
				return Status;
		}

	}
	else fshAfpInfo = *pfshAfpInfoStream;

	AfpInitAfpInfo(pAfpInfo, AfpId, IsDirectory, BEGINNING_OF_TIME);
	if (!IsDirectory)
	{
		ASSERT(pName != NULL);
		AfpSetFinderInfoByExtension(pName,
									&pAfpInfo->afpi_FinderInfo);
		AfpProDosInfoFromFinderInfo(&pAfpInfo->afpi_FinderInfo,
									&pAfpInfo->afpi_ProDosInfo);
	}

	AfpIoSetSize(&fshAfpInfo, 0);
	Status = AfpWriteAfpInfo(&fshAfpInfo, pAfpInfo);
	if (NT_SUCCESS(Status) &&
		ARGUMENT_PRESENT(pVolDesc) &&
		ARGUMENT_PRESENT(pNotifyPath))
	{
		// Do both FILE_ACTION_MODIFIED_STREAM and FILE_ACTION_MODIFIED in one go
		AfpQueueOurChange(pVolDesc,
				          FILE_ACTION_MODIFIED_STREAM,
						  pNotifyPath,
						  pNotifyPath);
	}

	if (!ARGUMENT_PRESENT(pfshAfpInfoStream))
	{
		AfpIoClose(&fshAfpInfo);
		AfpPutBackROAttr(pfshData, WriteBackROAttr);
	}

	return Status;
}


/***	AfpCreateAfpInfoStream
 *
 *	Similar to AfpSlapOnAfpInfoStream but tuned to Create file/directory case.
 */
NTSTATUS
AfpCreateAfpInfoStream(
	IN  PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pfshData,
	IN	DWORD			AfpId,
	IN	BOOLEAN			IsDirectory,
	IN	PUNICODE_STRING	pName			OPTIONAL,	// only needed for files
	IN	PUNICODE_STRING	pNotifyPath,
	OUT PAFPINFO		pAfpInfo,
	OUT	PFILESYSHANDLE	pfshAfpInfo
)
{
	NTSTATUS		Status;
	BOOLEAN			WriteBackROAttr = False;
	DWORD			crinfo;

	PAGED_CODE( );

	ASSERT((pfshData != NULL) && (pfshAfpInfo != NULL));

	do
	{
		if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData, pfshAfpInfo, &crinfo)))
		{
			if (Status == STATUS_ACCESS_DENIED)
			{
				// We may have failed to open the AFP_Afpinfo stream because
				// the file/dir is marked ReadOnly.  Clear the ReadOnly bit
				// and try to open it again.
				Status = AfpExamineAndClearROAttr(pfshData,
												  &WriteBackROAttr,
												  pVolDesc,
												  pNotifyPath);
				if (NT_SUCCESS(Status))
				{
					if (!NT_SUCCESS(Status = AfpCreateAfpInfo(pfshData,
															  pfshAfpInfo,
															  &crinfo)))
					{
						AfpPutBackROAttr(pfshData, WriteBackROAttr);
					}
				}
			}
			if (!NT_SUCCESS(Status))
				break;
		}

		AfpInitAfpInfo(pAfpInfo, AfpId, IsDirectory, BEGINNING_OF_TIME);
		if (!IsDirectory)
		{
			ASSERT(pName != NULL);
			AfpSetFinderInfoByExtension(pName,
										&pAfpInfo->afpi_FinderInfo);
			AfpProDosInfoFromFinderInfo(&pAfpInfo->afpi_FinderInfo,
										&pAfpInfo->afpi_ProDosInfo);
		}

		Status = AfpWriteAfpInfo(pfshAfpInfo, pAfpInfo);
		if (NT_SUCCESS(Status) && (crinfo == FILE_CREATED))
		{
			// Do both FILE_ACTION_MODIFIED_STREAM and FILE_ACTION_MODIFIED in one go
			AfpQueueOurChange(pVolDesc,
					          FILE_ACTION_MODIFIED_STREAM,
							  pNotifyPath,
							  pNotifyPath);
		}
		AfpPutBackROAttr(pfshData, WriteBackROAttr);
	} while (False);

	return Status;
}


/***	AfpExamineAndClearROAttr
 *
 *	If the ReadOnly attribute is set on a file or directory, clear it.
 *	pWriteBackROAttr is a boolean indicating whether or not the caller must
 *	subsequently reset the Readonly bit on the file/dir. (see AfpPutBackROAttr)
 */
NTSTATUS FASTCALL
AfpExamineAndClearROAttr(
	IN	PFILESYSHANDLE	pfshData,
	OUT	PBOOLEAN		pWriteBackROAttr,
	IN	PVOLDESC		pVolDesc		OPTIONAL,
	IN	PUNICODE_STRING	pPath			OPTIONAL
)
{
	NTSTATUS	Status;
	DWORD		NTAttr = 0;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pfshData));

	*pWriteBackROAttr = False;
	if (NT_SUCCESS(Status = AfpIoQueryTimesnAttr(pfshData, NULL, NULL, &NTAttr)) &&
		(NTAttr & FILE_ATTRIBUTE_READONLY))
	{
		// We need to clear the readonly bit.
		if (NT_SUCCESS(Status = AfpIoSetTimesnAttr(pfshData,
												   NULL,
												   NULL,
												   0,
												   FILE_ATTRIBUTE_READONLY,
												   pVolDesc,
												   pPath)))
		{
			*pWriteBackROAttr = True;
		}
	}
	return Status;
}

/***	AfpQueryProDos
 *
 *	Open the afpinfo stream relative to the file's Data handle, and
 *  read the ProDOS info out of it.  If the AfpInfo stream does not
 *  exist, return an error.
 *
 */
AFPSTATUS FASTCALL
AfpQueryProDos(
	IN	PFILESYSHANDLE	pfshData,
	OUT	PPRODOSINFO		pProDosInfo
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	FILESYSHANDLE	hAfpInfo;
	AFPINFO			afpinfo;

	Status = AfpIoOpen(pfshData,
					   AFP_STREAM_INFO,
					   FILEIO_OPEN_FILE,
					   &UNullString,
					   FILEIO_ACCESS_READ,
					   FILEIO_DENY_NONE,
					   False,
					   &hAfpInfo);
    if (NT_SUCCESS(Status))
	{
		if (NT_SUCCESS(AfpReadAfpInfo(&hAfpInfo, &afpinfo)))
		{
			*pProDosInfo = afpinfo.afpi_ProDosInfo;
		}
		else
		{
			Status = AFP_ERR_MISC;
		}

		AfpIoClose(&hAfpInfo);
	}
	else
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpUpdateIdInAfpInfo
 *
 *	Update the afpid in the afpinfo stream.
 *
 */
AFPSTATUS FASTCALL
AfpUpdateIdInAfpInfo(
	IN	PVOLDESC		pVolDesc,
	IN	PDFENTRY		pDfEntry
)
{
	FILESYSHANDLE	fshAfpInfo;
	AFPINFO			AfpInfo;
	AFPSTATUS		Status;
	UNICODE_STRING	Path;

	AfpSetEmptyUnicodeString(&Path, 0, NULL);
    Status = AfpHostPathFromDFEntry(pDfEntry, 0, &Path);
	if (NT_SUCCESS(Status))
	{
		// Open the afpinfo stream
		Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
						   AFP_STREAM_INFO,
						   FILEIO_OPEN_FILE,
						   &Path,
						   FILEIO_ACCESS_READWRITE,
						   FILEIO_DENY_NONE,
						   False,
						   &fshAfpInfo);
		if (NT_SUCCESS(Status))
		{
			Status = AfpReadAfpInfo(&fshAfpInfo, &AfpInfo);
			if (NT_SUCCESS(Status))
			{
				AfpInfo.afpi_Id = pDfEntry->dfe_AfpId;
				AfpWriteAfpInfo(&fshAfpInfo, &AfpInfo);
			}
			AfpIoClose(&fshAfpInfo);
		}
	
		if (Path.Buffer != NULL)
		{
			AfpFreeMemory(Path.Buffer);
		}
	}

	return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afpinfo.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpinfo.h

Abstract:

	This module contains the AfpInfo stream definitions.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _AFPINFO_
#define _AFPINFO_

typedef struct _AfpInfo
{
	DWORD		afpi_Signature;			// Signature
	LONG		afpi_Version;			// Version
	DWORD		afpi_Id;				// AFP File or directory Id
	DWORD		afpi_BackupTime;		// Backup time for the file/dir
										// (Volume backup time is stored
										// in the AFP_IdIndex stream)

	FINDERINFO	afpi_FinderInfo;		// Finder Info (32 bytes)
	PRODOSINFO	afpi_ProDosInfo;		// ProDos Info (6 bytes)

	USHORT		afpi_Attributes;		// Attributes mask (maps ReadOnly)

	BYTE		afpi_AccessOwner;		// Access mask (SFI vs. SFO)
	BYTE		afpi_AccessGroup;		// Directories only
	BYTE		afpi_AccessWorld;
} AFPINFO, *PAFPINFO;

//
// Initialize a AFPINFO structure with default values
//
// VOID
// AfpInitAfpInfo(
//		IN	PAFPINFO	pAfpInfo,
//		IN	DWORD		AfpId OPTIONAL, // 0 if we don't yet know the AFP Id
//		IN	BOOLEAN		IsDir
// )
//
#define AfpInitAfpInfo(_pAfpInfo, _AfpId, _IsDir, _BackupTime)	\
{																\
	RtlZeroMemory(&(_pAfpInfo)->afpi_FinderInfo,				\
				  sizeof(FINDERINFO)+sizeof(PRODOSINFO)+sizeof(USHORT));	\
	(_pAfpInfo)->afpi_Signature = AFP_SERVER_SIGNATURE;			\
	(_pAfpInfo)->afpi_Version = AFP_SERVER_VERSION;				\
	(_pAfpInfo)->afpi_BackupTime = (_BackupTime);				\
	(_pAfpInfo)->afpi_Id = (_AfpId);							\
	if (_IsDir)													\
	{															\
		(_pAfpInfo)->afpi_AccessOwner =							\
		(_pAfpInfo)->afpi_AccessGroup =							\
		(_pAfpInfo)->afpi_AccessWorld = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(_pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;\
		(_pAfpInfo)->afpi_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;\
	}															\
	else														\
	{															\
		(_pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_FILE; \
	}															\
}

//
// Open or Create the AFP_AfpInfo stream on a file or directory using a
// relative handle to the DataStream of the file/dir.
// If the stream does not yet exist, create an empty one, else open the
// existing one.
//
// NTSTATUS
// AfpCreateAfpInfo(
//		IN	PFILESYSHANDLE	phDataStream,	// handle to data stream of file/dir
//		OUT PFILESYSHANDLE	phAfpInfo,		// handle to AFP_AfpInfo stream
//		OUT	PDWORD			pInformation OPTIONAL // stream was opened/created
// );
//
#define AfpCreateAfpInfo(phDataStream, phAfpInfo,pInformation)	\
	AfpIoCreate(phDataStream,					\
				AFP_STREAM_INFO,				\
				&UNullString,					\
				FILEIO_ACCESS_READWRITE,		\
				FILEIO_DENY_NONE,				\
				FILEIO_OPEN_FILE,				\
				FILEIO_CREATE_INTERNAL,			\
				FILE_ATTRIBUTE_NORMAL,			\
				False,							\
				NULL,							\
				phAfpInfo,						\
				pInformation,					\
				NULL,							\
				NULL,							\
				NULL)

//
// Open or Create the AFP_AfpInfo stream on a file or directory using a
// relative handle to the parent directory, and the name of the file/dir.
// If the stream does not yet exist, create an empty one, else open the
// existing one.
//
// NTSTATUS
// AfpCreateAfpInfoWithNodeName(
//		IN	PFILESYSHANDLE	phRelative,				// handle to parent of file/dir
//		IN	PUNICODE_STRING pUEntityName,			// file/dir name of entity
//		IN	PVOLDESC		pVolDesc,				// Volume in question
//		OUT PFILESYSHANDLE	phAfpInfo,				// handle to AFP_AfpInfo stream
//		OUT	PDWORD			pInformation OPTIONAL	// stream was opened/created
// );
//
#define AfpCreateAfpInfoWithNodeName(phDataStream, pUEntityName, pNotifyPath, pVolDesc, phAfpInfo, pInformation) \
	AfpIoCreate(phDataStream,			\
				AFP_STREAM_INFO,		\
				pUEntityName,			\
				FILEIO_ACCESS_READWRITE,\
				FILEIO_DENY_NONE,		\
				FILEIO_OPEN_FILE,		\
				FILEIO_CREATE_INTERNAL,	\
				FILE_ATTRIBUTE_NORMAL,	\
				False,					\
				NULL,					\
				phAfpInfo,				\
				pInformation,			\
				pVolDesc,				\
				pNotifyPath,			\
				NULL)
//
// If we temporarily removed the ReadOnly attribute from a file or directory
// in order to write to the AFP_AfpInfo stream, set the attribute back on.
// (see AfpExamineAndClearROAttr)
//
// VOID
// AfpPutBackROAttr(
// 	IN	PFILESYSHANDLE 	pfshData,	// Handle to data stream of file/dir
//	IN	BOOLEAN			WriteBack	// Did we clear the RO bit to begin with?
// );
//
#define AfpPutBackROAttr(pfshData, WriteBack)	\
	if (WriteBack == True) 						\
	{											\
		AfpIoSetTimesnAttr(pfshData, NULL, NULL, FILE_ATTRIBUTE_READONLY, 0, NULL, NULL); \
	}

extern
NTSTATUS FASTCALL
AfpReadAfpInfo(
	IN	PFILESYSHANDLE	pfshAfpInfo,
	OUT PAFPINFO		pAfpInfo
);

//
//extern
//NTSTATUS
//AfpWriteAfpInfo(
//	IN	PFILESYSHANDLE			pfshAfpInfo,
//	IN	PAFPINFO				pAfpInfo
//);
//
#define AfpWriteAfpInfo(pfshAfpInfo,pAfpInfo) \
	AfpIoWrite(pfshAfpInfo, &LIZero, sizeof(AFPINFO), (PBYTE)pAfpInfo)

extern
VOID FASTCALL
AfpSetFinderInfoByExtension(
	IN	PUNICODE_STRING			pFileName,
	OUT	PFINDERINFO				pFinderInfo
);

extern
VOID FASTCALL
AfpProDosInfoFromFinderInfo(
	IN	PFINDERINFO				pFinderInfo,
	OUT PPRODOSINFO 			pProDosInfo
);

extern
VOID FASTCALL
AfpFinderInfoFromProDosInfo(
	IN	PPRODOSINFO				pProDosInfo,
	OUT PFINDERINFO				pFinderInfo
);

extern
NTSTATUS
AfpSlapOnAfpInfoStream(
	IN	struct _VolDesc *		pVolDesc OPTIONAL,
	IN	PUNICODE_STRING			pNotifyPath			OPTIONAL,
	IN	PFILESYSHANDLE			phDataStream,
	IN	PFILESYSHANDLE			pfshAfpInfoStream	OPTIONAL,
	IN	DWORD					AfpId,
	IN	BOOLEAN					IsDirectory,
	IN	PUNICODE_STRING			pName				OPTIONAL,	// only needed for files
	OUT PAFPINFO				pAfpInfo
);

extern
NTSTATUS
AfpCreateAfpInfoStream(
	IN	struct _VolDesc *		pVolDesc			OPTIONAL,
	IN	PFILESYSHANDLE			pfshData,
	IN	DWORD					AfpId,
	IN	BOOLEAN					IsDirectory,
	IN	PUNICODE_STRING			pName				OPTIONAL,	// only needed for files
	IN  PUNICODE_STRING			pNotifyPath,
	OUT PAFPINFO				pAfpInfo,
	OUT	PFILESYSHANDLE			pfshAfpInfo
);

extern
NTSTATUS FASTCALL
AfpExamineAndClearROAttr(
	IN	PFILESYSHANDLE			pfshData,
	OUT	PBOOLEAN				pWriteBackROAttr,
	IN	struct _VolDesc *		pVolDesc			OPTIONAL,
	IN	PUNICODE_STRING			pPath				OPTIONAL
);

extern
AFPSTATUS
AfpSetAfpInfo(
	IN	PFILESYSHANDLE			pfshData,			// handle to data stream of object
	IN	DWORD					Bitmap,
	IN	struct _FileDirParms *	pFDParm,
	IN	struct _VolDesc *		pVolDesc			OPTIONAL,
	IN	struct _DirFileEntry ** ppDFE				OPTIONAL
);

extern
AFPSTATUS FASTCALL
AfpQueryProDos(
	IN	PFILESYSHANDLE			pfshData,
	OUT	PPRODOSINFO				pProDosInfo
);

extern
AFPSTATUS FASTCALL
AfpUpdateIdInAfpInfo(
	IN	struct _VolDesc *		pVolDesc,
	IN	struct _DirFileEntry *	pDfEntry
);

#endif	// _AFPINFO_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afpapi.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	afpapi.c

Abstract:

	This module contains the AFP API Dispatcher.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#define	FILENUM	FILE_AFPAPI

#include <afp.h>
#include <gendisp.h>
#include <client.h>
#include <fdparm.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpStartApiProcessing)
#endif

/*
 *	The following array is indexed by the AFP opcode. The rationale behind this
 *	table is that the majority of codes are unused (> 200 out of 255). This
 *	scheme makes the actual dispatch table much smaller at the cost of an extra
 *	array look-up.
 */
LOCAL	BYTE	AfpOpCodeTable[256] =
{
/*00-02*/	_AFP_INVALID_OPCODE,	_AFP_BYTE_RANGE_LOCK,	_AFP_CLOSE_VOL,
/*03-05*/	_AFP_CLOSE_DIR,			_AFP_CLOSE_FORK,		_AFP_COPY_FILE,
/*06-08*/	_AFP_CREATE_DIR,		_AFP_CREATE_FILE,		_AFP_DELETE,
/*09-0B*/	_AFP_ENUMERATE,			_AFP_FLUSH,				_AFP_FLUSH_FORK,
/*0C-0E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_GET_FORK_PARMS,
/*0F-11*/	_AFP_GET_SRVR_INFO,		_AFP_GET_SRVR_PARMS,	_AFP_GET_VOL_PARMS,
/*12-14*/	_AFP_LOGIN,				_AFP_LOGIN_CONT,		_AFP_LOGOUT,
/*15-17*/	_AFP_MAP_ID,			_AFP_MAP_NAME,			_AFP_MOVE_AND_RENAME,
/*18-1A*/	_AFP_OPEN_VOL,			_AFP_OPEN_DIR,			_AFP_OPEN_FORK,
/*1B-1D*/	_AFP_READ,				_AFP_RENAME,			_AFP_SET_DIR_PARMS,
/*1E-20*/	_AFP_SET_FILE_PARMS,	_AFP_SET_FORK_PARMS,	_AFP_SET_VOL_PARMS,
/*21-23*/	_AFP_WRITE,				_AFP_GET_FILE_DIR_PARMS,_AFP_SET_FILE_DIR_PARMS,
/*24-26*/	_AFP_CHANGE_PASSWORD,	_AFP_GET_USER_INFO,		_AFP_GET_SRVR_MSG,
/*27-29*/	_AFP_CREATE_ID,			_AFP_DELETE_ID,			_AFP_RESOLVE_ID,
/*2A-2C*/	_AFP_EXCHANGE_FILES,	_AFP_CAT_SEARCH,		_AFP_INVALID_OPCODE,
/*2D-2F*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*30-32*/	_AFP_OPEN_DT,			_AFP_CLOSE_DT,			_AFP_INVALID_OPCODE,
/*33-35*/	_AFP_GET_ICON,			_AFP_GET_ICON_INFO,		_AFP_ADD_APPL,
/*36-38*/	_AFP_REMOVE_APPL,		_AFP_GET_APPL,			_AFP_ADD_COMMENT,
/*39-3B*/	_AFP_REMOVE_COMMENT,	_AFP_GET_COMMENT,		_AFP_INVALID_OPCODE,
/*3C-3E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*3F-41*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*42-44*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*45-47*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*48-4A*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*4B-4D*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*4E-50*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*51-53*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*54-56*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*57-59*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*5A-5C*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*5D-5F*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*60-62*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*63-65*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*66-68*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*69-6B*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*6C-6E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*6F-71*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*72-74*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*75-77*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*78-7A*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*7B-7D*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*7E-80*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*81-83*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*84-86*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*87-89*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*8A-8C*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*8D-8F*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*90-92*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*93-95*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*96-98*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*99-9B*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*9C-9E*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*9F-A1*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*A2-A4*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*A5-A7*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*A8-AA*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*AB-AD*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*AE-B0*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*B1-B3*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*B4-B6*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*B7-B9*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*BA-BC*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*BD-BF*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C0-C2*/	_AFP_ADD_ICON,			_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C3-C5*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C6-C8*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*C9-CB*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*CC-CE*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*CF-D1*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*D2-D4*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*D5-D7*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*D8-DA*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*DB-DD*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*DE-E0*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*E1-E3*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*E4-E6*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*E7-E9*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*EA-EC*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*ED-EF*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F0-F2*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F3-F5*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F6-F8*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*F9-FB*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*FC-FE*/	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,	_AFP_INVALID_OPCODE,
/*FF*/		_AFP_GET_DOMAIN_LIST
};



#if DBG
PCHAR	afpApiNames[] =
	{	"AfpInvalidOpcode",
		"AfpUnsupportedOpcode",
		"AfpGetSrvrInfo",
		"AfpGetSrvrParms",
		"AfpChangePassword",
		"AfpLogin",
		"AfpLoginCont",
		"AfpLogout",
		"AfpMapId",
		"AfpMapName",
		"AfpGetUserInfo",
		"AfpGetSrvrMsg",
		"AfpGetDomainList",
		"AfpOpenVol",
		"AfpCloseVol",
		"AfpGetVolParms",
		"AfpSetVolParms",
		"AfpFlush",
		"AfpGetFileDirParms",
		"AfpSetFileDirParms",
		"AfpDelete",
		"AfpRename",
		"AfpMoveAndRename",
		"AfpOpenDir",
		"AfpCloseDir",
		"AfpCreateDir",
		"AfpEnumerate",
		"AfpSetDirParms",
		"AfpCreateFile",
		"AfpCopyFile",
		"AfpCreateId",
		"AfpDeleteId",
		"AfpResolveId",
		"AfpSetFileParms",
		"AfpExchangeFiles",
		"AfpOpenFork",
		"AfpCloseFork",
		"AfpFlushFork",
		"AfpRead",
		"AfpWrite",
		"AfpByteRangeLock",
		"AfpGetForkParms",
		"AfpSetForkParms",
		"AfpOpenDt",
		"AfpCloseDt",
		"AfpAddAppl",
		"AfpGetAppl",
		"AfpRemoveAppl",
		"AfpAddComment",
		"AfpGetComment",
		"AfpRemoveComment",
		"AfpAddIcon",
		"AfpGetIcon",
		"AfpGetIconInfo",
		"AfpCatSearch"
	};
#endif

/*
 *	The following structure is the API Dispatch table. The structure is indexed
 *	by the _AFP code. Each entry consists of the routine address that handles
 *	the request and/or dispatches to FSP, the fixed size of the request
 *	packet and optionally three variable size packets. The fixed size request
 *	packet is further split up into SEVEN fields. Each field is of the type
 *	FLD_BYTE, FLD_WORD or FLD_DWRD. A field of the type FLD_WORD and FLD_DWRD
 *	is converted from on-the-wire format to the internal format. An FLD_NONE
 *	entry stops the scan for the fixed part of the request.
 *	NamexType where x is 1,2,3 defines what type of variable size packets
 *	follow. A NONE on any of the fields stops the parsing. A type of BLOCK
 *	consumes the balance of the packet. Each of the variable size packets are
 *	copied to the sda_Namex field which is defined as ANSI_STRING. For the
 *	TYP_BLOCK field, the Length field of the ANSI_STRING defines the length
 *	of the block. The motivation for this structure is to conserve memory.
 *	Since a request packet is 578 bytes long and most APIs use only a small
 *	subset of that, the fixed portion of the packet is copied to the SDA
 *	and a smaller buffer is allocated for the variable packet.
 *	The orignal buffer cannot be accessed once we return back from this call.
 */

// DO NOT CHANGE THE MANIFESTS BELOW BEFORE YOU CHECK THE CODE IN
//	AfpUnmarshallReq

// Descriptor values for fixed data
#define	FLD_NONE		0x00			// Terminate
#define	FLD_BYTE		sizeof(BYTE)	// Byte field
#define	FLD_WORD		sizeof(USHORT)	// WORD field
#define	FLD_DWRD		sizeof(DWORD)	// DWORD field
#define	FLD_SIGNED		0x08			// The value is to be treated as a signed
#define	FLD_NON_ZERO	0x10			// The value cannot be zero
#define	FLD_CHECK_MASK	0x20			// Check against the mask in ReqPktMask
#define	FLD_NOCONV		0x40			// Skip conversion from on-the-wire to host
#define	FLD_NOPAD		0x80			// Do not EVEN align the next field
#define	FLD_PROP_MASK	(FLD_SIGNED		|	\
						 FLD_NON_ZERO	|	\
						 FLD_CHECK_MASK |	\
						 FLD_NOCONV		|	\
						 FLD_NOPAD)

// Descriptor values for variable data
#define	TYP_NONE		0x00		// Terminate
#define	TYP_PATH		0x01		// AFPPATH -> ANSI_STRING
#define	TYP_STRING		0x02		// PASCALSTR -> ANSI_STRING
#define	TYP_BLK16		0x03		// Block of 16 bytes
#define	TYP_BLOCK		0x04		// Block of bytes
#define	TYP_NON_NULL	0x20		// The variable data cannot be null
#define	TYP_OPTIONAL	0x40		// This field can be optinal
#define	TYP_NOPAD		0x80		// Do not even align the next field
#define	TYP_PROP_MASK	(TYP_NON_NULL | TYP_OPTIONAL | TYP_NOPAD)

#define	API_AFP21ONLY				0x01	// Valid only for AFP 2.1 clients
#define	API_SKIPLOGONVALIDATION		0x02	// Don't check if user is logged on
#define	API_NOSUBFUNCTION			0x04	// For the AfpLogin Function
#define	API_CHECK_VOLID				0x08	// This API reference volume
#define	API_CHECK_OFORKREFNUM		0x10	// This API reference open fork
#define	API_TYPE_WRITE				0x20	// This attempts a write
#define	API_QUEUE_IF_DPC			0x40	// This conditionally queues to worker only if at DPC
#define	API_MUST_BE_QUEUED			0x80	// The Api must be queued to the worker thread

#define	MAX_MASK_ENTRIES			4		// Max. bitmasks to validate

LOCAL	struct _DispatchTable
{
	AFPAPIWORKER	AfpWorkerRoutine;				// Worker routine to call/queue
	BYTE			AfpStatus;						// Status to return on error
													// This has to be added to the base
	BYTE			ApiOptions;						// API_xxx values
	BYTE			ReqPktDesc[MAX_REQ_ENTRIES];	// Fixed data desc
	BYTE			NameXType[MAX_VAR_ENTRIES];		// Variable data desc
	USHORT			ReqPktMask[MAX_MASK_ENTRIES];	// Valid values for bit-maps
} AfpDispatchTable[_AFP_MAX_ENTRIES] =
{

/* 0x00 */
	{
		AfpFsdDispInvalidFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

/* 0x01 */
	{
		AfpFsdDispUnsupportedFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* SERVER APIs */

/* 0x02 */
	{
		AfpFsdDispInvalidFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x03 */
	{
		AfpFsdDispGetSrvrParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_NOSUBFUNCTION,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x04 */
	{
		AfpFspDispChangePassword,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING+TYP_NON_NULL,			// UAM Name
		TYP_STRING+TYP_NON_NULL,			// User Name
		TYP_BLOCK+TYP_NON_NULL				// UAM dependent info
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x05 */
	{
		AfpFspDispLogin,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_NOSUBFUNCTION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING+TYP_NOPAD+TYP_NON_NULL,		// AFP Version
		TYP_STRING+TYP_NOPAD+TYP_NON_NULL,		// UAM String
		TYP_BLOCK+TYP_NOPAD						// UAM dependent data
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x06 */
	{
		AfpFspDispLoginCont,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_MUST_BE_QUEUED,
	  {
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					// Response to Challenge
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					//
		FLD_DWRD+FLD_NOCONV,					//
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x07 */
	{
		AfpFspDispLogout,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_NOSUBFUNCTION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x08 */
	{
		AfpFspDispMapId,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_MUST_BE_QUEUED,
	  {
		FLD_DWRD,								// User or Group Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x09 */
	{
		AfpFspDispMapName,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING,								// User or Group Name
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0A */
	{
		AfpFspDispGetUserInfo,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_MUST_BE_QUEUED,
	  {
		FLD_DWRD,								// User Id
		FLD_WORD,								// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0B */
	{
		AfpFsdDispGetSrvrMsg,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_AFP21ONLY,
	  {
		FLD_WORD,								// Message Type
		FLD_WORD,								// Mesage Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0C */
	{
		AfpFsdDispInvalidFunc,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_SKIPLOGONVALIDATION+API_MUST_BE_QUEUED,
	  {
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* VOLUMEAPIs */

/* 0x0D */
	{
		AfpFsdDispOpenVol,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		0,
	  {
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_STRING+TYP_NON_NULL,				// Volume name
		TYP_BLOCK+TYP_OPTIONAL,					// Volume password
		TYP_NONE
	  },
	  {
		VOL_BITMAP_MASK,
		0,
		0,
		0
	  }
	},
/* 0x0E */
	{
		AfpFsdDispCloseVol,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x0F */
	{
		AfpFsdDispGetVolParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		VOL_BITMAP_MASK,
		0,
		0
	  }
	},
/* 0x10 */
	{
		AfpFsdDispSetVolParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_DWRD,								// Backup date
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		VOL_BITMAP_BACKUPTIME,
		0,
		0
	  }
	},
/* 0x11 */
	{
		AfpFsdDispFlush,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

	/* FILE-DIRECTORY APIs */

/* 0x12 */
	{
		AfpFspDispGetFileDirParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_CHECK_MASK,				// File Bitmap
		FLD_WORD+FLD_CHECK_MASK,				// Directory Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		DIR_BITMAP_MASK
	  }
	},
/* 0x13 */
	{
		AfpFspDispSetFileDirParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// File or Directory Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_BLOCK+TYP_NON_NULL,					// Parameters (packed)
		TYP_NONE
	  },
	  {
		0,
		0,
		FD_VALID_SET_PARMS,
		0
	  }
	},
/* 0x14 */
	{
		AfpFspDispDelete,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x15 */
	{
		AfpFspDispRename,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD,						// Path
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,		// New Name
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x16 */
	{
		AfpFspDispMoveAndRename,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Src Directory Id
		FLD_DWRD+FLD_NON_ZERO,					// Dst Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD,						// Source path
		TYP_PATH+TYP_NOPAD,						// Destination path
		TYP_PATH+TYP_NOPAD						// New Name (optional)
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* DIRECTORY APIs */

/* 0x17 */
	{
		AfpFspDispOpenDir,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Directory Name
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x18 */
	{
		AfpFspDispCloseDir,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x19 */
	{
		AfpFspDispCreateDir,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Directory Name
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1A */
	{
		AfpFspDispEnumerate,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_CHECK_MASK,				// File Bitmap
		FLD_WORD+FLD_CHECK_MASK,				// Directory Bitmap
		FLD_WORD+FLD_SIGNED+FLD_NON_ZERO,		// ReqCount
		FLD_WORD+FLD_SIGNED+FLD_NON_ZERO,		// Start Index
		FLD_WORD+FLD_SIGNED+FLD_NON_ZERO,		// ReplySize
	  },
	  {
		TYP_PATH,								// Path to directory
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		DIR_BITMAP_MASK
	  }
	},
/* 0x1B */
	{
		AfpFspDispSetDirParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Dir Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,								// Path
		TYP_BLOCK+TYP_NON_NULL,					// Parameters (packed)
		TYP_NONE
	  },
	  {
		0,
		0,
		DIR_VALID_SET_PARMS,
		0
	  }
	},

	/* FILE APIs */

/* 0x1C */
		{
		AfpFspDispCreateFile,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1D */
	{
		AfpFspDispCopyFile,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Src Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Src Directory Id
		FLD_WORD+FLD_NON_ZERO,					// Dst Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Dst Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,		// Src Path
		TYP_PATH+TYP_NOPAD,
		TYP_PATH+TYP_NOPAD
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1E */
	{
		AfpFspDispCreateId,
		(AFP_ERR_BASE - AFP_ERR_OBJECT_TYPE),
		API_AFP21ONLY+API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x1F */
	{
		AfpFspDispDeleteId,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_AFP21ONLY+API_CHECK_VOLID+API_MUST_BE_QUEUED+API_TYPE_WRITE,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// File Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x20 */
	{
		AfpFspDispResolveId,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_AFP21ONLY+API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD,								// File Id
		FLD_WORD+FLD_CHECK_MASK,				// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		0
	  }
	},
/* 0x21 */
	{
		AfpFspDispSetFileParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// File Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_BLOCK+TYP_NON_NULL,					// Parameters (packed)
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_VALID_SET_PARMS,
		0
	  }
	},
/* 0x22 */
	{
		AfpFspDispExchangeFiles,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED+API_AFP21ONLY,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Srce. Directory Id
		FLD_DWRD+FLD_NON_ZERO,					// Dest. Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,					// Srce. Path
		TYP_PATH+TYP_NOPAD+TYP_NON_NULL,					// Dest. Path
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

		/* FORK	APIs */

/* 0x23 */
	{
		AfpFspDispOpenFork,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_WORD+FLD_CHECK_MASK,				// Bitmap
		FLD_WORD,								// Access & Deny Modes
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		FILE_BITMAP_MASK,
		0
	  }
	},
/* 0x24 */
	{
		AfpFspDispCloseFork,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x25 */
	{
		AfpFspDispFlushFork,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x26 */
	{
		AfpFspDispRead,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_QUEUE_IF_DPC+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_DWRD,								// Offset
		FLD_DWRD,								// ReqCount
		FLD_BYTE+FLD_NOPAD,						// Newline Mask
		FLD_BYTE+FLD_NOPAD,						// Newline Char
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x27 */
	{
		AfpFspDispWrite,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_TYPE_WRITE+API_QUEUE_IF_DPC+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_DWRD,								// Offset
		FLD_DWRD,								// Length
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x28 */
	{
		AfpFspDispByteRangeLock,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_QUEUE_IF_DPC+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_DWRD,								// Offset
		FLD_DWRD,								// Length
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x29 */
	{
		AfpFspDispGetForkParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		FILE_BITMAP_MASK,
		0,
		0
	  }
	},
/* 0x2A */
	{
		AfpFspDispSetForkParms,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_OFORKREFNUM+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Fork_Id
		FLD_WORD+FLD_NON_ZERO+FLD_CHECK_MASK,	// Bitmap
		FLD_DWRD,								// Fork Length
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		FILE_BITMAP_DATALEN+FILE_BITMAP_RESCLEN,
		0,
		0
	  }
	},

	/* DESKTOP APIs */

/* 0x2B */
	{
		AfpFsdDispOpenDT,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x2C */
	{
		AfpFsdDispCloseDT,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x2D */
	{
		AfpFspDispAddAppl,
		(AFP_ERR_BASE - AFP_ERR_OBJECT_TYPE),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_DWRD,								// Appl Tag
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x2E */
	{
		AfpFspDispGetAppl,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_WORD,								// Appl Index
		FLD_WORD+FLD_CHECK_MASK,				// Bitmap
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		FILE_BITMAP_MASK
	  }
	},
/* 0x2F */
	{
		AfpFspDispRemoveAppl,
		(AFP_ERR_BASE - AFP_ERR_ITEM_NOT_FOUND),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH+TYP_NON_NULL,					// Path
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x30 */
	{
		AfpFspDispAddComment,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,
		TYP_STRING,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x31 */
	{
		AfpFspDispGetComment,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x32 */
	{
		AfpFspDispRemoveComment,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_TYPE_WRITE+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NON_ZERO,					// Directory Id
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_PATH,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x33 */
	{
		AfpFspDispAddIcon,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_DWRD+FLD_NOCONV,					// Type
		FLD_BYTE,								// IconType
		FLD_DWRD,								// IconTag
		FLD_WORD+FLD_SIGNED,					// Icon Size
		FLD_NONE,
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x34 */
	{
		AfpFspDispGetIcon,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_DWRD+FLD_NOCONV,					// Type
		FLD_BYTE,								// IconType
		FLD_WORD+FLD_SIGNED,					// Length
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},
/* 0x35 */
	{
		AfpFspDispGetIconInfo,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED,
	  {
		FLD_WORD+FLD_NON_ZERO,					// DTRefNum (same as VolId)
		FLD_DWRD+FLD_NOCONV,					// Creator
		FLD_WORD,								// IconIndex
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_NONE,
		TYP_NONE,
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	},

/* 0x36 */
	{
		AfpFspDispCatSearch,
		(AFP_ERR_BASE - AFP_ERR_PARAM),
		API_CHECK_VOLID+API_MUST_BE_QUEUED+API_AFP21ONLY,
	  {
		FLD_WORD+FLD_NON_ZERO,					// Volume_Id
		FLD_DWRD+FLD_NON_ZERO,					// Requested # of matches
		FLD_DWRD,								// Reserved
		FLD_NONE,
		FLD_NONE,
		FLD_NONE,
		FLD_NONE
	  },
	  {
		TYP_BLK16+TYP_NON_NULL,					// Catalog position
		TYP_BLOCK+TYP_NON_NULL,					// The rest of the stuff
		TYP_NONE
	  },
	  {
		0,
		0,
		0,
		0
	  }
	}
};


/***	AfpFsdDispInvalidFunc
 *
 *	This handles invalid AFP functions.
 */
AFPSTATUS FASTCALL
AfpFsdDispInvalidFunc(
	IN	PSDA	pSda
)
{
	return AFP_ERR_PARAM;
}


/***	AfpFsdDispUnsupportedFunc
 *
 *	This handles un-supported AFP functions.
 */
AFPSTATUS FASTCALL
AfpFsdDispUnsupportedFunc(
	IN	PSDA	pSda
)
{
	return AFP_ERR_CALL_NOT_SUPPORTED;
}


/***	AfpUnmarshallReq
 *
 *	The request completion routine has determined the session that this
 *	request initiated from. Determine if this session is currently being
 *	serviced. If not, the request packet is then broken down as follows.
 *
 *	Afp function code	->  pSda->sda_AfpFunc
 *	Afp SubFunc code	->  pSda->sda_AfpSubFunc
 *	Fixed part of the
 *	Api request parms	->  pSda->sda_ReqBlock each field is converted to a
 *							dword from the on-the-wire format to the host
 *							format. Dictated by the table above.
 *	Variable part		->  pSda->sda_Name1-3 as appropriate. Dictated by the
 *							table above. AFPPATH, BLOCK and PASCALSTR are
 *							all converted to ANSI_STRING.
 *
 *	Buffers for sda_Namex is allocated out of NonPagedPool, if it cannot
 *	fit into sda_NameXSpace.
 *
 *	A whole lot of book keeping is also done here. API statistics are maintained
 *	here and when the reply is posted.
 *
 *	If there is no error, then the following possible error codes result:
 *		AFP_ERR_NONE		The dispatch level worker can be called
 *		AFP_ERR_QUEUE		The request must be queued
 *		AFP_ERR_DEFER		The request must be deferred
 *		AFP_ERR_xxxxx		Appropriate error code
 *
 *	NOTE: This is called within ReceiveCompletion and hence at DISPATCH_LEVEL.
 */
VOID FASTCALL
AfpUnmarshallReq(
	IN	PSDA		pSda
)
{
	LONG			StrSize, Offset, i;
	LONG			NameOff = 0, SpaceLeft;
	PREQUEST		pRequest;
	LONG			RequestSize;
	PBYTE			pRequestBuf;
	USHORT			WriteSize = 0;
	PBYTE			pWriteBuf = NULL;
	AFPSTATUS		Status;
	BYTE			ApiCode;
    LONG            BytesToCopy;
	struct _DispatchTable *pDispTab;
	struct _RequestPacket
	{
		BYTE	_Function;
		BYTE	_SubFunc;
		BYTE	_OtherParms;
	} *pRqPkt;
#ifdef	PROFILING
	static TIME		TimeLastRequest = { 0, 0 };
	TIME			TimeS, TimeD, TimeE;

	AfpGetPerfCounter(&TimeS);
#endif

	ASSERT (VALID_SDA(pSda));
	ASSERT (pSda->sda_Flags & SDA_REQUEST_IN_PROCESS);
	ASSERT (pSda->sda_Request != NULL);

	pRequest = pSda->sda_Request;
	RequestSize = pRequest->rq_RequestSize;
	pRequestBuf = pRequest->rq_RequestBuf;
	ASSERT (pRequestBuf != NULL);

	pRqPkt = (struct _RequestPacket *)pRequestBuf;

	if (pRequest->rq_WriteMdl != NULL)
	{
        // if Mdl (and the buffer) was allocated by us, find the buffer
        if (pRequest->rq_CacheMgrContext == NULL)
        {
		    pWriteBuf = MmGetSystemAddressForMdlSafe(
					            pRequest->rq_WriteMdl,
					            NormalPagePriority);

            if (pWriteBuf == NULL)
            {
			    Status = AFP_ERR_MISC;
                ASSERT(0);
                goto AfpUnmarshallReq_ErrExit;
            }
        }

		WriteSize = (USHORT)AfpMdlChainSize(pRequest->rq_WriteMdl);
	}
    else
    {
        ASSERT(pRequest->rq_CacheMgrContext == NULL);
    }

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

#ifdef	PROFILING
	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);

	if (TimeLastRequest.QuadPart != 0)
	{
		TimeD.QuadPart = TimeS.QuadPart - TimeLastRequest.QuadPart;
		AfpServerProfile->perf_InterReqTime.QuadPart += TimeD.QuadPart;
		AfpServerProfile->perf_ReqCount ++;
	}

	TimeLastRequest.QuadPart = TimeS.QuadPart;

	RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif

	do
	{
		Offset = FIELD_OFFSET(struct _RequestPacket, _OtherParms);

#ifdef	PROFILING
		AfpGetPerfCounter(&pSda->sda_ApiStartTime);
#endif
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataIn,
								   RequestSize + WriteSize,
								   &AfpStatisticsLock);

		ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

		// Send a dummy reply if we are shutting down the server or the session
		// Also the request better be atleast the minimum size
		if ((pSda->sda_Flags & SDA_CLOSING)				||
			(AfpServerState & AFP_STATE_STOP_PENDING)	||
			(RequestSize < sizeof(pRqPkt->_Function)))
		{
			// Set a function code so that we know what statictics to update at
			// reply time
			pSda->sda_AfpFunc = _AFP_INVALID_OPCODE;
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			Status = AFP_ERR_PARAM;
			break;
		}

		ApiCode = AfpOpCodeTable[pRqPkt->_Function];

		// Translate the function code to what we understand
		pDispTab = &AfpDispatchTable[ApiCode];

		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpUnmarshallRequest: <%s>\n", afpApiNames[ApiCode]));

		if (!(pSda->sda_Flags & SDA_USER_LOGGEDIN))
		{
			if (!(pDispTab->ApiOptions & API_SKIPLOGONVALIDATION))
			{
				Status = AFP_ERR_USER_NOT_AUTH;
				if (pSda->sda_Flags & SDA_LOGIN_FAILED)
					Status = AFP_ERR_PWD_NEEDS_CHANGE;
				RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
				break;
			}
		}

		ASSERT (pDispTab->AfpWorkerRoutine != NULL);

		// Initialize the worker routine
		pSda->sda_WorkerRoutine = pDispTab->AfpWorkerRoutine;

		// Check if this is an AFP 2.1 request and if we are in a position to honor it.
		if ((pDispTab->ApiOptions & API_AFP21ONLY) &&
			(pSda->sda_ClientVersion < AFP_VER_21))
		{
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
			Status = AFP_ERR_CALL_NOT_SUPPORTED;
			break;
		}

		Status = AFP_ERR_NONE;
		pSda->sda_AfpFunc = ApiCode;
        if (RequestSize >= FIELD_OFFSET(struct _RequestPacket, _SubFunc))
        {
		    pSda->sda_AfpSubFunc = pRqPkt->_SubFunc;
        }
		pSda->sda_PathType = 0;			// Invalid till we actually encounter one
		pSda->sda_IOBuf = pWriteBuf;
		pSda->sda_IOSize = WriteSize;

		if (pDispTab->ApiOptions & API_QUEUE_IF_DPC)
		{
			pSda->sda_Flags |= SDA_QUEUE_IF_DPC;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		// Get all the fields from the request buffer to the sda_ReqBlock structure.
        if (RequestSize >= FIELD_OFFSET(struct _RequestPacket, _OtherParms))
        {
		    pRequestBuf = &pRqPkt->_OtherParms;
        }

		// Do this for APIs which do not provide a sub-function or a pad.
		// Currently the only culprit is FPLogin
		if (pDispTab->ApiOptions & API_NOSUBFUNCTION)
		{
			pSda->sda_AfpSubFunc = 0;
			pRequestBuf --;
			Offset --;
		}

		// Account for the function and subfunction (if any) from the request packet
		RequestSize -= Offset;

        //
        // for the Apple native UAM's (Randnum Exchange, and 2-Way Randnum exchange),
        // we special case and 'unmarshal' the parms directly (the Afp function code
        // being the same for AfpLoginCont regardless of the UAM used, it would be a
        // major hack if we had to 'unmarshal' the parms the regular way)
        //
        if ((ApiCode == _AFP_LOGIN_CONT) &&
            ((pSda->sda_ClientType == SDA_CLIENT_RANDNUM) ||
             (pSda->sda_ClientType == SDA_CLIENT_TWOWAY)))
        {

            // 8 bytes of Response, 2 bytes of LogonId
            if (pSda->sda_ClientType == SDA_CLIENT_RANDNUM)
            {
                BytesToCopy = (RANDNUM_RESP_LEN+sizeof(USHORT));
            }
            // 8 bytes of Response, 8 bytes of Mac's challeng, 2 bytes of LogonId
            else
            {
                BytesToCopy = (TWOWAY_RESP_LEN+sizeof(USHORT));
            }

            if (RequestSize < BytesToCopy)
            {
                ASSERT(0);
                Status = AFP_ERR_PARAM;
                break;
            }

            RtlCopyMemory((PBYTE)&pSda->sda_ReqBlock[0],
                          pRequestBuf,
                          BytesToCopy);

            //
            // skip everything else, now that we got what we wanted
            //
            Status = AFP_ERR_QUEUE;
            break;
        }

		for (i = 0;
			 (i < MAX_REQ_ENTRIES) && (pDispTab->ReqPktDesc[i] != FLD_NONE);
			 i++)
		{
			// Check alignment
			if (((pDispTab->ReqPktDesc[i] & FLD_NOPAD) == 0) &&
				((Offset % 2) != 0))
			{
				Offset ++;
				RequestSize --;
				pRequestBuf ++;
			}

			if (RequestSize < (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			switch (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK)
			{
				case FLD_BYTE:
					ASSERT ((pDispTab->ReqPktDesc[i] & FLD_NOCONV) == 0);
					GETBYTE2DWORD(&pSda->sda_ReqBlock[i], pRequestBuf);
					break;
				case FLD_WORD:
					ASSERT ((pDispTab->ReqPktDesc[i] & FLD_NOCONV) == 0);
					GETSHORT2DWORD(&pSda->sda_ReqBlock[i], pRequestBuf);
					if (pDispTab->ReqPktDesc[i] & FLD_SIGNED)
						pSda->sda_ReqBlock[i] = (LONG)((SHORT)pSda->sda_ReqBlock[i]);
					break;
				case FLD_DWRD:
					if (pDispTab->ReqPktDesc[i] & FLD_NOCONV)
					{
						 GETDWORD2DWORD_NOCONV(&pSda->sda_ReqBlock[i], pRequestBuf);
					}
					else
					{
						GETDWORD2DWORD(&pSda->sda_ReqBlock[i], pRequestBuf);
					}
					break;
				default:
					// How did we get here ?
					KeBugCheck(0);
					break;
			}

			if ((pDispTab->ReqPktDesc[i] & FLD_NON_ZERO) &&
				(pSda->sda_ReqBlock[i] == 0))
			{
				if (pDispTab->ReqPktDesc[i] & FLD_CHECK_MASK)
				{
					ASSERT ( i < MAX_MASK_ENTRIES);
					Status = AFP_ERR_BITMAP;
				}
				else
				{
					Status = AFP_ERR_PARAM;
				}
				break;
			}

			if ((pDispTab->ReqPktDesc[i] & FLD_CHECK_MASK) &&
				(((USHORT)(pSda->sda_ReqBlock[i]) & ~pDispTab->ReqPktMask[i]) != 0))
			{
				ASSERT (i < MAX_MASK_ENTRIES);
				Status = AFP_ERR_BITMAP;
				break;
			}

			pRequestBuf += (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK);
			Offset += (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK);
			RequestSize -= (pDispTab->ReqPktDesc[i] & ~FLD_PROP_MASK);
		}

		if (Status != AFP_ERR_NONE)
		{
			break;
		}

		// Before we go any further, check for volume/fork references and such
		//
		// NOTE: The VolId and OForkRefNum are always the first parameter and
		//		 hence referenced as such via the request packet structure
		if (pDispTab->ApiOptions & API_CHECK_VOLID)
		{
			PCONNDESC	pConnDesc;
			struct _RequestPacket
			{
				DWORD	_VolId;
			};
			struct _ModifiedPacket
			{
				ULONG_PTR	_VolId;
			};

			if ((pReqPkt->_VolId == 0) ||
				((pConnDesc = AfpConnectionReferenceAtDpc(pSda, (ULONG)(pReqPkt->_VolId))) == NULL))
			{
				Status = AFP_ERR_PARAM;
				break;
			}
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);
			pSda->sda_Flags |= SDA_DEREF_VOLUME;
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

            //if (sizeof(DWORD) != sizeof(ULONG_PTR))
#ifdef _WIN64
			// Create 64-bit space to hold VolDesc pointer
			// Push array 1 DWORD down
            {
     		    for (i = MAX_REQ_ENTRIES;
			        i > 0;
			        i--)
                {
                    pSda->sda_ReqBlock[i+1] = pSda->sda_ReqBlock[i];
                }
            }
#endif

   			pModPkt->_VolId = (ULONG_PTR)pConnDesc;

			if ((pDispTab->ApiOptions & API_TYPE_WRITE) &&
				 (pConnDesc->cds_pVolDesc->vds_Flags & AFP_VOLUME_READONLY))
			{
				DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
						("AfpUnmarshallReq: Write operation on a RO volume\n"));
				Status = AFP_ERR_VOLUME_LOCKED;
				break;
			}
			if (pConnDesc->cds_pVolDesc->vds_Flags & VOLUME_CDFS_INVALID)
			{
				ASSERT(!IS_VOLUME_NTFS(pConnDesc->cds_pVolDesc));
				DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_WARN,
						("AfpUnmarshallReq: Access to a defunct CD-Volume\n"));
				Status = AFP_ERR_MISC;
				break;

			}

		}
		else if (pDispTab->ApiOptions & API_CHECK_OFORKREFNUM)
		{
			POPENFORKENTRY	pOpenForkEntry;
			struct _RequestPacket
			{
				DWORD   _OForkRefNum;
			};
			struct _ModifiedPacket
			{
				ULONG_PTR	_OForkRefNum;
			};

			if ((pReqPkt->_OForkRefNum == 0) ||
				((pOpenForkEntry = AfpForkReferenceByRefNum(pSda, (ULONG)(pReqPkt->_OForkRefNum))) == NULL))
			{
				Status = AFP_ERR_PARAM;
				break;
			}

			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);
			pSda->sda_Flags |= SDA_DEREF_OFORK;
			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

            //if (sizeof(DWORD) != sizeof(ULONG_PTR))
#ifdef _WIN64
			// Create 64-bit space to hold VolDesc pointer
			// Push array 1 DWORD down
            {
    		    for (i = MAX_REQ_ENTRIES;
			        i > 0;
			        i--)
                {
                    pSda->sda_ReqBlock[i+1] = pSda->sda_ReqBlock[i];
                }
            }
#endif

			pModPkt->_OForkRefNum = (ULONG_PTR)pOpenForkEntry;

			if ((pDispTab->ApiOptions & API_TYPE_WRITE) &&
				!(pOpenForkEntry->ofe_OpenMode & FORK_OPEN_WRITE))
			{
				DBGPRINT(DBG_COMP_AFPAPI_FORK, DBG_LEVEL_WARN,
						("AfpUnmarshallReq: AfpWrite on a Fork not opened for write\n"));
				Status = AFP_ERR_ACCESS_DENIED;
				break;
			}

		}

		// Now get the sda_NameX fields. Allocate one chunk of memory for
		// copying all the variable size data. Use sda_NameXSpace if it fits there
		if ((pDispTab->NameXType[0] != TYP_NONE) &&
			(RequestSize > 0))
		{
			SpaceLeft = RequestSize;
			ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

			pSda->sda_NameBuf = NULL;
			if ((RequestSize <= pSda->sda_SizeNameXSpace) &&
				((pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE) == 0))
			{
				pSda->sda_NameBuf = pSda->sda_NameXSpace;
				pSda->sda_Flags |= SDA_NAMEXSPACE_IN_USE;
			}

			RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

			if ((pSda->sda_NameBuf == NULL) &&
				(pSda->sda_NameBuf = AfpAllocNonPagedMemory(RequestSize)) == NULL)
			{
				Status = AFP_ERR_MISC;
				break;
			}
		}

		for (i = 0;
			 (i < MAX_VAR_ENTRIES) && (pDispTab->NameXType[i] != TYP_NONE) && (RequestSize > 0);
			 i++)
		{
			if (((pDispTab->NameXType[i] & TYP_NOPAD) == 0) &&
				(RequestSize > 0) && ((Offset % 2) != 0))
			{
				Offset ++;
				RequestSize --;
				pRequestBuf ++;
			}

			switch (pDispTab->NameXType[i] & ~TYP_PROP_MASK)
			{
				case TYP_PATH:
					// TYP_PATH is almost like TYP_STRING except that there is a
					// leading PathType which should be valid. Just validate that
					// and fall through to the TYP_STRING case. Validate the size
					// to hold atleast the pathtype and the string length

					ASSERT (!(pDispTab->NameXType[i] & TYP_OPTIONAL));

					if ((RequestSize < 2*sizeof(BYTE)) ||
						 !VALIDPATHTYPE(*pRequestBuf)||
						 (VALIDPATHTYPE(pSda->sda_PathType) &&
						  (pSda->sda_PathType != *pRequestBuf)))
					{
						Status = AFP_ERR_PARAM;
						break;
					}
					// Save the PathType and account for it
					pSda->sda_PathType = *pRequestBuf++;
					Offset ++;
					RequestSize --;
				case TYP_STRING:
					// A TYP_STRING has a leading size byte and a string of that
					// size. A null string is then atleast one byte long.

					// Allow an optional string to be absent
					if ((pDispTab->NameXType[i] & TYP_OPTIONAL) &&
						(RequestSize == 0))
						continue;

					if ((RequestSize < sizeof(BYTE)) ||
						 ((StrSize = (LONG)pRequestBuf[0]) >
											(RequestSize - (LONG)sizeof(BYTE))))
					{
						Status = AFP_ERR_PARAM;
						break;
					}
					// Consume the string length
					pRequestBuf++;
					Offset ++;
					RequestSize --;
					break;
                case TYP_BLK16:
                    if (RequestSize < 16)
                    {
						Status = AFP_ERR_PARAM;
                        ASSERT(0);
						break;
                    }
					StrSize = 16;
					break;
				case TYP_BLOCK:
					StrSize = RequestSize;
					break;
				default:
					// How did we get here ?
					KeBugCheck(0);
					break;
			}

			if (Status != AFP_ERR_NONE)
			{
				break;
			}

			if (StrSize > 0)
			{
				ASSERT (StrSize <= SpaceLeft);
				pSda->sda_Name[i].Buffer = (pSda->sda_NameBuf + NameOff);
				SpaceLeft -= StrSize;
				NameOff += StrSize;

				pSda->sda_Name[i].Length =
				pSda->sda_Name[i].MaximumLength = (USHORT)StrSize;

				RtlCopyMemory(pSda->sda_Name[i].Buffer, pRequestBuf, StrSize);
				pRequestBuf += StrSize;
				Offset += StrSize;
				RequestSize -= StrSize;
			}

			if ((pDispTab->NameXType[i] & TYP_NON_NULL) &&
				(pSda->sda_Name[i].Length == 0))
				Status = (AFP_ERR_BASE - pDispTab->AfpStatus);
		}

		// Change the status if we have no worker at dispatch level
		if ((Status == AFP_ERR_NONE) && (pDispTab->ApiOptions & API_MUST_BE_QUEUED))
		{
			Status = AFP_ERR_QUEUE;
		}

		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpUnmarshallReq: <%s> returning Status %ld\n",
											afpApiNames[ApiCode], Status));
	} while (False);


AfpUnmarshallReq_ErrExit:

    //
	// Kill the write buffer Mdl since we do not need it anymore.  Of course,
    // if the Mdl belongs to cache mgr, don't touch it!
    //
	if ((pRequest->rq_WriteMdl != NULL) &&
        (pRequest->rq_CacheMgrContext == NULL))
	{
		AfpFreeMdl(pRequest->rq_WriteMdl);
		pRequest->rq_WriteMdl = NULL;
	}


	if ((Status != AFP_ERR_NONE) &&
		(Status != AFP_ERR_QUEUE))
	{
		if (pWriteBuf != NULL)
        {
			AfpIOFreeBuffer(pWriteBuf);
        }
		pSda->sda_IOBuf = NULL;
		pSda->sda_IOSize = 0;
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);

	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_UnmarshallCount);
	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AfpServerProfile->perf_UnmarshallTime,
									TimeD,
									&AfpStatisticsLock);
#endif
	AfpDisposeRequest(pSda, Status);
}



/***	AfpCompleteApiProcessing
 *
 *	Called in when the API processing is complete. Book-keeping is performed
 *	and a reply sent. If any buffers were allocated during un-marshalling,
 *	then they are freed up.
 *
 *	LOCKS:	sda_Lock (SPIN), AfpStatisticsLock (SPIN)
 *
 */
VOID FASTCALL
AfpCompleteApiProcessing(
	IN	PSDA		pSda,
	IN	AFPSTATUS	RetCode
)
{
	POPENFORKENTRY	pOpenForkEntry = NULL;
	PCONNDESC		pConnDesc = NULL;
	PDFRDREQQ		pDfrdReq = NULL;
	PLIST_ENTRY		pList;
	KIRQL			OldIrql;
	PMDL			ReplyMdl;
	PREQUEST		pRequest;
	struct _RequestPacket
	{
		union
		{
			PCONNDESC		_pConnDesc;
			POPENFORKENTRY	_pOpenForkEntry;
		};
	};

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
		("AfpCompleteApiProcessing: Completed <%s>\n", afpApiNames[pSda->sda_AfpFunc]));

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

	// If there is a deferred request, dequeue it now while we have the lock
	if (!IsListEmpty(&pSda->sda_DeferredQueue))
	{
		pList = RemoveHeadList(&pSda->sda_DeferredQueue);
		pDfrdReq = CONTAINING_RECORD(pList, DFRDREQQ, drq_Link);
	}

	ASSERT (pSda->sda_Flags & SDA_REQUEST_IN_PROCESS);

	pSda->sda_Flags &= ~SDA_QUEUE_IF_DPC;
	if (pSda->sda_Flags & SDA_DEREF_VOLUME)
	{
		pConnDesc = pReqPkt->_pConnDesc;
		pReqPkt->_pConnDesc = NULL;

		ASSERT(VALID_CONNDESC(pConnDesc));

		pSda->sda_Flags &= ~SDA_DEREF_VOLUME;

		// If we have a enumerated directory context, free it up
		// but only if we are not in the middle of an enumerate
		// and we are not doing the periodic GetVolParms either
		if ((pConnDesc->cds_pEnumDir != NULL) &&
			(pSda->sda_AfpFunc != _AFP_ENUMERATE) &&
			(pSda->sda_AfpFunc != _AFP_GET_VOL_PARMS))
		{
			AfpFreeMemory(pConnDesc->cds_pEnumDir);
			pConnDesc->cds_pEnumDir = NULL;
		}
	}
	if (pSda->sda_Flags & SDA_DEREF_OFORK)
	{
		pOpenForkEntry = pReqPkt->_pOpenForkEntry;

		ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

		pSda->sda_Flags &= ~SDA_DEREF_OFORK;
	}

	if (pSda->sda_NameBuf != NULL)
	{
		if (pSda->sda_NameBuf != pSda->sda_NameXSpace)
		{
			AfpFreeMemory(pSda->sda_NameBuf);
		}
		else
		{
			pSda->sda_Flags &= ~SDA_NAMEXSPACE_IN_USE;
		}
	    pSda->sda_NameBuf = NULL;
	}

	// Clear these fields. We do not want left-overs from previous api lying around.
	ASSERT((FIELD_OFFSET(SDA, sda_Name) - FIELD_OFFSET(SDA, sda_ReqBlock)) ==
													sizeof(DWORD)*(MAX_REQ_ENTRIES_PLUS_1));
	RtlZeroMemory(&pSda->sda_ReqBlock[0],
				  (sizeof(ANSI_STRING)*MAX_VAR_ENTRIES) + (sizeof(DWORD)*(MAX_REQ_ENTRIES_PLUS_1)));

	pSda->sda_SecUtilResult = STATUS_SUCCESS;

	ASSERT(pSda->sda_AfpFunc < _AFP_MAX_ENTRIES);

#ifdef	PROFILING
	{
		TIME	ApiEndTime, FuncTime;

		ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);

		// Update profile info
		AfpGetPerfCounter(&ApiEndTime);
		FuncTime.QuadPart = ApiEndTime.QuadPart - pSda->sda_ApiStartTime.QuadPart;

		AfpServerProfile->perf_ApiCounts[pSda->sda_AfpFunc] ++;
		AfpServerProfile->perf_ApiCumTimes[pSda->sda_AfpFunc].QuadPart += FuncTime.QuadPart;

		// Do not make this completely useless by recording times
		// for apis that do not succeed. They detect an error early
		// and hence make the Best Time fairly bogus
		if (RetCode == AFP_ERR_NONE)
		{
			if ((FuncTime.QuadPart > AfpServerProfile->perf_ApiWorstTime[pSda->sda_AfpFunc].QuadPart) ||
				(AfpServerProfile->perf_ApiWorstTime[pSda->sda_AfpFunc].QuadPart == 0))
				AfpServerProfile->perf_ApiWorstTime[pSda->sda_AfpFunc].QuadPart = FuncTime.QuadPart;

			if ((FuncTime.QuadPart < AfpServerProfile->perf_ApiBestTime[pSda->sda_AfpFunc].QuadPart) ||
				(AfpServerProfile->perf_ApiBestTime[pSda->sda_AfpFunc].QuadPart == 0))
				AfpServerProfile->perf_ApiBestTime[pSda->sda_AfpFunc].QuadPart = FuncTime.QuadPart;
		}

		RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
	}
#endif

	INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataOut,
							   (LONG)pSda->sda_ReplySize + (LONG)sizeof(RetCode),
							   &AfpStatisticsLock);

	pRequest = pSda->sda_Request;

	// We are done with the request. Do not reset if we have a deferred request to process
	if (pDfrdReq == NULL)
	{
		pSda->sda_Flags &= ~SDA_REQUEST_IN_PROCESS;
	}
	else
	{
		pSda->sda_Request = pDfrdReq->drq_pRequest;
	}

	// We are done with the request. Setup for reply.
	pSda->sda_Flags |= SDA_REPLY_IN_PROCESS;
	ReplyMdl = NULL;

    //
    // if we got Read Mdl from cache mgr, we don't allocate a new Mdl
    //
    if (pRequest->rq_CacheMgrContext)
    {
        ASSERT(pSda->sda_ReplyBuf == NULL);

        ReplyMdl = ((PDELAYEDALLOC)(pRequest->rq_CacheMgrContext))->pMdl;
    }

    //
    // nope, we are using our own buffer (if any).  We must allocate our
    // Mdl too
    //
    else
    {
	    if (pSda->sda_ReplyBuf != NULL)
	    {
		    ASSERT ((pSda->sda_ReplySize > 0) && (pSda->sda_ReplySize <= pSda->sda_MaxWriteSize));

		    if ((ReplyMdl = AfpAllocMdl(
                                (pSda->sda_ReplyBuf - DSI_BACKFILL_OFFSET(pSda)),
                                (pSda->sda_ReplySize + DSI_BACKFILL_OFFSET(pSda)),
                                NULL)) == NULL)
		    {
			    RetCode = AFP_ERR_MISC;
                AfpFreeReplyBuf(pSda, TRUE);
		    }
	    }
    }

	pSda->sda_ReplyBuf = NULL;
	pSda->sda_ReplySize = 0;

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	// Dereference the connection descriptor and the fork descriptor (from
	// above where we cannot call dereference as we are holding the SDA lock.
	if (pOpenForkEntry != NULL)
		AfpForkDereference(pOpenForkEntry);

	if (pConnDesc != NULL)
		AfpConnectionDereference(pConnDesc);

	pRequest->rq_ReplyMdl = ReplyMdl;

	AfpSpReplyClient(pRequest, RetCode, pSda->sda_XportTable);

	// Handle any deferred requests
	if (pDfrdReq != NULL)
	{
		KIRQL	OldIrql;

		// Note that AfpUnmarshallReq expects to be called at DISPATCH_LEVEL
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

#ifdef	PROFILING
		ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);
	
		AfpServerProfile->perf_CurDfrdReqCount --;
	
		RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif

		AfpUnmarshallReq(pSda);
		KeLowerIrql(OldIrql);
	
		AfpFreeMemory(pDfrdReq);
	}
}



/***	AfpStartApiProcessing
 *
 *	This is called when an API is queued up to the worker thread. This calls
 *	the real worker and then adjusts the count of outstanding worker requests.
 */
VOID FASTCALL
AfpStartApiProcessing(
	IN	PSDA	pSda
)
{
	AFPSTATUS	RetCode;
#ifdef	PROFILING
	TIME		TimeE;
#endif

	ASSERT(VALID_SDA(pSda) && (pSda->sda_WorkerRoutine != NULL));

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
						("AfpStartApiProcessing: Calling Fsp Worker for <%s>\n",
						afpApiNames[pSda->sda_AfpFunc]));

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeE.QuadPart -= pSda->sda_QueueTime.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_QueueTime,
								 TimeE,
								 &AfpStatisticsLock);
#endif

	// Call the real worker
	RetCode = (*pSda->sda_WorkerRoutine)(pSda);

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpStartApiProcessing: Fsp Worker returned %ld\n", RetCode));

	ASSERT ((RetCode != AFP_ERR_QUEUE) &&
			(RetCode != AFP_ERR_DEFER));

	if (RetCode != AFP_ERR_EXTENDED)
	{
		AfpCompleteApiProcessing(pSda, RetCode);
	}
}



/***	AfpDisposeRequest
 *
 *	The request has been un-marshalled. Determine what to do with it. The
 *	return code determines the possible course of action.
 */
VOID FASTCALL
AfpDisposeRequest(
	IN	PSDA		pSda,
	IN	AFPSTATUS	Status
)
{
	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
			("AfpDisposeRequest: %ld\n", Status));

    if ((Status == AFP_ERR_NONE) || (Status == AFP_ERR_QUEUE))
    {
	    ASSERT(VALID_SDA(pSda) && (pSda->sda_WorkerRoutine != NULL));
    }
    else
    {
	    ASSERT(VALID_SDA(pSda));
    }

	ASSERT (Status != AFP_ERR_DEFER);

	// Now see if must call the worker or queue it or respond
	if (Status == AFP_ERR_NONE)
	{
		Status = (*pSda->sda_WorkerRoutine)(pSda);
		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
				("AfpDisposeRequest: Fsd Worker returned %ld\n", Status));

		ASSERT (Status != AFP_ERR_DEFER);
	}

	if (Status == AFP_ERR_QUEUE)
	{
		if ((pSda->sda_Flags & SDA_QUEUE_IF_DPC) &&
			(KeGetCurrentIrql() != DISPATCH_LEVEL))
		{
			Status = (*pSda->sda_WorkerRoutine)(pSda);
			ASSERT ((Status != AFP_ERR_QUEUE) &&
					(Status != AFP_ERR_DEFER));

			if (Status != AFP_ERR_EXTENDED)
			{
				AfpCompleteApiProcessing(pSda, Status);
			}
		}
		else
		{
#ifdef	PROFILING
			AfpGetPerfCounter(&pSda->sda_QueueTime);
#endif
			AfpQueueWorkItem(&pSda->sda_WorkItem);
		}
	}

	else if ((Status != AFP_ERR_QUEUE) && (Status != AFP_ERR_EXTENDED))
	{
		AfpCompleteApiProcessing(pSda, Status);
	}
}



/***	afpQueueDeferredRequest
 *
 *	Queue a request in the deferred queue. The request is queued at the tail
 *	of the queue and dequeued at the head.
 *
 *	LOCKS_ASSUMED: sda_Lock (SPIN)
 */
VOID FASTCALL
afpQueueDeferredRequest(
	IN	PSDA		pSda,
	IN	PREQUEST	pRequest
)
{
	PDFRDREQQ		pDfrdReq;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
			("afpQueueDeferredRequest: Deferring Request\n"));

#ifdef	PROFILING
	ACQUIRE_SPIN_LOCK_AT_DPC(&AfpStatisticsLock);

	AfpServerProfile->perf_CurDfrdReqCount ++;
	if (AfpServerProfile->perf_CurDfrdReqCount >
						AfpServerProfile->perf_MaxDfrdReqCount)
	AfpServerProfile->perf_MaxDfrdReqCount =
						AfpServerProfile->perf_CurDfrdReqCount;

	RELEASE_SPIN_LOCK_FROM_DPC(&AfpStatisticsLock);
#endif

	pDfrdReq = (PDFRDREQQ)AfpAllocNonPagedMemory(sizeof(DFRDREQQ) + pRequest->rq_RequestSize);
	if (pDfrdReq == NULL)
	{
		// Should we respond to this request ? How ? Should we drop this session ?
		AFPLOG_DDERROR(AFPSRVMSG_DFRD_REQUEST,
					   STATUS_INSUFFICIENT_RESOURCES,
					   NULL,
					   0,
					   NULL);
		DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
				("afpQueueDeferredRequest: Unable to allocate DfrdReq packet, dropping request\n"));
		DBGBRK(DBG_LEVEL_FATAL);
		return;
	}

	RtlCopyMemory((PBYTE)pDfrdReq + sizeof(DFRDREQQ),
				  pRequest->rq_RequestBuf,
				  pRequest->rq_RequestSize);

	pDfrdReq->drq_pRequest = pRequest;
	pDfrdReq->drq_pRequest->rq_RequestBuf = (PBYTE)pDfrdReq + sizeof(DFRDREQQ);

	InsertTailList(&pSda->sda_DeferredQueue, &pDfrdReq->drq_Link);
}



/***	AfpGetWriteBuffer
 *
 *	This is called directly by the appletalk stack when a WRITE command is encountered.
 *	The request is examined for either FpWrite or FpAddIcon. These are the only reqs
 *	which uses a write command. If a request other than this is specified or if the
 *	size specified is 0 or if we fail to allocate memory or MDl, then a NULL is returned
 *	for the Mdl else a valid Mdl is returned.
 */
NTSTATUS FASTCALL
AfpGetWriteBuffer(
	IN	PSDA	    pSda,
	IN	PREQUEST    pRequest
)
{
	PMDL	            pMdl = NULL;
	PBYTE	            pBuf;
	LONG	            BufSize = 0;
    DWORD               Offset;
	USHORT		        ReqLen;
    PDELAYEDALLOC       pDelAlloc;
    POPENFORKENTRY      pOpenForkEntry;
    DWORD               OForkRefNum;
    NTSTATUS            status=STATUS_SUCCESS;
    KIRQL               OldIrql;
    PFILE_OBJECT        pFileObject;
    PFAST_IO_DISPATCH   pFastIoDisp;

	struct _FuncHdr
	{
		BYTE	_Func;
		BYTE	_SubFunc;
	};
	union _ReqHdr
	{
		struct _WriteReq
		{
			struct _FuncHdr	_FuncHdr;
			BYTE			_ForkRefNum[2];
			BYTE			_Offset[4];
			BYTE			_Size[4];
		} WriteReq;
		struct _AddIconReq
		{
			struct _FuncHdr	_FuncHdr;
			BYTE			_DTRefNum[2];
			BYTE			_Creator[4];
			BYTE			_Type[4];
			BYTE			_IconType;
			BYTE			_Reserved;
			BYTE			_IconTag[4];
			BYTE			_BitmapSize[2];
		} AddIconReq;
	} *pReqHdr;


    ReqLen = (USHORT)pRequest->rq_RequestSize;
	pReqHdr = (union _ReqHdr *)(pRequest->rq_RequestBuf);

    ASSERT(pRequest->rq_WriteMdl == NULL);

    pRequest->rq_WriteMdl = NULL;

	if ((pReqHdr != NULL) && (ReqLen >= sizeof(struct _FuncHdr)))
	{
		if ((pReqHdr->WriteReq._FuncHdr._Func == AFP_WRITE) &&
			(ReqLen >= sizeof(struct _WriteReq)))
		{
			GETDWORD2DWORD(&BufSize, pReqHdr->WriteReq._Size);

			if (BufSize > (LONG)pSda->sda_MaxWriteSize)
            {
				BufSize = (LONG)pSda->sda_MaxWriteSize;
            }

            //
            // if the Write is big enough, get an Mdl directly from cache mgr
            //
            if (BufSize >= CACHEMGR_WRITE_THRESHOLD)
            {
                // get the fork number from the request
                GETSHORT2DWORD(&OForkRefNum, pReqHdr->WriteReq._ForkRefNum);

                // get the offset at which to write
                GETDWORD2DWORD(&Offset, pReqHdr->WriteReq._Offset);

                KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
                pOpenForkEntry = AfpForkReferenceByRefNum(pSda, OForkRefNum);
                KeLowerIrql(OldIrql);

                if (pOpenForkEntry == NULL)
                {
	                DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	                    ("AfpGetWriteBuffer: couldn't ref fork on %lx\n", pSda));
                    return(STATUS_CONNECTION_DISCONNECTED);
                }

                pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
                pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;

                if ((pFileObject->Flags & FO_CACHE_SUPPORTED) &&
                    (pFastIoDisp->PrepareMdlWrite != NULL))
                {

                    pDelAlloc = AfpAllocDelAlloc();

                    if (pDelAlloc == NULL)
                    {
	                    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	                        ("AfpGetWriteBuffer: malloc for pDelAlloc failed\n"));

                        // remove the refcount we put before checking FO_CACHE_SUPPORTED
                        AfpForkDereference(pOpenForkEntry);
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }

                    // put DelayAlloc refcount
                    if (AfpSdaReferenceSessionByPointer(pSda) == NULL)
                    {
	                    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	                        ("AfpGetWriteBuffer: session closing, rejecting request\n"));

                        AfpFreeDelAlloc(pDelAlloc);

                        // remove the refcount we put before checking FO_CACHE_SUPPORTED
                        AfpForkDereference(pOpenForkEntry);
                        return(STATUS_CONNECTION_DISCONNECTED);
                    }

                    pRequest->rq_CacheMgrContext = pDelAlloc;

                    AfpInitializeWorkItem(&pDelAlloc->WorkItem,
                                          AfpAllocWriteMdl,
                                          pDelAlloc);

                    pDelAlloc->pSda = pSda;
                    pDelAlloc->pRequest = pRequest;
                    pDelAlloc->Offset.QuadPart = Offset;
                    pDelAlloc->BufSize = BufSize;
                    pDelAlloc->pOpenForkEntry = pOpenForkEntry;

// DELALLOCQUEUE: unrem the #if 0 part and delete the AfpQueueWorkItem line
#if 0
                    KeInsertQueue(&AfpDelAllocQueue, &(pDelAlloc->WorkItem.wi_List));
#endif
                    AfpQueueWorkItem(&pDelAlloc->WorkItem);

                    return(STATUS_PENDING);
                }
                else
                {
                    // remove the refcount we put before checking FO_CACHE_SUPPORTED
                    AfpForkDereference(pOpenForkEntry);
                }
            }
		}

		else if ((pReqHdr->AddIconReq._FuncHdr._Func == AFP_ADD_ICON) &&
				 (ReqLen >= sizeof(struct _AddIconReq)))
		{
			GETSHORT2DWORD(&BufSize, pReqHdr->AddIconReq._BitmapSize);
			if ((BufSize < 0) || (BufSize > (LONG)pSda->sda_MaxWriteSize))
			{
				BufSize = 0;
			}
		}

		if (BufSize > 0)
		{
			pBuf = AfpIOAllocBuffer(BufSize);
			if (pBuf != NULL)
			{
				pMdl = AfpAllocMdl(pBuf, BufSize, NULL);
				if (pMdl == NULL)
				{
					AfpIOFreeBuffer(pBuf);
                    status = STATUS_INSUFFICIENT_RESOURCES;
				}
			}
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
		}
	}

    pRequest->rq_WriteMdl = pMdl;

	return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\afpmem.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	memory.h

Abstract:

	This module contains the memory allocation routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _AFPMEMORY_
#define _AFPMEMORY_

//
// NOTE: The tag values below are designed to allocate/detect on free memory allocated.
//		 Note that the callers free the memory simply via AfpFreeMemory and allocate
//		 via AfpAllocMemory.
//
//		 via one of the three possible ways:
//		 a, Non paged memory via ExAllocatePool
//		 b, Paged memory via ExAllocatePool
//		 c, Non paged memory via Io Pool
//
#define	AFP_TAG							*(PULONG)"Afp "	// For ExAllocatePoolWithTag()
#define	PGD_MEM_TAG						0x11
#define	PAGED_MEMORY_TAG				(PGD_MEM_TAG << 24)
#define	NPG_MEM_TAG						0x22
#define	NON_PAGED_MEMORY_TAG			(NPG_MEM_TAG << 24)
#define	IO_POOL_TAG						0x44
#define	IO_POOL_MEMORY_TAG				(IO_POOL_TAG << 24)
#define	ZEROED_MEM_TAG					0x88
#define	ZEROED_MEMORY_TAG				(ZEROED_MEM_TAG << 24)
#define	MEMORY_TAG_MASK					(PAGED_MEMORY_TAG		| \
										 NON_PAGED_MEMORY_TAG	| \
										 IO_POOL_MEMORY_TAG		| \
										 ZEROED_MEMORY_TAG)

extern
NTSTATUS
AfpMemoryInit(
	VOID
);

extern
VOID
AfpMemoryDeInit(
	VOID
);

#ifdef	TRACK_MEMORY_USAGE

#define	AfpAllocNonPagedMemory(_S)			\
				AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocZeroedNonPagedMemory(_S)	\
				AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocPANonPagedMemory(_S)		\
				AfpAllocPAMemory((_S) | NON_PAGED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocPagedMemory(_S)				\
				AfpAllocMemory((_S) | PAGED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocZeroedPagedMemory(_S)	\
				AfpAllocMemory((_S) | PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG, FILENUM | __LINE__)

#define	AfpAllocPAPagedMemory(_S)			\
				AfpAllocPAMemory((_S) | PAGED_MEMORY_TAG, FILENUM | __LINE__)

extern
PBYTE FASTCALL
AfpAllocMemory(
	IN	LONG				Size,
	IN	DWORD				FileLine
);

extern
PBYTE FASTCALL
AfpAllocNonPagedLowPriority(
	IN	LONG	Size,
	IN	DWORD	FileLine
);

extern
PBYTE FASTCALL
AfpAllocPAMemory(
	IN	LONG				Size,
	IN	DWORD				FileLine
);

extern
VOID
AfpTrackMemoryUsage(
	IN	PVOID				pMem,
	IN	BOOLEAN				Alloc,
	IN	BOOLEAN				Paged,
	IN	DWORD				FileLine
);

#else

#define	AfpAllocNonPagedMemory(_S)			AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG)

#define	AfpAllocZeroedNonPagedMemory(_S)	AfpAllocMemory((_S) | NON_PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG)

#define	AfpAllocPANonPagedMemory(_S)		AfpAllocPAMemory((_S) | NON_PAGED_MEMORY_TAG)

#define	AfpAllocPagedMemory(_S)				AfpAllocMemory((_S) | PAGED_MEMORY_TAG)

#define	AfpAllocZeroedPagedMemory(_S)		AfpAllocMemory((_S) | PAGED_MEMORY_TAG | ZEROED_MEMORY_TAG)

#define	AfpAllocPAPagedMemory(_S)			AfpAllocPAMemory((_S) | PAGED_MEMORY_TAG)

extern
PBYTE FASTCALL
AfpAllocMemory(
	IN	LONG				Size
);

extern
PBYTE FASTCALL
AfpAllocNonPagedLowPriority(
	IN	LONG	Size
);

extern
PBYTE FASTCALL
AfpAllocPAMemory(
	IN	LONG				Size
);

#endif

#define	AfpAllocIoMemory(Size)				AfpIoAllocBuffer(Size)

extern
VOID FASTCALL
AfpFreeMemory(
	IN	PVOID				pBuffer
);

#define	AfpFreePAPagedMemory(_pBuf, _S)		AfpFreePAMemory(_pBuf, (_S) | PAGED_MEMORY_TAG)

#define	AfpFreePANonPagedMemory(_pBuf, _S)	AfpFreePAMemory(_pBuf, (_S) | NON_PAGED_MEMORY_TAG)

extern
VOID FASTCALL
AfpFreePAMemory(
	IN	PVOID				pBuffer,
	IN	DWORD				Size
);

extern
PBYTE FASTCALL
AfpAllocateVirtualMemoryPage(
	IN	VOID
);

extern
VOID FASTCALL
AfpFreeVirtualMemoryPage(
	IN	PVOID				pBuffer
);

extern
AFPSTATUS FASTCALL
AfpAllocReplyBuf(
	IN	PSDA				pSda
);

extern
PBYTE FASTCALL
AfpAllocStatusBuf(
	IN	LONG				Size
);

extern
PIRP FASTCALL
AfpAllocIrp(
	IN	CCHAR				StackSize
);

extern
VOID FASTCALL
AfpFreeIrp(
	IN	PIRP				pIrp
);

extern
PMDL FASTCALL
AfpAllocMdl(
	IN	PVOID				pBuffer,
	IN	DWORD				Size,
	IN	PIRP				pIrp
);

extern
PMDL
AfpAllocMdlForPagedPool(
	IN	PVOID				pBuffer,
	IN	DWORD				Size,
	IN	PIRP				pIrp
);

extern
VOID FASTCALL
AfpFreeMdl(
	IN	PMDL				pMdl
);

extern
DWORD FASTCALL
AfpMdlChainSize(
	IN	PMDL                pMdl
);

extern
PVOID FASTCALL
AfpIOAllocBuffer(
	IN	DWORD				BufSize
);

extern
VOID FASTCALL
AfpIOFreeBuffer(
	IN	PVOID				pBuffer
);

#define	EQUAL_UNICODE_STRING(pUS1, pUS2, fIgnoreCase)	\
		(((pUS1)->Length == (pUS2)->Length) &&			\
		 RtlEqualUnicodeString(pUS1, pUS2, fIgnoreCase))

#define	EQUAL_STRING(pS1, pS2, fIgnoreCase)				\
		(((pS1)->Length == (pS2)->Length) &&			\
		 RtlEqualString(pS1, pS2, fIgnoreCase))

// case sensitive unicode string compare
#define	EQUAL_UNICODE_STRING_CS(pUS1, pUS2)	\
		(((pUS1)->Length == (pUS2)->Length) &&			\
		 (memcmp((pUS1)->Buffer, (pUS2)->Buffer, (pUS1)->Length) == 0))

//
// AfpSetEmptyUnicodeString and AfpSetEmptyAnsiString are used in
// situations where you have allocated your own pointer for the string
// Buffer, and now you want to initialize all the fields of a counted
// string, making it point to your buffer and setting its length fields
// appropriately for an 'empty' string.  Situations like this would
// include data structures where you have allocated a large chunk of
// memory that has included room for any required strings at the end of
// the chunk.  For example, the VolDesc structure includes several
// counted strings, and we can just point the string buffers to the
// end of the same chunk of memory that the VolDesc itself occupies.
//
// VOID
// AfpSetEmptyUnicodeString(
// 	OUT	PUNICODE_STRING pstring,
//	IN	USHORT			buflen,
//  IN	PWSTR			pbuf
//  );
//

#define AfpSetEmptyUnicodeString(pstring,buflen,pbuf)		\
{															\
  (pstring)->Length = 0;									\
  (pstring)->MaximumLength = (USHORT)buflen;				\
  (pstring)->Buffer = (PWSTR)(pbuf);						\
}

//
// VOID
// AfpSetEmptyAnsiString(
// 	OUT	PANSI_STRING	pstring,
//	IN	USHORT			buflen,
//  IN	PCHAR			pbuf
//  );
//

#define AfpSetEmptyAnsiString(pstring,buflen,pbuf)			\
{															\
  (pstring)->Length = 0;									\
  (pstring)->MaximumLength = (USHORT)buflen;				\
  (pstring)->Buffer = (PCHAR)(pbuf);						\
}

//
//	AfpInitUnicodeStringWithNonNullTerm initializes a unicode string with
//  a non-null terminated wide char string and its length.
//
//	VOID
//	AfpInitUnicodeStringWithNonNullTerm(
//   OUT PUNICODE_STRING	pstring,
//	 IN	 USHORT				buflen,
//	 IN	 PWCHAR				pbuf
//	);
//

#define AfpInitUnicodeStringWithNonNullTerm(pstring,buflen,pbuf) \
{															\
	(pstring)->Buffer = pbuf;								\
	(pstring)->Length = (USHORT)buflen; 					\
	(pstring)->MaximumLength = (USHORT)buflen;				\
}

//
//	AfpInitAnsiStringWithNonNullTerm initializes an Ansi string with
//  a non-null terminated char string and its length.
//
//	VOID
//	AfpInitAnsiStringWithNonNullTerm(
//   OUT PANSI_STRING		pstring,
//	 IN	 USHORT				buflen,
//	 IN	 PCHAR				pbuf
//	);
//

#define AfpInitAnsiStringWithNonNullTerm(pstring,buflen,pbuf) \
{															\
	(pstring)->Buffer = pbuf;								\
	(pstring)->Length = (USHORT)buflen; 					\
	(pstring)->MaximumLength = (USHORT)buflen;				\
}

#define AfpCopyUnicodeString(pDst, pSrc)					\
{															\
	ASSERT((pDst)->MaximumLength >= (pSrc)->Length);		\
	RtlCopyMemory((pDst)->Buffer,							\
				  (pSrc)->Buffer,							\
				  (pSrc)->Length);							\
	(pDst)->Length = (pSrc)->Length;						\
}

#define AfpCopyAnsiString(pDst, pSrc)						\
{															\
	ASSERT((pDst)->MaximumLength >= (pSrc)->Length);		\
	RtlCopyMemory((pDst)->Buffer,							\
				  (pSrc)->Buffer,							\
				  (pSrc)->Length);							\
	(pDst)->Length = (pSrc)->Length;						\
}

#endif	// _AFPMEMORY_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\atalkio.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atalkio.c

Abstract:

	This module contains the interfaces to the appletalk stack and the
	completion routines for the IO requests to the stack via the TDI.
	All the routines in this module can be called at DPC level.


Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	18 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_ATALKIO

#include <afp.h>
#include <scavengr.h>
#include <forkio.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpSpOpenAddress)
#pragma alloc_text( PAGE, AfpSpCloseAddress)
#pragma alloc_text( PAGE, AfpSpRegisterName)
#endif



/***	AfpTdiPnpHandler
 *
 *	Call the routine (AfpSpOpenAddress) to bind to Asp.  This used to be done earlier
 *  in the DriverEntry code.  With plug-n-play, we do it after TDI calls
 *  us to notify us of an available binding
 */
VOID
AfpTdiPnpHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pBindDeviceName,
    IN PWSTR            BindingList
)
{
	NTSTATUS			Status;
	UNICODE_STRING		OurDeviceName;
    WORKER              ReCfgRoutine;
    WORK_ITEM           ReCfgWorkItem;
    KEVENT              ReCfgEvent;


    //
    // now see what pnp event has occured and do the needful
    //
	RtlInitUnicodeString(&OurDeviceName, ATALKASPS_DEVICENAME);

    if ((AfpServerState == AFP_STATE_STOP_PENDING) ||
        (AfpServerState == AFP_STATE_STOPPED))
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	        ("AfpTdiPnpHandler: server stopped or stopping (%d), ignoring PnP event %d\n",
            AfpServerState,PnPOpcode));

        return;
    }

    switch (PnPOpcode)
    {
        case TDI_PNP_OP_ADD:

            if (AfpServerBoundToAsp)
            {
    	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		   	        ("AfpTdi..: We are already bound!! ignoring!\n"));
                return;
            }

            // it had better be our device!
            if (!RtlEqualUnicodeString(pBindDeviceName, &OurDeviceName, TRUE))
            {
	            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		  	        ("AfpTdiPnpHandler: not our tranport: on %ws ignored\n",
                    pBindDeviceName->Buffer));

                ASSERT(0);

                return;
            }

	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
    	   	    ("AfpTdi..: Found our binding: %ws\n",pBindDeviceName->Buffer));

            ReCfgRoutine = (WORKER)AfpPnPReconfigEnable;

            break;

        case TDI_PNP_OP_DEL:

        	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		   	    ("AfpTdiPnpHandler: got TDI_PNP_OP_DEL, default adapter going away!\n"));

            if (!AfpServerBoundToAsp)
            {
        	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		    	    ("AfpTdiPnpHandler: We are not bound!! ignoring!\n"));
                return;
            }

            // it had better be our device!
            if (!RtlEqualUnicodeString(pBindDeviceName, &OurDeviceName, TRUE))
            {
	            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
		  	        ("AfpTdiPnpHandler: not our tranport: on %ws ignored\n",
                    pBindDeviceName->Buffer));

                ASSERT(0);

                return;
            }

            ReCfgRoutine = (WORKER)AfpPnPReconfigDisable;

            break;

        default:

        	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
		   	    ("AfpTdiPnpHandler: ignoring PnPOpcode %d on %ws\n",
                PnPOpcode,(pBindDeviceName)?pBindDeviceName->Buffer:L"Null Ptr"));

            return;
    }

    KeInitializeEvent(&ReCfgEvent,NotificationEvent, False);

    // file handle operation needs system context: use worker thread
    AfpInitializeWorkItem(&ReCfgWorkItem,
                          ReCfgRoutine,
                          &ReCfgEvent);

    AfpQueueWorkItem(&ReCfgWorkItem);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
        ("AfpTdiPnpHandler: put request on Queue, waiting for ReConfigure to complete\n"));

    KeWaitForSingleObject(&ReCfgEvent,
                          UserRequest,
                          KernelMode,
                          False,
                          NULL);

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
        ("AfpTdiPnpHandler: Reconfigure completed, returning....\n"));


}


/***	AfpPnPReconfigDisable
 *
 *	When the stack gets a PnPReconfigure event, we get notified too.  We first
 *  get the TDI_PNP_OP_DEL msg.  What we need to do here is close all the
 *  sessions and close the handle.
 */
VOID FASTCALL
AfpPnPReconfigDisable(
    IN PVOID    Context
)
{
    PKEVENT             pReCfgEvent;


    pReCfgEvent = (PKEVENT)Context;

	// Deregister our name from the network
	// Since the stack is going away, explicitly set the flag to FALSE
	// There may be timing issues here, where stack may go away
	// before SpRegisterName is issued.
	// Flagging explicitly avoids re-registration problems during PnPEnable
	AfpSpRegisterName(&AfpServerName, False);
    afpSpNameRegistered = FALSE;

    // Disable listens on ASP
    AfpSpDisableListensOnAsp();

    // now go and kill all the appletalk sessions
    AfpKillSessionsOverProtocol(TRUE);

    AfpSpCloseAddress();

    // wake up the blocked pnp thread
    KeSetEvent(pReCfgEvent, IO_NETWORK_INCREMENT, False);
}


/***	AfpPnPReconfigEnable
 *
 *	When the stack gets a PnPReconfigure event, we get notified too.  We
 *  get the TDI_PNP_OP_ADD msg.  What we need to do here is open our handle to
 *  the stack, register names etc.
 */
VOID FASTCALL
AfpPnPReconfigEnable(
    IN PVOID    Context
)
{

    NTSTATUS    Status=STATUS_SUCCESS;
    PKEVENT     pReCfgEvent;
    ULONG       OldServerState;


    pReCfgEvent = (PKEVENT)Context;

    if (afpSpAddressHandle == NULL)
    {
        Status = AfpSpOpenAddress();

        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	            ("AfpTdi..: AfpSpOpenAddress failed with status=%lx\n",Status));

            goto AfpPnPReconfigEnable_Exit;
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpPnPReconfigEnable: afp handle is already open!\n"));
        ASSERT(0);
        goto AfpPnPReconfigEnable_Exit;
    }

    if ((AfpServerState == AFP_STATE_START_PENDING) ||
        (AfpServerState == AFP_STATE_RUNNING))
    {
	    // Det the server status block
	    Status = AfpSetServerStatus();

	    if (!NT_SUCCESS(Status))
	    {
    	    AFPLOG_ERROR(AFPSRVMSG_SET_STATUS, Status, NULL, 0, NULL);
	        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        	    ("AfpTdi..: AfpSetServerStatus failed with %lx\n",Status));
            goto AfpPnPReconfigEnable_Exit;
	    }

        // Register our name on this address
	    Status = AfpSpRegisterName(&AfpServerName, True);

	    if (!NT_SUCCESS(Status))
	    {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	            ("AfpTdi...: AfpSpRegisterName failed with %lx\n",Status));

            goto AfpPnPReconfigEnable_Exit;
	    }

        // Enable listens now that we are ready for it.
	    AfpSpEnableListens();
    }


AfpPnPReconfigEnable_Exit:

    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	        ("AfpTdi...: Closing Asp because of failure %lx\n",Status));
        AfpSpCloseAddress();
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AFP/Appletalk bound and ready\n"));
    }
    // wake up the blocked pnp thread
    KeSetEvent(pReCfgEvent, IO_NETWORK_INCREMENT, False);

}

/***	AfpTdiRegister
 *
 *	Register our handler with tdi
 */
NTSTATUS
AfpTdiRegister(
    IN VOID
)
{
    NTSTATUS    Status;

    UNICODE_STRING ClientName;
    TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

    RtlInitUnicodeString(&ClientName,L"MacSrv");

    ClientInterfaceInfo.MajorTdiVersion = 2;
    ClientInterfaceInfo.MinorTdiVersion = 0;

    ClientInterfaceInfo.Unused = 0;
    ClientInterfaceInfo.ClientName = &ClientName;

    ClientInterfaceInfo.BindingHandler = AfpTdiPnpHandler;
    ClientInterfaceInfo.AddAddressHandlerV2 = DsiIpAddressCameIn;
    ClientInterfaceInfo.DelAddressHandlerV2 = DsiIpAddressWentAway;
    ClientInterfaceInfo.PnPPowerHandler = NULL;

    Status = TdiRegisterPnPHandlers (
                 &ClientInterfaceInfo,
                 sizeof(ClientInterfaceInfo),
                 &AfpTdiNotificationHandle );

    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
       	    ("AfpTdiRegister: TdiRegisterPnPHandlers failed (%lx)\n",Status));
    }

    return(Status);
}

/***	AfpSpOpenAddress
 *
 *	Create an address for the stack. This is called only once at initialization.
 *	Create a handle to the address and map it to the associated file object.
 *
 *	At this time, we do not know our server name. This is known only when the
 *	service calls us.
 */
AFPSTATUS
AfpSpOpenAddress(
	VOID
)
{
	NTSTATUS					Status;
	NTSTATUS					Status2;
	BYTE						EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
										TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
										sizeof(TA_APPLETALK_ADDRESS)];
	PFILE_FULL_EA_INFORMATION	pEaBuf = (PFILE_FULL_EA_INFORMATION)EaBuffer;
	TA_APPLETALK_ADDRESS		Ta;
	OBJECT_ATTRIBUTES			ObjAttr;
	UNICODE_STRING				DeviceName;
	IO_STATUS_BLOCK				IoStsBlk;
	PASP_BIND_ACTION			pBind = NULL;
	KEVENT						Event;
	PIRP						pIrp = NULL;
	PMDL						pMdl = NULL;


    PAGED_CODE( );

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
			("AfpSpOpenAddress: Creating an address object\n"));

	RtlInitUnicodeString(&DeviceName, ATALKASPS_DEVICENAME);

	InitializeObjectAttributes(&ObjAttr, &DeviceName, 0, NULL, NULL);

	// Initialize the EA Buffer
	pEaBuf->NextEntryOffset = 0;
	pEaBuf->Flags = 0;
	pEaBuf->EaValueLength = sizeof(TA_APPLETALK_ADDRESS);
	pEaBuf->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
	RtlCopyMemory(pEaBuf->EaName, TdiTransportAddress,
											TDI_TRANSPORT_ADDRESS_LENGTH + 1);
	Ta.TAAddressCount = 1;
	Ta.Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;
	Ta.Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);
	Ta.Address[0].Address[0].Socket = 0;
	// Ta.Address[0].Address[0].Network = 0;
	// Ta.Address[0].Address[0].Node = 0;
	RtlCopyMemory(&pEaBuf->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1], &Ta, sizeof(Ta));

	do
	{
		// Create the address object.
		Status = NtCreateFile(
						&afpSpAddressHandle,
						0,									// Don't Care
						&ObjAttr,
						&IoStsBlk,
						NULL,								// Don't Care
						0,									// Don't Care
						0,									// Don't Care
						0,									// Don't Care
						FILE_GENERIC_READ + FILE_GENERIC_WRITE,
						&EaBuffer,
						sizeof(EaBuffer));

		if (!NT_SUCCESS(Status))
		{
			AFPLOG_DDERROR(AFPSRVMSG_CREATE_ATKADDR, Status, NULL, 0, NULL);
			break;
		}

		// Get the file object corres. to the address object.
		Status = ObReferenceObjectByHandle(
								afpSpAddressHandle,
								0,
								NULL,
								KernelMode,
								(PVOID *)&afpSpAddressObject,
								NULL);

		ASSERT (NT_SUCCESS(Status));
		if (!NT_SUCCESS(Status))
		{
			if (afpSpAddressHandle != NULL)
			{
				ASSERT(VALID_FSH((PFILESYSHANDLE)&afpSpAddressHandle)) ;
				Status2 = NtClose(afpSpAddressHandle);

				afpSpAddressHandle = NULL;
		
				ASSERT(NT_SUCCESS(Status2));
			}

			AFPLOG_DDERROR(AFPSRVMSG_CREATE_ATKADDR, Status, NULL, 0, NULL);
			break;
		}

		// Now get the device object to the appletalk stack
		afpSpAppleTalkDeviceObject = IoGetRelatedDeviceObject(afpSpAddressObject);

		ASSERT (afpSpAppleTalkDeviceObject != NULL);

		// Now 'bind' to the ASP layer of the stack. Basically exchange the entry points
		// Allocate an Irp and an Mdl to describe the bind request
		KeInitializeEvent(&Event, NotificationEvent, False);

		if (((pBind = (PASP_BIND_ACTION)AfpAllocNonPagedMemory(
									sizeof(ASP_BIND_ACTION))) == NULL) ||
			((pIrp = AfpAllocIrp(1)) == NULL) ||
			((pMdl = AfpAllocMdl(pBind, sizeof(ASP_BIND_ACTION), pIrp)) == NULL))
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		afpInitializeActionHdr(pBind, ACTION_ASP_BIND);

		// Initialize the client part of the bind request
		pBind->Params.ClientEntries.clt_SessionNotify = AfpSdaCreateNewSession;
		pBind->Params.ClientEntries.clt_RequestNotify = afpSpHandleRequest;
		pBind->Params.ClientEntries.clt_GetWriteBuffer = AfpGetWriteBuffer;
		pBind->Params.ClientEntries.clt_ReplyCompletion = afpSpReplyComplete;
        pBind->Params.ClientEntries.clt_AttnCompletion = afpSpAttentionComplete;
		pBind->Params.ClientEntries.clt_CloseCompletion = afpSpCloseComplete;
		pBind->Params.pXportEntries = &AfpAspEntries;

		TdiBuildAction(	pIrp,
						AfpDeviceObject,
						afpSpAddressObject,
						(PIO_COMPLETION_ROUTINE)afpSpGenericComplete,
						&Event,
						pMdl);

		IoCallDriver(afpSpAppleTalkDeviceObject, pIrp);

		// Assert this. We cannot block at DISPATCH_LEVEL
		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

		AfpIoWait(&Event, NULL);
	} while (False);

	// Free the allocated resources
	if (pIrp != NULL)
		AfpFreeIrp(pIrp);
	if (pMdl != NULL)
		AfpFreeMdl(pMdl);
	if (pBind != NULL)
		AfpFreeMemory(pBind);

    if (NT_SUCCESS(Status))
    {
        AfpServerBoundToAsp = TRUE;

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	        ("AfpSpOpenAddress: net addr (net.node.socket) on def adapter = %x.%x.%x\n",
            AfpAspEntries.asp_AtalkAddr.Network,AfpAspEntries.asp_AtalkAddr.Node,AfpAspEntries.asp_AtalkAddr.Socket));
    }

	return Status;
}


/***	AfpSpCloseAddress
 *
 *	Close the socket address. This is called only once at driver unload.
 */
VOID
AfpSpCloseAddress(
	VOID
)
{
	NTSTATUS	Status;

	PAGED_CODE( );

	if (afpSpAddressHandle != NULL)
	{
		ObDereferenceObject(afpSpAddressObject);

		Status = NtClose(afpSpAddressHandle);

        afpSpAddressHandle = NULL;

		ASSERT(NT_SUCCESS(Status));
	}

    AfpServerBoundToAsp = FALSE;

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
	    ("AfpSpCloseAddress: closed Afp handle (%lx)\n",Status));
}


/***	AfpSpRegisterName
 *
 *	Call Nbp[De]Register to (de)register our name on the address that we
 *	already opened. This is called at server start/pause/continue. The server
 *	name is already validated and known to not contain any invalid characters.
 *	This call is synchronous to the caller, i.e. we wait for operation to
 *	complete and return an appropriate error.
 */
AFPSTATUS
AfpSpRegisterName(
	IN	PANSI_STRING	ServerName,
	IN	BOOLEAN			Register
)
{
	KEVENT					Event;
	PNBP_REGDEREG_ACTION	pNbp = NULL;
	PIRP					pIrp = NULL;
	PMDL					pMdl = NULL;
	AFPSTATUS				Status = AFP_ERR_NONE;
	USHORT					ActionCode;

	PAGED_CODE( );

	ASSERT(afpSpAddressHandle != NULL && afpSpAddressObject != NULL);

	if (Register ^ afpSpNameRegistered)
	{
		ASSERT(ServerName->Buffer != NULL);
		do
		{
			if (((pNbp = (PNBP_REGDEREG_ACTION)
						AfpAllocNonPagedMemory(sizeof(NBP_REGDEREG_ACTION))) == NULL) ||
				((pIrp = AfpAllocIrp(1)) == NULL) ||
				((pMdl = AfpAllocMdl(pNbp, sizeof(NBP_REGDEREG_ACTION), pIrp)) == NULL))
			{
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// Initialize the Action header and NBP Name. Note that the ServerName
			// is also NULL terminated apart from being a counted string.
			ActionCode = Register ?
						COMMON_ACTION_NBPREGISTER : COMMON_ACTION_NBPREMOVE;
			afpInitializeActionHdr(pNbp, ActionCode);

			pNbp->Params.RegisterTuple.NbpName.ObjectNameLen =
														(BYTE)(ServerName->Length);
			RtlCopyMemory(
				pNbp->Params.RegisterTuple.NbpName.ObjectName,
				ServerName->Buffer,
				ServerName->Length);

			pNbp->Params.RegisterTuple.NbpName.TypeNameLen =
													sizeof(AFP_SERVER_TYPE)-1;
			RtlCopyMemory(
				pNbp->Params.RegisterTuple.NbpName.TypeName,
				AFP_SERVER_TYPE,
				sizeof(AFP_SERVER_TYPE));

			pNbp->Params.RegisterTuple.NbpName.ZoneNameLen =
												sizeof(AFP_SERVER_ZONE)-1;
			RtlCopyMemory(
				pNbp->Params.RegisterTuple.NbpName.ZoneName,
				AFP_SERVER_ZONE,
				sizeof(AFP_SERVER_ZONE));

			KeInitializeEvent(&Event, NotificationEvent, False);

			// Build the Irp
			TdiBuildAction(	pIrp,
							AfpDeviceObject,
							afpSpAddressObject,
							(PIO_COMPLETION_ROUTINE)afpSpGenericComplete,
							&Event,
							pMdl);

			IoCallDriver(afpSpAppleTalkDeviceObject, pIrp);

			// Assert this. We cannot block at DISPATCH_LEVEL
			ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

			// Wait for completion.
			AfpIoWait(&Event, NULL);

			Status = pIrp->IoStatus.Status;
		} while (False);

		if (NT_SUCCESS(Status))
		{
			afpSpNameRegistered = Register;
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_REGISTER_NAME, Status, NULL, 0, NULL);
		}

		if (pNbp != NULL)
			AfpFreeMemory(pNbp);
		if (pIrp != NULL)
			AfpFreeIrp(pIrp);
		if (pMdl != NULL)
			AfpFreeMdl(pMdl);
	}
	return Status;
}


/***	AfpSpReplyClient
 *
 *	This is a wrapper over AspReply.
 *	The SDA is set up to accept another request when the reply completes.
 *	The sda_ReplyBuf is also freed up then.
 */
VOID FASTCALL
AfpSpReplyClient(
	IN	PREQUEST	        pRequest,
	IN	LONG		        ReplyCode,
    IN  PASP_XPORT_ENTRIES  XportTable
)
{
	LONG			Response;

	// Update count of outstanding replies
	INTERLOCKED_INCREMENT_LONG((PLONG)&afpSpNumOutstandingReplies);

	// Convert reply code to on-the-wire format
	PUTDWORD2DWORD(&Response, ReplyCode);

	(*(XportTable->asp_Reply))(pRequest,(PUCHAR)&Response);
}


/***	AfpSpSendAttention
 *
 *	Send a server attention to the client
 */
VOID FASTCALL
AfpSpSendAttention(
	IN	PSDA				pSda,
	IN	USHORT				AttnCode,
	IN	BOOLEAN				Synchronous
)
{
	KEVENT		Event;
	NTSTATUS	Status;

	if (Synchronous)
	{
		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
		KeInitializeEvent(&Event, NotificationEvent, False);
	
	}
	Status = (*(pSda->sda_XportTable->asp_SendAttention))((pSda)->sda_SessHandle,
												  AttnCode,
												  Synchronous ? &Event : NULL);

	if (NT_SUCCESS(Status) && Synchronous)
	{
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
		AfpIoWait(&Event, NULL);
	}
}


/***	AfpAllocReplyBuf
 *
 *	Allocate a reply buffer from non-paged memory. Initialize sda_ReplyBuf
 *	with the pointer. If the reply buffer is small enough, use it out of the
 *	sda itself.
 */
AFPSTATUS FASTCALL
AfpAllocReplyBuf(
	IN	PSDA	pSda
)
{
	KIRQL	OldIrql;
    PBYTE   pStartOfBuffer;
    DWORD   Offset;
    USHORT  ReplySize;


	ASSERT ((SHORT)(pSda->sda_ReplySize) >= 0);

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

    ReplySize =  pSda->sda_ReplySize;
    Offset = 0;

    //
    // for a TCP connection, alloc space for the DSI header
    //
    if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)
    {
        ReplySize += DSI_HEADER_SIZE;
        Offset = DSI_HEADER_SIZE;
    }

	if (((pSda->sda_Flags & SDA_NAMEXSPACE_IN_USE) == 0) &&
		(ReplySize <= pSda->sda_SizeNameXSpace))
	{
		pStartOfBuffer = pSda->sda_NameXSpace;
		pSda->sda_Flags |= SDA_NAMEXSPACE_IN_USE;
	}
	else
	{
		pStartOfBuffer = AfpAllocNonPagedMemory(ReplySize);
	}

	if (pStartOfBuffer != NULL)
	{
        pSda->sda_ReplyBuf = (pStartOfBuffer + Offset);
	}
    else
    {
		pSda->sda_ReplySize = 0;
        pSda->sda_ReplyBuf = NULL;
    }


#if DBG
    if (pStartOfBuffer != NULL)
    {
        *(DWORD *)pStartOfBuffer = 0x081294;
    }
#endif

	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	return ((pSda->sda_ReplyBuf == NULL) ? AFP_ERR_MISC : AFP_ERR_NONE);
}


/***	AfpSpCloseSession
 *
 *	Shutdown an existing session
 */
NTSTATUS FASTCALL
AfpSpCloseSession(
	IN	PSDA				pSda
)
{
    PASP_XPORT_ENTRIES  XportTable;

    XportTable = pSda->sda_XportTable;

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
			("AfpSpCloseSession: Closing session %lx\n", pSda->sda_SessHandle));

	(*(XportTable->asp_CloseConn))(pSda->sda_SessHandle);

	return STATUS_PENDING;
}


/***	afpSpHandleRequest
 *
 *	Handle an incoming request.
 *
 *	LOCKS:		afpSpDeferralQLock (SPIN)
 */
NTSTATUS FASTCALL
afpSpHandleRequest(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda,
	IN	PREQUEST			pRequest
)
{
    NTSTATUS        RetStatus=STATUS_SUCCESS;
	PBYTE	        pWriteBuf;
    PDELAYEDALLOC   pDelAlloc;


	ASSERT(VALID_SDA(pSda));

	// Get the status code and determine what happened.
	if (NT_SUCCESS(Status))
	{
		ASSERT(VALID_SDA(pSda));
		ASSERT(pSda->sda_RefCount != 0);
		ASSERT(pSda->sda_SessionId != 0);

		ACQUIRE_SPIN_LOCK_AT_DPC(&pSda->sda_Lock);

        if (pSda->sda_Flags & (SDA_CLOSING | SDA_SESSION_CLOSED | SDA_CLIENT_CLOSE))
        {
		    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
				("afpSpHandleRequest: got request on a closing connection!\n"));
		    RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

		    // If this was a write request and we have allocated a write Mdl, free that
		    if (pRequest->rq_WriteMdl != NULL)
		    {
                //
                // did we get this Mdl from cache mgr?  if so, treat it separately
                //
                if ((pDelAlloc = pRequest->rq_CacheMgrContext) != NULL)
                {
                    pDelAlloc->Flags |= AFP_CACHEMDL_DEADSESSION;

                    ASSERT(pRequest->rq_WriteMdl == pDelAlloc->pMdl);
                    ASSERT(!(pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR));

                    pRequest->rq_CacheMgrContext = NULL;

                    AfpReturnWriteMdlToCM(pDelAlloc);
                }
                else
                {
			        pWriteBuf = MmGetSystemAddressForMdlSafe(
							pRequest->rq_WriteMdl,
							NormalPagePriority);
					if (pWriteBuf != NULL)
					{
						AfpIOFreeBuffer(pWriteBuf);
					}
			        AfpFreeMdl(pRequest->rq_WriteMdl);
                }

                pRequest->rq_WriteMdl = NULL;
		    }

            return(STATUS_LOCAL_DISCONNECT);
        }

		pSda->sda_RefCount ++;

        //
        // should we queue this request up?
        //
		if ((pSda->sda_Flags & SDA_REQUEST_IN_PROCESS)	||
			(!IsListEmpty(&pSda->sda_DeferredQueue)))
		{
			afpQueueDeferredRequest(pSda, pRequest);
		    RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);
		}

        //
        // nope, let's do it now!
        //
		else
		{
			pSda->sda_Request = pRequest;
			pSda->sda_Flags |= SDA_REQUEST_IN_PROCESS;

			ASSERT ((pSda->sda_ReplyBuf == NULL) &&
					(pSda->sda_ReplySize == 0));

		    RELEASE_SPIN_LOCK_FROM_DPC(&pSda->sda_Lock);

			// Call AfpUnmarshallReq now. It will do the needful.
			AfpUnmarshallReq(pSda);
		}
	}
	else
	{
		KIRQL	OldIrql;

		DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
				("afpSpHandleRequest: Error %lx\n", Status));

		// if we nuked this session from the session maintenance timer the
		// status will be STATUS_LOCAL_DISCONNECT else STATUS_REMOTE_DISCONNECT
		// in the former case, log an error.
		if (Status == STATUS_LOCAL_DISCONNECT)
		{
			// The appletalk address of the client is encoded in the length
			if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
			{
				if (pSda->sda_Flags & SDA_SESSION_OVER_TCP) {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT_GUEST_TCPIP,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							NULL);
				} else {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT_GUEST,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							NULL);
				}
			}
			else
			{
				if (pSda->sda_Flags & SDA_SESSION_OVER_TCP) {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT_TCPIP,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							&pSda->sda_UserName);
				} else {
					AFPLOG_DDERROR(AFPSRVMSG_DISCONNECT,
							Status,
							&pRequest->rq_RequestSize,
							sizeof(LONG),
							&pSda->sda_UserName);
				}
			}
		}

		// Close down this session, but only if it isn't already closing
		// Its important to do this ahead of posting any new sessions since
		// we must take into account the ACTUAL number of sessions there are
		ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);

		pSda->sda_Flags |= SDA_CLIENT_CLOSE;
		if ((pSda->sda_Flags & SDA_SESSION_CLOSED) == 0)
		{
			DBGPRINT(DBG_COMP_SDA, DBG_LEVEL_INFO,
					("afpSpHandleRequest: Closing session handle\n"));
	
			pSda->sda_Flags |= SDA_SESSION_CLOSED;
			RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
			AfpSpCloseSession(pSda);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);
		}

		// If this was a write request and we have allocated a write Mdl, free that
		if (pRequest->rq_WriteMdl != NULL)
		{
            //
            // did we get this Mdl from cache mgr?  if so, treat it separately
            //
            if ((pDelAlloc = pRequest->rq_CacheMgrContext) != NULL)
            {
                pDelAlloc->Flags |= AFP_CACHEMDL_DEADSESSION;

                ASSERT(pRequest->rq_WriteMdl == pDelAlloc->pMdl);
                ASSERT(!(pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR));

                pRequest->rq_CacheMgrContext = NULL;

                AfpReturnWriteMdlToCM(pDelAlloc);
            }
            else
            {
			    pWriteBuf = MmGetSystemAddressForMdlSafe(
						pRequest->rq_WriteMdl,
						NormalPagePriority);
				if (pWriteBuf != NULL)
				{
					AfpIOFreeBuffer(pWriteBuf);
				}
			    AfpFreeMdl(pRequest->rq_WriteMdl);
            }

            pRequest->rq_WriteMdl = NULL;
		}
	}

    return(RetStatus);
}


/***	afpSpGenericComplete
 *
 *	Generic completion for an asynchronous request to the appletalk stack.
 *	Just clear the event and we are done.
 */
LOCAL NTSTATUS
afpSpGenericComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PKEVENT			pCmplEvent
)
{
	KeSetEvent(pCmplEvent, IO_NETWORK_INCREMENT, False);

	// Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
	// will stop working on the IRP.

	return STATUS_MORE_PROCESSING_REQUIRED;
}


/***	afpSpReplyComplete
 *
 *	This is the completion routine for AfpSpReplyClient(). The reply buffer is freed
 *	up and the Sda dereferenced.
 */
VOID FASTCALL
afpSpReplyComplete(
	IN	NTSTATUS	Status,
	IN	PSDA		pSda,
	IN	PREQUEST	pRequest
)
{
	KIRQL           OldIrql;
	DWORD           Flags = SDA_REPLY_IN_PROCESS;
	PMDL	        pMdl;
    PDELAYEDALLOC   pDelAlloc;


	ASSERT(VALID_SDA(pSda));

	// Update the afpSpNumOutstandingReplies
	ASSERT (afpSpNumOutstandingReplies != 0);

	DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
			("afpSpReplyComplete: %ld\n", Status));

	INTERLOCKED_DECREMENT_LONG((PLONG)&afpSpNumOutstandingReplies);

    pMdl = pRequest->rq_ReplyMdl;

    if ((pDelAlloc = pRequest->rq_CacheMgrContext) != NULL)
    {
        pRequest->rq_CacheMgrContext = NULL;

        ASSERT((pMdl != NULL) && (pMdl == pDelAlloc->pMdl));

        AfpReturnReadMdlToCM(pDelAlloc);
    }
    else
    {
	    if (pMdl != NULL)
	    {
		    PBYTE	pReplyBuf;

		    pReplyBuf = MmGetSystemAddressForMdlSafe(
					pMdl,
					NormalPagePriority);
		    ASSERT (pReplyBuf != NULL);

		    if ((pReplyBuf != pSda->sda_NameXSpace) &&
					(pReplyBuf != NULL))
            {
			     AfpFreeMemory(pReplyBuf);
            }
		    else
            {
                Flags |= SDA_NAMEXSPACE_IN_USE;
            }

		    AfpFreeMdl(pMdl);
	    }
    }

	ACQUIRE_SPIN_LOCK(&pSda->sda_Lock, &OldIrql);
	pSda->sda_Flags &= ~Flags;
	RELEASE_SPIN_LOCK(&pSda->sda_Lock, OldIrql);

	AfpSdaDereferenceSession(pSda);
}


/***	afpSpAttentionComplete
 *
 *	Completion routine for AfpSpSendAttention. Just signal the event and unblock caller.
 */
VOID FASTCALL
afpSpAttentionComplete(
	IN	PVOID				pEvent
)
{
	if (pEvent != NULL)
		KeSetEvent((PKEVENT)pEvent, IO_NETWORK_INCREMENT, False);
}


/***	afpSpCloseComplete
 *
 *	Completion routine for AfpSpCloseSession. Remove the creation reference
 *	from the sda.
 */
VOID FASTCALL
afpSpCloseComplete(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda
)
{
	AfpInterlockedSetDword(&pSda->sda_Flags,
							SDA_SESSION_CLOSE_COMP,
							&pSda->sda_Lock);
	AfpScavengerScheduleEvent(AfpSdaCloseSession,
							  pSda,
							  0,
							  True);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\atalkio.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atalkio.h

Abstract:

	This module contains interface specification to the appletalk stack.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATALKIO_
#define	_ATALKIO_

extern BOOLEAN  AfpServerBoundToAsp;
extern BOOLEAN  AfpServerBoundToTcp;

extern HANDLE   AfpTdiNotificationHandle;

extern
VOID
AfpTdiPnpHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pBindDeviceName,
    IN PWSTR            BindingList
);

extern
VOID FASTCALL
AfpPnPReconfigDisable(
    IN PVOID    Context
);

extern
VOID FASTCALL
AfpPnPReconfigEnable(
    IN PVOID    Context
);


extern
NTSTATUS
AfpTdiRegister(
    IN VOID
);

extern
VOID
AfpTdiBindCallback(
    IN PUNICODE_STRING pBindDeviceName
);

extern
VOID
AfpTdiUnbindCallback(
    IN PUNICODE_STRING pBindDeviceName
);

extern
NTSTATUS
AfpSpOpenAddress(
	VOID
);


extern
VOID
AfpSpCloseAddress(
	VOID
);


extern
NTSTATUS FASTCALL
AfpSpCloseSession(
	IN	PSDA				pSda
);


extern
AFPSTATUS
AfpSpRegisterName(
	IN	PANSI_STRING		ServerName,
	IN	BOOLEAN				Register
);


extern
VOID FASTCALL
AfpSpReplyClient(
	IN	PREQUEST			pRequest,
	IN	LONG				ReplyCode,
    IN  PASP_XPORT_ENTRIES  XportTable
);


extern
VOID FASTCALL
AfpSpSendAttention(
	IN	PSDA				pSda,
	IN	USHORT				AttnCode,
	IN	BOOLEAN				Synchronous
);

extern
VOID
AfpFreeReplyBuf(
    IN  PSDA    pSda,
    IN  BOOLEAN fLockHeld
);


#define DSI_BACKFILL_OFFSET(pSda) \
    ((pSda->sda_Flags & SDA_SESSION_OVER_TCP)? DSI_HEADER_SIZE : 0)

//
// when we go over TCP/IP, we want to allocate 16 more bytes for the
// DSI header for better performance.
//
#define AfpIOAllocBackFillBuffer(pSda)                              \
    {                                                               \
        DWORD   _ReplySize = pSda->sda_ReplySize;                   \
        DWORD   _Offset = 0;                                        \
        PBYTE   _pReplyBufStart;                                    \
                                                                    \
        if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)                 \
        {                                                           \
            _ReplySize += DSI_HEADER_SIZE;                          \
            _Offset = DSI_HEADER_SIZE;                              \
        }                                                           \
                                                                    \
        _pReplyBufStart = AfpIOAllocBuffer(_ReplySize);             \
                                                                    \
        if (_pReplyBufStart != NULL)                                \
        {                                                           \
            pSda->sda_IOBuf = _pReplyBufStart+_Offset;              \
        }                                                           \
        else                                                        \
        {                                                           \
            pSda->sda_IOBuf = NULL;                                 \
        }                                                           \
    }


#define AfpPutGuardSignature(pSda)                                  \
    {                                                               \
        PBYTE   _pReplyBufStart = pSda->sda_IOBuf;                  \
        if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)                 \
        {                                                           \
            _pReplyBufStart -= DSI_HEADER_SIZE;                     \
        }                                                           \
        *(DWORD *)_pReplyBufStart = 0x081294;                       \
    }

#define AfpIOFreeBackFillBuffer(pSda)                               \
    {                                                               \
        DWORD   _Offset = 0;                                        \
        PBYTE   _pReplyBufStart = pSda->sda_IOBuf;                  \
                                                                    \
        if (pSda->sda_IOBuf != NULL)                                \
        {                                                           \
            if (pSda->sda_Flags & SDA_SESSION_OVER_TCP)             \
            {                                                       \
                _pReplyBufStart -= DSI_HEADER_SIZE;                 \
            }                                                       \
                                                                    \
            AfpIOFreeBuffer(_pReplyBufStart);                       \
                                                                    \
            (pSda)->sda_IOBuf = NULL;                               \
            (pSda)->sda_IOSize = 0;                                 \
        }                                                           \
    }


#define	AfpFreeIOBuffer(pSda)			                            \
	if ((pSda)->sda_IOBuf != NULL)		                            \
	{									                            \
		AfpIOFreeBuffer((pSda)->sda_IOBuf);                         \
		(pSda)->sda_IOBuf = NULL;		                            \
		(pSda)->sda_IOSize = 0;			                            \
	}

// set the status on ASP
#define	AfpSpSetAspStatus(pStatusBuf, Size)                          \
	    (*(AfpAspEntries.asp_SetStatus))(AfpAspEntries.asp_AspCtxt,	 \
		    							 pStatusBuf,				 \
			    						 (USHORT)(Size));

// set the status on DSI
#define	AfpSpSetDsiStatus(pStatusBuf, Size)                          \
	    (*(AfpDsiEntries.asp_SetStatus))(AfpDsiEntries.asp_AspCtxt,	 \
		    							 pStatusBuf,				 \
			    						 (USHORT)(Size));

// set the Disable Listen on ASP only
#define	AfpSpDisableListensOnAsp()                                              \
{                                                                               \
    if (AfpServerBoundToAsp)                                                    \
    {                                                                           \
	    (*(AfpAspEntries.asp_ListenControl))(AfpAspEntries.asp_AspCtxt, False); \
    }                                                                           \
}

// set the Disable Listen on ASP as well as DSI interfaces!
#define	AfpSpDisableListens()                                                   \
{                                                                               \
    if (AfpServerBoundToAsp)                                                    \
    {                                                                           \
	    (*(AfpAspEntries.asp_ListenControl))(AfpAspEntries.asp_AspCtxt, False); \
    }                                                                           \
    if (AfpServerBoundToTcp)                                                    \
    {                                                                           \
	    (*(AfpDsiEntries.asp_ListenControl))(AfpDsiEntries.asp_AspCtxt, False); \
    }                                                                           \
}
							
// set the Enable Listen on ASP as well as DSI interfaces!
#define	AfpSpEnableListens()                                                    \
{                                                                               \
    if (AfpServerBoundToAsp)                                                    \
    {                                                                           \
	    (*(AfpAspEntries.asp_ListenControl))(AfpAspEntries.asp_AspCtxt, True);  \
    }                                                                           \
    if (AfpServerBoundToTcp)                                                    \
    {                                                                           \
	    (*(AfpDsiEntries.asp_ListenControl))(AfpDsiEntries.asp_AspCtxt, True);  \
    }                                                                           \
}
							

GLOBAL	ASP_XPORT_ENTRIES	AfpAspEntries EQU { 0 };
GLOBAL	ASP_XPORT_ENTRIES	AfpDsiEntries EQU { 0 };

#define	AFP_MAX_REQ_BUF				578

#define	afpInitializeActionHdr(p, Code)	\
		(p)->ActionHeader.TransportId = MATK;	\
		(p)->ActionHeader.ActionCode = (Code)

// This is the device handle to the stack.
extern BOOLEAN		        afpSpNameRegistered;
extern HANDLE				afpSpAddressHandle;
extern PDEVICE_OBJECT		afpSpAppleTalkDeviceObject;
extern PFILE_OBJECT		    afpSpAddressObject;
extern LONG				    afpSpNumOutstandingReplies;

LOCAL NTSTATUS FASTCALL
afpSpHandleRequest(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda,
	IN	PREQUEST			pRequest
);

LOCAL VOID FASTCALL
afpSpReplyComplete(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda,
	IN	PREQUEST	        pRequest
);

LOCAL VOID FASTCALL
afpSpCloseComplete(
	IN	NTSTATUS			Status,
	IN	PSDA				pSda
);

LOCAL NTSTATUS
afpSpGenericComplete(
	IN	PDEVICE_OBJECT		pDeviceObject,
	IN	PIRP				pIrp,
	IN	PKEVENT				pCmplEvent
);

LOCAL VOID FASTCALL
afpSpAttentionComplete(
	IN	PVOID				pContext
);

#endif	// _ATALKIO_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\cachemdl.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	cachemdl.c

Abstract:

	This module contains the routines for to get Mdl for Reads and Writes
    directly from the Cache Mgr, which helps avoid one data copy and reduces
    our non-paged memory consumption (significantly!)

Author:

	Shirish Koti


Revision History:
	June 12, 1998		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_CACHEMDL

#include <afp.h>
#include <forkio.h>
#include <gendisp.h>

VOID FASTCALL
AfpAllocWriteMdl(
    IN PDELAYEDALLOC    pDelAlloc
)
{
	PREQUEST        pRequest;
    POPENFORKENTRY  pOpenForkEntry;
    NTSTATUS        status=STATUS_SUCCESS;


    ASSERT(KeGetCurrentIrql() == LOW_LEVEL);
    ASSERT(VALID_SDA(pDelAlloc->pSda));
    ASSERT(pDelAlloc->BufSize >= CACHEMGR_WRITE_THRESHOLD);

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_WRITE_MDL);

    pRequest = pDelAlloc->pRequest;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT((VALID_OPENFORKENTRY(pOpenForkEntry)) || (pOpenForkEntry == NULL));

    // assume for now that cache mgr will fail to return the mdl
    status = STATUS_UNSUCCESSFUL;
    pRequest->rq_WriteMdl = NULL;

    if (pOpenForkEntry)
    {
        status = AfpBorrowWriteMdlFromCM(pDelAlloc, &pRequest->rq_WriteMdl);
    }

    if (status != STATUS_PENDING)
    {
        AfpAllocWriteMdlCompletion(NULL, NULL, pDelAlloc);
    }
}


NTSTATUS FASTCALL
AfpBorrowWriteMdlFromCM(
    IN  PDELAYEDALLOC   pDelAlloc,
    OUT PMDL           *ppReturnMdl
)
{

    IO_STATUS_BLOCK     IoStsBlk;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    PFAST_IO_DISPATCH   pFastIoDisp;
    LARGE_INTEGER       LargeOffset;
    BOOLEAN             fGetMdlWorked;
	PSDA	            pSda;
    POPENFORKENTRY      pOpenForkEntry;
    PFILE_OBJECT        pFileObject;



    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);

    ASSERT(pFileObject->Flags & FO_CACHE_SUPPORTED);

    ASSERT(pFastIoDisp->PrepareMdlWrite != NULL);

    LargeOffset = pDelAlloc->Offset;

    fGetMdlWorked = pFastIoDisp->PrepareMdlWrite(
                            pFileObject,
                            &LargeOffset,
                            pDelAlloc->BufSize,      // how big is the Write
                            pSda->sda_SessionId,
                            ppReturnMdl,
                            &IoStsBlk,
                            pOpenForkEntry->ofe_pDeviceObject);

    if (fGetMdlWorked && (*ppReturnMdl != NULL))
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_INFO,
	        ("AfpBorrowWriteMdlFromCM: fast path workd, Mdl = %lx\n",*ppReturnMdl));

        pDelAlloc->pMdl = *ppReturnMdl;

        return(STATUS_SUCCESS);
    }


    //
    // fast path didn't work (or worked only partially).  We must give an irp down
    // to get the (rest of the) mdl
    //

	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowWriteMdlFromCM: irp alloc failed!\n"));

        // if cache mgr returned a partial mdl, give it back!
        if (*ppReturnMdl)
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpBorrowWriteMdlFromCM: giving back partial Mdl\n"));

            pDelAlloc->pMdl = *ppReturnMdl;
            pDelAlloc->Flags |= AFP_CACHEMDL_ALLOC_ERROR;

            pDelAlloc->pRequest->rq_CacheMgrContext = NULL;

            AfpReturnWriteMdlToCM(pDelAlloc);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpAllocWriteMdlCompletion,
			pDelAlloc,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject =
                        AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_WRITE;
	pIrpSp->MinorFunction = IRP_MN_MDL;
	pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

	pIrpSp->Parameters.Write.Length = pDelAlloc->BufSize;
	pIrpSp->Parameters.Write.Key = pSda->sda_SessionId;
	pIrpSp->Parameters.Write.ByteOffset = LargeOffset;

    //
    // *ppReturnMdl could potentially be non-null if the fast-path returned
    // a partial mdl
    //
    pIrp->MdlAddress = *ppReturnMdl;

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_REQUESTED);
    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc,pIrp);

	IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

    return(STATUS_PENDING);
}



NTSTATUS
AfpAllocWriteMdlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{
	PSDA	            pSda;
	PBYTE	            pBuf;
	PREQUEST            pRequest;
    PDELAYEDALLOC       pDelAlloc;
    PMDL                pMdl=NULL;
    NTSTATUS            status=STATUS_SUCCESS;
    POPENFORKENTRY      pOpenForkEntry;


    pDelAlloc = (PDELAYEDALLOC)Context;

    pSda = pDelAlloc->pSda;
    pRequest = pDelAlloc->pRequest;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;


    ASSERT(VALID_SDA(pSda));
    ASSERT(pDelAlloc->BufSize >= CACHEMGR_WRITE_THRESHOLD);
    ASSERT((VALID_OPENFORKENTRY(pOpenForkEntry)) || (pOpenForkEntry == NULL));

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        //
        // mark the fact that this mdl belongs to the cache mgr
        //
        if (NT_SUCCESS(status))
        {
            pRequest->rq_WriteMdl = pIrp->MdlAddress;
            ASSERT(pRequest->rq_WriteMdl != NULL);

            pDelAlloc->pMdl = pRequest->rq_WriteMdl;
        }
        else
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpAllocWriteMdlCompletion: irp %lx failed %lx\n",pIrp,status));

            ASSERT(pRequest->rq_WriteMdl == NULL);
            pRequest->rq_WriteMdl = NULL;
        }

        AfpFreeIrp(pIrp);

        AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, NULL);
    }


    //
    // if we didn't get Mdl from cache mgr, fall back to the old, traditional
    // way of allocating!
    //
    if (pRequest->rq_WriteMdl == NULL)
    {
	    pBuf = AfpIOAllocBuffer(pDelAlloc->BufSize);

	    if (pBuf != NULL)
	    {
		    pMdl = AfpAllocMdl(pBuf, pDelAlloc->BufSize, NULL);
		    if (pMdl == NULL)
		    {
			    AfpIOFreeBuffer(pBuf);
		    }
	    }

        pRequest->rq_WriteMdl = pMdl;

        //
        // for whatever reason, we didn't get Mdl from cache mgr.  Undo the
        // things we had done in preparation (NOTE: if we do get the Mdl from
        // cache mgr, we leave the refcount etc. in tact until the Mdl is actually
        // returned to cache mgr)
        //

        pRequest->rq_CacheMgrContext = NULL;

        // make sure we aren't forgetting cache mgr's mdl
        ASSERT(pDelAlloc->pMdl == NULL);

        // don't need that memory no more
        AfpFreeDelAlloc(pDelAlloc);

        AfpSdaDereferenceSession(pSda);

        if (pOpenForkEntry)
        {
            AfpForkDereference(pOpenForkEntry);
        }
    }
    else
    {
        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_IN_USE);
        AFP_DBG_INC_DELALLOC_BYTECOUNT(AfpWriteCMAlloced, pDelAlloc->BufSize);
    }

    //
    // tell the transport below to continue with the write
    //
    (*(pSda->sda_XportTable->asp_WriteContinue))(pRequest);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}




VOID FASTCALL
AfpReturnWriteMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PFAST_IO_DISPATCH   pFastIoDisp;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    LARGE_INTEGER       LargeOffset;
	PFILE_OBJECT        pFileObject;
    PSDA                pSda;
    POPENFORKENTRY      pOpenForkEntry;
    PMDL                pMdl;
    PVOID               Context;


    ASSERT(pDelAlloc != NULL);
    ASSERT(pDelAlloc->pMdl != NULL);

    //
    // are we at DPC? if so, can't do this now
    //
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_QUEUED);

        AfpInitializeWorkItem(&pDelAlloc->WorkItem,
                              AfpReturnWriteMdlToCM,
                              pDelAlloc);

        AfpQueueWorkItem(&pDelAlloc->WorkItem);
        return;
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_IN_PROGRESS);

    pSda = pDelAlloc->pSda;
    pMdl = pDelAlloc->pMdl;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
    pDeviceObject = pOpenForkEntry->ofe_pDeviceObject;

    LargeOffset = pDelAlloc->Offset;

    pFastIoDisp = pDeviceObject->DriverObject->FastIoDispatch;

    Context = pDelAlloc;

    //
    // if we came here because the cache mdl alloc failed but had partially
    // succeeded, then we don't want the completion routine to free up things
    // prematurely: in this case, pass NULL context
    //
    if (pDelAlloc->Flags & AFP_CACHEMDL_ALLOC_ERROR)
    {
        Context = NULL;
    }

    if (pFastIoDisp->MdlWriteComplete)
    {
        if (pFastIoDisp->MdlWriteComplete(
                pFileObject,
                &LargeOffset,
                pMdl,
                pDeviceObject) == TRUE)
        {
            AfpReturnWriteMdlToCMCompletion(NULL, NULL, Context);
            return;
        }
    }


	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpReturnWriteMdlToCM: irp alloc failed!\n"));

        // log an event here - that's all we can do here!
        AFPLOG_ERROR(AFPSRVMSG_ALLOC_IRP, STATUS_INSUFFICIENT_RESOURCES,
						                     NULL, 0, NULL);
    
		AfpReturnWriteMdlToCMCompletion(NULL, NULL, Context);

        ASSERT(0);
        return;
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpReturnWriteMdlToCMCompletion,
			Context,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_WRITE;
	pIrpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
	pIrpSp->FileObject = AfpGetRealFileObject(pFileObject);
	pIrpSp->DeviceObject = pDeviceObject;

	pIrpSp->Parameters.Write.Length = pDelAlloc->BufSize;

	pIrpSp->Parameters.Write.ByteOffset = LargeOffset;

    pIrp->MdlAddress = pMdl;

    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, pIrp);
    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_IN_PROGRESS);

	IoCallDriver(pDeviceObject, pIrp);

}


NTSTATUS
AfpReturnWriteMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{
    PSDA            pSda;
    PDELAYEDALLOC   pDelAlloc;
    POPENFORKENTRY  pOpenForkEntry;
    NTSTATUS        status;
    AFPSTATUS       AfpStatus=AFP_ERR_NONE;

	struct _ResponsePacket
	{
		BYTE	__RealOffset[4];
	};


    pDelAlloc = (PDELAYEDALLOC)Context;

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        //
        // mark the fact that this mdl belongs to the cache mgr
        //
        if (NT_SUCCESS(status))
        {

            AfpStatus = AFP_ERR_NONE;
        }
        else
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpReturnWriteMdlToCMCompletion: irp failed %lx\n",status));

            ASSERT(0);
            AfpStatus = AFP_ERR_MISC;
        }

        AfpFreeIrp(pIrp);
    }

    //
    // if pDelAlloc is NULL, then some error occured while borrowing CM's mdl.  We
    // We already finished up with the API at the time of the failure, so done here
    //
    if (pDelAlloc == NULL)
    {
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }


    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

	if (AfpStatus == AFP_ERR_NONE)
	{
	    pSda->sda_ReplySize = SIZE_RESPPKT;
	    if ((AfpStatus = AfpAllocReplyBuf(pSda)) == AFP_ERR_NONE)
	    {
		    PUTDWORD2DWORD(pRspPkt->__RealOffset,
                           (pDelAlloc->Offset.LowPart + pDelAlloc->BufSize));
	    }
	}
    else
    {
        pSda->sda_ReplySize = 0;
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_COMPLETED);
    AFP_DBG_DEC_DELALLOC_BYTECOUNT(AfpWriteCMAlloced, pDelAlloc->BufSize);

    //
    // call the completion routine only if everything is ok (we don't want
    // to call completion if session went dead)
    //
    if (!(pDelAlloc->Flags & AFP_CACHEMDL_DEADSESSION))
    {
        AfpCompleteApiProcessing(pSda, AfpStatus);
    }

    // remove the refcount when we referenced this
    AfpForkDereference(pOpenForkEntry);

    // remove the DelAlloc refcount
    AfpSdaDereferenceSession(pSda);

    // don't need that memory no more
    AfpFreeDelAlloc(pDelAlloc);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}



NTSTATUS FASTCALL
AfpBorrowReadMdlFromCM(
    IN PSDA             pSda
)
{

    IO_STATUS_BLOCK     IoStsBlk;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    PFAST_IO_DISPATCH   pFastIoDisp;
    PMDL                pReturnMdl=NULL;
    KIRQL               OldIrql;
    PREQUEST            pRequest;
    PDELAYEDALLOC       pDelAlloc;
    POPENFORKENTRY      pOpenForkEntry;
    PFILE_OBJECT        pFileObject;
    LARGE_INTEGER       Offset;
    LARGE_INTEGER       ReadSize;
    BOOLEAN             fGetMdlWorked;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};


    ASSERT(VALID_SDA(pSda));

	Offset.QuadPart = pReqPkt->_Offset;
	ReadSize.QuadPart = pReqPkt->_Size;

    pOpenForkEntry = pReqPkt->_pOpenForkEntry;

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);

    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFastIoDisp = pOpenForkEntry->ofe_pDeviceObject->DriverObject->FastIoDispatch;

    if (!(pFileObject->Flags & FO_CACHE_SUPPORTED))
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: FO_CACHE_SUPPORTED not set\n"));

        return(STATUS_UNSUCCESSFUL);
    }

    if (pFastIoDisp->MdlRead == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: PrepareMdl is NULL\n"));

        return(STATUS_UNSUCCESSFUL);
    }

    pDelAlloc = AfpAllocDelAlloc();

    if (pDelAlloc == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: malloc for pDelAlloc failed\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_READ_MDL);

    // put DelAlloc refcount on pSda
    if (AfpSdaReferenceSessionByPointer(pSda) == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: couldn't reference pSda %lx\n",pSda));

        AfpFreeDelAlloc(pDelAlloc);
        return(STATUS_UNSUCCESSFUL);
    }

    // put DelAlloc refcount on pOpenForkEntry
    if (AfpForkReferenceByPointer(pOpenForkEntry) == NULL)
    {
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: couldn't reference %lx\n",pOpenForkEntry));

        // remove DelAlloc refcount
        AfpSdaDereferenceSession(pSda);
        AfpFreeDelAlloc(pDelAlloc);
        return(STATUS_UNSUCCESSFUL);
    }

    pRequest = pSda->sda_Request;

    ASSERT(pRequest->rq_ReplyMdl == NULL);

    pRequest->rq_CacheMgrContext = pDelAlloc;

    pDelAlloc->pSda = pSda;
    pDelAlloc->pRequest = pRequest;
    pDelAlloc->pOpenForkEntry = pOpenForkEntry;
    pDelAlloc->Offset = Offset;
    pDelAlloc->BufSize = ReadSize.LowPart;

    fGetMdlWorked = pFastIoDisp->MdlRead(
                            pFileObject,
                            &Offset,
                            ReadSize.LowPart,
                            pSda->sda_SessionId,
                            &pReturnMdl,
                            &IoStsBlk,
                            pOpenForkEntry->ofe_pDeviceObject);

    if (fGetMdlWorked && (pReturnMdl != NULL))
    {
        pDelAlloc->pMdl = pReturnMdl;

        // call the completion routine, so the read can complete
        AfpBorrowReadMdlFromCMCompletion(NULL, NULL, pDelAlloc);

        return(STATUS_PENDING);
    }


    //
    // fast path didn't work (or worked only partially).  We must give an irp down
    // to get the (rest of the) mdl
    //

	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pOpenForkEntry->ofe_pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpBorrowReadMdlFromCM: irp alloc failed!\n"));

        // if cache mgr returned a partial mdl, give it back!
        if (pReturnMdl)
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpBorrowReadMdlFromCM: giving back partial Mdl\n"));

            pDelAlloc->pMdl = pReturnMdl;
            pRequest->rq_CacheMgrContext = NULL;

            AfpReturnReadMdlToCM(pDelAlloc);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpBorrowReadMdlFromCMCompletion,
			pDelAlloc,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject =
                        AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_READ;
	pIrpSp->MinorFunction = IRP_MN_MDL;
	pIrpSp->FileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject);
	pIrpSp->DeviceObject = pOpenForkEntry->ofe_pDeviceObject;

	pIrpSp->Parameters.Write.Length = ReadSize.LowPart;
	pIrpSp->Parameters.Write.Key = pSda->sda_SessionId;
	pIrpSp->Parameters.Write.ByteOffset = Offset;

    //
    // pReturnMdl could potentially be non-null if the fast-path returned
    // a partial mdl
    //
    pIrp->MdlAddress = pReturnMdl;

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_REQUESTED);
    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc,pIrp);

	IoCallDriver(pOpenForkEntry->ofe_pDeviceObject, pIrp);

    return(STATUS_PENDING);
}


NTSTATUS
AfpBorrowReadMdlFromCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{

	PSDA	            pSda;
	PREQUEST            pRequest;
    PDELAYEDALLOC       pDelAlloc;
    PMDL                pMdl=NULL;
    NTSTATUS            status=STATUS_SUCCESS;
    AFPSTATUS           AfpStatus=AFP_ERR_NONE;
    PMDL                pCurrMdl;
    DWORD               CurrMdlSize;
    POPENFORKENTRY      pOpenForkEntry;
    PBYTE               pBuf;
    LONG                iLoc;
    LONG                i, Size;
	struct _RequestPacket
	{
		POPENFORKENTRY	_pOpenForkEntry;
		LONG			_Offset;
		LONG			_Size;
		DWORD			_NlMask;
		DWORD			_NlChar;
	};


    pDelAlloc = (PDELAYEDALLOC)Context;

    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;
    pRequest = pDelAlloc->pRequest;

    ASSERT(VALID_SDA(pSda));
    ASSERT(pDelAlloc->BufSize >= CACHEMGR_READ_THRESHOLD);
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));


    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        //
        // mark the fact that this mdl belongs to the cache mgr
        //
        if (NT_SUCCESS(status))
        {
            pDelAlloc->pMdl = pIrp->MdlAddress;

            ASSERT(pDelAlloc->pMdl != NULL);
        }
        else
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_WARN,
	            ("AfpBorrowReadMdlFromCMCompletion: irp %lx failed %lx\n",pIrp,status));

            ASSERT(pDelAlloc->pMdl == NULL);
            pDelAlloc->pMdl = NULL;

            AfpStatus = AFP_ERR_MISC;
        }

        AfpFreeIrp(pIrp);

        AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, NULL);
    }

    pRequest->rq_ReplyMdl = pDelAlloc->pMdl;

    // did we get Mdl from the cache mgr?  If so, we need to compute the reply size
    if (pRequest->rq_ReplyMdl != NULL)
    {
        Size = AfpMdlChainSize(pRequest->rq_ReplyMdl);

        if (Size == 0)
        {
            AfpStatus = AFP_ERR_EOF;
        }
		else if (pReqPkt->_NlMask != 0)
		{
            AfpStatus = AFP_ERR_NONE;

            pCurrMdl = pRequest->rq_ReplyMdl;

            CurrMdlSize = MmGetMdlByteCount(pCurrMdl);
            pBuf = MmGetSystemAddressForMdlSafe(
					pCurrMdl,
					NormalPagePriority);

			if (pBuf == NULL) {
				AfpStatus = AFP_ERR_MISC;
				goto error_end;
			}

			for (i=0, iLoc=0; i < Size; iLoc++, i++, pBuf++)
			{
                // move to the next Mdl if we exhausted this one
                if (iLoc >= (LONG)CurrMdlSize)
                {
                    ASSERT(i < Size);

                    pCurrMdl = pCurrMdl->Next;
                    ASSERT(pCurrMdl != NULL);

                    CurrMdlSize = MmGetMdlByteCount(pCurrMdl);
                    pBuf = MmGetSystemAddressForMdlSafe(
							pCurrMdl,
							NormalPagePriority);
					if (pBuf == NULL) {
						AfpStatus = AFP_ERR_MISC;
						goto error_end;
					}

                    iLoc = 0;
                }

			    if ((*pBuf & (BYTE)(pReqPkt->_NlMask)) == (BYTE)(pReqPkt->_NlChar))
				{
					Size = ++i;
					break;
				}
			}
		}

		pSda->sda_ReplySize = (USHORT)Size;

        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_IN_USE);
        AFP_DBG_INC_DELALLOC_BYTECOUNT(AfpReadCMAlloced, pDelAlloc->BufSize);
    }

    //
    // we didn't get Mdl from cache mgr, fall back to the old, traditional
    // way of allocating and reading the file
    //
    else
    {
        // make sure we aren't forgetting cache mgr's mdl
        ASSERT(pDelAlloc->pMdl == NULL);

        pRequest->rq_CacheMgrContext = NULL;

        AfpForkDereference(pOpenForkEntry);

        AfpSdaDereferenceSession(pSda);

        // don't need that memory no more
        AfpFreeDelAlloc(pDelAlloc);

        AfpStatus = AfpFspDispReadContinue(pSda);
    }

error_end:
    if (AfpStatus != AFP_ERR_EXTENDED)
    {
        AfpCompleteApiProcessing(pSda, AfpStatus);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);

}


VOID FASTCALL
AfpReturnReadMdlToCM(
    IN  PDELAYEDALLOC   pDelAlloc
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PFAST_IO_DISPATCH   pFastIoDisp;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    LARGE_INTEGER       LargeOffset;
    DWORD               ReadSize;
	PFILE_OBJECT        pFileObject;
    PSDA                pSda;
    PMDL                pMdl;
    POPENFORKENTRY      pOpenForkEntry;


    ASSERT(pDelAlloc != NULL);
    ASSERT(pDelAlloc->pMdl != NULL);


    //
    // are we at DPC? if so, can't do this now
    //
    if (KeGetCurrentIrql() == DISPATCH_LEVEL)
    {
        AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_QUEUED);

        AfpInitializeWorkItem(&pDelAlloc->WorkItem,
                              AfpReturnReadMdlToCM,
                              pDelAlloc);
        AfpQueueWorkItem(&pDelAlloc->WorkItem);
        return;
    }

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_PROC_IN_PROGRESS);

    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    pMdl = pDelAlloc->pMdl;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    pFileObject = AfpGetRealFileObject(pOpenForkEntry->ofe_pFileObject),
    pDeviceObject = pOpenForkEntry->ofe_pDeviceObject;

    LargeOffset = pDelAlloc->Offset;
    ReadSize = pDelAlloc->BufSize;

    pFastIoDisp = pDeviceObject->DriverObject->FastIoDispatch;

    //
    // try the fast path to return the Mdl to cache mgr
    //
    if (pFastIoDisp->MdlReadComplete)
    {
        if (pFastIoDisp->MdlReadComplete(pFileObject,pMdl,pDeviceObject) == TRUE)
        {
            AfpReturnReadMdlToCMCompletion(NULL, NULL, pDelAlloc);
            return;
        }
    }

    //
    // hmmm: fast path didn't work, got to post an irp!
    //

	// Allocate and initialize the IRP for this operation.
	pIrp = AfpAllocIrp(pDeviceObject->StackSize);

    // yikes, how messy can it get!
	if (pIrp == NULL)
	{
	    DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	        ("AfpReturnReadMdlToCM: irp alloc failed!\n"));

        // log an event here - that's all we can do here!
        AFPLOG_ERROR(AFPSRVMSG_ALLOC_IRP, STATUS_INSUFFICIENT_RESOURCES,
						                     NULL, 0, NULL);

		AfpReturnReadMdlToCMCompletion(NULL, NULL, pDelAlloc);

    	ASSERT(0);
        return;
	}

	// Set up the completion routine.
	IoSetCompletionRoutine(
            pIrp,
			(PIO_COMPLETION_ROUTINE)AfpReturnReadMdlToCMCompletion,
			pDelAlloc,
			True,
			True,
			True);

	pIrpSp = IoGetNextIrpStackLocation(pIrp);

	pIrp->Tail.Overlay.OriginalFileObject = AfpGetRealFileObject(pFileObject);
	pIrp->Tail.Overlay.Thread = AfpThread;
	pIrp->RequestorMode = KernelMode;

    pIrp->Flags = IRP_SYNCHRONOUS_API;

	pIrpSp->MajorFunction = IRP_MJ_READ;
	pIrpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
	pIrpSp->FileObject = AfpGetRealFileObject(pFileObject);
	pIrpSp->DeviceObject = pDeviceObject;

    pIrpSp->Parameters.Read.ByteOffset = LargeOffset;
    pIrpSp->Parameters.Read.Length = ReadSize;

    pIrp->MdlAddress = pMdl;

    AFP_DBG_SET_DELALLOC_IRP(pDelAlloc, pIrp);
    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_IN_PROGRESS);

	IoCallDriver(pDeviceObject, pIrp);

}



NTSTATUS
AfpReturnReadMdlToCMCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
)
{
    PDELAYEDALLOC       pDelAlloc;
    PSDA                pSda;
    POPENFORKENTRY      pOpenForkEntry;
    NTSTATUS            status;


    pDelAlloc = (PDELAYEDALLOC)Context;

    ASSERT(pDelAlloc != NULL);

    pSda = pDelAlloc->pSda;
    pOpenForkEntry = pDelAlloc->pOpenForkEntry;

    ASSERT(VALID_SDA(pSda));
    ASSERT(VALID_OPENFORKENTRY(pOpenForkEntry));

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        if (!NT_SUCCESS(status))
        {
	        DBGPRINT(DBG_COMP_AFPAPI, DBG_LEVEL_ERR,
	            ("AfpReturnReadMdlToCMCompletion: irp failed %lx\n",status));

            ASSERT(0);
        }

        AfpFreeIrp(pIrp);
    }

    AfpForkDereference(pOpenForkEntry);

    AfpSdaDereferenceSession(pSda);

    AFP_DBG_SET_DELALLOC_STATE(pDelAlloc, AFP_DBG_MDL_RETURN_COMPLETED);
    AFP_DBG_DEC_DELALLOC_BYTECOUNT(AfpReadCMAlloced, pDelAlloc->BufSize);

    // don't need that memory no more
    AfpFreeDelAlloc(pDelAlloc);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}


PDELAYEDALLOC FASTCALL
AfpAllocDelAlloc(
    IN VOID
)
{
    PDELAYEDALLOC   pDelAlloc;
    KIRQL           OldIrql;

    pDelAlloc = (PDELAYEDALLOC) AfpAllocZeroedNonPagedMemory(sizeof(DELAYEDALLOC));

#if DBG
    if (pDelAlloc)
    {
        pDelAlloc->Signature = AFP_DELALLOC_SIGNATURE;
        pDelAlloc->State = AFP_DBG_MDL_INIT;

        ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &OldIrql);
        InsertTailList(&AfpDebugDelAllocHead, &pDelAlloc->Linkage);
        RELEASE_SPIN_LOCK(&AfpDebugSpinLock, OldIrql);
    }
#endif

    return(pDelAlloc);
}


VOID FASTCALL
AfpFreeDelAlloc(
    IN PDELAYEDALLOC    pDelAlloc
)
{
    KIRQL   OldIrql;

#if DBG

    ASSERT(pDelAlloc->Signature == AFP_DELALLOC_SIGNATURE);

    pDelAlloc->State |= AFP_DBG_MDL_END;

    ACQUIRE_SPIN_LOCK(&AfpDebugSpinLock, &OldIrql);
    RemoveEntryList(&pDelAlloc->Linkage);

    pDelAlloc->Linkage.Flink = (PLIST_ENTRY)0x11111111;
    pDelAlloc->Linkage.Blink = (PLIST_ENTRY)0x33333333;
    RELEASE_SPIN_LOCK(&AfpDebugSpinLock, OldIrql);
#endif

    AfpFreeMemory(pDelAlloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\chgntfy.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	chgntfy.c

Abstract:

	This module contains the code for processing change notifies.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	15 Jun 1995 JameelH	Seperated the change notify code from idindex.c

Notes:		Tab stop: 4

--*/

#define IDINDEX_LOCALS
#define	FILENUM	FILE_CHGNTFY

#include <afp.h>
#include <scavengr.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <access.h>	// for AfpWorldId

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, afpVerifyDFE)
#pragma alloc_text(PAGE, afpAddDfEntryAndCacheInfo)
#pragma alloc_text(PAGE, afpReadIdDb)
#pragma alloc_text(PAGE, AfpProcessChangeNotify)
#pragma alloc_text(PAGE, afpProcessPrivateNotify)
#pragma alloc_text(PAGE, AfpQueuePrivateChangeNotify)
#pragma alloc_text(PAGE, AfpCacheDirectoryTree)
#pragma alloc_text(PAGE, AfpQueueOurChange)
#endif

/***	afpVerifyDFE
 *
 *	Check if our view of this item in our data-base matches whats on disk. If not
 *  update our view with whats on disk.
 */
VOID
afpVerifyDFE(
	IN	struct _VolDesc *			pVolDesc,
	IN	PDFENTRY					pDfeParent,
	IN	PUNICODE_STRING				pUName,			// munged unicode name
	IN	PFILESYSHANDLE				pfshParentDir,	// open handle to parent directory
	IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath,	// to filter out our own AFP_AfpInfo change notifies
	IN	PDFENTRY	*				ppDfEntry
)
{
	PDFENTRY	pDfEntry = *ppDfEntry;

	if (pFBDInfo->LastWriteTime.QuadPart > pDfEntry->dfe_LastModTime.QuadPart)
	{
		FILESYSHANDLE	fshAfpInfo, fshData;
		AFPINFO			AfpInfo;
        DWORD			crinfo, openoptions = 0;
		BOOLEAN			SeenComment, WriteBackROAttr = False;
        PSTREAM_INFO	pStreams = NULL, pCurStream;
		NTSTATUS		Status = STATUS_SUCCESS;
		BOOLEAN			IsDir;

		// Our view is stale, update it
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpVerifyDFE: Updating stale database with fresh info\n\t%Z\n", pNotifyPath));

		IsDir = (pFBDInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? True : False;

		ASSERT (IS_VOLUME_NTFS(pVolDesc));

		ASSERT (!(DFE_IS_DIRECTORY(pDfEntry) ^ IsDir));

		// Update DFE from FBDInfo first
		pDfEntry->dfe_CreateTime = AfpConvertTimeToMacFormat(&pFBDInfo->CreationTime);
		pDfEntry->dfe_LastModTime = pFBDInfo->LastWriteTime;
		pDfEntry->dfe_NtAttr = (USHORT)(pFBDInfo->FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS);
		if (!IsDir)
		{
			pDfEntry->dfe_DataLen = pFBDInfo->EndOfFile.LowPart;
		}

		// Open/Create the AfpInfo stream
		fshAfpInfo.fsh_FileHandle = NULL;
		fshData.fsh_FileHandle	= NULL;

		do
		{
			// open or create the AfpInfo stream
			if (!NT_SUCCESS(AfpCreateAfpInfoWithNodeName(pfshParentDir,
														 pUName,
														 pNotifyPath,
														 pVolDesc,
														 &fshAfpInfo,
														 &crinfo)))
			{
				if (!(pFBDInfo->FileAttributes & FILE_ATTRIBUTE_READONLY))
				{
					// What other reason is there that we could not open
					// this stream except that this file/dir is readonly?
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				openoptions = IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE;
				Status = STATUS_UNSUCCESSFUL;	// Assume failure
				if (NT_SUCCESS(AfpIoOpen(pfshParentDir,
										 AFP_STREAM_DATA,
										 openoptions,
										 pUName,
										 FILEIO_ACCESS_NONE,
										 FILEIO_DENY_NONE,
										 False,
										 &fshData)))
				{
					if (NT_SUCCESS(AfpExamineAndClearROAttr(&fshData,
															&WriteBackROAttr,
															pVolDesc,
															pNotifyPath)))
					{
						if (NT_SUCCESS(AfpCreateAfpInfo(&fshData,
														&fshAfpInfo,
														&crinfo)))
						{
							Status = STATUS_SUCCESS;
						}
					}
				}

				if (!NT_SUCCESS(Status))
				{
					// Skip this entry if you cannot get to the AfpInfo, cannot
					// clear the RO attribute or whatever.
					break;
				}
			}

			// We successfully opened or created the AfpInfo stream.  If
			// it existed, then validate the ID, otherwise create all new
			// Afpinfo for this file/dir.
			if ((crinfo == FILE_OPENED) &&
				(NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &AfpInfo))))
			{
				BOOLEAN	fSuccess;

				if ((AfpInfo.afpi_Id != pDfEntry->dfe_AfpId) &&
					(pDfEntry->dfe_AfpId != AFP_ID_ROOT))
				{
					PDFENTRY	pDFE;

					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpVerifyDFE: IdDb Id does not match the AfpInfo Id!!!\n"));

					// Unlink it from the hash-bucket since we have the wrong id.
					AfpUnlinkDouble(pDfEntry, dfe_NextOverflow, dfe_PrevOverflow);

					// If some other entity has this id, then assign a new one. Else
					// use the one from the AfpInfo stream.
					pDFE = AfpFindDfEntryById(pVolDesc, AfpInfo.afpi_Id, DFE_ANY);
					if (pDFE != NULL)
					{
						pDfEntry->dfe_AfpId = afpGetNextId(pVolDesc);
					}
					else
					{
						pDfEntry->dfe_AfpId = AfpInfo.afpi_Id;
					}

					// Re-insert it with the new id
                    afpInsertDFEInHashBucket(pVolDesc, pDfEntry, IsDir, &fSuccess);
				}

				// NOTE: should we set the finder invisible bit if the
				// hidden attribute is set so system 6 will obey the
				// hiddenness in finder?
				pDfEntry->dfe_FinderInfo = AfpInfo.afpi_FinderInfo;
				pDfEntry->dfe_BackupTime = AfpInfo.afpi_BackupTime;
				pDfEntry->dfe_AfpAttr = AfpInfo.afpi_Attributes;
			}
			else
			{
				// AfpInfo stream was newly created, or we could not read
				// the existing one because it was corrupt.  Create new
				// info for this file/dir. Trust the version from the IdDb
				AfpInitAfpInfo(&AfpInfo, pDfEntry->dfe_AfpId, IsDir, pDfEntry->dfe_BackupTime);
				AfpInfo.afpi_FinderInfo = pDfEntry->dfe_FinderInfo;
				AfpInfo.afpi_Attributes = pDfEntry->dfe_AfpAttr;
				if (IsDir)
				{
					// Keep track of see files vs. see folders
					AfpInfo.afpi_AccessOwner = DFE_OWNER_ACCESS(pDfEntry);
					AfpInfo.afpi_AccessGroup = DFE_GROUP_ACCESS(pDfEntry);
					AfpInfo.afpi_AccessWorld = DFE_WORLD_ACCESS(pDfEntry);
				}
				else
				{
					AfpProDosInfoFromFinderInfo(&AfpInfo.afpi_FinderInfo,
												&AfpInfo.afpi_ProDosInfo);
					pDfEntry->dfe_RescLen = 0;	// Assume no resource fork

					// if this is a Mac application, make sure there is an APPL
					// mapping for it.
					if (AfpInfo.afpi_FinderInfo.fd_TypeD == *(PDWORD)"APPL")
					{
						AfpAddAppl(pVolDesc,
								   pDfEntry->dfe_FinderInfo.fd_CreatorD,
								   0,
								   pDfEntry->dfe_AfpId,
								   True,
								   pDfEntry->dfe_Parent->dfe_AfpId);
					}
				}

				Status = AfpWriteAfpInfo(&fshAfpInfo, &AfpInfo);
				if (!NT_SUCCESS(Status))
				{
					// We failed to write the AfpInfo stream;
					Status = STATUS_UNSUCCESSFUL;
					break;
				}
			}

			// Check for comment and resource stream
			pStreams = AfpIoQueryStreams(&fshAfpInfo);
			if (pStreams == NULL)
			{
				Status = STATUS_NO_MEMORY;
				break;
			}

			for (pCurStream = pStreams, SeenComment = False;
				 pCurStream->si_StreamName.Buffer != NULL;
				 pCurStream++)
			{
				if (IS_COMMENT_STREAM(&pCurStream->si_StreamName))
				{
					DFE_SET_COMMENT(pDfEntry);
					SeenComment = True;
					if (IsDir)
						break;	// Scan no further for directories
				}
				else if (!IsDir && IS_RESOURCE_STREAM(&pCurStream->si_StreamName))
				{
					pDfEntry->dfe_RescLen = pCurStream->si_StreamSize.LowPart;
					if (SeenComment)
						break;	// We have all we need to
				}
			}

		} while (False);

		if (fshData.fsh_FileHandle != NULL)
		{
			AfpPutBackROAttr(&fshData, WriteBackROAttr);
			AfpIoClose(&fshData);
		}

		if (fshAfpInfo.fsh_FileHandle != NULL)
			AfpIoClose(&fshAfpInfo);

		if (pStreams != NULL)
			AfpFreeMemory(pStreams);

		if (!NT_SUCCESS(Status))
		{
			*ppDfEntry = NULL;
		}
		else
		{
			// If this is the root directory, make sure we do not blow away the
			// AFP_VOLUME_HAS_CUSTOM_ICON bit for NTFS Volume.
			if (DFE_IS_ROOT(pDfEntry) &&
				(pVolDesc->vds_Flags & AFP_VOLUME_HAS_CUSTOM_ICON))
			{
				// Don't bother writing back to disk since we do not
				// try to keep this in sync in the permanent afpinfo
				// stream with the actual existence of the icon<0d> file.
				pDfEntry->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_HAS_CUSTOM_ICON;
			}
		}
	}
}


/***	afpAddDfEntryAndCacheInfo
 *
 *	During the initial sync with disk on volume startup, add each entry
 *  we see during enumerate to the id index database.
 */
VOID
afpAddDfEntryAndCacheInfo(
	IN	PVOLDESC					pVolDesc,
	IN	PDFENTRY					pParentDfe,
	IN	PUNICODE_STRING 			pUName,			// munged unicode name
	IN  PFILESYSHANDLE				pfshEnumDir,	// open handle to parent directory
    IN	PFILE_BOTH_DIR_INFORMATION	pFBDInfo,		// from enumerate
	IN	PUNICODE_STRING				pNotifyPath, 	// For Afpinfo Stream
	IN	PDFENTRY	*				ppDfEntry,
	IN	BOOLEAN						CheckDuplicate
)
{
	BOOLEAN			IsDir, SeenComment, WriteBackROAttr = False;
	NTSTATUS		Status = STATUS_SUCCESS;
	FILESYSHANDLE		fshAfpInfo, fshData;
	DWORD			crinfo, openoptions = 0;
	PDFENTRY		pDfEntry;
	AFPINFO			AfpInfo;
	FINDERINFO		FinderInfo;
	PSTREAM_INFO	pStreams = NULL, pCurStream;
    UNICODE_STRING  EmptyString;
    DWORD           NTAttr = 0;
    TIME            ModTime;
    DWORD           ModMacTime;


	PAGED_CODE();

	fshAfpInfo.fsh_FileHandle = NULL;
	fshData.fsh_FileHandle	= NULL;

	IsDir = (pFBDInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? True : False;

	do
	{
		if (IS_VOLUME_NTFS(pVolDesc))
		{
			if (IsDir || CheckDuplicate)
			{
				// Make sure we don't already have this item in our database.
				// Multiple notifies for the same item could possibly occur if
				// the PC is renaming or moving items around on the disk, or
				// copying trees while we are trying to cache it, since we are
				// also queueing up private notifies for directories.

				afpFindDFEByUnicodeNameInSiblingList_CS(pVolDesc,
														pParentDfe,
														pUName,
														&pDfEntry,
														IsDir ? DFE_DIR : DFE_FILE);
				if (pDfEntry != NULL)
				{
					Status = AFP_ERR_OBJECT_EXISTS;
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
						("afpAddDfEntryAndCacheInfo: Attempt to add a duplicate entry: %Z\n", pUName));
					break;
				}
			}

			openoptions = IsDir ? FILEIO_OPEN_DIR : FILEIO_OPEN_FILE;
			if (NT_SUCCESS(AfpIoOpen(pfshEnumDir,
									 AFP_STREAM_DATA,
									 openoptions,
									 pUName,
									 FILEIO_ACCESS_NONE,
									 FILEIO_DENY_NONE,
									 False,
									 &fshData)))
			{
                // save the LastModify time on the data stream of the file: we need to restore it
                AfpIoQueryTimesnAttr(&fshData,
                                     NULL,
                                     &ModTime,
                                     &NTAttr);

                ModMacTime = AfpConvertTimeToMacFormat(&ModTime);
            }
            else
            {
                // if we can't open the data file, just skip this entry!
                Status = STATUS_UNSUCCESSFUL;
	            DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
	                ("Couldn't open data stream for %Z\n", pUName));
                break;
            }


            AfpSetEmptyUnicodeString(&EmptyString, 0, NULL);

			// open or create the AfpInfo stream
			if (!NT_SUCCESS(AfpCreateAfpInfoWithNodeName(&fshData,
														 &EmptyString,
														 pNotifyPath,
														 pVolDesc,
														 &fshAfpInfo,
														 &crinfo)))
			{
				if (!(pFBDInfo->FileAttributes & FILE_ATTRIBUTE_READONLY))
				{
					// What other reason is there that we could not open
					// this stream except that this file/dir is readonly?
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				Status = STATUS_UNSUCCESSFUL;	// Assume failure
				if (NT_SUCCESS(AfpExamineAndClearROAttr(&fshData,
														&WriteBackROAttr,
														pVolDesc,
														pNotifyPath)))
				{
					if (NT_SUCCESS(AfpCreateAfpInfo(&fshData,
													&fshAfpInfo,
													&crinfo)))
					{
						Status = STATUS_SUCCESS;
					}
				}

				if (!NT_SUCCESS(Status))
				{
					// Skip this entry if you cannot get to the AfpInfo, cannot
					// clear the RO attribute or whatever.
					break;
				}
			}

			// We successfully opened or created the AfpInfo stream.  If
			// it existed, then validate the ID, otherwise create all new
			// Afpinfo for this file/dir.
			if ((crinfo == FILE_OPENED) &&
				(NT_SUCCESS(AfpReadAfpInfo(&fshAfpInfo, &AfpInfo))))
			{
				// the file/dir had an AfpInfo stream on it
				afpCheckDfEntry(pVolDesc,
								AfpInfo.afpi_Id,
								pUName,
								IsDir,
								pParentDfe,
								&pDfEntry);

				if (pDfEntry == NULL)
				{
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				if (pDfEntry->dfe_AfpId != AfpInfo.afpi_Id)
				{
					// Write out the AFP_AfpInfo with the new AfpId
					// and uninitialized icon coordinates
					AfpInfo.afpi_Id = pDfEntry->dfe_AfpId;
					AfpInfo.afpi_FinderInfo.fd_Location[0] =
					AfpInfo.afpi_FinderInfo.fd_Location[1] =
					AfpInfo.afpi_FinderInfo.fd_Location[2] =
					AfpInfo.afpi_FinderInfo.fd_Location[3] = 0xFF;
					AfpInfo.afpi_FinderInfo.fd_Attr1 &= ~FINDER_FLAG_SET;

					if (!NT_SUCCESS(AfpWriteAfpInfo(&fshAfpInfo, &AfpInfo)))
					{
						// We failed to write the AfpInfo stream;
						// delete the thing from the database
						AfpDeleteDfEntry(pVolDesc, pDfEntry);
						Status = STATUS_UNSUCCESSFUL;
						break;
					}
				}

				// NOTE: should we set the finder invisible bit if the
				// hidden attribute is set so system 6 will obey the
				// hiddenness in finder?
				pDfEntry->dfe_FinderInfo = AfpInfo.afpi_FinderInfo;
				pDfEntry->dfe_BackupTime = AfpInfo.afpi_BackupTime;
				pDfEntry->dfe_AfpAttr = AfpInfo.afpi_Attributes;
			}
			else
			{
				// AfpInfo stream was newly created, or we could not read
				// the existing one because it was corrupt.  Create new
				// info for this file/dir
				pDfEntry = AfpAddDfEntry(pVolDesc,
										pParentDfe,
										pUName,
										IsDir,
										0);
				if (pDfEntry == NULL)
				{
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				if (NT_SUCCESS(AfpSlapOnAfpInfoStream(pVolDesc,
													  pNotifyPath,
													  NULL,
													  &fshAfpInfo,
													  pDfEntry->dfe_AfpId,
													  IsDir,
													  pUName,
													  &AfpInfo)))
				{
					// NOTE: should we set the finder invisible bit if the
					// hidden attribute is set so system 6 will obey the
					// hiddenness in finder?
					pDfEntry->dfe_FinderInfo = AfpInfo.afpi_FinderInfo;
					pDfEntry->dfe_BackupTime = AfpInfo.afpi_BackupTime;
					pDfEntry->dfe_AfpAttr = AfpInfo.afpi_Attributes;
				}
				else
				{
					// We failed to write the AfpInfo stream;
					// delete the thing from the database
					AfpDeleteDfEntry(pVolDesc, pDfEntry);
					Status = STATUS_UNSUCCESSFUL;
					break;
				}
			}

			ASSERT(pDfEntry != NULL);

			if (IsDir)
			{
				// Keep track of see files vs. see folders
				DFE_OWNER_ACCESS(pDfEntry) = AfpInfo.afpi_AccessOwner;
				DFE_GROUP_ACCESS(pDfEntry) = AfpInfo.afpi_AccessGroup;
				DFE_WORLD_ACCESS(pDfEntry) = AfpInfo.afpi_AccessWorld;
			}
			else
			{
				// it's a file

				pDfEntry->dfe_RescLen = 0;	// Assume no resource fork

				// if this is a Mac application, make sure there is an APPL
				// mapping for it.
				if (AfpInfo.afpi_FinderInfo.fd_TypeD == *(PDWORD)"APPL")
				{
					AfpAddAppl(pVolDesc,
							   AfpInfo.afpi_FinderInfo.fd_CreatorD,
							   0,
							   pDfEntry->dfe_AfpId,
							   True,
							   pDfEntry->dfe_Parent->dfe_AfpId);
				}
			}

			// Check for comment and resource stream
			pStreams = AfpIoQueryStreams(&fshAfpInfo);
			if (pStreams == NULL)
			{
				Status = STATUS_NO_MEMORY;
				break;
			}

			for (pCurStream = pStreams, SeenComment = False;
				 pCurStream->si_StreamName.Buffer != NULL;
				 pCurStream++)
			{
				if (IS_COMMENT_STREAM(&pCurStream->si_StreamName))
				{
					DFE_SET_COMMENT(pDfEntry);
					SeenComment = True;
					if (IsDir)
						break;	// Scan no further for directories
				}
				else if (!IsDir && IS_RESOURCE_STREAM(&pCurStream->si_StreamName))
				{
					pDfEntry->dfe_RescLen = pCurStream->si_StreamSize.LowPart;
					if (SeenComment)
						break;	// We have all we need to
				}
			}
			AfpFreeMemory(pStreams);
		}
		else // CDFS
		{
			pDfEntry = AfpAddDfEntry(pVolDesc,
									 pParentDfe,
									 pUName,
									 IsDir,
									 0);

            if (pDfEntry == NULL)
            {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            RtlZeroMemory(&FinderInfo, sizeof(FINDERINFO));
            RtlZeroMemory(&pDfEntry->dfe_FinderInfo, sizeof(FINDERINFO));
			pDfEntry->dfe_BackupTime = BEGINNING_OF_TIME;
			pDfEntry->dfe_AfpAttr = 0;

			if (IsDir)
			{
				DFE_OWNER_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
				DFE_GROUP_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
				DFE_WORLD_ACCESS(pDfEntry) = (DIR_ACCESS_SEARCH | DIR_ACCESS_READ);
			}

			if (IS_VOLUME_CD_HFS(pVolDesc))
			{
    		    Status = AfpIoOpen(pfshEnumDir,
				            AFP_STREAM_DATA,
				            openoptions,
				            pUName,
				            FILEIO_ACCESS_NONE,
				            FILEIO_DENY_NONE,
				            False,
				            &fshData);
			    if (!NT_SUCCESS(Status))
			    {
				    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				      ("afpAddDfEntryAndCacheInfo: AfpIoOpen on %Z failed (%lx) for CD_HFS\n", pUName,Status));
			        break;
			    }

			    pDfEntry->dfe_RescLen = 0;

			    // if it's a file...

                if (!IsDir)
                {
    		        // if this is a Mac application, make sure there is an APPL
    			    // mapping for it.
    			    if (FinderInfo.fd_TypeD == *(PDWORD)"APPL")
			        {
    			        AfpAddAppl( pVolDesc,
				    	            FinderInfo.fd_CreatorD,
				                    0,
    				                pDfEntry->dfe_AfpId,
	    			                True,
		    		                pDfEntry->dfe_Parent->dfe_AfpId);
			        }

			        // Check for resource stream
			        pStreams = AfpIoQueryStreams(&fshData);
			        if (pStreams == NULL)
			        {
        			    Status = STATUS_NO_MEMORY;
			            break;
			        }

    			    for (pCurStream = pStreams;
        			    pCurStream->si_StreamName.Buffer != NULL;
		    	        pCurStream++)
			        {
    			        if (IS_RESOURCE_STREAM(&pCurStream->si_StreamName))
			            {
    			            pDfEntry->dfe_RescLen = pCurStream->si_StreamSize.LowPart;
				            break;
			            }
			        }

			        AfpFreeMemory(pStreams);
                }
			}
			// NOTE: if CdHfs doesn't have finder info, should we check for
			// that and set it ourselves using AfpSetFinderInfoByExtension?

			else
			{
    		    AfpSetFinderInfoByExtension(pUName, &pDfEntry->dfe_FinderInfo);
			    pDfEntry->dfe_RescLen = 0;
			}
			
		}

		// Record common NTFS & CDFS information
		pDfEntry->dfe_CreateTime = AfpConvertTimeToMacFormat(&pFBDInfo->CreationTime);
		pDfEntry->dfe_LastModTime = pFBDInfo->LastWriteTime;
		pDfEntry->dfe_NtAttr = (USHORT)pFBDInfo->FileAttributes & FILE_ATTRIBUTE_VALID_FLAGS;


        // if this is an HFS volume, check if Finder says file should be invisible
		if (IS_VOLUME_CD_HFS(pVolDesc))
        {
            if (pDfEntry->dfe_FinderInfo.fd_Attr1 & FINDER_FLAG_INVISIBLE)
            {
		        pDfEntry->dfe_NtAttr |= FILE_ATTRIBUTE_HIDDEN;
            }
        }

		if (!IsDir)
		{
			pDfEntry->dfe_DataLen = pFBDInfo->EndOfFile.LowPart;
		}

		ASSERT(pDfEntry != NULL);
	} while (False); // error handling loop

	if (fshAfpInfo.fsh_FileHandle != NULL)
    {
		AfpIoClose(&fshAfpInfo);

        // NTFS will set the LastModify time to current time on file since we modified the
        // AfpInfo stream: restore the original time
		if (!IsDir)
        {
            // force ntfs to "flush" any pending time updates before we reset the time
            AfpIoChangeNTModTime(&fshData,
                                 &ModTime);

            AfpIoSetTimesnAttr(&fshData,
                               NULL,
                               &ModMacTime,
                               0,
                               0,
                               NULL,
                               NULL);
        }
    }

	if (fshData.fsh_FileHandle != NULL)
	{
		if (IS_VOLUME_NTFS(pVolDesc))
		{
		    AfpPutBackROAttr(&fshData, WriteBackROAttr);
		}
		AfpIoClose(&fshData);
	}


	if (!NT_SUCCESS(Status))
	{
		pDfEntry = NULL;
	}

	*ppDfEntry = pDfEntry;
}


/***	afpReadIdDb
 *
 *	This is called when a volume is added, if an existing Afp_IdIndex stream
 *	is found on the root of the volume.  The stream is is read in, the
 *	VolDesc is initialized with the header image on disk, and the
 *	IdDb sibling tree/hash tables are created from the data on disk.
 *
**/
LOCAL NTSTATUS FASTCALL
afpReadIdDb(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pfshIdDb,
	OUT	BOOLEAN *       pfVerifyIndex
)
{
	PBYTE					pReadBuf;
	PIDDBHDR				pIdDbHdr;
	NTSTATUS				Status;
	LONG					SizeRead = 0, Count;
	FORKOFFST				ForkOffst;
	UNICODE_STRING			uName;
	UNALIGNED DISKENTRY	*	pCurDiskEnt = NULL;
	DWORD					NameLen, CurEntSize, SizeLeft;
	LONG					i, NumRead = 0;
	PDFENTRY				pParentDfe = NULL, pCurDfe = NULL;
    struct _DirFileEntry ** DfeDirBucketStart;
	BOOLEAN					LastBuf = False, ReadDb = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
			("afpReadIdDb: Reading existing Id Database header stream...\n") );

	do
	{
		if ((pReadBuf = AfpAllocPANonPagedMemory(IDDB_UPDATE_BUFLEN)) == NULL)
		{
			Status=STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pIdDbHdr = (PIDDBHDR)pReadBuf;

		// read in the header
		Status = AfpIoRead(pfshIdDb,
						   &LIZero,
						   IDDB_UPDATE_BUFLEN,
						   &SizeRead,
						   (PBYTE)pIdDbHdr);

		if (!NT_SUCCESS(Status)									||
			(SizeRead < sizeof(IDDBHDR))						||
			(pIdDbHdr->idh_Signature == AFP_SERVER_SIGNATURE_INITIDDB)	||
			(pIdDbHdr->idh_LastId < AFP_ID_NETWORK_TRASH))
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				("Index database corrupted for volume %Z, rebuilding database\n",
                &pVolDesc->vds_Name) );

            DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
                    ("Read sign = %lx, True sign = %lx\n", 
                     pIdDbHdr->idh_Signature, AFP_SERVER_SIGNATURE));

			// just recreate the stream
			Status = AFP_ERR_BAD_VERSION;
			AfpIoSetSize(pfshIdDb, 0);
		}
		else
		{
			if (pIdDbHdr->idh_Version == AFP_IDDBHDR_VERSION)
			{
                if ((pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE) &&
                    (pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE_MANUALSTOP))
                {
                    DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
                            ("afpreadiddb: Totally corrupt sign = (%lx), required sign = (%lx)\n", 
                             pIdDbHdr->idh_Signature, AFP_SERVER_SIGNATURE));

                    // just recreate the stream
                    Status = AFP_ERR_BAD_VERSION;
                    AfpIoSetSize(pfshIdDb, 0);
                }
                else
                {
			        if (pIdDbHdr->idh_Signature == AFP_SERVER_SIGNATURE_MANUALSTOP)	
                    {
				        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					        ("afpreadIdDb: **** Need to verify index after reading it\n"));
                        *pfVerifyIndex = True;
                    }

                    AfpIdDbHdrToVolDesc(pIdDbHdr, pVolDesc);
    		        if (SizeRead < (sizeof(IDDBHDR) + sizeof(DWORD)))
			        {
				        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
						        ("afpreadIdDb: Size incorrect\n"));
				        Count = 0;
				        Status = STATUS_END_OF_FILE;
			        }
			        else
			        {
				        Count = *(PDWORD)(pReadBuf + sizeof(IDDBHDR));
				        if (Count != 0)
                           {
					        ReadDb = True;
                           }
				        else
				        {
					        Status = STATUS_END_OF_FILE;
					        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							        ("afpreadIdDb: Count incorrect\n"));
				        }
			        }
                }
                    
			}
			else if ((pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION1) &&
					 (pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION2) &&
					 (pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION3) &&
					 (pIdDbHdr->idh_Version != AFP_IDDBHDR_VERSION4))
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("afpreadIdDb: Bad Version (expected %x, actual %x)\n",
                    AFP_IDDBHDR_VERSION,pIdDbHdr->idh_Version));

				// just recreate the stream
				AfpIoSetSize(pfshIdDb, 0);
				Status = AFP_ERR_BAD_VERSION;
			}
			else
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
                    ("afpreadIdDb: Downlevel Version, re-index volume\n"));

				Status = STATUS_END_OF_FILE;

				AfpIdDbHdrToVolDesc(pIdDbHdr, pVolDesc);

				// Dont blow away the header
				AfpIoSetSize(pfshIdDb, sizeof(IDDBHDR));

                AFPLOG_INFO(AFPSRVMSG_UPDATE_INDEX_VERSION,
                            STATUS_SUCCESS,
                            NULL,
                            0,
                            &pVolDesc->vds_Name);

			}
		}

		if (!NT_SUCCESS(Status) || !ReadDb || (Count == 0))
		{
			break;
		}

		// read the count of entries from the stream
		ForkOffst.QuadPart = SizeRead;
		SizeLeft = SizeRead - (sizeof(IDDBHDR) + sizeof(DWORD));
		pCurDiskEnt = (UNALIGNED DISKENTRY *)(pReadBuf + (sizeof(IDDBHDR) + sizeof(DWORD)));

		// Start the database with the PARENT_OF_ROOT
		// At this point there is only the ParentOfRoot DFE in the volume.
		// Just access it rather can calling AfpFindDfEntryById

        DfeDirBucketStart = pVolDesc->vds_pDfeDirBucketStart;
		pParentDfe = DfeDirBucketStart[AFP_ID_PARENT_OF_ROOT];

		ASSERT (pParentDfe != NULL);
		ASSERT (pParentDfe->dfe_AfpId == AFP_ID_PARENT_OF_ROOT);

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("afpreadIdDb: Number of entries %d\n", Count));

		while ((NumRead < Count) &&
			   ((pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)) == 0))
		{
			//
			// get the next entry
			//

			// We ensure that there are no partial entries. If an entry does not fit at
			// the end, we write an invalid entry (AfpId == 0) and skip to the next
			// buffer.
			if ((SizeLeft < (sizeof(DISKENTRY)))  || (pCurDiskEnt->dsk_AfpId == 0))
			{
				if (LastBuf) // we have already read to the end of file
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpreadIdDb: Reached EOF\n"));
					Status = STATUS_UNSUCCESSFUL;
					break;
				}

				// Skip to the next page and continue with the next entry
				Status = AfpIoRead(pfshIdDb,
								   &ForkOffst,
								   IDDB_UPDATE_BUFLEN,
								   &SizeRead,
								   pReadBuf);

				if (!NT_SUCCESS(Status))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("afpreadIdDb: Read Eror %lx\n", Status));
					break;
				}

				ForkOffst.QuadPart += SizeRead;
				// if we read less than we asked for, then we reached EOF
				LastBuf = (SizeRead < IDDB_UPDATE_BUFLEN) ? True : False;
				SizeLeft = SizeRead;
				pCurDiskEnt = (UNALIGNED DISKENTRY *)pReadBuf;
				continue;
			}

			//
			// check dsk_Signature for signature, just to be sure you are
			// still aligned on a structure and not off in la-la land
			//
			if (pCurDiskEnt->dsk_Signature != AFP_DISKENTRY_SIGNATURE)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
						("afpreadIdDb: Signature mismatch\n"));
				Status = STATUS_DATATYPE_MISALIGNMENT;
				break;
			}

			ASSERT(pCurDiskEnt->dsk_AfpId != AFP_ID_NETWORK_TRASH);

			// add current entry to database
			if (pCurDiskEnt->dsk_AfpId != AFP_ID_ROOT)
			{
				AfpInitUnicodeStringWithNonNullTerm(&uName,
													(pCurDiskEnt->dsk_Flags & DFE_FLAGS_NAMELENBITS) * sizeof(WCHAR),
													(PWSTR)(pCurDiskEnt->dsk_Name));
			}
			else
			{
				// In case someone has reused a directory with an existing
				// AFP_IdIndex stream for a different volume name
				uName = pVolDesc->vds_Name;
			}

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("afpReadIdDb: Read %d: %Z\n", 
					 pCurDiskEnt->dsk_AfpId,
					&uName));

			if ((pCurDfe = AfpAddDfEntry(pVolDesc,
										 pParentDfe,
										 &uName,
										 (BOOLEAN)((pCurDiskEnt->dsk_Flags & DFE_FLAGS_DIR) == DFE_FLAGS_DIR),
										 pCurDiskEnt->dsk_AfpId)) == NULL)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
						("afpreadIdDb: AfpAddDfEntry failed for %Z (ParentId %x)\n",
						 &uName, pParentDfe->dfe_AfpId));
				Status = STATUS_UNSUCCESSFUL;
				break;
			}

			// Initialize pointer to root.
			if (DFE_IS_ROOT(pCurDfe))
			{
				pVolDesc->vds_pDfeRoot = pCurDfe;
			}

			afpUpdateDfeWithSavedData(pCurDfe, pCurDiskEnt);

			NameLen = (DWORD)((pCurDiskEnt->dsk_Flags & DFE_FLAGS_NAMELENBITS)*sizeof(WCHAR));
			CurEntSize = DWLEN(FIELD_OFFSET(DISKENTRY, dsk_Name) + NameLen);

			NumRead ++;
			SizeLeft -= CurEntSize;
			pCurDiskEnt = (UNALIGNED DISKENTRY *)((PBYTE)pCurDiskEnt + CurEntSize);

			// figure out who the next parent should be
			if (pCurDfe->dfe_Flags & DFE_FLAGS_HAS_CHILD)
			{
				DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
						("afpreadIdDb: Moving down %Z\n", &pCurDfe->dfe_UnicodeName));
				pParentDfe = pCurDfe;
			}
			else if (!(pCurDfe->dfe_Flags & DFE_FLAGS_HAS_SIBLING))
			{
				if (DFE_IS_PARENT_OF_ROOT(pParentDfe))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpreadIdDb: Done, NumRead %d, Count %d\n", NumRead, Count));
					ASSERT(NumRead == Count);
					break;
				}
				while (!(pParentDfe->dfe_Flags & DFE_FLAGS_HAS_SIBLING))
				{
					if (DFE_IS_ROOT(pParentDfe))
					{
						break;
					}
					pParentDfe = pParentDfe->dfe_Parent;
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpreadIdDb: Moving up\n"));
				}
				pParentDfe = pParentDfe->dfe_Parent;
				if (DFE_IS_PARENT_OF_ROOT(pParentDfe))
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
							("afpreadIdDb: Reached Id 1\n"));
					ASSERT(NumRead == Count);
					break;
				}
			}
		} // while

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("Indexing: Read %ld entries (%lx)\n", NumRead,Status) );

		if (!NT_SUCCESS(Status))
		{
		
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
				("afpReadIdDb: Indexing: Starting all over\n"));

			// Free everything and start over
			AfpFreeIdIndexTables(pVolDesc);
			afpInitializeIdDb(pVolDesc);
		}

	} while (False);

	if (pReadBuf != NULL)
		AfpFreePANonPagedMemory(pReadBuf, IDDB_UPDATE_BUFLEN);

	return Status;
}


VOID
AfpGetDirFileHashSizes(
	IN	PVOLDESC			pVolDesc,
    OUT PDWORD              pdwDirHashSz,
    OUT PDWORD              pdwFileHashSz
)
{

    FILESYSHANDLE   fshIdDb;
    ULONG           CreateInfo;
    PBYTE           pReadBuf=NULL;
    PIDDBHDR        pIdDbHdr;
    DWORD           dwDirFileCount=0;
    DWORD           dwTemp;
    DWORD           dwDirHshTblLen, dwFileHshTblLen;
    LONG            SizeRead=0;
    NTSTATUS        Status;
    BOOLEAN         fFileOpened=FALSE;


    // in case we bail out..
    *pdwDirHashSz = IDINDEX_BUCKETS_DIR_INIT;
    *pdwFileHashSz = IDINDEX_BUCKETS_FILE_INIT;

    if (!IS_VOLUME_NTFS(pVolDesc))
    {
        goto AfpGetDirFileCount_Exit;
    }

    if ((pReadBuf = AfpAllocNonPagedMemory(1024)) == NULL)
    {
        goto AfpGetDirFileCount_Exit;
    }

	Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
						AFP_STREAM_IDDB,
						&UNullString,
						FILEIO_ACCESS_READWRITE,
						FILEIO_DENY_WRITE,
						FILEIO_OPEN_FILE_SEQ,
						FILEIO_CREATE_INTERNAL,
						FILE_ATTRIBUTE_NORMAL,
						False,
						NULL,
						&fshIdDb,
						&CreateInfo,
						NULL,
						NULL,
						NULL);

	if (!NT_SUCCESS(Status))
	{
        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
            ("AfpGetDirFileHashSizes: AfpIoCreate failed %lx for %Z\n",Status,&pVolDesc->vds_Name));
        goto AfpGetDirFileCount_Exit;
	}

    fFileOpened = TRUE;

    // if the file just got created, it didn't exist before!
    if (CreateInfo != FILE_OPENED)
    {
        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
            ("AfpGetDirFileHashSizes: file created, not opened %d for %Z\n",CreateInfo,&pVolDesc->vds_Name));
        goto AfpGetDirFileCount_Exit;
    }

    //
    // if we reached here, it means that the file existed before, which means
    // we made an effort earlier to index this volume.  We are going to read the
    // dwDirFileCount and calcualte the hash table sizes, but for now let's
    // initiliaze this to a high value
    //
    *pdwDirHashSz = IDINDEX_BUCKETS_32K;
    *pdwFileHashSz = IDINDEX_BUCKETS_32K;

	// read in the header
	Status = AfpIoRead(&fshIdDb,
					   &LIZero,
					   1024,
					   &SizeRead,
					   pReadBuf);

    pIdDbHdr = (PIDDBHDR)pReadBuf;

	if (!NT_SUCCESS(Status)									||
		(SizeRead < (sizeof(IDDBHDR) + sizeof(DWORD)))		||
		((pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE)  &&
		(pIdDbHdr->idh_Signature != AFP_SERVER_SIGNATURE_MANUALSTOP)))
	{
		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
			("Reading DirFileCount: database corrupted for volume %Z!\n",
            &pVolDesc->vds_Name) );

        goto AfpGetDirFileCount_Exit;
	}
	else if (pIdDbHdr->idh_Version == AFP_IDDBHDR_VERSION)
	{
		dwDirFileCount = *(PDWORD)(pReadBuf + sizeof(IDDBHDR));

        DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
   	        ("Reading DirFileCount = %d!\n",dwDirFileCount));
	}


AfpGetDirFileCount_Exit:

    if (fFileOpened)
    {
        AfpIoClose(&fshIdDb);
    }

    if (pReadBuf)
    {
        AfpFreeMemory(pReadBuf);
    }

    if (dwDirFileCount == 0)
    {
        return;
    }

    //
    // first calculate the size of hashtable for Dirs
    // We assume here that 10% of the (files+directories) are directories
    // We want to try and keep no more than 20 nodes per hash bucket
    //
    dwDirHshTblLen = (dwDirFileCount / 10);
    dwDirHshTblLen = (dwDirHshTblLen / 20);

    if (dwDirHshTblLen <= IDINDEX_BUCKETS_DIR_MIN)
    {
        dwDirHshTblLen = IDINDEX_BUCKETS_DIR_MIN;
    }
    else if (dwDirHshTblLen >= IDINDEX_BUCKETS_MAX)
    {
        dwDirHshTblLen = IDINDEX_BUCKETS_MAX;
    }
    else
    {
        // find the smallest power of 2 that's bigger than dwDirHshTblLen
        dwTemp = IDINDEX_BUCKETS_MAX;
        while (dwDirHshTblLen < dwTemp)
        {
            dwTemp /= 2;
        }

        dwDirHshTblLen = 2*dwTemp;
    }

    //
    // now, calculate the size of hashtable for Files
    // (even though we should take 90% as number of files, we keep it that way!)
    // We want to try and keep no more than 20 nodes per hash bucket
    //
    dwFileHshTblLen = (dwDirFileCount / 20);

    if (dwFileHshTblLen <= IDINDEX_BUCKETS_FILE_MIN)
    {
        dwFileHshTblLen = IDINDEX_BUCKETS_FILE_MIN;
    }
    else if (dwFileHshTblLen >= IDINDEX_BUCKETS_MAX)
    {
        dwFileHshTblLen = IDINDEX_BUCKETS_MAX;
    }
    else
    {
        // find the smallest power of 2 that's bigger than dwFileHshTblLen
        dwTemp = IDINDEX_BUCKETS_MAX;

        while (dwFileHshTblLen < dwTemp)
        {
            dwTemp /= 2;
        }

        dwFileHshTblLen = 2*dwTemp;
    }

    *pdwDirHashSz = dwDirHshTblLen;
    *pdwFileHashSz = dwFileHshTblLen;
}

/***	AfpFlushIdDb
 *
 *	Initiated by the scavenger thread. If it is determined that the Afp_IdIndex
 *	stream for this volume is to be flushed to disk, then this is called to
 *	do the job. The swmr access is locked for read while the update is in
 *	progress. The vds_cScvgrIdDb and vds_cChangesIdDb are reset if there is
 *	no error writing the entire database.  An initial count of zero is written
 *	to the database before it is updated, just in case an error occurs that
 *	prevents us from writing the entire database.  When the entire thing is
 *	written, then the actual count of entries is written to disk.  The
 *	parent-of-root entry is never saved on disk, nor is the network trash
 *	subtree of the database. The iddb header is written whether it is dirty
 *	or not.
 *
 *	LOCKS:			vds_VolLock (SPIN)
 *	LOCKS_ASSUMED:	vds_idDbAccessLock (SWMR, Shared)
 *	LOCK_ORDER:		vds_VolLock after vds_IdDbAccessLock
 */
VOID FASTCALL
AfpFlushIdDb(
	IN	PVOLDESC			pVolDesc,
	IN	PFILESYSHANDLE		phIdDb
)
{
	PBYTE					pWriteBuf;
	NTSTATUS				Status;
	BOOLEAN					WriteEntireHdr = False;
	PDFENTRY				pCurDfe;
	DWORD					SizeLeft;	// the number of free bytes left in the writebuffer
	DWORD					CurEntSize, NumWritten = 0;
	FORKOFFST				ForkOffst;
	UNALIGNED DISKENTRY	*	pCurDiskEnt = NULL;
	PIDDBHDR				pIdDbHdr;
	BOOLEAN					HdrDirty = False;
	KIRQL					OldIrql;
	DWORD					fbi = 0, CreateInfo;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_IdIndexUpdCount);
	AfpGetPerfCounter(&TimeS);
#endif

	DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,("\tWriting out IdDb...\n") );
	ASSERT(VALID_VOLDESC(pVolDesc));


	// Take the Swmr so that nobody can initiate changes to the IdDb
	AfpSwmrAcquireShared(&pVolDesc->vds_IdDbAccessLock);

	do
	{
		if ((pWriteBuf = AfpAllocPANonPagedMemory(IDDB_UPDATE_BUFLEN)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		pIdDbHdr = (PIDDBHDR)pWriteBuf;

		// Snapshot the IdDbHdr and dirty bit
		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		AfpVolDescToIdDbHdr(pVolDesc, pIdDbHdr);
        if (!fAfpServerShutdownEvent)
        {
            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                        ("AfpFlushIdDb: Corrupting signature during scavenger run\n"));

            // If server going down due to admin stop, indicate it
            // with a unique signature

            if (fAfpAdminStop)
            {
            	pIdDbHdr->idh_Signature = AFP_SERVER_SIGNATURE_MANUALSTOP;
            }
            else
            {
            	pIdDbHdr->idh_Signature = AFP_SERVER_SIGNATURE_INITIDDB;
            }
        }

		if (pVolDesc->vds_Flags & VOLUME_IDDBHDR_DIRTY)
		{
			HdrDirty = True;
			// Clear the dirty bit
			pVolDesc->vds_Flags &= ~VOLUME_IDDBHDR_DIRTY;
		}

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		// Set the count of entries to zero. Once we are done, we'll then
		// overwrite it with the right value
		*(PDWORD)(pWriteBuf + sizeof(IDDBHDR)) = 0;

   		// Set the pointer to the first entry we'll write past the header and
		// the count of entries. Adjust space remaining.
		pCurDiskEnt = (UNALIGNED DISKENTRY *)(pWriteBuf + sizeof(IDDBHDR) + sizeof(DWORD));
		SizeLeft = IDDB_UPDATE_BUFLEN - (sizeof(IDDBHDR) + sizeof(DWORD));
		ForkOffst.QuadPart = 0;

		// start with the root (don't write out the parent of root)
		pCurDfe = pVolDesc->vds_pDfeRoot;
		ASSERT(pCurDfe != NULL);

		Status = STATUS_SUCCESS;

        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
            ("AfpFlushIdDb: writing index file for vol %Z started..\n",&pVolDesc->vds_Name));
		do
		{
			ASSERT(!DFE_IS_NWTRASH(pCurDfe));

			// The size of the current entry is:
			//	DISKENTRY structure + namelen padded to 4*N
			CurEntSize = DWLEN(FIELD_OFFSET(DISKENTRY, dsk_Name) + pCurDfe->dfe_UnicodeName.Length);
			if (CurEntSize > SizeLeft)
			{
				// If there is atleast a DWORD left, write a ZERO there to
				// indicate that the rest of the buffer is to be skipped.
				// ZERO is an invalid AfpId.
				// NOTE: dsk_AfpId NEEDS TO BE THE FIRST FIELD IN THE STRUCT
				ASSERT(FIELD_OFFSET(DISKENTRY, dsk_AfpId) == 0);

				if (SizeLeft > 0)
				{
					RtlZeroMemory(pWriteBuf + IDDB_UPDATE_BUFLEN - SizeLeft,
								  SizeLeft);
				}

				// write out the buffer and start at the beginning of buffer
				Status = AfpIoWrite(phIdDb,
									&ForkOffst,
									IDDB_UPDATE_BUFLEN,
									pWriteBuf);
				if (!NT_SUCCESS(Status))
				{
					// Reset the dirty bit if need be
					if (HdrDirty && (ForkOffst.QuadPart == 0))
					{
						AfpInterlockedSetDword(&pVolDesc->vds_Flags,
												VOLUME_IDDBHDR_DIRTY,
												&pVolDesc->vds_VolLock);
					}
					break;
				}
				ForkOffst.QuadPart += IDDB_UPDATE_BUFLEN;
				SizeLeft = IDDB_UPDATE_BUFLEN;
				pCurDiskEnt = (UNALIGNED DISKENTRY *)pWriteBuf;
			}

			NumWritten ++;
			afpSaveDfeData(pCurDfe, pCurDiskEnt);

			if (DFE_IS_DIRECTORY(pCurDfe))
			{
				PDIRENTRY	pDirEntry = pCurDfe->dfe_pDirEntry;

				pCurDiskEnt->dsk_RescLen = 0;

				pCurDiskEnt->dsk_Access = *(PDWORD)(&pDirEntry->de_Access);
				ASSERT (pCurDfe->dfe_pDirEntry != NULL);

				if ((pCurDfe->dfe_FileOffspring > 0)	||
					(pCurDfe->dfe_DirOffspring > 1)		||
					 ((pCurDfe->dfe_DirOffspring > 0) &&
					 !DFE_IS_NWTRASH(pDirEntry->de_ChildDir)))
				{
					pCurDiskEnt->dsk_Flags |= DFE_FLAGS_HAS_CHILD;
				}

				if (pCurDfe->dfe_NextSibling != NULL)
				{
					// Make sure we ignore the nwtrash folder
					if (!DFE_IS_NWTRASH(pCurDfe->dfe_NextSibling) ||
						(pCurDfe->dfe_NextSibling->dfe_NextSibling != NULL))
					{
						pCurDiskEnt->dsk_Flags |= DFE_FLAGS_HAS_SIBLING;
					}
				}
			}
			else
			{
				BOOLEAN	fHasSibling;

				pCurDiskEnt->dsk_RescLen = pCurDfe->dfe_RescLen;
				pCurDiskEnt->dsk_DataLen = pCurDfe->dfe_DataLen;
				DFE_FILE_HAS_SIBLING(pCurDfe, fbi, &fHasSibling);
				if (fHasSibling)
				{
					pCurDiskEnt->dsk_Flags |= DFE_FLAGS_HAS_SIBLING;
				}
			}

			// stick the current entry into the write buffer
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("AfpFlushIdDb: Writing %s %d: %Z, flags %x\n",
					DFE_IS_DIRECTORY(pCurDfe) ? "Dir" : "File", pCurDfe->dfe_AfpId,
					&pCurDfe->dfe_UnicodeName, pCurDiskEnt->dsk_Flags));

			SizeLeft -= CurEntSize;
			pCurDiskEnt = (UNALIGNED DISKENTRY *)((PBYTE)pCurDiskEnt + CurEntSize);

			/*
			 * Get to the next DFE. The entire tree under the network-trash
			 * folder is ignored. The Next DFE is:
			 *
			 * if (the current DFE is a file)
			 * {
			 *		if (there is another file sibling)
			 *		{
			 *			CurDfe = file Sibling;
			 *		}
			 *		else if (there is dir sibling)
			 *		{
			 *			CurDfe = dir Sibling;
			 *		}
			 *		else
			 *		{
			 *			CurDfe = Parent's next sibling directory;
			 * 		}
			 * }
			 * else
			 * {
			 *		if (dir has any file children)
			 *		{
			 *			CurDfe = First file child;
			 *		}
			 *		else if (dir has any dir children)
			 *		{
			 *			CurDfe = First dir child;
			 *		}
			 *		if (there is a sibling)
			 *		{
			 *			CurDfe = dir Sibling;
			 *		}
			 *		else
			 *		{
			 *			CurDfe = Parent's next sibling directory;
			 * 		}
			 * }
			 * When we hit the root, we are done
			 *
			 */
			if (DFE_IS_FILE(pCurDfe))
			{
				if (pCurDfe->dfe_NextSibling != NULL)
				{
					pCurDfe = pCurDfe->dfe_NextSibling;
				}
				else
				{
					PDIRENTRY	pDirEntry;

					pDirEntry = pCurDfe->dfe_Parent->dfe_pDirEntry;

					fbi++;
					while ((fbi < MAX_CHILD_HASH_BUCKETS) &&
						   (pDirEntry->de_ChildFile[fbi] == NULL))
					{
						fbi++;
					}

					if (fbi < MAX_CHILD_HASH_BUCKETS)
					{
						pCurDfe = pDirEntry->de_ChildFile[fbi];
						continue;
					}

					// There are no more files from this parent. Try its children
					// next. Ignore the NWTRASH folder.
					fbi = 0;
					if (pDirEntry->de_ChildDir != NULL)
					{
	                    if (!DFE_IS_NWTRASH(pDirEntry->de_ChildDir))
						{
							pCurDfe = pDirEntry->de_ChildDir;
							continue;
						}

						if (pDirEntry->de_ChildDir->dfe_NextSibling != NULL)
						{
							pCurDfe = pDirEntry->de_ChildDir->dfe_NextSibling;
							continue;
						}
					}

					// No more 'dir' siblings, move on up.
					if (!DFE_IS_ROOT(pCurDfe))
					{
						goto move_up;
					}
					else
					{
						// we've reached the root: we're done: get out of the loop
						pCurDfe = NULL;
					}
				}
			}
			else
			{
				PDIRENTRY	pDirEntry;

				// Reset ChildFileBucket index. First check for and handle
				// all file children of this directory and then move on to
				// its children or siblings
				fbi = 0;
				pDirEntry = pCurDfe->dfe_pDirEntry;
				while ((fbi < MAX_CHILD_HASH_BUCKETS) &&
					   (pDirEntry->de_ChildFile[fbi] == NULL))
				{
					fbi++;
				}
				if (fbi < MAX_CHILD_HASH_BUCKETS)
				{
					pCurDfe = pDirEntry->de_ChildFile[fbi];
					continue;
				}

				if (pDirEntry->de_ChildDir != NULL)
				{
					pCurDfe = pDirEntry->de_ChildDir;

					// don't bother writing out the network trash tree
					if (DFE_IS_NWTRASH(pCurDfe))
					{
						// could be null, if so, we're done
						pCurDfe = pCurDfe->dfe_NextSibling;
					}
				}
				else if (pCurDfe->dfe_NextSibling != NULL)
				{
					pCurDfe = pCurDfe->dfe_NextSibling;
					// don't bother writing out the network trash tree
					if (DFE_IS_NWTRASH(pCurDfe))
					{
						// could be null, if so, we're done
						pCurDfe = pCurDfe->dfe_NextSibling;
					}
				}
				else if (!DFE_IS_ROOT(pCurDfe))
				{
				  move_up:
					while (pCurDfe->dfe_Parent->dfe_NextSibling == NULL)
					{
						if (DFE_IS_ROOT(pCurDfe->dfe_Parent))
						{
							break;
						}
						pCurDfe = pCurDfe->dfe_Parent;
					}

                    // if ROOT then you get NULL
					pCurDfe = pCurDfe->dfe_Parent->dfe_NextSibling; // if ROOT then you get NULL

					// Make sure we ignore the nwtrash folder
					if ((pCurDfe != NULL) && DFE_IS_NWTRASH(pCurDfe))
					{
						pCurDfe = pCurDfe->dfe_NextSibling; // Could be null
					}
				}
				else break;
			}
		} while ((pCurDfe != NULL) && NT_SUCCESS(Status));

		if (NT_SUCCESS(Status))
		{
			DWORD	LastWriteSize, SizeRead;

			LastWriteSize = (DWORD)ROUND_TO_PAGES(IDDB_UPDATE_BUFLEN - SizeLeft);
			if (SizeLeft != IDDB_UPDATE_BUFLEN)
			{
				// write out the last bunch of the entries. Zero out unused space
				RtlZeroMemory(pWriteBuf + IDDB_UPDATE_BUFLEN - SizeLeft,
							  LastWriteSize - (IDDB_UPDATE_BUFLEN - SizeLeft));
				Status = AfpIoWrite(phIdDb,
									&ForkOffst,
									LastWriteSize,
									pWriteBuf);
				if (!NT_SUCCESS(Status))
				{
					// Reset the dirty bit if need be
					if (HdrDirty && (ForkOffst.QuadPart == 0))
					{
						AfpInterlockedSetDword(&pVolDesc->vds_Flags,
												VOLUME_IDDBHDR_DIRTY,
												&pVolDesc->vds_VolLock);
					}
					break;
				}
			}

			// set the file length to IdDb plus count plus header
			Status = AfpIoSetSize(phIdDb,
								  ForkOffst.LowPart + LastWriteSize);
			ASSERT(Status == AFP_ERR_NONE);

			// write out the count of entries written to the file. Do a read-modify-write
			// of the first page
			ForkOffst.QuadPart = 0;
			Status = AfpIoRead(phIdDb,
							   &ForkOffst,
							   PAGE_SIZE,
							   &SizeRead,
							   pWriteBuf);
			ASSERT (NT_SUCCESS(Status) && (SizeRead == PAGE_SIZE));
			if (!NT_SUCCESS(Status))
			{
				// set the file length to header plus count of zero entries
				AfpIoSetSize(phIdDb,
							 sizeof(IDDBHDR)+sizeof(DWORD));
				break;
			}

			*(PDWORD)(pWriteBuf + sizeof(IDDBHDR)) = NumWritten;
			Status = AfpIoWrite(phIdDb,
								&ForkOffst,
								PAGE_SIZE,
								pWriteBuf);
			if (!NT_SUCCESS(Status))
			{
				// set the file length to header plus count of zero entries
				AfpIoSetSize(phIdDb,
							 sizeof(IDDBHDR)+sizeof(NumWritten));
				break;
			}

			// not protected since scavenger is the only consumer of this field
			pVolDesc->vds_cScvgrIdDb = 0;

			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
					("Wrote %ld entries on volume %Z\n",NumWritten,&pVolDesc->vds_Name) );

			ASSERT(Status == AFP_ERR_NONE);
		}
	} while (False);

	AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);

	if (!NT_SUCCESS(Status))
	{
        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
            ("AfpFlushIdDb: writing index file for vol %Z failed (%lx)\n",
            &pVolDesc->vds_Name,Status));

		AFPLOG_ERROR(AFPSRVMSG_WRITE_IDDB,
					 Status,
					 NULL,
					 0,
					 &pVolDesc->vds_Name);
	}
    else
    {
        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_INFO,
            ("AfpFlushIdDb: writing index file for vol %Z finished.\n",&pVolDesc->vds_Name));
    }

	if (pWriteBuf != NULL)
	{
		AfpFreePANonPagedMemory(pWriteBuf, IDDB_UPDATE_BUFLEN);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_IdIndexUpdTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
}


/***	AfpChangeNotifyThread
 *
 *	Handle change notify requests queued by the notify completion routine.
 */
VOID
AfpChangeNotifyThread(
	IN	PVOID	pContext
)
{
	PKQUEUE		NotifyQueue;
	PLIST_ENTRY	pTimerList, pList, pNotifyList, pNext, pVirtualNotifyList;
	LIST_ENTRY	TransitionList;
	PVOL_NOTIFY	pVolNotify;
	PVOLDESC	pVolDesc;
	PVOLDESC	pCurrVolDesc=NULL;
	ULONG		BasePriority;
	PLONG		pNotifyQueueCount;
	KIRQL		OldIrql;
	NTSTATUS	Status;
    DWORD       ThisVolItems=0;
    BOOLEAN     fSwmrLocked=False;
#ifdef	PROFILING
	TIME		TimeS, TimeE, TimeD;
#endif
	LONG ShutdownPriority = LOW_REALTIME_PRIORITY; // Priority higher than file server

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpChangeNotifyThread: Starting %ld\n", pContext));

    IoSetThreadHardErrorMode( FALSE );

	// Boost our priority to just below low realtime.
	// The idea is get the work done fast and get out of the way.
	BasePriority = LOW_REALTIME_PRIORITY;
	Status = NtSetInformationThread(NtCurrentThread(),
									ThreadBasePriority,
									&BasePriority,
									sizeof(BasePriority));
	ASSERT(NT_SUCCESS(Status));

	pNotifyList = &AfpVolumeNotifyList[(LONG_PTR)pContext];
	pVirtualNotifyList = &AfpVirtualMemVolumeNotifyList[(LONG_PTR)pContext];
	NotifyQueue = &AfpVolumeNotifyQueue[(LONG_PTR)pContext];
	pNotifyQueueCount = &AfpNotifyQueueCount[(LONG_PTR)pContext];
	AfpThreadPtrsW[(LONG_PTR)pContext] = PsGetCurrentThread();

	do
	{
		AFPTIME		CurrentTime;

		ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);



		if (!IsListEmpty(pVirtualNotifyList))
		{
			AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
			pList = RemoveHeadList(pVirtualNotifyList);
			AfpSwmrRelease(&AfpVolumeListSwmr);
		}
		else
		{
			// Wait for a change notify request to process or timeout
			//pList = KeRemoveQueue(NotifyQueue, KernelMode, &TwoSecTimeOut);
			pList = KeRemoveQueue(NotifyQueue, KernelMode, &OneSecTimeOut);
		}

		// We either have something to process or we timed out. In the latter case
		// see if it is time to move some stuff from the list to the queue.
		if ((NTSTATUS)((ULONG_PTR)pList) != STATUS_TIMEOUT)
		{
			pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);

			if (pVolNotify == &AfpTerminateNotifyThread)
			{
				DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
					("ChangeNotifyThread Got AfpTerminateNotifyEvent Thread = %ld\n", (LONG_PTR)pContext));

                if (pCurrVolDesc)
                {
		            AfpSwmrRelease(&pCurrVolDesc->vds_IdDbAccessLock);

                    // remove that ref we put before grabbing the swmr lock
                    AfpVolumeDereference(pCurrVolDesc);
                    pCurrVolDesc = NULL;
                }

				// If these assertions fail, then there will be extra ref
				// counts on some volumes due to unprocessed notifies,
				// and the volumes will never go away.
				ASSERT((*pNotifyQueueCount == 0)	&&
						(AfpNotifyListCount[(LONG_PTR)pContext] == 0) &&
						IsListEmpty(pNotifyList));
				break;			// Asked to quit, so do so.
			}

#ifdef	PROFILING
			AfpGetPerfCounter(&TimeS);
#endif
			pVolDesc = pVolNotify->vn_pVolDesc;

            //
            // if we just moved to the next volume, release the lock for the
            // previous volume, and also, grab the lock for the this volume
            //
            if (pVolDesc != pCurrVolDesc)
            {
                if ((pCurrVolDesc) && (fSwmrLocked))
                {
				    AfpSwmrRelease(&pCurrVolDesc->vds_IdDbAccessLock);

                    // remove that ref we put before grabbing the swmr lock
                    AfpVolumeDereference(pCurrVolDesc);
                }
                pCurrVolDesc = pVolDesc;
                ThisVolItems = 0;

                // reference the volume, and deref when we release this swmr lock
                if (AfpVolumeReference(pVolDesc))
                {
                    AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
                    fSwmrLocked = True;
                }
                else
                {
		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			            ("AfpChangeNotifyThread: couldn't reference volume %Z!!\n",
                        &pVolDesc->vds_Name));

                    fSwmrLocked = False;

					// Remove all private notifies which follow this one
					AfpVolumeStopIndexing(pVolDesc, pVolNotify);

           		}

            }
            else
            {
                //
                // if someone's waiting for the lock, release it and reacuire it
                // to give him a chance
                //
                if ( (SWMR_SOMEONE_WAITING(&pVolDesc->vds_IdDbAccessLock)) &&
                     (ThisVolItems % 50 == 0) )
                {
                    ASSERT(fSwmrLocked);

                    AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
                    AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
                }
            }

            ThisVolItems++;

			if (!(((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE))
			{
				(*pNotifyQueueCount) --;
			}

			ASSERT(VALID_VOLDESC(pVolDesc));


			// The volume is already referenced for the notification processing.
			// Dereference after finishing processing.
			if ((pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED)) == 0)
			{
#ifndef BLOCK_MACS_DURING_NOTIFYPROC
				AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
#endif
				(*pVolNotify->vn_Processor)(pVolNotify);
#ifndef BLOCK_MACS_DURING_NOTIFYPROC
				AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
#endif
			}

			AfpVolumeDereference(pVolDesc);

		 	// was this a private notify?
			if (((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE)
			{
				// Free	virtual memory
				afpFreeNotify(pVolNotify);
			}
			else
			{
				// Free	non-paged memory
				AfpFreeMemory(pVolNotify);
			}

#ifdef	PROFILING
			AfpGetPerfCounter(&TimeE);
			TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
			INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ChangeNotifyTime,
										 TimeD,
										 &AfpStatisticsLock);
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_ChangeNotifyCount);
#endif

			if (*pNotifyQueueCount > 0)
				continue;
		}

        //
        // release the lock for the volume we just finished
        //
        if ((pCurrVolDesc) && (fSwmrLocked))
        {
		    AfpSwmrRelease(&pCurrVolDesc->vds_IdDbAccessLock);

            // remove that ref we put before grabbing the swmr lock
            AfpVolumeDereference(pCurrVolDesc);
        }

		// If we timed out because there was nothing in the queue, or we
		// just processed the last thing in the queue, then see if there are
		// more things that can be moved into the queue.
		InitializeListHead(&TransitionList);

		// Look at the list to see if some stuff should move to the
		// Queue now i.e. if the delta has elapsed since we were notified of this change
		AfpGetCurrentTimeInMacFormat(&CurrentTime);

		ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

		while (!IsListEmpty(pNotifyList))
		{
			pList = RemoveHeadList(pNotifyList);
			pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
			pVolDesc = pVolNotify->vn_pVolDesc;

			if ((pVolNotify->vn_TimeStamp == AFP_QUEUE_NOTIFY_IMMEDIATELY) ||
				((CurrentTime - pVolNotify->vn_TimeStamp) >= VOLUME_NTFY_DELAY) ||
				(pVolDesc->vds_Flags & (VOLUME_STOPPED | VOLUME_DELETED)))
			{
				AfpNotifyListCount[(LONG_PTR)pContext] --;
				(*pNotifyQueueCount) ++;
				// Build up a list of items to queue up outside the spinlock
				// since we will want to take the IdDb swmr for any volume
				// which has notifies that we are about to process.
				// Make sure you add things so they are processed in the
				// order they came in with!!
				InsertTailList(&TransitionList, pList);
			}
			else
			{
				// Put it back where we we took it from - its time has not come yet
				// And we are done now since the list is ordered in time.
				InsertHeadList(pNotifyList, pList);
				break;
			}
		}

		RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

		while (!IsListEmpty(&TransitionList))
		{
            pList = TransitionList.Flink;
			pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
			pCurrVolDesc = pVolNotify->vn_pVolDesc;

            //
            // walk the entire list and collect all the items that belong to the
            // same VolDesc and put them on the list.  This way we take the swmr
            // lock only for the volume we are working on
            //
            while (pList != &TransitionList)
            {
			    pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
			    pVolDesc = pVolNotify->vn_pVolDesc;
                pNext = pList->Flink;
                if (pVolDesc == pCurrVolDesc)
                {
                    RemoveEntryList(pList);
					AfpVolumeQueueChangeNotify (pVolNotify, NotifyQueue);	
					//InsertTailList(pVirtualNotifyList, pList);
                }
                pList = pNext;
            }
		}

        pCurrVolDesc = NULL;

	} while (True);

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AfpChangeNotifyThread: Quitting %ld\n", pContext));

	// Raise the priority of the current thread, so that this thread
	// completes before any other thread interrupts it
	NtSetInformationThread (
					NtCurrentThread( ),
					ThreadBasePriority,
					&ShutdownPriority,
					sizeof(ShutdownPriority)
				);

	AfpThreadPtrsW[(LONG_PTR)pContext] = NULL;
	KeSetEvent(&AfpStopConfirmEvent, IO_NETWORK_INCREMENT, False);
	Status = PsTerminateSystemThread (STATUS_SUCCESS);
	ASSERT (NT_SUCCESS(Status));
}


/***	AfpProcessChangeNotify
 *
 * A change item has been dequeued by one of the notify processing threads.
 *
 *	LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
VOID FASTCALL
AfpProcessChangeNotify(
	IN	PVOL_NOTIFY			pVolNotify
)
{
	PVOLDESC					pVolDesc;
	UNICODE_STRING				UName, UParent, UTail;
	PFILE_NOTIFY_INFORMATION	pFNInfo;
	BOOLEAN						CleanupHandle;
	PLIST_ENTRY					pList;
	NTSTATUS					status;
	PDFENTRY					pDfEntry;
	FILESYSHANDLE				handle;
	DWORD						afpChangeAction;
	DWORD						StreamId;
	PFILE_BOTH_DIR_INFORMATION	pFBDInfo = NULL;
	LONG						infobuflen;
        LONGLONG                        infobuf[(sizeof(FILE_BOTH_DIR_INFORMATION) + (AFP_LONGNAME_LEN + 1) * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
#if DBG
	static PBYTE	Action[] = { "",
								 "ADDED",
								 "REMOVED",
								 "MODIFIED",
								 "RENAMED OLD",
								 "RENAMED NEW",
								 "STREAM ADDED",
								 "STREAM REMOVED",
								 "STREAM MODIFIED"};
#endif

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpProcessChangeNotify: entered...\n"));

	pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);

	ASSERT((pFNInfo->Action & AFP_ACTION_PRIVATE) == 0);

    pVolDesc = pVolNotify->vn_pVolDesc;
	ASSERT (VALID_VOLDESC(pVolDesc));

	INTERLOCKED_DECREMENT_LONG(&pVolDesc->vds_cOutstandingNotifies);

	StreamId = pVolNotify->vn_StreamId;

	if ( (pFNInfo->Action == FILE_ACTION_REMOVED) ||
		 (pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME) )
	{
		ASSERT(!IsListEmpty(&pVolDesc->vds_ChangeNotifyLookAhead));

		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpProcessChangeNotify: removing %s LookAhead change\n",
				Action[pFNInfo->Action]));

		pList = ExInterlockedRemoveHeadList(&pVolDesc->vds_ChangeNotifyLookAhead,
											&(pVolDesc->vds_VolLock.SpinLock));

		ASSERT(pList == &(pVolNotify->vn_DelRenLink));
	}

	// Process each of the entries in the list for this volume
	while (True)
	{
		CleanupHandle = False;
		status = STATUS_SUCCESS;

		AfpInitUnicodeStringWithNonNullTerm(&UName,
											(USHORT)pFNInfo->FileNameLength,
											pFNInfo->FileName);
		UName.MaximumLength += (AFP_LONGNAME_LEN+1)*sizeof(WCHAR);

		ASSERT(IS_VOLUME_NTFS(pVolDesc) && !EXCLUSIVE_VOLUME(pVolDesc));

		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpProcessChangeNotify: Action: %s Name: %Z\n",
				Action[pFNInfo->Action], &UName));

		do
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					 ("AfpProcessChangeNotify: !!!!Processing Change!!!!\n"));

			// We have the idindex write lock, look up the entry by path,
			// open a handle to the item, query the appropriate info,
			// cache the info in the DFE.  Where necessary, open a handle
			// to the parent directory and update its cached ModTime.

		  Lookup_Entry:
			pDfEntry = afpFindEntryByNtPath(pVolDesc,
											pFNInfo->Action,
											&UName,
											&UParent,
											&UTail);
			if (pDfEntry != NULL)
			{
				// Open a handle to parent or entity relative to the volume root handle
				CleanupHandle = True;
				status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								   StreamId,
								   FILEIO_OPEN_EITHER,
								   ((pFNInfo->Action == FILE_ACTION_ADDED) ||
									(pFNInfo->Action == FILE_ACTION_REMOVED) ||
									(pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME)) ?
										&UParent : &UName,
								   FILEIO_ACCESS_NONE,
								   FILEIO_DENY_NONE,
								   False,
								   &handle);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("AfpProcessChangeNotify: Failed to open (0x%lx) for %Z\n", status, &UName));

					if (pFNInfo->Action == FILE_ACTION_ADDED) {

						// Add the full-pathname of file relative to volume root
						// to the DelayedNotifyList for the current VolumeDesc
						// We assume here that the filename relative to the
						// volume path will not be greater than 512
						// characters (unicode)

						status = AddToDelayedNotifyList(pVolDesc, &UName);
						if (!NT_SUCCESS(status)) {
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
									("AfpProcessChangeNotify: Error in addToDelayedList (0x%lx)\n", status));
							break;
						}
					}

					CleanupHandle = False;
					break;
				}

				switch (pFNInfo->Action)
				{
					case FILE_ACTION_ADDED:
					{
						UNICODE_STRING	UEntity;
						UNICODE_STRING	UTemp;
						PDFENTRY		pDfeNew;
						FILESYSHANDLE	fshEnumDir;
						BOOLEAN			firstEnum = True;
						ULONG			fileLength;

						// Update timestamp of parent dir.
						AfpIoQueryTimesnAttr(&handle,
											 NULL,
											 &pDfEntry->dfe_LastModTime,
											 NULL);

						// enumerate parent handle for this entity to get
						// the file/dir info, then add entry to the IDDB
						/*
						if ((UTail.Length/sizeof(WCHAR)) <= AFP_LONGNAME_LEN)
						*/
						// Bug 311023
						fileLength = RtlUnicodeStringToAnsiSize(&UTail)-1;
						if (fileLength <= AFP_LONGNAME_LEN)
						{
							pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)infobuf;
							infobuflen = sizeof(infobuf);
						}
						else
						{
							infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
											  (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));
							if ((pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
											AfpAllocNonPagedMemory(infobuflen)) == NULL)
							{
								status = STATUS_NO_MEMORY;
								break; // out of case FILE_ACTION_ADDED
							}
						}

						do
						{
							status = AfpIoQueryDirectoryFile(&handle,
															 pFBDInfo,
															 infobuflen,
															 FileBothDirectoryInformation,
															 True,
															 True,
															 firstEnum ? &UTail : NULL);
							if ((status == STATUS_BUFFER_TOO_SMALL) ||
								(status == STATUS_BUFFER_OVERFLOW))
							{
								// Since we queue our own ACTION_ADDED for directories when
								// caching a tree, we may have the case where we queued it
								// by shortname because it actually had a name > 31 chars.
								// Note that a 2nd call to QueryDirectoryFile after a buffer
								// Overflow must send a null filename, since if the name is
								// not null, it will override the restartscan parameter
								// which means the scan will not restart from the beginning
								// and we will not find the file name we are looking for.

								ASSERT((PBYTE)pFBDInfo == (PBYTE)infobuf);

								// This should never happen, but if it does...
								if ((PBYTE)pFBDInfo != (PBYTE)infobuf)
								{
									status = STATUS_UNSUCCESSFUL;
									break;
								}

								firstEnum = False;

								infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
													(MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));

								if ((pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
													AfpAllocNonPagedMemory(infobuflen)) == NULL)
									status = STATUS_NO_MEMORY;
							}
						} while ((status == STATUS_BUFFER_TOO_SMALL) ||
								 (status == STATUS_BUFFER_OVERFLOW));

						if (status == STATUS_SUCCESS)
						{
							// If this file was created in a directory that has
							// not been looked at by a mac, just ignore it.
							// If this was not a FILE_ACTION_ADDED we would not
							// have found it in the database at all if it was
							// a file and the parent has not had its file
							// children cached in, so we will ignore those
							// notifies by default anyway since the DFE would
							// come back as NULL from afpFindEntryByNtPath.
							// We *do* want to process changes for directories
							// even if the parent has not had its
							// file children brought in since directories
							// are only cached in once at volume startup.
							if (((pFBDInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) &&
								!DFE_CHILDREN_ARE_PRESENT(pDfEntry))
							{
								break;
							}

							// figure out which name to use
							// If NT name > AFP_LONGNAME_LEN, use the NT shortname for
							// Mac longname on NTFS, any other file system the shortname
							// will be null, so ignore the file
							// Bug 311023
							AfpInitUnicodeStringWithNonNullTerm(&UTemp,
									(USHORT)pFBDInfo->FileNameLength,
									pFBDInfo->FileName);
							fileLength=RtlUnicodeStringToAnsiSize(&UTemp)-1;
							if (fileLength <= AFP_LONGNAME_LEN)
							{
								AfpInitUnicodeStringWithNonNullTerm(&UEntity,
																	(USHORT)pFBDInfo->FileNameLength,
																	pFBDInfo->FileName);
							}
							else if (pFBDInfo->ShortNameLength > 0)
							{
								AfpInitUnicodeStringWithNonNullTerm(&UEntity,
																	(USHORT)pFBDInfo->ShortNameLength,
																	pFBDInfo->ShortName);
							}
							else
							{
								DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
										("AfpProcessChangeNotify: Name is > 31 with no short name ?\n") );
								status = STATUS_UNSUCCESSFUL;
							}

							if (NT_SUCCESS(status))
							{
								// add the entry
								afpAddDfEntryAndCacheInfo(pVolDesc,
														  pDfEntry,
														  &UEntity,
														  &handle,
														  pFBDInfo,
														  &UName,
														  &pDfeNew,
														  True);

								if (pDfeNew == NULL)
								{
									DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
										("AfpProcessChangeNotify: Could not add DFE for %Z\n", &UName));
								}
								else if (DFE_IS_DIRECTORY(pDfeNew))
								{
									// if a directory was added, we must see if it has
									// children that we must cache as well
									if (NT_SUCCESS(status = AfpIoOpen(&pVolDesc->vds_hRootDir,
																	  AFP_STREAM_DATA,
																	  FILEIO_OPEN_DIR,
																	  &UName,
																	  FILEIO_ACCESS_NONE,
																	  FILEIO_DENY_NONE,
																	  False,
																	  &fshEnumDir)))
									{
										status = AfpCacheDirectoryTree(pVolDesc,
																	   pDfeNew,
																	   GETENTIRETREE | REENUMERATE,
																	   &fshEnumDir,
																	   &UName);
										AfpIoClose(&fshEnumDir);
										if (!NT_SUCCESS(status))
										{
											DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
													("AfpProcessChangeNotify: Could not cache dir tree for %Z\n",
													&UName) );
										}
									}
									else
									{
										DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
												("AfpProcessChangeNotify: Added dir %Z but couldn't open it for enumerating\n", &UName) );
									}
								}
							}
						}

						if (((PBYTE)pFBDInfo != NULL) &&
							((PBYTE)pFBDInfo != (PBYTE)infobuf))
						{
							AfpFreeMemory(pFBDInfo);
							pFBDInfo = NULL;
						}
					}
					break;

					case FILE_ACTION_REMOVED:
					{
						// Remove entries from DelayedNotifyList for the
						// volume belonging to the directory which is
						// being removed since they need not be added to
						// the IDDB after this
						status = RemoveFromDelayedNotifyList(
										pVolDesc,
										&UName,
										pFNInfo
										);
						if (!NT_SUCCESS(status)) {
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
								("Error in RemoveFromDelayedNotifyList 0x%lx\n", status));
						}

						// update timestamp of parent dir.
						AfpIoQueryTimesnAttr(&handle,
											 NULL,
											 &pDfEntry->dfe_Parent->dfe_LastModTime,
											 NULL);
						// remove entry from IDDb.
						AfpDeleteDfEntry(pVolDesc, pDfEntry);
					}
					break;

					case FILE_ACTION_MODIFIED:
					{
						FORKSIZE forklen;
						DWORD	 NtAttr;

						// NOTE: if a file is SUPERSEDED or OVERWRITTEN,
						// you will only get a MODIFIED notification.  Is
						// there a way to check the creation date against
						// what we have cached in order to figure out if
						// this is what happened?

						// query for times and attributes.  If its a file,
						// also query for the data fork length.
						if (NT_SUCCESS(AfpIoQueryTimesnAttr(&handle,
															&pDfEntry->dfe_CreateTime,
															&pDfEntry->dfe_LastModTime,
															&NtAttr)))
						{
							pDfEntry->dfe_NtAttr = (USHORT)NtAttr &
														 FILE_ATTRIBUTE_VALID_FLAGS;
						}
						if (DFE_IS_FILE(pDfEntry) &&
							NT_SUCCESS(AfpIoQuerySize(&handle, &forklen)))
						{
							pDfEntry->dfe_DataLen = forklen.LowPart;
						}
					}
					break;

					case FILE_ACTION_RENAMED_OLD_NAME:
					{
						UNICODE_STRING				UNewname;
						PFILE_NOTIFY_INFORMATION	pFNInfo2;
						ULONG						fileLength;
						BOOLEAN						checkIfDirectory=False;

						status = STATUS_SUCCESS;

						// The next item in the change buffer better be the
						// new name -- consume this entry so we don't find
						// it next time thru the loop.  If there is none,
						// then throw the whole thing out and assume the
						// rename aborted in NTFS
						if (pFNInfo->NextEntryOffset == 0)
							break; // from switch

						// If the next change in the buffer is not the
						// new name, we don't want to advance over it,
						// we want it to be processed next time thru
						// the loop. Note we are assuming it is valid.
						(PBYTE)pFNInfo2 = (PBYTE)pFNInfo + pFNInfo->NextEntryOffset;
						ASSERT(pFNInfo2->Action == FILE_ACTION_RENAMED_NEW_NAME);
						if (pFNInfo2->Action != FILE_ACTION_RENAMED_NEW_NAME)
						{
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
									("AfpProcessChangeNotify: Rename did not come with new name!!!\n"));
							break; // from switch
						}

						pFNInfo = pFNInfo2;

						// update timestamp of parent dir.
						AfpIoQueryTimesnAttr(&handle,
											 NULL,
											 &pDfEntry->dfe_Parent->dfe_LastModTime,
											 NULL);

						// get the entity name from the path (subtract the
						// parent path length from total length), if it is
						// > 31 chars, we have to get the shortname by
						// enumerating the parent for this item, since we
						// already have a handle to the parent
						AfpInitUnicodeStringWithNonNullTerm(&UNewname,
															(USHORT)pFNInfo->FileNameLength,
															pFNInfo->FileName);

						if (DFE_IS_DIRECTORY(pDfEntry))
						{
							checkIfDirectory = True;
						}


						if (UParent.Length > 0)
						{
							// if the rename is not in the volume root,
							// get rid of the path separator before the name
							UNewname.Length -= UParent.Length + sizeof(WCHAR);
							UNewname.Buffer = (PWCHAR)((PBYTE)UNewname.Buffer + UParent.Length + sizeof(WCHAR));
						}

						// Bug 311023
						fileLength = RtlUnicodeStringToAnsiSize(&UNewname)-1;
						if (fileLength > AFP_LONGNAME_LEN)
						{
							infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
									  (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));
							if ((pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
									AfpAllocNonPagedMemory(infobuflen)) == NULL)
							{
								status = STATUS_NO_MEMORY;
								break; // out of case FILE_ACTION_RENAMED
							}

							status = AfpIoQueryDirectoryFile(&handle,
															 pFBDInfo,
															 infobuflen,
															 FileBothDirectoryInformation,
															 True,
															 True,
															 &UNewname);
							if (status == STATUS_SUCCESS)
							{
								// figure out which name to use
								// If NT name > AFP_LONGNAME_LEN, use the NT shortname for
								// Mac longname on NTFS, any other file system the shortname
								// will be null, so ignore the file
								// Bug 311023
								AfpInitUnicodeStringWithNonNullTerm(
										&UNewname,
										(USHORT)
										pFBDInfo->FileNameLength,
										pFBDInfo->FileName);
								fileLength=RtlUnicodeStringToAnsiSize(&UNewname)-1;
								if (fileLength <= AFP_LONGNAME_LEN)
								{
									AfpInitUnicodeStringWithNonNullTerm(&UNewname,
																		(USHORT)pFBDInfo->FileNameLength,
																		pFBDInfo->FileName);
								}
								else if (pFBDInfo->ShortNameLength > 0)
								{
									AfpInitUnicodeStringWithNonNullTerm(&UNewname,
																		(USHORT)pFBDInfo->ShortNameLength,
																		pFBDInfo->ShortName);
								}
								else
								{
									DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
											("AfpProcessChangeNotify: Name is > 31 with no short name ?\n") );
									status = STATUS_UNSUCCESSFUL;
								}
							}
						}

						// rename the entry
						if (NT_SUCCESS(status))
						{
							AfpRenameDfEntry(pVolDesc, pDfEntry, &UNewname);
						}

						// Check if a directory is being renamed
						// If yes, check if there are any files/directories
						// which were not added to the IDDB due to ChangeNotify
						// requests getting delayed
						if (checkIfDirectory) {

							status = CheckAndProcessDelayedNotify (
									pVolDesc,
									&UName,
									&UNewname,
									&UParent
									);
						
							if (!NT_SUCCESS(status))
							{
								DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
										("Error in CheckAndProcessDelayedNotify 0x%lx\n", status));
							}

						}

						if ((PBYTE)pFBDInfo != NULL)
						{
							AfpFreeMemory(pFBDInfo);
							pFBDInfo = NULL;
						}
					}
					break;

					case FILE_ACTION_MODIFIED_STREAM:
					{
						FORKSIZE forklen;

						// If it is the AFP_Resource stream on a file,
						// cache the resource fork length.
						if ((StreamId == AFP_STREAM_RESC) &&
							DFE_IS_FILE(pDfEntry) &&
							NT_SUCCESS(AfpIoQuerySize(&handle, &forklen)))
						{
							pDfEntry->dfe_RescLen = forklen.LowPart;
						}
						else if (StreamId == AFP_STREAM_INFO)
						{
							AFPINFO		afpinfo;
							FILEDIRPARM fdparms;

							// Read the afpinfo stream.  If the file ID in
							// the DfEntry does not match the one in the
							// stream, write back the ID we know it by.
							// Update our cached FinderInfo.
							if (NT_SUCCESS(AfpReadAfpInfo(&handle, &afpinfo)))
							{
								pDfEntry->dfe_FinderInfo = afpinfo.afpi_FinderInfo;
								pDfEntry->dfe_BackupTime = afpinfo.afpi_BackupTime;

								if (pDfEntry->dfe_AfpId != afpinfo.afpi_Id)
								{
									// munge up a fake FILEDIRPARMS structure
                                    AfpInitializeFDParms(&fdparms);
									fdparms._fdp_Flags = pDfEntry->dfe_Flags;
									fdparms._fdp_AfpId = pDfEntry->dfe_AfpId;
									AfpConvertMungedUnicodeToAnsi(&pDfEntry->dfe_UnicodeName,
																  &fdparms._fdp_LongName);

									// NOTE: can we open a handle to afpinfo
									// relative to a afpinfo handle??
									AfpSetAfpInfo(&handle,
												  FILE_BITMAP_FILENUM,
												  &fdparms,
												  NULL,
												  NULL);
								}
							}
						}
					}
					break; // from switch

					default:
						ASSERTMSG("AfpProcessChangeNotify: Unexpected Action\n", False);
						break;
				} // switch
			}
			else
			{
				PFILE_NOTIFY_INFORMATION	pFNInfo2;

				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
						("AfpProcessChangeNotify: Could not find DFE for %Z\n", &UName));

				// This item may have been deleted, renamed or moved
				// by someone else in the interim, ignore this change
				// if it was not a rename.  If it was a rename, then
				// try to add the item using the new name.
				if ((pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME) &&
					(pFNInfo->NextEntryOffset != 0))
				{
					// If the next change in the buffer is not the
					// new name, we don't want to advance over it,
					// we want it to be processed next time thru
					// the loop. Note we are assuming it is valid.
					(PBYTE)pFNInfo2 = (PBYTE)pFNInfo + pFNInfo->NextEntryOffset;
					ASSERT(pFNInfo2->Action == FILE_ACTION_RENAMED_NEW_NAME);
					if (pFNInfo2->Action != FILE_ACTION_RENAMED_NEW_NAME)
					{
						DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
								("AfpProcessChangeNotify: Rename did not come with new name!!! (no-DFE case)\n"));
						break; // from error loop
					}

					pFNInfo = pFNInfo2;

					pFNInfo->Action = FILE_ACTION_ADDED;

					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pFNInfo->FileNameLength,
														pFNInfo->FileName);

					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
							("AfpProcessChangeNotify: Converting RENAME into Action: %s for Name: %Z\n",
							Action[pFNInfo->Action], &UName));

					goto Lookup_Entry;
				}
			}
		} while (False);

		if (CleanupHandle)
			AfpIoClose(&handle);

		// Advance to the next entry in the change buffer
		if (pFNInfo->NextEntryOffset == 0)
		{
			break;
		}
		(PBYTE)pFNInfo += pFNInfo->NextEntryOffset;
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
				("More than one entry in notify ?\n"));
	}

	// Get new values for Free space on disk and update volume time
	AfpUpdateVolFreeSpaceAndModTime(pVolDesc, TRUE);
}

/***	AddToDelayedNotifyList
 *
 *  Add Pathname of delayed notify for added file to DelayedNotifyList of the
 *  corresponding volume
 *
 *	LOCKS_ASSUMED: none
 */
NTSTATUS FASTCALL
AddToDelayedNotifyList(
	IN PVOLDESC         pVolDesc,
	IN PUNICODE_STRING  pUName
)
{
	KIRQL		OldIrql;
	PDELAYED_NOTIFY pDelayedNotify;
	NTSTATUS status = STATUS_SUCCESS;

	pDelayedNotify = (PDELAYED_NOTIFY)AfpAllocNonPagedMemory (sizeof(DELAYED_NOTIFY));
	if (pDelayedNotify == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		return status;
	}

	pDelayedNotify->filename.Length = 0;
	pDelayedNotify->filename.MaximumLength = pUName->MaximumLength;
	pDelayedNotify->filename.Buffer = (PWSTR)AfpAllocNonPagedMemory(pUName->MaximumLength);
	if (pDelayedNotify->filename.Buffer == NULL)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
        AfpFreeMemory(pDelayedNotify);
		return status;
	}

	RtlCopyUnicodeString(&pDelayedNotify->filename, pUName);

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
	InsertHeadList (&pVolDesc->vds_DelayedNotifyList, &pDelayedNotify->dn_List);
	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	return status;
}


/***	RemoveFromDelayedNotifyList
 *
 *  Remove entry from DelayedNotifyList for files which are within the
 *  directory that was deleted
 *
 *	LOCKS_ASSUMED: none
 */
NTSTATUS
RemoveFromDelayedNotifyList (
	IN PVOLDESC pVolDesc,
	IN PUNICODE_STRING pUName,
	IN PFILE_NOTIFY_INFORMATION    pFNInfo
)
{
	PLIST_ENTRY 		pList, pNext;
	PDELAYED_NOTIFY 	pDelayedNotify;
	KIRQL				OldIrql;	
	NTSTATUS			status=STATUS_SUCCESS;


    AfpInitUnicodeStringWithNonNullTerm(pUName,
			(USHORT)pFNInfo->FileNameLength,
			pFNInfo->FileName);

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpProcessChangeNotify: Going to remove %Z \n", pUName));
	
	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	if (!IsListEmpty(&pVolDesc->vds_DelayedNotifyList)) {

		pList = pVolDesc->vds_DelayedNotifyList.Flink;

		while (pList != &pVolDesc->vds_DelayedNotifyList)
		{
		
			pDelayedNotify = CONTAINING_RECORD (pList, DELAYED_NOTIFY, dn_List);
			pNext = pList->Flink;

			if (pDelayedNotify->filename.Length >= pUName->Length)
			{
				if (RtlCompareMemory ((PVOID)pUName->Buffer, (PVOID)pDelayedNotify->filename.Buffer, pUName->Length) == pUName->Length) {
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR, ("AfpProcessChangeNotify: Correction no longer to be done for %Z\n", &pDelayedNotify->filename));
					RemoveEntryList(pList);
					AfpFreeMemory(pDelayedNotify->filename.Buffer);
					AfpFreeMemory(pDelayedNotify);
				}
			}

			pList = pNext;
		}
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	return status;
}
							
/***	CheckAndProcessDelayedNotify
 *
 *  Check if the directory being renamed had entries that were not added to
 *  the IDDB. Rename the entries and issue new FILE_ACTION_ADDED ChangeNotify
 *  requests as if the NTFS filesystem has made the requests
 *
 *	LOCKS_ASSUMED: none
 */
NTSTATUS
CheckAndProcessDelayedNotify (
	IN PVOLDESC			pVolDesc,
	IN PUNICODE_STRING	pUName,
	IN PUNICODE_STRING	pUNewname,
	IN PUNICODE_STRING	pUParent
)
{
	PLIST_ENTRY                 pList;
	PDELAYED_NOTIFY             pDelayedNotify;
	KIRQL			            OldIrql;
	NTSTATUS		            status = STATUS_SUCCESS;
    PFILE_NOTIFY_INFORMATION    pFNInfo;
	PDFENTRY                    pParentDfEntry;
	UNICODE_STRING              newNotifyName;
	PVOL_NOTIFY	                pVolNotify;
										

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    pList = pVolDesc->vds_DelayedNotifyList.Flink;

    while (1)
    {
        // finished the list?
        if (pList == &pVolDesc->vds_DelayedNotifyList)
        {
            RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
            break;
        }

		pDelayedNotify = CONTAINING_RECORD (pList, DELAYED_NOTIFY, dn_List);

        pList = pList->Flink;

		if (pDelayedNotify->filename.Length < pUName->Length)
		{
            continue;
		}

		if (RtlCompareMemory ((PVOID)pUName->Buffer,
                              (PVOID)pDelayedNotify->filename.Buffer,
                              pUName->Length) == pUName->Length)
        {

			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                ("AfpProcessChangeNotify: Correction required to be done for %Z\n", &pDelayedNotify->filename));

			RemoveEntryList(&pDelayedNotify->dn_List);
            RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

			if ((newNotifyName.Buffer = (PWSTR)AfpAllocNonPagedMemory(1024)) == NULL)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
                AfpFreeMemory(pDelayedNotify->filename.Buffer);
                AfpFreeMemory(pDelayedNotify);
				return status;
			};

			newNotifyName.Length = 0;
			newNotifyName.MaximumLength = 1024;
										
			if (pUParent->Length > 0)
			{
				RtlCopyUnicodeString (&newNotifyName, pUName);
					
				// Copy the Parent name and the "/" separator and then the new name
				RtlCopyMemory (newNotifyName.Buffer + pUParent->Length/2 + 1,
						pUNewname->Buffer, pUNewname->Length);
				newNotifyName.Length = pUParent->Length + pUNewname->Length + 2;
			}
			else
			{
				RtlCopyUnicodeString (&newNotifyName, pUNewname);
			}	

			RtlAppendUnicodeToString (&newNotifyName,
					pDelayedNotify->filename.Buffer + pUName->Length/2);

			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
                ("AfpProcessChangeNotify: After correction, name = %Z, Old=%Z, New=%Z, chgto=%Z\n",
                &pDelayedNotify->filename, pUName, pUNewname, &newNotifyName));

			pVolNotify = (PVOL_NOTIFY)AfpAllocNonPagedMemory(
                                                sizeof(VOL_NOTIFY) +
                                                (ULONG)(newNotifyName.Length) +
                                                sizeof(FILE_NOTIFY_INFORMATION) +
                                                (AFP_LONGNAME_LEN + 1)*sizeof(WCHAR));

		    if (pVolNotify != NULL)
			{
				AfpGetCurrentTimeInMacFormat(&pVolNotify->vn_TimeStamp);
				pVolNotify->vn_pVolDesc = pVolDesc;
				pVolNotify->vn_Processor = AfpProcessChangeNotify;
				pVolNotify->vn_StreamId = AFP_STREAM_DATA;
				pVolNotify->vn_TailLength = newNotifyName.Length;
				pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
				pFNInfo->Action = FILE_ACTION_ADDED;
				pFNInfo->NextEntryOffset = 0;
				pFNInfo->FileNameLength = newNotifyName.Length;

				RtlCopyMemory((PVOID)&pFNInfo->FileName,
							(PVOID)newNotifyName.Buffer,
							newNotifyName.Length);

				if (AfpVolumeReference(pVolDesc))
				{
					AfpVolumeInsertChangeNotifyList(pVolNotify, pVolDesc);
				}
			}
			else
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,("Out of memory!!\n"));
				ASSERT(0);
				status = STATUS_INSUFFICIENT_RESOURCES;
				AfpFreeMemory(newNotifyName.Buffer);
                AfpFreeMemory(pDelayedNotify->filename.Buffer);
                AfpFreeMemory(pDelayedNotify);
				return status;
			}

			AfpFreeMemory(pDelayedNotify->filename.Buffer);
            AfpFreeMemory(pDelayedNotify);
			AfpFreeMemory(newNotifyName.Buffer);

            ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
            pList = pVolDesc->vds_DelayedNotifyList.Flink;   // start from the head again

		}
	}
	
	return status;
}

/***	afpProcessPrivateNotify
 *
 *	Similar to AfpProcessChangeNotify but optimized/special-cased for private notifies.
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
VOID FASTCALL
afpProcessPrivateNotify(
	IN	PVOL_NOTIFY			pVolNotify
)
{
	PVOLDESC					pVolDesc;
	UNICODE_STRING				UName;
	PFILE_NOTIFY_INFORMATION	pFNInfo;
	NTSTATUS					status;
	PDFENTRY					pParentDFE;
	BOOLEAN						CloseParentHandle = False, Verify = True;
    BOOLEAN                     DirModified=TRUE;
    BOOLEAN                     fNewVolume=FALSE;
	PFILE_BOTH_DIR_INFORMATION	pFBDInfo;
    LONGLONG                    infobuf[(sizeof(FILE_BOTH_DIR_INFORMATION) +
                (AFP_LONGNAME_LEN + 1) * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
    LONG                        infobuflen;
    BOOLEAN                     fMemAlloced=FALSE;


	PAGED_CODE( );

	pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
	ASSERT (pFNInfo->Action & AFP_ACTION_PRIVATE);

	pVolDesc = pVolNotify->vn_pVolDesc;
	ASSERT (VALID_VOLDESC(pVolDesc));

	INTERLOCKED_DECREMENT_LONG(&pVolDesc->vds_cPrivateNotifies);

    if (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS)
    {
        fNewVolume = TRUE;
    }

	pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)infobuf;
	AfpInitUnicodeStringWithNonNullTerm(&UName,
										(USHORT)pFNInfo->FileNameLength,
										pFNInfo->FileName);
	// We always allocate extra space for notifies
	UName.MaximumLength += (AFP_LONGNAME_LEN+1)*sizeof(WCHAR);

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("ParentId %d, Path: %Z\n",pVolNotify->vn_ParentId, &UName));

	// Lookup the parent DFE using the AfpId stored in the notify
	// structure, and setup the UParent and UTail appropriately
	pParentDFE = AfpFindDfEntryById(pVolDesc,
									pVolNotify->vn_ParentId,
									DFE_DIR);
	if (pParentDFE != NULL)
	{
		FILESYSHANDLE	ParentHandle, DirHandle;

		status = STATUS_SUCCESS;

		// Open a handle to the directory relative to the volume root handle
		// Special case volume root
		ASSERT((UName.Length != 0) || (pVolNotify->vn_ParentId == AFP_ID_ROOT));

		do
		{
			PDFENTRY		pDfeNew;
			UNICODE_STRING	UParent, UTail;

			if (pVolNotify->vn_ParentId == AFP_ID_ROOT)
			{
				AfpSetEmptyUnicodeString(&UParent, 0, NULL);
				UTail = UName;
			}
			else
			{
				UParent.MaximumLength =
				UParent.Length = UName.Length - (USHORT)pVolNotify->vn_TailLength - sizeof(WCHAR);
				UParent.Buffer = UName.Buffer;

				UTail.MaximumLength =
				UTail.Length = (USHORT)pVolNotify->vn_TailLength;
				UTail.Buffer = (PWCHAR)((PBYTE)UName.Buffer + UParent.Length + sizeof(WCHAR));
			}

			if (UName.Length != 0)
			{
				// Open a handle to parent relative to the volume root handle
				status = AfpIoOpen(&pVolDesc->vds_hRootDir,
								   AFP_STREAM_DATA,
								   FILEIO_OPEN_DIR,
								   &UParent,
								   FILEIO_ACCESS_NONE,
								   FILEIO_DENY_NONE,
								   False,
								   &ParentHandle);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("afpProcessPrivateNotify: Failed to open parent: %Z (0x%lx)\n",
							&UParent, status));
					break;
				}

				CloseParentHandle = True;


				status = AfpIoQueryDirectoryFile(&ParentHandle,
												 pFBDInfo,
												 sizeof(infobuf),
												 FileBothDirectoryInformation,
												 True,
												 True,
												 &UTail);

                //
                // dir name longer than 31 char? Then we must allocate a buffer
                //
                if ((status == STATUS_BUFFER_OVERFLOW) ||
                    (status == STATUS_BUFFER_TOO_SMALL))
                {
                    infobuflen = sizeof(FILE_BOTH_DIR_INFORMATION) +
                                    (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR));

                    pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)
                                    AfpAllocNonPagedMemory(infobuflen);

                    if (pFBDInfo == NULL)
                    {
                        status = STATUS_NO_MEMORY;
                        break;
                    }

                    fMemAlloced = TRUE;

				    status = AfpIoQueryDirectoryFile(&ParentHandle,
					        						 pFBDInfo,
							        				 infobuflen,
									        		 FileBothDirectoryInformation,
											         True,
											         True,
											         &UTail);

                }

                if (!NT_SUCCESS(status))
                {
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("afpProcessPrivateNotify: AfpIoQueryDirectoryFile failed: %d %Z at %Z(0x%lx)\n",
							sizeof(infobuf),&UTail, &UParent,status));
					break;
				}

				// Lookup this entry in the data-base. If not there then we need to add
				// it. If its there, we need to verify it.
				// NOTE: Use DFE_ANY here and not DFE_DIR !!!
				pDfeNew = AfpFindEntryByUnicodeName(pVolDesc,
													&UTail,
													AFP_LONGNAME,
													pParentDFE,
													DFE_ANY);
				if (pDfeNew == NULL)
                {
					Verify = False;
                }
			}
			else
			{
				FILE_BASIC_INFORMATION	FBasInfo;


				status = AfpIoQueryBasicInfo(&pVolDesc->vds_hRootDir,
											 &FBasInfo);
				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
							("afpProcessPrivateNotify: Could not get basic information for root\n"));
					status = STATUS_UNSUCCESSFUL;
					break;
				}

				afpConvertBasicToBothDirInfo(&FBasInfo, pFBDInfo);
				pDfeNew = pParentDFE;
				ParentHandle = pVolDesc->vds_hRootDir;

				// Root directory needs special casing. The reason here is that we have
				// no parent directory. Also we need to handle the AFP_HAS_CUSTOM_ICON
				// bit in the volume descriptor since the finderinfo on the root volume
				// doesn't have this bit saved.
				if (pVolDesc->vds_Flags & AFP_VOLUME_HAS_CUSTOM_ICON)
				{
					pDfeNew->dfe_FinderInfo.fd_Attr1 |= FINDER_FLAG_HAS_CUSTOM_ICON;
				}
			}

			if (!Verify)
			{
				ASSERT(pDfeNew == NULL);
				afpAddDfEntryAndCacheInfo(pVolDesc,
										  pParentDFE,
										  &UTail,
										  &ParentHandle,
										  pFBDInfo,
										  &UName,
										  &pDfeNew,
										  False);
			}
			else if (pFBDInfo->LastWriteTime.QuadPart > pDfeNew->dfe_LastModTime.QuadPart)
			{
                pDfeNew->dfe_Flags &= ~DFE_FLAGS_INIT_COMPLETED;
				afpVerifyDFE(pVolDesc,
							 pParentDFE,
							 &UTail,
							 &ParentHandle,
							 pFBDInfo,
							 &UName,
							 &pDfeNew);

                DirModified = TRUE;
			}
            else
            {
                DirModified = FALSE;
            }

			if (pDfeNew == NULL)
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
						("afpProcessPrivateNotify: Could not add DFE for %Z\n", &UName));
				status = STATUS_UNSUCCESSFUL;
				break;
			}

			pParentDFE = pDfeNew;

			//
			// Now open the directory itself so that it can be enumerated
			// Open the directory relative to its parent since we already
			// have the parent handle open.
			//
			if (Verify && !DirModified && (pVolNotify->vn_ParentId != AFP_ID_ROOT))
			{
			}
			else
			{
				status = AfpIoOpen(&ParentHandle,
							   AFP_STREAM_DATA,
							   FILEIO_OPEN_DIR,
							   &UTail,
							   FILEIO_ACCESS_NONE,
							   FILEIO_DENY_NONE,
							   False,
							   &DirHandle);

				if (!NT_SUCCESS(status))
				{
					DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
						("afpProcessPrivateNotify: AfpIoOpen failed: %Z (0x%lx)\n",
						 &UTail, status));
					break;
				}
			}
		} while (False);

        if (fMemAlloced)
        {
            ASSERT(pFBDInfo != ((PFILE_BOTH_DIR_INFORMATION)(infobuf)));

	        AfpFreeMemory(pFBDInfo);
        }

		if (CloseParentHandle)
		{
			AfpIoClose(&ParentHandle);
		}

		if (NT_SUCCESS(status))
		{
			DWORD	Method;

			// Always get the root level files

			if (Verify && !DirModified && (pVolNotify->vn_ParentId != AFP_ID_ROOT))
            {
                Method = GETDIRSKELETON;
            }
            else
            {
                Method = (GETENTIRETREE | REENUMERATE);
            }

			status = AfpCacheDirectoryTree(pVolDesc,
										   pParentDFE,
										   Method,
										   &DirHandle,
										   &UName);
			if (!NT_SUCCESS(status))
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
						("afpProcessPrivateNotify: CacheDir failed %lx tree for %Z\n", status,&UName));
			}
			if (Method != GETDIRSKELETON)
			{
				AfpIoClose(&DirHandle);
			}
		}
	}


	afpActivateVolume(pVolDesc);
}


/***	afpActivateVolume
 *
 *	If we just finished caching in the directory structure, activate the volume now.
 *	This is keyed off the AFP_INITIAL_CACHE bit in the volume flags.
 */
VOID FASTCALL
afpActivateVolume(
	IN	PVOLDESC			pVolDesc
)
{
	BOOLEAN	        fCdfs;
	KIRQL	        OldIrql;
	NTSTATUS	    Status = STATUS_SUCCESS;
	UNICODE_STRING	RootName;
    PVOLDESC        pWalkVolDesc;
    IDDBHDR         IdDbHdr;
    BOOLEAN         fPostIrp;
    BOOLEAN         fRetry=TRUE;
	LARGE_INTEGER	ActivationTime;
	ULONG			HighPart;
	ULONG			LowPart;


	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    // if we have more notifies queued up, we aren't done yet
	if (pVolDesc->vds_cPrivateNotifies != 0)
	{
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
        return;
	}


    //
    // ok, we're here because the scan of the volume completed
    //

    //
    // if this was a newly created volume and if this was its first pass, we must
    // post the change-notify irp and restart the scan
    //
	if (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS)
	{
        pVolDesc->vds_Flags &= ~VOLUME_NEW_FIRST_PASS;

        // we post a change notify irp if this volume is not an exclusive volume
		fPostIrp = (!EXCLUSIVE_VOLUME(pVolDesc));

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

		if (fPostIrp)
		{
			// Begin monitoring changes to the tree. Even though we may
			// start processing PC changes before we have finished
			// enumerating the tree, if we get notified of part of the
			// tree we have yet to cache (and therefore can't find it's
			// path in our database its ok, since we will end up
			// picking up the change when we enumerate that branch.  Also,
			// by posting this before starting to cache the tree instead
			// of after, we will pick up any changes that are made to parts
			// of the tree we have already seen, otherwise we would miss
			// those.

			// Explicitly reference this volume for ChangeNotifies and post it
			ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

		    DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				("AfpAdmWVolumeAdd: posting chg-notify irp on volume %Z in second pass\n",
                    &pVolDesc->vds_Name));

			if (AfpVolumeReference(pVolDesc))
            {
			    pVolDesc->vds_RequiredNotifyBufLen = AFP_VOLUME_NOTIFY_STARTING_BUFSIZE;

			    Status = AfpVolumePostChangeNotify(pVolDesc);
			    if (NT_SUCCESS(Status))
			    {
    		        // scan the entire directory tree and sync disk with iddb, now that
                    // we are in the second pass for this (not-so) newly created volume
		            AfpSetEmptyUnicodeString(&RootName, 0, NULL);
		            AfpQueuePrivateChangeNotify(pVolDesc,
			            						&RootName,
				            					&RootName,
					            				AFP_ID_ROOT);
			    }
                else
                {
                    AFPLOG_ERROR(AFPSRVMSG_START_VOLUME,
                                 Status,
                                 NULL,
                                 0,
                                &pVolDesc->vds_Name);

		            DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
				        ("AfpAdmWVolumeAdd: posting chg-notify failed (%lx)!!\n",Status));

                    AfpVolumeDereference(pVolDesc);
                    ASSERT(0);
                }
            }
            else
            {
		        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			        ("AfpAdmWVolumeAdd: couldn't reference volume %Z!!\n",&pVolDesc->vds_Name));
            }

		}
    }

    //
    // ok, we are through with all the passes and the scan is successful:
    // mark the volume as 'officially' available to the clients
    //
	else if (pVolDesc->vds_Flags & VOLUME_INITIAL_CACHE)
	{
		pVolDesc->vds_Flags |=  VOLUME_SCAVENGER_RUNNING;
		pVolDesc->vds_Flags &= ~VOLUME_INITIAL_CACHE;


		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

        // Set the type of the ICON<0d> file to 0's so that
		// mac apps will not list it in their file-open dialogs
		fCdfs = !IS_VOLUME_NTFS(pVolDesc);
		if (!fCdfs)
		{
			PDFENTRY		pdfetmp;
			UNICODE_STRING	iconstr;
			WCHAR			iconname[5] = AFPSERVER_VOLUME_ICON_FILE_ANSI;

			AfpInitUnicodeStringWithNonNullTerm(&iconstr,
												sizeof(iconname),
												iconname);

			if ((pdfetmp = AfpFindEntryByUnicodeName(pVolDesc,
													 &iconstr,
													 AFP_LONGNAME,
													 pVolDesc->vds_pDfeRoot,
													 DFE_FILE)) != NULL)
			{
				pdfetmp->dfe_FinderInfo.fd_TypeD = 0;
			}

			// Kick off the OurChange scavenger scheduled routine
			// Explicitly reference this for the scavenger routine
			if (AfpVolumeReference(pVolDesc))
            {
			    // Schedule the scavenger to run periodically. This scavenger
			    // is queued since it acquires a SWMR.
			    AfpScavengerScheduleEvent(AfpOurChangeScavenger,
				    					  pVolDesc,
					    				  VOLUME_OURCHANGE_AGE,
						    			  False);
            }
            else
            {
		        DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
			        ("afpActivateVolume: couldn't reference volume %Z!!\n",
                    &pVolDesc->vds_Name));
            }

		}

		Status = AfpIoQueryTimesnAttr(&pVolDesc->vds_hRootDir,
								      &pVolDesc->vds_pDfeRoot->dfe_CreateTime,
								      &pVolDesc->vds_pDfeRoot->dfe_LastModTime,
								      NULL);

        pVolDesc->vds_CreateTime = pVolDesc->vds_pDfeRoot->dfe_CreateTime;

        if (NT_SUCCESS(Status))
        {
            pVolDesc->vds_ModifiedTime =
                AfpConvertTimeToMacFormat(&pVolDesc->vds_pDfeRoot->dfe_LastModTime);
        }
        else
        {
            pVolDesc->vds_ModifiedTime = pVolDesc->vds_pDfeRoot->dfe_CreateTime;
        }

		// Kick off the scavenger thread scheduled routine
		// Explicitly reference this for the scavenger routine
		if (AfpVolumeReference(pVolDesc))
        {
            //
            // let's save the index file the way we know it now
            // (setting vds_cScvgrIdDb to 1 will trigger it via scavenger thread)
            //
            if (IS_VOLUME_NTFS(pVolDesc))
            {
                ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);
                pVolDesc->vds_cScvgrIdDb = 1;
                RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
            }


		    // Schedule the scavenger to run periodically. Always make the
		    // scavenger use the worker thread for CD-ROM volumes since we
		    // 'nudge' it every invocation to see if the CD is in the drive
		    AfpScavengerScheduleEvent(AfpVolumeScavenger,
			    					  pVolDesc,
				    				  fCdfs ?
					    				VOLUME_CDFS_SCAVENGER_INTERVAL :
						    			VOLUME_NTFS_SCAVENGER_INTERVAL,
							    	  fCdfs);

            //
            // another workaround for an Apple bug.  If creation date on two
            // volumes is identical, the alias manager gets all confused and points
            // alias for one guy to another!
            // See if this volume's creation date is the same as any of the other
            // volume's creation date: if so, add 1 second
            //
            while (fRetry)
            {
                fRetry = FALSE;

                ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);

                for (pWalkVolDesc = AfpVolumeList;
                     pWalkVolDesc != NULL;
                     pWalkVolDesc = pWalkVolDesc->vds_Next)
                {
                    if (pWalkVolDesc == pVolDesc)
                    {
                        continue;
                    }

                    if (pWalkVolDesc->vds_CreateTime == pVolDesc->vds_CreateTime)
                    {
	                    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			                ("Vol creation date conflict: %Z and %Z.  Hack-o-rama at work\n",
                            &pVolDesc->vds_Name,&pWalkVolDesc->vds_Name));

                        pVolDesc->vds_CreateTime += 1;
                        fRetry = TRUE;
                        break;
                    }
                }

                RELEASE_SPIN_LOCK(&AfpVolumeListLock,OldIrql);
            }

			KeQuerySystemTime (&ActivationTime);

	        DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			    ("afpActivateVolume: volume %Z activated %s at %8lx%08lx , max notifies=%ld\n", 
						 &pVolDesc->vds_Name,
                        (pVolDesc->vds_Flags & AFP_VOLUME_SUPPORTS_CATSRCH) ?
                        " " : "(CatSearch disabled)", 
						0xffffffff*ActivationTime.HighPart,
						0xffffffff*ActivationTime.LowPart,
						pVolDesc->vds_maxPrivateNotifies
						));
			if ((int)(pVolDesc->vds_IndxStTime.LowPart-ActivationTime.LowPart) >= 0)
			{
				LowPart = pVolDesc->vds_IndxStTime.LowPart-ActivationTime.LowPart;
				HighPart = pVolDesc->vds_IndxStTime.HighPart-ActivationTime.HighPart;
			}
			else
			{
				LowPart = 0xffffffff - ActivationTime.LowPart + 1 + pVolDesc->vds_IndxStTime.LowPart;
				HighPart = pVolDesc->vds_IndxStTime.HighPart-ActivationTime.HighPart -1;
			}
	        DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("Time taken for indexing = %8lx%08lx\n",
					 0xffffffff*(pVolDesc->vds_IndxStTime.HighPart-ActivationTime.HighPart),
					 0xffffffff*(pVolDesc->vds_IndxStTime.LowPart-ActivationTime.LowPart)
					 ));
        }
        else
        {
	        DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
			    ("afpActivateVolume: couldn't reference volume %Z\n",&pVolDesc->vds_Name));
        }
	}
    else
    {
		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
    }
}

/***	AfpShouldWeIgnoreThisNotification
 *
 *	Check to see if this notification should be ignored. The following events are
 *	ignored.
 *
 *		(((Action == FILE_ACTION_MODIFIED_STREAM) &&
 *		  (Stream != AFP_RESC_STREAM)			  &&
 *		  (Stream != AFP_INFO_STREAM))				||
 *		 (Its one of our own changes))
 *
 *	LOCKS:	vds_VolLock (SPIN)
 */
BOOLEAN FASTCALL
AfpShouldWeIgnoreThisNotification(
	IN	PVOL_NOTIFY		pVolNotify
)
{
	PFILE_NOTIFY_INFORMATION pFNInfo;
	PVOLDESC				 pVolDesc;
	UNICODE_STRING			 UName;
	BOOLEAN					 ignore = False;

	pFNInfo = (PFILE_NOTIFY_INFORMATION)(pVolNotify + 1);
	pVolDesc = pVolNotify->vn_pVolDesc;
	AfpInitUnicodeStringWithNonNullTerm(&UName,
										(USHORT)pFNInfo->FileNameLength,
										pFNInfo->FileName);

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpShouldWeIgnoreThisNotification: Action: %d Name: %Z\n", pFNInfo->Action, &UName));

	pVolNotify->vn_StreamId = AFP_STREAM_DATA;
	if (pFNInfo->Action == FILE_ACTION_MODIFIED_STREAM)
	{
		UNICODE_STRING	UStream;

		ignore = True;
		UStream.Length = UStream.MaximumLength = AfpInfoStream.Length;
		UStream.Buffer = (PWCHAR)((PBYTE)UName.Buffer +
								  UName.Length - AfpInfoStream.Length);

		if (EQUAL_UNICODE_STRING(&UStream, &AfpInfoStream, False))
		{
			pVolNotify->vn_StreamId = AFP_STREAM_INFO;
			pFNInfo->FileNameLength -= AfpInfoStream.Length;
			UName.Length -= AfpInfoStream.Length;
			ignore = False;
		}
		else
		{
			UStream.Length = UStream.MaximumLength = AfpResourceStream.Length;
			UStream.Buffer = (PWCHAR)((PBYTE)UName.Buffer +
									  UName.Length - AfpResourceStream.Length);

			if (EQUAL_UNICODE_STRING(&UStream, &AfpResourceStream, False))
			{
				pVolNotify->vn_StreamId = AFP_STREAM_RESC;
				pFNInfo->FileNameLength -= AfpResourceStream.Length;
				UName.Length -= AfpResourceStream.Length;
				ignore = False;
			}
		}
	}

	if (!ignore)
	{
		PLIST_ENTRY		pList, pListHead;
		POUR_CHANGE		pChange;
		DWORD			afpChangeAction;
		KIRQL			OldIrql;

		afpChangeAction = AFP_CHANGE_ACTION(pFNInfo->Action);

		ASSERT(afpChangeAction <= AFP_CHANGE_ACTION_MAX);

		ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

		// point to the head of the appropriate change action list
		pListHead = &pVolDesc->vds_OurChangeList[afpChangeAction];

		for (pList = pListHead->Flink;
			 pList != pListHead;
			 pList = pList->Flink)
		{
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);

			// do a case *sensitive* unicode string compare
			if (EQUAL_UNICODE_STRING_CS(&UName, &pChange->oc_Path))
			{
				RemoveEntryList(&pChange->oc_Link);
				AfpFreeMemory(pChange);

				// We were notified of our own change
				ignore = True;

				if (pFNInfo->Action == FILE_ACTION_RENAMED_OLD_NAME)
				{
					// consume the RENAMED_NEW_NAME if it exists
					if (pFNInfo->NextEntryOffset != 0)
					{
						PFILE_NOTIFY_INFORMATION	pFNInfo2;

						(PBYTE)pFNInfo2 = (PBYTE)pFNInfo + pFNInfo->NextEntryOffset;
						if (pFNInfo2->Action == FILE_ACTION_RENAMED_NEW_NAME)
						{
							ASSERT(pFNInfo2->NextEntryOffset == 0);
						}
						else
						{
							DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
									("AfpShouldWeIgnoreThisNotification: Our Rename did not come with new name!!!\n"));
						}
					}
					else
					{
						DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
								("AfpShouldWeIgnoreThisNotification: Our Rename did not come with new name!!!\n"));

					}
				} // if rename
				else
				{
					// We are ignoring this notify. Make sure its not a multiple
					ASSERT(pFNInfo->NextEntryOffset == 0);
				}

				break;
			}
		} // while there are more of our changes to look thru

		RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
	}
	else
	{
		// We are ignoring this notify. Make sure its not a multiple
		ASSERT(pFNInfo ->NextEntryOffset == 0);
	}

	if (!ignore)
	{
		INTERLOCKED_INCREMENT_LONG(&pVolDesc->vds_cOutstandingNotifies);
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("ShouldWe: Action: %d Name: \t\t\t\t\t\n%Z\n", pFNInfo->Action, &UName));
	}

	return ignore;
}


/***	AfpCacheDirectoryTree
 *
 *	Scan a directory tree and build the idindex database from this information.
 *	Do a breadth-first search. On volume start, this will cache the tree
 *	beginning at the root directory. For Directory ADDED notifications, this
 *	will cache the subtree beginning at the added directory, since a PC user can
 *  potentially move an entire subtree into a mac volume, but we will only
 *  be notified of the one directory addition.
 *
 *	Only the first level is actually handled here. Sub-directories are queued up
 *	as faked notifies and handled that way.
 *
 *  Method:
 *  REENUMERATE:		In case we need to reenumerate just
 *						this level in the tree in order to
 *						get rid of any dead wood that a PC
 *						removed by its 'other' name
 *
 *	GETDIRSKELETON:		When we want to bring in only the skeleton
 *						of the tree by adding directories only
 *
 *	GETFILES:			When we need to fill in the files for this
 *						level of the tree because a mac has accessed
 *						a dir for the first time.
 *
 *  GetDirSkeletonAndFiles:
 *						A Combination of the above two.
 *						When we want to bring in both files and directories.
 *						This is used when adding a volume, and we want the
 *						files in the root directory cached in, but no others.
 *						Also this will be used if we are rebuilding the
 *						Desktop database APPLs while caching the disk tree.
 *						The private ChangeNotifies we queue up for ADDED dirs
 *						will also read in the files if the volume is marked
 *						for rebuilding of the desktop.
 *
 *	GETENTIRETREE:		When we want to cache in the entire tree
 *
 *	GetEntireTreeAndReEnumerate:
 *						Combines GETENTIRETREE and REENUMERATE
 *
 *  LOCKS_ASSUMED: vds_IdDbAccessLock (SWMR, Exclusive)
 */
NTSTATUS
AfpCacheDirectoryTree(
	IN	PVOLDESC			pVolDesc,
	IN	PDFENTRY			pDFETreeRoot,		// DFE of the tree root directory
	IN	DWORD				Method,				// See explanation in procedure comment
	IN	PFILESYSHANDLE		phRootDir OPTIONAL, // open handle to tree root directory
	IN	PUNICODE_STRING		pDirPath  OPTIONAL
)
{
	UNICODE_STRING				UName, Path, ParentPath;
    UNICODE_STRING              RootName;
	PDFENTRY					pDFE;
	PDFENTRY					pChainDFE;
	PDFENTRY					pCurrDfe;
	NTSTATUS					Status = STATUS_SUCCESS;
	PBYTE						enumbuf = NULL;
	PFILE_BOTH_DIR_INFORMATION	pNextEntry;
	FILESYSHANDLE				fshEnumDir;
	USHORT						SavedPathLength;
    BOOLEAN                     fQueueThisSubDir=FALSE;
    BOOLEAN                     fOneSubDirAlreadyQueued=FALSE;
    BOOLEAN                     fAllSubDirsVisited=TRUE;
    BOOLEAN                     fExitLoop=FALSE;
#ifdef	PROFILING
	TIME						TimeS, TimeE, TimeD;
	DWORD						NumScanned = 0;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT (VALID_DFE(pDFETreeRoot));
	ASSERT (DFE_IS_DIRECTORY(pDFETreeRoot));

	ASSERT((Method != GETFILES) || !DFE_CHILDREN_ARE_PRESENT(pDFETreeRoot));

	// allocate the buffer that will hold enumerated files and dirs
	if ((pVolDesc->vds_EnumBuffer == NULL) &&
		((pVolDesc->vds_EnumBuffer = (PBYTE)AfpAllocPANonPagedMemory(AFP_ENUMBUF_SIZE)) == NULL))
	{
		return STATUS_NO_MEMORY;
	}

	do
	{
		fshEnumDir.fsh_FileHandle = NULL;
		enumbuf = pVolDesc->vds_EnumBuffer;

		// Get the volume root relative path to the directory tree being scanned
		// Get extra space for one more entry to tag on for queuing notifies.
		// In case we already have the path corres. to directory we are attempting
		// to cache, get it from there. Note that in this case we are always
		// guaranteed that extra space is available
		if (ARGUMENT_PRESENT(pDirPath))
		{
			Path = *pDirPath;
		}
		else
		{
			AfpSetEmptyUnicodeString(&Path, 0, NULL);
			Status = AfpHostPathFromDFEntry(pDFETreeRoot,
											(AFP_LONGNAME_LEN+1)*sizeof(WCHAR),
											&Path);

			if (!NT_SUCCESS(Status))
			{
				break;
			}
		}

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpCacheDirectoryTree: ParentId %d, Path %Z\n",
				 pDFETreeRoot->dfe_AfpId, &Path));

		if (Method != GETDIRSKELETON)
		{
		if (!ARGUMENT_PRESENT(phRootDir))
		{
			// Need to open a handle to the directory in order to enumerate
			if (NT_SUCCESS(Status = AfpIoOpen(&pVolDesc->vds_hRootDir,
											  AFP_STREAM_DATA,
											  FILEIO_OPEN_DIR,
											  &Path,
											  FILEIO_ACCESS_NONE,
											  FILEIO_DENY_NONE,
											  False,
											  &fshEnumDir)))
			{
				phRootDir = &fshEnumDir;
			}
			else
			{
				break;
			}
		}
		}

		SavedPathLength = Path.Length;

		DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_INFO,
				("AfpCacheDirectoryTree: Scanning Tree: %Z\n", &Path));

		if (Method & REENUMERATE)
		{
			afpMarkAllChildrenUnseen(pDFETreeRoot);
		}

		if (Method != GETDIRSKELETON)
		{

		while (True)
		{
			// keep enumerating till we get all the entries
			Status = AfpIoQueryDirectoryFile(phRootDir,
											 (PFILE_BOTH_DIR_INFORMATION)enumbuf,
											 AFP_ENUMBUF_SIZE,
											 FileBothDirectoryInformation,
											 False, // return multiple entries
											 False, // don't restart scan
											 NULL);

			ASSERT(Status != STATUS_PENDING);

			if (Status != STATUS_SUCCESS)
			{
				if ((Status == STATUS_NO_MORE_FILES) ||
					(Status == STATUS_NO_SUCH_FILE))
				{
					Status = STATUS_SUCCESS;
					break; // that's it, we've seen everything there is
				}
				else
				{
					AFPLOG_HERROR(AFPSRVMSG_ENUMERATE,
								  Status,
								  NULL,
								  0,
								  phRootDir->fsh_FileHandle);
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("AfpCacheDirectoryTree: dir enum failed %lx\n", Status));
					break;	// enumerate failed, bail out
				}
			}

			// process the enumerated files and dirs in the current enumbuf
			pNextEntry = (PFILE_BOTH_DIR_INFORMATION)enumbuf;

			while (True)
			{
				BOOLEAN						IsDir, WriteBackROAttr, FixIt;
				WCHAR						wc;
				PFILE_BOTH_DIR_INFORMATION	pCurrEntry;

                fQueueThisSubDir = FALSE;

				if (pNextEntry == NULL)
				{
					Status = STATUS_NO_MORE_ENTRIES;
					break;
				}
				WriteBackROAttr = False;
				IsDir = False;

				// Move the structure to the next entry or NULL if we hit the end
				pCurrEntry = pNextEntry;
				(PBYTE)pNextEntry += pCurrEntry->NextEntryOffset;
				if (pCurrEntry->NextEntryOffset == 0)
				{
					pNextEntry = NULL;
				}

				if (pCurrEntry->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// Ignore dirs if we are only getting files for this level
					if (Method == GETFILES)
					{
						continue;
					}
					IsDir = True;
				}
				else if (Method == GETDIRSKELETON)
				{
					// Ignore files if we are only getting the dir skeleton
					continue;
				}

				// If NT name > AFP_LONGNAME_LEN, use the NT shortname for
				// Mac longname on NTFS, any other file system the shortname
				// will be null, so ignore the file
				//if (pCurrEntry->FileNameLength <= (AFP_LONGNAME_LEN*sizeof(WCHAR)))
					
				AfpInitUnicodeStringWithNonNullTerm(&UName,
						(USHORT)pCurrEntry->FileNameLength,
						pCurrEntry->FileName);
				if ((RtlUnicodeStringToAnsiSize(&UName)-1) <= AFP_LONGNAME_LEN)
				{
					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pCurrEntry->FileNameLength,
														pCurrEntry->FileName);
				}
				else if (pCurrEntry->ShortNameLength > 0)
				{
					AfpInitUnicodeStringWithNonNullTerm(&UName,
														(USHORT)pCurrEntry->ShortNameLength,
														pCurrEntry->ShortName);
				}
				else
				{
					DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
							("AfpCacheDirectoryTree: Name is > 31 with no short name ?\n"));
					continue;
				}

				if (IsDir &&
					(EQUAL_UNICODE_STRING_CS(&Dot, &UName) ||
					 EQUAL_UNICODE_STRING_CS(&DotDot, &UName)))
				{
					continue;
				}

				// Check if this entry is an invalid win32 name i.e. it has either
				// a period or a space at end, if so convert it to the new format.
				// NOTE: can we construct a path to use to catch our own changes ?
				wc = UName.Buffer[(UName.Length - 1)/sizeof(WCHAR)];
				if ((wc == UNICODE_SPACE) || (wc == UNICODE_PERIOD))
				{
                    // NOTE: MacCD driver should fix this??
                    if (IS_VOLUME_NTFS(pVolDesc))
                    {
                        afpRenameInvalidWin32Name(phRootDir, IsDir, &UName);
                    }
				}

#ifdef	PROFILING
				NumScanned++;
#endif
				pDFE = NULL;
				FixIt = False;
				if (Method & REENUMERATE)
				{
					// If we have this item in our DB, just mark it as seen.
					// Use DFE_ANY here since a mismatch is fatal.
					afpFindDFEByUnicodeNameInSiblingList(pVolDesc,
														 pDFETreeRoot,
														 &UName,
														 &pDFE,
														 DFE_ANY);
					if (pDFE != NULL)
					{
						// If we have a wrong type, fix it.
						if (IsDir ^ DFE_IS_DIRECTORY(pDFE))
						{
							AfpDeleteDfEntry(pVolDesc, pDFE);
							pDFE = NULL;
							FixIt = True;
						}
						else
						{
							DFE_MARK_AS_SEEN(pDFE);
						}
					}
				}

				if ((Method != REENUMERATE) || FixIt) 
				{
					// add this entry to the idindex database, and cache all the required
					// information, but only for files since the directories are queued
					// back and added at that time.
					if (!IsDir)
					{
						// Construct a full path to the file in order to filter our
						// own changes to AFP_AfpInfo stream when adding the file
						if (Path.Length > 0)
						{
							// Append a path separator
							Path.Buffer[Path.Length / sizeof(WCHAR)] = L'\\';
							Path.Length += sizeof(WCHAR);
						}
						ASSERT(Path.Length + UName.Length <= Path.MaximumLength);
						RtlAppendUnicodeStringToString(&Path, &UName);

						if (pDFE == NULL)
						{
							afpAddDfEntryAndCacheInfo(pVolDesc,
													  pDFETreeRoot,
													  &UName,
													  phRootDir,
													  pCurrEntry,
													  &Path,
													  &pDFE,
													  True);
						}
						else if (pCurrEntry->LastWriteTime.QuadPart > pDFE->dfe_LastModTime.QuadPart)
						{
							afpVerifyDFE(pVolDesc,
										 pDFETreeRoot,
										 &UName,
										 phRootDir,
										 pCurrEntry,
										 &Path,
										 &pDFE);
						}


						// Restore the original length of the path to enum dir
						Path.Length = SavedPathLength;


						if (pDFE == NULL)
						{
							// one reason this could fail is if we encounter pagefile.sys
							// if our volume is rooted at the drive root
							DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_WARN,
									("AfpCacheDirectoryTree: AddDfEntry failed %Z at %Z\n",&UName,&Path));
							continue;
						}
						else if (Method == (GETENTIRETREE | REENUMERATE))
						{
							DFE_MARK_AS_SEEN(pDFE);
						}
					}
					else
					{
						ASSERT(IsDir);
						ASSERT ((Method != GETFILES) &&
								(Method != REENUMERATE));

						// queue this directory as a simulated Notify of a directory add.
                        // If we have too much stuff on the queue already, then queue
                        // only one subdirectory so that we are guaranteed to eventually
                        // visit all the subdirs.  Also, on a huge volume, we want to limit
                        // how many directories enque per level of the tree
                        //

                        fQueueThisSubDir = TRUE;

						// We dont use this flag DFE_FLAGS_INIT_COMPLETED
						// anymore. So, reducing one lookup
#if 0
				        pCurrDfe = AfpFindEntryByUnicodeName(pVolDesc,
													         &UName,
													         AFP_LONGNAME,
													         pDFETreeRoot,
													         DFE_ANY);

                        //
                        // if this subdir is already complete, skip it
                        //
				        if ((pCurrDfe != NULL) &&
                            (pCurrDfe->dfe_Flags & DFE_FLAGS_INIT_COMPLETED))
                        {
                            fQueueThisSubDir = FALSE;
                        }
#endif

                        if (fQueueThisSubDir)
                        {
						    AfpQueuePrivateChangeNotify(pVolDesc,
							    						&UName,
								    					&Path,
									    				pDFETreeRoot->dfe_AfpId);
                        }
					}
				}

                if (fExitLoop)
                {
                    break;
                }

			} // while more entries in the enumbuf

			if ((!NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES)) ||
                (fExitLoop))
			{
				break;
			}

		} // while there are more files to enumerate


		if (NT_SUCCESS(Status))
		{
			if (Method & REENUMERATE)
			{
				afpPruneUnseenChildren(pVolDesc, pDFETreeRoot);
			}

			DFE_MARK_CHILDREN_PRESENT(pDFETreeRoot);
		}
        else
		{
			DBGPRINT(DBG_COMP_IDINDEX, DBG_LEVEL_ERR,
					("AfpCacheDirectoryTree: Status %lx\n", Status));
		}

		} /* if Method != GETDIRSKELETON */
		else if (Method == GETDIRSKELETON)
		{
			PDFENTRY 	pcurrDfEntry;
			PDFENTRY	pDfEntry;	
		
			pcurrDfEntry = (pDFETreeRoot)->dfe_pDirEntry->de_ChildDir;				
			do														
			{														
				for (NOTHING;										
						pcurrDfEntry != NULL;								
						pcurrDfEntry = pcurrDfEntry->dfe_NextSibling)
				{													
#if 0
					if (((*(_ppDfEntry))->dfe_NameHash == NameHash)	&&	
							EQUAL_UNICODE_STRING(&((*(_ppDfEntry))->dfe_UnicodeName), 
									_pName,				
									True))					
					{													
						afpUpdateDfeAccessTime(_pVolDesc, *(_ppDfEntry));
						Found = True;									
						break;										
					}											
#endif
						    
					AfpQueuePrivateChangeNotify(pVolDesc,
							&(pcurrDfEntry->dfe_UnicodeName),
							&Path,
							pDFETreeRoot->dfe_AfpId);

				}											

				Status = STATUS_SUCCESS;

			} while (False);								

		} /* if Method == GETDIRSKELETON */
		
	} while (False);


	ASSERT (enumbuf != NULL);
	if ((pVolDesc->vds_cPrivateNotifies == 0) &&
		(pVolDesc->vds_cOutstandingNotifies == 0))
	{
		if (enumbuf != NULL)
		{
			AfpFreePANonPagedMemory(enumbuf, AFP_ENUMBUF_SIZE);
		}
		pVolDesc->vds_EnumBuffer = NULL;
	}


	ASSERT (Path.Buffer != NULL);
	if (!ARGUMENT_PRESENT(pDirPath) && (Path.Buffer != NULL))
	{
		AfpFreeMemory(Path.Buffer);
	}

	if (fshEnumDir.fsh_FileHandle != NULL)
	{
		AfpIoClose(&fshEnumDir);
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_ULONG(&AfpServerProfile->perf_ScanTreeCount,
						  NumScanned,
						  &AfpStatisticsLock);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_ScanTreeTime,
								TimeD,
								&AfpStatisticsLock);
#endif

	return Status;
}


BOOLEAN FASTCALL
AfpVolumeAbortIndexing(
    IN  PVOLDESC    pVolDesc
)
{

    KIRQL           OldIrql;
    PKQUEUE         pNotifyQueue;
    PLIST_ENTRY     pNotifyList;
    PLIST_ENTRY     pPrivateNotifyList;
    LIST_ENTRY      TransitionList;
    PLIST_ENTRY     pList, pNext;
    LARGE_INTEGER   Immediate;
    PVOL_NOTIFY     pVolNotify;
    LONG            index;
    DWORD           DerefCount=0;
    DWORD           PvtNotifyCount=0;
    BOOLEAN         fResult=TRUE;
    BOOLEAN         fNewVolume=FALSE;
    BOOLEAN         fCancelNotify=FALSE;

	
    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR, 
			("AbortIndexing: Aborting Index for Volume\n"));

    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

    fNewVolume = (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS) ? TRUE : FALSE;

    pVolDesc->vds_Flags |= VOLUME_DELETED;

    // set this so we don't reset the Indexing global flag again!
    pVolDesc->vds_Flags |= VOLUME_INTRANSITION;

    if (pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED)
    {
        ASSERT(pVolDesc->vds_pIrp != NULL);
        fCancelNotify = TRUE;
    }

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

    if (fCancelNotify)
    {
        IoCancelIrp(pVolDesc->vds_pIrp);
    }

    InitializeListHead(&TransitionList);

    index = pVolDesc->vds_VolId % NUM_NOTIFY_QUEUES;

    pNotifyQueue = &AfpVolumeNotifyQueue[index];
    pNotifyList = &AfpVolumeNotifyList[index];
    pPrivateNotifyList = &AfpVirtualMemVolumeNotifyList[index];
    Immediate.HighPart = Immediate.LowPart = 0;

    while (1)
    {
        pList = KeRemoveQueue(pNotifyQueue, KernelMode, &Immediate);

        //
        // finished the list?
        //
        if ((NTSTATUS)((ULONG_PTR)pList) == STATUS_TIMEOUT)
        {
            break;
        }

        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);

        //
        // some other notifications?  keep them on temp list for now
        //
        if ((pVolNotify->vn_pVolDesc != pVolDesc) ||
            (pVolNotify == &AfpTerminateNotifyThread))
        {
            InsertTailList(&TransitionList, pList);
        }

        //
        // notification for this volume: get rid of it
        //
        else
        {
            ASSERT(pVolNotify->vn_pVolDesc == pVolDesc);
            ASSERT((pVolNotify->vn_TimeStamp == AFP_QUEUE_NOTIFY_IMMEDIATELY) ||
                   (!fNewVolume));

            // was this a private notify?
            if (((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE)
            {
                INTERLOCKED_DECREMENT_LONG(&pVolDesc->vds_cPrivateNotifies);
            }
            AfpFreeMemory(pVolNotify);
            AfpVolumeDereference(pVolDesc);
            AfpNotifyQueueCount[index]--;
        }
    }

    ACQUIRE_SPIN_LOCK(&AfpVolumeListLock, &OldIrql);
    pList = pNotifyList->Flink;
    while (pList != pNotifyList)
    {
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
        pNext = pList->Flink;
        if (pVolNotify->vn_pVolDesc == pVolDesc)
        {
            RemoveEntryList(pList);

            // was this a private notify?
            if (((PFILE_NOTIFY_INFORMATION)(pVolNotify + 1))->Action & AFP_ACTION_PRIVATE)
            {
                PvtNotifyCount++;
            }

            DerefCount++;
            AfpFreeMemory(pVolNotify);
            AfpNotifyListCount[index]--;
        }

        pList = pNext;
    }
    RELEASE_SPIN_LOCK(&AfpVolumeListLock, OldIrql);

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
    pList = pPrivateNotifyList->Flink;
    while (pList != pPrivateNotifyList)
    {
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
        pNext = pList->Flink;
        if (pVolNotify->vn_pVolDesc == pVolDesc)
        {
            RemoveEntryList(pList);
			afpFreeNotify(pVolNotify);

            AfpVolumeDereference(pVolDesc);

            //AfpNotifyListCount[index]--;
        }

        pList = pNext;
    }
    AfpSwmrRelease(&AfpVolumeListSwmr);

    if (DerefCount > 0)
    {
	    ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

        ASSERT(pVolDesc->vds_RefCount >= DerefCount);
        ASSERT(pVolDesc->vds_cPrivateNotifies >= (LONG)PvtNotifyCount);

        pVolDesc->vds_RefCount -= (DerefCount - 1);
        pVolDesc->vds_cPrivateNotifies -= PvtNotifyCount;

        RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

        AfpVolumeDereference(pVolDesc);
    }

    //
    // if there were any other notifications, put them back on the queue
    //
    while (!IsListEmpty(&TransitionList))
    {
        pList = TransitionList.Flink;
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);

        ASSERT(pVolNotify->vn_pVolDesc != pVolDesc);
        RemoveEntryList(pList);
        AfpVolumeQueueChangeNotify(pVolNotify, pNotifyQueue);
    }


    return(fResult);
}

BOOLEAN FASTCALL
AfpVolumeStopIndexing(
	IN  PVOLDESC   	   pVolDesc,
    IN  PVOL_NOTIFY    pInVolNotify
)
{

    PKQUEUE         pNotifyQueue;
    PLIST_ENTRY     pNotifyList;
    PLIST_ENTRY     pPrivateNotifyList;
    PLIST_ENTRY     pList, pNext;
    LARGE_INTEGER   Immediate;
    PVOL_NOTIFY     pVolNotify;
    LONG            index;
    BOOLEAN         fResult=TRUE;

    DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR, 
			("StopIndexing: Stopping Index for Volume\n"));

    index = pVolDesc->vds_VolId % NUM_NOTIFY_QUEUES;

    pNotifyQueue = &AfpVolumeNotifyQueue[index];
    pNotifyList = &AfpVolumeNotifyList[index];
    pPrivateNotifyList = &AfpVirtualMemVolumeNotifyList[index];
    Immediate.HighPart = Immediate.LowPart = 0;

    AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
    pList = pPrivateNotifyList->Flink;
    while (pList != pPrivateNotifyList)
    {
        pVolNotify = CONTAINING_RECORD(pList, VOL_NOTIFY, vn_List);
        pNext = pList->Flink;
        if ((pVolNotify->vn_pVolDesc == pVolDesc) && 
						(pVolNotify != pInVolNotify))
        {
            RemoveEntryList(pList);
			afpFreeNotify(pVolNotify);

            AfpVolumeDereference(pVolDesc);

            //AfpNotifyListCount[index]--;
        }

        pList = pNext;
    }
    AfpSwmrRelease(&AfpVolumeListSwmr);


    return(fResult);
}


/***	AfpQueuePrivateChangeNotify
 *
 *	LOCKS_ASSUMED: vds_idDbAccessLock (SWMR, Exclusive)
 */
VOID
AfpQueuePrivateChangeNotify(
	IN	PVOLDESC			pVolDesc,
	IN	PUNICODE_STRING		pName,
	IN	PUNICODE_STRING		pPath,
	IN	DWORD				ParentId
)
{

    DWORD       dwSize;
	LONG		Index;
	PLIST_ENTRY	pVirtualNotifyList;

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("PvtNotify: ParentId %d, Path %Z, Name %Z\n",
			ParentId, pPath, pName));

	pVirtualNotifyList = &AfpVirtualMemVolumeNotifyList[pVolDesc->vds_VolId % NUM_NOTIFY_QUEUES];

	// Reference the volume for Notify processing
	if (AfpVolumeReference(pVolDesc))
	{
		PVOL_NOTIFY					pVolNotify;
		PFILE_NOTIFY_INFORMATION	pNotifyInfo;

		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpQueuePrivateChangeNotify: Queuing directory %Z\\%Z\n", pPath, pName));

		// Allocate an extra component worths
		dwSize = sizeof(VOL_NOTIFY) +
				 sizeof(FILE_NOTIFY_INFORMATION) +
				 pPath->Length +
				 pName->Length +
				 (AFP_LONGNAME_LEN+1)*sizeof(WCHAR)+
				 sizeof(WCHAR);

		Index = NOTIFY_USIZE_TO_INDEX(pPath->Length+pName->Length+sizeof(WCHAR));
		pVolNotify = afpAllocNotify (Index, TRUE);

		if (pVolNotify != NULL)
		{
			LONG	Offset = 0;

			INTERLOCKED_INCREMENT_LONG(&pVolDesc->vds_cPrivateNotifies);
			if (pVolDesc->vds_cPrivateNotifies > pVolDesc->vds_maxPrivateNotifies)
			{
				pVolDesc->vds_maxPrivateNotifies = pVolDesc->vds_cPrivateNotifies;
			}

			pVolNotify->vn_VariableLength = pPath->Length+pName->Length+sizeof(WCHAR);
			pVolNotify->vn_pVolDesc = pVolDesc;
			pVolNotify->vn_Processor = afpProcessPrivateNotify;
			pVolNotify->vn_TimeStamp = AFP_QUEUE_NOTIFY_IMMEDIATELY;
			pVolNotify->vn_ParentId = ParentId;
			pVolNotify->vn_TailLength = pName->Length;
			pVolNotify->vn_StreamId = AFP_STREAM_DATA;
			pNotifyInfo = (PFILE_NOTIFY_INFORMATION)((PBYTE)pVolNotify + sizeof(VOL_NOTIFY));
			pNotifyInfo->NextEntryOffset = 0;
			pNotifyInfo->Action = FILE_ACTION_ADDED | AFP_ACTION_PRIVATE;
			pNotifyInfo->FileNameLength = pName->Length + pPath->Length;
			if (pPath->Length > 0)
			{
				RtlCopyMemory(pNotifyInfo->FileName,
							  pPath->Buffer,
							  pPath->Length);

				pNotifyInfo->FileName[pPath->Length/sizeof(WCHAR)] = L'\\';
				pNotifyInfo->FileNameLength += sizeof(WCHAR);
				Offset = pPath->Length + sizeof(WCHAR);
			}
			if (pName->Length > 0)
			{
				RtlCopyMemory((PBYTE)pNotifyInfo->FileName + Offset,
							  pName->Buffer,
							  pName->Length);
			}

			AfpSwmrAcquireExclusive(&AfpVolumeListSwmr);
			InsertTailList(pVirtualNotifyList, &pVolNotify->vn_List);
			AfpSwmrRelease(&AfpVolumeListSwmr);

		}
		else
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("AfpQueuePrivateChangeNotify: Queuing of notify for directory %Z\\%Z failed\n",
					pPath, pName));

            AFPLOG_ERROR(AFPSRVMSG_VOLUME_INIT_FAILED,
                         STATUS_INSUFFICIENT_RESOURCES,
                         NULL,
                         0,
                         &pVolDesc->vds_Name);

            //
            // this will remove all the entries that have been queued so far
            //
            AfpVolumeAbortIndexing(pVolDesc);

            // remove the refcount put above when vol referenced
			AfpVolumeDereference(pVolDesc);

            // remove the creation refcount
			AfpVolumeDereference(pVolDesc);
		}
	}
	else 
	{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_ERR,
					("AfpQueuePrivateChangeNotify: Queuing of notify for directory %Z\\%Z failed as Reference not possible\n",
					pPath, pName));
	}
}


/***	AfpQueueOurChange
 *
 * 	LOCKS:	vds_VolLock (SPIN)
 */
VOID
AfpQueueOurChange(
	IN PVOLDESC				pVolDesc,
	IN DWORD				Action,		// NT FILE_ACTION_XXX (ntioapi.h)
	IN PUNICODE_STRING		pPath,
	IN PUNICODE_STRING		pParentPath	OPTIONAL // queues a ACTION_MODIFIED
)
{
	POUR_CHANGE pchange = NULL;
	KIRQL		OldIrql;
#if DBG
	static PBYTE	ActionStrings[] =
					{	"",
						"ADDED",
						"REMOVED",
						"MODIFIED",
						"RENAMED OLD",
						"RENAMED NEW",
						"STREAM ADDED",
						"STREAM REMOVED",
						"STREAM MODIFIED"
					};
#endif

	PAGED_CODE( );
	ASSERT(IS_VOLUME_NTFS(pVolDesc) && !EXCLUSIVE_VOLUME(pVolDesc));

    //
    // if the volume is being built, we don't have change-notify posted.
    // Don't queue this change: we are never going to get a change-notify!
    //
    if (pVolDesc->vds_Flags & VOLUME_NEW_FIRST_PASS)
    {
        ASSERT(!(pVolDesc->vds_Flags & VOLUME_NOTIFY_POSTED));
        return;
    }

	pchange = (POUR_CHANGE)AfpAllocNonPagedMemory(sizeof(OUR_CHANGE) + pPath->Length);

	if (pchange != NULL)
	{
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				 ("AfpQueueOurChange: Queueing a %s for %Z\n", ActionStrings[Action], pPath));
		AfpGetCurrentTimeInMacFormat(&pchange->oc_Time);
		AfpInitUnicodeStringWithNonNullTerm(&pchange->oc_Path,
											pPath->Length,
											(PWCHAR)((PBYTE)pchange + sizeof(OUR_CHANGE)));
		RtlCopyMemory(pchange->oc_Path.Buffer,
					  pPath->Buffer,
					  pPath->Length);

		ExInterlockedInsertTailList(&pVolDesc->vds_OurChangeList[AFP_CHANGE_ACTION(Action)],
								    &pchange->oc_Link,
									&(pVolDesc->vds_VolLock.SpinLock));
	}

	if (ARGUMENT_PRESENT(pParentPath))
	{
		pchange = (POUR_CHANGE)AfpAllocNonPagedMemory(sizeof(OUR_CHANGE) + pParentPath->Length);

		if (pchange != NULL)
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					 ("AfpQueueOurChange: Queueing (parent) %s for %Z\n",
					 ActionStrings[FILE_ACTION_MODIFIED], pParentPath));
			AfpGetCurrentTimeInMacFormat(&pchange->oc_Time);
			AfpInitUnicodeStringWithNonNullTerm(&pchange->oc_Path,
												pParentPath->Length,
												(PWCHAR)((PBYTE)pchange + sizeof(OUR_CHANGE)));
			RtlCopyMemory(pchange->oc_Path.Buffer,
						  pParentPath->Buffer,
						  pParentPath->Length);

			ExInterlockedInsertTailList(&pVolDesc->vds_OurChangeList[AFP_CHANGE_ACTION(FILE_ACTION_MODIFIED)],
										&pchange->oc_Link,
										&(pVolDesc->vds_VolLock.SpinLock));
		}
	}
}


/***	AfpDequeueOurChange
 *
 * 	LOCKS: LOCKS:	vds_VolLock (SPIN)
 */
VOID
AfpDequeueOurChange(
	IN PVOLDESC				pVolDesc,
	IN DWORD				Action,				// NT FILE_ACTION_XXX (ntioapi.h)
	IN PUNICODE_STRING		pPath,
	IN PUNICODE_STRING		pParentPath	OPTIONAL// queues a ACTION_MODIFIED
)
{
	POUR_CHANGE pChange;
	PLIST_ENTRY	pList, pListHead;
	KIRQL		OldIrql;
#if DBG
	static PBYTE	ActionStrings[] =
					{	"",
						"ADDED",
						"REMOVED",
						"MODIFIED",
						"RENAMED OLD",
						"RENAMED NEW",
						"STREAM ADDED",
						"STREAM REMOVED",
						"STREAM MODIFIED"
					};
#endif

	ASSERT(IS_VOLUME_NTFS(pVolDesc) && !EXCLUSIVE_VOLUME(pVolDesc));

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	// point to the head of the appropriate change action list
	pListHead = &pVolDesc->vds_OurChangeList[AFP_CHANGE_ACTION(Action)];

	for (pList = pListHead->Flink;
		 pList != pListHead;
		 pList = pList->Flink)
	{
		pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);

		// do a case *sensitive* unicode string compare
		if (EQUAL_UNICODE_STRING_CS(pPath, &pChange->oc_Path))
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					 ("AfpDequeueOurChange: Dequeueing a %s for %Z\n",
					 ActionStrings[Action], pPath));

			RemoveEntryList(&pChange->oc_Link);
			AfpFreeMemory(pChange);
			break;
		}
	}

	if (ARGUMENT_PRESENT(pParentPath))
	{
		// point to the head of the appropriate change action list
		pListHead = &pVolDesc->vds_OurChangeList[FILE_ACTION_MODIFIED];
	
		for (pList = pListHead->Flink;
			 pList != pListHead;
			 pList = pList->Flink)
		{
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);
	
			// do a case *sensitive* unicode string compare
			if (EQUAL_UNICODE_STRING_CS(pParentPath, &pChange->oc_Path))
			{
				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
						 ("AfpDequeueOurChange: Dequeueing (parent) %s for %Z\n",
						 ActionStrings[FILE_ACTION_MODIFIED], pParentPath));

				RemoveEntryList(&pChange->oc_Link);
				AfpFreeMemory(pChange);
				break;
			}
		}
	}
	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);
}

/***	AfpOurChangeScavenger
 *
 *  This runs in a worker thread context since it takes an swmr.
 *
 *  LOCKS:	vds_VolLock (SPIN)
 */
AFPSTATUS FASTCALL
AfpOurChangeScavenger(
	IN PVOLDESC pVolDesc
)
{
	AFPTIME		Now;
	KIRQL		OldIrql;
	int 		i;
	BOOLEAN		DerefVol = False;
#if DBG
	static PBYTE	Action[] = { "",
								 "ADDED",
								 "REMOVED",
								 "MODIFIED",
								 "RENAMED OLD",
								 "RENAMED NEW",
								 "STREAM ADDED",
								 "STREAM REMOVED",
								 "STREAM MODIFIED"};
#endif

	DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
			("AfpOurChangeScavenger: OurChange scavenger for volume %Z entered...\n",
			 &pVolDesc->vds_Name));

	// If this volume is going away, do not requeue this scavenger routine
	// We don't take the volume lock to check these flags since they are
	// one-way, i.e. once set they are never cleared.
	if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
	{
		DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
				("AfpOurChangeScavenger: OurChange scavenger for volume %Z: Final run\n",
				 &pVolDesc->vds_Name));
		DerefVol = True;
	}

  CleanTurds:

	AfpGetCurrentTimeInMacFormat(&Now);

	ACQUIRE_SPIN_LOCK(&pVolDesc->vds_VolLock, &OldIrql);

	for (i = 0; i < NUM_AFP_CHANGE_ACTION_LISTS; i++)
	{
		PLIST_ENTRY	pList, pHead;
		POUR_CHANGE	pChange;

		pHead = &pVolDesc->vds_OurChangeList[i];
		while (!IsListEmpty(pHead))
		{
			pList = pHead->Flink;
			pChange = CONTAINING_RECORD(pList, OUR_CHANGE, oc_Link);

			if (((Now - pChange->oc_Time) > OURCHANGE_AGE) || DerefVol)
			{
				RemoveHeadList(pHead);

				DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_WARN,
						("AfpOurChangeScavenger: freeing %Z (%s)\n",
						&pChange->oc_Path, &Action[i]));
				AfpFreeMemory(pChange);
			}
			else
			{
				// All subsequent items in list will have later times so
				// don't bother checking them
				break;
			}
		}
	}

	RELEASE_SPIN_LOCK(&pVolDesc->vds_VolLock, OldIrql);

	// Check again if this volume is going away and if so do not requeue this
	// scavenger routine.  Note that while we were running, the volume may
	// have been deleted but this scavenger event could not be killed because
	// it wasn't found on the list. We don't want to requeue this routine again
	// because it will take AFP_OURCHANGE_AGE minutes for the volume to go
	// away otherwise. This closes the window more, but does not totally
	// eliminate it from happening.
	if (!DerefVol)
	{
		if (pVolDesc->vds_Flags & (VOLUME_DELETED | VOLUME_STOPPED))
		{
			DBGPRINT(DBG_COMP_CHGNOTIFY, DBG_LEVEL_INFO,
					("AfpOurChangeScavenger: OurChanges scavenger for volume %Z: Final Run\n",
					 &pVolDesc->vds_Name));
			DerefVol = True;
			goto CleanTurds;
		}
	}
	else
	{
		AfpVolumeDereference(pVolDesc);
		return AFP_ERR_NONE;
	}

	return AFP_ERR_REQUEUE;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\desktop.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	desktop.c

Abstract:

	This module contains the routines for manipulating the desktop database.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_DESKTOP
#define	DESKTOP_LOCALS

#include <afp.h>
#include <scavengr.h>
#include <fdparm.h>
#include <pathmap.h>
#include <client.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfpDesktopInit)
#pragma alloc_text( PAGE, AfpAddIcon)
#pragma alloc_text( PAGE, AfpLookupIcon)
#pragma alloc_text( PAGE, AfpLookupIconInfo)
#pragma alloc_text( PAGE, AfpAddAppl)
#pragma alloc_text( PAGE, AfpLookupAppl)
#pragma alloc_text( PAGE, AfpRemoveAppl)
#pragma alloc_text( PAGE, AfpAddComment)
#pragma alloc_text( PAGE, AfpGetComment)
#pragma alloc_text( PAGE, AfpRemoveComment)
#pragma alloc_text( PAGE, AfpAddIconToGlobalList)
#pragma alloc_text( PAGE, afpLookupIconInGlobalList)
#pragma alloc_text( PAGE, AfpFreeGlobalIconList)
#pragma alloc_text( PAGE, afpGetGlobalIconInfo)
#pragma alloc_text( PAGE, afpReadDesktopFromDisk)
#pragma alloc_text( PAGE, AfpInitDesktop)
#pragma alloc_text( PAGE, AfpUpdateDesktop)
#pragma alloc_text( PAGE, AfpFreeDesktopTables)
#endif

/***	AfpDesktopInit
 *
 *	Initialize locks for global icons.
 */
NTSTATUS
AfpDesktopInit(
	VOID
)
{
	AfpSwmrInitSwmr(&AfpIconListLock);

	return STATUS_SUCCESS;
}


/***	AfpAddIcon
 *
 * Add an icon to the desktop database. The icon is added in such a way that
 * the list is maintained in a sorted fashion - sorted by Creator, Type and
 * IconType
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAddIcon(
	IN  PVOLDESC	pVolDesc,		// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	DWORD		Type,
	IN	DWORD		Tag,
	IN	LONG		IconSize,
	IN	DWORD		IconType,
	IN  PBYTE		pIcon			// The icon bitmap
)
{
	PICONINFO	pIconInfo;
	PICONINFO *	ppIconInfo;
	BOOLEAN		Found = False;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&pVolDesc->vds_DtAccessLock);
	ppIconInfo = &pVolDesc->vds_pIconBuckets[HASH_ICON(Creator)];
	do
	{
		// Find the right slot
		for (;(pIconInfo = *ppIconInfo) != NULL;
			  ppIconInfo = &pIconInfo->icon_Next)
		{
			if (pIconInfo->icon_Creator < Creator)
				continue;
			if (pIconInfo->icon_Creator > Creator)
				break;
			if (pIconInfo->icon_Type < Type)
				continue;
			if (pIconInfo->icon_Type > Type)
				break;
			if (pIconInfo->icon_IconType < (USHORT)IconType)
				continue;
			if (pIconInfo->icon_IconType > (USHORT)IconType)
				break;
			/*
			 * If we come this far, we have hit the bulls eye
			 * Make sure the size matches, before we commit
			 */
			if (pIconInfo->icon_Size != IconSize)
			{
				Status = AFP_ERR_ICON_TYPE;
				break;
			}
			Found = True;
			break;
		}

		if (!Found && (Status == AFP_ERR_NONE))
		{
			// ppIconInfo now points to the right place
			if ((pIconInfo = ALLOC_ICONINFO(IconSize)) != NULL)
			{
				pIconInfo->icon_Next = *ppIconInfo;
				*ppIconInfo = pIconInfo;
				pIconInfo->icon_Creator = Creator;
				pIconInfo->icon_Type = Type;
				pIconInfo->icon_IconType = (USHORT)IconType;
				pIconInfo->icon_Size = (SHORT)IconSize;
				pIconInfo->icon_Tag = Tag;
				pVolDesc->vds_cIconEnts ++;
				Found = True;
			}
			else Status = AFP_ERR_MISC;
		}
		if (Found && (Status == AFP_ERR_NONE))
		{
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO), pIcon, IconSize);
		}
	} while (False);
	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpLookupIcon
 *
 * Search the desktop for an icon matching the given search parameters.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Shared), AfpIconListLock (SWMR, Shared)
 */
AFPSTATUS
AfpLookupIcon(
	IN  PVOLDESC	pVolDesc,		// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	DWORD		Type,
	IN	LONG		Length,
	IN	DWORD		IconType,
    OUT PLONG       pActualLength,
	OUT PBYTE		pIconBitMap	// Buffer for icon bit map
)
{
	PICONINFO	pIconInfo;
    LONG        LengthToCopy;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

    LengthToCopy = Length;

	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);
	pIconInfo = pVolDesc->vds_pIconBuckets[HASH_ICON(Creator)];

	// Scan the list looking for the entry
	for (;pIconInfo != NULL; pIconInfo = pIconInfo->icon_Next)
	{
		if (pIconInfo->icon_Creator < Creator)
			continue;
		if (pIconInfo->icon_Creator > Creator)
		{
			pIconInfo = NULL;
			break;
		}
		if (pIconInfo->icon_Type < Type)
			continue;
		if (pIconInfo->icon_Type > Type)
		{
			pIconInfo = NULL;
			break;
		}
		if (pIconInfo->icon_IconType < (USHORT)IconType)
			continue;
		if (pIconInfo->icon_IconType > (USHORT)IconType)
		{
			pIconInfo = NULL;
			break;
		}
		break;
	}
	// If we did not find it, try the global list
	if (pIconInfo == NULL)
	{
		Status = afpLookupIconInGlobalList(Creator,
										   Type,
										   IconType,
										   &LengthToCopy,
										   pIconBitMap);
	}
	else if (Length > 0)
	{
        if ((LONG)(pIconInfo->icon_Size) < Length)
        {
            LengthToCopy = (LONG)(pIconInfo->icon_Size);
        }
        else
        {
            LengthToCopy = Length;
        }
		RtlCopyMemory(pIconBitMap, (PBYTE)pIconInfo + sizeof(ICONINFO), LengthToCopy);
	}

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);

    *pActualLength = LengthToCopy;
	return Status;
}


/***	AfpLookupIconInfo
 *
 *	Search the desktop for an icon matching the given Creator. In case of
 *	multiple icons corresponding to the same creator, get the nth where n
 *	is the index.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Shared), AfpIconListLock (SWMR, Shared)
 */
AFPSTATUS
AfpLookupIconInfo(
	IN  PVOLDESC	pVolDesc,	// Volume descriptor of referenced desktop
	IN	DWORD		Creator,	// Creator associated with the icon
	IN  LONG		Index,		// Index number of Icon
	OUT PDWORD		pType,		// Place where Type is returned
	OUT PDWORD	 	pIconType,	// Icon type e.g. ICN#
	OUT PDWORD		pTag,		// Arbitrary tag
	OUT PLONG		pSize		// Size of the icon
)
{
	PICONINFO	pIconInfo;
	LONG		i;
	AFPSTATUS	Status = AFP_ERR_ITEM_NOT_FOUND;

	PAGED_CODE( );

	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);
	pIconInfo = pVolDesc->vds_pIconBuckets[HASH_ICON(Creator)];

	// Scan the list looking for the first entry
	for (;pIconInfo != NULL; pIconInfo = pIconInfo->icon_Next)
	{
		if (pIconInfo->icon_Creator == Creator)
			break;				// Found the first one
		if (pIconInfo->icon_Creator > Creator)
		{
			pIconInfo = NULL;
			break;
		}
	}

	/*
	 * We are now either pointing to the first entry or there are none. In the
	 * latter case, we just fall through
	 */
	for (i = 1; pIconInfo != NULL; pIconInfo = pIconInfo->icon_Next)
	{
		if ((pIconInfo->icon_Creator > Creator) || (i > Index))
		{
			pIconInfo = NULL;
			break;
		}

		if (i == Index)
			break;				// Found the right entry
		i++;
	}

	// If we did find it, extract the information
	if (pIconInfo != NULL)
	{
		*pSize = pIconInfo->icon_Size;
		*pType = pIconInfo->icon_Type;
		*pTag = pIconInfo->icon_Tag;
		*pIconType = pIconInfo->icon_IconType;
		Status = AFP_ERR_NONE;
	}

	// If we did not find it, try the global list, but only for the first one
	else if (Index == 1)
	{
		Status = afpGetGlobalIconInfo(Creator, pType, pIconType, pTag, pSize);
	}
	else Status = AFP_ERR_ITEM_NOT_FOUND;

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpAddAppl
 *
 *	Add an APPL mapping to the desktop database. Is added in such a way that
 *	the list is maintained in a sorted fashion - sorted by Creator. It is
 *	already determined that the application file exists and that the user has
 *	appropriate access to it.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAddAppl(
	IN  PVOLDESC	pVolDesc,	// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	DWORD		ApplTag,
	IN  DWORD		FileNum,	// File number of the associated file
	IN	BOOLEAN		Internal,	// Is the server adding the APPL itself?
	IN	DWORD		ParentID	// DirId of parent dir of the application file
)
{
	PAPPLINFO2	pApplInfo, *ppApplInfo;
	BOOLEAN		ApplReplace = False, UpdateDT = True;
	AFPSTATUS	Status = AFP_ERR_NONE;


	PAGED_CODE( );

	ASSERT(FileNum != 0);

	AfpSwmrAcquireExclusive(&pVolDesc->vds_DtAccessLock);

	ppApplInfo = &pVolDesc->vds_pApplBuckets[HASH_APPL(Creator)];

	// Find the right slot
	for (;(pApplInfo = *ppApplInfo) != NULL; ppApplInfo = &pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_Creator >= Creator)
			break;
	}

	/*
	 * If there is already an entry for this creator, make sure it is not for
	 * the same file, if it is replace it.
	 */
	for ( ; pApplInfo != NULL && pApplInfo->appl_Creator == Creator;
			pApplInfo = pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_FileNum == FileNum)
		{
			if (!Internal)
			{
				pApplInfo->appl_Tag = ApplTag;
			}
			else	
			{
				if (pApplInfo->appl_ParentID == ParentID)
					UpdateDT = False;
			}

			pApplInfo->appl_ParentID = ParentID;
			ApplReplace = True;
		}
	}

	if (!ApplReplace)
	{
		// ppApplInfo now points to the right place
		if ((pApplInfo = ALLOC_APPLINFO()) != NULL)
		{
			pApplInfo->appl_Next = *ppApplInfo;
			*ppApplInfo = pApplInfo;
			pApplInfo->appl_Creator = Creator;
			pApplInfo->appl_Tag = ApplTag;
			pApplInfo->appl_FileNum = FileNum;
			pApplInfo->appl_ParentID = ParentID;
			pVolDesc->vds_cApplEnts ++;
		}
		else Status = AFP_ERR_MISC;
	}

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);

	return Status;
}


/***	AfpLookupAppl
 *
 *	Search the desktop for an appl entry matching the given Creator. In
 *	case of multiple appl entries corresponding to the same creator, get
 *	the nth where n is the index.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Shared);
 */
AFPSTATUS
AfpLookupAppl(
	IN  PVOLDESC 	pVolDesc,	// Volume descriptor of referenced desktop
	IN	DWORD		Creator,
	IN	LONG		Index,
	OUT PDWORD 		pApplTag,	// Place holder for Tag
	OUT PDWORD		pFileNum, 	// Place holder for file number
	OUT	PDWORD		pParentID	
)
{
	PAPPLINFO2	pApplInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;
	LONG		i;

	PAGED_CODE( );

	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);
	pApplInfo = pVolDesc->vds_pApplBuckets[HASH_ICON(Creator)];

	// Scan the list looking for the entry
	for (;pApplInfo != NULL; pApplInfo = pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_Creator == Creator)
			break;
		if (pApplInfo->appl_Creator > Creator) {
			pApplInfo = NULL;
			break;
		}
	}
	/*
	 * We are now either pointing to the first entry or there are none. In the
	 * latter case, we just fall through
	 */
	if (Index != 0)
	{
		for (i = 1; pApplInfo!=NULL; i++, pApplInfo = pApplInfo->appl_Next)
		{
			if ((i > Index)	|| (pApplInfo->appl_Creator != Creator))
			{
				pApplInfo = NULL;
				break;
			}
			if (i == Index)
				break;				// Found the right entry
		}
	}
	if (pApplInfo == NULL)
		Status = AFP_ERR_ITEM_NOT_FOUND;
	else
	{
		*pFileNum = pApplInfo->appl_FileNum;
		*pApplTag = pApplInfo->appl_Tag;
		*pParentID = pApplInfo->appl_ParentID;
	}
	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpRemoveAppl
 *
 *	The entries corresponding to the given Creator in the specified directory
 *	is removed from the desktop database. It is already determined that the
 *	application file exists and that the user has appropriate access to it.
 *
 *	LOCKS:	vds_DtAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpRemoveAppl(
	IN  PVOLDESC 	pVolDesc,		// Open Volume descriptor of ref desktop
	IN	DWORD		Creator,
	IN  DWORD		FileNum			// File number of the associated file
)
{
	PAPPLINFO2	pApplInfo, *ppApplInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;
	BOOLEAN		Found = False;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&pVolDesc->vds_DtAccessLock);
	ppApplInfo = &pVolDesc->vds_pApplBuckets[HASH_APPL(Creator)];

	// Find the APPL entry in the desktop
	for (;(pApplInfo = *ppApplInfo) != NULL; ppApplInfo = &pApplInfo->appl_Next)
	{
		if (pApplInfo->appl_Creator < Creator)
			continue;
		if (pApplInfo->appl_Creator > Creator)
			break;
		/*
		 * Check if the File number matches, if it does delete.
		 */
		if (pApplInfo->appl_FileNum == FileNum)
		{
			Found = True;
			*ppApplInfo = pApplInfo->appl_Next;
			AfpFreeMemory(pApplInfo);
			pVolDesc->vds_cApplEnts --;
			break;
		}
	}
	if (!Found)
		Status = AFP_ERR_ITEM_NOT_FOUND;

	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
	return Status;
}


/***	AfpAddComment
 *
 *	Add the comment to the file or directory in question. Create the comment
 *	stream on the entity in question (if it does not already exist), convert
 *	the comment to unicode and write it. Update the flag in the DFEntry.
 */
AFPSTATUS
AfpAddComment(
	IN  PSDA		 	pSda,		// Session Data Area
	IN  PVOLDESC		pVolDesc,	// Volume descriptor of referenced desktop
	IN  PANSI_STRING	Comment,	// Comment to associate with the file/dir
	IN  PPATHMAPENTITY	pPME,		// Handle to the entity or its Host Id
	IN	BOOLEAN			Directory,	// True if directory
	IN	DWORD			AfpId
)
{
	UNICODE_STRING	UComment;
	WCHAR			CommentBuf[AFP_MAXCOMMENTSIZE+1];
	FILESYSHANDLE	HandleCommentStream;
	DWORD			CreateInfo;
	NTSTATUS		Status = AFP_ERR_MISC;
	PDFENTRY		pDFE = NULL;
    BOOLEAN         RestoreModTime = FALSE;
    AFPTIME         aModTime;
    TIME            ModTime;

	PAGED_CODE( );

	ASSERT (IS_VOLUME_NTFS(pVolDesc));

	if (Comment->Length == 0)
	{
		AfpRemoveComment(pSda, pVolDesc, pPME, Directory, AfpId);
		return AFP_ERR_NONE;
	}

	if (Comment->Length > AFP_MAXCOMMENTSIZE)
	{
		// Truncate comment if necessary
		Comment->Length = AFP_MAXCOMMENTSIZE;
	}

	UComment.Buffer = CommentBuf;
	UComment.MaximumLength = (USHORT)(RtlAnsiStringToUnicodeSize(Comment) + sizeof(WCHAR));
	UComment.Length = 0;

	AfpConvertStringToUnicode(Comment, &UComment);

	do
	{
		AfpImpersonateClient(pSda);

        // Get the last modified time from the file so we can reset it.

        Status = AfpIoQueryTimesnAttr( &pPME->pme_Handle,
                                       NULL,
                                       &ModTime,
                                       NULL );

		if (NT_SUCCESS(Status))
        {
		    RestoreModTime = TRUE;
            aModTime = AfpConvertTimeToMacFormat(&ModTime);
        }

		// Open the comment stream on the target entity.
		Status = AfpIoCreate(&pPME->pme_Handle,
							AFP_STREAM_COMM,
							&UNullString,
							FILEIO_ACCESS_WRITE,
							FILEIO_DENY_NONE,
							FILEIO_OPEN_FILE,
							FILEIO_CREATE_HARD,
							FILE_ATTRIBUTE_NORMAL,
							True,
							NULL,
							&HandleCommentStream,
							&CreateInfo,
							NULL,
							NULL,
							NULL);

		AfpRevertBack();

		if (Status != AFP_ERR_NONE) {
			if ((Status = AfpIoConvertNTStatusToAfpStatus(Status)) != AFP_ERR_ACCESS_DENIED)
				Status = AFP_ERR_MISC;
			break;
		}

		Status = AfpIoWrite(&HandleCommentStream,
							&LIZero,
							(LONG)UComment.Length,
							(PBYTE)UComment.Buffer);

		AfpIoClose(&HandleCommentStream);

        if( RestoreModTime )
        {
            AfpIoSetTimesnAttr( &pPME->pme_Handle,
                                NULL,
                                &aModTime,
                                0,
                                0,
                                NULL,
                                NULL );
        }

		if (NT_SUCCESS(Status))
		{
			AfpVolumeSetModifiedTime(pVolDesc);

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			if ((pDFE = AfpFindDfEntryById(pVolDesc,
											AfpId,
											DFE_ANY)) != NULL)
            {
				pDFE->dfe_Flags |= DFE_FLAGS_HAS_COMMENT;
			}
			else
			{
				Status = AFP_ERR_MISC;
			}
			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
		}
	} while (False);

	return Status;
}


/***	AfpGetComment
 *
 *	Extract the comment from the file or directory in question. The comment is
 *	copied to the ReplyBuf.
 */
AFPSTATUS
AfpGetComment(
	IN  PSDA			pSda,			// Session Data Area
	IN  PVOLDESC		pVolDesc,		// Volume descriptor of referenced desktop
	IN  PPATHMAPENTITY	pPME,			// Handle to the entity or its Host Id
	IN	BOOLEAN			Directory		// True if directory
)
{
	NTSTATUS		Status = AFP_ERR_MISC;
	LONG			SizeRead;
	UNICODE_STRING	UComment;
	WCHAR			CommentBuf[AFP_MAXCOMMENTSIZE+1];
	ANSI_STRING		AComment;
	FILESYSHANDLE	HandleCommentStream;

	PAGED_CODE( );

	// ASSERT (IS_VOLUME_NTFS(pVolDesc));

	// Initialize AComment
	AComment.Buffer = pSda->sda_ReplyBuf + 1;	// For size of string
	AComment.MaximumLength = AFP_MAXCOMMENTSIZE;
	AComment.Length = 0;

	UComment.MaximumLength = (AFP_MAXCOMMENTSIZE + 1) * sizeof(WCHAR);
	UComment.Buffer = CommentBuf;

	do
	{
		AfpImpersonateClient(pSda);

		// Open the comment stream on the target entity.
		Status = AfpIoOpen(&pPME->pme_Handle,
							AFP_STREAM_COMM,
							FILEIO_OPEN_FILE,
							&UNullString,
							FILEIO_ACCESS_READ,
							FILEIO_DENY_NONE,
							True,
							&HandleCommentStream);

		AfpRevertBack();

		if (Status != AFP_ERR_NONE)
		{
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
			if (Status == AFP_ERR_OBJECT_NOT_FOUND)
				Status = AFP_ERR_ITEM_NOT_FOUND;
			else if (Status != AFP_ERR_ACCESS_DENIED)
				Status = AFP_ERR_OBJECT_NOT_FOUND;
			break;
		}

		Status = AfpIoRead(&HandleCommentStream,
						   &LIZero,
						   (LONG)UComment.MaximumLength,
						   &SizeRead,
						   (PBYTE)UComment.Buffer);

		AfpIoClose(&HandleCommentStream);

		if (Status == AFP_ERR_NONE)
		{
			UComment.Length = (USHORT) SizeRead;
			AfpConvertStringToAnsi(&UComment, &AComment);
			pSda->sda_ReplyBuf[0] = (BYTE)AComment.Length;
			pSda->sda_ReplySize = AComment.Length + 1;
		}
	} while (False);

	return Status;
}


/***	AfpRemoveComment
 *
 *	Remove the comment from the file or directory in question. Essentially
 *	open the comment stream and set the length to 0.
 */
AFPSTATUS
AfpRemoveComment(
	IN  PSDA			pSda,		// Session Data Area
	IN  PVOLDESC		pVolDesc,	// Volume descriptor of referenced desktop
	IN  PPATHMAPENTITY	pPME,		// Handle to the entity or its Host Id
	IN	BOOLEAN			Directory,	// True if directory
	IN	DWORD			AfpId
)
{
	FILESYSHANDLE	HandleCommentStream;
	NTSTATUS		Status = AFP_ERR_MISC;
	PDFENTRY		pDFE = NULL;

	PAGED_CODE( );

	ASSERT (IS_VOLUME_NTFS(pVolDesc));

	do
	{
		AfpImpersonateClient(pSda);

		// Open the comment stream on the target entity.
		Status = AfpIoOpen(&pPME->pme_Handle,
							AFP_STREAM_COMM,
							FILEIO_OPEN_FILE,
							&UNullString,
							FILEIO_ACCESS_DELETE,
							FILEIO_DENY_NONE,
							True,
							&HandleCommentStream);

		AfpRevertBack();

		if (Status != AFP_ERR_NONE)
		{
			if ((Status = AfpIoConvertNTStatusToAfpStatus(Status)) != AFP_ERR_ACCESS_DENIED)
				Status = AFP_ERR_ITEM_NOT_FOUND;
			break;
		}
		Status = AfpIoMarkFileForDelete(&HandleCommentStream, NULL, NULL, NULL);

		AfpIoClose(&HandleCommentStream);

		if (NT_SUCCESS(Status))
		{
			AfpVolumeSetModifiedTime(pVolDesc);

			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			if ((pDFE = AfpFindDfEntryById(pVolDesc,
											AfpId,
											DFE_ANY)) != NULL)
            {
				pDFE->dfe_Flags &= ~DFE_FLAGS_HAS_COMMENT;
			}
			else
			{
				Status = AFP_ERR_MISC;
			}
			AfpSwmrRelease(&pVolDesc->vds_IdDbAccessLock);
		}
	} while (False);

	return Status;
}


/***	AfpAddIconToGlobalList
 *
 *	The global list of icons is a server maintained list updated by the service.
 *	This adds an icon to the list. If an icon exists for the given type and
 *	creator, it is replaced. This list is maintained via the AfpIconAdd() admin
 *	api.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpAddIconToGlobalList(
	IN  DWORD	Type,
	IN  DWORD	Creator,
	IN  DWORD	IconType,
	IN  LONG	IconSize,
	IN  PBYTE	pIconBitMap
)
{
	PICONINFO	pIconInfo,
				pIconInfoNew,
				*ppIconInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	// Pre-allocate memory for the new icon, delete if necessary later
	if ((pIconInfoNew = ALLOC_ICONINFO(IconSize)) == NULL)
		return AFP_ERR_MISC;

	AfpSwmrAcquireExclusive(&AfpIconListLock);
	ppIconInfo = &AfpGlobalIconList;
	for (; (pIconInfo = *ppIconInfo) != NULL; ppIconInfo = &pIconInfo->icon_Next)
	{
		if ((pIconInfo->icon_Type == Type) &&
			(pIconInfo->icon_Creator == Creator))
			break;
	}
	if (pIconInfo == NULL)
	{
		if (IconSize > 0)
			RtlCopyMemory((PBYTE)pIconInfoNew + sizeof(ICONINFO), pIconBitMap, IconSize);
		pIconInfoNew->icon_Creator = Creator;
		pIconInfoNew->icon_Type = Type;
		pIconInfoNew->icon_IconType = (USHORT)IconType;
		pIconInfoNew->icon_Size = (SHORT)IconSize;
		pIconInfoNew->icon_Tag = 0;
		pIconInfoNew->icon_Next = NULL;
		*ppIconInfo = pIconInfoNew;
	}
	else
	{
		// We do not need the memory any more, release it
		AfpFreeMemory(pIconInfoNew);
		if (pIconInfo->icon_IconType != (USHORT)IconType)
			Status = AFPERR_InvalidParms;
		else if (IconSize > 0)
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO), pIconBitMap, IconSize);
	}
	AfpSwmrRelease(&AfpIconListLock);
	return AFP_ERR_NONE;
}


/***	afpLookupIconInGlobalList
 *
 *	The global list of icons is a server maintained list updates by the service.
 *	This is called by AfpLookupIcon() when the specified icon is not found in
 *	the volume desktop.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Shared);
 */
LOCAL AFPSTATUS
afpLookupIconInGlobalList(
	IN  DWORD	Creator,
	IN  DWORD	Type,
	IN  DWORD	IconType,
	IN  PLONG	pSize,
	OUT PBYTE	pBitMap
)
{
	PICONINFO	pIconInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	AfpSwmrAcquireShared(&AfpIconListLock);
	pIconInfo = AfpGlobalIconList;
	for (pIconInfo = AfpGlobalIconList;
		 pIconInfo != NULL;
		 pIconInfo = pIconInfo->icon_Next)
	{
		if ((pIconInfo->icon_Type == Type) &&
			(pIconInfo->icon_Creator == Creator) &&
			(pIconInfo->icon_IconType == (USHORT)IconType))
			break;
	}
	if (pIconInfo == NULL)
		Status = AFP_ERR_ITEM_NOT_FOUND;
	else
	{
		if (*pSize > pIconInfo->icon_Size)
			*pSize = pIconInfo->icon_Size;
		if (*pSize > 0)
			RtlCopyMemory(pBitMap, (PBYTE)pIconInfo + sizeof(ICONINFO), *pSize);
	}
	AfpSwmrRelease(&AfpIconListLock);
	return Status;
}


/***	AfpFreeGlobalIconList
 *
 *	Called at server stop time to free the memory allocated for the global
 *	icons.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Exclusive);
 */
VOID
AfpFreeGlobalIconList(
	VOID
)
{
	PICONINFO	pIconInfo;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&AfpIconListLock);

	for (pIconInfo = AfpGlobalIconList; pIconInfo != NULL; )
	{
		PICONINFO	pFree;

		pFree = pIconInfo;
		pIconInfo = pIconInfo->icon_Next;
		AfpFreeMemory (pFree);
	}

	AfpSwmrRelease(&AfpIconListLock);
}


/***	afpGetGlobalIconInfo
 *
 *	The global list of icons is a server maintained list updates by the service.
 *	This is called by AfpLookupIconInfo() when the specified icon is not found
 *	in the volume desktop.
 *
 *	LOCKS:	AfpIconListLock (SWMR, Shared)
 */
LOCAL AFPSTATUS
afpGetGlobalIconInfo(
	IN  DWORD	Creator,
	OUT PDWORD	pType,
	OUT PDWORD	pIconType,
	OUT PDWORD	pTag,
	OUT PLONG	pSize
)
{
	PICONINFO	pIconInfo;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	AfpSwmrAcquireExclusive(&AfpIconListLock);
	pIconInfo = AfpGlobalIconList;
	for (pIconInfo = AfpGlobalIconList;
		 pIconInfo != NULL;
		 pIconInfo = pIconInfo->icon_Next)
	{
		if (pIconInfo->icon_Creator == Creator)
			break;
	}
	if (pIconInfo == NULL)
		Status = AFP_ERR_ITEM_NOT_FOUND;
	else
	{
		*pType = pIconInfo->icon_Type;
		*pIconType = pIconInfo->icon_IconType;
		*pTag = pIconInfo->icon_Tag;
		*pSize = pIconInfo->icon_Size;
	}
	AfpSwmrRelease(&AfpIconListLock);
	return Status;
}


/*** afpReadDesktopFromDisk
 *
 *	Read the desktop database from the desktop stream. No locks are required
 *	for this routine since it only operates on volume descriptors which are
 *	newly created and not yet linked into the global volume list.
 */
LOCAL NTSTATUS
afpReadDesktopFromDisk(
	IN	PVOLDESC		pVolDesc,
	IN	PFILESYSHANDLE	pfshDesktop
)
{
	DESKTOP		Desktop;
	PAPPLINFO2	*ppApplInfo;
	PICONINFO	*ppIconInfo;
	NTSTATUS	Status;
	DWORD		DskOffst;
	FORKOFFST	ForkOffset;
	PBYTE		pBuffer;
	LONG		i, SizeRead, BufOffst = 0;
	LONG		PrevHash, applSize;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
			 ("\tReading Desktop from disk....\n") );

	// Work with one page of memory and do multiple I/Os to the disk.
	if ((pBuffer = AfpAllocNonPagedMemory(DESKTOPIO_BUFSIZE)) == NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	ForkOffset.QuadPart = DskOffst = 0;

	// Read in the desktop header and validate it
	Status = AfpIoRead(pfshDesktop,
					   &ForkOffset,
					   sizeof(DESKTOP),
					   &SizeRead,
					   (PBYTE)&Desktop);

	if (!NT_SUCCESS(Status) ||

		(SizeRead != sizeof(DESKTOP)) ||

		(Desktop.dtp_Signature != AFP_SERVER_SIGNATURE)	||

		((Desktop.dtp_Version != AFP_DESKTOP_VERSION1) &&
		 (Desktop.dtp_Version != AFP_DESKTOP_VERSION2))	||

		((Desktop.dtp_cApplEnts > 0) &&
		 ((ULONG_PTR)(Desktop.dtp_pApplInfo) != sizeof(DESKTOP))) ||

		((Desktop.dtp_cIconEnts > 0) &&
		 ((ULONG_PTR)(Desktop.dtp_pIconInfo) != sizeof(DESKTOP) +
						(Desktop.dtp_cApplEnts *
						((Desktop.dtp_Version == AFP_DESKTOP_VERSION1) ?
							sizeof(APPLINFO) : sizeof(APPLINFO2))) ))  )
	{
		AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, NULL, 0,
					 &pVolDesc->vds_Name);
		goto desktop_corrupt;
	}

	switch (Desktop.dtp_Version)
	{
		case AFP_DESKTOP_VERSION1:
		{
			AFPLOG_INFO(AFPSRVMSG_UPDATE_DESKTOP_VERSION,
						 STATUS_SUCCESS,
						 NULL,
						 0,
						 &pVolDesc->vds_Name);

			applSize = sizeof(APPLINFO);

			break;
		}
		case AFP_DESKTOP_VERSION2:
        {
			applSize = sizeof(APPLINFO2);
			break;
		}
		default:
        {
			// This should never happen since it was checked above
			DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_WARN,
				 ("afpReadDesktopFromDisk: Unexpected DT version 0x%lx\n", Desktop.dtp_Version) );
			ASSERTMSG("afpReadDesktopFromDisk: Unexpected DT Version", 0);
			goto desktop_corrupt;
		}
	}

	// Initialize the desktop header.  Even though we may be reading a
	// downlevel version database, set the in-memory desktop database
	// version to current version since we are building it with the
	// current appl version structure.
	AfpDtHdrToVolDesc(&Desktop, pVolDesc);

	ForkOffset.QuadPart = DskOffst = sizeof(DESKTOP);
	SizeRead = 0;

	// Now read in the APPL entries, if any
	for (i = 0, PrevHash = -1;
		(Status == AFP_ERR_NONE) && (i < Desktop.dtp_cApplEnts);
		i++)
	{
		PAPPLINFO2	pApplInfo;

		if ((SizeRead - BufOffst) < applSize)
		{
			// We have a partial APPLINFO.  Backup and read the whole thing
			DskOffst -= ((DWORD)SizeRead - (DWORD)BufOffst);
            ForkOffset.QuadPart = DskOffst;
			Status = AfpIoRead(pfshDesktop,
								&ForkOffset,
								DESKTOPIO_BUFSIZE,
								&SizeRead,
								pBuffer);
			if ((Status != AFP_ERR_NONE) || (SizeRead < applSize))
			{
				AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, &SizeRead,
							 sizeof(SizeRead), &pVolDesc->vds_Name);
				Status = STATUS_UNEXPECTED_IO_ERROR;
				break;
			}
			DskOffst += SizeRead;
			ForkOffset.QuadPart = DskOffst;
			BufOffst = 0;
		}

		if ((pApplInfo = ALLOC_APPLINFO()) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}
		pApplInfo->appl_ParentID = 0;
		// If we are reading downlevel appl structures, they will
		// get read into the first part of the current appl structures.
		// These fields should be identical!  If this is the case, the
		// appl_ParentId field will be 0 and the volume marked as needing
		// its appls rebuilt.
		RtlCopyMemory(pApplInfo, pBuffer + BufOffst, applSize);
		pApplInfo->appl_Next = NULL;
		BufOffst += applSize;
		if (PrevHash != (LONG)HASH_APPL(pApplInfo->appl_Creator))
		{
			PrevHash = (LONG)HASH_APPL(pApplInfo->appl_Creator);
			ppApplInfo = &pVolDesc->vds_pApplBuckets[PrevHash];
		}
		*ppApplInfo = pApplInfo;
		ppApplInfo = &pApplInfo->appl_Next;
	}


	// Now read in the ICON entries, if any

	for (i = 0, PrevHash = -1;
		(Status == AFP_ERR_NONE) && (i < Desktop.dtp_cIconEnts);
		i++)
	{
		PICONINFO	pIconInfo;

		if ((SizeRead - BufOffst) < sizeof(ICONINFO))
		{
			// We have a partial ICONINFO.  Backup and read the whole thing
			DskOffst -= ((DWORD)SizeRead - (DWORD)BufOffst);
			ForkOffset.QuadPart = DskOffst;
			Status = AfpIoRead(pfshDesktop,
								&ForkOffset,
								DESKTOPIO_BUFSIZE,
								&SizeRead,
								pBuffer);
			if ((Status != AFP_ERR_NONE) || (SizeRead < sizeof(ICONINFO)))
			{
				AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, &SizeRead,
							 sizeof(SizeRead), &pVolDesc->vds_Name);
				Status = STATUS_UNEXPECTED_IO_ERROR;
				break;
			}
			DskOffst += SizeRead;
			ForkOffset.QuadPart = DskOffst;
			BufOffst = 0;
		}

		// Validate icon size
		if ((((PICONINFO)(pBuffer + BufOffst))->icon_Size > ICONSIZE_ICN8) ||
			(((PICONINFO)(pBuffer + BufOffst))->icon_Size < ICONSIZE_ICS))
		{
			Status = STATUS_UNEXPECTED_IO_ERROR;
			AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status,
						 &((PICONINFO)(pBuffer + BufOffst))->icon_Size,
						 sizeof(((PICONINFO)(0))->icon_Size),
						 &pVolDesc->vds_Name);
			break;
		}

		if ((pIconInfo = ALLOC_ICONINFO(((PICONINFO)(pBuffer + BufOffst))->icon_Size)) == NULL)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}

		// First copy the icon header and then link the icon into the hash table
		RtlCopyMemory(pIconInfo, pBuffer + BufOffst, sizeof(ICONINFO));

		pIconInfo->icon_Next = NULL;
		if (PrevHash != (LONG)HASH_ICON(pIconInfo->icon_Creator))
		{
			PrevHash = (LONG)HASH_ICON(pIconInfo->icon_Creator);
			ppIconInfo = &pVolDesc->vds_pIconBuckets[PrevHash];
		}
		*ppIconInfo = pIconInfo;
		ppIconInfo = &pIconInfo->icon_Next;

		// Now check if there is sufficient stuff here to get the icon
		BufOffst += sizeof(ICONINFO);
		if ((SizeRead - BufOffst) < pIconInfo->icon_Size)
		{
			LONG	Size2Copy;

			Size2Copy = SizeRead - BufOffst;

			// Copy what we can first
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO),
						   pBuffer + BufOffst, Size2Copy);

			Status = AfpIoRead(pfshDesktop,
								&ForkOffset,
								DESKTOPIO_BUFSIZE,
								&SizeRead,
								pBuffer);
			if ((Status != AFP_ERR_NONE) ||
				(SizeRead < (pIconInfo->icon_Size - Size2Copy)))
			{
				AFPLOG_ERROR(AFPSRVMSG_READ_DESKTOP, Status, &SizeRead,
							 sizeof(SizeRead), &pVolDesc->vds_Name);
				Status = STATUS_UNEXPECTED_IO_ERROR;
				break;
			}
			DskOffst += SizeRead;
			ForkOffset.QuadPart = DskOffst;

			// Now copy the rest of the icon
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO) + Size2Copy,
						   pBuffer,
						   pIconInfo->icon_Size - Size2Copy);

			BufOffst = pIconInfo->icon_Size - Size2Copy;
		}
		else
		{
			RtlCopyMemory((PBYTE)pIconInfo + sizeof(ICONINFO),
							pBuffer + BufOffst,
							pIconInfo->icon_Size);

			BufOffst += pIconInfo->icon_Size;
		}
	}

	if (Status != AFP_ERR_NONE)
	{
		AfpFreeDesktopTables(pVolDesc);
desktop_corrupt:
		// We have essentially ignored the existing data in the stream
		// Initialize the header
		pVolDesc->vds_cApplEnts = 0;
		pVolDesc->vds_cIconEnts = 0;

		AfpVolDescToDtHdr(pVolDesc, &Desktop);
		Desktop.dtp_pIconInfo = NULL;
		Desktop.dtp_pApplInfo = NULL;
		AfpIoWrite(pfshDesktop,
					&LIZero,
					sizeof(DESKTOP),
					(PBYTE)&Desktop);

		// Truncate the stream at this point
		AfpIoSetSize(pfshDesktop, sizeof(DESKTOP));
		Status = STATUS_SUCCESS;
	}

	if (pBuffer != NULL)
		AfpFreeMemory(pBuffer);

	return Status;
}



/***	AfpInitDesktop
 *
 *	This routine initializes the memory image (and all related volume
 *	descriptor fields) of the desktop for a newly added volume.  If a desktop
 *	stream already exists on the disk for the volume root directory, that
 *	stream is read in.  If this is a newly created volume, the desktop
 *	stream is created on the root of the volume.  If this is a CD-ROM volume,
 *	only the memory image is initialized.
 *
 *	No locks are necessary since this routine only operates on volume
 *	descriptors which are newly allocated, but not yet linked into the global
 *	volume list.
 */
AFPSTATUS
AfpInitDesktop(
	IN	PVOLDESC	pVolDesc,
    OUT BOOLEAN    *pfNewVolume
)
{
	BOOLEAN				InitHeader = True;
	NTSTATUS			Status = STATUS_SUCCESS;
	FILESYSHANDLE		fshDesktop;

	PAGED_CODE( );

    // for now
    *pfNewVolume = FALSE;

	DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO, ("\tInitializing Desktop...\n") );
	AfpSwmrInitSwmr(&(pVolDesc->vds_DtAccessLock));

	// if this is an NTFS volume, attempt to create the desktop stream.
	// If it already exists, open it and read it in.
	if (IS_VOLUME_NTFS(pVolDesc))
	{
		ULONG	CreateInfo;

        InitHeader = False;

		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
						AFP_STREAM_DT,
						&UNullString,
						FILEIO_ACCESS_READWRITE,
						FILEIO_DENY_WRITE,
						FILEIO_OPEN_FILE,
						FILEIO_CREATE_INTERNAL,
						FILE_ATTRIBUTE_NORMAL,
						False,
						NULL,
						&fshDesktop,
						&CreateInfo,
						NULL,
						NULL,
						NULL);

		if (NT_SUCCESS(Status))
		{
			if (CreateInfo == FILE_OPENED)
			{
				Status = afpReadDesktopFromDisk(pVolDesc, &fshDesktop);
				AfpIoClose(&fshDesktop);
			}
			else if (CreateInfo != FILE_CREATED)
			{
				DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_ERR,
				 ("AfpInitDesktop: Unexpected create action 0x%lx\n", CreateInfo) );
				ASSERT(0); // this should never happen
				Status = STATUS_UNSUCCESSFUL;
			}
            else
            {
                DBGPRINT(DBG_COMP_VOLUME, DBG_LEVEL_ERR,
                    ("AfpInitDesktop: volume %Z is new\n",&pVolDesc->vds_Name));

                InitHeader = True;
                *pfNewVolume = TRUE;
            }
		}
		else
		{
			DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_ERR,
				 ("AfpInitDesktop: AfpIoCreate failed %lx\n", Status));
			Status = STATUS_UNSUCCESSFUL;
		}
	}

	if (InitHeader)
	{
		DESKTOP	Desktop;

		// Initialize the header
		pVolDesc->vds_cApplEnts = 0;
		pVolDesc->vds_cIconEnts = 0;

		if (IS_VOLUME_NTFS(pVolDesc))
		{
			AfpVolDescToDtHdr(pVolDesc, &Desktop);
			Desktop.dtp_pIconInfo = NULL;
			Desktop.dtp_pApplInfo = NULL;
			AfpIoWrite(&fshDesktop,
						&LIZero,
						sizeof(DESKTOP),
						(PBYTE)&Desktop);
			AfpIoClose(&fshDesktop);
		}
	}
	return Status;
}


/***	AfpUpdateDesktop
 *
 *	Update the desktop database on the volume root. The swmr access is held
 *	for read (by the caller) while the update is in progress. It is already
 *	determined by the caller that the volume desktop needs to be updated.
 *
 *	LOCKS: vds_DtAccessLock (SWMR, Shared)
 */
VOID
AfpUpdateDesktop(
	IN  PVOLDESC pVolDesc		// Volume Descriptor of the open volume
)
{
	AFPSTATUS		Status;
	PBYTE			pBuffer;
	DWORD			Offset = 0, Size;
	LONG			i;
	DESKTOP			Desktop;
	FORKOFFST		ForkOffset;
	FILESYSHANDLE	fshDesktop;
	ULONG			CreateInfo;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	PAGED_CODE( );

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DesktopUpdCount);
	AfpGetPerfCounter(&TimeS);
#endif

	// Take the swmr so that nobody can initiate changes to the desktop
	AfpSwmrAcquireShared(&pVolDesc->vds_DtAccessLock);

	DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
			 ("\tWriting Desktop to disk....\n") );

	do
	{
		fshDesktop.fsh_FileHandle = NULL;
		// Work with one page of memory and do multiple I/Os to the disk.
		if ((pBuffer = AfpAllocPagedMemory(DESKTOPIO_BUFSIZE)) == NULL)
		{
			AFPLOG_ERROR(AFPSRVMSG_WRITE_DESKTOP, STATUS_NO_MEMORY, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}

		// Open a handle to the desktop stream, denying others read/write
		// access (i.e. backup/restore)
		Status = AfpIoCreate(&pVolDesc->vds_hRootDir,
							 AFP_STREAM_DT,
							 &UNullString,
							 FILEIO_ACCESS_WRITE,
							 FILEIO_DENY_ALL,
							 FILEIO_OPEN_FILE,
							 FILEIO_CREATE_INTERNAL,
							 FILE_ATTRIBUTE_NORMAL,
							 False,
							 NULL,
							 &fshDesktop,
							 &CreateInfo,
							 NULL,
							 NULL,
							 NULL);

		if (NT_SUCCESS(Status))
		{
			if ((CreateInfo != FILE_OPENED) && (CreateInfo != FILE_CREATED))
			{
				// This should never happen!
				DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_WARN,
				 ("AfpUpdateDesktop: Unexpected create action 0x%lx\n", CreateInfo) );
				ASSERTMSG("AfpUpdateDesktop: Unexpected create action", 0);
				break;
			}
		}
		else
		{
			AFPLOG_ERROR(AFPSRVMSG_WRITE_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
			break;
		}

		// Snapshot the header and write it with an invalid signature. We write
		// the header again later with a valid signature. This protects us from
		// incomplete writes (server crash etc.)
		AfpVolDescToDtHdr(pVolDesc, &Desktop);
		Desktop.dtp_Signature = 0;

		(ULONG_PTR)(Desktop.dtp_pApplInfo) = 0;
		if (Desktop.dtp_cApplEnts > 0)
			(ULONG_PTR)(Desktop.dtp_pApplInfo) = sizeof(DESKTOP);

		(ULONG_PTR)(Desktop.dtp_pIconInfo) = 0;
		if (Desktop.dtp_cIconEnts > 0)
			(ULONG_PTR)(Desktop.dtp_pIconInfo) = sizeof(DESKTOP) +
										 sizeof(APPLINFO2)*Desktop.dtp_cApplEnts;

		// Write out the header with invalid signature
		Status = AfpIoWrite(&fshDesktop,
							&LIZero,
							sizeof(DESKTOP),
							(PBYTE)&Desktop);

		Offset = sizeof(DESKTOP);
		Size = 0;

		// First write the APPL Entries
		for (i = 0; (Status == AFP_ERR_NONE) && (i < APPL_BUCKETS); i++)
		{
			PAPPLINFO2		pApplInfo;

			for (pApplInfo = pVolDesc->vds_pApplBuckets[i];
				 (Status == AFP_ERR_NONE) && (pApplInfo != NULL);
				 pApplInfo = pApplInfo->appl_Next)
			{
				if ((DESKTOPIO_BUFSIZE - Size) < sizeof(APPLINFO2))
				{
					DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
						("afpUpdateDesktop: Writing Appl %ld at %ld\n", Size, Offset));

					ForkOffset.QuadPart = Offset;
					Status = AfpIoWrite(&fshDesktop,
										&ForkOffset,
										Size,
										pBuffer);
					Size = 0;
					Offset += Size;
				}
				*(PAPPLINFO2)(pBuffer + Size) = *pApplInfo;
				Size += sizeof(APPLINFO2);
			}
		}

		// And now the ICON entries
		for (i = 0; (Status == AFP_ERR_NONE) && (i < ICON_BUCKETS); i++)
		{
			PICONINFO		pIconInfo;

			for (pIconInfo = pVolDesc->vds_pIconBuckets[i];
				 (Status == AFP_ERR_NONE) && (pIconInfo != NULL);
				 pIconInfo = pIconInfo->icon_Next)
			{
				if ((DESKTOPIO_BUFSIZE - Size) < (sizeof(ICONINFO) + pIconInfo->icon_Size))
				{
					DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
						("afpUpdateDesktop: Writing icons %ld at %ld\n", Size, Offset));

					ForkOffset.QuadPart = Offset;
					Status = AfpIoWrite(&fshDesktop,
										&ForkOffset,
										Size,
										pBuffer);
					Offset += Size;
					Size = 0;
				}
				RtlCopyMemory(pBuffer + Size,
							  (PBYTE)pIconInfo,
							  sizeof(ICONINFO) + pIconInfo->icon_Size);
				Size += sizeof(ICONINFO) + pIconInfo->icon_Size;
			}
		}

		while (Status == AFP_ERR_NONE)
		{
			if (Size > 0)
			{
				DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
						("afpUpdateDesktop: Writing at end %ld at %ld\n", Size, Offset));

				ForkOffset.QuadPart = Offset;
				Status = AfpIoWrite(&fshDesktop,
									&ForkOffset,
									Size,
									pBuffer);
				if (Status != AFP_ERR_NONE)
					break;
			}

			DBGPRINT(DBG_COMP_DESKTOP, DBG_LEVEL_INFO,
					("afpUpdateDesktop: Setting desktop stream size @ %ld\n", Size + Offset));
			// Chop off the stream at this offset.
			Status = AfpIoSetSize(&fshDesktop, Offset + Size);

			ASSERT (Status == AFP_ERR_NONE);

			// Write the correct signature back
			Desktop.dtp_Signature = AFP_SERVER_SIGNATURE;

			Status = AfpIoWrite(&fshDesktop,
								&LIZero,
								sizeof(DESKTOP),
								(PBYTE)&Desktop);

			// Update the count of changes: vds_cChangesDt is protected by the
			// swmr, the scavenger can set this with READ access.  All others
			// MUST hold the swmr for WRITE access to increment the cChangesDt.
			// Scavenger is the only consumer of vds_cScvgrDt, so no lock is
			// really needed for it.
			pVolDesc->vds_cScvgrDt = 0;
			break;
		}

		if (Status != AFP_ERR_NONE)
		{
			AFPLOG_ERROR(AFPSRVMSG_WRITE_DESKTOP, Status, NULL, 0,
						 &pVolDesc->vds_Name);
		}

	} while (False);

	if (pBuffer != NULL)
	{
		AfpFreeMemory(pBuffer);
		if (fshDesktop.fsh_FileHandle != NULL)
			AfpIoClose(&fshDesktop);
	}
#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DesktopUpdTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	AfpSwmrRelease(&pVolDesc->vds_DtAccessLock);
}


/***	AfpFreeDesktopTables
 *
 *	Free the allocated memory for the volume desktop tables. The volume is
 *	about to be deleted. Ensure that either the volume is non-NTFS or it is
 *	clean i.e. the scavenger threads have written it back. No locks are needed
 *	as this structure is all by itself.
 */
VOID
AfpFreeDesktopTables(
	IN	PVOLDESC	pVolDesc
)
{
	LONG		i;

	PAGED_CODE( );

	// This should never happen
	ASSERT (!IS_VOLUME_NTFS(pVolDesc) ||
			 (pVolDesc->vds_pOpenForkDesc == NULL));

	// First tackle the ICON list. Traverse each of the hash indices.
	// Note that the icon is allocated as part of the IconInfo structure
	// so free in together.
	for (i = 0; i < ICON_BUCKETS; i++)
	{
		PICONINFO	pIconInfo, pFree;

		for (pIconInfo = pVolDesc->vds_pIconBuckets[i]; pIconInfo != NULL; )
		{
			pFree = pIconInfo;
			pIconInfo = pIconInfo->icon_Next;
			AfpFreeMemory(pFree);
		}
		// In case we ever try to free the table again
		pVolDesc->vds_pIconBuckets[i] = NULL;
	}

	// Now tackle the APPL list. Traverse each of the hash indices.
	for (i = 0; i < APPL_BUCKETS; i++)
	{
		PAPPLINFO2	pApplInfo, pFree;

		for (pApplInfo = pVolDesc->vds_pApplBuckets[i]; pApplInfo != NULL; )
		{
			pFree = pApplInfo;
			pApplInfo = pApplInfo->appl_Next;
			AfpFreeMemory(pFree);
		}
		// In case we ever try to free the table again
		pVolDesc->vds_pApplBuckets[i] = NULL;
	}
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\desktop.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	desktop.h

Abstract:

	This module contains the desktop database structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _DESKTOP_
#define _DESKTOP_

#define AFP_DESKTOP_VERSION1	0x00010000
#define AFP_DESKTOP_VERSION2	0x00020000
#define AFP_DESKTOP_VERSION		AFP_DESKTOP_VERSION2

typedef struct _ApplInfo
{
	struct _ApplInfo * appl_Next;		// link to next entry for this hash
	DWORD	appl_Creator;				// Creator
	DWORD	appl_FileNum;				// File Number of the application file
	DWORD	appl_Tag;					// APPL Tag
} APPLINFO, *PAPPLINFO;

// NOTE: the first 4 fields of _ApplInfo2 must be exactly the same as
// _ApplInfo so that version 1 desktop APPLs can be read into the version 2
// structure.
typedef struct _ApplInfo2
{
	struct _ApplInfo2 * appl_Next;		// link to next entry for this hash
	DWORD	appl_Creator;				// Creator
	DWORD	appl_FileNum;				// File Number of the application file
	DWORD	appl_Tag;					// APPL Tag
	DWORD	appl_ParentID;				// DirId of parent of the app file
} APPLINFO2, *PAPPLINFO2;

typedef struct _IconInfo
{
	struct _IconInfo * icon_Next;		// Link to Next entry for this hash
	DWORD	icon_Creator;				// Creator
	DWORD	icon_Type;					// Finder Type
	DWORD	icon_Tag;					// ICON Tag
	USHORT	icon_IconType;				// Icon type
	SHORT	icon_Size;					// Size of Icon
	// Icon bitmap follows the structure
} ICONINFO, *PICONINFO;


typedef struct _Desktop
{
	DWORD		dtp_Signature;				// Signature
	DWORD		dtp_Version;				// Version number
	LONG		dtp_cApplEnts;				// Number of APPL entries
	PAPPLINFO	dtp_pApplInfo;				// Pointer to 1st APPL entry
											// Used only on disk
	LONG		dtp_cIconEnts;				// Number of ICON entries
	PICONINFO	dtp_pIconInfo;				// Pointer to 1st ICON entry
											// Used only on disk
} DESKTOP, *PDESKTOP;

#define	DESKTOPIO_BUFSIZE			8180	// 8192 - 12
#define	HASH_ICON(Creator)			((Creator) % ICON_BUCKETS)
#define	HASH_APPL(Creator)			((Creator) % APPL_BUCKETS)


GLOBAL	SWMR					AfpIconListLock EQU { 0 };
GLOBAL	PICONINFO				AfpGlobalIconList EQU NULL;

extern
NTSTATUS
AfpDesktopInit(
	VOID
);

extern
AFPSTATUS
AfpAddIcon(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					Type,
	IN	DWORD					Tag,
	IN	LONG					IconSize,
	IN	DWORD					IconType,
	IN	PBYTE					pIconBitmap
);

extern
AFPSTATUS
AfpLookupIcon(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					Type,
	IN	LONG					Length,
	IN	DWORD					IconType,
    OUT PLONG                   pActualLength,
	OUT PBYTE					pIconBitMap
);

extern
AFPSTATUS
AfpLookupIconInfo(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	LONG					Index,
	OUT PDWORD					pType,
	OUT PDWORD	 				pIconType,
	OUT PDWORD					pTag,
	OUT PLONG					pSize
);

extern
AFPSTATUS
AfpAddAppl(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					ApplTag,
	IN	DWORD					FileNum,
	IN	BOOLEAN					Internal,
	IN	DWORD					ParentID
);

extern
AFPSTATUS
AfpLookupAppl(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	LONG					Index,
	OUT PDWORD					pApplTag,
	OUT PDWORD					pFileNum,
	OUT	PDWORD					pParentID
);

extern
AFPSTATUS
AfpRemoveAppl(
	IN	struct _VolDesc *		pVolDesc,
	IN	DWORD					Creator,
	IN	DWORD					FileNum
);

extern
AFPSTATUS
AfpAddComment(
	IN	PSDA					pSda,
	IN	struct _VolDesc *		pVolDesc,
	IN	PANSI_STRING			Comment,
	IN	struct _PathMapEntity *	PME,
	IN	BOOLEAN					Directory,
	IN	DWORD					AfpId
);

extern
AFPSTATUS
AfpGetComment(
	IN	PSDA					pSda,
	IN	struct _VolDesc *		pVolDesc,
	IN	struct _PathMapEntity *	PME,
	IN	BOOLEAN					Directory
);

extern
AFPSTATUS
AfpRemoveComment(
	IN	PSDA					pSda,
	IN	struct _VolDesc *		pVolDesc,
	IN	struct _PathMapEntity *	PME,
	IN	BOOLEAN					Directory,
	IN	DWORD					AfpId
);

extern
AFPSTATUS
AfpAddIconToGlobalList(
	IN	DWORD					Type,
	IN	DWORD					Creator,
	IN	DWORD					IconType,
	IN	LONG					IconSize,
	IN	PBYTE					pIconBitMap
);

extern
VOID
AfpFreeGlobalIconList(
	VOID
);

extern
AFPSTATUS
AfpInitDesktop(
	IN	struct _VolDesc *		pVolDesc,
    OUT BOOLEAN         *       pfNewVolume
);


extern
VOID
AfpUpdateDesktop(
	IN	struct _VolDesc *		pVolDesc
);

extern
VOID
AfpFreeDesktopTables(
	IN	struct _VolDesc *		pVolDesc
);


#ifdef	DESKTOP_LOCALS

#define	ALLOC_ICONINFO(IconLen)	(PICONINFO)AfpAllocPagedMemory((IconLen) + sizeof(ICONINFO))

#define	ALLOC_APPLINFO()		(PAPPLINFO2)AfpAllocPagedMemory(sizeof(APPLINFO2))

LOCAL AFPSTATUS
afpGetGlobalIconInfo(
	IN	DWORD					Creator,
	OUT PDWORD					pType,
	OUT PDWORD					pIconType,
	OUT PDWORD					pTag,
	OUT PLONG					pSize
);

LOCAL AFPSTATUS
afpLookupIconInGlobalList(
	IN	DWORD					Creator,
	IN	DWORD					Type,
	IN	DWORD					IconType,
	IN	PLONG					pSize,
	OUT PBYTE					pBitMap
);

LOCAL NTSTATUS
afpReadDesktopFromDisk(
	IN	struct _VolDesc *			pVolDesc,
	IN	struct _FileSysHandle *		pfshDesktop
);

#endif	// DESKTOP_LOCALS

#endif	// _DESKTOP_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\client.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	client.h

Abstract:

	This module contains prototypes for client impersonation and Lsa support
	routines.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	08 Jul 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_CLIENT_
#define	_CLIENT_

extern
VOID
AfpImpersonateClient(
	IN	PSDA	pSda	OPTIONAL
);


extern
VOID
AfpRevertBack(
	VOID
);


extern
AFPSTATUS
AfpLogonUser(
	IN	PSDA			pSda,
	IN	PANSI_STRING	UserPasswd
);


extern
PBYTE
AfpGetChallenge(
	IN	VOID
);

#endif	// _CLIENT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\client.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the client impersonation code.

Author:

    Jameel Hyder (microsoft!jameelh)


Revision History:
    16 Jun 1992  Initial Version

Notes:  Tab stop: 4
--*/

#define FILENUM FILE_CLIENT

#include <afp.h>
#include <client.h>
#include <access.h>
#include <secutil.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpImpersonateClient)
#pragma alloc_text( PAGE, AfpRevertBack)
#pragma alloc_text( PAGE, AfpGetChallenge)
#pragma alloc_text( PAGE, AfpLogonUser)
#endif



/***    AfpImpersonateClient
 *
 *  Impersonates the remote client. The token representing the remote client
 *  is available in the SDA. If the SDA is NULL (i.e. server context) then
 *  impersonate the token that we have created for ourselves.
 */
VOID
AfpImpersonateClient(
    IN  PSDA    pSda    OPTIONAL
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    HANDLE      Token;

    PAGED_CODE( );

    if (pSda != NULL)
    {
        Token = pSda->sda_UserToken;
    }
    else Token = AfpFspToken;

    ASSERT(Token != NULL);

    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID)&Token,
                                    sizeof(Token));
    ASSERT(NT_SUCCESS(Status));
}


/***    AfpRevertBack
 *
 *  Revert back to the default thread context.
 */
VOID
AfpRevertBack(
    VOID
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    HANDLE      Handle = NULL;

    PAGED_CODE( );

    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID)&Handle,
                                    sizeof(Handle));
    ASSERT(NT_SUCCESS(Status));
}


/***    AfpGetChallenge
 *
 *  Obtain a challenge token from the MSV1_0 package. This token is used by
 *  AfpLogin call.
 *
 *  The following function modified so that we generate the challenge ourselves
 *  instead of making a call.  This routine borrowed almost verbatim from
 *  the LM server code.
 */
PBYTE
AfpGetChallenge(
    IN  VOID
)
{
    PMSV1_0_LM20_CHALLENGE_REQUEST  ChallengeRequest;
    PMSV1_0_LM20_CHALLENGE_RESPONSE ChallengeResponse;
    ULONG                           Length;
    PBYTE                           pRetBuf;
    NTSTATUS                        Status, StatusX;
    union
    {
        LARGE_INTEGER   time;
        UCHAR           bytes[8];
    } u;

    ULONG seed;
    ULONG challenge[2];
    ULONG result3;

    PAGED_CODE( );

    ChallengeRequest = NULL;

    //
    // Create a pseudo-random 8-byte number by munging the system time
    // for use as a random number seed.
    //
    // Start by getting the system time.
    //

    ASSERT( MSV1_0_CHALLENGE_LENGTH == 2 * sizeof(ULONG) );

    KeQuerySystemTime( &u.time );

    //
    // To ensure that we don't use the same system time twice, add in the
    // count of the number of times this routine has been called.  Then
    // increment the counter.
    //
    // *** Since we don't use the low byte of the system time (it doesn't
    //     take on enough different values, because of the timer
    //     resolution), we increment the counter by 0x100.
    //
    // *** We don't interlock the counter because we don't really care
    //     if it's not 100% accurate.
    //

    u.time.LowPart += EncryptionKeyCount;

    EncryptionKeyCount += 0x100;

    //
    // Now use parts of the system time as a seed for the random
    // number generator.
    //
    // *** Because the middle two bytes of the low part of the system
    //     time change most rapidly, we use those in forming the seed.
    //

    seed = ((u.bytes[1] + 1) <<  0)  |
            ((u.bytes[2] + 0) <<  8) |
            ((u.bytes[2] - 1) << 16) |
            ((u.bytes[1] + 0) << 24);

    //
    // Now get two random numbers.  RtlRandom does not return negative
    // numbers, so we pseudo-randomly negate them.
    //

    challenge[0] = RtlRandom( &seed );
    challenge[1] = RtlRandom( &seed );
    result3 = RtlRandom( &seed );

    if ( (result3 & 0x1) != 0 )
    {
        challenge[0] |= 0x80000000;
    }
    if ( (result3 & 0x2) != 0 )
    {
        challenge[1] |= 0x80000000;
    }

    // Allocate a buffer to hold the challenge and copy it in
    if ((pRetBuf = AfpAllocNonPagedMemory(MSV1_0_CHALLENGE_LENGTH)) != NULL)
    {
        RtlCopyMemory(pRetBuf, challenge, MSV1_0_CHALLENGE_LENGTH);
    }

    return (pRetBuf);
}



/***    AfpLogonUser
 *
 *  Attempt to login the user. The password is either encrypted or cleartext
 *  based on the UAM used. The UserName and domain is extracted out of the Sda.
 *
 *  LOCKS:  AfpStatisticsLock (SPIN)
 */
AFPSTATUS
AfpLogonUser(
    IN  PSDA        pSda,
    IN  PANSI_STRING    UserPasswd
)
{
    NTSTATUS                    Status, SubStatus;
    PUNICODE_STRING             WSName;
    ULONG                       ulUnused;
    ULONG                       NtlmInTokenSize;
    PNTLM_AUTHENTICATE_MESSAGE  NtlmInToken = NULL;
    PAUTHENTICATE_MESSAGE       InToken = NULL;
    ULONG                       InTokenSize;
    PNTLM_ACCEPT_RESPONSE       OutToken = NULL;
    ULONG                       OutTokenSize;
    SIZE_T                      AllocateSize;
    SecBufferDesc               InputToken;
    SecBuffer                   InputBuffers[2];
    SecBufferDesc               OutputToken;
    SecBuffer                   OutputBuffer;
    CtxtHandle                  hNewContext;
    TimeStamp                   Expiry;
    ULONG                       BufferOffset;
    PCHAR                       pTmp;
    PRAS_SUBAUTH_INFO           pRasSubAuthInfo;
    PARAP_SUBAUTH_REQ           pSfmSubAuthInfo;
    PARAP_SUBAUTH_RESP          pSfmResp;
    DWORD                       ResponseHigh;
    DWORD                       ResponseLow;
    DWORD                       dwTmpLen;


    PAGED_CODE( );

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#ifdef OPTIMIZE_GUEST_LOGONS
     // 11/28/94 SueA: Now that there is a License Service to track the number
     // of sessions via LsaLogonUser, we can no longer fake the guest tokens.

     // Optimization for subsequent guest logons
     // After the first guest logon, we save the token and do not free it till the
     // server stops. All subsequent guest logons 'share' that token.
    if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
    {
        AfpSwmrAcquireExclusive(&AfpEtcMapLock);

        if (AfpGuestToken != NULL)
        {
            pSda->sda_UserToken = AfpGuestToken;
            pSda->sda_UserSid = &AfpSidWorld;
            pSda->sda_GroupSid = &AfpSidWorld;  // Primary group of Guest is also 'World'
#ifdef  INHERIT_DIRECTORY_PERMS
            pSda->sda_UID = AfpIdWorld;
            pSda->sda_GID = AfpIdWorld;
#else
            ASSERT (AfpGuestSecDesc != NULL);
            pSda->sda_pSecDesc = AfpGuestSecDesc;
#endif
            AfpSwmrRelease(&AfpEtcMapLock);
            return AFP_ERR_NONE;
        }
        else
        {
            AfpSwmrRelease(&AfpEtcMapLock);
        }
    }

#endif  // OPTIMIZE_GUEST_LOGONS


    WSName = &AfpDefaultWksta;
    if (pSda->sda_WSName.Length != 0)
        WSName = &pSda->sda_WSName;


    //
    // Figure out how big a buffer we need.  We put all the messages
    // in one buffer for efficiency's sake.
    //

    NtlmInTokenSize = sizeof(NTLM_AUTHENTICATE_MESSAGE);

    // alignment needs to be correct based on 32/64 bit addressing!!!
    NtlmInTokenSize = (NtlmInTokenSize + 7) & 0xfffffff8;

    InTokenSize = sizeof(AUTHENTICATE_MESSAGE) +
                  pSda->sda_UserName.Length +
                  WSName->Length +
                  (sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ)) +
                  pSda->sda_DomainName.Length +
                  UserPasswd->Length +
                  24;                    // extra for byte aligning

    InTokenSize = (InTokenSize + 7) & 0xfffffff8;

    OutTokenSize = sizeof(NTLM_ACCEPT_RESPONSE);
    OutTokenSize = (OutTokenSize + 7) & 0xfffffff8;

    //
    // Round this up to 8 byte boundary becaus the out token needs to be
    // quad word aligned for the LARGE_INTEGER.
    //
    AllocateSize = ((NtlmInTokenSize + InTokenSize + 7) & 0xfffffff8) + OutTokenSize;


    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &InToken,
                                     0L,
                                     &AllocateSize,
                                     MEM_COMMIT,
                                     PAGE_READWRITE);

    if (!NT_SUCCESS(Status))
    {
        AFPLOG_ERROR(AFPSRVMSG_PAGED_POOL, Status, &AllocateSize,sizeof(AllocateSize), NULL);
#if DBG
        DbgBreakPoint();
#endif
        return(AFP_ERR_MISC);
    }

    NtlmInToken = (PNTLM_AUTHENTICATE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
    OutToken = (PNTLM_ACCEPT_RESPONSE) ((PUCHAR)NtlmInToken + ((NtlmInTokenSize + 7) & 0xfffffff8));

    RtlZeroMemory(InToken, InTokenSize + NtlmInTokenSize);

    //
    // set up the NtlmInToken first
    //

    if (pSda->sda_Challenge)
    {
        RtlCopyMemory(NtlmInToken->ChallengeToClient,
                      pSda->sda_Challenge,
                      MSV1_0_CHALLENGE_LENGTH );
    }

    if ((pSda->sda_ClientType == SDA_CLIENT_RANDNUM) ||
        (pSda->sda_ClientType == SDA_CLIENT_TWOWAY))
    {
        NtlmInToken->ParameterControl = (MSV1_0_SUBAUTHENTICATION_DLL_RAS << 24);
    }
    else
    {
        NtlmInToken->ParameterControl = 0;
    }

    //
    // Okay, now for the tought part - marshalling the AUTHENTICATE_MESSAGE
    //

    RtlCopyMemory(InToken->Signature,
                  NTLMSSP_SIGNATURE,
                  sizeof(NTLMSSP_SIGNATURE) );

    InToken->MessageType = NtLmAuthenticate;

    BufferOffset = sizeof(AUTHENTICATE_MESSAGE);

    //
    // LM password - case insensitive
    //

    pTmp = (PBYTE)InToken + BufferOffset;
    *(LPWSTR)pTmp = L'\0';

    InToken->LmChallengeResponse.Buffer = BufferOffset;
    InToken->LmChallengeResponse.Length = 1;
    InToken->LmChallengeResponse.MaximumLength = sizeof(WCHAR);

    InToken->NtChallengeResponse.Buffer = BufferOffset;
    InToken->NtChallengeResponse.Length = 0;
    InToken->NtChallengeResponse.MaximumLength = sizeof(WCHAR);

    InToken->DomainName.Buffer = BufferOffset;
    InToken->DomainName.Length = 0;
    InToken->DomainName.MaximumLength = sizeof(WCHAR);

    InToken->Workstation.Buffer = BufferOffset;
    InToken->Workstation.Length = 0;
    InToken->Workstation.MaximumLength = sizeof(WCHAR);

    InToken->UserName.Buffer = BufferOffset;
    InToken->UserName.Length = 0;
    InToken->UserName.MaximumLength = sizeof(WCHAR);


    if (pSda->sda_UserName.Length != 0)
    {

        if (pSda->sda_DomainName.Length != 0)
        {

            InToken->DomainName.Length = pSda->sda_DomainName.Length;
            InToken->DomainName.MaximumLength = pSda->sda_DomainName.MaximumLength;

            InToken->DomainName.Buffer = BufferOffset;
            RtlCopyMemory((PBYTE)InToken + BufferOffset,
                          (PBYTE)pSda->sda_DomainName.Buffer,
                          pSda->sda_DomainName.Length);
            BufferOffset += pSda->sda_DomainName.Length;
            BufferOffset = (BufferOffset + 3) & 0xfffffffc; // dword align it
        }


        InToken->LmChallengeResponse.Buffer = BufferOffset;

        //
        // is he using native Apple UAM? setup buffers differently!
        //
        if ((pSda->sda_ClientType == SDA_CLIENT_RANDNUM) ||
            (pSda->sda_ClientType == SDA_CLIENT_TWOWAY))
        {
            pRasSubAuthInfo =
                (PRAS_SUBAUTH_INFO)((PBYTE)InToken + BufferOffset);

            pRasSubAuthInfo->ProtocolType = RAS_SUBAUTH_PROTO_ARAP;
            pRasSubAuthInfo->DataSize = sizeof(ARAP_SUBAUTH_REQ);

            pSfmSubAuthInfo = (PARAP_SUBAUTH_REQ)&pRasSubAuthInfo->Data[0];

            if (pSda->sda_ClientType == SDA_CLIENT_RANDNUM)
            {
                pSfmSubAuthInfo->PacketType = SFM_SUBAUTH_LOGON_PKT;
            }
            else
            {
                pSfmSubAuthInfo->PacketType = SFM_2WAY_SUBAUTH_LOGON_PKT;
            }

            pSfmSubAuthInfo->Logon.fGuestLogon = FALSE;

            ASSERT(pSda->sda_Challenge != NULL);

            // put the 2 dwords of challenge that we gave the Mac
            pTmp = pSda->sda_Challenge;
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.NTChallenge1,pTmp);

            pTmp += sizeof(DWORD);
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.NTChallenge2,pTmp);

            // put the 2 dwords of response that the Mac gave us
            pTmp = UserPasswd->Buffer;
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacResponse1,pTmp);

            pTmp += sizeof(DWORD);
            GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacResponse2,pTmp);

            // 2-way guy sends his own challenge: doesn't trust us!
            if (pSda->sda_ClientType == SDA_CLIENT_TWOWAY)
            {
                pTmp += sizeof(DWORD);
                GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacChallenge1,pTmp);

                pTmp += sizeof(DWORD);
                GETDWORD2DWORD_NOCONV((PBYTE)&pSfmSubAuthInfo->Logon.MacChallenge2,pTmp);
            }

            dwTmpLen = (sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ));
            InToken->LmChallengeResponse.Length = (USHORT)dwTmpLen;
            InToken->LmChallengeResponse.MaximumLength = (USHORT)dwTmpLen;

            BufferOffset += dwTmpLen;
        }

        //
        // this client is using MS-UAM or Apple's cleartext
        //
        else
        {
            InToken->LmChallengeResponse.Length = UserPasswd->Length;
            InToken->LmChallengeResponse.MaximumLength = UserPasswd->MaximumLength;

            RtlCopyMemory( (PBYTE)InToken + BufferOffset,
                            UserPasswd->Buffer,
                            UserPasswd->Length );

            BufferOffset += UserPasswd->Length;
        }


        BufferOffset = (BufferOffset + 3) & 0xfffffffc;     // dword align it

        //
        // Workstation Name
        //

        InToken->Workstation.Buffer = BufferOffset;
        InToken->Workstation.Length = WSName->Length;
        InToken->Workstation.MaximumLength = WSName->MaximumLength;

        RtlCopyMemory((PBYTE)InToken + BufferOffset,
                      WSName->Buffer,
                      WSName->Length);

        BufferOffset += WSName->Length;
        BufferOffset = (BufferOffset + 3) & 0xfffffffc;     // dword align it

        //
        // User Name
        //

        InToken->UserName.Buffer = BufferOffset;
        InToken->UserName.Length = pSda->sda_UserName.Length;
        InToken->UserName.MaximumLength = pSda->sda_UserName.MaximumLength;

        RtlCopyMemory((PBYTE)InToken + BufferOffset,
                      pSda->sda_UserName.Buffer,
                      pSda->sda_UserName.Length);

        BufferOffset += pSda->sda_UserName.Length;
    }


    InputToken.pBuffers = InputBuffers;
    InputToken.cBuffers = 2;
    InputToken.ulVersion = 0;
    InputBuffers[0].pvBuffer = InToken;
    InputBuffers[0].cbBuffer = InTokenSize;
    InputBuffers[0].BufferType = SECBUFFER_TOKEN;
    InputBuffers[1].pvBuffer = NtlmInToken;
    InputBuffers[1].cbBuffer = NtlmInTokenSize;
    InputBuffers[1].BufferType = SECBUFFER_TOKEN;

    OutputToken.pBuffers = &OutputBuffer;
    OutputToken.cBuffers = 1;
    OutputToken.ulVersion = 0;
    OutputBuffer.pvBuffer = OutToken;
    OutputBuffer.cbBuffer = OutTokenSize;
    OutputBuffer.BufferType = SECBUFFER_TOKEN;

    Status = AcceptSecurityContext(&AfpSecHandle,
                                   NULL,
                                   &InputToken,
                                   ASC_REQ_LICENSING,
                                   SECURITY_NATIVE_DREP,
                                   &hNewContext,
                                   &OutputToken,
                                   &ulUnused,
                                   &Expiry );

    if (NT_SUCCESS(Status))
    {
        AFPTIME     CurrentTime;
        NTSTATUS    SecStatus;

        if (pSda->sda_ClientType != SDA_CLIENT_GUEST)
        {
            SecPkgContext_PasswordExpiry PasswordExpires;


            // Get the kickoff time from the profile buffer. Round this to
            // even # of SESSION_CHECK_TIME units

            SecStatus = QueryContextAttributes(
                                &hNewContext,
                                SECPKG_ATTR_PASSWORD_EXPIRY,
                                &PasswordExpires
                                );

            if( SecStatus == NO_ERROR )
            {
                AfpGetCurrentTimeInMacFormat(&CurrentTime);

                pSda->sda_tTillKickOff = (DWORD)
                        ( AfpConvertTimeToMacFormat(&PasswordExpires.tsPasswordExpires) -
                          CurrentTime );

                pSda->sda_tTillKickOff -= pSda->sda_tTillKickOff % SESSION_CHECK_TIME;
            }
            else
            {
                DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                    ("AfpLogonUser: QueryContextAttributes failed %lx\n",SecStatus));
            }
        }

        // return stuff from subauth
        pSfmResp = (PARAP_SUBAUTH_RESP)&OutToken->UserSessionKey[0];

        ResponseHigh = pSfmResp->Response.high;
        ResponseLow  = pSfmResp->Response.low;

        SubStatus = NtFreeVirtualMemory(NtCurrentProcess( ),
                                        (PVOID *)&InToken,
                                        &AllocateSize,
                                        MEM_RELEASE);
        ASSERT(NT_SUCCESS(SubStatus));

        //
        // 2-Way authentication? client expects us to send a response to
        // the challenge that it sent
        //
        if (pSda->sda_ClientType == SDA_CLIENT_TWOWAY)
        {
            pSda->sda_ReplySize = RANDNUM_RESP_LEN;

            if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
            {
                return(AFP_ERR_USER_NOT_AUTH);
            }

            pTmp = pSda->sda_ReplyBuf;
            PUTBYTE42BYTE4(pTmp, (PBYTE)&ResponseHigh);

            pTmp += sizeof(DWORD);
            PUTBYTE42BYTE4(pTmp, (PBYTE)&ResponseLow);
        }

        else if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
                 (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
        {
            pSda->sda_ReplySize = sizeof(DWORD);

            if (AfpAllocReplyBuf(pSda) != AFP_ERR_NONE)
            {
                return(AFP_ERR_USER_NOT_AUTH);
            }

            pTmp = pSda->sda_ReplyBuf;
            PUTBYTE42BYTE4(pTmp, (PBYTE)&pSda->sda_tTillKickOff);
        }

    }

    else  // if (NT_SUCCESS(Status) != NO_ERROR)
    {
        NTSTATUS    ExtErrCode = Status;

        DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                 ("AfpLogonUser: AcceptSecurityContext() failed with %X\n", Status));

        SubStatus = NtFreeVirtualMemory(NtCurrentProcess(),
                                        (PVOID *)&InToken,
                                        &AllocateSize,
                                        MEM_RELEASE );
        ASSERT(NT_SUCCESS(SubStatus));

        // Set extended error codes here if using custom UAM or AFP 2.1
        Status = AFP_ERR_USER_NOT_AUTH; // default

        // The mac will map this to a session error dialog for each UAM.
        // The dialog may be a little different for different versions of
        // the mac OS and each UAM, but will always have something to do
        // with getting the message across about no more sessions available.

        if (ExtErrCode == STATUS_LICENSE_QUOTA_EXCEEDED)
        {
            DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                 ("AfpLogonUser: License Quota Exceeded: returning ASP_SERVER_BUSY\n"));
            return (ASP_SERVER_BUSY);
        }

        if ((pSda->sda_ClientVersion >= AFP_VER_21) &&
            (pSda->sda_ClientType != SDA_CLIENT_MSUAM_V2) &&
            (pSda->sda_ClientType != SDA_CLIENT_MSUAM_V3))
        {
            if ((ExtErrCode == STATUS_PASSWORD_EXPIRED) ||
                (ExtErrCode == STATUS_PASSWORD_MUST_CHANGE))
                Status = AFP_ERR_PWD_EXPIRED;
        }
        else if ((pSda->sda_ClientType == SDA_CLIENT_MSUAM_V1) ||
                 (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V2) ||
                 (pSda->sda_ClientType == SDA_CLIENT_MSUAM_V3))
        {
            if ((ExtErrCode == STATUS_PASSWORD_EXPIRED) ||
                (ExtErrCode == STATUS_PASSWORD_MUST_CHANGE))
                Status = AFP_ERR_PASSWORD_EXPIRED;
            else if ((ExtErrCode == STATUS_ACCOUNT_DISABLED) ||
                     (ExtErrCode == STATUS_ACCOUNT_LOCKED_OUT))
                Status = AFP_ERR_ACCOUNT_DISABLED;
            else if (ExtErrCode == STATUS_INVALID_LOGON_HOURS)
                Status = AFP_ERR_INVALID_LOGON_HOURS;
            else if (ExtErrCode == STATUS_INVALID_WORKSTATION)
                Status = AFP_ERR_INVALID_WORKSTATION;
        }

        return( Status );
    }

    //
    // get the token out using the context
    //
    Status = QuerySecurityContextToken( &hNewContext, &pSda->sda_UserToken );
    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                 ("AfpLogonUser: QuerySecurityContextToken() failed with %X\n", Status));
        pSda->sda_UserToken = NULL;          // just paranoia
        return(Status);
    }

    Status = DeleteSecurityContext( &hNewContext );
    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                ("AfpLogonUser: DeleteSecurityContext() failed with %X\n", Status));
    }

    Status = AfpGetUserAndPrimaryGroupSids(pSda);
    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_SECURITY, DBG_LEVEL_ERR,
                ("AfpLogonUser: AfpGetUserAndPrimaryGroupSids() failed with %X\n", Status));
        AFPLOG_ERROR(AFPSRVMSG_LOGON, Status, NULL, 0, NULL);
        return( Status );
    }

#ifdef  INHERIT_DIRECTORY_PERMS
    // Convert the user and group sids to IDs
    AfpSidToMacId(pSda->sda_UserSid, &pSda->sda_UID);

    AfpSidToMacId(pSda->sda_GroupSid, &pSda->sda_GID);
#else
    // Make a security descriptor for user
    Status = AfpMakeSecurityDescriptorForUser(pSda->sda_UserSid,
                                              pSda->sda_GroupSid,
                                              &pSda->sda_pSecDesc);
#endif

#ifdef  OPTIMIZE_GUEST_LOGONS
    if (pSda->sda_ClientType == SDA_CLIENT_GUEST)
    {
        // Save the guest login token and security descriptor
        AfpSwmrAcquireExclusive(&AfpEtcMapLock);
        AfpGuestToken = pSda->sda_UserToken;

#ifdef  INHERIT_DIRECTORY_PERMS
        AfpSidToMacId(&AfpSidWorld, &AfpIdWorld);
#else
        AfpGuestSecDesc = pSda->sda_pSecDesc;
#endif
        AfpSwmrRelease(&AfpEtcMapLock);
    }
#endif  // OPTIMIZE_GUEST_LOGONS

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\dsi.c ===
/*

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dsi.c

Abstract:

	This module contains the routines that implement the Data Stream Interface
    (DSI) for AFP/TCP.


Author:

	Shirish Koti


Revision History:
	22 Jan 1998		Initial Version

--*/

#define	FILENUM	FILE_TCPDSI

#include <afp.h>



/***	DsiAfpSetStatus
 *
 *	This routine is a direct call-in from AFP.
 *  It frees up the earlier status buffer, if any, and stores the new status as
 *  given by AFP into a new buffer
 *
 *  Parm IN:  Context - unused (Appletalk interface compatibility)
 *            pStatusBuf - the buffer containing new status
 *            StsBufSize - size of this buffer
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpSetStatus(
    IN  PVOID   Context,
    IN  PUCHAR  pStatusBuf,
    IN  USHORT  StsBufSize
)
{
    PBYTE       pBuffer;
    PBYTE       pOldBuffer;
    KIRQL       OldIrql;


    pBuffer = AfpAllocNonPagedMemory(StsBufSize);
    if (pBuffer == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpSetStatus: malloc failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(pBuffer, pStatusBuf, StsBufSize);

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    pOldBuffer = DsiStatusBuffer;
    DsiStatusBuffer = pBuffer;
    DsiStatusBufferSize = StsBufSize;

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    if (pOldBuffer)
    {
        AfpFreeMemory(pOldBuffer);
    }

    return(STATUS_SUCCESS);
}



/***	DsiAfpCloseConn
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to close the session down
 *
 *  Parm IN:  pTcpConn - the connection context to close
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpCloseConn(
    IN  PTCPCONN    pTcpConn
)
{
    KIRQL       OldIrql;
    NTSTATUS    status=STATUS_SUCCESS;
    BOOLEAN     fAlreadyDown=TRUE;


    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
    if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_AFP)
    {
        fAlreadyDown = FALSE;
        pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_AFP;
        pTcpConn->con_State |= TCPCONN_STATE_TICKLES_STOPPED;
    }
    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (!fAlreadyDown)
    {
        status = DsiSendDsiRequest(pTcpConn, 0, 0, NULL,DSI_COMMAND_CLOSESESSION);
    }

    return(status);
}


/***	DsiAfpFreeConn
 *
 *	This routine is a direct call-in from AFP.
 *  With this call, AFP tells DSI that its connection is being freed.  We can
 *  now remove the refcount on pTcpConn that we had put to protect AFP's context
 *
 *  Parm IN:  pTcpConn - the connection context to close
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpFreeConn(
    IN  PTCPCONN    pTcpConn
)
{
    ASSERT(VALID_TCPCONN(pTcpConn));

    // remove AFP refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiAfpFreeConn: AFP dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_SUCCESS);
}


/***	DsiAfpListenControl
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to either enable or disable "listens".  We don't do
 *  anything fancy here: simply toggle a global variable.
 *
 *  Parm IN:  Context - unused (Appletalk interface compatibility)
 *            Enable - enable or disable?
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiAfpListenControl(
    IN  PVOID       Context,
    IN  BOOLEAN     Enable
)
{
    KIRQL       OldIrql;

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    DsiTcpEnabled = Enable;
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // update the status buffer, since listen is now enabled or disabled
    DsiScheduleWorkerEvent(DsiUpdateAfpStatus, NULL);

    return(STATUS_SUCCESS);
}


/***	DsiAfpWriteContinue
 *
 *	This routine is a direct call-in from AFP.
 *  AFP calls this routine to tell that a previous request to allocate
 *  Mdl (and buffer) has completed and that whatever action was postponed can
 *  now continue
 *
 *  Parm IN:  pRequest - pointer to the request structure
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiAfpWriteContinue(
    IN  PREQUEST    pRequest
)
{
    KIRQL               OldIrql;
    NTSTATUS            status=STATUS_SUCCESS;
    PDSIREQ             pDsiReq;
    PTCPCONN            pTcpConn;
    PDEVICE_OBJECT      pDeviceObject;
    PIRP                pIrp;
    BOOLEAN             fAbortConnection=FALSE;


    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_INFO,
        ("DsiAfpWriteContinue: entered with pRequest = %lx\n",pRequest));

    pDsiReq = CONTAINING_RECORD(pRequest, DSIREQ, dsi_AfpRequest);

    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));


    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    ASSERT(pTcpConn->con_RcvState == DSI_AWAITING_WRITE_MDL);
    ASSERT(pDsiReq == pTcpConn->con_pDsiReq);
    ASSERT(!(pTcpConn->con_State & TCPCONN_STATE_TCP_HAS_IRP));

    pTcpConn->con_RcvState = DSI_PARTIAL_WRITE;

    //
    // if connection is closing or if Mdl alloc failed, not much we can do but
    // to abort the connection!
    //
    if ((pTcpConn->con_State & TCPCONN_STATE_CLOSING) ||
        (pRequest->rq_WriteMdl == NULL))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpWriteContinue: aborting conn! %lx\n",pRequest));
        fAbortConnection = TRUE;
    }

    else
    {
        ASSERT(AfpMdlChainSize(pRequest->rq_WriteMdl) == pDsiReq->dsi_WriteLen);

        pIrp = DsiGetIrpForTcp(pTcpConn, NULL, pRequest->rq_WriteMdl, pDsiReq->dsi_WriteLen);

        if (pIrp == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiAfpWriteContinue: irp alloc failed, aborting connection\n"));
            fAbortConnection = TRUE;
        }
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (fAbortConnection)
    {
        DsiAbortConnection(pTcpConn);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    // since we are calling IoCallDriver, undo what was done to this irp!
    IoSkipCurrentIrpStackLocation(pIrp)

    //
    // hand over the irp to tell TCP to fill our buffer
    //
    IoCallDriver(pDeviceObject,pIrp);

    return(status);
}


/***	DsiAfpReply
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to send a reply to the client.  When TCP completes
 *  our send (that contains AFP's reply), then we complete this reply for AFP
 *  (i.e. call AFP's completion routine)
 *
 *  Parm IN:  pRequest - pointer to the request structure
 *            pResultCode - error code (ErrorCode field of DSI header)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS FASTCALL
DsiAfpReply(
    IN  PREQUEST    pRequest,
    IN  PBYTE       pResultCode
)
{
    NTSTATUS    status;
    PDSIREQ     pDsiReq;
    KIRQL       OldIrql;
    PBYTE       pPacket;
    PTCPCONN    pTcpConn;
    PMDL        pMdl;
    DWORD       DataLen;
    DWORD       SendLen;
    BOOLEAN     fWeAllocated=FALSE;


    pDsiReq = CONTAINING_RECORD(pRequest, DSIREQ, dsi_AfpRequest);

    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
    if (pTcpConn->con_State & TCPCONN_STATE_CLOSING)
    {
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
        return(STATUS_SUCCESS);
    }
    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    //
    // we need to append our own Mdl (for DSI header) if the outgoing data
    // is part of cache mgr's Mdl
    //
    if (pRequest->rq_CacheMgrContext)
    {
        pPacket = &pDsiReq->dsi_RespHeader[0];

        if (pDsiReq->dsi_AfpRequest.rq_ReplyMdl)
        {
            DataLen = AfpMdlChainSize(pDsiReq->dsi_AfpRequest.rq_ReplyMdl);
        }
        else
        {
            DataLen = 0;
        }

        SendLen = DataLen + DSI_HEADER_SIZE;

        pMdl = AfpAllocMdl(pPacket, DSI_HEADER_SIZE, NULL);
        if (pMdl == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiAfpReply: mdl alloc failed!\n"));

            DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
            DsiAbortConnection(pTcpConn);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // link in Afp's mdl
        pMdl->Next = pDsiReq->dsi_AfpRequest.rq_ReplyMdl;

        pDsiReq->dsi_pDsiAllocedMdl = pMdl;
        fWeAllocated = TRUE;
    }
    else
    {
        pMdl = pDsiReq->dsi_AfpRequest.rq_ReplyMdl;

        if (pMdl)
        {
            //
            // get the total length of the send, which include the DSI header size
            //
            SendLen = AfpMdlChainSize(pMdl);

            ASSERT(SendLen >= DSI_HEADER_SIZE);
            DataLen = SendLen - DSI_HEADER_SIZE;

            pPacket = MmGetSystemAddressForMdlSafe(
					        pMdl,
					        NormalPagePriority);
			if (pPacket == NULL)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto error_end;
			}

#if DBG
            // make sure we allocated room for the DSI header!
            ASSERT(*(DWORD *)pPacket == 0x081294);
#endif

        }
        else
        {
            pPacket = &pDsiReq->dsi_RespHeader[0];
            SendLen = DSI_HEADER_SIZE;
            DataLen = 0;

            pMdl = AfpAllocMdl(pPacket, SendLen, NULL);
            if (pMdl == NULL)
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiAfpReply: mdl alloc failed!\n"));

                DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
                DsiAbortConnection(pTcpConn);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            pDsiReq->dsi_pDsiAllocedMdl = pMdl;
            fWeAllocated = TRUE;
        }
    }

    //
    // form the DSI header
    //

    pPacket[DSI_OFFSET_FLAGS] = DSI_REPLY;
    pPacket[DSI_OFFSET_COMMAND] = pDsiReq->dsi_Command;

    PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);

    *(DWORD *)&pPacket[DSI_OFFSET_DATAOFFSET] = *(DWORD *)pResultCode;

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], DataLen);

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_RESERVED], 0);

    status = DsiTdiSend(pTcpConn,
                        pMdl,
                        SendLen,
                        DsiAfpReplyCompletion,
                        pDsiReq);

error_end:

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpReply: DsiTdiSend failed %lx\n",status));

        if (fWeAllocated)
        {
            pMdl->Next = NULL;
            AfpFreeMdl(pMdl);
        }
        DsiAfpReplyCompletion(NULL, NULL, pDsiReq);
        status = STATUS_PENDING;
    }

    return(status);
}



/***	DsiAfpSendAttention
 *
 *	This routine is a direct call-in from AFP.
 *  It honors AFP's request to send attention to the client.
 *
 *  Parm IN:  pTcpConn - the connection context to close
 *            AttentionWord - attention word to send
 *            pContext - context, to be supplied at completion time
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpSendAttention(
    IN  PTCPCONN    pTcpConn,
    IN  USHORT      AttentionWord,
    IN  PVOID       pContext
)
{

    NTSTATUS        status;


    ASSERT(VALID_TCPCONN(pTcpConn));

    status = DsiSendDsiRequest(pTcpConn,
                               sizeof(USHORT),
                               AttentionWord,
                               pContext,
                               DSI_COMMAND_ATTENTION);
    return(status);
}


/***	DsiAcceptConnection
 *
 *	This routine accepts (or rejects) an incoming tcp connection request.
 *  Basically, after making a few checks, a (pre-allocated) connection object
 *  is dequeued and returned as our context to TCP.
 *
 *  Parm IN:  pTcpAdptr - adapter
 *            MacIpAddr - ipaddr of the Mac that's connecting
 *
 *  Parm OUT: ppRetTcpCon - connection object we are returning as context
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAcceptConnection(
    IN  PTCPADPTR       pTcpAdptr,
    IN  IPADDRESS       MacIpAddr,
    OUT PTCPCONN       *ppRetTcpConn
)
{

    NTSTATUS        status=STATUS_SUCCESS;
    KIRQL           OldIrql;
    PTCPCONN        pTcpConn;
    PLIST_ENTRY     pList;
    DWORD           dwReplCount=0;
    DWORD           i;
    BOOLEAN         fReplenish=FALSE;


    *ppRetTcpConn = NULL;

    // if the server is disabled, don't accept this connection
    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    if (!DsiTcpEnabled)
    {
        RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: Server is disabled\n"));

        return(STATUS_DATA_NOT_ACCEPTED);
    }
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);


    ACQUIRE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, &OldIrql);

    //
    // if the adapter is closing, don't accept this connection
    //
    if (pTcpAdptr->adp_State & TCPADPTR_STATE_CLOSING)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: %lx is closing, rejecting connection\n",pTcpAdptr));

        goto DsiAcceptConnection_ErrExit;
    }

    //
    // do we have a connection object available in the free list?
    //
    if (IsListEmpty(&pTcpAdptr->adp_FreeConnHead))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: FreeConnHead empty, rejecting connection\n"));

        goto DsiAcceptConnection_ErrExit;
    }

    pList = RemoveHeadList(&pTcpAdptr->adp_FreeConnHead);

    ASSERT(pTcpAdptr->adp_NumFreeConnections > 0);

    pTcpAdptr->adp_NumFreeConnections--;

    pTcpConn = CONTAINING_RECORD(pList, TCPCONN, con_Linkage);

    ACQUIRE_SPIN_LOCK_AT_DPC(&pTcpConn->con_SpinLock);

    // put TCP CLIENT-FIN refcount, removed after TCP tells us it got client's FIN
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiAcceptConnection: CLIENT-FIN inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    // put TCP SRVR-FIN refcount, removed after TCP tells us it sent out FIN
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiAcceptConnection: SRVR-FIN inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    // put ACCEPT refcount, removed after TCP calls our accept completion
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiAcceptConnection: ACCEPT inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    pTcpConn->con_State |= (TCPCONN_STATE_CONNECTED | TCPCONN_STATE_NOTIFY_TCP);

    pTcpConn->con_DestIpAddr = MacIpAddr;

    //
    // put this connection on the active list (though this isn't fully active yet)
    //
    InsertTailList(&pTcpAdptr->adp_ActiveConnHead, &pTcpConn->con_Linkage);

    RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);

    if (pTcpAdptr->adp_NumFreeConnections < DSI_INIT_FREECONNLIST_SIZE)
    {
        //
        // we are going to create a new connection in the free list to replenish
        // the one we just used up: make sure adapter stays around when that
        // delayed event fires!
        //
        pTcpAdptr->adp_RefCount++;
        fReplenish = TRUE;
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: at or above limit (%d): NOT replenishing\n",
            pTcpAdptr->adp_NumFreeConnections));
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    if (fReplenish)
    {
        //
        // now schedule that event to replenish the connection...
        //
        DsiScheduleWorkerEvent(DsiCreateTcpConn, pTcpAdptr);
    }


    *ppRetTcpConn = pTcpConn;

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);
    DsiNumTcpConnections++;
    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    return(STATUS_SUCCESS);


    //
    // Error case
    //
DsiAcceptConnection_ErrExit:

    if (pTcpAdptr->adp_NumFreeConnections < DSI_INIT_FREECONNLIST_SIZE)
    {
        dwReplCount = (DSI_INIT_FREECONNLIST_SIZE - pTcpAdptr->adp_NumFreeConnections);

        pTcpAdptr->adp_RefCount += dwReplCount;
        fReplenish = TRUE;

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnection: below limit (%d): replenishing %d times\n",
            pTcpAdptr->adp_NumFreeConnections,dwReplCount));
    }

    RELEASE_SPIN_LOCK(&pTcpAdptr->adp_SpinLock, OldIrql);

    if (fReplenish)
    {
        for (i=0; i<dwReplCount; i++)
        {
            DsiScheduleWorkerEvent(DsiCreateTcpConn, pTcpAdptr);
        }
    }

    return(STATUS_DATA_NOT_ACCEPTED);

}


/***	DsiProcessData
 *
 *	This routine is the main data processing state machine.  Since TCP is a
 *  streaming protocol, there is no guarantee that whatever the client sent
 *  can come in in one piece.  That's why the states.  Here's what they mean:
 *
 *  DSI_NEW_REQUEST      : init state, waiting for a new request from client
 *  DSI_PARTIAL_HEADER   : we have received only some of the 16 bytes of hdr
 *  DSI_HDR_COMPLETE     : we have the complete header (received all 16 bytes)
 *  DSI_PARTIAL_COMMAND  : we have recvd only some of the request bytes
 *  DSI_COMMAND_COMPLETE : we have recvd all of the request bytes
 *  DSI_PARTIAL_WRITE    : we have recvd some of the Write bytes
 *  DSI_WRITE_COMPLETE   : we have recvd all of the Write bytes
 *
 *  Parm IN:  pTcpConn - the connection object in question
 *            BytesIndicated - bytes indicated
 *            BytesAvailable - bytes available (usually same as indicated)
 *            pBufferFromTcp - pointer to the DSI data
 *
 *  Parm OUT: pBytesAccepted - pointer to how many bytes we consumed
 *            ppIrp - pointer to an irp pointer, if necessary
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiProcessData(
    IN  PTCPCONN    pTcpConn,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    IN  PBYTE       pBufferFromTcp,
    OUT PULONG      pBytesAccepted,
    OUT PIRP       *ppRetIrp
)
{

    KIRQL           OldIrql;
    NTSTATUS        status=STATUS_SUCCESS;
    DWORD           BytesConsumed=0;
    DWORD           UnProcessedBytes;
    DWORD           BytesNeeded;
    DWORD           BytesActuallyCopied;
    PBYTE           pStreamPtr;
    PBYTE           pDestBuffer;
    PBYTE           pHdrBuf=NULL;
    DWORD           RequestLen;
    PDSIREQ         pDsiReq=NULL;
    PMDL            pMdl;
    PIRP            pIrp;
    BOOLEAN         fSomeMoreProcessing=TRUE;
    BOOLEAN         fTCPHasMore=FALSE;



    *ppRetIrp = NULL;

    UnProcessedBytes = BytesIndicated;

    pStreamPtr = pBufferFromTcp;


    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    // if we are closing, throw away these bytes
    if (pTcpConn->con_State & TCPCONN_STATE_CLOSING)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiProcessData: dropping data, conn %lx closing\n",pTcpConn));

        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        *pBytesAccepted = BytesIndicated;
        return(STATUS_SUCCESS);
    }

    //
    // this can happen if we are just submitting an irp down, and before the irp
    // gets down to TCP, an indicate comes in.  Reject this data since our irp is
    // on its way.
    //
    if (pTcpConn->con_State & TCPCONN_STATE_TCP_HAS_IRP)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiProcessData: TCP has irp, so rejecting indication\n"));

        *pBytesAccepted = 0;
        pTcpConn->con_BytesWithTcp += BytesAvailable;

        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // if we already know TCP has unconsumed bytes, or if TCP is indicating less
    // than what's available, mark the fact that TCP has more stuff with it
    //
    if (BytesAvailable > BytesIndicated)
    {
        fTCPHasMore = TRUE;
    }


    while (fSomeMoreProcessing)
    {
        fSomeMoreProcessing = FALSE;

        switch (pTcpConn->con_RcvState)
        {
            //
            // most common case.  We are ready to deal with a new request.
            //
            case DSI_NEW_REQUEST:

                ASSERT(!(pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA));

                pDsiReq = DsiGetRequest();

                if (pDsiReq == NULL)
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiProcessData: DsiGetRequest failed, killing %lx\n",pTcpConn));

                    goto DsiProcessData_ErrorExit;
                }

                pDsiReq->dsi_pTcpConn = pTcpConn;

                pTcpConn->con_pDsiReq = pDsiReq;

                // put a REQUEST refcount - remove when the request is done
                pTcpConn->con_RefCount++;

                DBGREFCOUNT(("DsiProcessData: REQUEST inc %lx (%d  %d,%d)\n",
                    pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

                //
                // do we have the complete header?
                //
                if (UnProcessedBytes >= DSI_HEADER_SIZE)
                {
                    //
                    // get info out of the header
                    //
                    DSI_PARSE_HEADER(pDsiReq, pStreamPtr);

                    //
                    // hack!  Mac client 3.7 has a bug where if a 0-byte Write is
                    // sent to us, the DataOffset field is 0, but Total Data Length
                    // field is 0xC (or whatever the request length is)
                    // Put in a workaround!
                    //
                    if ((pDsiReq->dsi_Command == DSI_COMMAND_WRITE) &&
                        (pDsiReq->dsi_RequestLen == 0))
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiProcessData: 0-byte Write hack to workaround Mac's bug\n"));

                        pDsiReq->dsi_RequestLen = pDsiReq->dsi_WriteLen;
                        pDsiReq->dsi_WriteLen = 0;
                    }

                    // update all the counters and buffers
                    BytesConsumed += DSI_HEADER_SIZE;
                    pStreamPtr += DSI_HEADER_SIZE;
                    UnProcessedBytes -= DSI_HEADER_SIZE;

                    ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                    pTcpConn->con_RcvState = DSI_HDR_COMPLETE;

                    // make sure we visit case DSI_HDR_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }

                //
                // yikes, only part of the header has come in
                // just set the state and let the parsing loop continue..
                //
                else
                {
                    pTcpConn->con_State |= TCPCONN_STATE_PARTIAL_DATA;
                    pTcpConn->con_RcvState = DSI_PARTIAL_HEADER;
                    pTcpConn->con_pDsiReq->dsi_RequestLen = DSI_HEADER_SIZE;
                }

                break;  // case DSI_NEW_REQUEST:


            //
            // PartialHeader case is extremely unlikely to occur, given how small
            // the header is (16 bytes).  But given that we have a streaming
            // protocol (TCP) below us, anything is possible.
            // PartialCommand is also unlikely for the same reason.  However, in
            // case of a Write command, we always force PartialCommand state
            // since it's very unlikely the whole Write can come in in one packet.
            //
            case DSI_PARTIAL_HEADER:
            case DSI_PARTIAL_COMMAND:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                ASSERT(pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA);

                //
                // if we haven't started copying any bytes in yet then we need
                // to get storage room (use built-in buffer if possible)
                //
                if (pDsiReq->dsi_PartialBufSize == 0)
                {
                    ASSERT(pDsiReq->dsi_PartialBuf == NULL);

                    if (pDsiReq->dsi_RequestLen <= DSI_BUFF_SIZE)
                    {
                        pDsiReq->dsi_PartialBuf = &pDsiReq->dsi_RespHeader[0];
                    }
                    //
                    // allocate a buffer to hold this partial header.
                    //
                    else
                    {
                        pDsiReq->dsi_PartialBuf =
                                    DsiGetReqBuffer(pDsiReq->dsi_RequestLen);

                        if (pDsiReq->dsi_PartialBuf == NULL)
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiProcessData: Buffer alloc failed, killing %lx\n",pTcpConn));

                            goto DsiProcessData_ErrorExit;
                        }
                    }
                }

                //
                // how many more bytes do we need to complete this hdr/command
                //
                BytesNeeded = (pDsiReq->dsi_RequestLen - pDsiReq->dsi_PartialBufSize);

                //
                // if we don't have enough bytes to satisfy this Command (or Hdr),
                // don't copy anything but give an irp back to TCP
                //
                if (UnProcessedBytes < BytesNeeded)
                {
                    pIrp = DsiGetIrpForTcp(
                                pTcpConn,
                                (pDsiReq->dsi_PartialBuf + pDsiReq->dsi_PartialBufSize),
                                NULL,
                                BytesNeeded);

                    if (pIrp == NULL)
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiProcessData: couldn't alloc RcvIrp, killing %lx\n",pTcpConn));

                        goto DsiProcessData_ErrorExit;
                    }

                    pDsiReq->dsi_pDsiAllocedMdl = pIrp->MdlAddress;

                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                        ("DsiProcessData: A irp %lx to TCP for %d bytes (%lx)\n",
                        pIrp,BytesNeeded,pTcpConn));


                    *ppRetIrp = pIrp;

                    *pBytesAccepted = BytesConsumed;

                    // did TCP call us?  then update byte count
                    if (BytesIndicated)
                    {
                        pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
                    }

                    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
                    return(STATUS_MORE_PROCESSING_REQUIRED);
                }


                //
                // if the bytes we need are available, copy them in.  Then decide
                // what to do next (same if we already have the bytes)
                //
                else if ((UnProcessedBytes > 0) || (BytesNeeded == 0))
                {
                    if (BytesNeeded > 0)
                    {
                        ASSERT(pDsiReq->dsi_PartialBufSize == 0);

                        RtlCopyMemory(
                            (pDsiReq->dsi_PartialBuf + pDsiReq->dsi_PartialBufSize),
                            pStreamPtr,
                            BytesNeeded);


                        //
                        // update all the counters and buffers
                        //
                        pDsiReq->dsi_PartialBufSize += BytesNeeded;

                        BytesConsumed += BytesNeeded;
                        pStreamPtr += BytesNeeded;
                        UnProcessedBytes -= BytesNeeded;
                        ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                    }

                    // we should have all the bytes we need now
                    ASSERT(pDsiReq->dsi_PartialBufSize == pDsiReq->dsi_RequestLen);

                    //
                    // find out what the next rcv state should be
                    //
                    if (pTcpConn->con_RcvState == DSI_PARTIAL_HEADER)
                    {
                        //
                        // get info out of the header
                        //
                        DSI_PARSE_HEADER(pDsiReq, pDsiReq->dsi_PartialBuf);

                        //
                        // hack!  Mac client 3.7 has a bug where if a 0-byte Write is
                        // sent to us, the DataOffset field is 0, but Total Data Length
                        // field is 0xC (or whatever the request length is)
                        // Put in a workaround!
                        //
                        if ((pDsiReq->dsi_Command == DSI_COMMAND_WRITE) &&
                            (pDsiReq->dsi_RequestLen == 0))
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiProcessData: 0-byte Write hack to workaround Mac's bug\n"));

                            pDsiReq->dsi_RequestLen = pDsiReq->dsi_WriteLen;
                            pDsiReq->dsi_WriteLen = 0;
                        }

                        pTcpConn->con_RcvState = DSI_HDR_COMPLETE;
                    }

                    //
                    // no, we were in DSI_PARTIAL_COMMAND, so we will now move
                    // to DSI_PARTIAL_WRITE if this is a Write command, otherwise
                    // to DSI_COMMAND_COMPLETE
                    //
                    else
                    {
                        if (pDsiReq->dsi_Command == DSI_COMMAND_WRITE)
                        {
                            pDsiReq->dsi_AfpRequest.rq_RequestBuf =
                                                        pDsiReq->dsi_PartialBuf;

                            pDsiReq->dsi_AfpRequest.rq_RequestSize =
                                                    pDsiReq->dsi_PartialBufSize;

                            //
                            // for now, assume that AfpCB_GetWriteBuffer will
                            // return pending and set the state in anticipation
                            //
                            pTcpConn->con_RcvState = DSI_AWAITING_WRITE_MDL;

                            pDsiReq->dsi_PartialWriteSize = 0;

                            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                            //
                            // allocate the write mdl before we move to
                            // DSI_PARTIAL_WRITE state
                            //
                            status = AfpCB_GetWriteBuffer(pTcpConn->con_pSda,
                                                          &pDsiReq->dsi_AfpRequest);

                            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

                            //
                            // most common case: file server will pend it so it can
                            // go to cache mgr
                            //
                            if (status == STATUS_PENDING)
                            {
                                // if TCP has any unconsumed bytes, update our count

                                if (BytesIndicated > 0)
                                {
                                    pTcpConn->con_BytesWithTcp +=
                                        (BytesAvailable - BytesConsumed);
                                }

                                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                                *pBytesAccepted = BytesConsumed;

                                status = (BytesConsumed)?
                                         STATUS_SUCCESS : STATUS_DATA_NOT_ACCEPTED;

                                return(status);
                            }
                            else if (status != STATUS_SUCCESS)
                            {
                                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                    ("DsiProcessData: GetWriteBuffer failed\n"));

                                pTcpConn->con_RcvState = DSI_PARTIAL_WRITE;
                                goto DsiProcessData_ErrorExit;
                            }

                            //
                            // AfpCB_GetWriteBuffer succeeded synchronously: set
                            // the state to partial-write
                            //
                            pTcpConn->con_RcvState = DSI_PARTIAL_WRITE;

                            ASSERT((pDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL) ||
                                   (pDsiReq->dsi_WriteLen == 0));

                            if (pDsiReq->dsi_WriteLen == 0)
                            {
                                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                    ("DsiProcessData: 0-len write on %lx\n",pDsiReq));
                            }
                        }

                        //
                        // it's not a Write, but a Command
                        //
                        else
                        {
                            ASSERT(pDsiReq->dsi_Command == DSI_COMMAND_COMMAND);

                            pTcpConn->con_RcvState = DSI_COMMAND_COMPLETE;
                        }
                    }

                    // make sure we visit case DSI_HDR_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }

                break;  // case DSI_PARTIAL_HEADER: case DSI_PARTIAL_COMMAND:


            //
            // we have the full header:  see what we must do next
            //
            case DSI_HDR_COMPLETE:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                if (pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA)
                {
                    ASSERT(pDsiReq->dsi_PartialBuf != NULL);
                    ASSERT(pDsiReq->dsi_PartialBufSize > 0);

                    if (pDsiReq->dsi_PartialBuf != &pDsiReq->dsi_RespHeader[0])
                    {
                        DsiFreeReqBuffer(pDsiReq->dsi_PartialBuf);
                    }
                    pDsiReq->dsi_PartialBuf = NULL;
                    pDsiReq->dsi_PartialBufSize = 0;
                }

                pTcpConn->con_State &= ~TCPCONN_STATE_PARTIAL_DATA;

                if (!DsiValidateHeader(pTcpConn, pDsiReq))
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiProcessData: packet invalid, killing %lx\n",pTcpConn));

                    goto DsiProcessData_ErrorExit;
                }
                //
                // if this is a Write command, we need to get mdl from AFP
                //
                if (pDsiReq->dsi_Command == DSI_COMMAND_WRITE)
                {
                    // we need to copy the request bytes
                    pTcpConn->con_RcvState = DSI_PARTIAL_COMMAND;
                    pTcpConn->con_State |= TCPCONN_STATE_PARTIAL_DATA;
                }

                //
                // do we have all the bytes needed to complete the request?
                //
                else if (UnProcessedBytes >= pDsiReq->dsi_RequestLen)
                {
                    pTcpConn->con_RcvState = DSI_COMMAND_COMPLETE;

                    // make sure we visit case DSI_HDR_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }
                else
                {
                    pTcpConn->con_RcvState = DSI_PARTIAL_COMMAND;
                    pTcpConn->con_State |= TCPCONN_STATE_PARTIAL_DATA;
                }

                break;


            //
            // we are waiting for Afp to give us an mdl (and buffer), but TCP tells
            // us data has arrived: just note the fact, and go back
            //
            case DSI_AWAITING_WRITE_MDL:

                // did TCP call us?  then update byte count
                if (BytesIndicated)
                {
                    pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
                }

                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                *pBytesAccepted = BytesConsumed;

                status = (BytesConsumed)? STATUS_SUCCESS : STATUS_DATA_NOT_ACCEPTED;

                return(status);

            //
            // we are in the middle of a Write command: copy the remaining bytes
            // needed to complete the Write, or whatever bytes that have come in
            // as the case may be
            //
            case DSI_PARTIAL_WRITE:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                BytesNeeded = (pDsiReq->dsi_WriteLen - pDsiReq->dsi_PartialWriteSize);

                //
                // if we don't have enough bytes to satisfy this Write, give irp to
                // TCP: TCP will come back when the irp completes
                //
                if (UnProcessedBytes < BytesNeeded)
                {
                    ASSERT(pDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL);

                    pIrp = DsiGetIrpForTcp(
                                pTcpConn,
                                NULL,
                                pDsiReq->dsi_AfpRequest.rq_WriteMdl,
                                BytesNeeded);

                    if (pIrp == NULL)
                    {
                        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                            ("DsiProcessData: B couldn't alloc RcvIrp, killing %lx\n",pTcpConn));

                        goto DsiProcessData_ErrorExit;
                    }

                    ASSERT(pDsiReq->dsi_pDsiAllocedMdl == NULL);
                    ASSERT(pIrp->MdlAddress == pDsiReq->dsi_AfpRequest.rq_WriteMdl);

                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                        ("DsiProcessData: B irp for %d bytes,Rem=%d (%lx)\n",
                        BytesNeeded,pTcpConn->con_BytesWithTcp,pTcpConn));

                    *ppRetIrp = pIrp;
                    *pBytesAccepted = BytesConsumed;

                    // did TCP call us?  then update byte count
                    if (BytesIndicated)
                    {
                        pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
                    }

                    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
                    return(STATUS_MORE_PROCESSING_REQUIRED);
                }


                //
                // if the bytes we need are available, copy them in.  Then decide
                // what to do next (same if we already have the bytes)
                //
                else if ((UnProcessedBytes > 0) || (BytesNeeded == 0))
                {
                    ASSERT(BytesNeeded <= UnProcessedBytes);

                    if (BytesNeeded > 0)
                    {
                        ASSERT(pDsiReq->dsi_PartialWriteSize == 0);

                        TdiCopyBufferToMdl(pStreamPtr,
                                           0,
                                           BytesNeeded,
                                           pDsiReq->dsi_AfpRequest.rq_WriteMdl,
                                           pDsiReq->dsi_PartialWriteSize,
                                          &BytesActuallyCopied);

                        if (BytesActuallyCopied != BytesNeeded)
                        {
                            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                                ("DsiProcessData: Tdi copied %ld instead of %ld\n",
                                BytesActuallyCopied,BytesNeeded));

                            goto DsiProcessData_ErrorExit;
                        }

                        pDsiReq->dsi_PartialWriteSize += BytesNeeded;

                        BytesConsumed += BytesActuallyCopied;
                        pStreamPtr += BytesActuallyCopied;
                        UnProcessedBytes -= BytesActuallyCopied;
                    }

                    // at this point, all the bytes needed to satisfy the Write should be in
                    ASSERT(pDsiReq->dsi_PartialWriteSize == pDsiReq->dsi_WriteLen);

                    pTcpConn->con_RcvState = DSI_WRITE_COMPLETE;

                    // make sure we visit case DSI_WRITE_COMPLETE: before leaving
                    fSomeMoreProcessing = TRUE;
                }

                ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                break;  // case DSI_PARTIAL_WRITE:


            case DSI_COMMAND_COMPLETE:
            case DSI_WRITE_COMPLETE:

                pDsiReq = pTcpConn->con_pDsiReq;

                ASSERT(pDsiReq != NULL);
                ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

                //
                // setup the AfpRequest according whether we buffered the
                // request or whether we are using TCP's buffer
                //

                if (pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA)
                {
                    ASSERT(pDsiReq->dsi_PartialBufSize != 0);
                    ASSERT(pDsiReq->dsi_PartialBuf != NULL);
                    ASSERT(pDsiReq->dsi_PartialBufSize == pDsiReq->dsi_RequestLen);

                    pDsiReq->dsi_AfpRequest.rq_RequestBuf = pDsiReq->dsi_PartialBuf;
                }
                else
                {
                    pDsiReq->dsi_AfpRequest.rq_RequestBuf = pStreamPtr;
                }

                pDsiReq->dsi_AfpRequest.rq_RequestSize = pDsiReq->dsi_RequestLen;

                InsertTailList(&pTcpConn->con_PendingReqs, &pDsiReq->dsi_Linkage);

                pTcpConn->con_pDsiReq = NULL;

                RequestLen = pDsiReq->dsi_RequestLen;

                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                //
                // call the routine to take appropriate action, based on what
                // DSI command it is
                // Once we are back from this routine, there is no telling what
                // would have happened to pDsiReq!  So don't touch it!
                //
                status = DsiExecuteCommand(pTcpConn, pDsiReq);

                if (!NT_SUCCESS(status))
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiProcessData: fatal error %lx, killing %lx\n",status,pTcpConn));

                    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
                    RemoveEntryList(&pDsiReq->dsi_Linkage);
                    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

                    if (pDsiReq->dsi_AfpRequest.rq_WriteMdl != NULL)
                    {
                        pDsiReq->dsi_AfpRequest.rq_RequestSize =
                            (LONG)pTcpConn->con_DestIpAddr;

                        ASSERT(pTcpConn->con_pSda != NULL);
                        AfpCB_RequestNotify(STATUS_REMOTE_DISCONNECT,
                                            pTcpConn->con_pSda,
                                            &pDsiReq->dsi_AfpRequest);
                    }

                    DsiAbortConnection(pTcpConn);
                    DsiFreeRequest(pDsiReq);

                    // remove the REQUEST refcount
                    DsiDereferenceConnection(pTcpConn);
                    DBGREFCOUNT(("DsiProcessData: REQUEST dec %lx (%d  %d,%d)\n",
                        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
                    *pBytesAccepted = BytesIndicated;
                    return(STATUS_SUCCESS);
                }

                ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

                //
                // were we using our own buffer to buffer data that came in pieces?
                //
                if (pTcpConn->con_State & TCPCONN_STATE_PARTIAL_DATA)
                {
                    pTcpConn->con_State &= ~TCPCONN_STATE_PARTIAL_DATA;
                }
                //
                // we weren't buffering, but using TCP's buffer: update counters
                //
                else
                {
                    BytesConsumed += RequestLen;
                    pStreamPtr += RequestLen;
                    UnProcessedBytes -= RequestLen;
                }

                pTcpConn->con_RcvState = DSI_NEW_REQUEST;

                ASSERT(pStreamPtr <= pBufferFromTcp+BytesIndicated);

                break;  // case DSI_HDR_COMPLETE:


            default:

                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiProcessData: and what state is this??\n"));

                ASSERT(0);

                break;

        }  // switch (pTcpConn->con_RcvState)


        //
        // If there are more bytes yet to be processed, or if TCP has more
        // bytes that we need to retrieve, we go back into the loop
        //
        if ((UnProcessedBytes > 0) || (fTCPHasMore))
        {
            fSomeMoreProcessing = TRUE;
        }

    } // while (fSomeMoreProcessing)

    //
    // if no bytes were indicated (if we came here not via TCP) then, we shouldn't
    // have consumed anything!
    //
    if (BytesIndicated == 0)
    {
        ASSERT(BytesConsumed == 0);
    }

    // did TCP call us?  then update byte count
    if (BytesIndicated)
    {
        pTcpConn->con_BytesWithTcp += (BytesAvailable - BytesConsumed);
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    ASSERT( UnProcessedBytes == 0 );
    ASSERT( BytesConsumed == BytesIndicated );

    *pBytesAccepted = BytesConsumed;

    return(status);


DsiProcessData_ErrorExit:

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiProcessData: executing Error path, aborting connection %lx\n",pTcpConn));

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
    DsiAbortConnection(pTcpConn);
    *pBytesAccepted = BytesIndicated;

    return(STATUS_SUCCESS);

}



/***	DsiTcpRcvIrpCompletion
 *
 *	This routine is called into by TCP when it has finished copying all the data
 *  into the irp we supplied.
 *
 *  Parm IN:  Unused - well, unused!
 *            pIrp - the irp that we had passed
 *            pContext - our context (i.e. pTcpConn)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTcpRcvIrpCompletion(
    IN  PDEVICE_OBJECT  Unused,
    IN  PIRP            pIrp,
    IN  PVOID           pContext
)
{
    PDEVICE_OBJECT      pDeviceObject;
    PTCPCONN            pTcpConn;
    PDSIREQ             pDsiReq=NULL;
    KIRQL               OldIrql;
    PMDL                pMdl;
    PMDL                pOrgMdl;
    PMDL                pPrevPartialMdl;
    PMDL                pNewPartialMdl;
    NTSTATUS            status;
    DWORD               BytesTaken;
    DWORD               BytesThisTime;
    DWORD               BytesAvailable;
    PIRP                pIrpToPost=NULL;
    DWORD               BytesNeeded;
    DWORD               BytesSoFar;


    pTcpConn = (PTCPCONN)pContext;

    ASSERT(VALID_TCPCONN(pTcpConn));

    ASSERT(pIrp == pTcpConn->con_pRcvIrp);

    pMdl = pIrp->MdlAddress;

    pPrevPartialMdl = (pMdl->MdlFlags & MDL_PARTIAL) ? pMdl : NULL;

    status = pIrp->IoStatus.Status;

    // if the receive failed, not much can be done with this connection!
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: irp %lx failed %lx on %lx!\n",pIrp,status,pTcpConn));

        goto DsiTcpRcvIrp_Completed;
    }


    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & (TCPCONN_STATE_CLOSING | TCPCONN_STATE_CLEANED_UP))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: conn %lx going away, ignoring date\n",pTcpConn));

        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
        goto DsiTcpRcvIrp_Completed;
    }

    ASSERT(pTcpConn->con_State & TCPCONN_STATE_TCP_HAS_IRP);

    BytesThisTime = (DWORD)(pIrp->IoStatus.Information);

    pDsiReq = pTcpConn->con_pDsiReq;

    ASSERT(pDsiReq != NULL);
    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    switch (pTcpConn->con_RcvState)
    {
        case DSI_PARTIAL_COMMAND:
        case DSI_PARTIAL_HEADER:

            pDsiReq->dsi_PartialBufSize += BytesThisTime;
            BytesSoFar = pDsiReq->dsi_PartialBufSize;

            ASSERT(BytesSoFar <= pDsiReq->dsi_RequestLen);
            BytesNeeded = (pDsiReq->dsi_RequestLen - BytesSoFar);

            pOrgMdl = pDsiReq->dsi_pDsiAllocedMdl;

            break;

        case DSI_PARTIAL_WRITE:

            pDsiReq->dsi_PartialWriteSize += BytesThisTime;
            BytesSoFar = pDsiReq->dsi_PartialWriteSize;

            ASSERT(BytesSoFar <= pDsiReq->dsi_WriteLen);
            BytesNeeded = (pDsiReq->dsi_WriteLen - BytesSoFar);

            pOrgMdl = pDsiReq->dsi_AfpRequest.rq_WriteMdl;

            break;

        default:

            ASSERT(0);

            status = STATUS_INVALID_SERVER_STATE;
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTcpRcvIrpCompletion: Bad RcvState %lx, irp %lx on %lx!\n",pTcpConn->con_RcvState,pIrp,status,pTcpConn));
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            goto DsiTcpRcvIrp_Completed;
    }

    ASSERT((BytesSoFar+BytesNeeded) == AfpMdlChainSize(pOrgMdl));

    if (pPrevPartialMdl == pOrgMdl)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: PrevPartial same as Org Mdl = %lx\n",pOrgMdl));

        pPrevPartialMdl = NULL;
    }


    //
    // update the count of how many bytes TCP has that we still need to retrieve.
    // It's possible for TCP to return more bytes in this irp (BytesThisTime) than
    // what we thought TCP had with it, because more stuff could have come on the wire
    //
    if (BytesThisTime > pTcpConn->con_BytesWithTcp)
    {
        pTcpConn->con_BytesWithTcp  = 0;
    }
    else
    {
        pTcpConn->con_BytesWithTcp -= BytesThisTime;
    }

    BytesAvailable = pTcpConn->con_BytesWithTcp;


    //
    // if we still need more bytes to satisfy this request, we need to pass the irp
    // back to TCP.  We must first get a partial Mdl describing the new offset though
    //
    if (BytesNeeded > 0)
    {
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

        // free up previously allocated partial mdl, if any
        if (pPrevPartialMdl)
        {
            ASSERT(pPrevPartialMdl != pOrgMdl);

            IoFreeMdl(pPrevPartialMdl);

            AFP_DBG_DEC_COUNT(AfpDbgMdlsAlloced);
            pNewPartialMdl = NULL;
        }

        pNewPartialMdl = DsiMakePartialMdl(pOrgMdl, BytesSoFar);

        if (pNewPartialMdl == NULL)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTcpRcvIrpCompletion: couldn't get partial mdl\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto DsiTcpRcvIrp_Completed;
        }

        TdiBuildReceive(pIrp,
                        pDeviceObject,
                        pTcpConn->con_pFileObject,
                        DsiTcpRcvIrpCompletion,
                        (PVOID)pTcpConn,
                        pNewPartialMdl,
                        TDI_RECEIVE_NORMAL,
                        BytesNeeded);

        IoCallDriver(pDeviceObject,pIrp);

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }


    pTcpConn->con_State &= ~TCPCONN_STATE_TCP_HAS_IRP;

    pTcpConn->con_pRcvIrp = NULL;

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    status = STATUS_SUCCESS;


DsiTcpRcvIrp_Completed:

    // free up previously allocated partial mdl, if any
    if (pPrevPartialMdl)
    {
        ASSERT(pPrevPartialMdl != pOrgMdl);
        IoFreeMdl(pPrevPartialMdl);

        AFP_DBG_DEC_COUNT(AfpDbgMdlsAlloced);
    }

    // if DSI had allocated Mdl, free it here
    if (pDsiReq && pDsiReq->dsi_pDsiAllocedMdl)
    {
        AfpFreeMdl(pDsiReq->dsi_pDsiAllocedMdl);
        pDsiReq->dsi_pDsiAllocedMdl = NULL;
    }

    // and, say good bye to that irp
    AfpFreeIrp(pIrp);

    //
    // if the irp completed normally (most common case) then we need to call
    // our processing loop so state is updated, Afp is informed (if needed) etc.
    // also, if there are more bytes with TCP, we need to post an irp to get them
    //
    if (NT_SUCCESS(status))
    {
        status = DsiProcessData(pTcpConn,
                                0,
                                BytesAvailable,
                                NULL,
                                &BytesTaken,
                                &pIrpToPost);

        //
        // does TCP have more data? then we have an irp to post to TCP
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            ASSERT(pIrpToPost != NULL);

            IoSkipCurrentIrpStackLocation(pIrpToPost);

            IoCallDriver(pDeviceObject,pIrpToPost);

            //
            // remove the TcpIRP refcount since the original irp, pIrp completed
            // The newer irp, pIrpToPost, will have upped refcount and will decrement
            // when it completes
            //
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiTcpRcvIrpCompletion: TcpIRP dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

            return(STATUS_MORE_PROCESSING_REQUIRED);
        }

        //
        // if DsiProcessData returns this errorcode, it's to tell TCP that it will
        // give an irp later.  It's not an error, so change it to success
        //
        else if (status == STATUS_DATA_NOT_ACCEPTED)
        {
            status = STATUS_SUCCESS;
        }
    }


    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTcpRcvIrpCompletion: aborting %lx because status = %lx!\n",
            pTcpConn, status));

        DsiAbortConnection(pTcpConn);
    }

    // remove the TcpIRP refcount now that the irp completed
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiTcpRcvIrpCompletion: TcpIRP dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


/***	DsiExecuteCommand
 *
 *	This routine looks at what DSI command has come from the client, and takes
 *  appropriate.  If adequate data is not yet available to take action, it
 *  marks the state appropritely and returns.
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DSI request object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiExecuteCommand(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{

    NTSTATUS        status=STATUS_SUCCESS;
    KIRQL           OldIrql;
    BOOLEAN         fWeIniatedClose=FALSE;



    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    // we don't need to hold a lock here: it's not essential to be accurate
    if (pDsiReq->dsi_Command != DSI_COMMAND_TICKLE)
    {
        pTcpConn->con_LastHeard = AfpSecondsSinceEpoch;
    }

    //
    // see what command it is, and do the needful
    //

    switch (pDsiReq->dsi_Command)
    {
        case DSI_COMMAND_COMMAND:
        case DSI_COMMAND_WRITE:

            //
            // make sure the guy has opened AFP session before we hand this over..
            //
            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
            if (!(pTcpConn->con_State & TCPCONN_STATE_NOTIFY_AFP))
            {
                RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: must do OpenSession first! Disconnecting..\n"));
                status = STATUS_UNSUCCESSFUL;
                break;
            }
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            // ok, hand over the request to AFP (AfpUnmarshall.. expects DPC)
		    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

            status = AfpCB_RequestNotify(STATUS_SUCCESS,
                                        pTcpConn->con_pSda,
                                        &pDsiReq->dsi_AfpRequest);

		    KeLowerIrql(OldIrql);

            if (!NT_SUCCESS(status))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: AfpCB_RequestNotify failed %lx\n",status));
            }

            break;

        case DSI_COMMAND_GETSTATUS:

            status = DsiSendStatus(pTcpConn, pDsiReq);

            if (!NT_SUCCESS(status))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: DsiSendStatus failed %lx\n",status));
            }

            break;

        case DSI_COMMAND_CLOSESESSION:

            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

            fWeIniatedClose = (pDsiReq->dsi_Flags == DSI_REPLY);

            pTcpConn->con_State |= TCPCONN_STATE_CLOSING;
            pTcpConn->con_State |= TCPCONN_STATE_RCVD_REMOTE_CLOSE;

            if (fWeIniatedClose)
            {
                RemoveEntryList(&pDsiReq->dsi_Linkage);
                InitializeListHead(&pDsiReq->dsi_Linkage);
            }
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            //
            // if we initiated the CloseSession, then what we just got is the
            // client's reponse. Done here: go ahead and terminate the connection.
            //
            if (fWeIniatedClose)
            {
                DsiFreeRequest(pDsiReq);

                // remove the REQUEST refcount
                DsiDereferenceConnection(pTcpConn);

                DBGREFCOUNT(("DsiExecuteCommand: REQUEST dec %lx (%d  %d,%d)\n",
                    pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
                DsiTerminateConnection(pTcpConn);
            }

            //
            // remote client initiated the CloseSession.  Tell AFP that the
            // session is going away, and then send CloseSession response
            //
            else
            {
                DsiDisconnectWithAfp(pTcpConn, STATUS_REMOTE_DISCONNECT);

                status = DsiSendDsiReply(pTcpConn, pDsiReq, STATUS_SUCCESS);

                if (!NT_SUCCESS(status))
                {
                    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                        ("DsiExecuteCommand: send on CloseSess failed %lx\n",status));
                }
            }

            break;

        case DSI_COMMAND_OPENSESSION:

            // see if AFP will accept this session request
            status = DsiOpenSession(pTcpConn, pDsiReq);

            if (!NT_SUCCESS(status))
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiExecuteCommand: DsiOpenSession failed %lx\n",status));
            }

            DsiSendDsiReply(pTcpConn, pDsiReq, status);

            status = STATUS_SUCCESS;

            break;

        //
        // we got a tickle, or a response to our Attention.
        // Just free up this request.
        // If we get an unrecognized command, we just tear the connection down!
        //
        case DSI_COMMAND_TICKLE:
        case DSI_COMMAND_ATTENTION:

            ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);
            RemoveEntryList(&pDsiReq->dsi_Linkage);
            InitializeListHead(&pDsiReq->dsi_Linkage);
            RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

            DsiFreeRequest(pDsiReq);

            // remove the REQUEST refcount
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiExecuteCommand: REQUEST dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

            break;

        default:

            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiExecuteCommand: unknown command %d\n",pDsiReq->dsi_Command));
            status = STATUS_UNSUCCESSFUL;

            break;
    }

    return(status);

}



/***	DsiOpenSession
 *
 *	This routine responds to an OpenSession request from the client, after
 *  notifying AFP and making sure that AFP wants to accept this connection
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DSI request object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiOpenSession(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{

    KIRQL       OldIrql;
    PSDA        pSda;
    PBYTE       pOptions;


    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pSda = AfpCB_SessionNotify(pTcpConn, TRUE);

    if (pSda == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiOpenSession: AfpCB_SessionNotify failed!\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    pTcpConn->con_pSda = pSda;

    pTcpConn->con_State |= TCPCONN_STATE_AFP_ATTACHED;

    // from here on, if we disconnect, we must tell AFP
    pTcpConn->con_State |= TCPCONN_STATE_NOTIFY_AFP;

    // put AFP refcount, to be removed when AFP closes the session
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiOpenSession: AFP inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    //
    // parse any options that might have arrived with the OpenSession command
    // Currently, the only option that we can get from the client is the largest
    // attention packet it can receive from us.
    //

    if (pDsiReq->dsi_RequestLen > 0)
    {
        // currently, this can only be 6 bytes
        ASSERT(pDsiReq->dsi_RequestLen == 6);

        pOptions = pDsiReq->dsi_AfpRequest.rq_RequestBuf;

        ASSERT(pOptions[0] == 0x01);
        ASSERT(pOptions[1] == 4);

        GETDWORD2DWORD(&pTcpConn->con_MaxAttnPktSize, &pOptions[2]);
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    return(STATUS_SUCCESS);

}




/***	DsiSendDsiRequest
 *
 *	This routine sends a request to the client.  The only requests that originate
 *  from the server are CloseSession, Tickle and Attention
 *
 *  Parm IN:  pTcpConn - the connection object
 *            SendLen - how many bytes we are sending
 *            AttentionWord - if this is Attention request, the 2 bytes
 *            AttentionContext - context, if this is Attention request
 *            Command - which one is it: Close, Tickle or Attention
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendDsiRequest(
    IN  PTCPCONN    pTcpConn,
    IN  DWORD       DataLen,
    IN  USHORT      AttentionWord,
    IN  PVOID       AttentionContext,
    IN  BYTE        Command
)
{
    NTSTATUS        status;
    KIRQL           OldIrql;
    PDSIREQ         pDsiReq=NULL;
    DWORD           SendLen;
    PBYTE           pPacket;
    PMDL            pMdl;


    pDsiReq = DsiGetRequest();
    if (pDsiReq == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpSendAttention: DsiGetRequest failed\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pPacket = &pDsiReq->dsi_RespHeader[0];

    SendLen = DataLen + DSI_HEADER_SIZE;

    pMdl = AfpAllocMdl(pPacket, SendLen, NULL);
    if (pMdl == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAfpSendAttention: alloc mdl failed\n"));
        DsiFreeRequest(pDsiReq);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    pDsiReq->dsi_RequestID = pTcpConn->con_OutgoingReqId++;
    InsertTailList(&pTcpConn->con_PendingReqs, &pDsiReq->dsi_Linkage);

    // put a REQUEST refcount
    pTcpConn->con_RefCount++;

    DBGREFCOUNT(("DsiSendDsiRequest: REQUEST inc %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    pDsiReq->dsi_Signature = DSI_REQUEST_SIGNATURE;
    pDsiReq->dsi_pTcpConn = pTcpConn;
    pDsiReq->dsi_Command = Command;
    pDsiReq->dsi_Flags = DSI_REQUEST;
    pDsiReq->dsi_pDsiAllocedMdl = pMdl;

    //
    // form the DSI header
    //

    pPacket[DSI_OFFSET_FLAGS] = DSI_REQUEST;
    pPacket[DSI_OFFSET_COMMAND] = Command;

    PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);

    *(DWORD *)&pPacket[DSI_OFFSET_DATAOFFSET] = 0;

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], DataLen);

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_RESERVED], 0);

    if (Command == DSI_COMMAND_ATTENTION)
    {
        PUTSHORT2SHORT(&pPacket[DSI_HEADER_SIZE], AttentionWord);
        pDsiReq->dsi_AttnContext = AttentionContext;
    }

    status = DsiTdiSend(pTcpConn,
                        pMdl,
                        SendLen,
                        DsiSendCompletion,
                        pDsiReq);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendDsiRequest: DsiTdiSend failed %lx\n",status));

        AfpFreeMdl(pMdl);
        pDsiReq->dsi_pDsiAllocedMdl = NULL;
        DsiSendCompletion(NULL, NULL, pDsiReq);
        status = STATUS_PENDING;
    }

    return(status);
}



/***	DsiSendDsiReply
 *
 *	This routine sends a reply to the client, in response to the client's
 *  DSI-level request (OpenSession, CloseSession, or Tickle)
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DIS request (from client's)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendDsiReply(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq,
    IN  NTSTATUS    OpStatus
)
{
    PBYTE       pPacket;
    PBYTE       pOption;
    PMDL        pMdl;
    DWORD       OptionLen;
    DWORD       TotalLen;
    NTSTATUS    status=STATUS_SUCCESS;


    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    if (pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION)
    {
        OptionLen = DSI_OPENSESS_OPTION_LEN + DSI_OPTION_FIXED_LEN;
        TotalLen = DSI_HEADER_SIZE + OptionLen;
    }
    else
    {
        ASSERT((pDsiReq->dsi_Command == DSI_COMMAND_CLOSESESSION) ||
               (pDsiReq->dsi_Command == DSI_COMMAND_TICKLE));

        TotalLen = DSI_HEADER_SIZE;
        OptionLen = 0;
    }

    pPacket = &pDsiReq->dsi_RespHeader[0];

    RtlZeroMemory(pPacket, TotalLen);

    pPacket[DSI_OFFSET_FLAGS] = DSI_REPLY;
    pPacket[DSI_OFFSET_COMMAND] = pDsiReq->dsi_Command;

    PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);

    PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], OptionLen);

    //
    // if this is an OpenSession packet, setup the optional fields
    //
    if (pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION)
    {
        pOption = &pPacket[DSI_HEADER_SIZE];

        pOption[DSI_OFFSET_OPTION_TYPE] = DSI_OPTION_SRVREQ_QUANTUM;
        pOption[DSI_OFFSET_OPTION_LENGTH] = DSI_OPENSESS_OPTION_LEN;

        PUTDWORD2DWORD(&pOption[DSI_OFFSET_OPTION_OPTION],
                       DSI_SERVER_REQUEST_QUANTUM);

        // if open session didn't go well, tell client the whole store
        if (OpStatus == STATUS_INSUFFICIENT_RESOURCES)
        {
            PUTDWORD2DWORD(&pPacket[DSI_OFFSET_ERROROFFSET], ASP_SERVER_BUSY);
        }
    }

    //
    // allocate an mdl
    //
    pMdl = AfpAllocMdl(pPacket, TotalLen, NULL);
    if (pMdl == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendDsiReply: malloc failed!\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(status))
    {
        status = DsiTdiSend(pTcpConn,
                            pMdl,
                            TotalLen,
                            DsiSendCompletion,
                            pDsiReq);

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendDsiReply: DsiTdiSend failed %lx\n",status));
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (pMdl)
        {
            AfpFreeMdl(pMdl);
        }
        DsiSendCompletion(NULL, NULL, pDsiReq);
    }

    return(status);
}


/***	DsiSendStatus
 *
 *	This routine responds to the GetStatus requst from the client.
 *  Basically, we simply copy the status buffer here and send it.
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DIS request (from client's)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendStatus(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{
    NTSTATUS        status=STATUS_SUCCESS;
    PBYTE           pPacket;
    PMDL            pMdl=NULL;
    KIRQL           OldIrql;
    DWORD           TotalLen;


    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);

    if (DsiStatusBuffer != NULL)
    {
        TotalLen = DsiStatusBufferSize + DSI_HEADER_SIZE;

        pPacket = AfpAllocNonPagedMemory(TotalLen);
        if (pPacket != NULL)
        {
            //
            // form the DSI header
            //
            pPacket[DSI_OFFSET_FLAGS] = DSI_REPLY;
            pPacket[DSI_OFFSET_COMMAND] = pDsiReq->dsi_Command;
            PUTSHORT2SHORT(&pPacket[DSI_OFFSET_REQUESTID], pDsiReq->dsi_RequestID);
            *(DWORD *)&pPacket[DSI_OFFSET_DATAOFFSET] = 0;
            PUTDWORD2DWORD(&pPacket[DSI_OFFSET_DATALEN], DsiStatusBufferSize);
            PUTDWORD2DWORD(&pPacket[DSI_OFFSET_RESERVED], 0);

            //
            // copy the status buffer
            //
            RtlCopyMemory(pPacket + DSI_HEADER_SIZE,
                          DsiStatusBuffer,
                          DsiStatusBufferSize);

            pMdl = AfpAllocMdl(pPacket, TotalLen, NULL);
            if (pMdl == NULL)
            {
                DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                    ("DsiSendStatus: mdl alloc failed\n"));
                AfpFreeMemory(pPacket);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendStatus: malloc for GetStatus failed\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendStatus: DsiStatusBuffer is null, server didn't SetStatus?\n"));
        status = STATUS_UNSUCCESSFUL;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    if (NT_SUCCESS(status))
    {
        status = DsiTdiSend(pTcpConn,
                            pMdl,
                            TotalLen,
                            DsiSendCompletion,
                            pDsiReq);
    }

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendStatus: DsiTdiSend failed %lx\n",status));

        if (pMdl)
        {
            AfpFreeMdl(pMdl);
        }
        DsiSendCompletion(NULL, NULL, pDsiReq);
        status = STATUS_PENDING;
    }

    return(status);
}



/***	DsiSendTickles
 *
 *	This routine sends out a tickle from our end to every client that we haven't
 *  heard from in the last 30 seconds
 *
 *  Parm IN:  nothing
 *
 *  Returns:  status of operation
 *
 */
AFPSTATUS FASTCALL
DsiSendTickles(
    IN  PVOID pUnUsed
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pList;
    PTCPCONN            pTcpConn;
    AFPSTATUS           status;


    ASSERT(AfpServerBoundToTcp);

    ASSERT(DsiTcpAdapter != NULL);

    ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

    // if adapter is shutting down, go back (and don't requeue)
    if (DsiTcpAdapter->adp_State & TCPADPTR_STATE_CLOSING)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendTickles: adapter closing, so just returned\n"));

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);
        return(AFP_ERR_NONE);
    }

    // put TickleTimer refcount: don't want it to go away till we're done here
    DsiTcpAdapter->adp_RefCount++;

    pList = DsiTcpAdapter->adp_ActiveConnHead.Flink;

    while (pList != &DsiTcpAdapter->adp_ActiveConnHead) 
    {
        pTcpConn = CONTAINING_RECORD(pList, TCPCONN, con_Linkage);

        pList = pList->Flink;

        ACQUIRE_SPIN_LOCK_AT_DPC(&pTcpConn->con_SpinLock);

        // connection closing or tickles stopped on this connection?  skip it
        if (pTcpConn->con_State & (TCPCONN_STATE_CLOSING |
                                   TCPCONN_STATE_TICKLES_STOPPED))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("DsiSendTickles: %lx closing or tickles stopped: skipping\n",pTcpConn));

            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }

        if (!(pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendTickles: %lx *** RACE CONDITION *** conn not setup yet\n",pTcpConn));

            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }


        // have we heard from the client recently for this puppy?  if so, skip it
        if ((AfpSecondsSinceEpoch - pTcpConn->con_LastHeard) < DSI_TICKLE_TIME_LIMIT)
        {
            RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);
            continue;
        }

        // reset this, so we don't keep sending
        pTcpConn->con_LastHeard = AfpSecondsSinceEpoch;

        // Put TICKLE refcount: make sure connection stays around till we're done!
        pTcpConn->con_RefCount++;

        DBGREFCOUNT(("DsiSendTickles: TICKLE inc %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        RELEASE_SPIN_LOCK_FROM_DPC(&pTcpConn->con_SpinLock);

        RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

        DsiSendDsiRequest(pTcpConn, 0, 0, NULL, DSI_COMMAND_TICKLE);

        ACQUIRE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, &OldIrql);

        // since we released the lock, things could have changed: start over
        pList = DsiTcpAdapter->adp_ActiveConnHead.Flink;
    }

    status = AFP_ERR_REQUEUE;

    if (DsiTcpAdapter->adp_State & TCPADPTR_STATE_CLOSING)
    {
        status = AFP_ERR_NONE;
    }

    RELEASE_SPIN_LOCK(&DsiTcpAdapter->adp_SpinLock, OldIrql);

    // remove the TickleTimer refcount
    DsiDereferenceAdapter(DsiTcpAdapter);

    return(status);
}


/***	DsiValidateHeader
 *
 *	This routine makes sure that the packet we just received looks good.
 *  i.e. whether the request id matches what we expect to receive, whether
 *  the command is valid, whether the Write length (if applicable) is what we
 *  negotiated (or less) etc.
 *
 *  Parm IN:  pTcpConn - the connection object
 *            pDsiReq - the DIS request (from client's)
 *
 *  Returns:  TRUE if the packet header is acceptable, FALSE otherwise
 *
 *  NOTE: pTcpConn spinlock is held on entry
 */
BOOLEAN
DsiValidateHeader(
    IN  PTCPCONN    pTcpConn,
    IN  PDSIREQ     pDsiReq
)
{

    BOOLEAN     fCheckIncomingReqId = TRUE;

    //
    // if this is the first packet we are receiving on this connection, note
    // down what the client's starting request id is
    //
    if ((pDsiReq->dsi_Command == DSI_COMMAND_GETSTATUS) ||
        (pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION))
    {
        if (pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: session already going!\n"));
            return(FALSE);
        }

        pTcpConn->con_NextReqIdToRcv =
            (pDsiReq->dsi_RequestID == 0xFFFF)? 0 : (pDsiReq->dsi_RequestID+1);

        fCheckIncomingReqId = FALSE;
    }
    else
    {
        if (!(pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: command %d rcvd, but session not setup!\n",
                pDsiReq->dsi_Command));
        }
    }

    if (pDsiReq->dsi_Flags != DSI_REQUEST)
    {
        if (pDsiReq->dsi_Flags != DSI_REPLY)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: Flags=%d, neither Request, nor reply\n",
                pDsiReq->dsi_Flags));
            return(FALSE);
        }

        //
        // we expect REPLY from client only for two commands: anything else is bad
        //
        if ((pDsiReq->dsi_Command != DSI_COMMAND_CLOSESESSION) &&
            (pDsiReq->dsi_Command != DSI_COMMAND_ATTENTION))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: Flags=Reply, but cmd=%d\n",pDsiReq->dsi_Command));
            return(FALSE);
        }
        fCheckIncomingReqId = FALSE;
    }


    //
    // for all requests (except the first one), the RequestId must match what
    // we expect.  Otherwise, we just kill the connection!
    //
    if (fCheckIncomingReqId)
    {
        if (pDsiReq->dsi_RequestID != pTcpConn->con_NextReqIdToRcv)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: ReqId mismatch (%ld vs. %ld)\n",
                pDsiReq->dsi_RequestID,pTcpConn->con_NextReqIdToRcv));
            return(FALSE);
        }

        if (pTcpConn->con_NextReqIdToRcv == 0xFFFF)
        {
            pTcpConn->con_NextReqIdToRcv = 0;
        }
        else
        {
            pTcpConn->con_NextReqIdToRcv++;
        }
    }

    if (pDsiReq->dsi_RequestLen > DSI_SERVER_REQUEST_QUANTUM)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiValidateHeader: RequestLen too big %ld\n",pDsiReq->dsi_RequestLen));
        return(FALSE);
    }

    if (pDsiReq->dsi_Command == DSI_COMMAND_WRITE)
    {
        if (pDsiReq->dsi_WriteLen > DSI_SERVER_REQUEST_QUANTUM)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiValidateHeader: WriteLen too big %ld\n",pDsiReq->dsi_WriteLen));
            return(FALSE);
        }
    }

    return(TRUE);
}



/***	DsiAfpReplyCompletion
 *
 *	When AFP sends a reply to the client, DSI sends it out.  When TCP completes
 *  that send, this routine gets called.  We complete AFP's send at this point,
 *  and do other cleanup like releasing resources (if necessary)
 *
 *  Parm IN:  DeviceObject - not used
 *            pIrp - the irp that we sent out
 *            pContext - the DIS request (pDsiReq)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAfpReplyCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
)
{
    PDSIREQ     pDsiReq;
    KIRQL       OldIrql;
    PMDL        pMdl=NULL;
    PTCPCONN    pTcpConn;
    PBYTE       pPacket=NULL;
    NTSTATUS    status=STATUS_SUCCESS;


    pDsiReq = (PDSIREQ)pContext;

    ASSERT(pDsiReq->dsi_Signature == DSI_REQUEST_SIGNATURE);

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    RemoveEntryList(&pDsiReq->dsi_Linkage);

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        pMdl = pIrp->MdlAddress;

#if DBG
        if (pMdl)
        {
            // put in a signature to say completion routine has runn on this puppy
            pPacket = MmGetSystemAddressForMdlSafe(
					pMdl,
					NormalPagePriority);
			if (pPacket != NULL)
			{
				*(DWORD *)pPacket = 0x11223344;
			}
			else
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
			}
        }
#endif
        // if this mdl was allocated by DSI, free it here
        if (pDsiReq->dsi_pDsiAllocedMdl != NULL)
        {
            ASSERT(pDsiReq->dsi_pDsiAllocedMdl == pMdl);
            ASSERT(pDsiReq->dsi_pDsiAllocedMdl->Next == pDsiReq->dsi_AfpRequest.rq_ReplyMdl);

            pDsiReq->dsi_pDsiAllocedMdl->Next = NULL;

            AfpFreeMdl(pDsiReq->dsi_pDsiAllocedMdl);

            pDsiReq->dsi_pDsiAllocedMdl = NULL;
        }

        pIrp->MdlAddress = NULL;

        AfpFreeIrp(pIrp);
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    AfpCB_ReplyCompletion(status, pTcpConn->con_pSda, &pDsiReq->dsi_AfpRequest);

    DsiFreeRequest(pDsiReq);

    // remove the REQUEST refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiAfpReplyCompletion: REQUEST dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_MORE_PROCESSING_REQUIRED);

}

/***	DsiSendCompletion
 *
 *	When DSI sends a request (tickle, close session, attention) or reply
 *  (CloseSession, OpenSession) and when TCP completes that send, this routine
 *  gets called.
 *
 *  Parm IN:  DeviceObject - not used
 *            pIrp - the irp that we sent out
 *            pContext - the DIS request (pDsiReq)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiSendCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
)
{
    PDSIREQ     pDsiReq;
    KIRQL       OldIrql;
    PBYTE       pPacket=NULL;
    PBYTE       pOption;
    PMDL        pMdl=NULL;
    PTCPCONN    pTcpConn;
    NTSTATUS    status=STATUS_SUCCESS;
    BOOLEAN     fMacHasAlreadySentClose=FALSE;
    BOOLEAN     fAfpIsAttached=TRUE;


    pDsiReq = (PDSIREQ)pContext;

    pTcpConn = pDsiReq->dsi_pTcpConn;

    ASSERT(VALID_TCPCONN(pTcpConn));

    if (pIrp)
    {
        status = pIrp->IoStatus.Status;

        pMdl = pIrp->MdlAddress;

        ASSERT(pMdl != NULL);
        pPacket = MmGetSystemAddressForMdlSafe(
				pMdl,
				NormalPagePriority);
		if (pPacket != NULL) {
			if (pPacket != &pDsiReq->dsi_RespHeader[0])
			{
				AfpFreeMemory(pPacket);
			}
		}

        AfpFreeMdl(pMdl);
        pDsiReq->dsi_pDsiAllocedMdl = NULL;

        AfpFreeIrp(pIrp);
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_RCVD_REMOTE_CLOSE)
    {
        fMacHasAlreadySentClose = TRUE;
    }

    if (!(pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED))
    {
        fAfpIsAttached = FALSE;
    }

    RemoveEntryList(&pDsiReq->dsi_Linkage);

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    //
    // was this an Attention? call afp's completion to say Attention was sent
    //
    if (pDsiReq->dsi_Command == DSI_COMMAND_ATTENTION)
    {
        AfpCB_AttnCompletion(pDsiReq->dsi_AttnContext);
    }

    // if this was a OpenSession reply and if it didn't go well, terminate the conn
    else if ((pDsiReq->dsi_Command == DSI_COMMAND_OPENSESSION) && (!fAfpIsAttached))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiSendCompletion: terminating conn since OpenSess didn't succeed %lx\n",pTcpConn));

        DsiTerminateConnection(pTcpConn);
    }

    //
    // if this was a CloseSession request and we have already received Mac's
    // close, or if this was a GetStatus request, terminate the connection
    //
    else if (((pDsiReq->dsi_Command == DSI_COMMAND_CLOSESESSION) &&
              (fMacHasAlreadySentClose)) ||
             (pDsiReq->dsi_Command == DSI_COMMAND_GETSTATUS))
    {
        DsiTerminateConnection(pTcpConn);
    }

    //
    // if this was a Tickle, remove that TICKLE refcount we had put before send
    //
    else if (pDsiReq->dsi_Command == DSI_COMMAND_TICKLE)
    {
        DsiDereferenceConnection(pTcpConn);
        DBGREFCOUNT(("DsiSendCompletion: TICKLE dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    //
    // send failed?  might as well abort!
    //
    if (!NT_SUCCESS(status))
    {
        if (!(pTcpConn->con_State & TCPCONN_STATE_CLEANED_UP))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiSendCompletion: send failed %lx, so killing conection %lx\n",
                status,pTcpConn));
        }

        DsiAbortConnection(pTcpConn);
    }


    // remove the REQUEST refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiSendCompletion: REQUEST dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    DsiFreeRequest(pDsiReq);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}



/***	DsiAcceptConnectionCompletion
 *
 *	When TCP completes the accept, this routine is called
 *
 *  Parm IN:  DeviceObject - unused
 *            pIrp - our irp that completed
 *            Context - our context (pTcpConn)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiAcceptConnectionCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
{
    NTSTATUS        status;
    PTCPCONN        pTcpConn;
    KIRQL           OldIrql;
    BOOLEAN         fMustDeref=FALSE;


    pTcpConn = (PTCPCONN)Context;

    ASSERT(VALID_TCPCONN(pTcpConn));

    status = pIrp->IoStatus.Status;

    // if the incoming connection failed to be setup right, go cleanup!
    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiAcceptConnectionCompletion: connection failed %lx\n",status));

        DsiAbortConnection(pTcpConn);
    }

    // this is our irp: free it
    AfpFreeIrp(pIrp);

    // remove the ACCEPT refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiAcceptConnectionCompletion: ACCEPT dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


/***	DsiDisconnectWithTcp
 *
 *	This routine passes an irp down to tcp, asking it to disconnect the connection
 *
 *  Parm IN:  pTcpConn - the connection object in question
 *            DiscFlag - how should the disconnect be, graceful or abortive
 *
 *  Returns:  result of operation
 *
 */
NTSTATUS
DsiDisconnectWithTcp(
    IN  PTCPCONN    pTcpConn,
    IN DWORD        DiscFlag
)
{
    PDEVICE_OBJECT      pDeviceObject;
    KIRQL               OldIrql;
    PIRP                pIrp;
    NTSTATUS            status;
    BOOLEAN             fTcpAlreadyKnows=FALSE;


    //
    // find out if TCP still thinks the connection is up (basically watch out
    // for a timing window where we send an irp down and tcp calls our disconnect
    // handler: we want to deref only once in this case!)
    //
    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_TCP)
    {
        fTcpAlreadyKnows = FALSE;
        pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_TCP;

        // put a DISCONNECT refcount, since we'll be sending an irp down
        pTcpConn->con_RefCount++;

        // mark that we initiated an abortive disconnect (we use this flag to avoid
        // a race condition where we are doing a graceful close but the remote guy
        // resets our connection)
        if (DiscFlag == TDI_DISCONNECT_ABORT)
        {
            pTcpConn->con_State |= TCPCONN_STATE_ABORTIVE_DISCONNECT;
        }

        DBGREFCOUNT(("DsiDisconnectWithTcp: DISCONNECT inc %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }
    else
    {
        fTcpAlreadyKnows = TRUE;
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (fTcpAlreadyKnows)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiDisconnectWithTcp: TCP already disconnected, no irp posted\n"));

        return(STATUS_SUCCESS);
    }


    pDeviceObject = IoGetRelatedDeviceObject(pTcpConn->con_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDisconnectWithTcp: AllocIrp failed\n"));

        // remove that DISCONNECT refcount
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiDisconnectWithTcp: DISCONNECT dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIrp->CancelRoutine = NULL;

    TdiBuildDisconnect(
        pIrp,
        pDeviceObject,
        pTcpConn->con_pFileObject,
        DsiTcpDisconnectCompletion,
        pTcpConn,
        0,
        DiscFlag,
        NULL,
        NULL);

    pIrp->MdlAddress = NULL;

    status = IoCallDriver(pDeviceObject,pIrp);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiDisconnectWithTcp: IoCallDriver failed %lx\n",status));
    }

    // if we are doing an abortive disconnect, tcp will not inform us anymore!
    if (DiscFlag == TDI_DISCONNECT_ABORT)
    {
        // remove the TCP CLIENT-FIN refcount
        DsiDereferenceConnection(pTcpConn);
        DBGREFCOUNT(("DsiDisconnectWithTcp: CLIENT-FIN dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
    }

    return(STATUS_PENDING);
}



/***	DsiDisconnectWithAfp
 *
 *	This routine tells AFP that the connection is going away
 *
 *  Parm IN:  pTcpConn - the connection object in question
 *            Reason - why is the connection going away
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiDisconnectWithAfp(
    IN  PTCPCONN    pTcpConn,
    IN  NTSTATUS    Reason
)
{

    KIRQL       OldIrql;
    REQUEST     Request;
    BOOLEAN     fAfpAlreadyKnows=FALSE;


    RtlZeroMemory(&Request, sizeof(REQUEST));

    ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

    if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_AFP)
    {
        fAfpAlreadyKnows = FALSE;
        pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_AFP;
    }
    else
    {
        fAfpAlreadyKnows = TRUE;
    }

    RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

    if (fAfpAlreadyKnows)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("DsiDisconnectWithAfp: AFP need not be told (again)\n"));

        return(STATUS_SUCCESS);
    }

    //
    // notify AFP that the connection is going away
    //
    Request.rq_RequestSize = (LONG)pTcpConn->con_DestIpAddr;

    AfpCB_RequestNotify(Reason, pTcpConn->con_pSda, &Request);

    return(STATUS_SUCCESS);

}

/***	DsiTcpDisconnectCompletion
 *
 *	This routine is the completion routine when tcp completes our disconnect request
 *
 *  Parm IN:  DeviceObject - unused
 *            pIrp - our irp, to be freed
 *            Context - pTcpConn, our connection object
 *
 *  Returns:  result of operation
 *
 */
NTSTATUS
DsiTcpDisconnectCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
)
{

    PTCPCONN    pTcpConn;
    KIRQL       OldIrql;
    NTSTATUS    status=STATUS_SUCCESS;


    pTcpConn = (PTCPCONN)Context;

    ASSERT(VALID_TCPCONN(pTcpConn));

    //
    // tell AFP that the close completed
    //
    if (pTcpConn->con_pSda)
    {
        AfpCB_CloseCompletion(STATUS_SUCCESS, pTcpConn->con_pSda);
    }

    ACQUIRE_SPIN_LOCK(&DsiResourceLock, &OldIrql);
    ASSERT(DsiNumTcpConnections > 0);
    DsiNumTcpConnections--;
    RELEASE_SPIN_LOCK(&DsiResourceLock, OldIrql);

    // TCP is telling us it sent our FIN: remove the TCP SRVR-FIN refcount
    DsiDereferenceConnection(pTcpConn);

    DBGREFCOUNT(("DsiTcpDisconnectCompletion: SRVR-FIN dec %lx (%d  %d,%d)\n",
        pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

    if (pIrp != NULL)
    {
        status = pIrp->IoStatus.Status;

        if (!NT_SUCCESS(status))
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTcpDisconnectCompletion: status = %lx\n",status));
        }

        // remove the DISCONNECT refcount for completion of the irp
        DsiDereferenceConnection(pTcpConn);

        DBGREFCOUNT(("DsiTcpDisconnectCompletion: DISCONNECT dec %lx (%d  %d,%d)\n",
            pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));

        // it's ours: free it
        AfpFreeIrp(pIrp);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	errorlog.c

Abstract:

	This module implements the error logging in the server.

	!!! This module must be nonpageable.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	10 Jun 1992		Initial Version

--*/

#define	FILENUM	FILE_ERRORLOG
#include <afp.h>

VOID
AfpWriteErrorLogEntry(
	IN ULONG			EventCode,				// message number
	IN LONG				UniqueErrorCode OPTIONAL,
	IN NTSTATUS			NtStatusCode,
	IN PVOID			RawDataBuf OPTIONAL,
	IN LONG				RawDataLen,
	IN PUNICODE_STRING	pInsertionString OPTIONAL
)
{

	PIO_ERROR_LOG_PACKET	ErrorLogEntry;
	LONG					InsertionStringLength = 0;

#ifdef	STOP_ON_ERRORS
	DBGBRK(DBG_LEVEL_ERR);
#endif

	if (ARGUMENT_PRESENT(pInsertionString))
	{
		InsertionStringLength = pInsertionString->Length;
	}

	ErrorLogEntry =
		(PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(AfpDeviceObject,
		(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + RawDataLen + InsertionStringLength));

	if (ErrorLogEntry != NULL)
	{
		// Fill in the Error log entry

		ErrorLogEntry->ErrorCode = EventCode;
		ErrorLogEntry->MajorFunctionCode = 0;
		ErrorLogEntry->RetryCount = 0;
		ErrorLogEntry->UniqueErrorValue = (ULONG)UniqueErrorCode;
		ErrorLogEntry->FinalStatus = NtStatusCode;
		ErrorLogEntry->IoControlCode = 0;
		ErrorLogEntry->DeviceOffset.LowPart = 0;
		ErrorLogEntry->DeviceOffset.HighPart = 0;
		ErrorLogEntry->DumpDataSize = (USHORT)RawDataLen;
		ErrorLogEntry->StringOffset =
			(USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + RawDataLen);
		ErrorLogEntry->NumberOfStrings = (ARGUMENT_PRESENT(pInsertionString)) ? 1 : 0;
		ErrorLogEntry->SequenceNumber = 0;

		if (ARGUMENT_PRESENT(RawDataBuf))
		{
			RtlCopyMemory(ErrorLogEntry->DumpData, RawDataBuf, RawDataLen);
		}

		if (ARGUMENT_PRESENT(pInsertionString))
		{
			RtlCopyMemory((PCHAR)ErrorLogEntry->DumpData + RawDataLen,
						  pInsertionString->Buffer,
					      pInsertionString->Length);
		}

		// Write the entry
		IoWriteErrorLogEntry(ErrorLogEntry);
	}

	INTERLOCKED_INCREMENT_LONG( &AfpServerStatistics.stat_Errors );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fdparm.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fdparm.h

Abstract:

	This file defines file-dir parameter handling data structure and prototypes.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#ifndef	_FDPARM_
#define	_FDPARM_


#define	EVENALIGN(n)	(((n) + 1) & ~1)

// Common File and Directory bitmap definitions
#define	FD_BITMAP_ATTR				0x0001
#define	FD_BITMAP_PARENT_DIRID		0x0002
#define	FD_BITMAP_CREATETIME		0x0004
#define	FD_BITMAP_MODIFIEDTIME		0x0008
#define	FD_BITMAP_BACKUPTIME		0x0010
#define	FD_BITMAP_FINDERINFO		0x0020
#define	FD_BITMAP_LONGNAME			0x0040
#define	FD_BITMAP_SHORTNAME			0x0080
#define	FD_BITMAP_PRODOSINFO		0x2000

// File Specific bitmap definitions
#define	FILE_BITMAP_FILENUM			0x0100
#define	FILE_BITMAP_DATALEN			0x0200
#define	FILE_BITMAP_RESCLEN			0x0400
#define	FILE_BITMAP_MASK			0x27FF

// Directory bitmap definitions
#define	DIR_BITMAP_DIRID			FILE_BITMAP_FILENUM
#define	DIR_BITMAP_OFFSPRINGS		FILE_BITMAP_DATALEN
#define	DIR_BITMAP_OWNERID			FILE_BITMAP_RESCLEN
#define	DIR_BITMAP_GROUPID			0x0800
#define	DIR_BITMAP_ACCESSRIGHTS		0x1000
#define	DIR_BITMAP_MASK				0x3FFF

#define	FD_VALID_SET_PARMS			(FD_BITMAP_ATTR			|	\
									 FD_BITMAP_FINDERINFO	|	\
									 FD_BITMAP_PRODOSINFO	|	\
									 FD_BITMAP_CREATETIME	|	\
									 FD_BITMAP_BACKUPTIME	|	\
									 FD_BITMAP_MODIFIEDTIME)

#define	DIR_VALID_SET_PARMS			(FD_VALID_SET_PARMS		|	\
									 DIR_BITMAP_OWNERID		|	\
									 DIR_BITMAP_GROUPID		|	\
									 DIR_BITMAP_ACCESSRIGHTS)

#define	FILE_VALID_SET_PARMS		(FD_VALID_SET_PARMS)

// We have no way of knowing what the ASP buffer size on the client end is,
// from trial and error it appears to be less than 578
#define MAX_CATSEARCH_REPLY			512
// Valid Request (search criteria) bitmaps for AfpCatSearch
#define FD_VALID_SEARCH_CRITERIA	(FD_BITMAP_PARENT_DIRID	|	\
									 FD_BITMAP_CREATETIME	|	\
									 FD_BITMAP_MODIFIEDTIME |	\
									 FD_BITMAP_BACKUPTIME	|	\
									 FD_BITMAP_FINDERINFO	|	\
									 FD_BITMAP_LONGNAME)

#define FILE_VALID_SEARCH_CRITERIA	(FD_VALID_SEARCH_CRITERIA 	|	\
									 FD_BITMAP_ATTR		   		|	\
									 FILE_BITMAP_DATALEN		|	\
									 FILE_BITMAP_RESCLEN)	

#define DIR_VALID_SEARCH_CRITERIA	(FD_VALID_SEARCH_CRITERIA	|	\
									 FD_BITMAP_ATTR				|	\
									 DIR_BITMAP_OFFSPRINGS)

// The only valid information that can be requested as a result of a
// AfpCatSearch is the parent dirid and the longname of the file/dir found.
#define FD_VALID_SEARCH_RESULT		(FD_BITMAP_PARENT_DIRID |	\
									 FD_BITMAP_LONGNAME)

// Common File and Directory attribute definitions
#define	FD_BITMAP_ATTR_INVISIBLE	0x0001
#define	FD_BITMAP_ATTR_SYSTEM		0x0004
#define	FD_BITMAP_ATTR_BACKUPNEED	0x0040
#define	FD_BITMAP_ATTR_RENAMEINH	0x0080
#define	FD_BITMAP_ATTR_DELETEINH	0x0100
#define	FD_BITMAP_ATTR_SET			0x8000

// File specific attribute definitions
#define	FILE_BITMAP_ATTR_MULTIUSER	0x0002
#define	FILE_BITMAP_ATTR_DATAOPEN	0x0008
#define	FILE_BITMAP_ATTR_RESCOPEN	0x0010
#define	FILE_BITMAP_ATTR_WRITEINH	0x0020
#define	FILE_BITMAP_ATTR_COPYPROT	0x0400

#define	FD_VALID_ATTR				(FD_BITMAP_ATTR_SET			|	\
									 FD_BITMAP_ATTR_DELETEINH	|	\
									 FILE_BITMAP_ATTR_WRITEINH	|	\
									 FD_BITMAP_ATTR_RENAMEINH	|	\
									 FD_BITMAP_ATTR_BACKUPNEED	|	\
									 FD_BITMAP_ATTR_INVISIBLE	|	\
									 FD_BITMAP_ATTR_SYSTEM)

// File/Dir Attributes that map onto the NT ReadOnly attribute
#define	FD_BITMAP_ATTR_NT_RO		(FD_BITMAP_ATTR_RENAMEINH	|	\
									 FD_BITMAP_ATTR_DELETEINH	| 	\
									 FILE_BITMAP_ATTR_WRITEINH)

// This is the set of attributes that are part DfeEntry
#define	AFP_FORK_ATTRIBUTES			(FILE_BITMAP_ATTR_DATAOPEN	|	\
									 FILE_BITMAP_ATTR_RESCOPEN)

// Dir Attributes that can only be changed *from their current settings*
// by the owner of the directory
#define DIR_BITMAP_ATTR_CHG_X_OWNER_ONLY (FD_BITMAP_ATTR_RENAMEINH | \
										  FD_BITMAP_ATTR_DELETEINH | \
										  FD_BITMAP_ATTR_INVISIBLE | \
										  FILE_BITMAP_ATTR_WRITEINH)

// These are the OpenAccess bits that encode the FILEIO_ACCESS_XXX values
// into the Bitmap parameter so that the pathmap code can open the file/dir
// (under impersonation) with the appropriate access for each AFP API.
// We also encode the access needed by the AdminDirectory Get/Set apis for
// when admin calls into pathmap.

#define	FD_INTERNAL_BITMAP_SKIP_IMPERSONATION	0x00200000
#define	FD_INTERNAL_BITMAP_OPENFORK_RESC		0x00400000

// Tells pathmap code whether it should return the paths in the
// PATHMAPENTITY structure for APIs which will cause disk changes that will
// cause a change notify to complete.
#define FD_INTERNAL_BITMAP_RETURN_PMEPATHS		0x00800000

// AdminDirectoryGetInfo: FILE_READ_ATTRIBUTES | READ_CONTROL | SYNCHRONIZE
#define FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET	0x01000000	

// AdminDirectorySetInfo: same as ADMINGET plus the following:
// FILE_WRITE_ATTRIBUTES | WRITE_DAC | WRITE_OWNER
#define FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET	0x02000000	

#define FD_INTERNAL_BITMAP_OPENACCESS_READCTRL	0x04000000	//READ_CONTROL+FILEIO_ACCESS_NONE
#define FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL	0x08000000	//READ_CONTROL+WRITE_CONTROL+FILEIO_ACCESS_NONE
#define FD_INTERNAL_BITMAP_OPENACCESS_READ		0x10000000	//FILEIO_ACCESS_READ
#define FD_INTERNAL_BITMAP_OPENACCESS_WRITE		0x20000000	//FILEIO_ACCESS_WRITE
#define FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR	0x40000000	//FILE_WRITE_ATTRIBUTES+FILEIO_ACCESS_NONE
#define FD_INTERNAL_BITMAP_OPENACCESS_DELETE	0x80000000	//FILEIO_ACCESS_DELETE

#define FD_INTERNAL_BITMAP_OPENACCESS_READWRITE ( \
							FD_INTERNAL_BITMAP_OPENACCESS_READ		| \
							FD_INTERNAL_BITMAP_OPENACCESS_WRITE)

#define FD_INTERNAL_BITMAP_OPENACCESS_ALL	( \
							FD_INTERNAL_BITMAP_OPENACCESS_ADMINGET	| \
							FD_INTERNAL_BITMAP_OPENACCESS_ADMINSET	| \
							FD_INTERNAL_BITMAP_OPENACCESS_READCTRL	| \
							FD_INTERNAL_BITMAP_OPENACCESS_RWCTRL	| \
							FD_INTERNAL_BITMAP_OPENACCESS_READ		| \
							FD_INTERNAL_BITMAP_OPENACCESS_WRITE		| \
							FD_INTERNAL_BITMAP_OPENACCESS_RW_ATTR	| \
							FD_INTERNAL_BITMAP_OPENACCESS_DELETE)

// These are the DenyMode bits that encode the FILEIO_DENY_XXX values
// into the Bitmap parameter so that the pathmap code can open the fork
// with the appropriate deny modes when mac is calling FpOpenFork.  Pathmap
// will shift these bits right by FD_INTERNAL_BITMAP_DENYMODE_SHIFT and use
// the value as an index into the AfpDenyModes array to come up with the
// correct deny mode to open the fork with.  Note how these bit values
// correspond to the FORK_DENY_xxx bits in forks.h

#define FD_INTERNAL_BITMAP_DENYMODE_READ		0x00010000	//FILEIO_DENY_READ
#define FD_INTERNAL_BITMAP_DENYMODE_WRITE		0x00020000	//FILEIO_DENY_WRITE

#define FD_INTERNAL_BITMAP_DENYMODE_ALL		( \
							FD_INTERNAL_BITMAP_DENYMODE_READ		| \
							FD_INTERNAL_BITMAP_DENYMODE_WRITE)

// Number of bits to shift right in order to get the correct index into the
// AfpDenyModes array
#define FD_INTERNAL_BITMAP_DENYMODE_SHIFT	16


// This gets returned as part of GetFileDirParms
#define	FILEDIR_FLAG_DIR			0x80
#define	FILEDIR_FLAG_FILE			0x00

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights
#define	OWNER_BITS_ALL				0x00808080
											// Mask used to clear owner bit for
											// Owner/Group/World. We are only
											// required to report this bit for
											// 'ThisUser'

#define	DIR_ACCESS_ALL				(DIR_ACCESS_READ	| \
									 DIR_ACCESS_SEARCH	| \
									 DIR_ACCESS_WRITE)

#define	OWNER_RIGHTS_SHIFT			0
#define	GROUP_RIGHTS_SHIFT			8
#define	WORLD_RIGHTS_SHIFT			16
#define	USER_RIGHTS_SHIFT			24

typedef	struct _FileDirParms
{
	DWORD		_fdp_AfpId;
	DWORD		_fdp_ParentId;
	DWORD		_fdp_Flags;				// one of DFE_FLAGS_DFBITS
	USHORT		_fdp_Attr;
	USHORT		_fdp_EffectiveAttr;		// After any additions/subtractions
	AFPTIME		_fdp_CreateTime;
	AFPTIME		_fdp_ModifiedTime;
	AFPTIME		_fdp_BackupTime;

	union
	{
	  struct
	  {
		 DWORD	_fdp_DataForkLen;
		 DWORD	_fdp_RescForkLen;
	  };
	  struct
	  {
		 DWORD	_fdp_FileCount;
		 DWORD	_fdp_DirCount;
		 DWORD	_fdp_OwnerId;
		 DWORD	_fdp_GroupId;
	  };
	};

	FINDERINFO	_fdp_FinderInfo;
	ANSI_STRING	_fdp_LongName;			// Name of the entity (Not fully qualified)
	ANSI_STRING	_fdp_ShortName;
	PRODOSINFO	_fdp_ProDosInfo;

	BOOLEAN		_fdp_UserIsMemberOfDirGroup;
	BOOLEAN		_fdp_UserIsOwner;

	union
	{
	  struct
	  {
	  	BYTE	_fdp_OwnerRights;		// The Rights bytes must be in the order
	  	BYTE	_fdp_GroupRights;   	// of Owner,Group,World,User
	  	BYTE	_fdp_WorldRights;
	  	BYTE	_fdp_UserRights;
	  };
	  DWORD		_fdp_Rights;			// All rights accessed as a single entity
	};

	BOOLEAN		_fdp_fPartialName;		// For FpCatSearch partial name flag

	BYTE		_fdp_LongNameBuf [AFP_LONGNAME_LEN+1];
	BYTE		_fdp_ShortNameBuf[AFP_SHORTNAME_LEN+1];
} FILEDIRPARM, *PFILEDIRPARM;

#define	IsDir(pFDParm)	(BOOLEAN)(((pFDParm)->_fdp_Flags & DFE_FLAGS_DIR) == DFE_FLAGS_DIR)
#define	AfpInitializeFDParms(pFDParms)	\
			(pFDParms)->_fdp_LongName.MaximumLength = AFP_LONGNAME_LEN+1;	\
			(pFDParms)->_fdp_LongName.Length = 0;							\
			(pFDParms)->_fdp_LongName.Buffer = (pFDParms)->_fdp_LongNameBuf;\
			(pFDParms)->_fdp_ShortName.MaximumLength = AFP_SHORTNAME_LEN+1;	\
			(pFDParms)->_fdp_ShortName.Length = 0;							\
			(pFDParms)->_fdp_ShortName.Buffer = (pFDParms)->_fdp_ShortNameBuf;

extern
USHORT
AfpGetFileDirParmsReplyLength(
	IN	PFILEDIRPARM			pFDParm,
	IN	DWORD					Bitmap
);

extern
VOID
AfpPackFileDirParms(
	IN	PFILEDIRPARM			pFileDirParm,
	IN	DWORD					Bitmap,
	OUT	PBYTE					pBuffer
);

extern
AFPSTATUS
AfpUnpackFileDirParms(
	IN	PBYTE					pBuffer,
	IN	LONG					Length,
	IN	PDWORD					pBitmap,
	OUT	PFILEDIRPARM			pFileDirParm
);

extern
AFPSTATUS
AfpSetFileDirParms(
	IN	PVOLDESC				pVolDesc,
	IN	struct _PathMapEntity *	pPME,
	IN	DWORD					Bitmap,
	IN	PFILEDIRPARM			pFDParm
);

extern
USHORT
AfpConvertNTAttrToAfpAttr(
	IN	DWORD					Attr
);

extern
DWORD
AfpConvertAfpAttrToNTAttr(
	IN	USHORT					Attr
);

extern
VOID
AfpNormalizeAfpAttr(
	IN OUT	PFILEDIRPARM		pFDParm,
	IN		DWORD				NtAttr
);

extern
DWORD
AfpMapFDBitmapOpenAccess(
	IN	DWORD	Bitmap,
	IN	BOOLEAN IsDir
);

extern
AFPSTATUS
AfpQuerySecurityIdsAndRights(
	IN	PSDA					pSda,
	IN	PFILESYSHANDLE			FSHandle,
	IN	DWORD					Bitmap,
	IN OUT PFILEDIRPARM			pFDParm
);

extern
AFPSTATUS	
AfpCheckForInhibit(
	IN	PFILESYSHANDLE			hData,
	IN	DWORD					InhibitBit,
	IN	DWORD					AfpAttr,
	OUT PDWORD					pNTAttr
);

extern
AFPSTATUS
AfpUnpackCatSearchSpecs(
	IN	PBYTE					pBuffer,		// Pointer to beginning of Spec data
	IN	USHORT					BufLength,		// Length of Spec1 + Spec2 data
	IN	DWORD					Bitmap,
	OUT	PFILEDIRPARM			pFDParm1,
	OUT PFILEDIRPARM			pFDParm2,
	OUT PUNICODE_STRING			pMatchString
);

extern
SHORT
AfpIsCatSearchMatch(
	IN	PDFENTRY				pDFE,
	IN	DWORD					Bitmap,			// Search criteria
	IN	DWORD					ReplyBitmap,	// Info to return
	IN	PFILEDIRPARM			pFDParm1,
	IN	PFILEDIRPARM			pFDParm2,
	IN	PUNICODE_STRING			pMatchName OPTIONAL	
);


#endif	// _FDPARM


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fileio.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fileio.c

Abstract:

	This module contains the routines for performing file system functions.
	No other part of the server should be calling filesystem NtXXX routines
	directly

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	18 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILEIO_LOCALS
#define	FILENUM	FILE_FILEIO

#include <afp.h>
#include <client.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpFileIoInit)
#pragma alloc_text( PAGE, AfpIoOpen)
#pragma alloc_text( PAGE, AfpIoCreate)
#pragma alloc_text( PAGE, AfpIoRead)
#pragma alloc_text( PAGE, AfpIoWrite)
#pragma alloc_text( PAGE, AfpIoQuerySize)
#pragma alloc_text( PAGE, AfpIoSetSize)
#pragma alloc_text( PAGE, AfpIoChangeNTModTime)
#pragma alloc_text( PAGE, AfpIoQueryTimesnAttr)
#pragma alloc_text( PAGE, AfpIoSetTimesnAttr)
#pragma alloc_text( PAGE, AfpIoQueryLongName)
#pragma alloc_text( PAGE, AfpIoQueryShortName)
#pragma alloc_text( PAGE, AfpIoQueryStreams)
#pragma alloc_text( PAGE, AfpIoMarkFileForDelete)
#pragma alloc_text( PAGE, AfpIoQueryDirectoryFile)
#pragma alloc_text( PAGE, AfpIoQueryBasicInfo)
#pragma alloc_text( PAGE, AfpIoClose)
#pragma alloc_text( PAGE, AfpIoQueryVolumeSize)
#pragma alloc_text( PAGE, AfpIoMoveAndOrRename)
#pragma alloc_text( PAGE, AfpIoCopyFile1)
#pragma alloc_text( PAGE, AfpIoCopyFile2)
#pragma alloc_text( PAGE, AfpIoWait)
#pragma alloc_text( PAGE, AfpIoConvertNTStatusToAfpStatus)
#pragma alloc_text( PAGE, AfpQueryPath)
#pragma alloc_text( PAGE, AfpIoIsSupportedDevice)
#endif

/***	AfpFileIoInit
 *
 *	Initialize various strings that we use for stream names etc.
 */
NTSTATUS
AfpFileIoInit(
	VOID
)
{

	// NTFS Stream names
	RtlInitUnicodeString(&AfpIdDbStream, AFP_IDDB_STREAM);
	RtlInitUnicodeString(&AfpDesktopStream, AFP_DT_STREAM);
	RtlInitUnicodeString(&AfpResourceStream, AFP_RESC_STREAM);
	RtlInitUnicodeString(&AfpInfoStream, AFP_INFO_STREAM);
	RtlInitUnicodeString(&AfpCommentStream, AFP_COMM_STREAM);
	RtlInitUnicodeString(&AfpDataStream, L"");

	// Directory enumeration names to ignore
	RtlInitUnicodeString(&Dot,L".");
	RtlInitUnicodeString(&DotDot,L"..");

	// Supported file systems
	RtlInitUnicodeString(&afpNTFSName, AFP_NTFS);
	RtlInitUnicodeString(&afpCDFSName, AFP_CDFS);
	RtlInitUnicodeString(&afpAHFSName, AFP_AHFS);

	// Prepended to full path names originating at drive letter
	RtlInitUnicodeString(&DosDevices, AFP_DOSDEVICES);

	// CopyFile stream not to create
	RtlInitUnicodeString(&DataStreamName, FULL_DATA_STREAM_NAME);

	RtlInitUnicodeString(&FullCommentStreamName, FULL_COMMENT_STREAM_NAME);
	RtlInitUnicodeString(&FullResourceStreamName, FULL_RESOURCE_STREAM_NAME);
	RtlInitUnicodeString(&FullInfoStreamName, FULL_INFO_STREAM_NAME);

	// ExchangeFiles temporary filename
	RtlInitUnicodeString(&AfpExchangeName, AFP_TEMP_EXCHANGE_NAME);


	return STATUS_SUCCESS;
}


/***	AfpIoOpen
 *
 *	Perform a file/stream open. The stream is specified by a manifest rather
 *	than a name.  The entity can only be opened by name (Not by ID).
 *	If a stream other than the DATA stream is to be opened, then
 *	the phRelative handle MUST be that of the unnamed (that is, DATA) stream
 *	of the file/dir	itself.
 */
NTSTATUS
AfpIoOpen(
	IN	PFILESYSHANDLE	phRelative				OPTIONAL,
	IN	DWORD			StreamId,
	IN	DWORD			OpenOptions,
	IN	PUNICODE_STRING	pObject,
	IN	DWORD			AfpAccess,				// FILEIO_ACCESS_XXX desired access
	IN	DWORD			AfpDenyMode,			// FILIEO_DENY_XXX
	IN	BOOLEAN			CheckAccess,
	OUT	PFILESYSHANDLE	pNewHandle
)
{
	OBJECT_ATTRIBUTES	ObjAttr;
	IO_STATUS_BLOCK		IoStsBlk;
	NTSTATUS			Status;
	NTSTATUS			Status2;
	UNICODE_STRING		UName;
	HANDLE				hRelative = NULL;
	BOOLEAN				FreeBuf = False;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoOpen entered\n"));

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

#if DBG
	pNewHandle->Signature = FSH_SIGNATURE;
#endif

	// Assume Failure
	pNewHandle->fsh_FileHandle = NULL;

	if (phRelative != NULL)
	{
		ASSERT(VALID_FSH(phRelative));
		hRelative = phRelative->fsh_FileHandle;
	}


	ASSERT (StreamId < AFP_STREAM_MAX);
	ASSERT ((pObject->Length > 0) || (phRelative != NULL));

	if (StreamId != AFP_STREAM_DATA)
	{
		if (pObject->Length > 0)
		{
			UName.Length =
			UName.MaximumLength = pObject->Length + AFP_MAX_STREAMNAME*sizeof(WCHAR);
			UName.Buffer = (LPWSTR)AfpAllocNonPagedMemory(UName.Length);
			if (UName.Buffer == NULL)
			{
				return STATUS_NO_MEMORY;
			}
			AfpCopyUnicodeString(&UName, pObject);
			RtlAppendUnicodeStringToString(&UName, &AfpStreams[StreamId]);
			pObject = &UName;
			FreeBuf = True;
		}
		else
		{
			pObject = &AfpStreams[StreamId];
		}
	}

	InitializeObjectAttributes(&ObjAttr,
								pObject,
								OBJ_CASE_INSENSITIVE,
								hRelative,
								NULL);		// no security descriptor

	ObjAttr.SecurityQualityOfService = &AfpSecurityQOS;

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
								("AfpIoOpen: about to call NtOpenFile\n"));

	// If we are opening for RWCTRL, then specify to use privilege.
	if (AfpAccess & (WRITE_DAC | WRITE_OWNER))
	{
		OpenOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
	}

	Status = IoCreateFile(&pNewHandle->fsh_FileHandle,
						  AfpAccess,
						  &ObjAttr,
						  &IoStsBlk,
						  NULL,
						  0,
						  AfpDenyMode,
						  FILE_OPEN,
						  OpenOptions,
						  (PVOID)NULL,
						  0L,
						  CreateFileTypeNone,
						  (PVOID)NULL,
						  CheckAccess ? IO_FORCE_ACCESS_CHECK : 0);

	if (Status != 0)
		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoOpen: IoCreateFile returned 0x%lx, %Z\n",Status,
			 ObjAttr.ObjectName));

	if (FreeBuf)
		AfpFreeMemory(UName.Buffer);

	if (NT_SUCCESS(Status))
	{
		Status = ObReferenceObjectByHandle(pNewHandle->fsh_FileHandle,
										   AfpAccess,
										   NULL,
										   KernelMode,
										   (PVOID *)(&pNewHandle->fsh_FileObject),
										   NULL);

		if (!NT_SUCCESS(Status)) {
			ASSERT(VALID_FSH((PFILESYSHANDLE)&pNewHandle->fsh_FileHandle)) ;
	
			Status2 = NtClose(pNewHandle->fsh_FileHandle);
			pNewHandle->fsh_FileHandle = NULL;

			ASSERT(NT_SUCCESS(Status2));
		}
		else
		{
		pNewHandle->fsh_DeviceObject = IoGetRelatedDeviceObject(pNewHandle->fsh_FileObject);
		(ULONG_PTR)(pNewHandle->fsh_FileObject) |= 1;
		ASSERT(NT_SUCCESS(Status));
		afpUpdateOpenFiles(True, True);

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);

		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		if (OpenOptions == FILEIO_OPEN_DIR)
		{
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountDR);
			INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeDR,
									 TimeD,
									 &AfpStatisticsLock);
		}
		else
		{
			if ((AfpAccess & FILEIO_ACCESS_DELETE) == FILEIO_ACCESS_DELETE)
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountDL);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeDL,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else if (((AfpAccess & FILEIO_ACCESS_READWRITE) == FILEIO_ACCESS_READ) ||
					 ((AfpAccess & FILEIO_ACCESS_READWRITE) == FILEIO_ACCESS_WRITE) ||
					 ((AfpAccess & FILEIO_ACCESS_READWRITE) == FILEIO_ACCESS_READWRITE))
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountRW);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeRW,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else if (AfpAccess & (WRITE_DAC | WRITE_OWNER))
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_OpenCountWC);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeWC,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else if (AfpAccess & READ_CONTROL)
			{
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_OpenCountRC);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeRC,
										 TimeD,
										 &AfpStatisticsLock);
			}
			else	// Ought to be read-attributes or write-attributes
			{
				ASSERT ((AfpAccess == FILEIO_ACCESS_NONE) ||
						(AfpAccess == (FILEIO_ACCESS_NONE | FILE_WRITE_ATTRIBUTES)));
				INTERLOCKED_INCREMENT_LONG( &AfpServerProfile->perf_OpenCountRA);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_OpenTimeRA,
										 TimeD,
										 &AfpStatisticsLock);
			}
		}
#endif
		}
	}

	return Status;
}


/***	AfpIoCreate
 *
 *	Perform a file/stream create. The stream is specified by a manifest rather
 *	than a name.  If a stream other than the DATA stream is to be created, then
 *	the phRelative handle MUST be that of either the Parent directory, or the
 *	unnamed (that is, DATA) stream of the file/dir itself because we only use
 *	a buffer large enough for a AFP filename plus the maximum stream name
 *	length.
 */
NTSTATUS
AfpIoCreate(
	IN	PFILESYSHANDLE		phRelative,				// create relative to this
	IN	DWORD				StreamId,				// Id of stream to create
	IN	PUNICODE_STRING		pObject,				// Name of file
	IN	DWORD				AfpAccess,				// FILEIO_ACCESS_XXX desired access
	IN	DWORD				AfpDenyMode,			// FILEIO_DENY_XXX
	IN	DWORD				CreateOptions,			// File/Directory etc.
	IN	DWORD				Disposition,			// Soft or hard create
	IN	DWORD				Attributes,				// hidden, archive, normal, etc.
	IN	BOOLEAN				CheckAccess,    		// If TRUE, enforce security
	IN	PSECURITY_DESCRIPTOR pSecDesc			OPTIONAL, // Security descriptor to slap on
	OUT	PFILESYSHANDLE		pNewHandle,				// Place holder for the handle
	OUT	PDWORD				pInformation		OPTIONAL, // file opened, created, etc.
	IN  PVOLDESC			pVolDesc			OPTIONAL, // only if NotifyPath
	IN  PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN  PUNICODE_STRING		pNotifyParentPath	OPTIONAL
)
{
	NTSTATUS			Status;
	NTSTATUS			Status2;
	OBJECT_ATTRIBUTES	ObjAttr;
	UNICODE_STRING		RealName;
	IO_STATUS_BLOCK		IoStsBlk;
	HANDLE				hRelative;
	WCHAR				NameBuffer[AFP_FILENAME_LEN + 1 + AFP_MAX_STREAMNAME];
	BOOLEAN				Queue = False;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif


	PAGED_CODE( );

	ASSERT(pObject != NULL && phRelative != NULL && StreamId < AFP_STREAM_MAX);

	ASSERT(VALID_FSH(phRelative) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

#if DBG
	pNewHandle->Signature = FSH_SIGNATURE;
#endif
	hRelative = phRelative->fsh_FileHandle;

	// Assume Failure
	pNewHandle->fsh_FileHandle = NULL;

	if (StreamId != AFP_STREAM_DATA)
	{
		ASSERT(pObject->Length <= (AFP_FILENAME_LEN*sizeof(WCHAR)));

		// Construct the name to pass to NtCreateFile
		AfpSetEmptyUnicodeString(&RealName, sizeof(NameBuffer), NameBuffer);
		AfpCopyUnicodeString(&RealName, pObject);
		RtlAppendUnicodeStringToString(&RealName, &AfpStreams[StreamId]);
		pObject = &RealName;
	}

	InitializeObjectAttributes(&ObjAttr,
							   pObject,
							   OBJ_CASE_INSENSITIVE,
							   hRelative,
							   pSecDesc);

	ObjAttr.SecurityQualityOfService = &AfpSecurityQOS;

	// Do not queue our changes for exclusive volumes since no notifies are posted
	if (ARGUMENT_PRESENT(pNotifyPath)	&&
		!EXCLUSIVE_VOLUME(pVolDesc)		&&
		(StreamId == AFP_STREAM_DATA))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));
		ASSERT((Disposition == FILEIO_CREATE_HARD) ||
			   (Disposition == FILEIO_CREATE_SOFT));
		Queue = True;

		// Queue a change for both cases.
		AfpQueueOurChange(pVolDesc,
						  FILE_ACTION_ADDED,
						  pNotifyPath,
						  pNotifyParentPath);
		AfpQueueOurChange(pVolDesc,
						  FILE_ACTION_MODIFIED,
						  pNotifyPath,
						  NULL);
	}

	Status = IoCreateFile(&pNewHandle->fsh_FileHandle,
						  AfpAccess,
						  &ObjAttr,
						  &IoStsBlk,
						  NULL,
						  Attributes,
						  AfpDenyMode,
						  Disposition,
						  CreateOptions,
						  NULL,
						  0,
						  CreateFileTypeNone,
						  (PVOID)NULL,
						  CheckAccess ? IO_FORCE_ACCESS_CHECK : 0);

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoCreate: IoCreateFile returned 0x%lx\n", Status) );

	if (Queue)
	{
		if (NT_SUCCESS(Status))
		{
			ASSERT((IoStsBlk.Information == FILE_CREATED) ||
				   (IoStsBlk.Information == FILE_SUPERSEDED));

			// Dequeue the extra change that was queued
			AfpDequeueOurChange(pVolDesc,
								(IoStsBlk.Information == FILE_CREATED) ?
								FILE_ACTION_MODIFIED : FILE_ACTION_ADDED,
								pNotifyPath,
								NULL);
		}
		else
		{
			AfpDequeueOurChange(pVolDesc,
								FILE_ACTION_ADDED,
								pNotifyPath,
								pNotifyParentPath);
			AfpDequeueOurChange(pVolDesc,
								FILE_ACTION_MODIFIED,
								pNotifyPath,
								NULL);
		}
	}

	if (NT_SUCCESS(Status))
	{
		if (ARGUMENT_PRESENT(pInformation))
		{
			*pInformation = (ULONG)(IoStsBlk.Information);
		}

		Status = ObReferenceObjectByHandle(pNewHandle->fsh_FileHandle,
										   AfpAccess,
										   NULL,
										   KernelMode,
										   (PVOID *)(&pNewHandle->fsh_FileObject),
										   NULL);
		if (!NT_SUCCESS(Status)) 
		{
			ASSERT(VALID_FSH((PFILESYSHANDLE)&pNewHandle->fsh_FileHandle)) ;
	
			Status2 = NtClose(pNewHandle->fsh_FileHandle);
			pNewHandle->fsh_FileHandle = NULL;

			ASSERT(NT_SUCCESS(Status2));
		}
		else
		{
		ASSERT(NT_SUCCESS(Status));

		pNewHandle->fsh_DeviceObject = IoGetRelatedDeviceObject(pNewHandle->fsh_FileObject);
		(ULONG_PTR)(pNewHandle->fsh_FileObject) |= 1;
		afpUpdateOpenFiles(True, True);

#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);

		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
		if (StreamId == AFP_STREAM_DATA)
		{
			if (CreateOptions == FILEIO_OPEN_FILE)
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CreateCountFIL);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CreateTimeFIL,
											 TimeD,
											 &AfpStatisticsLock);
			}
			else
			{
				INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CreateCountDIR);
				INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CreateTimeDIR,
											 TimeD,
											 &AfpStatisticsLock);
			}
		}
		else
		{
			INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CreateCountSTR);
			INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CreateTimeSTR,
										 TimeD,
										 &AfpStatisticsLock);
		}
#endif
		}
	}

	return Status;
}



/***	AfpIoRead
 *
 *	Perform file read. Just a wrapper over NtReadFile.
 */
AFPSTATUS
AfpIoRead(
	IN	PFILESYSHANDLE	pFileHandle,
	IN	PFORKOFFST		pForkOffset,
	IN	LONG			SizeReq,
	OUT	PLONG			pSizeRead,
	OUT	PBYTE			pBuffer
)
{
	NTSTATUS		Status;
	DWORD			Key = 0;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoRead Entered, Size %lx, Key %lx\n",
			SizeReq, Key));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() == LOW_LEVEL));

	ASSERT (INTERNAL_HANDLE(pFileHandle));

	*pSizeRead = 0;
	Status = NtReadFile(pFileHandle->fsh_FileHandle,
						NULL,
						NULL,
						NULL,
						&IoStsBlk,
						pBuffer,
						(DWORD)SizeReq,
						pForkOffset,
						&Key);

	if (NT_SUCCESS(Status))
	{
		*pSizeRead = (LONG)IoStsBlk.Information;
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataReadInternal,
								   (ULONG)(IoStsBlk.Information),
								   &AfpStatisticsLock);
	}
	else
	{
		if (Status == STATUS_FILE_LOCK_CONFLICT)
			Status = AFP_ERR_LOCK;
		else if (Status == STATUS_END_OF_FILE)
			Status = AFP_ERR_EOF;
		else
		{
			AFPLOG_HERROR(AFPSRVMSG_CANT_READ,
						  Status,
						  NULL,
						  0,
						  pFileHandle->fsh_FileHandle);

			Status = AFP_ERR_MISC;
		}
	}
	return Status;
}


/***	AfpIoWrite
 *
 *	Perform file write. Just a wrapper over NtWriteFile.
 */
AFPSTATUS
AfpIoWrite(
	IN	PFILESYSHANDLE	pFileHandle,
	IN	PFORKOFFST		pForkOffset,
	IN	LONG			SizeWrite,
	OUT	PBYTE			pBuffer
)
{
	NTSTATUS		Status;
	DWORD			Key = 0;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoWrite Entered, Size %lx, Key %lx\n",
			SizeWrite, Key));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() == LOW_LEVEL));

	ASSERT (INTERNAL_HANDLE(pFileHandle));

	Status = NtWriteFile(pFileHandle->fsh_FileHandle,
						 NULL,
						 NULL,
						 NULL,
						 &IoStsBlk,
						 pBuffer,
						 (DWORD)SizeWrite,
						 pForkOffset,
						 &Key);

	if (NT_SUCCESS(Status))
	{
		INTERLOCKED_ADD_STATISTICS(&AfpServerStatistics.stat_DataWrittenInternal,
								   SizeWrite,
								   &AfpStatisticsLock);
	}

	else
	{
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
		    ("AfpIoWrite: NtWriteFile returned 0x%lx\n",Status));

		if (Status == STATUS_FILE_LOCK_CONFLICT)
			Status = AFP_ERR_LOCK;
		else
		{
			AFPLOG_HERROR(AFPSRVMSG_CANT_WRITE,
						  Status,
						  NULL,
						  0,
						  pFileHandle->fsh_FileHandle);
			Status = AfpIoConvertNTStatusToAfpStatus(Status);
		}
	}
	return Status;
}


/***	AfpIoQuerySize
 *
 *	Get the current size of the fork.
 */
AFPSTATUS FASTCALL
AfpIoQuerySize(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PFORKSIZE			pForkLength
)
{
	FILE_STANDARD_INFORMATION		FStdInfo;
	NTSTATUS						Status;
	IO_STATUS_BLOCK					IoStsBlk;
	PFAST_IO_DISPATCH				fastIoDispatch;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryStandardInfo &&
		fastIoDispatch->FastIoQueryStandardInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
												True,
												&FStdInfo,
												&IoStsBlk,
												pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;

#ifdef	PROFILING
		// The fast I/O path worked. Update statistics
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif

	}
	else
	{

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										&FStdInfo,
										sizeof(FStdInfo),
										FileStandardInformation);

	}

	if (!NT_SUCCESS((NTSTATUS)Status))
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_FILESIZE,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		return AFP_ERR_MISC;	// What else can we do
	}
	*pForkLength = FStdInfo.EndOfFile;
	return AFP_ERR_NONE;
}


/***	AfpIoSetSize
 *
 *	Set the size of the open fork to the value specified.
 *
 *	ISSUE:
 *	We can check the locks and resolve any lock conflicts before we go
 *	to the filesystem. The issue that needs to be resolved here is:
 *	Is it OK to truncate the file such that our own locks cause
 *	conflict ?
 */
AFPSTATUS FASTCALL
AfpIoSetSize(
	IN	PFILESYSHANDLE		pFileHandle,
	IN	LONG				ForkLength
)
{
	NTSTATUS						Status;
	FILE_END_OF_FILE_INFORMATION	FEofInfo;
	IO_STATUS_BLOCK					IoStsBlk;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	FEofInfo.EndOfFile.QuadPart = ForkLength;
	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  &FEofInfo,
								  sizeof(FEofInfo),
								  FileEndOfFileInformation);

	if (!NT_SUCCESS(Status))
	{
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
		    ("AfpIoSetSize: NtSetInformationFile returned 0x%lx\n",Status));

		if (Status != STATUS_FILE_LOCK_CONFLICT)
			AFPLOG_HERROR(AFPSRVMSG_CANT_SET_FILESIZE,
						  Status,
						  &ForkLength,
						  sizeof(ForkLength),
						  pFileHandle->fsh_FileHandle);

		if (Status == STATUS_DISK_FULL)
        {
	        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,("AfpIoSetSize: DISK_FULL error\n"));
            ASSERT(0);
			Status = AFP_ERR_DISK_FULL;
        }

		else if (Status == STATUS_FILE_LOCK_CONFLICT)
			Status = AFP_ERR_LOCK;
		// Default error code. What else can it be ?
		else Status = AFP_ERR_MISC;
	}

	return Status;
}

/***	AfpIoChangeNTModTime
 *
 *	Get the NTFS ChangeTime of a file/dir.  If it is larger than the
 *  NTFS LastWriteTime, set NTFS LastWriteTime to this time.
 *  Return the resultant LastWriteTime in pModTime (whether changed or not).
 *  This is used to update the modified time when the resource fork is changed
 *  or when some other attribute changes that should cause the timestamp on
 *  the file to change as viewed by mac.
 *
 */
AFPSTATUS
AfpIoChangeNTModTime(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PTIME				pModTime
)
{
	FILE_BASIC_INFORMATION	FBasicInfo;
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() == LOW_LEVEL));


	// Set all times/attr to Zero (this will cause NTFS to update LastModTime
    // if there are any writes pending)

    RtlZeroMemory(&FBasicInfo, sizeof(FBasicInfo));

	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  (PVOID)&FBasicInfo,
								  sizeof(FBasicInfo),
								  FileBasicInformation);

    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoChangeNTModTime: NtSetInformationFile failed with 0x%lx\n",Status));

		AFPLOG_HERROR(AFPSRVMSG_CANT_SET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);

		return AFP_ERR_MISC;
    }

    // now, go and query for the updated times

    Status = AfpIoQueryTimesnAttr( pFileHandle,
                                   NULL,
                                   pModTime,
                                   NULL );
    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoChangeNTModTime: AfpIoQueryTimesnAttr returned 0x%lx\n",Status));
    }

	return Status;
}

/***	AfpIoQueryTimesnAttr
 *
 *	Get the times associated with the file.
 */
AFPSTATUS
AfpIoQueryTimesnAttr(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PDWORD				pCreatTime	OPTIONAL,
	OUT	PTIME				pModTime	OPTIONAL,
	OUT	PDWORD				pAttr		OPTIONAL
)
{
	FILE_BASIC_INFORMATION	FBasicInfo;
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;

#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	// Atleast something should be queried.
	ASSERT((pCreatTime != NULL) || (pModTime != NULL) || (pAttr != NULL));

	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryBasicInfo &&
		fastIoDispatch->FastIoQueryBasicInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
											 True,
											 &FBasicInfo,
											 &IoStsBlk,
											 pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;

#ifdef	PROFILING
		// The fast I/O path worked. Update statistics
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif

	}
	else
	{

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
							&IoStsBlk, &FBasicInfo, sizeof(FBasicInfo),
							FileBasicInformation);
	}

	if (NT_SUCCESS((NTSTATUS)Status))
	{
		if (pModTime != NULL)
			*pModTime = FBasicInfo.LastWriteTime;
		if (pCreatTime != NULL)
			*pCreatTime = AfpConvertTimeToMacFormat(&FBasicInfo.CreationTime);
		if (pAttr != NULL)
			*pAttr = FBasicInfo.FileAttributes;
#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_GetInfoCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_GetInfoTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	}
	else
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		Status = AFP_ERR_MISC;	// What else can we do
	}

	return Status;
}

/***	AfpIoSetTimesnAttr
 *
 *	Set the times and attributes associated with the file.
 */
AFPSTATUS
AfpIoSetTimesnAttr(
	IN PFILESYSHANDLE		pFileHandle,
	IN AFPTIME		*		pCreateTime	OPTIONAL,
	IN AFPTIME		*		pModTime	OPTIONAL,
	IN DWORD				AttrSet,
	IN DWORD				AttrClear,
	IN PVOLDESC				pVolDesc	OPTIONAL,	// only if NotifyPath
	IN PUNICODE_STRING		pNotifyPath	OPTIONAL
)
{
	NTSTATUS				Status;
	FILE_BASIC_INFORMATION	FBasicInfo;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;
	BOOLEAN					Queue = False;
#ifdef	PROFILING
	TIME					TimeS, TimeE, TimeD;
#endif

	PAGED_CODE( );

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeS);
#endif

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
									("AfpIoSetTimesnAttr entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	// At least something should be set
	ASSERT((pCreateTime != NULL) || (pModTime != NULL) || (AttrSet != 0) || (AttrClear != 0));

	// First query the information
	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryBasicInfo &&
		fastIoDispatch->FastIoQueryBasicInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
											 True,
											 &FBasicInfo,
											 &IoStsBlk,
											 pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;

#ifdef	PROFILING
		// The fast I/O path worked. Update statistics
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoSucceeded));
#endif

	}
	else
	{

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG((PLONG)(&AfpServerProfile->perf_NumFastIoFailed));
#endif

		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										&FBasicInfo,
										sizeof(FBasicInfo),
										FileBasicInformation);
	}

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoSetTimesnAttr: NtQueryInformationFile returned 0x%lx\n",Status));

	if (!NT_SUCCESS((NTSTATUS)Status))
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		return AFP_ERR_MISC;	// What else can we do
	}

	// Set all times to Zero. This will not change it. Then set the times that are to
	// change
	FBasicInfo.CreationTime = LIZero;
	FBasicInfo.ChangeTime = LIZero;
	FBasicInfo.LastWriteTime = LIZero;
	FBasicInfo.LastAccessTime = LIZero;

	if (pCreateTime != NULL)
		AfpConvertTimeFromMacFormat(*pCreateTime, &FBasicInfo.CreationTime);

	if (pModTime != NULL)
	{
		AfpConvertTimeFromMacFormat(*pModTime, &FBasicInfo.LastWriteTime);
		FBasicInfo.ChangeTime = FBasicInfo.LastWriteTime;
	}

	// NTFS is not returning FILE_ATTRIBUTE_NORMAL if it is a file,
	// therefore we may end up trying to set attributes of 0 when we
	// want to clear all attributes. 0 is taken to mean you do not want
	// to set any attributes, so it is ignored all together by NTFS.  In
	// this case, just tack on the normal bit so that our request is not
	// ignored.

	if (!(FBasicInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		FBasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	FBasicInfo.FileAttributes |= AttrSet;
	FBasicInfo.FileAttributes &= ~AttrClear;

	// Do not queue our changes for exclusive volumes since no notifies are posted
	if (ARGUMENT_PRESENT(pNotifyPath) &&
		!EXCLUSIVE_VOLUME(pVolDesc))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));
		Queue = True;
		AfpQueueOurChange(pVolDesc,
						  FILE_ACTION_MODIFIED,
						  pNotifyPath,
						  NULL);
	}

	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  (PVOID)&FBasicInfo,
								  sizeof(FBasicInfo),
								  FileBasicInformation);

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoSetTimesnAttr: NtSetInformationFile returned 0x%lx\n",Status));


	if (!NT_SUCCESS(Status))
	{
		if (Queue)
		{
			AfpDequeueOurChange(pVolDesc,
								FILE_ACTION_MODIFIED,
								pNotifyPath,
								NULL);
		}

		AFPLOG_HERROR(AFPSRVMSG_CANT_SET_TIMESNATTR,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
		return AFP_ERR_MISC;
	}
	else
	{
#ifdef	PROFILING
		AfpGetPerfCounter(&TimeE);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

		INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_SetInfoCount);
		INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_SetInfoTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	}

	return AFP_ERR_NONE;

}


/***	AfpIoRestoreTimeStamp
 *
 *	When we don't want to change the modification timestamp, we call this function
 *  in 2 steps: first time, it queries the original Mod time; second time, it sets it
 */
AFPSTATUS
AfpIoRestoreTimeStamp(
	IN PFILESYSHANDLE		pFileHandle,
    IN OUT PTIME            pOriginalModTime,
    IN DWORD                dwFlag
)
{
    NTSTATUS                Status;
    DWORD                   NTAttr = 0;
	FILE_BASIC_INFORMATION	FBasicInfo;
	IO_STATUS_BLOCK			IoStsBlk;
	PFAST_IO_DISPATCH		fastIoDispatch;


    // if we are asked to retrieve the original timestamp, do that and return
    if (dwFlag == AFP_RETRIEVE_MODTIME)
    {
        Status = AfpIoQueryTimesnAttr(pFileHandle, NULL, pOriginalModTime, &NTAttr);
        return(Status);
    }

    //
    // we've been asked to restore the timestamp: let's do that!
    //

    ASSERT(dwFlag == AFP_RESTORE_MODTIME);

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

    // this will cause file system to flush any timestamps
    RtlZeroMemory(&FBasicInfo, sizeof(FBasicInfo));

    Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
                                  &IoStsBlk,
                                  (PVOID)&FBasicInfo,
                                  sizeof(FBasicInfo),
                                  FileBasicInformation);

    if (!NT_SUCCESS(Status))
    {
        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
            ("AfpIoRestoreTimeStamp: NtSetInformationFile failed with 0x%lx\n",Status));
    }

	// First query the information
	fastIoDispatch = pFileHandle->fsh_DeviceObject->DriverObject->FastIoDispatch;

	if (fastIoDispatch &&
		fastIoDispatch->FastIoQueryBasicInfo &&
		fastIoDispatch->FastIoQueryBasicInfo(AfpGetRealFileObject(pFileHandle->fsh_FileObject),
											 True,
											 &FBasicInfo,
											 &IoStsBlk,
											 pFileHandle->fsh_DeviceObject))
	{
		Status = IoStsBlk.Status;
	}
	else
	{
		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										&FBasicInfo,
										sizeof(FBasicInfo),
										FileBasicInformation);
	}

	if (!NT_SUCCESS((NTSTATUS)Status))
	{
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoRestoreTimeStamp: NtQueryInformationFile returned 0x%lx\n",Status));
		return AFP_ERR_MISC;	// What else can we do
	}

    //
	// Set times to Zero for the ones we don't want to restore, so that those don't change
	//
	FBasicInfo.CreationTime = LIZero;
	FBasicInfo.LastAccessTime = LIZero;

    FBasicInfo.LastWriteTime = *pOriginalModTime;
	FBasicInfo.ChangeTime = *pOriginalModTime;

	// see AfpIoSetTimesnAttr()
	if (!(FBasicInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		FBasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
	}

	Status = NtSetInformationFile(pFileHandle->fsh_FileHandle,
								  &IoStsBlk,
								  (PVOID)&FBasicInfo,
								  sizeof(FBasicInfo),
								  FileBasicInformation);

	if (!NT_SUCCESS(Status))
	{
		return AFP_ERR_MISC;
	}

	return AFP_ERR_NONE;

}

/***	AfpIoQueryLongName
 *
 *	Get the long name associated with a file. Caller makes sure that
 *	the buffer is big enough to handle the long name.  The only caller of this
 *	should be the AfpFindEntryByName routine when looking up a name by
 *	SHORTNAME.  If it dosn't find it in the database by shortname (i.e.
 *	shortname == longname), then it queries for the longname so it can look
 *	in the database by longname (since all database entries are stored with
 *	longname only).
 *	The Admin Get/SetDirectoryInfo calls may also call this if they find a
 *	~ in a path component, then it will assume that it got a shortname.
 */
NTSTATUS
AfpIoQueryLongName(
	IN	PFILESYSHANDLE		pFileHandle,
	IN	PUNICODE_STRING		pShortname,
	OUT	PUNICODE_STRING		pLongName
)
{
        LONGLONG   Infobuf[(sizeof(FILE_BOTH_DIR_INFORMATION) + MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	UNICODE_STRING			uName;
	PFILE_BOTH_DIR_INFORMATION	pFBDInfo = (PFILE_BOTH_DIR_INFORMATION)Infobuf;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	Status = NtQueryDirectoryFile(pFileHandle->fsh_FileHandle,
							  NULL,NULL,NULL,
							  &IoStsBlk,
							  Infobuf,
							  sizeof(Infobuf),
							  FileBothDirectoryInformation,
							  True,
							  pShortname,
							  False);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
								("NtQueryDirectoryFile returned 0x%lx\n",Status) );
	// Do not errorlog if an error occurs (usually STATUS_NO_SUCH_FILE) because
	// this normally happens when someone is creating a file/dir by SHORTNAME
	// and it does not yet exist.  This would not be an error.
	if (NT_SUCCESS(Status))
	{
			uName.Length =
			uName.MaximumLength = (USHORT)pFBDInfo->FileNameLength;
			uName.Buffer = pFBDInfo->FileName;
		//if (pFBDInfo->FileNameLength/sizeof(WCHAR) > AFP_FILENAME_LEN)
		if ((RtlUnicodeStringToAnsiSize(&uName)-1) > AFP_FILENAME_LEN)
		{
			// NTFS name is longer than 31 chars, use the shortname
			uName.Length =
			uName.MaximumLength = (USHORT)pFBDInfo->ShortNameLength;
			uName.Buffer = pFBDInfo->ShortName;
		}
		else
		{
			uName.Length =
			uName.MaximumLength = (USHORT)pFBDInfo->FileNameLength;
			uName.Buffer = pFBDInfo->FileName;
		}
		AfpCopyUnicodeString(pLongName, &uName);
		ASSERT(pLongName->Length == uName.Length);
	}
	return Status;
}


/***	AfpIoQueryShortName
 *
 *	Get the short name associated with a file. Caller makes sure that
 *	the buffer is big enough to handle the short name.
 */
AFPSTATUS FASTCALL
AfpIoQueryShortName(
	IN	PFILESYSHANDLE		pFileHandle,
	OUT	PANSI_STRING		pName
)
{
	LONGLONG       ShortNameBuf[(sizeof(FILE_NAME_INFORMATION) + AFP_SHORTNAME_LEN * sizeof(WCHAR))/sizeof(LONGLONG) + 1];
	NTSTATUS				Status;
	IO_STATUS_BLOCK			IoStsBlk;
	UNICODE_STRING			uName;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	// Query for the alternate name
	Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
				&IoStsBlk, ShortNameBuf, sizeof(ShortNameBuf),
				FileAlternateNameInformation);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_ERROR(AFPSRVMSG_CANT_GET_FILENAME,
					 Status,
					 NULL,
					 0,
					 NULL);
		Status = AFP_ERR_MISC;	// What else can we do
	}
	else
	{
		uName.Length =
		uName.MaximumLength = (USHORT)(((PFILE_NAME_INFORMATION)ShortNameBuf)->FileNameLength);
		uName.Buffer = ((PFILE_NAME_INFORMATION)ShortNameBuf)->FileName;

		if (!NT_SUCCESS(AfpConvertMungedUnicodeToAnsi(&uName, pName)))
			Status = AFP_ERR_MISC;	// What else can we do
	}

	return Status;
}


/***	AfpIoQueryStreams
 *
 *	Get the names of all the streams that a file has. Memory is allocated out
 *	of non-paged pool to hold the stream names. These have to be freed by the
 *	caller.
 */
PSTREAM_INFO FASTCALL
AfpIoQueryStreams(
	IN	PFILESYSHANDLE		pFileHandle

)
{
	PFILE_STREAM_INFORMATION	pStreamBuf;
	PBYTE						pBuffer;
	NTSTATUS					Status = STATUS_SUCCESS;
	IO_STATUS_BLOCK				IoStsBlk;
	DWORD						BufferSize;
	LONGLONG					Buffer[512/sizeof(LONGLONG) + 1];
	PSTREAM_INFO				pStreams = NULL;

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	pBuffer = (PBYTE)Buffer;
	BufferSize = sizeof(Buffer);
	do
	{
		if (Status != STATUS_SUCCESS)
		{
			if (pBuffer != (PBYTE)Buffer)
				AfpFreeMemory(pBuffer);

			BufferSize *= 2;
			if ((pBuffer = AfpAllocNonPagedMemory(BufferSize)) == NULL)
			{
				Status = STATUS_NO_MEMORY;
				break;
			}
		}

		// Query for the stream information
		Status = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
										&IoStsBlk,
										pBuffer,
										BufferSize,
										FileStreamInformation);

	} while ((Status != STATUS_SUCCESS) &&
			 ((Status == STATUS_BUFFER_OVERFLOW) ||
			  (Status == STATUS_MORE_ENTRIES)));

	if (NT_SUCCESS(Status)) do
	{
		USHORT	i, NumStreams = 1;
		USHORT	TotalBufferSize = 0;
		PBYTE	NamePtr;

		// Make a pass thru the buffer and figure out the # of streams and then
		// allocate memory to hold the information
		pStreamBuf = (PFILE_STREAM_INFORMATION)pBuffer;
		if (IoStsBlk.Information != 0)
		{
			pStreamBuf = (PFILE_STREAM_INFORMATION)pBuffer;
			for (NumStreams = 1,
				 TotalBufferSize = (USHORT)(pStreamBuf->StreamNameLength + sizeof(WCHAR));
				 NOTHING; NumStreams++)
			{
				if (pStreamBuf->NextEntryOffset == 0)
					break;

				pStreamBuf = (PFILE_STREAM_INFORMATION)((PBYTE)pStreamBuf +
												pStreamBuf->NextEntryOffset);
				TotalBufferSize += (USHORT)(pStreamBuf->StreamNameLength + sizeof(WCHAR));
			}
			NumStreams ++;
		}

		// Now allocate space for the streams
		if ((pStreams = (PSTREAM_INFO)AfpAllocNonPagedMemory(TotalBufferSize +
									(NumStreams * sizeof(STREAM_INFO)))) == NULL)
		{
			Status = AFP_ERR_MISC;
			break;
		}

		// The end is marked by an empty string
		pStreams[NumStreams-1].si_StreamName.Buffer = NULL;
		pStreams[NumStreams-1].si_StreamName.Length =
		pStreams[NumStreams-1].si_StreamName.MaximumLength = 0;
		pStreams[NumStreams-1].si_StreamSize.QuadPart = 0;

		// Now initialize the array
		NamePtr = (PBYTE)pStreams + (NumStreams * sizeof(STREAM_INFO));
		pStreamBuf = (PFILE_STREAM_INFORMATION)pBuffer;
		for (i = 0; NumStreams-1 != 0; i++)
		{
			PUNICODE_STRING	pStream;

			pStream = &pStreams[i].si_StreamName;

			pStream->Buffer = (LPWSTR)NamePtr;
			pStream->Length = (USHORT)(pStreamBuf->StreamNameLength);
			pStream->MaximumLength = pStream->Length + sizeof(WCHAR);
			pStreams[i].si_StreamSize = pStreamBuf->StreamSize;
			RtlCopyMemory(NamePtr,
						  pStreamBuf->StreamName,
						  pStreamBuf->StreamNameLength);

			NamePtr += pStream->MaximumLength;

			if (pStreamBuf->NextEntryOffset == 0)
				break;

			pStreamBuf = (PFILE_STREAM_INFORMATION)((PBYTE)pStreamBuf +
												pStreamBuf->NextEntryOffset);
		}
	} while (False);

	if (!NT_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
				("AfpIoQueryStreams: Failed %lx\n", Status));

		// Free up any memory that has been allocated
		if (pStreams != NULL)
			AfpFreeMemory(pStreams);

		// We get the following error for non-NTFS volumes, if this case simply assume it to be
		// CDFS and return the data stream.
		if (Status == STATUS_INVALID_PARAMETER)
		{
			if ((pStreams = (PSTREAM_INFO)AfpAllocNonPagedMemory((2*sizeof(STREAM_INFO)) +
														DataStreamName.MaximumLength)) != NULL)
			{
				pStreams[0].si_StreamName.Buffer = (PWCHAR)((PBYTE)pStreams + 2*sizeof(STREAM_INFO));
				pStreams[0].si_StreamName.Length = DataStreamName.Length;
				pStreams[0].si_StreamName.MaximumLength = DataStreamName.MaximumLength;
				RtlCopyMemory(pStreams[0].si_StreamName.Buffer,
							  DataStreamName.Buffer,
							  DataStreamName.MaximumLength);
				AfpIoQuerySize(pFileHandle, &pStreams[0].si_StreamSize);
				pStreams[1].si_StreamName.Length =
				pStreams[1].si_StreamName.MaximumLength = 0;
				pStreams[1].si_StreamName.Buffer = NULL;
			}
		}
		else
		{
			AFPLOG_HERROR(AFPSRVMSG_CANT_GET_STREAMS,
						  Status,
						  NULL,
						  0,
						  pFileHandle->fsh_FileHandle);
		}
	}

	if ((pBuffer != NULL) && (pBuffer != (PBYTE)Buffer))
		AfpFreeMemory(pBuffer);

	return pStreams;
}


/***	AfpIoMarkFileForDelete
 *
 *	Mark an open file as deleted.  Returns NTSTATUS, not AFPSTATUS.
 */
NTSTATUS
AfpIoMarkFileForDelete(
	IN	PFILESYSHANDLE	pFileHandle,
	IN	PVOLDESC		pVolDesc			OPTIONAL, // only if pNotifyPath
	IN	PUNICODE_STRING pNotifyPath 		OPTIONAL,
	IN	PUNICODE_STRING pNotifyParentPath 	OPTIONAL
)
{
	NTSTATUS						rc;
	IO_STATUS_BLOCK					IoStsBlk;
	FILE_DISPOSITION_INFORMATION	fdispinfo;
#ifdef	PROFILING
	TIME							TimeS, TimeE, TimeD;

	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE( );

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	fdispinfo.DeleteFile = True;
	rc = NtSetInformationFile(pFileHandle->fsh_FileHandle,
							  &IoStsBlk,
							  &fdispinfo,
							  sizeof(fdispinfo),
							  FileDispositionInformation);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoMarkFileForDelete: NtSetInfoFile returned 0x%lx\n",rc) );

	if (ARGUMENT_PRESENT(pNotifyPath) &&
		!EXCLUSIVE_VOLUME(pVolDesc))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));
		// Do not queue for exclusive volumes
		if (NT_SUCCESS(rc))
		{
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_REMOVED,
							  pNotifyPath,
							  pNotifyParentPath);
		}
	}

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_DeleteCount);
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_DeleteTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return rc;
}

/***	AfpIoQueryDirectoryFile
 *
 *	Enumerate a directory.
 *	Note this must return NTSTATUS in order for the caller to know when to
 *	stop enumerating.
 */
NTSTATUS
AfpIoQueryDirectoryFile(
	IN	PFILESYSHANDLE	pFileHandle,
	OUT	PVOID			Enumbuf,	// type depends on FileInfoClass
	IN	ULONG			Enumbuflen,
	IN	ULONG			FileInfoClass,
	IN	BOOLEAN			ReturnSingleEntry,
	IN	BOOLEAN			RestartScan,
	IN	PUNICODE_STRING pString			OPTIONAL
)
{
	NTSTATUS		rc;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQueryDirectoryFile entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	rc = NtQueryDirectoryFile(pFileHandle->fsh_FileHandle,
							  NULL,
							  NULL,
							  NULL,
							  &IoStsBlk,
							  Enumbuf,
							  Enumbuflen,
							  FileInfoClass,
							  ReturnSingleEntry,
							  pString,
							  RestartScan);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("NtQueryDirectoryFile returned 0x%lx\n",rc) );

	return rc;
}


/***	AfpIoQueryBasicInfo
 *
 *	Query FILE_BASIC_INFO for a handle.
 */
NTSTATUS
AfpIoQueryBasicInfo(
	IN	PFILESYSHANDLE	pFileHandle,
	OUT	PVOID			BasicInfobuf
)
{
	NTSTATUS		rc;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQueryBasicInfo entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	rc = NtQueryInformationFile(pFileHandle->fsh_FileHandle,
								&IoStsBlk,
								BasicInfobuf,
								sizeof(FILE_BASIC_INFORMATION),
								FileBasicInformation);
	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQuerybasicInfo: NtQueryInformationFile returned 0x%lx\n",rc) );

	return rc;
}


/***	AfpIoClose
 *
 *	Close the File/Fork/Directory.
 */
AFPSTATUS FASTCALL
AfpIoClose(
	IN	PFILESYSHANDLE		pFileHandle
)
{
	NTSTATUS		Status;
	BOOLEAN			Internal;
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	INTERLOCKED_INCREMENT_LONG(&AfpServerProfile->perf_CloseCount);
	AfpGetPerfCounter(&TimeS);
#endif

	PAGED_CODE ();

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoClose entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	Internal = INTERNAL_HANDLE(pFileHandle);
	afpUpdateOpenFiles(Internal, False);

	ObDereferenceObject(AfpGetRealFileObject(pFileHandle->fsh_FileObject));

	Status = NtClose(pFileHandle->fsh_FileHandle);
	pFileHandle->fsh_FileHandle = NULL;

	ASSERT(NT_SUCCESS(Status));

#ifdef	PROFILING
	AfpGetPerfCounter(&TimeE);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AfpServerProfile->perf_CloseTime,
								 TimeD,
								 &AfpStatisticsLock);
#endif
	return AFP_ERR_NONE;
}


/***	AfpIoQueryVolumeSize
 *
 *	Get the volume size and free space.
 *
 *	Called by Admin thread and Scavenger thread
 */
AFPSTATUS
AfpIoQueryVolumeSize(
	IN	PVOLDESC		pVolDesc,
	OUT LARGE_INTEGER  *pFreeBytes,
	OUT	LARGE_INTEGER  *pVolumeSize OPTIONAL
)
{
	FILE_FS_SIZE_INFORMATION	fssizeinfo;
	IO_STATUS_BLOCK				IoStsBlk;
	NTSTATUS					rc;
	LONG						BytesPerAllocationUnit;
	LARGE_INTEGER				FreeBytes, VolumeSize;


	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoQueryVolumeSize entered\n"));

	ASSERT(VALID_VOLDESC(pVolDesc) && VALID_FSH(&pVolDesc->vds_hRootDir) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	rc = NtQueryVolumeInformationFile(pVolDesc->vds_hRootDir.fsh_FileHandle,
									  &IoStsBlk,
									  (PVOID)&fssizeinfo,
									  sizeof(fssizeinfo),
									  FileFsSizeInformation);

	if (!NT_SUCCESS(rc))
	{
	        DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoQueryVolumeSize: NtQueryVolInfoFile returned 0x%lx\n",rc));

		return rc;
	}

	BytesPerAllocationUnit =
		(LONG)(fssizeinfo.BytesPerSector * fssizeinfo.SectorsPerAllocationUnit);

	if (ARGUMENT_PRESENT(pVolumeSize))
	{
		VolumeSize = RtlExtendedIntegerMultiply(fssizeinfo.TotalAllocationUnits,
								BytesPerAllocationUnit);

		*pVolumeSize = VolumeSize;
	}

	FreeBytes  = RtlExtendedIntegerMultiply(fssizeinfo.AvailableAllocationUnits,
											BytesPerAllocationUnit);

	*pFreeBytes = FreeBytes;

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
				("AfpIoQueryVolumeSize: volume size=%lu, freebytes=%lu\n",
				VolumeSize.LowPart, FreeBytes.LowPart));

    pVolDesc->vds_AllocationBlockSize = BytesPerAllocationUnit;

	return STATUS_SUCCESS;
}


/***	AfpIoMoveAndOrRename
 *
 *	Calls NtSetInformationFile with name information in order to rename, move,
 *	or move AND rename a file or directory.  pNewName must be a node name.
 *	The pfshNewDir parameter is required for a Move operation, and is
 *	an open handle to the target parent directory of the item to be moved.
 *
 *	Retain the last change/modified time in this case.
 */
AFPSTATUS
AfpIoMoveAndOrRename(
	IN PFILESYSHANDLE	pfshFile,
	IN PFILESYSHANDLE	pfshNewParent		OPTIONAL,	// Supply for Move operation
	IN PUNICODE_STRING	pNewName,
	IN PVOLDESC			pVolDesc			OPTIONAL,	// only if NotifyPath
	IN PUNICODE_STRING	pNotifyPath1		OPTIONAL,	// REMOVE or RENAME action
	IN PUNICODE_STRING	pNotifyParentPath1	OPTIONAL,
	IN PUNICODE_STRING	pNotifyPath2		OPTIONAL,	// ADDED action
	IN PUNICODE_STRING	pNotifyParentPath2	OPTIONAL
)
{
	NTSTATUS					Status;
	IO_STATUS_BLOCK				iosb;
	BOOLEAN						Queue = False;
	PFILE_RENAME_INFORMATION	pFRenameInfo;
	// this has to be at least as big as AfpExchangeName
	BYTE buffer[sizeof(FILE_RENAME_INFORMATION) + 42 * sizeof(WCHAR)];

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoMoveAndOrRename entered\n"));

	ASSERT(VALID_FSH(pfshFile) && (KeGetCurrentIrql() < DISPATCH_LEVEL));
	pFRenameInfo = (PFILE_RENAME_INFORMATION)buffer;

	pFRenameInfo->RootDirectory = NULL;
	if (ARGUMENT_PRESENT(pfshNewParent))
	{
		// its a move operation
		ASSERT(VALID_FSH(pfshNewParent));
		pFRenameInfo->RootDirectory = pfshNewParent->fsh_FileHandle;
	}

	pFRenameInfo->FileNameLength = pNewName->Length;
	RtlCopyMemory(pFRenameInfo->FileName, pNewName->Buffer, pNewName->Length);
	pFRenameInfo->ReplaceIfExists = False;

	// Do not queue for exclusive volumes
	if (ARGUMENT_PRESENT(pNotifyPath1) &&
		!EXCLUSIVE_VOLUME(pVolDesc))
	{
		ASSERT(VALID_VOLDESC(pVolDesc));

		Queue = True;
		if (ARGUMENT_PRESENT(pNotifyPath2))
		{
			// move operation
			ASSERT(ARGUMENT_PRESENT(pfshNewParent));
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_REMOVED,
							  pNotifyPath1,
							  pNotifyParentPath1);
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_ADDED,
							  pNotifyPath2,
							  pNotifyParentPath2);
		}
		else
		{
			// rename operation
			ASSERT(!ARGUMENT_PRESENT(pfshNewParent));
			AfpQueueOurChange(pVolDesc,
							  FILE_ACTION_RENAMED_OLD_NAME,
							  pNotifyPath1,
							  pNotifyParentPath1);
		}
	}

	Status = NtSetInformationFile(pfshFile->fsh_FileHandle,
								  &iosb,
								  pFRenameInfo,
								  sizeof(*pFRenameInfo) + pFRenameInfo->FileNameLength,
								  FileRenameInformation);

    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			("AfpIoMoveAndOrRename: NtSetInfoFile returned 0x%lx\n",Status));
    }

	if (Queue)
	{
		// Undo on failure
		if (!NT_SUCCESS(Status))
		{
			if (ARGUMENT_PRESENT(pNotifyPath2))
			{
				// move operation
				ASSERT(ARGUMENT_PRESENT(pfshNewParent));
				AfpDequeueOurChange(pVolDesc,
									FILE_ACTION_REMOVED,
									pNotifyPath1,
									pNotifyParentPath1);
				AfpDequeueOurChange(pVolDesc,
									FILE_ACTION_ADDED,
									pNotifyPath2,
									pNotifyParentPath2);
			}
			else
			{
				// rename operation
				ASSERT(!ARGUMENT_PRESENT(pfshNewParent));
				AfpDequeueOurChange(pVolDesc,
									FILE_ACTION_RENAMED_OLD_NAME,
									pNotifyPath1,
									pNotifyParentPath1);
			}
		}
	}

	if (!NT_SUCCESS(Status))
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpIoCopyFile1
 *
 *	Copy phSrcFile to phDstDir directory with the name of pNewName.  Returns
 *	the handles to the streams on the newly created file (open with DELETE access.
 *	Caller must close all the handles after copying the data.
 */
AFPSTATUS
AfpIoCopyFile1(
	IN	PFILESYSHANDLE		phSrcFile,
	IN	PFILESYSHANDLE		phDstDir,
	IN	PUNICODE_STRING		pNewName,
	IN	PVOLDESC			pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL,
	OUT	PCOPY_FILE_INFO		pCopyFileInfo
)
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PUNICODE_STRING	pStreamName;
	PSTREAM_INFO	pStreams = NULL, pCurStream;
	DWORD			CreateTime = 0, ModTime = 0;
	FILESYSHANDLE	hDstFile;
	LONG			NumStreams, i;
	IO_STATUS_BLOCK	IoStsBlk;

	PAGED_CODE( );

	ASSERT(VALID_FSH(phDstDir) && VALID_FSH(phSrcFile));

	do
	{
		hDstFile.fsh_FileHandle = NULL;

		// Create (soft) the destination file
		Status = AfpIoCreate(phDstDir,
							 AFP_STREAM_DATA,
							 pNewName,
							 FILEIO_ACCESS_WRITE | FILEIO_ACCESS_DELETE,
							 FILEIO_DENY_NONE,
							 FILEIO_OPEN_FILE,
							 FILEIO_CREATE_SOFT,
							 FILE_ATTRIBUTE_ARCHIVE,
							 True,
							 NULL,
							 &hDstFile,
							 NULL,
							 pVolDesc,
							 pNotifyPath,
							 pNotifyParentPath);

		if (!NT_SUCCESS(Status))
		{
			break;
		}

		// Get a list of all stream names of the source file
		if ((pStreams = AfpIoQueryStreams(phSrcFile)) != NULL)
		{
			for (pCurStream = pStreams, NumStreams = 0;
				 pCurStream->si_StreamName.Buffer != NULL;
				 pCurStream++, NumStreams ++)
				 NOTHING;

			// Allocate an array of handles for storing stream handles as we create them
			if (((pCopyFileInfo->cfi_SrcStreamHandle = (PFILESYSHANDLE)
							AfpAllocNonPagedMemory(sizeof(FILESYSHANDLE)*NumStreams)) == NULL) ||
				((pCopyFileInfo->cfi_DstStreamHandle = (PFILESYSHANDLE)
							AfpAllocNonPagedMemory(sizeof(FILESYSHANDLE)*NumStreams)) == NULL))
			{
				if (pCopyFileInfo->cfi_SrcStreamHandle != NULL)
				{
					AfpFreeMemory(pCopyFileInfo->cfi_SrcStreamHandle);
                    pCopyFileInfo->cfi_SrcStreamHandle = NULL;
				}
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			else
			{
				RtlZeroMemory(pCopyFileInfo->cfi_SrcStreamHandle, sizeof(FILESYSHANDLE)*NumStreams);
				RtlZeroMemory(pCopyFileInfo->cfi_DstStreamHandle, sizeof(FILESYSHANDLE)*NumStreams);
				pCopyFileInfo->cfi_SrcStreamHandle[0] = *phSrcFile;
				pCopyFileInfo->cfi_DstStreamHandle[0] = hDstFile;
				pCopyFileInfo->cfi_NumStreams = 1;
			}
		}
		else
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
		}

		for (pCurStream = pStreams, i = 1;	// Start index
			 NT_SUCCESS(Status) &&
			 ((pStreamName = &pCurStream->si_StreamName)->Buffer != NULL);
			 pCurStream++)
		{
			PFILESYSHANDLE	phdst;

			// For each stream, create it on the destination, open it on src,
			// set the size and lock the range. We already have the data forks
			// open, ignore Afp_AfpInfo streams since we are going to re-create
			// it again soon. Also ignore streams of 0 size.
			if (IS_INFO_STREAM(pStreamName) ||
				(pCurStream->si_StreamSize.QuadPart == 0))
			{
				continue;
			}
			if (!IS_DATA_STREAM(pStreamName))
			{
				Status = AfpIoOpen(	phSrcFile,
									AFP_STREAM_DATA,
									FILEIO_OPEN_FILE,
									pStreamName,
									FILEIO_ACCESS_READ,
									FILEIO_DENY_READ | FILEIO_DENY_WRITE,
									True,
									&pCopyFileInfo->cfi_SrcStreamHandle[i]);
				if (!NT_SUCCESS(Status))
				{
					break;
				}

				Status = AfpIoCreate(&hDstFile,
									 AFP_STREAM_DATA,
									 pStreamName,
									 FILEIO_ACCESS_WRITE,
									 FILEIO_DENY_READ | FILEIO_DENY_WRITE,
									 FILEIO_OPEN_FILE,
									 FILEIO_CREATE_SOFT,
									 0,
									 True,
									 NULL,
									 &pCopyFileInfo->cfi_DstStreamHandle[i],
									 NULL,
									 NULL,
									 NULL,
									 NULL);
				if (!NT_SUCCESS(Status))
				{
					break;
				}
				phdst = &pCopyFileInfo->cfi_DstStreamHandle[i];
				pCopyFileInfo->cfi_NumStreams ++;
				i ++;		// Onto the next stream
			}
			else	// IS_DATA_STREAM(pStreamName)
			{
				phdst = &hDstFile;
			}

			// Set the size of the new stream and lock it down
			Status = AfpIoSetSize(phdst, pCurStream->si_StreamSize.LowPart);
			if (!NT_SUCCESS(Status))
			{
				break;
			}

			NtLockFile(phdst,
					   NULL,
					   NULL,
					   NULL,
					   &IoStsBlk,
					   &LIZero,
					   &pCurStream->si_StreamSize,
					   0,
					   True,
					   True);
		}

		// We failed to create/open a stream
		if (!NT_SUCCESS(Status))
		{
			// Delete the new file we just created. The handle is closed below.
			AfpIoMarkFileForDelete(&hDstFile,
								   pVolDesc,
								   pNotifyPath,
								   pNotifyParentPath);

			// Close all the handles, Free the handle space.
			// DO NOT FREE THE SRC FILE HANDLE IN THE ERROR CASE.
			// The Destination has already been deleted above.
			for (i = 1; i < NumStreams; i++)
			{
				if (pCopyFileInfo->cfi_SrcStreamHandle[i].fsh_FileHandle != NULL)
				{
					AfpIoClose(&pCopyFileInfo->cfi_SrcStreamHandle[i]);
				}
				if (pCopyFileInfo->cfi_DstStreamHandle[i].fsh_FileHandle != NULL)
				{
					AfpIoClose(&pCopyFileInfo->cfi_DstStreamHandle[i]);
				}
			}

			if (pCopyFileInfo->cfi_SrcStreamHandle != NULL)
				AfpFreeMemory(pCopyFileInfo->cfi_SrcStreamHandle);
			if (pCopyFileInfo->cfi_DstStreamHandle)
				AfpFreeMemory(pCopyFileInfo->cfi_DstStreamHandle);

			RtlZeroMemory(pCopyFileInfo, sizeof(COPY_FILE_INFO));
		}
	} while (False);

	if (pStreams != NULL)
		AfpFreeMemory(pStreams);

	if (!NT_SUCCESS(Status) && (hDstFile.fsh_FileHandle != NULL))
	{
		AfpIoClose(&hDstFile);
	}

	if (!NT_SUCCESS(Status))
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpIoCopyFile2
 *
 *	Phase 2 of the copy file. See AfpIoCopyFile1( above.
 *	The physical data is copied here.
 *	The relevant streams have been already created and locked.
 *  Destination file acquires the CreateTime and ModTime of the source file.
 */
AFPSTATUS
AfpIoCopyFile2(
	IN	PCOPY_FILE_INFO		pCopyFileInfo,
	IN	PVOLDESC			pVolDesc			OPTIONAL,	// only if pNotifyPath
	IN	PUNICODE_STRING		pNotifyPath			OPTIONAL,
	IN	PUNICODE_STRING		pNotifyParentPath	OPTIONAL
)
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PBYTE			RWbuf;
	DWORD			CreateTime = 0;
	TIME			ModTime;
	LONG			i;
#define	RWBUFSIZE	1500		// So we can use secondary buffer from IO Pool.

	PAGED_CODE( );

	do
	{
		if ((RWbuf = AfpIOAllocBuffer(RWBUFSIZE)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		for (i = 0; i < pCopyFileInfo->cfi_NumStreams; i++)
		{
			while (NT_SUCCESS(Status))
			{
				LONG	bytesRead;

				bytesRead = 0;

				// Read from src, write to dst
				Status = AfpIoRead(&pCopyFileInfo->cfi_SrcStreamHandle[i],
									NULL,
									RWBUFSIZE,
									&bytesRead,
									RWbuf);
				if (Status == AFP_ERR_EOF)
				{
					Status = STATUS_SUCCESS;
					break;
				}
				else if (NT_SUCCESS(Status))
				{
					Status = AfpIoWrite(&pCopyFileInfo->cfi_DstStreamHandle[i],
										NULL,
										bytesRead,
										RWbuf);
				}
			}
		}

		if (!NT_SUCCESS(Status))
		{
			// We failed to read/write a stream
			// Delete the new file we just created
			AfpIoMarkFileForDelete(&pCopyFileInfo->cfi_DstStreamHandle[0],
								   pVolDesc,
								   pNotifyPath,
								   pNotifyParentPath);
		}
	} while (False);

	if (RWbuf != NULL)
		AfpIOFreeBuffer(RWbuf);

	if (!NT_SUCCESS(Status))
		Status = AfpIoConvertNTStatusToAfpStatus(Status);

	return Status;
}


/***	AfpIoWait
 *
 *	Wait on a single object. This is a wrapper over	KeWaitForSingleObject.
 */
NTSTATUS FASTCALL
AfpIoWait(
	IN	PVOID			pObject,
	IN	PLARGE_INTEGER	pTimeOut	OPTIONAL
)
{
	NTSTATUS	Status;

	PAGED_CODE( );

	Status = KeWaitForSingleObject( pObject,
									UserRequest,
									KernelMode,
									False,
									pTimeOut);
	if (!NT_SUCCESS(Status))
	{
		AFPLOG_DDERROR(AFPSRVMSG_WAIT4SINGLE,
					   Status,
					   NULL,
					   0,
					   NULL);
	}

	return Status;
}


/***	AfpUpgradeHandle
 *
 *	Change a handles type from internal to client.
 */
VOID FASTCALL
AfpUpgradeHandle(
	IN	PFILESYSHANDLE	pFileHandle
)
{
	KIRQL	OldIrql;

	UPGRADE_HANDLE(pFileHandle);
	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);

	AfpServerStatistics.stat_CurrentFilesOpen ++;
	AfpServerStatistics.stat_TotalFilesOpened ++;
	if (AfpServerStatistics.stat_CurrentFilesOpen >
							AfpServerStatistics.stat_MaxFilesOpened)
		AfpServerStatistics.stat_MaxFilesOpened =
							AfpServerStatistics.stat_CurrentFilesOpen;
	AfpServerStatistics.stat_CurrentInternalOpens --;

	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
}


/***	afpUpdateOpenFiles
 *
 *	Update statistics to indicate number of open files.
 */
LOCAL VOID FASTCALL
afpUpdateOpenFiles(
	IN	BOOLEAN	Internal,		// True for internal handles
	IN	BOOLEAN	Open			// True for open, False for close
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AfpStatisticsLock, &OldIrql);
	if (Open)
	{
		if (!Internal)
		{
			AfpServerStatistics.stat_CurrentFilesOpen ++;
			AfpServerStatistics.stat_TotalFilesOpened ++;
			if (AfpServerStatistics.stat_CurrentFilesOpen >
									AfpServerStatistics.stat_MaxFilesOpened)
				AfpServerStatistics.stat_MaxFilesOpened =
									AfpServerStatistics.stat_CurrentFilesOpen;
		}
		else
		{
			AfpServerStatistics.stat_CurrentInternalOpens ++;
			AfpServerStatistics.stat_TotalInternalOpens ++;
			if (AfpServerStatistics.stat_CurrentInternalOpens >
									AfpServerStatistics.stat_MaxInternalOpens)
				AfpServerStatistics.stat_MaxInternalOpens =
									AfpServerStatistics.stat_CurrentInternalOpens;
		}
	}
	else
	{
		if (!Internal)
			 AfpServerStatistics.stat_CurrentFilesOpen --;
		else AfpServerStatistics.stat_CurrentInternalOpens --;
	}
	RELEASE_SPIN_LOCK(&AfpStatisticsLock, OldIrql);
}



/***	AfpIoConvertNTStatusToAfpStatus
 *
 *	Map NT Status code to the closest AFP equivalents. Currently it only handles
 *	error codes from NtOpenFile and NtCreateFile.
 */
AFPSTATUS FASTCALL
AfpIoConvertNTStatusToAfpStatus(
	IN	NTSTATUS	Status
)
{
	AFPSTATUS	RetCode;

	PAGED_CODE( );

	ASSERT (!NT_SUCCESS(Status));

	if ((Status >= AFP_ERR_PWD_NEEDS_CHANGE) &&
		(Status <= AFP_ERR_ACCESS_DENIED))
	{
		// Status is already in mac format
		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
			("AfpIoConvertNTStatusToAfpStatus: Status (%d) already in mac format!!\n", Status));

		return Status;
	}

	switch (Status)
	{
		case STATUS_OBJECT_PATH_INVALID:
		case STATUS_OBJECT_NAME_INVALID:
			RetCode = AFP_ERR_PARAM;
			break;

		case STATUS_OBJECT_PATH_NOT_FOUND:
		case STATUS_OBJECT_NAME_NOT_FOUND:
			RetCode = AFP_ERR_OBJECT_NOT_FOUND;
			break;

		case STATUS_OBJECT_NAME_COLLISION:
		case STATUS_OBJECT_NAME_EXISTS:
			RetCode = AFP_ERR_OBJECT_EXISTS;
			break;

		case STATUS_ACCESS_DENIED:
			RetCode = AFP_ERR_ACCESS_DENIED;
			break;

        case STATUS_QUOTA_EXCEEDED:
        case STATUS_DISK_FULL:
			RetCode = AFP_ERR_DISK_FULL;
			break;

		case STATUS_DIRECTORY_NOT_EMPTY:
			RetCode = AFP_ERR_DIR_NOT_EMPTY;
			break;

		case STATUS_SHARING_VIOLATION:
			RetCode = AFP_ERR_DENY_CONFLICT;
			break;

		default:
			RetCode = AFP_ERR_MISC;
			break;
	}
	return RetCode;
}

/***	AfpQueryPath
 *
 *	Given a file handle, get the full pathname of the file/dir. If the
 *	name is longer than MaximumBuf, then forget it and return an error.
 *	Caller must free the pPath.Buffer.
 */
NTSTATUS
AfpQueryPath(
	IN	HANDLE			FileHandle,
	IN	PUNICODE_STRING	pPath,
	IN	ULONG			MaximumBuf
)
{
	PFILE_NAME_INFORMATION	pNameinfo;
	IO_STATUS_BLOCK			iosb;
	NTSTATUS				Status;

	PAGED_CODE( );

	do
	{
		if ((pNameinfo = (PFILE_NAME_INFORMATION)AfpAllocNonPagedMemory(MaximumBuf)) == NULL)
		{
			Status = STATUS_NO_MEMORY;
			break;
		}

		Status = NtQueryInformationFile(FileHandle,
										&iosb,
										pNameinfo,
										MaximumBuf,
										FileNameInformation);
		if (!NT_SUCCESS(Status))
		{
			AfpFreeMemory(pNameinfo);
			break;
		}

		pPath->Length = pPath->MaximumLength = (USHORT) pNameinfo->FileNameLength;
		// Shift the name to the front of the buffer
		RtlMoveMemory(pNameinfo, &pNameinfo->FileName[0], pNameinfo->FileNameLength);
		pPath->Buffer = (PWCHAR)pNameinfo;
	} while (False);

	return Status;
}

/***	AfpIoIsSupportedDevice
 *
 *	AFP volumes can only be created on local disk or cdrom devices.
 *	(i.e. not network, virtual, etc. devices
 */
BOOLEAN FASTCALL
AfpIoIsSupportedDevice(
	IN	PFILESYSHANDLE	pFileHandle,
	OUT	PDWORD			pFlags
)
{
	IO_STATUS_BLOCK					IoStsBlk;
	FILE_FS_DEVICE_INFORMATION		DevInfo;
	PFILE_FS_ATTRIBUTE_INFORMATION	pFSAttrInfo;
	LONGLONG		        Buffer[(sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + AFP_FSNAME_BUFLEN)/sizeof(LONGLONG) + 1];
	UNICODE_STRING					uFsName;
	NTSTATUS						Status;
	BOOLEAN							RetCode = False;

	PAGED_CODE( );

	DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
			 ("AfpIoIsSupportedDevice entered\n"));

	ASSERT(VALID_FSH(pFileHandle) && (KeGetCurrentIrql() < DISPATCH_LEVEL));

	do
	{
		Status = NtQueryVolumeInformationFile(pFileHandle->fsh_FileHandle,
											  &IoStsBlk,
											  (PVOID)&DevInfo,
											  sizeof(DevInfo),
											  FileFsDeviceInformation);

		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
				("AfpIoIsSupportedDevice: NtQueryVolInfFile returned 0x%lx\n", Status));

		if (!NT_SUCCESS(Status) ||
			((DevInfo.DeviceType != FILE_DEVICE_DISK) &&
			 (DevInfo.DeviceType != FILE_DEVICE_CD_ROM)))
		{
			break;
		}

		// need to check if this is NTFS, CDFS or unsupported FS
		pFSAttrInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)Buffer;

		Status = NtQueryVolumeInformationFile(pFileHandle->fsh_FileHandle,
											  &IoStsBlk,
											  (PVOID)pFSAttrInfo,
											  sizeof(Buffer),
											  FileFsAttributeInformation);

		DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_INFO,
				("AfpIoIsSupportedDevice: NtQueryVolInfFile returned 0x%lx\n", Status));

		if (!NT_SUCCESS(Status))
		{
			break;
		}

        if (pFSAttrInfo->FileSystemAttributes & FILE_VOLUME_QUOTAS)
        {
			*pFlags |= VOLUME_DISKQUOTA_ENABLED;
        }

		// convert returned non-null terminated file system name to counted unicode
		AfpInitUnicodeStringWithNonNullTerm(&uFsName,
										   (USHORT)pFSAttrInfo->FileSystemNameLength,
										   pFSAttrInfo->FileSystemName);
		if (EQUAL_UNICODE_STRING(&afpNTFSName, &uFsName, True))
		{
			// its an NTFS volume
			*pFlags |= VOLUME_NTFS;
			RetCode = True;
		}
		else if (EQUAL_UNICODE_STRING(&afpCDFSName, &uFsName, True))
		{
			// its a CDFS volume
			*pFlags |= AFP_VOLUME_READONLY;
			RetCode = True;
		}
		else if (EQUAL_UNICODE_STRING(&afpAHFSName, &uFsName, True))
		{
			// its a volume on CD with HFS support
			*pFlags |= (AFP_VOLUME_READONLY | VOLUME_CD_HFS);
			RetCode = True;
		}
		else
		{
			// an unsupported file system
			DBGPRINT(DBG_COMP_FILEIO, DBG_LEVEL_ERR,
					("AfpIoIsSupportedDevice: unsupported file system: name=%Z, CDString=%Z\n", &uFsName, &afpCDFSName));
			break;
		}
	} while (False);

	if (!NT_SUCCESS(Status))
	{
		AFPLOG_HERROR(AFPSRVMSG_CANT_GET_FSNAME,
					  Status,
					  NULL,
					  0,
					  pFileHandle->fsh_FileHandle);
	}

	return RetCode;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\errorlog.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	errorlog.h

Abstract:

	This module contains the manifests and macros used for error logging
	in the Afp server.

	!!! This module must be nonpageable.

Author:

	Jameel Hyder (microsoft!jameelh)

Revision History:
	10 Jun 1992		Initial Version

--*/


#ifndef	_ERRORLOG_
#define	_ERRORLOG_

//
//	Debug levels used with DBGPRINT and DBGBRK
//

#define	DBG_LEVEL_INFO			0x0000
#define	DBG_LEVEL_WARN			0x1000
#define	DBG_LEVEL_ERR			0x2000
#define	DBG_LEVEL_FATAL			0x3000

//
//	Component types used with DBGPRINT
//
#define	DBG_COMP_INIT			0x00000001
#define	DBG_COMP_MEMORY			0x00000002
#define	DBG_COMP_FILEIO	   		0x00000004
#define	DBG_COMP_SCVGR 	   		0x00000008
#define	DBG_COMP_LOCKS 	   		0x00000010
#define	DBG_COMP_CHGNOTIFY 		0x00000020
#define	DBG_COMP_SDA   	   		0x00000040
#define	DBG_COMP_FORKS 	   		0x00000080
#define	DBG_COMP_DESKTOP   		0x00000100
#define	DBG_COMP_VOLUME	   		0x00000200
#define	DBG_COMP_AFPINFO		0x00000400
#define	DBG_COMP_IDINDEX		0x00000800
#define	DBG_COMP_STACKIF		0x00001000
#define	DBG_COMP_SECURITY		0x00002000

#define	DBG_COMP_ADMINAPI		0x00004000
#define	DBG_COMP_ADMINAPI_SC	0x00008000
#define	DBG_COMP_ADMINAPI_STAT	0x00010000
#define	DBG_COMP_ADMINAPI_SRV	0x00020000
#define	DBG_COMP_ADMINAPI_VOL	0x00040000
#define	DBG_COMP_ADMINAPI_SESS	0x00080000
#define	DBG_COMP_ADMINAPI_CONN	0x00100000
#define	DBG_COMP_ADMINAPI_FORK	0x00200000
#define	DBG_COMP_ADMINAPI_DIR	0x00400000
#define	DBG_COMP_ADMINAPI_ALL	0x007FC000

#define	DBG_COMP_AFPAPI			0x00800000
#define	DBG_COMP_AFPAPI_DTP		0x01000000
#define	DBG_COMP_AFPAPI_FORK	0x02000000
#define	DBG_COMP_AFPAPI_FILE	0x04000000
#define	DBG_COMP_AFPAPI_DIR		0x08000000
#define	DBG_COMP_AFPAPI_FD		0x10000000
#define	DBG_COMP_AFPAPI_VOL		0x20000000
#define	DBG_COMP_AFPAPI_SRV		0x40000000
#define	DBG_COMP_AFPAPI_ALL		0x7F800000

#define	DBG_COMP_NOHEADER		0x80000000

#define	DBG_COMP_ALL			0x7FFFFFFF


// Change this to level of debugging desired. This can also be changed on the
// fly via the kernel debugger

#if DBG

GLOBAL	LONG		AfpDebugLevel EQU DBG_LEVEL_ERR;
GLOBAL	LONG		AfpDebugComponent EQU DBG_COMP_ALL;
GLOBAL  LONG        AfpDebugRefcount  EQU 0;

#define	DBGPRINT(Component, Level, Fmt)	\
		if ((Level >= AfpDebugLevel) && (AfpDebugComponent & Component)) \
		{												\
			if (!(Component & DBG_COMP_NOHEADER))		\
				DbgPrint("***AFPSRV*** ");				\
			DbgPrint Fmt;								\
		}

#define	DBGBRK(Level)				\
		if (Level >= AfpDebugLevel)	\
			DbgBreakPoint()

#define DBGREFCOUNT(Fmt)                    \
        if (AfpDebugRefcount)               \
        {                                   \
            DbgPrint("***AFPSRV*** ");      \
            DbgPrint Fmt;                   \
        }

#else
#define	DBGPRINT(Component, Level, Fmt)
#define	DBGBRK(Level)
#define DBGREFCOUNT(Fmt)
#endif


//
// The types of events that can be logged.
// (cut-n-pasted from ntelfapi.h, after the "use ntsrv.h, not ntos.h" changes)
//

#define EVENTLOG_ERROR_TYPE             0x0001
#define EVENTLOG_INFORMATION_TYPE       0x0004

// This method of logging will end up calling the IoWriteErrorlogEntry. It
// should be used in places where for some reason do not want to queue up
// the errorlog to be logged from the usermode service.  It takes ONE insertion
// string max. pInsertionString is a PUNICODE_STRING.  An example of where this
// should be used is in the AllocNonPagedMem routines, because if we were
// to call the AfpLogEvent routine from there, it would again turn around and
// call the alloc mem routine.  Also any routines that are called during
// server initialization/deinitialization should use this logging method since
// the usermode utility worker component is not guaranteed to be up accepting
// error log requests!
#define AFPLOG_DDERROR(ErrMsgNum, NtStatus, RawData, RawDataLen, pInsertionString)	\
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_WARN, ("AFP_ERRORLOG: %s (%d) Status %lx\n",	\
			__FILE__, __LINE__, NtStatus));	\
	AfpWriteErrorLogEntry(ErrMsgNum, FILENUM + __LINE__, NtStatus,			\
						   RawData, RawDataLen,								\
						   pInsertionString)

// This is the most basic method of logging; takes ONE insertion string max.
// pInsertionString is a PUNICODE_STRING.  This will cause the errorlog to
// be sent up to the usermode service to be logged.
#define AFPLOG_ERROR(ErrMsgNum, NtStatus, RawData, RawDataLen, pInsertionString) \
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_WARN, ("AFP_ERRORLOG: %s (%d) Status %lx\n",	\
			__FILE__, __LINE__, NtStatus));	\
	AfpLogEvent(EVENTLOG_ERROR_TYPE, ErrMsgNum, FILENUM + __LINE__, NtStatus,			\
				(PBYTE)RawData, RawDataLen, 0,								\
				(pInsertionString == NULL) ? 0 : ((PUNICODE_STRING)(pInsertionString))->Length, \
				(pInsertionString == NULL) ? NULL : ((PUNICODE_STRING)(pInsertionString))->Buffer);

// This method of errorlogging takes a file handle and extracts the
// corresponding filename to use as the *first* insertion string.
#define AFPLOG_HERROR(ErrMsgNum, NtStatus, RawData, RawDataLen, Handle) \
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR, ("AFP_ERRORLOG: %s (%d) Status %lx\n", \
			__FILE__, __LINE__, NtStatus));	\
	AfpLogEvent(EVENTLOG_ERROR_TYPE, ErrMsgNum, FILENUM + __LINE__, NtStatus, \
				(PBYTE)RawData, RawDataLen, Handle, 0, NULL)

// This is the most basic method of logging; takes ONE insertion string max.
// pInsertionString is a PUNICODE_STRING.  This will cause the eventlog to
// be sent up to the usermode service to be logged.
#define AFPLOG_INFO(ErrMsgNum, NtStatus, RawData, RawDataLen, pInsertionString) \
	DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO, ("AFP_EVENTLOG: %s (%d) Status %lx\n",	\
			__FILE__, __LINE__, NtStatus));	\
	AfpLogEvent(EVENTLOG_INFORMATION_TYPE, ErrMsgNum, FILENUM + __LINE__, NtStatus,			\
				(PBYTE)RawData, RawDataLen, 0,								\
				(pInsertionString == NULL) ? 0 : ((PUNICODE_STRING)(pInsertionString))->Length, \
				(pInsertionString == NULL) ? NULL : ((PUNICODE_STRING)(pInsertionString))->Buffer);


//
// Error levels used with AfpWriteErrorLogEntry
//

#define ERROR_LEVEL_EXPECTED    0
#define ERROR_LEVEL_UNEXPECTED  1
#define ERROR_LEVEL_IMPOSSIBLE  2
#define ERROR_LEVEL_FATAL       3

extern
VOID
AfpWriteErrorLogEntry(
	IN ULONG			EventCode,
	IN LONG				UniqueErrorCode OPTIONAL,
	IN NTSTATUS			NtStatusCode,
	IN PVOID			RawDataBuf OPTIONAL,
	IN LONG				RawDataLen,
	IN PUNICODE_STRING	pInsertionString OPTIONAL
);

// This routine is implemented in secutil.c
extern
VOID
AfpLogEvent(
	IN USHORT		EventType, 			
	IN ULONG		MsgId,
	IN DWORD		File_Line  OPTIONAL,
	IN NTSTATUS		Status 	   OPTIONAL,
	IN PBYTE RawDataBuf OPTIONAL,
	IN LONG			RawDataLen,
	IN HANDLE FileHandle OPTIONAL,
	IN LONG			String1Len,
	IN PWSTR String1    OPTIONAL
);

#endif	// _ERRORLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\afp\server\fdparm.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fdparm.c

Abstract:

	This module contains the routines for handling file parameters.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	_FDPARM_LOCALS
#define	FILENUM	FILE_FDPARM

#include <seposix.h>
#include <afp.h>
#include <fdparm.h>
#include <pathmap.h>
#include <afpinfo.h>
#include <client.h>
#include <access.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfpGetFileDirParmsReplyLength)
#pragma alloc_text( PAGE, AfpPackFileDirParms)
#pragma alloc_text( PAGE, AfpUnpackFileDirParms)
#pragma alloc_text( PAGE, AfpUnpackCatSearchSpecs)
#pragma alloc_text( PAGE, AfpSetFileDirParms)
#pragma alloc_text( PAGE, AfpQuerySecurityIdsAndRights)
#pragma alloc_text( PAGE, AfpConvertNTAttrToAfpAttr)
#pragma alloc_text( PAGE, AfpConvertAfpAttrToNTAttr)
#pragma alloc_text( PAGE, AfpNormalizeAfpAttr)
#pragma alloc_text( PAGE, AfpMapFDBitmapOpenAccess)
#pragma alloc_text( PAGE, AfpCheckForInhibit)
#pragma alloc_text( PAGE, AfpIsCatSearchMatch)
#endif


/***	AfpGetFileDirParmsReplyLength
 *
 *	Compute the size of buffer required to copy the file parameters based
 *	on the bitmap.
 */
USHORT
AfpGetFileDirParmsReplyLength(
	IN	PFILEDIRPARM	pFDParm,
	IN	DWORD			Bitmap
)
{
	LONG	i;
	USHORT	Size = 0;
	static	BYTE	Bitmap2Size[14] =
				{
					sizeof(USHORT),		// Attributes
					sizeof(DWORD),		// Parent DirId
					sizeof(DWORD),		// Create Date
					sizeof(DWORD),		// Mod. Date
					sizeof(DWORD),		// Backup Date
					sizeof(FINDERINFO),
					sizeof(USHORT) + sizeof(BYTE),	// Long Name
					sizeof(USHORT) + sizeof(BYTE),	// Short Name
					sizeof(DWORD),		// DirId/FileNum
					sizeof(DWORD),		// DataForkLength/Offspring Count
					sizeof(DWORD),		// RescForkLength/Owner Id
					sizeof(DWORD),		// Group Id
					sizeof(DWORD),		// Access Rights
					sizeof(PRODOSINFO)	// ProDos Info
				};

	PAGED_CODE( );

	ASSERT ((Bitmap & ~DIR_BITMAP_MASK) == 0);

	if (Bitmap & FD_BITMAP_LONGNAME)
		Size += pFDParm->_fdp_LongName.Length;

	if (Bitmap & FD_BITMAP_SHORTNAME)
		Size += pFDParm->_fdp_ShortName.Length;

	if (IsDir(pFDParm) && (Bitmap & DIR_BITMAP_OFFSPRINGS))
		Size -= sizeof(USHORT);

	for (i = 0; Bitmap; i++)
	{
		if (Bitmap & 1)
			Size += (USHORT)Bitmap2Size[i];
		Bitmap >>= 1;
	}
	return Size;
}



/***	AfpPackFileDirParms
 *
 *	Pack file or directory parameters into the reply buffer in on-the-wire
 *	format.
 */
VOID
AfpPackFileDirParms(
	IN	PFILEDIRPARM	pFDParm,
	IN	DWORD			Bitmap,
	IN	PBYTE			pReplyBuf
)
{
	LONG	Offset = 0;
	LONG	LongNameOff, ShortNameOff;

	PAGED_CODE( );

	if (Bitmap & FD_BITMAP_ATTR)
	{
		PUTSHORT2SHORT(pReplyBuf + Offset, pFDParm->_fdp_Attr);
		Offset += sizeof(USHORT);
	}
	if (Bitmap & FD_BITMAP_PARENT_DIRID)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_ParentId);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_CREATETIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_CreateTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_MODIFIEDTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_ModifiedTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_BACKUPTIME)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_BackupTime);
		Offset += sizeof(DWORD);
	}
	if (Bitmap & FD_BITMAP_FINDERINFO)
	{
		if ((Bitmap & FD_BITMAP_ATTR) && (pFDParm->_fdp_Attr & FD_BITMAP_ATTR_INVISIBLE))
			pFDParm->_fdp_FinderInfo.fd_Attr1 |= FINDER_FLAG_INVISIBLE;

		RtlCopyMemory(pReplyBuf + Offset, (PBYTE)&pFDParm->_fdp_FinderInfo,
													sizeof(FINDERINFO));
		Offset += sizeof(FINDERINFO);
	}

	// Note the offset where the pointers to names will go. We'll have to
	// Fill it up later.
	if (Bitmap & FD_BITMAP_LONGNAME)
	{
		LongNameOff = Offset;
		Offset += sizeof(USHORT);
	}
	if (Bitmap & FD_BITMAP_SHORTNAME)
	{
		ShortNameOff = Offset;
		Offset += sizeof(USHORT);
	}

	// FileNum for files and DirId for Directories are in the same place
	if (Bitmap & FILE_BITMAP_FILENUM)
	{
		PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_AfpId);
		Offset += sizeof(DWORD);
	}

	if (IsDir(pFDParm))
	{
		// Directory parameters
		if (Bitmap & DIR_BITMAP_OFFSPRINGS)
		{
			DWORD	OffSpring;
	
			OffSpring = pFDParm->_fdp_FileCount + pFDParm->_fdp_DirCount;
			PUTDWORD2SHORT(pReplyBuf + Offset, OffSpring);
			Offset += sizeof(USHORT);
		}

		if (Bitmap & DIR_BITMAP_OWNERID)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_OwnerId);
			Offset += sizeof(DWORD);
		}
	
		if (Bitmap & DIR_BITMAP_GROUPID)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_GroupId);
			Offset += sizeof(DWORD);
		}

		if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
		{
			DWORD	AccessInfo;
	
			AccessInfo = (pFDParm->_fdp_OwnerRights << OWNER_RIGHTS_SHIFT) +
						 (pFDParm->_fdp_GroupRights << GROUP_RIGHTS_SHIFT) +
						 (pFDParm->_fdp_WorldRights << WORLD_RIGHTS_SHIFT) +
						 (pFDParm->_fdp_UserRights  << USER_RIGHTS_SHIFT);
	
			PUTDWORD2DWORD(pReplyBuf + Offset, AccessInfo & ~OWNER_BITS_ALL);
			Offset += sizeof(DWORD);
		}
	}
	else
	{
		if (Bitmap & FILE_BITMAP_DATALEN)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_DataForkLen);
			Offset += sizeof(DWORD);
		}

		// Resc Length for files and Owner Id for Directories are in the same place
		if (Bitmap & FILE_BITMAP_RESCLEN)
		{
			PUTDWORD2DWORD(pReplyBuf + Offset, pFDParm->_fdp_RescForkLen);
			Offset += sizeof(DWORD);
		}
	}

	if (Bitmap & FD_BITMAP_PRODOSINFO)
	{
		RtlCopyMemory(pReplyBuf + Offset, (PBYTE)&pFDParm->_fdp_ProDosInfo,
													sizeof(PRODOSINFO));
		Offset += sizeof(PRODOSINFO);
	}
	if (Bitmap & FD_BITMAP_LONGNAME)
	{
		ASSERT(pFDParm->_fdp_LongName.Length <= AFP_LONGNAME_LEN);

		PUTDWORD2SHORT(pReplyBuf + LongNameOff, Offset);
		PUTSHORT2BYTE(pReplyBuf + Offset, pFDParm->_fdp_LongName.Length);
		RtlCopyMemory(pReplyBuf + Offset + sizeof(BYTE),
					  pFDParm->_fdp_LongName.Buffer,
					  pFDParm->_fdp_LongName.Length);

		Offset += pFDParm->_fdp_LongName.Length + sizeof(BYTE);
	}
	if (Bitmap & FD_BITMAP_SHORTNAME)
	{
		ASSERT(pFDParm->_fdp_ShortName.Length <= AFP_SHORTNAME_LEN);

		PUTDWORD2SHORT(pReplyBuf + ShortNameOff, Offset);
		PUTSHORT2BYTE(pReplyBuf + Offset, pFDParm->_fdp_ShortName.Length);
		RtlCopyMemory(pReplyBuf + Offset + sizeof(BYTE),
					  pFDParm->_fdp_ShortName.Buffer,
					  pFDParm->_fdp_ShortName.Length);
		Offset += pFDParm->_fdp_ShortName.Length + sizeof(BYTE);
	}
	if (Offset & 1)
		*(pReplyBuf + Offset) = 0;
}



/***	AfpUnpackFileDirParms
 *
 *	Unpack the information from the on-the-wire format to the FileDirParm
 *	structure. Only the fields that can be set are looked at. The bitmaps
 *	are validated by the caller.
 *
 *	OPTIMIZATION:	The finder is notorious for setting things needlessly.
 *					We figure out if what is being set is same as what it
 *					is currently and if it is just clear that bit.
 */
AFPSTATUS
AfpUnpackFileDirParms(
	IN	PBYTE			pBuffer,
	IN	LONG			Length,
	IN	PDWORD			pBitmap,
	OUT	PFILEDIRPARM	pFDParm
)
{
	DWORD		Bitmap = *pBitmap;
	AFPTIME		ModTime;
	USHORT		Offset = 0;
	BOOLEAN		SetModTime = False;
	AFPSTATUS	Status = AFP_ERR_NONE;

	PAGED_CODE( );

	do
	{
		if ((LONG)AfpGetFileDirParmsReplyLength(pFDParm, *pBitmap) > Length)
		{
			DBGPRINT(DBG_COMP_AFPAPI_FD, DBG_LEVEL_FATAL,
				("UnpackFileDirParms: Buffer not large enough!\n"));
	        DBGBRK(DBG_LEVEL_FATAL);
			Status = AFP_ERR_PARAM;
			break;
		}

		if (Bitmap & FD_BITMAP_ATTR)
		{
			USHORT	OldAttr, NewAttr;
			USHORT	Set;

			GETSHORT2SHORT(&NewAttr, pBuffer+Offset);
			// keep track of if client wants to set bits or clear bits
			Set = (NewAttr & FD_BITMAP_ATTR_SET);
			// take off the 'set' bit to isolate the requested bits
			NewAttr &= ~FD_BITMAP_ATTR_SET;
			// the current effective settings of attributes
			OldAttr = (pFDParm->_fdp_Attr & ~FD_BITMAP_ATTR_SET);

			if ((NewAttr != 0) &&
				(((Set != 0) && ((OldAttr ^ NewAttr) != 0)) ||
				 ((Set == 0) && ((OldAttr & NewAttr) != 0))))
			{
				// becomes the new resultant AFP attributes after setting
				pFDParm->_fdp_EffectiveAttr = (Set != 0) ?
													(pFDParm->_fdp_Attr | NewAttr) :
													(pFDParm->_fdp_Attr & ~NewAttr);

				// changing a directory's inhibit and invisible attributes from
				// their current settings can only be done by the dir owner
				if (IsDir(pFDParm) &&
					((pFDParm->_fdp_EffectiveAttr & DIR_BITMAP_ATTR_CHG_X_OWNER_ONLY) ^
					 (pFDParm->_fdp_Attr & DIR_BITMAP_ATTR_CHG_X_OWNER_ONLY)) &&
					!(pFDParm->_fdp_UserRights & DIR_ACCESS_OWNER))
                {
					Status = AFP_ERR_ACCESS_DENIED;
					break;
				}

				// becomes attribute bits requested to be set/cleared
				pFDParm->_fdp_Attr = (NewAttr | Set);
			}
			else *pBitmap &= ~FD_BITMAP_ATTR;
			Offset += sizeof(USHORT);
		}
		if (Bitmap & FD_BITMAP_CREATETIME)
		{
			AFPTIME	CreateTime;

			GETDWORD2DWORD(&CreateTime, pBuffer+Offset);
			if (CreateTime == pFDParm->_fdp_CreateTime)
				*pBitmap &= ~FD_BITMAP_CREATETIME;
			else pFDParm->_fdp_CreateTime = CreateTime;
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_MODIFIEDTIME)
		{
			GETDWORD2DWORD(&ModTime, pBuffer+Offset);
			if (ModTime == pFDParm->_fdp_ModifiedTime)
			{
				*pBitmap &= ~FD_BITMAP_MODIFIEDTIME;
				SetModTime = True;
			}
			else
			{
				pFDParm->_fdp_ModifiedTime = ModTime;
			}
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_BACKUPTIME)
		{
			AFPTIME	BackupTime;

			GETDWORD2DWORD(&BackupTime, pBuffer+Offset);
			if (BackupTime == pFDParm->_fdp_BackupTime)
				*pBitmap &= ~FD_BITMAP_BACKUPTIME;
			else pFDParm->_fdp_BackupTime = BackupTime;
			Offset += sizeof(DWORD);
		}
		if (Bitmap & FD_BITMAP_FINDERINFO)
		{
			int		i, rlo = -1, rhi = -1;	// Range of bytes that are different
			PBYTE	pSrc, pDst;

			pSrc = pBuffer + Offset;
			pDst = (PBYTE)(&pFDParm->_fdp_FinderInfo);
			for (i = 0; i < sizeof(FINDERINFO); i++)
			{
				if (*pSrc++ != *pDst++)
				{
					if (rlo == -1)
						rlo = i;
					else rhi = i;
				}
			}

			if ((rlo != -1) && (rhi == -1))
				rhi = rlo;

			// Optimization: if nothing has changed, avoid a copy
			if (rlo == -1)
			{
				*pBitmap &= ~FD_BITMAP_FINDERINFO;
			}
			else
			{
				RtlCopyMemory((PBYTE)&pFDParm->_fdp_FinderInfo,
							  pBuffer+Offset,
							  sizeof(FINDERINFO));
			}
			Offset += sizeof(FINDERINFO);
		}

		if (IsDir(pFDParm) &&
			(Bitmap & (DIR_BITMAP_OWNERID |
					   DIR_BITMAP_GROUPID |
					   DIR_BITMAP_ACCESSRIGHTS)))
		{
			if (Bitmap & DIR_BITMAP_OWNERID)
			{
				DWORD	OwnerId;

				GETDWORD2DWORD(&OwnerId, pBuffer+Offset);
				if (pFDParm->_fdp_OwnerId == OwnerId)
					Bitmap &= ~DIR_BITMAP_OWNERID;
				else pFDParm->_fdp_OwnerId = OwnerId;
				Offset += sizeof(DWORD);
			}
			if (Bitmap & DIR_BITMAP_GROUPID)
			{
				DWORD	GroupId;

				GETDWORD2DWORD(&GroupId, pBuffer+Offset);
				if (pFDParm->_fdp_GroupId == GroupId)
					Bitmap &= ~DIR_BITMAP_GROUPID;
				else pFDParm->_fdp_GroupId = GroupId;
				Offset += sizeof(DWORD);
			}
			if (Bitmap & DIR_BITMAP_ACCESSRIGHTS)
			{
				DWORD	AccessInfo;

				GETDWORD2DWORD(&AccessInfo, pBuffer+Offset);

				pFDParm->_fdp_OwnerRights  =
						(BYTE)((AccessInfo >> OWNER_RIGHTS_SHIFT) & DIR_ACCESS_ALL);
				pFDParm->_fdp_GroupRights =
						(BYTE)((AccessInfo >> GROUP_RIGHTS_SHIFT) & DIR_ACCESS_ALL);
				pFDParm->_fdp_WorldRights =
						(BYTE)((AccessInfo >> WORLD_RIGHTS_SHIFT) & DIR_ACCESS_ALL);
				Offset += sizeof(DWORD);
			}
			if (Bitmap & (DIR_BITMAP_OWNERID | DIR_BITMAP_GROUPID))
				Bitmap |= DIR_BITMAP_ACCESSRIGHTS;
		}

		if (Bitmap & FD_BITMAP_PRODOSINFO)
		{
			int		i;
			PBYTE	pSrc, pDst;

			pSrc = pBuffer + Offset;
			pDst = (PBYTE)(&pFDParm->_fdp_ProDosInfo);
			for (i = 0; i < sizeof(PRODOSINFO); i++)
				if (*pSrc++ != *pDst++)
					break;
			if (i == sizeof(PRODOSINFO))
				*pBitmap &= ~FD_BITMAP_PRODOSINFO;
			else RtlCopyMemory((PBYTE)&pFDParm->_fdp_ProDosInfo,
								pBuffer+Offset,
								sizeof(PRODOSINFO));
			// Offset += sizeof(PRODOSINFO);
		}
	} while (False);

	// If anything is being set and modified time was dropped because it was identical
	// to what is already on, set the bitmap so that it is restored after the change.
	if (SetModTime && *pBitmap)
	{
		*pBitmap |= FD_BITMAP_MODIFIEDTIME;
	}

	return Status;
}


/***	AfpSetFileDirParms
 *
 *	This is the worker for AfpGetFileDirParms/AfpSetFileParms/AfpSetDirParms.
 *	This is callable only in the worker's context.
 *
 *  LOCKS: vds_IdDbAccessLock (SWMR, Exclusive);
 */
AFPSTATUS
AfpSetFileDirParms(
	IN  PVOLDESC		pVolDesc,
	IN  PPATHMAPENTITY	pPME,
	IN  DWORD			Bitmap,
	IN	PFILEDIRPARM	pFDParm
)
{
	AFPSTATUS		Status = AFP_ERR_NONE;
	BOOLEAN			CleanupLock = False, SetROAttr = False;
	PDFENTRY		pDfEntry = NULL;

	PAGED_CODE( );

	do
	{
        ASSERT(IS_VOLUME_NTFS(pVolDesc));

		// NOTE: should we take the SWMR while we set permissions?
		if (IsDir(pFDParm))
		{
			if (Bitmap & (DIR_BITMAP_OWNERID |
						  DIR_BITMAP_GROUPID |
						  DIR_BITMAP_ACCESSRIGHTS))
			{

				Status = AfpSetAfpPermissions(pPME->pme_Handle.fsh_FileHandle,
											  Bitmap,
											  pFDParm);
				if (!NT_SUCCESS(Status))
					break;
			}
		}

		if (Bitmap & (FD_BITMAP_FINDERINFO |
					  FD_BITMAP_PRODOSINFO |
					  FD_BITMAP_ATTR |
					  FD_BITMAP_BACKUPTIME |
					  DIR_BITMAP_ACCESSRIGHTS |
					  DIR_BITMAP_OWNERID   |
					  DIR_BITMAP_GROUPID   |
					  FD_BITMAP_CREATETIME |
					  FD_BITMAP_MODIFIEDTIME |
					  FD_BITMAP_ATTR))
		{
			AfpSwmrAcquireExclusive(&pVolDesc->vds_IdDbAccessLock);
			CleanupLock = True;
		}

		if (Bitmap & (FD_BITMAP_FINDERINFO |
					  FD_BITMAP_PRODOSINFO |
					  FD_BITMAP_ATTR |
					  FD_BITMAP_BACKUPTIME |
					  DIR_BITMAP_ACCESSRIGHTS))
		{

			// Will update the cached AfpInfo as well as the stream
			Status = AfpSetAfpInfo(&pPME->pme_Handle,
								   Bitmap,
								   pFDParm,
								   pVolDesc,
								   &pDfEntry);

			if (Status != AFP_ERR_NONE)
				break;
		}

		if (Bitmap & (FD_BITMAP_CREATETIME |
					  FD_BITMAP_MODIFIEDTIME |
					  FD_BITMAP_ATTR |
					  DIR_BITMAP_ACCESSRIGHTS |
					  DIR_BITMAP_OWNERID |
					  DIR_BITMAP_GROUPID))
		{
			DWORD	SetNtAttr = 0, ClrNtAttr = 0;

			// need to update the cached times too.  If we didn't get the
			// pDfEntry back from setting some other AfpInfo, look it up now
			if (pDfEntry == NULL)
			{
				pDfEntry = AfpFindDfEntryById(pVolDesc,
											   pFDParm->_fdp_AfpId,
											   IsDir(pFDParm) ? DFE_DIR : DFE_FILE);
				if (pDfEntry == NULL)
				{
					Status = AFP_ERR_OBJECT_NOT_FOUND;
					break;
				}
			}

			if (Bitmap & FD_BITMAP_ATTR)
			{
				if (pFDParm->_fdp_Attr & FD_BITMAP_ATTR_SET)
					SetNtAttr = AfpConvertAfpAttrToNTAttr(pFDParm->_fdp_Attr);
				else
					ClrNtAttr = AfpConvertAfpAttrToNTAttr(pFDParm->_fdp_Attr);

                if (pFDParm->_fdp_Attr & (FD_BITMAP_ATTR_RENAMEINH |
										  FD_BITMAP_ATTR_DELETEINH))
				{
					SetROAttr = True;
				}

				if ((SetNtAttr == 0) && (ClrNtAttr == 0))
				{
					// Since there is no attribute being set/cleared that
					// corresponds to any NT attribute, we can clear the
					// ATTR bitmap since we've already set the Mac specific
					// stuff in the DFE and Afpinfo.
					Bitmap &= ~FD_BITMAP_ATTR;
				}
			}

			if (Bitmap & (FD_BITMAP_CREATETIME |
						  FD_BITMAP_MODIFIEDTIME |
						  FD_BITMAP_ATTR))
			{
				ASSERT(pPME->pme_FullPath.Buffer != NULL);
				Status = AfpIoSetTimesnAttr(&pPME->pme_Handle,
						((Bitmap & FD_BITMAP_CREATETIME) != 0) ?
									(PAFPTIME)&pFDParm->_fdp_CreateTime : NULL,
						(((Bitmap & FD_BITMAP_MODIFIEDTIME) != 0) || (SetROAttr)) ?
									(PAFPTIME)&pFDParm->_fdp_ModifiedTime : NULL,
						SetNtAttr, ClrNtAttr,
						pVolDesc,
						&pPME->pme_FullPath);
			}


			if (!NT_SUCCESS(Status))
				break;

			if (Bitmap & FD_BITMAP_CREATETIME)
			{
				pDfEntry->dfe_CreateTime =
								(AFPTIME)pFDParm->_fdp_CreateTime;
			}

			if (Bitmap & FD_BITMAP_MODIFIEDTIME)
			{
				AfpConvertTimeFromMacFormat(pFDParm->_fdp_ModifiedTime,
											&pDfEntry->dfe_LastModTime);
			}
			else if (IsDir(pFDParm) &&
					 ((Bitmap & (DIR_BITMAP_OWNERID |
						 	     DIR_BITMAP_GROUPID |
							     DIR_BITMAP_ACCESSRIGHTS)) ||
					   SetROAttr))
			{
				ASSERT(VALID_DFE(pDfEntry));
				// Setting permissions on a dir or changing its RO attribute
				// should update the modified time on the dir (as observed
				// on Appleshare 4.0)
				AfpIoChangeNTModTime(&pPME->pme_Handle,
									 &pDfEntry->dfe_LastModTime);
			}

			if (Bitmap & FD_BITMAP_ATTR)
			{
				if (pFDParm->_fdp_Attr & FD_BITMAP_ATTR_SET)
					 pDfEntry->dfe_NtAttr |= (USHORT)SetNtAttr;
				else pDfEntry->dfe_NtAttr &= ~((USHORT)ClrNtAttr);

			}

		}

		AfpVolumeSetModifiedTime(pVo